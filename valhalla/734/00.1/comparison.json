{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=valhalla\n@@ -7,5 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+error=author,committer,executable,symlink,whitespace\n@@ -21,7 +17,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n@@ -30,6 +19,0 @@\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-JAVADOC_OPTIONS := -use -keywords -notimestamp \\\n+JAVADOC_OPTIONS := -XDignore.symbol.file=true -use -keywords -notimestamp \\\n@@ -109,0 +109,1 @@\n+    -XDenableValueTypes \\\n","filename":"make\/Docs.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+# Valhalla temporarily disabled\n+VALHALLA_TEMP=false\n+\n","filename":"make\/autoconf\/hotspot.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1447,0 +1447,1 @@\n+        args = concat(args, \"--with-version-pre=\" + version_numbers.get(\"DEFAULT_PROMOTED_VERSION_PRE\"));\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=lworld4ea\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2256,0 +2256,1 @@\n+            case \"Preload\":\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,8 @@\n+  ifeq ($$($1_Type), Reference)\n+    $1_ARGS += -KReference\n+  endif\n+\n+  ifeq ($$($1_Type), Value)\n+    $1_ARGS += -KValue\n+  endif\n+\n@@ -58,0 +66,2 @@\n+        else ifeq ($$($1_Type), Value)\n+\t  $$(eval $1_type := Object)\n@@ -265,1 +275,1 @@\n-VARHANDLES_TYPES := Boolean Byte Short Char Int Long Float Double Reference\n+VARHANDLES_TYPES := Boolean Byte Short Char Int Long Float Double Reference Value\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    DISABLED_WARNINGS := processing rawtypes cast serial preview, \\\n+    DISABLED_WARNINGS := processing rawtypes unchecked cast serial preview deprecation, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -765,0 +765,1 @@\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libobjmonusage007 := $(NSK_JVMTI_AGENT_INCLUDES)\n@@ -1471,0 +1472,1 @@\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage007 += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1782,0 +1782,3 @@\n+  } else if (_entry_point == NULL) {\n+    \/\/ See CallLeafNoFPIndirect\n+    return 1 * NativeInstruction::instruction_size;\n@@ -1893,3 +1896,0 @@\n-  \/\/ n.b. frame size includes space for return pc and rfp\n-  const int framesize = C->output()->frame_size_in_bytes();\n-\n@@ -1915,5 +1915,2 @@\n-  int bangsize = C->output()->bang_size_in_bytes();\n-  if (C->output()->need_stack_bang(bangsize))\n-    __ generate_stack_overflow_check(bangsize);\n-\n-  __ build_frame(framesize);\n+  __ verified_entry(C, 0);\n+  __ bind(*_verified_entry);\n@@ -1957,6 +1954,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -2006,1 +1997,1 @@\n-  __ remove_frame(framesize);\n+  __ remove_frame(framesize, C->needs_stack_repair());\n@@ -2023,5 +2014,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {\n-  \/\/ Variable size. Determine dynamically.\n-  return MachNode::size(ra_);\n-}\n-\n@@ -2333,1 +2319,23 @@\n-\/\/=============================================================================\n+\/\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"# MachVEPNode\");\n+  if (!_verified) {\n+    st->print_cr(\"\\t load_class\");\n+  } else {\n+    st->print_cr(\"\\t unpack_inline_arg\");\n+  }\n+}\n+#endif\n+\n+void MachVEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+{\n+  MacroAssembler _masm(&cbuf);\n+\n+  if (!_verified) {\n+    Label skip;\n+    __ cmp_klass(j_rarg0, rscratch2, rscratch1);\n+    __ br(Assembler::EQ, skip);\n+      __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+    __ bind(skip);\n@@ -2335,0 +2343,11 @@\n+  } else {\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    __ b(*_verified_entry);\n+  }\n+}\n+\n+\/\/=============================================================================\n@@ -2356,0 +2375,1 @@\n+  Label skip;\n@@ -2357,0 +2377,1 @@\n+  \/\/ UseCompressedClassPointers logic are inside cmp_klass\n@@ -2358,1 +2379,1 @@\n-  Label skip;\n+\n@@ -2366,5 +2387,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_);\n-}\n-\n@@ -3905,0 +3921,33 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+        uint con = (tf()->range_cc()->cnt() - 1);\n+        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = fast_out(i)->as_Proj();\n+          if (proj->_con == con) {\n+            \/\/ Set IsInit if r0 is non-null (a non-null value is returned buffered or scalarized)\n+            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+            __ cmp(r0, zr);\n+            __ cset(toReg, Assembler::NE);\n+            if (reg->is_stack()) {\n+              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+              __ str(toReg, Address(sp, st_off));\n+            }\n+            break;\n+          }\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ r0 &= (r0 & 1) - 1\n+        __ andr(rscratch1, r0, 0x1);\n+        __ sub(rscratch1, rscratch1, 0x1);\n+        __ andr(r0, r0, rscratch1);\n+      }\n+    }\n@@ -4000,0 +4049,5 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        __ andr(tmp, tmp, ~((int) markWord::inline_type_bit_in_place));\n+      }\n+\n@@ -7784,1 +7838,1 @@\n-    \"mov  $dst, $con\\t# ptr\\n\\t\"\n+    \"mov  $dst, $con\\t# ptr\"\n@@ -8985,0 +9039,15 @@\n+instruct castN2X(iRegLNoSp dst, iRegN src) %{\n+  match(Set dst (CastP2X src));\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"mov $dst, $src\\t# ptr -> long\" %}\n+\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ mov(as_Register($dst$$reg), as_Register($src$$reg));\n+    }\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -15554,1 +15623,1 @@\n-instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)\n+instruct clearArray_reg_reg_immL0(iRegL_R11 cnt, iRegP_R10 base, immL0 zero, Universe dummy, rFlagsReg cr)\n@@ -15556,1 +15625,1 @@\n-  match(Set dummy (ClearArray cnt base));\n+  match(Set dummy (ClearArray (Binary cnt base) zero));\n@@ -15573,0 +15642,16 @@\n+instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, iRegL val, Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->word_copy_only());\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, KILL cr);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ClearArray $cnt, $base, $val\" %}\n+\n+  ins_encode %{\n+    __ fill_words($base$$Register, $cnt$$Register, $val$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -15576,1 +15661,2 @@\n-            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord));\n+            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord)\n+            && !((ClearArrayNode*)n)->word_copy_only());\n@@ -16910,0 +16996,18 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPIndirect(iRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == NULL);\n+\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf nofp indirect $target\" %}\n+\n+  ins_encode %{\n+    __ blr($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -16912,0 +17016,2 @@\n+  predicate(n->as_Call()->entry_point() != NULL);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":137,"deletions":31,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    case T_PRIMITIVE_OBJECT : i = 10; break;\n","filename":"src\/hotspot\/cpu\/aarch64\/abstractInterpreter_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,66 @@\n+\/\/ Implementation of LoadFlattenedArrayStub\n+\n+LoadFlattenedArrayStub::LoadFlattenedArrayStub(LIR_Opr array, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n+  _array = array;\n+  _index = index;\n+  _result = result;\n+  _scratch_reg = FrameMap::r0_oop_opr;\n+  _info = new CodeEmitInfo(info);\n+}\n+\n+void LoadFlattenedArrayStub::emit_code(LIR_Assembler* ce) {\n+  assert(__ rsp_offset() == 0, \"frame size should be fixed\");\n+  __ bind(_entry);\n+  ce->store_parameter(_array->as_register(), 1);\n+  ce->store_parameter(_index->as_register(), 0);\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flattened_array_id)));\n+  ce->add_call_info_here(_info);\n+  ce->verify_oop_map(_info);\n+  if (_result->as_register() != r0) {\n+    __ mov(_result->as_register(), r0);\n+  }\n+  __ b(_continuation);\n+}\n+\n+\n+\/\/ Implementation of StoreFlattenedArrayStub\n+\n+StoreFlattenedArrayStub::StoreFlattenedArrayStub(LIR_Opr array, LIR_Opr index, LIR_Opr value, CodeEmitInfo* info) {\n+  _array = array;\n+  _index = index;\n+  _value = value;\n+  _scratch_reg = FrameMap::r0_oop_opr;\n+  _info = new CodeEmitInfo(info);\n+}\n+\n+\n+void StoreFlattenedArrayStub::emit_code(LIR_Assembler* ce) {\n+  assert(__ rsp_offset() == 0, \"frame size should be fixed\");\n+  __ bind(_entry);\n+  ce->store_parameter(_array->as_register(), 2);\n+  ce->store_parameter(_index->as_register(), 1);\n+  ce->store_parameter(_value->as_register(), 0);\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flattened_array_id)));\n+  ce->add_call_info_here(_info);\n+  ce->verify_oop_map(_info);\n+  __ b(_continuation);\n+}\n+\n+\/\/ Implementation of SubstitutabilityCheckStub\n+SubstitutabilityCheckStub::SubstitutabilityCheckStub(LIR_Opr left, LIR_Opr right, CodeEmitInfo* info) {\n+  _left = left;\n+  _right = right;\n+  _scratch_reg = FrameMap::r0_oop_opr;\n+  _info = new CodeEmitInfo(info);\n+}\n+\n+void SubstitutabilityCheckStub::emit_code(LIR_Assembler* ce) {\n+  assert(__ rsp_offset() == 0, \"frame size should be fixed\");\n+  __ bind(_entry);\n+  ce->store_parameter(_left->as_register(), 1);\n+  ce->store_parameter(_right->as_register(), 0);\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::substitutability_check_id)));\n+  ce->add_call_info_here(_info);\n+  ce->verify_oop_map(_info);\n+  __ b(_continuation);\n+}\n@@ -145,0 +211,1 @@\n+         stub_id == Runtime1::new_instance_no_inline_id       ||\n@@ -151,2 +218,0 @@\n-\n-\n@@ -192,1 +257,2 @@\n-NewObjectArrayStub::NewObjectArrayStub(LIR_Opr klass_reg, LIR_Opr length, LIR_Opr result, CodeEmitInfo* info) {\n+NewObjectArrayStub::NewObjectArrayStub(LIR_Opr klass_reg, LIR_Opr length, LIR_Opr result,\n+                                       CodeEmitInfo* info, bool is_null_free) {\n@@ -197,0 +263,1 @@\n+  _is_null_free = is_null_free;\n@@ -205,1 +272,7 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_object_array_id)));\n+\n+  if (_is_null_free) {\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_flat_array_id)));\n+  } else {\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_object_array_id)));\n+  }\n+\n@@ -213,1 +286,1 @@\n-MonitorEnterStub::MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info)\n+MonitorEnterStub::MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info,  CodeStub* throw_imse_stub, LIR_Opr scratch_reg)\n@@ -217,0 +290,5 @@\n+  _scratch_reg = scratch_reg;\n+  _throw_imse_stub = throw_imse_stub;\n+  if (_throw_imse_stub != NULL) {\n+    assert(_scratch_reg != LIR_OprFact::illegalOpr, \"must be\");\n+  }\n@@ -223,0 +301,10 @@\n+  if (_throw_imse_stub != NULL) {\n+    \/\/ When we come here, _obj_reg has already been checked to be non-null.\n+    __ ldr(rscratch1, Address(_obj_reg->as_register(), oopDesc::mark_offset_in_bytes()));\n+    __ mov(rscratch2, markWord::inline_type_pattern);\n+    __ andr(rscratch1, rscratch1, rscratch2);\n+\n+    __ cmp(rscratch1, rscratch2);\n+    __ br(Assembler::EQ, *_throw_imse_stub->entry());\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":94,"deletions":6,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -454,1 +456,1 @@\n-  __ remove_frame(initial_frame_size_in_bytes());\n+  __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());\n@@ -498,0 +500,12 @@\n+  ciMethod* method = compilation()->method();\n+  if (InlineTypeReturnedAsFields && method->return_type()->is_inlinetype()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n+    if (vk->can_be_returned_as_fields()) {\n+      address unpack_handler = vk->unpack_handler();\n+      assert(unpack_handler != NULL, \"must be\");\n+      __ far_call(RuntimeAddress(unpack_handler));\n+      \/\/ At this point, r0 points to the value object (for interpreter or C1 caller).\n+      \/\/ The fields of the object are copied into registers (for C2 caller).\n+    }\n+  }\n+\n@@ -499,1 +513,1 @@\n-  __ remove_frame(initial_frame_size_in_bytes());\n+  __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());\n@@ -511,0 +525,4 @@\n+int LIR_Assembler::store_inline_type_fields_to_buf(ciInlineKlass* vk) {\n+  return (__ store_inline_type_fields_to_buf(vk, false));\n+}\n+\n@@ -556,0 +574,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -557,3 +576,1 @@\n-        if (patch_code == lir_patch_none) {\n-          jobject2reg(c->as_jobject(), dest->as_register());\n-        } else {\n+        if (patch_code != lir_patch_none) {\n@@ -561,0 +578,2 @@\n+        } else {\n+          jobject2reg(c->as_jobject(), dest->as_register());\n@@ -602,0 +621,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -668,0 +688,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -670,0 +691,2 @@\n+    \/\/ Non-null case is not handled on aarch64 but handled on x86\n+    \/\/ FIXME: do we need to add it here?\n@@ -708,1 +731,1 @@\n-    if (src->type() == T_OBJECT) {\n+    if (src->type() == T_OBJECT || src->type() == T_PRIMITIVE_OBJECT) {\n@@ -808,0 +831,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -937,1 +961,1 @@\n-  if (addr->base()->type() == T_OBJECT) {\n+  if (addr->base()->type() == T_OBJECT || addr->base()->type() == T_PRIMITIVE_OBJECT) {\n@@ -961,0 +985,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1020,0 +1045,14 @@\n+void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {\n+  assert(dst->is_cpu_register(), \"must be\");\n+  assert(dst->type() == src->type(), \"must be\");\n+\n+  if (src->is_cpu_register()) {\n+    reg2reg(src, dst);\n+  } else if (src->is_stack()) {\n+    stack2reg(src, dst, dst->type());\n+  } else if (src->is_constant()) {\n+    const2reg(src, dst, lir_patch_none, NULL);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n@@ -1211,1 +1250,1 @@\n-  if (UseSlowPath ||\n+  if (UseSlowPath || op->type() == T_PRIMITIVE_OBJECT ||\n@@ -1317,0 +1356,1 @@\n+  if (op->need_null_check()) {\n@@ -1335,0 +1375,1 @@\n+  }\n@@ -1523,0 +1564,127 @@\n+void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {\n+  \/\/ We are loading\/storing from\/to an array that *may* be flattened (the\n+  \/\/ declared type is Object[], abstract[], interface[] or VT.ref[]).\n+  \/\/ If this array is flattened, take the slow path.\n+\n+  Register klass = op->tmp()->as_register();\n+  if (UseArrayMarkWordCheck) {\n+    __ test_flattened_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+  } else {\n+    __ load_klass(klass, op->array()->as_register());\n+    __ ldrw(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ tst(klass, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    __ br(Assembler::NE, *op->stub()->entry());\n+  }\n+  if (!op->value()->is_illegal()) {\n+    \/\/ The array is not flattened, but it might be null-free. If we are storing\n+    \/\/ a null into a null-free array, take the slow path (which will throw NPE).\n+    Label skip;\n+    __ cbnz(op->value()->as_register(), skip);\n+    if (UseArrayMarkWordCheck) {\n+      __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+    } else {\n+      __ tst(klass, Klass::_lh_null_free_array_bit_inplace);\n+      __ br(Assembler::NE, *op->stub()->entry());\n+    }\n+    __ bind(skip);\n+  }\n+}\n+\n+void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {\n+  \/\/ We are storing into an array that *may* be null-free (the declared type is\n+  \/\/ Object[], abstract[], interface[] or VT.ref[]).\n+  if (UseArrayMarkWordCheck) {\n+    Label test_mark_word;\n+    Register tmp = op->tmp()->as_register();\n+    __ ldr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n+    __ tst(tmp, markWord::unlocked_value);\n+    __ br(Assembler::NE, test_mark_word);\n+    __ load_prototype_header(tmp, op->array()->as_register());\n+    __ bind(test_mark_word);\n+    __ tst(tmp, markWord::null_free_array_bit_in_place);\n+  } else {\n+    Register klass = op->tmp()->as_register();\n+    __ load_klass(klass, op->array()->as_register());\n+    __ ldr(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ tst(klass, Klass::_lh_null_free_array_bit_inplace);\n+  }\n+}\n+\n+void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {\n+  Label L_oops_equal;\n+  Label L_oops_not_equal;\n+  Label L_end;\n+\n+  Register left  = op->left()->as_register();\n+  Register right = op->right()->as_register();\n+\n+  __ cmp(left, right);\n+  __ br(Assembler::EQ, L_oops_equal);\n+\n+  \/\/ (1) Null check -- if one of the operands is null, the other must not be null (because\n+  \/\/     the two references are not equal), so they are not substitutable,\n+  \/\/     FIXME: do null check only if the operand is nullable\n+  {\n+    __ cbz(left, L_oops_not_equal);\n+    __ cbz(right, L_oops_not_equal);\n+  }\n+\n+  ciKlass* left_klass = op->left_klass();\n+  ciKlass* right_klass = op->right_klass();\n+\n+  \/\/ (2) Inline type check -- if either of the operands is not a inline type,\n+  \/\/     they are not substitutable. We do this only if we are not sure that the\n+  \/\/     operands are inline type\n+  if ((left_klass == NULL || right_klass == NULL) ||\/\/ The klass is still unloaded, or came from a Phi node.\n+      !left_klass->is_inlinetype() || !right_klass->is_inlinetype()) {\n+    Register tmp1  = op->tmp1()->as_register();\n+    __ mov(tmp1, markWord::inline_type_pattern);\n+    __ ldr(rscratch1, Address(left, oopDesc::mark_offset_in_bytes()));\n+    __ andr(tmp1, tmp1, rscratch1);\n+    __ ldr(rscratch1, Address(right, oopDesc::mark_offset_in_bytes()));\n+    __ andr(tmp1, tmp1, rscratch1);\n+    __ cmp(tmp1, (u1)markWord::inline_type_pattern);\n+    __ br(Assembler::NE, L_oops_not_equal);\n+  }\n+\n+  \/\/ (3) Same klass check: if the operands are of different klasses, they are not substitutable.\n+  if (left_klass != NULL && left_klass->is_inlinetype() && left_klass == right_klass) {\n+    \/\/ No need to load klass -- the operands are statically known to be the same inline klass.\n+    __ b(*op->stub()->entry());\n+  } else {\n+    Register left_klass_op = op->left_klass_op()->as_register();\n+    Register right_klass_op = op->right_klass_op()->as_register();\n+\n+    if (UseCompressedClassPointers) {\n+      __ ldrw(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));\n+      __ ldrw(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));\n+      __ cmpw(left_klass_op, right_klass_op);\n+    } else {\n+      __ ldr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));\n+      __ ldr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));\n+      __ cmp(left_klass_op, right_klass_op);\n+    }\n+\n+    __ br(Assembler::EQ, *op->stub()->entry()); \/\/ same klass -> do slow check\n+    \/\/ fall through to L_oops_not_equal\n+  }\n+\n+  __ bind(L_oops_not_equal);\n+  move(op->not_equal_result(), op->result_opr());\n+  __ b(L_end);\n+\n+  __ bind(L_oops_equal);\n+  move(op->equal_result(), op->result_opr());\n+  __ b(L_end);\n+\n+  \/\/ We've returned from the stub. R0 contains 0x0 IFF the two\n+  \/\/ operands are not substitutable. (Don't compare against 0x1 in case the\n+  \/\/ C compiler is naughty)\n+  __ bind(*op->stub()->continuation());\n+  __ cbz(r0, L_oops_not_equal); \/\/ (call_stub() == 0x0) -> not_equal\n+  move(op->equal_result(), op->result_opr()); \/\/ (call_stub() != 0x0) -> equal\n+  \/\/ fall-through\n+  __ bind(L_end);\n+}\n+\n+\n@@ -1964,0 +2132,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -2038,1 +2207,1 @@\n-  add_call_info(code_offset(), op->info());\n+  add_call_info(code_offset(), op->info(), op->maybe_return_as_fields());\n@@ -2049,1 +2218,1 @@\n-  add_call_info(code_offset(), op->info());\n+  add_call_info(code_offset(), op->info(), op->maybe_return_as_fields());\n@@ -2132,0 +2301,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -2168,0 +2338,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -2212,0 +2383,22 @@\n+void LIR_Assembler::arraycopy_inlinetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {\n+  if (null_check) {\n+    __ cbz(obj, *slow_path->entry());\n+  }\n+  if (UseArrayMarkWordCheck) {\n+    if (is_dest) {\n+      __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n+    } else {\n+      __ test_flattened_array_oop(obj, tmp, *slow_path->entry());\n+    }\n+  } else {\n+    __ load_klass(tmp, obj);\n+    __ ldr(tmp, Address(tmp, Klass::layout_helper_offset()));\n+    if (is_dest) {\n+      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains NULLs.\n+      __ tst(tmp, Klass::_lh_null_free_array_bit_inplace);\n+    } else {\n+      __ tst(tmp, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    }\n+    __ br(Assembler::NE, *slow_path->entry());\n+  }\n+}\n@@ -2230,0 +2423,6 @@\n+  if (flags & LIR_OpArrayCopy::always_slow_path) {\n+    __ b(*stub->entry());\n+    __ bind(*stub->continuation());\n+    return;\n+  }\n+\n@@ -2283,0 +2482,9 @@\n+  \/\/ Handle inline type arrays\n+  if (flags & LIR_OpArrayCopy::src_inlinetype_check) {\n+    arraycopy_inlinetype_check(src, tmp, stub, false, (flags & LIR_OpArrayCopy::src_null_check));\n+  }\n+\n+  if (flags & LIR_OpArrayCopy::dst_inlinetype_check) {\n+    arraycopy_inlinetype_check(dst, tmp, stub, true, (flags & LIR_OpArrayCopy::dst_null_check));\n+  }\n+\n@@ -2857,0 +3065,20 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Register obj = op->obj()->as_register();\n+  Register tmp = op->tmp()->as_pointer_register();\n+  bool not_null = op->not_null();\n+  int flag = op->flag();\n+\n+  Label not_inline_type;\n+  if (!not_null) {\n+    __ cbz(obj, not_inline_type);\n+  }\n+\n+  __ test_oop_is_not_inline_type(obj, tmp, not_inline_type);\n+\n+  Address mdo_addr = as_Address(op->mdp()->as_address_ptr(), rscratch2);\n+  __ ldrb(rscratch1, mdo_addr);\n+  __ orr(rscratch1, rscratch1, flag);\n+  __ strb(rscratch1, mdo_addr);\n+\n+  __ bind(not_inline_type);\n+}\n@@ -2997,0 +3225,4 @@\n+void LIR_Assembler::check_orig_pc() {\n+  __ ldr(rscratch2, frame_map()->address_for_orig_pc_addr());\n+  __ cmp(rscratch2, (u1)NULL_WORD);\n+}\n@@ -3144,0 +3376,1 @@\n+  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":243,"deletions":10,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -105,0 +106,6 @@\n+void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr& tmp1, LIR_Opr& tmp2) {\n+  tmp1 = new_register(T_INT);\n+  tmp2 = LIR_OprFact::illegalOpr;\n+}\n+\n+\n@@ -316,0 +323,5 @@\n+  \/\/ Need a scratch register for inline type\n+  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n+  if (EnableValhalla && x->maybe_inlinetype()) {\n+    scratch = new_register(T_INT);\n+  }\n@@ -321,0 +333,6 @@\n+\n+  CodeStub* throw_imse_stub =\n+      x->maybe_inlinetype() ?\n+      new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id, LIR_OprFact::illegalOpr, state_for(x)) :\n+      NULL;\n+\n@@ -324,2 +342,2 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n-                        x->monitor_no(), info_for_exception, info);\n+  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+                        x->monitor_no(), info_for_exception, info, throw_imse_stub);\n@@ -1123,5 +1141,22 @@\n-                       FrameMap::r10_oop_opr,\n-                       FrameMap::r11_oop_opr,\n-                       FrameMap::r4_oop_opr,\n-                       LIR_OprFact::illegalOpr,\n-                       FrameMap::r3_metadata_opr, info);\n+               \/* allow_inline *\/ false,\n+               FrameMap::r10_oop_opr,\n+               FrameMap::r11_oop_opr,\n+               FrameMap::r4_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::r3_metadata_opr, info);\n+  LIR_Opr result = rlock_result(x);\n+  __ move(reg, result);\n+}\n+\n+void LIRGenerator::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n+  \/\/ Mapping to do_NewInstance (same code) but use state_before for reexecution.\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+  x->set_to_object_type();\n+  LIR_Opr reg = result_register_for(x->type());\n+  new_instance(reg, x->klass(), false,\n+               \/* allow_inline *\/ true,\n+               FrameMap::r10_oop_opr,\n+               FrameMap::r11_oop_opr,\n+               FrameMap::r4_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::r3_metadata_opr, info);\n@@ -1130,0 +1165,1 @@\n+\n@@ -1177,2 +1213,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);\n-  ciKlass* obj = (ciKlass*) ciObjArrayKlass::make(x->klass());\n+  ciKlass* obj = (ciKlass*) x->exact_type();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n@@ -1182,0 +1218,1 @@\n+\n@@ -1183,1 +1220,5 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n+  if (x->is_null_free()) {\n+    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_PRIMITIVE_OBJECT, klass_reg, slow_path);\n+  } else {\n+    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n+  }\n@@ -1259,0 +1300,3 @@\n+  if (x->is_null_free()) {\n+    __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));\n+  }\n@@ -1277,0 +1321,2 @@\n+\n+\n@@ -1280,1 +1326,2 @@\n-               x->profiled_method(), x->profiled_bci());\n+               x->profiled_method(), x->profiled_bci(), x->is_null_free());\n+\n@@ -1358,1 +1405,6 @@\n-  __ cmp(lir_cond(cond), left, right);\n+  if (x->substitutability_check()) {\n+    substitutability_check(x, *xin, *yin);\n+  } else {\n+    __ cmp(lir_cond(cond), left, right);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":64,"deletions":12,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -88,0 +90,6 @@\n+\n+  if (EnableValhalla) {\n+    \/\/ Mask always_locked bit such that we go to the slow path if object is an inline type\n+    andr(hdr, hdr, ~markWord::inline_type_bit_in_place);\n+  }\n+\n@@ -166,2 +174,8 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t\n-  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+  if (EnableValhalla) {\n+    \/\/ Need to copy markWord::prototype header for klass\n+    assert_different_registers(obj, klass, len, t1, t2);\n+    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n+  } else {\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+  }\n@@ -247,0 +261,1 @@\n+\n@@ -291,0 +306,16 @@\n+void C1_MacroAssembler::build_frame_helper(int frame_size_in_bytes, int sp_inc, bool needs_stack_repair) {\n+  MacroAssembler::build_frame(frame_size_in_bytes);\n+\n+  if (needs_stack_repair) {\n+    save_stack_increment(sp_inc, frame_size_in_bytes);\n+  }\n+}\n+\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, bool needs_stack_repair, bool has_scalarized_args, Label* verified_inline_entry_label) {\n+  if (has_scalarized_args) {\n+    \/\/ Initialize orig_pc to detect deoptimization during buffering in the entry points\n+    str(zr, Address(sp, sp_offset_for_orig_pc - frame_size_in_bytes));\n+  }\n+  if (!needs_stack_repair && verified_inline_entry_label != NULL) {\n+    bind(*verified_inline_entry_label);\n+  }\n@@ -292,2 +323,0 @@\n-void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {\n-  assert(bang_size_in_bytes >= framesize, \"stack bang size incorrect\");\n@@ -296,0 +325,1 @@\n+  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n@@ -297,1 +327,2 @@\n-  MacroAssembler::build_frame(framesize);\n+\n+  build_frame_helper(frame_size_in_bytes, 0, needs_stack_repair);\n@@ -302,3 +333,5 @@\n-}\n-void C1_MacroAssembler::remove_frame(int framesize) {\n-  MacroAssembler::remove_frame(framesize);\n+  if (needs_stack_repair && verified_inline_entry_label != NULL) {\n+    \/\/ Jump here from the scalarized entry points that require additional stack space\n+    \/\/ for packing scalarized arguments and therefore already created the frame.\n+    bind(*verified_inline_entry_label);\n+  }\n@@ -308,1 +341,0 @@\n-\n@@ -315,0 +347,66 @@\n+  if (C1Breakpoint) brk(1);\n+}\n+\n+int C1_MacroAssembler::scalarized_entry(const CompiledEntrySignature* ces, int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, Label& verified_inline_entry_label, bool is_inline_ro_entry) {\n+  assert(InlineTypePassFieldsAsArgs, \"sanity\");\n+  \/\/ Make sure there is enough stack space for this method's activation.\n+  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n+  generate_stack_overflow_check(bang_size_in_bytes);\n+\n+  GrowableArray<SigEntry>* sig    = &ces->sig();\n+  GrowableArray<SigEntry>* sig_cc = is_inline_ro_entry ? &ces->sig_cc_ro() : &ces->sig_cc();\n+  VMRegPair* regs      = ces->regs();\n+  VMRegPair* regs_cc   = is_inline_ro_entry ? ces->regs_cc_ro() : ces->regs_cc();\n+  int args_on_stack    = ces->args_on_stack();\n+  int args_on_stack_cc = is_inline_ro_entry ? ces->args_on_stack_cc_ro() : ces->args_on_stack_cc();\n+\n+  assert(sig->length() <= sig_cc->length(), \"Zero-sized inline class not allowed!\");\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig_cc->length());\n+  int args_passed = sig->length();\n+  int args_passed_cc = SigEntry::fill_sig_bt(sig_cc, sig_bt);\n+\n+  \/\/ Check if we need to extend the stack for packing\n+  int sp_inc = 0;\n+  if (args_on_stack > args_on_stack_cc) {\n+    sp_inc = extend_stack_for_inline_args(args_on_stack);\n+  }\n+\n+  \/\/ Create a temp frame so we can call into the runtime. It must be properly set up to accommodate GC.\n+  build_frame_helper(frame_size_in_bytes, sp_inc, ces->c1_needs_stack_repair());\n+\n+  \/\/ Initialize orig_pc to detect deoptimization during buffering in below runtime call\n+  str(zr, Address(sp, sp_offset_for_orig_pc));\n+\n+  \/\/ The runtime call might safepoint, make sure nmethod entry barrier is executed\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+\n+  \/\/ FIXME -- call runtime only if we cannot in-line allocate all the incoming inline type args.\n+  mov(r19, (intptr_t) ces->method());\n+  if (is_inline_ro_entry) {\n+    far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id)));\n+  } else {\n+    far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_id)));\n+  }\n+  int rt_call_offset = offset();\n+\n+  \/\/ The runtime call returns the new array in r20 instead of the usual r0\n+  \/\/ because r0 is also j_rarg7 which may be holding a live argument here.\n+  Register val_array = r20;\n+\n+  \/\/ Remove the temp frame\n+  MacroAssembler::remove_frame(frame_size_in_bytes);\n+\n+  shuffle_inline_args(true, is_inline_ro_entry, sig_cc,\n+                      args_passed_cc, args_on_stack_cc, regs_cc, \/\/ from\n+                      args_passed, args_on_stack, regs,          \/\/ to\n+                      sp_inc, val_array);\n+\n+  if (ces->c1_needs_stack_repair()) {\n+    \/\/ Create the real frame. Below jump will then skip over the stack banging and frame\n+    \/\/ setup code in the verified_inline_entry (which has a different real_frame_size).\n+    build_frame_helper(frame_size_in_bytes, sp_inc, true);\n+  }\n+\n+  b(verified_inline_entry_label);\n+  return rt_call_offset;\n@@ -317,0 +415,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":108,"deletions":9,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -644,0 +644,1 @@\n+    case new_instance_no_inline_id:\n@@ -652,0 +653,2 @@\n+        } else if (id == new_instance_no_inline_id) {\n+          __ set_info(\"new_instance_no_inline\", dont_gc_arguments);\n@@ -661,1 +664,6 @@\n-        int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n+        int call_offset;\n+        if (id == new_instance_no_inline_id) {\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance_no_inline), klass);\n+        } else {\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n+        }\n@@ -694,0 +702,1 @@\n+    case new_flat_array_id:\n@@ -701,1 +710,1 @@\n-        } else {\n+        } else if (id == new_object_array_id) {\n@@ -703,0 +712,2 @@\n+        } else {\n+          __ set_info(\"new_flat_array\", dont_gc_arguments);\n@@ -712,7 +723,23 @@\n-          int tag = ((id == new_type_array_id)\n-                     ? Klass::_lh_array_tag_type_value\n-                     : Klass::_lh_array_tag_obj_value);\n-          __ mov(rscratch1, tag);\n-          __ cmpw(t0, rscratch1);\n-          __ br(Assembler::EQ, ok);\n-          __ stop(\"assert(is an array klass)\");\n+          switch (id) {\n+          case new_type_array_id:\n+            __ cmpw(t0, Klass::_lh_array_tag_type_value);\n+            __ br(Assembler::EQ, ok);\n+            __ stop(\"assert(is a type array klass)\");\n+            break;\n+          case new_object_array_id:\n+            __ cmpw(t0, Klass::_lh_array_tag_obj_value); \/\/ new \"[Ljava\/lang\/Object;\"\n+            __ br(Assembler::EQ, ok);\n+            __ cmpw(t0, Klass::_lh_array_tag_vt_value);  \/\/ new \"[LVT;\"\n+            __ br(Assembler::EQ, ok);\n+            __ stop(\"assert(is an object or inline type array klass)\");\n+            break;\n+          case new_flat_array_id:\n+            \/\/ new \"[QVT;\"\n+            __ cmpw(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be flattened.\n+            __ br(Assembler::EQ, ok);\n+            __ cmpw(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)\n+            __ br(Assembler::EQ, ok);\n+            __ stop(\"assert(is an object or inline type array klass)\");\n+            break;\n+          default:  ShouldNotReachHere();\n+          }\n@@ -729,1 +756,1 @@\n-        } else {\n+        } else if (id == new_object_array_id) {\n@@ -731,0 +758,3 @@\n+        } else {\n+          assert(id == new_flat_array_id, \"must be\");\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_flat_array), klass, length);\n@@ -765,0 +795,82 @@\n+    case buffer_inline_args_id:\n+    case buffer_inline_args_no_receiver_id:\n+      {\n+        const char* name = (id == buffer_inline_args_id) ?\n+          \"buffer_inline_args\" : \"buffer_inline_args_no_receiver\";\n+        StubFrame f(sasm, name, dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm);\n+        Register method = r19;   \/\/ Incoming\n+        address entry = (id == buffer_inline_args_id) ?\n+          CAST_FROM_FN_PTR(address, buffer_inline_args) :\n+          CAST_FROM_FN_PTR(address, buffer_inline_args_no_receiver);\n+        \/\/ This is called from a C1 method's scalarized entry point\n+        \/\/ where r0-r7 may be holding live argument values so we can't\n+        \/\/ return the result in r0 as the other stubs do. LR is used as\n+        \/\/ a temporay below to avoid the result being clobbered by\n+        \/\/ restore_live_registers.\n+        int call_offset = __ call_RT(lr, noreg, entry, method);\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers(sasm);\n+        __ mov(r20, lr);\n+        __ verify_oop(r20);  \/\/ r20: an array of buffered value objects\n+     }\n+     break;\n+\n+    case load_flattened_array_id:\n+      {\n+        StubFrame f(sasm, \"load_flattened_array\", dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm);\n+\n+        \/\/ Called with store_parameter and not C abi\n+\n+        f.load_argument(1, r0); \/\/ r0,: array\n+        f.load_argument(0, r1); \/\/ r1,: index\n+        int call_offset = __ call_RT(r0, noreg, CAST_FROM_FN_PTR(address, load_flattened_array), r0, r1);\n+\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_r0(sasm);\n+\n+        \/\/ r0: loaded element at array[index]\n+        __ verify_oop(r0);\n+      }\n+      break;\n+\n+    case store_flattened_array_id:\n+      {\n+        StubFrame f(sasm, \"store_flattened_array\", dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm, 4);\n+\n+        \/\/ Called with store_parameter and not C abi\n+\n+        f.load_argument(2, r0); \/\/ r0: array\n+        f.load_argument(1, r1); \/\/ r1: index\n+        f.load_argument(0, r2); \/\/ r2: value\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flattened_array), r0, r1, r2);\n+\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_r0(sasm);\n+      }\n+      break;\n+\n+    case substitutability_check_id:\n+      {\n+        StubFrame f(sasm, \"substitutability_check\", dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm);\n+\n+        \/\/ Called with store_parameter and not C abi\n+\n+        f.load_argument(1, r1); \/\/ r1,: left\n+        f.load_argument(0, r2); \/\/ r2,: right\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, substitutability_check), r1, r2);\n+\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_r0(sasm);\n+\n+        \/\/ r0,: are the two operands substitutable\n+      }\n+      break;\n+\n@@ -804,1 +916,1 @@\n-      { StubFrame f(sasm, \"throw_incompatible_class_cast_exception\", dont_gc_arguments, does_not_return);\n+      { StubFrame f(sasm, \"throw_incompatible_class_change_error\", dont_gc_arguments, does_not_return);\n@@ -809,0 +921,6 @@\n+    case throw_illegal_monitor_state_exception_id:\n+      { StubFrame f(sasm, \"throw_illegal_monitor_state_exception\", dont_gc_arguments);\n+        oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_illegal_monitor_state_exception), false);\n+      }\n+      break;\n+\n@@ -1012,0 +1130,2 @@\n+      \/\/ FIXME: For unhandled trap_id this code fails with assert during vm intialization\n+      \/\/ rather than insert a call to unimplemented_entry\n@@ -1019,0 +1139,2 @@\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -158,2 +158,2 @@\n-      sender_unextended_sp = sender_sp;\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+      intptr_t **saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n+      saved_fp = *saved_fp_addr;\n@@ -162,1 +162,4 @@\n-    }\n+      \/\/ Repair the sender sp if this is a method with scalarized inline type args\n+      sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);\n+      sender_unextended_sp = sender_sp;\n+    }\n@@ -560,0 +563,1 @@\n+    case T_PRIMITIVE_OBJECT :\n@@ -779,0 +783,16 @@\n+\/\/ Check for a method with scalarized inline type arguments that needs\n+\/\/ a stack repair and return the repaired sender stack pointer.\n+intptr_t* frame::repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const {\n+  CompiledMethod* cm = _cb->as_compiled_method_or_null();\n+  if (cm != NULL && cm->needs_stack_repair()) {\n+    \/\/ The stack increment resides just below the saved FP on the stack and\n+    \/\/ records the total frame size excluding the two words for saving FP and LR.\n+    intptr_t* sp_inc_addr = (intptr_t*) (saved_fp_addr - 1);\n+    assert(*sp_inc_addr % StackAlignmentInBytes == 0, \"sp_inc not aligned\");\n+    int real_frame_size = (*sp_inc_addr \/ wordSize) + 2;\n+    assert(real_frame_size >= _cb->frame_size() && real_frame_size <= 1000000, \"invalid frame size\");\n+    sender_sp = unextended_sp() + real_frame_size;\n+  }\n+  return sender_sp;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -149,0 +149,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  intptr_t* repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -424,0 +427,4 @@\n+#ifdef ASSERT\n+   address sender_pc_copy = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+#endif\n+\n@@ -426,0 +433,5 @@\n+  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp - frame::sender_sp_offset);\n+\n+  \/\/ Repair the sender sp if the frame has been extended\n+  l_sender_sp = repair_sender_sp(l_sender_sp, saved_fp_addr);\n+\n@@ -430,1 +442,9 @@\n-  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp - frame::sender_sp_offset);\n+#ifdef ASSERT\n+  if (sender_pc != sender_pc_copy) {\n+    \/\/ When extending the stack in the callee method entry to make room for unpacking of value\n+    \/\/ type args, we keep a copy of the sender pc at the expected location in the callee frame.\n+    \/\/ If the sender pc is patched due to deoptimization, the copy is not consistent anymore.\n+    nmethod* nm = CodeCache::find_blob(sender_pc)->as_nmethod();\n+    assert(sender_pc == nm->deopt_mh_handler_begin() || sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+  }\n+#endif\n@@ -436,2 +456,14 @@\n-    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n-      map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+    bool c1_buffering = false;\n+#ifdef COMPILER1\n+    nmethod* nm = _cb->as_nmethod_or_null();\n+    if (nm != NULL && nm->is_compiled_by_c1() && nm->method()->has_scalarized_args() &&\n+        pc() < nm->verified_inline_entry_point()) {\n+      \/\/ The VEP and VIEP(RO) of C1-compiled methods call buffer_inline_args_xxx\n+      \/\/ before doing any argument shuffling, so we need to scan the oops\n+      \/\/ as the caller passes them.\n+      c1_buffering = true;\n+    }\n+#endif\n+    if (!_cb->is_compiled() || c1_buffering) { \/\/ compiled frames do not use callee-saved registers\n+      bool caller_args = _cb->caller_must_gc_arguments(map->thread()) || c1_buffering;\n+      map->set_include_argument_oops(caller_args);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -158,1 +158,21 @@\n-  __ push_call_clobbered_registers();\n+  \/\/ save the live input values\n+  RegSet saved = RegSet::of(pre_val);\n+  FloatRegSet fsaved;\n+\n+  \/\/ Barriers might be emitted when converting between (scalarized) calling\n+  \/\/ conventions for inline types. Save all argument registers before calling\n+  \/\/ into the runtime.\n+  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n+    if (tosca_live) saved += RegSet::of(r0);\n+    if (obj != noreg) saved += RegSet::of(obj);\n+    saved += RegSet::of(j_rarg0, j_rarg1, j_rarg2, j_rarg3);\n+    saved += RegSet::of(j_rarg4, j_rarg5, j_rarg6, j_rarg7);\n+\n+    fsaved += FloatRegSet::of(j_farg0, j_farg1, j_farg2, j_farg3);\n+    fsaved += FloatRegSet::of(j_farg4, j_farg5, j_farg6, j_farg7);\n+\n+    __ push(saved, sp);\n+    __ push_fp(fsaved, sp);\n+  } else {\n+    __ push_call_clobbered_registers();\n+  }\n@@ -179,1 +199,6 @@\n-  __ pop_call_clobbered_registers();\n+  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n+  __ pop_fp(fsaved, sp);\n+  __ pop(saved, sp);\n+  } else {\n+    __ pop_call_clobbered_registers();\n+  }\n@@ -192,2 +217,1 @@\n-  assert_different_registers(store_addr, new_val, thread, tmp, tmp2,\n-                             rscratch1);\n+  assert_different_registers(store_addr, new_val, thread, tmp, rscratch1);\n@@ -219,0 +243,2 @@\n+  assert_different_registers(store_addr, thread, tmp, tmp2, rscratch1);\n+\n@@ -252,0 +278,1 @@\n+\n@@ -254,0 +281,13 @@\n+  FloatRegSet fsaved;\n+\n+  \/\/ Barriers might be emitted when converting between (scalarized) calling\n+  \/\/ conventions for inline types. Save all argument registers before calling\n+  \/\/ into the runtime.\n+  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n+    saved += RegSet::of(j_rarg0, j_rarg1, j_rarg2, j_rarg3);\n+    saved += RegSet::of(j_rarg4, j_rarg5, j_rarg6, j_rarg7);\n+\n+    fsaved += FloatRegSet::of(j_farg0, j_farg1, j_farg2, j_farg3);\n+    fsaved += FloatRegSet::of(j_farg4, j_farg5, j_farg6, j_farg7);\n+  }\n+\n@@ -255,0 +295,1 @@\n+  __ push_fp(fsaved, sp);\n@@ -256,0 +297,1 @@\n+  __ pop_fp(fsaved, sp);\n@@ -285,1 +327,14 @@\n-                                         Address dst, Register val, Register tmp1, Register tmp2) {\n+                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  bool as_normal = (decorators & AS_NORMAL) != 0;\n+  bool dest_uninitialized = (decorators & IS_DEST_UNINITIALIZED) != 0;\n+\n+  bool needs_pre_barrier = as_normal && !dest_uninitialized;\n+  bool needs_post_barrier = (val != noreg && in_heap);\n+\n+  if (tmp3 == noreg) {\n+    tmp3 = rscratch2;\n+  }\n+  assert_different_registers(val, tmp1, tmp2, tmp3);\n+\n@@ -288,2 +343,2 @@\n-    if (dst.base() != r3) {\n-      __ mov(r3, dst.base());\n+    if (dst.base() != tmp1) {\n+      __ mov(tmp1, dst.base());\n@@ -292,1 +347,1 @@\n-    __ lea(r3, dst);\n+    __ lea(tmp1, dst);\n@@ -295,7 +350,9 @@\n-  g1_write_barrier_pre(masm,\n-                       r3 \/* obj *\/,\n-                       tmp2 \/* pre_val *\/,\n-                       rthread \/* thread *\/,\n-                       tmp1  \/* tmp *\/,\n-                       val != noreg \/* tosca_live *\/,\n-                       false \/* expand_call *\/);\n+  if (needs_pre_barrier) {\n+    g1_write_barrier_pre(masm,\n+                         tmp1 \/* obj *\/,\n+                         tmp2 \/* pre_val *\/,\n+                         rthread \/* thread *\/,\n+                         tmp3  \/* tmp *\/,\n+                         val != noreg \/* tosca_live *\/,\n+                         false \/* expand_call *\/);\n+  }\n@@ -304,1 +361,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), noreg, noreg, noreg, noreg);\n@@ -308,3 +365,16 @@\n-    if (UseCompressedOops) {\n-      new_val = rscratch2;\n-      __ mov(new_val, val);\n+    if (needs_post_barrier) {\n+      if (UseCompressedOops) {\n+        new_val = tmp3;\n+        __ mov(new_val, val);\n+      }\n+    }\n+\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n+\n+    if (needs_post_barrier) {\n+      g1_write_barrier_post(masm,\n+                            tmp1 \/* store_adr *\/,\n+                            new_val \/* new_val *\/,\n+                            rthread \/* thread *\/,\n+                            tmp2 \/* tmp *\/,\n+                            tmp3 \/* tmp2 *\/);\n@@ -312,7 +382,0 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);\n-    g1_write_barrier_post(masm,\n-                          r3 \/* store_adr *\/,\n-                          new_val \/* new_val *\/,\n-                          rthread \/* thread *\/,\n-                          tmp1 \/* tmp *\/,\n-                          tmp2 \/* tmp2 *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":89,"deletions":26,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/barrierSetRuntime.hpp\"\n@@ -49,0 +50,2 @@\n+\n+  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n@@ -83,1 +86,1 @@\n-                                   Address dst, Register val, Register tmp1, Register tmp2) {\n+                                   Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -86,0 +89,3 @@\n+  bool is_not_null = (decorators & IS_NOT_NULL) != 0;\n+\n+  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n@@ -89,5 +95,6 @@\n-    val = val == noreg ? zr : val;\n-      if (UseCompressedOops) {\n-        assert(!dst.uses(val), \"not enough registers\");\n-        if (val != zr) {\n-          __ encode_heap_oop(val);\n+      if (val == noreg) {\n+        assert(!is_not_null, \"inconsistent access\");\n+        if (UseCompressedOops) {\n+          __ strw(zr, dst);\n+        } else {\n+          __ str(zr, dst);\n@@ -96,2 +103,11 @@\n-        __ strw(val, dst);\n-        __ str(val, dst);\n+        if (UseCompressedOops) {\n+          assert(!dst.uses(val), \"not enough registers\");\n+          if (is_not_null) {\n+            __ encode_heap_oop_not_null(val);\n+          } else {\n+            __ encode_heap_oop(val);\n+          }\n+          __ strw(val, dst);\n+        } else {\n+          __ str(val, dst);\n+        }\n@@ -102,0 +118,1 @@\n+      assert(val != noreg, \"not supported\");\n@@ -122,0 +139,13 @@\n+void BarrierSetAssembler::value_copy(MacroAssembler* masm, DecoratorSet decorators,\n+                                     Register src, Register dst, Register value_klass) {\n+  \/\/ value_copy implementation is fairly complex, and there are not any\n+  \/\/ \"short-cuts\" to be made from asm. What there is, appears to have the same\n+  \/\/ cost in C++, so just \"call_VM_leaf\" for now rather than maintain hundreds\n+  \/\/ of hand-rolled instructions...\n+  if (decorators & IS_DEST_UNINITIALIZED) {\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized), src, dst, value_klass);\n+  } else {\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy), src, dst, value_klass);\n+  }\n+}\n+\n@@ -302,1 +332,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":38,"deletions":9,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -54,1 +54,4 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3 = noreg);\n+\n+  virtual void value_copy(MacroAssembler* masm, DecoratorSet decorators,\n+                          Register src, Register dst, Register value_klass);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-                                             Address dst, Register val, Register tmp1, Register tmp2) {\n+                                             Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -402,1 +402,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg, noreg);\n@@ -411,1 +411,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3 = noreg);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n-                                        Register tmp2) {\n+                                        Register tmp2,\n+                                        Register tmp3) {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-                        Register tmp2);\n+                        Register tmp2,\n+                        Register tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+define_pd_global(bool, InlineTypePassFieldsAsArgs, true);\n+define_pd_global(bool, InlineTypeReturnedAsFields, true);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -272,0 +273,63 @@\n+void InterpreterMacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                                  Register t1, Register t2,\n+                                                  bool clear_fields, Label& alloc_failed) {\n+  MacroAssembler::allocate_instance(klass, new_obj, t1, t2, clear_fields, alloc_failed);\n+  {\n+    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0);\n+    \/\/ Trigger dtrace event for fastpath\n+    push(atos);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), new_obj);\n+    pop(atos);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n+                                                   Register field_index, Register field_offset,\n+                                                   Register temp, Register obj) {\n+  Label alloc_failed, empty_value, done;\n+  const Register src = field_offset;\n+  const Register alloc_temp = rscratch1;\n+  const Register dst_temp   = temp;\n+  assert_different_registers(obj, holder_klass, field_index, field_offset, dst_temp);\n+\n+  \/\/ Grab the inline field klass\n+  push(holder_klass);\n+  const Register field_klass = holder_klass;\n+  get_inline_type_field_klass(holder_klass, field_index, field_klass);\n+\n+  \/\/check for empty value klass\n+  test_klass_is_empty_inline_type(field_klass, dst_temp, empty_value);\n+\n+  \/\/ allocate buffer\n+  push(obj); \/\/ save holder\n+  allocate_instance(field_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n+\n+  \/\/ Have an oop instance buffer, copy into it\n+  data_for_oop(obj, dst_temp, field_klass);\n+  pop(alloc_temp);             \/\/ restore holder\n+  lea(src, Address(alloc_temp, field_offset));\n+  \/\/ call_VM_leaf, clobbers a few regs, save restore new obj\n+  push(obj);\n+  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, field_klass);\n+  pop(obj);\n+  pop(holder_klass);\n+  b(done);\n+\n+  bind(empty_value);\n+  get_empty_inline_type_oop(field_klass, dst_temp, obj);\n+  pop(holder_klass);\n+  b(done);\n+\n+  bind(alloc_failed);\n+  pop(obj);\n+  pop(holder_klass);\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+          obj, field_index, holder_klass);\n+\n+  bind(done);\n+\n+  \/\/ Ensure the stores to copy the inline field contents are visible\n+  \/\/ before any subsequent store that publishes this reference.\n+  membar(Assembler::StoreStore);\n+}\n+\n@@ -318,1 +382,2 @@\n-                                                  Label& ok_is_subtype) {\n+                                                  Label& ok_is_subtype,\n+                                                  bool profile) {\n@@ -324,1 +389,3 @@\n-  profile_typecheck(r2, Rsub_klass, r5); \/\/ blows r2, reloads r5\n+  if (profile) {\n+    profile_typecheck(r2, Rsub_klass, r5); \/\/ blows r2, reloads r5\n+  }\n@@ -330,1 +397,3 @@\n-  profile_typecheck_failed(r2); \/\/ blows r2\n+  if (profile) {\n+    profile_typecheck_failed(r2); \/\/ blows r2\n+  }\n@@ -691,0 +760,1 @@\n+\n@@ -710,0 +780,33 @@\n+\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+    Label skip;\n+    test_oop_is_not_inline_type(r0, rscratch2, skip);\n+\n+    \/\/ Load fields from a buffered value with an inline class specific handler\n+    load_klass(rscratch1 \/*dst*\/, r0 \/*src*\/);\n+    ldr(rscratch1, Address(rscratch1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    ldr(rscratch1, Address(rscratch1, InlineKlass::unpack_handler_offset()));\n+    \/\/ Unpack handler can be null if inline type is not scalarizable in returns\n+    cbz(rscratch1, skip);\n+\n+    blr(rscratch1);\n+#ifdef ASSERT\n+    if (StressInlineTypeReturnedAsFields) {\n+      \/\/ TODO 8284443 Enable this for value class returns (L-type descriptor)\n+      Label skip_stress;\n+      ldr(rscratch1, Address(rfp, frame::interpreter_frame_method_offset * wordSize));\n+      ldr(rscratch1, Address(rscratch1, Method::const_offset()));\n+      ldrb(rscratch1, Address(rscratch1, ConstMethod::result_type_offset()));\n+      cmpw(rscratch1, (u1) T_PRIMITIVE_OBJECT);\n+      br(Assembler::NE, skip_stress);\n+      load_klass(r0, r0);\n+      orr(r0, r0, 1);\n+      bind(skip_stress);\n+    }\n+#endif\n+    bind(skip);\n+    \/\/ Check above kills sender esp in rscratch2. Reload it.\n+    ldr(rscratch2, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+  }\n+\n@@ -764,0 +867,4 @@\n+    if (EnableValhalla) {\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      andr(swap_reg, swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+    }\n@@ -1108,1 +1215,1 @@\n-void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp) {\n+void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp, bool acmp) {\n@@ -1120,1 +1227,1 @@\n-    update_mdp_by_constant(mdp, in_bytes(BranchData::branch_data_size()));\n+    update_mdp_by_constant(mdp, acmp ? in_bytes(ACmpData::acmp_data_size()) : in_bytes(BranchData::branch_data_size()));\n@@ -1484,0 +1591,79 @@\n+void InterpreterMacroAssembler::profile_array(Register mdp,\n+                                              Register array,\n+                                              Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, array);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::array_offset())));\n+\n+    Label not_flat;\n+    test_non_flattened_array_oop(array, tmp, not_flat);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::flat_array_byte_constant());\n+\n+    bind(not_flat);\n+\n+    Label not_null_free;\n+    test_non_null_free_array_oop(array, tmp, not_null_free);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::null_free_array_byte_constant());\n+\n+    bind(not_null_free);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_element(Register mdp,\n+                                                Register element,\n+                                                Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, element);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::element_offset())));\n+\n+    \/\/ The method data pointer needs to be updated.\n+    update_mdp_by_constant(mdp, in_bytes(ArrayLoadStoreData::array_load_store_data_size()));\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_acmp(Register mdp,\n+                                             Register left,\n+                                             Register right,\n+                                             Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, left);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::left_offset())));\n+\n+    Label left_not_inline_type;\n+    test_oop_is_not_inline_type(left, tmp, left_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::left_inline_type_byte_constant());\n+    bind(left_not_inline_type);\n+\n+    mov(tmp, right);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::right_offset())));\n+\n+    Label right_not_inline_type;\n+    test_oop_is_not_inline_type(right, tmp, right_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::right_inline_type_byte_constant());\n+    bind(right_not_inline_type);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n@@ -1734,1 +1920,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n@@ -1780,1 +1966,1 @@\n-    Address mdo_ret_addr(mdp, -in_bytes(ReturnTypeEntry::size()));\n+    Address mdo_ret_addr(mdp, -in_bytes(SingleTypeEntry::size()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":193,"deletions":7,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -146,0 +146,22 @@\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+\n+  \/\/ Allocate instance in \"obj\" and read in the content of the inline field\n+  \/\/ NOTES:\n+  \/\/   - input holder object via \"obj\", which must be r0,\n+  \/\/     will return new instance via the same reg\n+  \/\/   - assumes holder_klass and valueKlass field klass have both been resolved\n+  void read_inlined_field(Register holder_klass,\n+                          Register field_index, Register field_offset,\n+                          Register temp,  Register obj = r0);\n+\n+  \/\/ Allocate value buffer in \"obj\" and read in flattened element at the given index\n+  \/\/ NOTES:\n+  \/\/   - Return via \"obj\" must be r0\n+  \/\/   - kills all given regs\n+  void read_flattened_element(Register array, Register index,\n+                              Register t1, Register t2,\n+                              Register obj = r0);\n+\n@@ -191,1 +213,1 @@\n-  void gen_subtype_check( Register sub_klass, Label &ok_is_subtype );\n+  void gen_subtype_check( Register sub_klass, Label &ok_is_subtype, bool profile = true);\n@@ -284,1 +306,1 @@\n-  void profile_not_taken_branch(Register mdp);\n+  void profile_not_taken_branch(Register mdp, bool acmp = false);\n@@ -297,0 +319,3 @@\n+  void profile_array(Register mdp, Register array, Register tmp);\n+  void profile_element(Register mdp, Register element, Register tmp);\n+  void profile_acmp(Register mdp, Register left, Register right, Register tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/jfieldIDWorkaround.hpp\"\n@@ -156,1 +157,1 @@\n-  __ lsr(roffset, c_rarg2, 2);                \/\/ offset\n+  __ lsr(roffset, c_rarg2, jfieldIDWorkaround::offset_shift);       \/\/ offset\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n@@ -57,0 +59,1 @@\n+#include \"vmreg_aarch64.inline.hpp\"\n@@ -1110,0 +1113,35 @@\n+void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_default_value_oop from non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  Register offset = temp_reg;\n+  \/\/ Getting the offset of the pre-allocated default value\n+  ldr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n+  ldr(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));\n+\n+  \/\/ Getting the mirror\n+  ldr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n+  resolve_oop_handle(obj, inline_klass);\n+\n+  \/\/ Getting the pre-allocated default value from the mirror\n+  Address field(obj, offset);\n+  load_heap_oop(obj, field);\n+}\n+\n+void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_empty_value from non-empty inline klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  get_default_value_oop(inline_klass, temp_reg, obj);\n+}\n+\n@@ -1460,1 +1498,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -1493,1 +1535,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -1575,0 +1621,1 @@\n+  assert_different_registers(arg_1, c_rarg0);\n@@ -1582,0 +1629,2 @@\n+  assert_different_registers(arg_1, c_rarg0);\n+  assert_different_registers(arg_2, c_rarg0, c_rarg1);\n@@ -1588,0 +1637,4 @@\n+void MacroAssembler::super_call_VM_leaf(address entry_point) {\n+  MacroAssembler::call_VM_leaf_base(entry_point, 1);\n+}\n+\n@@ -1637,0 +1690,110 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  assert_different_registers(markword, rscratch2);\n+  andr(markword, markword, markWord::inline_type_mask_in_place);\n+  mov(rscratch2, markWord::inline_type_pattern);\n+  cmp(markword, rscratch2);\n+  br(Assembler::EQ, is_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n+  ldrw(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  andr(temp_reg, temp_reg, JVM_ACC_VALUE);\n+  cbnz(temp_reg, is_inline_type);\n+}\n+\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+  assert_different_registers(tmp, rscratch1);\n+  cbz(object, not_inline_type);\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  ldr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  mov(rscratch1, is_inline_type_mask);\n+  andr(tmp, tmp, rscratch1);\n+  cmp(tmp, rscratch1);\n+  br(Assembler::NE, not_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(klass, temp_reg, done_check);\n+    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  ldrw(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n+  andr(temp_reg, temp_reg, InstanceKlass::misc_flag_is_empty_inline_type());\n+  cbnz(temp_reg, is_empty_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ConstantPoolCacheEntry::is_null_free_inline_type_shift, is_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbz(flags, ConstantPoolCacheEntry::is_null_free_inline_type_shift, not_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label& is_flattened) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ConstantPoolCacheEntry::is_inlined_shift, is_flattened);\n+}\n+\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  ldr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  tst(temp_reg, markWord::unlocked_value);\n+  br(Assembler::NE, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  load_prototype_header(temp_reg, oop);\n+\n+  bind(test_mark_word);\n+  andr(temp_reg, temp_reg, test_bit);\n+  if (jmp_set) {\n+    cbnz(temp_reg, jmp_label);\n+  } else {\n+    cbz(temp_reg, jmp_label);\n+  }\n+}\n+\n+void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg, Label& is_flattened_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+}\n+\n+void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,\n+                                                  Label&is_non_flattened_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n+}\n+\n+void MacroAssembler::test_flattened_array_layout(Register lh, Label& is_flattened_array) {\n+  tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  br(Assembler::NE, is_flattened_array);\n+}\n+\n+void MacroAssembler::test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array) {\n+  tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  br(Assembler::EQ, is_non_flattened_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_layout(Register lh, Label& is_null_free_array) {\n+  tst(lh, Klass::_lh_null_free_array_bit_inplace);\n+  br(Assembler::NE, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array) {\n+  tst(lh, Klass::_lh_null_free_array_bit_inplace);\n+  br(Assembler::EQ, is_non_null_free_array);\n+}\n+\n@@ -4039,0 +4202,8 @@\n+void MacroAssembler::load_metadata(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -4098,0 +4269,5 @@\n+void MacroAssembler::load_prototype_header(Register dst, Register src) {\n+  load_klass(dst, src);\n+  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n+}\n+\n@@ -4411,1 +4587,2 @@\n-                                     Register tmp1, Register thread_tmp) {\n+                                     Register tmp1, Register thread_tmp, Register tmp3) {\n+\n@@ -4416,1 +4593,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);\n@@ -4418,1 +4595,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, thread_tmp);\n+    bs->store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);\n@@ -4422,0 +4599,40 @@\n+void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,\n+                                       Register inline_klass) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->value_copy(this, decorators, src, dst, inline_klass);\n+}\n+\n+void MacroAssembler::first_field_offset(Register inline_klass, Register offset) {\n+  ldr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+  ldrw(offset, Address(offset, InlineKlass::first_field_offset_offset()));\n+}\n+\n+void MacroAssembler::data_for_oop(Register oop, Register data, Register inline_klass) {\n+  \/\/ ((address) (void*) o) + vk->first_field_offset();\n+  Register offset = (data == oop) ? rscratch1 : data;\n+  first_field_offset(inline_klass, offset);\n+  if (data == oop) {\n+    add(data, data, offset);\n+  } else {\n+    lea(data, Address(oop, offset));\n+  }\n+}\n+\n+void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,\n+                                                Register index, Register data) {\n+  assert_different_registers(array, array_klass, index);\n+  assert_different_registers(rscratch1, array, index);\n+\n+  \/\/ array->base() + (index << Klass::layout_helper_log2_element_size(lh));\n+  ldrw(rscratch1, Address(array_klass, Klass::layout_helper_offset()));\n+\n+  \/\/ Klass::layout_helper_log2_element_size(lh)\n+  \/\/ (lh >> _lh_log2_element_size_shift) & _lh_log2_element_size_mask;\n+  lsr(rscratch1, rscratch1, Klass::_lh_log2_element_size_shift);\n+  andr(rscratch1, rscratch1, Klass::_lh_log2_element_size_mask);\n+  lslv(index, index, rscratch1);\n+\n+  add(data, array, index);\n+  add(data, data, arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT));\n+}\n+\n@@ -4433,2 +4650,2 @@\n-                                    Register thread_tmp, DecoratorSet decorators) {\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);\n+                                    Register thread_tmp, Register tmp3, DecoratorSet decorators) {\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);\n@@ -4439,1 +4656,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);\n+  access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);\n@@ -4504,0 +4721,96 @@\n+\/\/ Object \/ value buffer allocation...\n+void MacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                       Register t1, Register t2,\n+                                       bool clear_fields, Label& alloc_failed)\n+{\n+  Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;\n+  Register layout_size = t1;\n+  assert(new_obj == r0, \"needs to be r0\");\n+  assert_different_registers(klass, new_obj, t1, t2);\n+\n+  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n+  ldrw(layout_size, Address(klass, Klass::layout_helper_offset()));\n+  \/\/ test to see if it has a finalizer or is malformed in some way\n+  tst(layout_size, Klass::_lh_instance_slow_path_bit);\n+  br(Assembler::NE, slow_case_no_pop);\n+\n+  \/\/ Allocate the instance:\n+  \/\/  If TLAB is enabled:\n+  \/\/    Try to allocate in the TLAB.\n+  \/\/    If fails, go to the slow path.\n+  \/\/    Initialize the allocation.\n+  \/\/    Exit.\n+  \/\/\n+  \/\/  Go to slow path.\n+\n+  if (UseTLAB) {\n+    push(klass);\n+    tlab_allocate(new_obj, layout_size, 0, klass, t2, slow_case);\n+    if (ZeroTLAB || (!clear_fields)) {\n+      \/\/ the fields have been already cleared\n+      b(initialize_header);\n+    } else {\n+      \/\/ initialize both the header and fields\n+      b(initialize_object);\n+    }\n+\n+    if (clear_fields) {\n+      \/\/ The object is initialized before the header.  If the object size is\n+      \/\/ zero, go directly to the header initialization.\n+      bind(initialize_object);\n+      subs(layout_size, layout_size, sizeof(oopDesc));\n+      br(Assembler::EQ, initialize_header);\n+\n+      \/\/ Initialize topmost object field, divide size by 8, check if odd and\n+      \/\/ test if zero.\n+\n+  #ifdef ASSERT\n+      \/\/ make sure instance_size was multiple of 8\n+      Label L;\n+      tst(layout_size, 7);\n+      br(Assembler::EQ, L);\n+      stop(\"object size is not multiple of 8 - adjust this code\");\n+      bind(L);\n+      \/\/ must be > 0, no extra check needed here\n+  #endif\n+\n+      lsr(layout_size, layout_size, LogBytesPerLong);\n+\n+      \/\/ initialize remaining object fields: instance_size was a multiple of 8\n+      {\n+        Label loop;\n+        Register base = t2;\n+\n+        bind(loop);\n+        add(rscratch1, new_obj, layout_size, Assembler::LSL, LogBytesPerLong);\n+        str(zr, Address(rscratch1, sizeof(oopDesc) - 1*oopSize));\n+        subs(layout_size, layout_size, 1);\n+        br(Assembler::NE, loop);\n+      }\n+    } \/\/ clear_fields\n+\n+    \/\/ initialize object header only.\n+    bind(initialize_header);\n+    pop(klass);\n+    Register mark_word = t2;\n+    ldr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+    str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes ()));\n+    store_klass_gap(new_obj, zr);  \/\/ zero klass gap for compressed oops\n+    mov(t2, klass);         \/\/ preserve klass\n+    store_klass(new_obj, t2);  \/\/ src klass reg is potentially compressed\n+\n+    \/\/ TODO: Valhalla removed SharedRuntime::dtrace_object_alloc from here ?\n+\n+    b(done);\n+  }\n+\n+  if (UseTLAB) {\n+    bind(slow_case);\n+    pop(klass);\n+  }\n+  bind(slow_case_no_pop);\n+  b(alloc_failed);\n+\n+  bind(done);\n+}\n+\n@@ -4543,0 +4856,13 @@\n+void MacroAssembler::get_inline_type_field_klass(Register klass, Register index, Register inline_klass) {\n+  ldr(inline_klass, Address(klass, InstanceKlass::inline_type_field_klasses_offset()));\n+#ifdef ASSERT\n+  {\n+    Label done;\n+    cbnz(inline_klass, done);\n+    stop(\"get_inline_type_field_klass contains no inline klass\");\n+    bind(done);\n+  }\n+#endif\n+  ldr(inline_klass, Address(inline_klass, index, Address::lsl(3)));\n+}\n+\n@@ -4668,0 +4994,51 @@\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair) {\n+  if (needs_stack_repair) {\n+    \/\/ Remove the extension of the caller's frame used for inline type unpacking\n+    \/\/\n+    \/\/ Right now the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP\n+    \/\/ | Saved LR #1               |\n+    \/\/ | Saved FP #1               |\n+    \/\/ |---------------------------|\n+    \/\/ | Extension space for       |\n+    \/\/ |   inline arg (un)packing  |\n+    \/\/ |---------------------------|  <-- start of this method's frame\n+    \/\/ | Saved LR #2               |\n+    \/\/ | Saved FP #2               |\n+    \/\/ |---------------------------|  <-- FP\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n+    \/\/\n+    \/\/ There are two copies of FP and LR on the stack. They will be identical\n+    \/\/ unless the caller has been deoptimized, in which case LR #1 will be patched\n+    \/\/ to point at the deopt blob, and LR #2 will still point into the old method.\n+    \/\/\n+    \/\/ The sp_inc stack slot holds the total size of the frame including the\n+    \/\/ extension space minus two words for the saved FP and LR.\n+\n+    int sp_inc_offset = initial_framesize - 3 * wordSize;  \/\/ Immediately below saved LR and FP\n+\n+    ldr(rscratch1, Address(sp, sp_inc_offset));\n+    add(sp, sp, rscratch1);\n+    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  } else {\n+    remove_frame(initial_framesize);\n+  }\n+}\n+\n+void MacroAssembler::save_stack_increment(int sp_inc, int frame_size) {\n+  int real_frame_size = frame_size + sp_inc;\n+  assert(sp_inc == 0 || sp_inc > 2*wordSize, \"invalid sp_inc value\");\n+  assert(real_frame_size >= 2*wordSize, \"frame size must include FP\/LR space\");\n+  assert((real_frame_size & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+\n+  int sp_inc_offset = frame_size - 3 * wordSize;  \/\/ Immediately below saved LR and FP\n+\n+  \/\/ Subtract two words for the saved FP and LR as these will be popped\n+  \/\/ separately. See remove_frame above.\n+  mov(rscratch1, real_frame_size - 2*wordSize);\n+  str(rscratch1, Address(sp, sp_inc_offset));\n+}\n@@ -5576,0 +5953,432 @@\n+#ifdef COMPILER2\n+\/\/ C2 compiled method's prolog code\n+\/\/ Moved here from aarch64.ad to support Valhalla code belows\n+void MacroAssembler::verified_entry(Compile* C, int sp_inc) {\n+\n+  \/\/ n.b. frame size includes space for return pc and rfp\n+  const long framesize = C->output()->frame_size_in_bytes();\n+\n+  \/\/ insert a nop at the start of the prolog so we can patch in a\n+  \/\/ branch if we need to invalidate the method later\n+  nop();\n+\n+  int bangsize = C->output()->bang_size_in_bytes();\n+  if (C->output()->need_stack_bang(bangsize))\n+    generate_stack_overflow_check(bangsize);\n+\n+  build_frame(framesize);\n+\n+  if (C->needs_stack_repair()) {\n+    save_stack_increment(sp_inc, framesize);\n+  }\n+\n+  if (VerifyStackAtCalls) {\n+    Unimplemented();\n+  }\n+}\n+#endif \/\/ COMPILER2\n+\n+int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  \/\/ An inline type might be returned. If fields are in registers we\n+  \/\/ need to allocate an inline type instance and initialize it with\n+  \/\/ the value of the fields.\n+  Label skip;\n+  \/\/ We only need a new buffered inline type if a new one is not returned\n+  tbz(r0, 0, skip);\n+  int call_offset = -1;\n+\n+  \/\/ Be careful not to clobber r1-7 which hold returned fields\n+  \/\/ Also do not use callee-saved registers as these may be live in the interpreter\n+  Register tmp1 = r13, tmp2 = r14, klass = r15, r0_preserved = r12;\n+\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != NULL, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(r0_preserved, r0); \/\/ save r0 for slow_case since *_allocate may corrupt it when allocation failed\n+\n+  if (vk != NULL) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(klass, (intptr_t)vk->get_InlineKlass());\n+    jint obj_size = vk->layout_helper();\n+    assert(obj_size != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB) {\n+      tlab_allocate(r0, noreg, obj_size, tmp1, tmp2, slow_case);\n+    } else {\n+      b(slow_case);\n+    }\n+  } else {\n+    \/\/ Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)\n+    andr(klass, r0, -2);\n+    ldrw(tmp2, Address(klass, Klass::layout_helper_offset()));\n+    if (UseTLAB) {\n+      tlab_allocate(r0, tmp2, 0, tmp1, tmp2, slow_case);\n+    } else {\n+      b(slow_case);\n+    }\n+  }\n+  if (UseTLAB) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = r0;\n+    mov(rscratch1, (intptr_t)markWord::inline_type_prototype().value());\n+    str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+    store_klass_gap(buffer_obj, zr);\n+    if (vk == NULL) {\n+      \/\/ store_klass corrupts klass, so save it for later use (interpreter case only).\n+      mov(tmp1, klass);\n+    }\n+    store_klass(buffer_obj, klass);\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n+    if (vk != NULL) {\n+      far_call(RuntimeAddress(vk->pack_handler())); \/\/ no need for call info as this will not safepoint.\n+    } else {\n+      \/\/ tmp1 holds klass preserved above\n+      ldr(tmp1, Address(tmp1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      ldr(tmp1, Address(tmp1, InlineKlass::pack_handler_offset()));\n+      blr(tmp1);\n+    }\n+\n+    membar(Assembler::StoreStore);\n+    b(skip);\n+  } else {\n+    \/\/ Must have already branched to slow_case above.\n+    DEBUG_ONLY(should_not_reach_here());\n+  }\n+  bind(slow_case);\n+  \/\/ We failed to allocate a new inline type, fall back to a runtime\n+  \/\/ call. Some oop field may be live in some registers but we can't\n+  \/\/ tell. That runtime call will take care of preserving them\n+  \/\/ across a GC if there's one.\n+  mov(r0, r0_preserved);\n+\n+  if (from_interpreter) {\n+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());\n+  } else {\n+    far_call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n+    call_offset = offset();\n+  }\n+  membar(Assembler::StoreStore);\n+\n+  bind(skip);\n+  return call_offset;\n+}\n+\n+\/\/ Move a value between registers\/stack slots and update the reg_state\n+bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]) {\n+  assert(from->is_valid() && to->is_valid(), \"source and destination must be valid\");\n+  if (reg_state[to->value()] == reg_written) {\n+    return true; \/\/ Already written\n+  }\n+\n+  if (from != to && bt != T_VOID) {\n+    if (reg_state[to->value()] == reg_readonly) {\n+      return false; \/\/ Not yet writable\n+    }\n+    if (from->is_reg()) {\n+      if (to->is_reg()) {\n+        if (from->is_Register() && to->is_Register()) {\n+          mov(to->as_Register(), from->as_Register());\n+        } else if (from->is_FloatRegister() && to->is_FloatRegister()) {\n+          fmovd(to->as_FloatRegister(), from->as_FloatRegister());\n+        } else {\n+          ShouldNotReachHere();\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n+        Address to_addr = Address(sp, st_off);\n+        if (from->is_FloatRegister()) {\n+          if (bt == T_DOUBLE) {\n+             strd(from->as_FloatRegister(), to_addr);\n+          } else {\n+             assert(bt == T_FLOAT, \"must be float\");\n+             strs(from->as_FloatRegister(), to_addr);\n+          }\n+        } else {\n+          str(from->as_Register(), to_addr);\n+        }\n+      }\n+    } else {\n+      Address from_addr = Address(sp, from->reg2stack() * VMRegImpl::stack_slot_size);\n+      if (to->is_reg()) {\n+        if (to->is_FloatRegister()) {\n+          if (bt == T_DOUBLE) {\n+            ldrd(to->as_FloatRegister(), from_addr);\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            ldrs(to->as_FloatRegister(), from_addr);\n+          }\n+        } else {\n+          ldr(to->as_Register(), from_addr);\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(rscratch1, from_addr);\n+        str(rscratch1, Address(sp, st_off));\n+      }\n+    }\n+  }\n+\n+  \/\/ Update register states\n+  reg_state[from->value()] = reg_writable;\n+  reg_state[to->value()] = reg_written;\n+  return true;\n+}\n+\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  int sp_inc = args_on_stack * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  assert(sp_inc > 0, \"sanity\");\n+\n+  \/\/ Save a copy of the FP and LR here for deoptimization patching and frame walking\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+\n+  \/\/ Adjust the stack pointer. This will be repaired on return by MacroAssembler::remove_frame\n+  if (sp_inc < (1 << 9)) {\n+    sub(sp, sp, sp_inc);   \/\/ Fits in an immediate\n+  } else {\n+    mov(rscratch1, sp_inc);\n+    sub(sp, sp, rscratch1);\n+  }\n+\n+  return sp_inc + 2 * wordSize;  \/\/ Account for the FP\/LR space\n+}\n+\n+\/\/ Read all fields from an inline type oop and store the values in registers\/stack slots\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                                          VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                                          RegState reg_state[]) {\n+  assert(sig->at(sig_index)._bt == T_VOID, \"should be at end delimiter\");\n+  assert(from->is_valid(), \"source must be valid\");\n+  bool progress = false;\n+#ifdef ASSERT\n+  const int start_offset = offset();\n+#endif\n+\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r11;\n+  Register fromReg = noreg;\n+  ScalarizedInlineArgsStream stream(sig, sig_index, to, to_count, to_index, -1);\n+  bool done = true;\n+  bool mark_done = true;\n+  VMReg toReg;\n+  BasicType bt;\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n+  while (stream.next(toReg, bt)) {\n+    assert(toReg->is_valid(), \"destination must be valid\");\n+    int idx = (int)toReg->value();\n+    if (reg_state[idx] == reg_readonly) {\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n+    } else if (reg_state[idx] == reg_written) {\n+      continue;\n+    }\n+    assert(reg_state[idx] == reg_writable, \"must be writable\");\n+    reg_state[idx] = reg_written;\n+    progress = true;\n+\n+    if (fromReg == noreg) {\n+      if (from->is_reg()) {\n+        fromReg = from->as_Register();\n+      } else {\n+        int st_off = from->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(tmp1, Address(sp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        cbz(fromReg, L_null);\n+      }\n+    }\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        mov(tmp2, 1);\n+        str(tmp2, Address(sp, st_off));\n+      } else {\n+        mov(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n+    Address fromAddr = Address(fromReg, off);\n+    if (!toReg->is_FloatRegister()) {\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n+      if (is_reference_type(bt)) {\n+        load_heap_oop(dst, fromAddr);\n+      } else {\n+        bool is_signed = (bt != T_CHAR) && (bt != T_BOOLEAN);\n+        load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);\n+      }\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        str(dst, Address(sp, st_off));\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      ldrd(toReg->as_FloatRegister(), fromAddr);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      ldrs(toReg->as_FloatRegister(), fromAddr);\n+    }\n+  }\n+  if (progress && null_check) {\n+    if (done) {\n+      b(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+            str(zr, Address(sp, st_off));\n+          } else {\n+            mov(toReg->as_Register(), zr);\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n+  sig_index = stream.sig_index();\n+  to_index = stream.regs_index();\n+\n+  if (mark_done && reg_state[from->value()] != reg_written) {\n+    \/\/ This is okay because no one else will write to that slot\n+    reg_state[from->value()] = reg_writable;\n+  }\n+  from_index--;\n+  assert(progress || (start_offset == offset()), \"should not emit code\");\n+  return done;\n+}\n+\n+\/\/ Pack fields back into an inline type oop\n+bool MacroAssembler::pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                                        VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                                        RegState reg_state[], Register val_array) {\n+  assert(sig->at(sig_index)._bt == T_PRIMITIVE_OBJECT, \"should be at end delimiter\");\n+  assert(to->is_valid(), \"destination must be valid\");\n+\n+  if (reg_state[to->value()] == reg_written) {\n+    skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+    return true; \/\/ Already written\n+  }\n+\n+  \/\/ The GC barrier expanded by store_heap_oop below may call into the\n+  \/\/ runtime so use callee-saved registers for any values that need to be\n+  \/\/ preserved. The GC barrier assembler should take care of saving the\n+  \/\/ Java argument registers.\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n+  Register val_obj_tmp = r21;\n+  Register from_reg_tmp = r22;\n+  Register tmp1 = r14;\n+  Register tmp2 = r13;\n+  Register tmp3 = r12;\n+  Register val_obj = to->is_stack() ? val_obj_tmp : to->as_Register();\n+\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n+  if (reg_state[to->value()] == reg_readonly) {\n+    if (!is_reg_in_unpacked_fields(sig, sig_index, to, from, from_count, from_index)) {\n+      skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+      return false; \/\/ Not yet writable\n+    }\n+    val_obj = val_obj_tmp;\n+  }\n+\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_PRIMITIVE_OBJECT);\n+  load_heap_oop(val_obj, Address(val_array, index));\n+\n+  ScalarizedInlineArgsStream stream(sig, sig_index, from, from_count, from_index);\n+  VMReg fromReg;\n+  BasicType bt;\n+  Label L_null;\n+  while (stream.next(fromReg, bt)) {\n+    assert(fromReg->is_valid(), \"source must be valid\");\n+    reg_state[fromReg->value()] = reg_writable;\n+\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(tmp2, Address(sp, ld_off));\n+        cbnz(tmp2, L_notNull);\n+      } else {\n+        cbnz(fromReg->as_Register(), L_notNull);\n+      }\n+      mov(val_obj, 0);\n+      b(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n+    assert(off > 0, \"offset in object should be positive\");\n+    size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+\n+    \/\/ Pack the scalarized field into the value object.\n+    Address dst(val_obj, off);\n+\n+    if (!fromReg->is_FloatRegister()) {\n+      Register src;\n+      if (fromReg->is_stack()) {\n+        src = from_reg_tmp;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        load_sized_value(src, Address(sp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+      } else {\n+        src = fromReg->as_Register();\n+      }\n+      assert_different_registers(dst.base(), src, tmp1, tmp2, tmp3, val_array);\n+      if (is_reference_type(bt)) {\n+        store_heap_oop(dst, src, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        store_sized_value(dst, src, size_in_bytes);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      strd(fromReg->as_FloatRegister(), dst);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      strs(fromReg->as_FloatRegister(), dst);\n+    }\n+  }\n+  bind(L_null);\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+\n+  assert(reg_state[to->value()] == reg_writable, \"must have already been read\");\n+  bool success = move_helper(val_obj->as_VMReg(), to, T_OBJECT, reg_state);\n+  assert(success, \"to register must be writeable\");\n+\n+  return true;\n+}\n+\n+VMReg MacroAssembler::spill_reg_for(VMReg reg) {\n+  return (reg->is_FloatRegister()) ? v0->as_VMReg() : r14->as_VMReg();\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":817,"deletions":8,"binary":false,"changes":825,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -35,0 +36,4 @@\n+#include \"runtime\/signature.hpp\"\n+\n+\n+class ciInlineKlass;\n@@ -609,0 +614,31 @@\n+  \/\/ markWord tests, kills markWord reg\n+  void test_markword_is_inline_type(Register markword, Label& is_inline_type);\n+\n+  \/\/ inlineKlass queries, kills temp_reg\n+  void test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type);\n+  void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type);\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n+\n+  \/\/ Get the default value oop for the given InlineKlass\n+  void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);\n+  \/\/ The empty value oop, for the given InlineKlass (\"empty\" as in no instance fields)\n+  \/\/ get_default_value_oop with extra assertion for empty inline klass\n+  void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);\n+\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n+  void test_field_is_inlined(Register flags, Register temp_reg, Label& is_flattened);\n+\n+  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  void test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label);\n+  void test_flattened_array_oop(Register klass, Register temp_reg, Label& is_flattened_array);\n+  void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&is_non_flattened_array);\n+  void test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array);\n+  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array);\n+\n+  \/\/ Check array klass layout helper for flatten or null-free arrays...\n+  void test_flattened_array_layout(Register lh, Label& is_flattened_array);\n+  void test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array);\n+  void test_null_free_array_layout(Register lh, Label& is_null_free_array);\n+  void test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array);\n+\n@@ -838,0 +874,2 @@\n+  void load_metadata(Register dst, Register src);\n+\n@@ -850,1 +888,10 @@\n-                       Register tmp1, Register tmp_thread);\n+                       Register tmp1, Register tmp_thread, Register tmp3 = noreg);\n+\n+  void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);\n+\n+  \/\/ inline type data payload offsets...\n+  void first_field_offset(Register inline_klass, Register offset);\n+  void data_for_oop(Register oop, Register data, Register inline_klass);\n+  \/\/ get data payload ptr a flat value array at index, kills rcx and index\n+  void data_for_value_array_index(Register array, Register array_klass,\n+                                  Register index, Register data);\n@@ -858,1 +905,1 @@\n-                      Register tmp_thread = noreg, DecoratorSet decorators = 0);\n+                      Register tmp_thread = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n@@ -865,0 +912,2 @@\n+  void load_prototype_header(Register dst, Register src);\n+\n@@ -912,0 +961,9 @@\n+\n+  \/\/ Object \/ value buffer allocation...\n+  \/\/ Allocate instance of klass, assumes klass initialized by caller\n+  \/\/ new_obj prefers to be rax\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+\n@@ -922,0 +980,3 @@\n+  \/\/ For field \"index\" within \"klass\", return inline_klass ...\n+  void get_inline_type_field_klass(Register klass, Register index, Register inline_klass);\n+\n@@ -1306,0 +1367,18 @@\n+  void verified_entry(Compile* C, int sp_inc);\n+\n+  \/\/ Inline type specific methods\n+  #include \"asm\/macroAssembler_common.hpp\"\n+\n+  int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);\n+  bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]);\n+  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                            VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                            RegState reg_state[]);\n+  bool pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                          VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                          RegState reg_state[], Register val_array);\n+  int extend_stack_for_inline_args(int args_on_stack);\n+  void remove_frame(int initial_framesize, bool needs_stack_repair);\n+  VMReg spill_reg_for(VMReg reg);\n+  void save_stack_increment(int sp_inc, int frame_size);\n+\n@@ -1370,0 +1449,2 @@\n+  void fill_words(Register base, uint64_t cnt, Register value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":83,"deletions":2,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -118,1 +118,5 @@\n-  const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_offset() :\n+  \/\/ The following jump might pass an inline type argument that was erased to Object as oop to a\n+  \/\/ callee that expects inline type arguments to be passed as fields. We need to call the compiled\n+  \/\/ value entry (_code->inline_entry_point() or _adapter->c2i_inline_entry()) which will take care\n+  \/\/ of translating between the calling conventions.\n+  const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_inline_offset() :\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -349,0 +350,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -382,0 +384,80 @@\n+\n+const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j;\n+const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;\n+\n+int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {\n+\n+  \/\/ Create the mapping between argument positions and registers.\n+\n+  static const Register INT_ArgReg[java_return_convention_max_int] = {\n+    r0 \/* j_rarg7 *\/, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2, j_rarg1, j_rarg0\n+  };\n+\n+  static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {\n+    j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7\n+  };\n+\n+  uint int_args = 0;\n+  uint fp_args = 0;\n+\n+  for (int i = 0; i < total_args_passed; i++) {\n+    switch (sig_bt[i]) {\n+    case T_BOOLEAN:\n+    case T_CHAR:\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+      if (int_args < SharedRuntime::java_return_convention_max_int) {\n+        regs[i].set1(INT_ArgReg[int_args]->as_VMReg());\n+        int_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_VOID:\n+      \/\/ halves of T_LONG or T_DOUBLE\n+      assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+      regs[i].set_bad();\n+      break;\n+    case T_LONG:\n+      assert((i + 1) < total_args_passed && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      \/\/ fall through\n+    case T_OBJECT:\n+    case T_ARRAY:\n+    case T_ADDRESS:\n+      \/\/ Should T_METADATA be added to java_calling_convention as well ?\n+    case T_METADATA:\n+    case T_PRIMITIVE_OBJECT:\n+      if (int_args < SharedRuntime::java_return_convention_max_int) {\n+        regs[i].set2(INT_ArgReg[int_args]->as_VMReg());\n+        int_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_FLOAT:\n+      if (fp_args < SharedRuntime::java_return_convention_max_float) {\n+        regs[i].set1(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_DOUBLE:\n+      assert((i + 1) < total_args_passed && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      if (fp_args < SharedRuntime::java_return_convention_max_float) {\n+        regs[i].set2(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  return int_args + fp_args;\n+}\n+\n@@ -416,0 +498,109 @@\n+\/\/ For each inline type argument, sig includes the list of fields of\n+\/\/ the inline type. This utility function computes the number of\n+\/\/ arguments for the call if inline types are passed by reference (the\n+\/\/ calling convention the interpreter expects).\n+static int compute_total_args_passed_int(const GrowableArray<SigEntry>* sig_extended) {\n+  int total_args_passed = 0;\n+  if (InlineTypePassFieldsAsArgs) {\n+     for (int i = 0; i < sig_extended->length(); i++) {\n+       BasicType bt = sig_extended->at(i)._bt;\n+       if (bt == T_PRIMITIVE_OBJECT) {\n+         \/\/ In sig_extended, an inline type argument starts with:\n+         \/\/ T_PRIMITIVE_OBJECT, followed by the types of the fields of the\n+         \/\/ inline type and T_VOID to mark the end of the value\n+         \/\/ type. Inline types are flattened so, for instance, in the\n+         \/\/ case of an inline type with an int field and an inline type\n+         \/\/ field that itself has 2 fields, an int and a long:\n+         \/\/ T_PRIMITIVE_OBJECT T_INT T_PRIMITIVE_OBJECT T_INT T_LONG T_VOID (second\n+         \/\/ slot for the T_LONG) T_VOID (inner T_PRIMITIVE_OBJECT) T_VOID\n+         \/\/ (outer T_PRIMITIVE_OBJECT)\n+         total_args_passed++;\n+         int vt = 1;\n+         do {\n+           i++;\n+           BasicType bt = sig_extended->at(i)._bt;\n+           BasicType prev_bt = sig_extended->at(i-1)._bt;\n+           if (bt == T_PRIMITIVE_OBJECT) {\n+             vt++;\n+           } else if (bt == T_VOID &&\n+                      prev_bt != T_LONG &&\n+                      prev_bt != T_DOUBLE) {\n+             vt--;\n+           }\n+         } while (vt != 0);\n+       } else {\n+         total_args_passed++;\n+       }\n+     }\n+  } else {\n+    total_args_passed = sig_extended->length();\n+  }\n+\n+  return total_args_passed;\n+}\n+\n+\n+static void gen_c2i_adapter_helper(MacroAssembler* masm,\n+                                   BasicType bt,\n+                                   BasicType prev_bt,\n+                                   size_t size_in_bytes,\n+                                   const VMRegPair& reg_pair,\n+                                   const Address& to,\n+                                   Register tmp1,\n+                                   Register tmp2,\n+                                   Register tmp3,\n+                                   int extraspace,\n+                                   bool is_oop) {\n+  assert(bt != T_PRIMITIVE_OBJECT || !InlineTypePassFieldsAsArgs, \"no inline type here\");\n+  if (bt == T_VOID) {\n+    assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, \"missing half\");\n+    return;\n+  }\n+\n+  \/\/ Say 4 args:\n+  \/\/ i   st_off\n+  \/\/ 0   32 T_LONG\n+  \/\/ 1   24 T_VOID\n+  \/\/ 2   16 T_OBJECT\n+  \/\/ 3    8 T_BOOL\n+  \/\/ -    0 return address\n+  \/\/\n+  \/\/ However to make thing extra confusing. Because we can fit a Java long\/double in\n+  \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n+  \/\/ leaves one slot empty and only stores to a single slot. In this case the\n+  \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n+\n+  bool wide = (size_in_bytes == wordSize);\n+  VMReg r_1 = reg_pair.first();\n+  VMReg r_2 = reg_pair.second();\n+  assert(r_2->is_valid() == wide, \"invalid size\");\n+  if (!r_1->is_valid()) {\n+    assert(!r_2->is_valid(), \"\");\n+    return;\n+  }\n+\n+  if (!r_1->is_FloatRegister()) {\n+    Register val = tmp3;\n+    if (r_1->is_stack()) {\n+      \/\/ memory to memory use tmp3 (scratch registers are used by store_heap_oop)\n+      int ld_off = r_1->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+      __ load_sized_value(val, Address(sp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+    } else {\n+      val = r_1->as_Register();\n+    }\n+    assert_different_registers(to.base(), val, rscratch2, tmp1, tmp2);\n+    if (is_oop) {\n+      __ store_heap_oop(to, val, rscratch2, tmp1, tmp2, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+    } else {\n+      __ store_sized_value(to, val, size_in_bytes);\n+    }\n+  } else {\n+    if (wide) {\n+      __ strd(r_1->as_FloatRegister(), to);\n+    } else {\n+      \/\/ only a float use just part of the slot\n+      __ strs(r_1->as_FloatRegister(), to);\n+    }\n+  }\n+}\n+\n@@ -417,3 +608,1 @@\n-                            int total_args_passed,\n-                            int comp_args_on_stack,\n-                            const BasicType *sig_bt,\n+                            const GrowableArray<SigEntry>* sig_extended,\n@@ -421,1 +610,7 @@\n-                            Label& skip_fixup) {\n+                            Label& skip_fixup,\n+                            address start,\n+                            OopMapSet* oop_maps,\n+                            int& frame_complete,\n+                            int& frame_size_in_words,\n+                            bool alloc_inline_receiver) {\n+\n@@ -431,1 +626,22 @@\n-  int words_pushed = 0;\n+  \/\/ Name some registers to be used in the following code. We can use\n+  \/\/ anything except r0-r7 which are arguments in the Java calling\n+  \/\/ convention, rmethod (r12), and r13 which holds the outgoing sender\n+  \/\/ SP for the interpreter.\n+  Register buf_array = r10;   \/\/ Array of buffered inline types\n+  Register buf_oop = r11;     \/\/ Buffered inline type oop\n+  Register tmp1 = r15;\n+  Register tmp2 = r16;\n+  Register tmp3 = r17;\n+\n+  if (InlineTypePassFieldsAsArgs) {\n+    \/\/ Is there an inline type argument?\n+    bool has_inline_argument = false;\n+    for (int i = 0; i < sig_extended->length() && !has_inline_argument; i++) {\n+      has_inline_argument = (sig_extended->at(i)._bt == T_PRIMITIVE_OBJECT);\n+    }\n+    if (has_inline_argument) {\n+      \/\/ There is at least an inline type argument: we're coming from\n+      \/\/ compiled code so we have no buffers to back the inline types\n+      \/\/ Allocate the buffers here with a runtime call.\n+      RegisterSaver reg_save(false \/* save_vectors *\/);\n+      OopMap* map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -433,2 +649,2 @@\n-  \/\/ Since all args are passed on the stack, total_args_passed *\n-  \/\/ Interpreter::stackElementSize is the space we need.\n+      frame_complete = __ offset();\n+      address the_pc = __ pc();\n@@ -436,1 +652,2 @@\n-  int extraspace = total_args_passed * Interpreter::stackElementSize;\n+      Label retaddr;\n+      __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);\n@@ -438,1 +655,3 @@\n-  __ mov(r19_sender_sp, sp);\n+      __ mov(c_rarg0, rthread);\n+      __ mov(c_rarg1, rmethod);\n+      __ mov(c_rarg2, (int64_t)alloc_inline_receiver);\n@@ -440,2 +659,3 @@\n-  \/\/ stack is aligned, keep it that way\n-  extraspace = align_up(extraspace, 2*wordSize);\n+      __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));\n+      __ blr(rscratch1);\n+      __ bind(retaddr);\n@@ -443,2 +663,2 @@\n-  if (extraspace)\n-    __ sub(sp, sp, extraspace);\n+      oop_maps->add_gc_map(__ pc() - start, map);\n+      __ reset_last_Java_frame(false);\n@@ -446,6 +666,1 @@\n-  \/\/ Now write the args into the outgoing interpreter space\n-  for (int i = 0; i < total_args_passed; i++) {\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n-      continue;\n-    }\n+      reg_save.restore_live_registers(masm);\n@@ -453,16 +668,3 @@\n-    \/\/ offset to start parameters\n-    int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;\n-    int next_off = st_off - Interpreter::stackElementSize;\n-\n-    \/\/ Say 4 args:\n-    \/\/ i   st_off\n-    \/\/ 0   32 T_LONG\n-    \/\/ 1   24 T_VOID\n-    \/\/ 2   16 T_OBJECT\n-    \/\/ 3    8 T_BOOL\n-    \/\/ -    0 return address\n-    \/\/\n-    \/\/ However to make thing extra confusing. Because we can fit a Java long\/double in\n-    \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n-    \/\/ leaves one slot empty and only stores to a single slot. In this case the\n-    \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n+      Label no_exception;\n+      __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+      __ cbz(rscratch1, no_exception);\n@@ -470,5 +672,9 @@\n-    VMReg r_1 = regs[i].first();\n-    VMReg r_2 = regs[i].second();\n-    if (!r_1->is_valid()) {\n-      assert(!r_2->is_valid(), \"\");\n-      continue;\n+      __ str(zr, Address(rthread, JavaThread::vm_result_offset()));\n+      __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));\n+      __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+      __ bind(no_exception);\n+\n+      \/\/ We get an array of objects from the runtime call\n+      __ get_vm_result(buf_array, rthread);\n+      __ get_vm_result_2(rmethod, rthread); \/\/ TODO: required to keep the callee Method live?\n@@ -476,9 +682,1 @@\n-    if (r_1->is_stack()) {\n-      \/\/ memory to memory use rscratch1\n-      int ld_off = (r_1->reg2stack() * VMRegImpl::stack_slot_size\n-                    + extraspace\n-                    + words_pushed * wordSize);\n-      if (!r_2->is_valid()) {\n-        \/\/ sign extend??\n-        __ ldrw(rscratch1, Address(sp, ld_off));\n-        __ str(rscratch1, Address(sp, st_off));\n+  }\n@@ -486,1 +684,11 @@\n-      } else {\n+  \/\/ Since all args are passed on the stack, total_args_passed *\n+  \/\/ Interpreter::stackElementSize is the space we need.\n+\n+  int total_args_passed = compute_total_args_passed_int(sig_extended);\n+  int extraspace = total_args_passed * Interpreter::stackElementSize;\n+\n+  \/\/ stack is aligned, keep it that way\n+  extraspace = align_up(extraspace, StackAlignmentInBytes);\n+\n+  \/\/ set senderSP value\n+  __ mov(r19_sender_sp, sp);\n@@ -488,1 +696,1 @@\n-        __ ldr(rscratch1, Address(sp, ld_off));\n+  __ sub(sp, sp, extraspace);\n@@ -490,6 +698,26 @@\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ ld_off == LSW, ld_off+wordSize == MSW\n-          \/\/ st_off == MSW, next_off == LSW\n-          __ str(rscratch1, Address(sp, next_off));\n+  \/\/ Now write the args into the outgoing interpreter space\n+\n+  \/\/ next_arg_comp is the next argument from the compiler point of\n+  \/\/ view (inline type fields are passed in registers\/on the stack). In\n+  \/\/ sig_extended, an inline type argument starts with: T_PRIMITIVE_OBJECT,\n+  \/\/ followed by the types of the fields of the inline type and T_VOID\n+  \/\/ to mark the end of the inline type. ignored counts the number of\n+  \/\/ T_PRIMITIVE_OBJECT\/T_VOID. next_vt_arg is the next inline type argument:\n+  \/\/ used to get the buffer for that argument from the pool of buffers\n+  \/\/ we allocated above and want to pass to the\n+  \/\/ interpreter. next_arg_int is the next argument from the\n+  \/\/ interpreter point of view (inline types are passed by reference).\n+  for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;\n+       next_arg_comp < sig_extended->length(); next_arg_comp++) {\n+    assert(ignored <= next_arg_comp, \"shouldn't skip over more slots than there are arguments\");\n+    assert(next_arg_int <= total_args_passed, \"more arguments for the interpreter than expected?\");\n+    BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+    int st_off = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;\n+    if (!InlineTypePassFieldsAsArgs || bt != T_PRIMITIVE_OBJECT) {\n+      int next_off = st_off - Interpreter::stackElementSize;\n+      const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;\n+      const VMRegPair reg_pair = regs[next_arg_comp-ignored];\n+      size_t size_in_bytes = reg_pair.second()->is_valid() ? 8 : 4;\n+      gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                             size_in_bytes, reg_pair, Address(sp, offset), tmp1, tmp2, tmp3, extraspace, false);\n+      next_arg_int++;\n@@ -497,7 +725,4 @@\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaaaull);\n-          __ str(rscratch1, Address(sp, st_off));\n-#endif \/* ASSERT *\/\n-        } else {\n-          __ str(rscratch1, Address(sp, st_off));\n-        }\n+      if (bt == T_LONG || bt == T_DOUBLE) {\n+        \/\/ Overwrite the unused slot with known junk\n+        __ mov(rscratch1, CONST64(0xdeadffffdeadaaaa));\n+        __ str(rscratch1, Address(sp, st_off));\n@@ -505,16 +730,24 @@\n-    } else if (r_1->is_Register()) {\n-      Register r = r_1->as_Register();\n-      if (!r_2->is_valid()) {\n-        \/\/ must be only an int (or less ) so move only 32bits to slot\n-        \/\/ why not sign extend??\n-        __ str(r, Address(sp, st_off));\n-      } else {\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ jlong\/double in gpr\n-#ifdef ASSERT\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaabull);\n-          __ str(rscratch1, Address(sp, st_off));\n-          __ str(r, Address(sp, next_off));\n+    } else {\n+      ignored++;\n+      \/\/ get the buffer from the just allocated pool of buffers\n+      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_PRIMITIVE_OBJECT);\n+      __ load_heap_oop(buf_oop, Address(buf_array, index));\n+      next_vt_arg++; next_arg_int++;\n+      int vt = 1;\n+      \/\/ write fields we get from compiled code in registers\/stack\n+      \/\/ slots to the buffer: we know we are done with that inline type\n+      \/\/ argument when we hit the T_VOID that acts as an end of inline\n+      \/\/ type delimiter for this inline type. Inline types are flattened\n+      \/\/ so we might encounter embedded inline types. Each entry in\n+      \/\/ sig_extended contains a field offset in the buffer.\n+      Label L_null;\n+      do {\n+        next_arg_comp++;\n+        BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+        BasicType prev_bt = sig_extended->at(next_arg_comp - 1)._bt;\n+        if (bt == T_PRIMITIVE_OBJECT) {\n+          vt++;\n+          ignored++;\n+        } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+          vt--;\n+          ignored++;\n@@ -523,1 +756,22 @@\n-          __ str(r, Address(sp, st_off));\n+          int off = sig_extended->at(next_arg_comp)._offset;\n+          if (off == -1) {\n+            \/\/ Nullable inline type argument, emit null check\n+            VMReg reg = regs[next_arg_comp-ignored].first();\n+            Label L_notNull;\n+            if (reg->is_stack()) {\n+              int ld_off = reg->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+              __ ldr(tmp1, Address(sp, ld_off));\n+              __ cbnz(tmp1, L_notNull);\n+            } else {\n+              __ cbnz(reg->as_Register(), L_notNull);\n+            }\n+            __ str(zr, Address(sp, st_off));\n+            __ b(L_null);\n+            __ bind(L_notNull);\n+            continue;\n+          }\n+          assert(off > 0, \"offset in object should be positive\");\n+          size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+          bool is_oop = is_reference_type(bt);\n+          gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                                 size_in_bytes, regs[next_arg_comp-ignored], Address(buf_oop, off), tmp1, tmp2, tmp3, extraspace, is_oop);\n@@ -525,14 +779,4 @@\n-      }\n-    } else {\n-      assert(r_1->is_FloatRegister(), \"\");\n-      if (!r_2->is_valid()) {\n-        \/\/ only a float use just part of the slot\n-        __ strs(r_1->as_FloatRegister(), Address(sp, st_off));\n-      } else {\n-#ifdef ASSERT\n-        \/\/ Overwrite the unused slot with known junk\n-        __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaacull);\n-        __ str(rscratch1, Address(sp, st_off));\n-#endif \/* ASSERT *\/\n-        __ strd(r_1->as_FloatRegister(), Address(sp, next_off));\n-      }\n+      } while (vt != 0);\n+      \/\/ pass the buffer to the interpreter\n+      __ str(buf_oop, Address(sp, st_off));\n+      __ bind(L_null);\n@@ -548,0 +792,1 @@\n+void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray<SigEntry>* sig, const VMRegPair *regs) {\n@@ -549,5 +794,0 @@\n-void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,\n-                                    int total_args_passed,\n-                                    int comp_args_on_stack,\n-                                    const BasicType *sig_bt,\n-                                    const VMRegPair *regs) {\n@@ -611,1 +851,1 @@\n-  int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)>>LogBytesPerWord;\n+  int comp_words_on_stack = 0;\n@@ -613,2 +853,3 @@\n-    __ sub(rscratch1, sp, comp_words_on_stack * wordSize);\n-    __ andr(sp, rscratch1, -16);\n+     comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) >> LogBytesPerWord;\n+     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);\n+     __ andr(sp, rscratch1, -16);\n@@ -619,1 +860,1 @@\n-  __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));\n+  __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_inline_offset())));\n@@ -633,0 +874,2 @@\n+  int total_args_passed = sig->length();\n+\n@@ -635,2 +878,5 @@\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n+    BasicType bt = sig->at(i)._bt;\n+\n+    assert(bt != T_PRIMITIVE_OBJECT, \"i2c adapter doesn't unpack inline typ args\");\n+    if (bt == T_VOID) {\n+      assert(i > 0 && (sig->at(i - 1)._bt == T_LONG || sig->at(i - 1)._bt == T_DOUBLE), \"missing half\");\n@@ -641,0 +887,1 @@\n+    assert(!regs[i].second()->is_valid() || regs[i].first()->next() == regs[i].second(), \"scrambled load targets?\");\n@@ -642,3 +889,1 @@\n-    assert(!regs[i].second()->is_valid() || regs[i].first()->next() == regs[i].second(),\n-            \"scrambled load targets?\");\n-    int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;\n+    int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;\n@@ -659,1 +904,1 @@\n-      int st_off = regs[i].first()->reg2stack()*VMRegImpl::stack_slot_size;\n+      int st_off = regs[i].first()->reg2stack() * VMRegImpl::stack_slot_size;\n@@ -676,2 +921,1 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n-                           next_off : ld_off;\n+        const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;\n@@ -680,14 +924,28 @@\n-        __ str(rscratch2, Address(sp, st_off));\n-      }\n-    } else if (r_1->is_Register()) {  \/\/ Register argument\n-      Register r = r_1->as_Register();\n-      if (r_2->is_valid()) {\n-        \/\/\n-        \/\/ We are using two VMRegs. This can be either T_OBJECT,\n-        \/\/ T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates\n-        \/\/ two slots but only uses one for thr T_LONG or T_DOUBLE case\n-        \/\/ So we must adjust where to pick up the data to match the\n-        \/\/ interpreter.\n-\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n-                           next_off : ld_off;\n+         __ str(rscratch2, Address(sp, st_off));\n+       }\n+     } else if (r_1->is_Register()) {  \/\/ Register argument\n+       Register r = r_1->as_Register();\n+       if (r_2->is_valid()) {\n+         \/\/\n+         \/\/ We are using two VMRegs. This can be either T_OBJECT,\n+         \/\/ T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates\n+         \/\/ two slots but only uses one for thr T_LONG or T_DOUBLE case\n+         \/\/ So we must adjust where to pick up the data to match the\n+         \/\/ interpreter.\n+\n+        const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;\n+\n+         \/\/ this can be a misaligned move\n+         __ ldr(r, Address(esp, offset));\n+       } else {\n+         \/\/ sign extend and use a full word?\n+         __ ldrw(r, Address(esp, ld_off));\n+       }\n+     } else {\n+       if (!r_2->is_valid()) {\n+         __ ldrs(r_1->as_FloatRegister(), Address(esp, ld_off));\n+       } else {\n+         __ ldrd(r_1->as_FloatRegister(), Address(esp, next_off));\n+       }\n+     }\n+   }\n@@ -695,14 +953,0 @@\n-        \/\/ this can be a misaligned move\n-        __ ldr(r, Address(esp, offset));\n-      } else {\n-        \/\/ sign extend and use a full word?\n-        __ ldrw(r, Address(esp, ld_off));\n-      }\n-    } else {\n-      if (!r_2->is_valid()) {\n-        __ ldrs(r_1->as_FloatRegister(), Address(esp, ld_off));\n-      } else {\n-        __ ldrd(r_1->as_FloatRegister(), Address(esp, next_off));\n-      }\n-    }\n-  }\n@@ -725,1 +969,0 @@\n-\n@@ -729,13 +972,1 @@\n-\/\/ ---------------------------------------------------------------\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n-  address i2c_entry = __ pc();\n-\n-  gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);\n-\n-  address c2i_unverified_entry = __ pc();\n-  Label skip_fixup;\n+static void gen_inline_cache_check(MacroAssembler *masm, Label& skip_fixup) {\n@@ -776,0 +1007,2 @@\n+}\n+\n@@ -777,0 +1010,33 @@\n+\/\/ ---------------------------------------------------------------\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n+                                                            int comp_args_on_stack,\n+                                                            const GrowableArray<SigEntry>* sig,\n+                                                            const VMRegPair* regs,\n+                                                            const GrowableArray<SigEntry>* sig_cc,\n+                                                            const VMRegPair* regs_cc,\n+                                                            const GrowableArray<SigEntry>* sig_cc_ro,\n+                                                            const VMRegPair* regs_cc_ro,\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n+\n+  address i2c_entry = __ pc();\n+  gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);\n+\n+  address c2i_unverified_entry = __ pc();\n+  Label skip_fixup;\n+\n+  gen_inline_cache_check(masm, skip_fixup);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  int frame_complete = CodeOffsets::frame_never_safe;\n+  int frame_size_in_words = 0;\n+\n+  \/\/ Scalarized c2i adapter with non-scalarized receiver (i.e., don't pack receiver)\n+  address c2i_inline_ro_entry = __ pc();\n+  if (regs_cc != regs_cc_ro) {\n+    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+    skip_fixup.reset();\n+  }\n+\n+  \/\/ Scalarized c2i adapter\n@@ -801,1 +1067,14 @@\n-  gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);\n+  gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);\n+\n+  address c2i_unverified_inline_entry = c2i_unverified_entry;\n+\n+  \/\/ Non-scalarized c2i adapter\n+  address c2i_inline_entry = c2i_entry;\n+  if (regs != regs_cc) {\n+    Label inline_entry_skip_fixup;\n+    c2i_unverified_inline_entry = __ pc();\n+    gen_inline_cache_check(masm, inline_entry_skip_fixup);\n+\n+    c2i_inline_entry = __ pc();\n+    gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+  }\n@@ -804,1 +1083,9 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+\n+  \/\/ The c2i adapter might safepoint and trigger a GC. The caller must make sure that\n+  \/\/ the GC knows about the location of oop argument locations passed to the c2i adapter.\n+  if (allocate_code_blob) {\n+    bool caller_must_gc_arguments = (regs != regs_cc);\n+    new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  }\n+\n+  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -852,0 +1139,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1514,0 +1802,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1629,0 +1918,4 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        __ andr(swap_reg, swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+      }\n@@ -1694,0 +1987,1 @@\n+  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n@@ -2943,0 +3237,121 @@\n+\n+BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {\n+  BufferBlob* buf = BufferBlob::create(\"inline types pack\/unpack\", 16 * K);\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  MacroAssembler _masm(&buffer);\n+  MacroAssembler* masm = &_masm;\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  int pack_fields_jobject_off = __ offset();\n+  \/\/ Resolve pre-allocated buffer from JNI handle.\n+  \/\/ We cannot do this in generate_call_stub() because it requires GC code to be initialized.\n+  Register Rresult = r14;  \/\/ See StubGenerator::generate_call_stub().\n+  __ ldr(r0, Address(Rresult));\n+  __ resolve_jobject(r0 \/* value *\/,\n+                     rthread \/* thread *\/,\n+                     r12 \/* tmp *\/);\n+  __ str(r0, Address(Rresult));\n+\n+  int pack_fields_off = __ offset();\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address to(r0, off);\n+    if (bt == T_FLOAT) {\n+      __ strs(r_1->as_FloatRegister(), to);\n+    } else if (bt == T_DOUBLE) {\n+      __ strd(r_1->as_FloatRegister(), to);\n+    } else if (bt == T_OBJECT || bt == T_ARRAY) {\n+      Register val = r_1->as_Register();\n+      assert_different_registers(r0, val);\n+      \/\/ We don't need barriers because the destination is a newly allocated object.\n+      \/\/ Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.\n+      if (UseCompressedOops) {\n+        __ encode_heap_oop(val);\n+        __ str(val, to);\n+      } else {\n+        __ str(val, to);\n+      }\n+    } else {\n+      assert(is_java_primitive(bt), \"unexpected basic type\");\n+      assert_different_registers(r0, r_1->as_Register());\n+      size_t size_in_bytes = type2aelembytes(bt);\n+      __ store_sized_value(to, r_1->as_Register(), size_in_bytes);\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ ret(lr);\n+\n+  int unpack_fields_off = __ offset();\n+\n+  Label skip;\n+  __ cbz(r0, skip);\n+\n+  j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address from(r0, off);\n+    if (bt == T_FLOAT) {\n+      __ ldrs(r_1->as_FloatRegister(), from);\n+    } else if (bt == T_DOUBLE) {\n+      __ ldrd(r_1->as_FloatRegister(), from);\n+    } else if (bt == T_OBJECT || bt == T_ARRAY) {\n+      assert_different_registers(r0, r_1->as_Register());\n+      __ load_heap_oop(r_1->as_Register(), from);\n+    } else {\n+      assert(is_java_primitive(bt), \"unexpected basic type\");\n+      assert_different_registers(r0, r_1->as_Register());\n+\n+      size_t size_in_bytes = type2aelembytes(bt);\n+      __ load_sized_value(r_1->as_Register(), from, size_in_bytes, bt != T_CHAR && bt != T_BOOLEAN);\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ bind(skip);\n+\n+  __ ret(lr);\n+\n+  __ flush();\n+\n+  return BufferedInlineTypeBlob::create(&buffer, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":571,"deletions":156,"binary":false,"changes":727,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-    \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+    \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n@@ -323,4 +323,13 @@\n-    __ ldr(j_rarg2, result);\n-    Label is_long, is_float, is_double, exit;\n-    __ ldr(j_rarg1, result_type);\n-    __ cmp(j_rarg1, (u1)T_OBJECT);\n+    \/\/ All of j_rargN may be used to return inline type fields so be careful\n+    \/\/ not to clobber those.\n+    \/\/ SharedRuntime::generate_buffered_inline_type_adapter() knows the register\n+    \/\/ assignment of Rresult below.\n+    Register Rresult = r14, Rresult_type = r15;\n+    __ ldr(Rresult, result);\n+    Label is_long, is_float, is_double, check_prim, exit;\n+    __ ldr(Rresult_type, result_type);\n+    __ cmp(Rresult_type, (u1)T_OBJECT);\n+    __ br(Assembler::EQ, check_prim);\n+    __ cmp(Rresult_type, (u1)T_PRIMITIVE_OBJECT);\n+    __ br(Assembler::EQ, check_prim);\n+    __ cmp(Rresult_type, (u1)T_LONG);\n@@ -328,3 +337,1 @@\n-    __ cmp(j_rarg1, (u1)T_LONG);\n-    __ br(Assembler::EQ, is_long);\n-    __ cmp(j_rarg1, (u1)T_FLOAT);\n+    __ cmp(Rresult_type, (u1)T_FLOAT);\n@@ -332,1 +339,1 @@\n-    __ cmp(j_rarg1, (u1)T_DOUBLE);\n+    __ cmp(Rresult_type, (u1)T_DOUBLE);\n@@ -336,1 +343,1 @@\n-    __ strw(r0, Address(j_rarg2));\n+    __ strw(r0, Address(Rresult));\n@@ -384,0 +391,11 @@\n+    __ BIND(check_prim);\n+    if (InlineTypeReturnedAsFields) {\n+      \/\/ Check for scalarized return value\n+      __ tbz(r0, 0, is_long);\n+      \/\/ Load pack handler address\n+      __ andr(rscratch1, r0, -2);\n+      __ ldr(rscratch1, Address(rscratch1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      __ ldr(rscratch1, Address(rscratch1, InlineKlass::pack_handler_jobject_offset()));\n+      __ blr(rscratch1);\n+      __ b(exit);\n+    }\n@@ -386,1 +404,1 @@\n-    __ str(r0, Address(j_rarg2, 0));\n+    __ str(r0, Address(Rresult, 0));\n@@ -390,1 +408,1 @@\n-    __ strs(j_farg0, Address(j_rarg2, 0));\n+    __ strs(j_farg0, Address(Rresult, 0));\n@@ -394,1 +412,1 @@\n-    __ strd(j_farg0, Address(j_rarg2, 0));\n+    __ strd(j_farg0, Address(Rresult, 0));\n@@ -1856,1 +1874,1 @@\n-    __ store_heap_oop(__ post(to, UseCompressedOops ? 4 : 8), copied_oop, noreg, noreg, AS_RAW);  \/\/ store the oop\n+    __ store_heap_oop(__ post(to, UseCompressedOops ? 4 : 8), copied_oop, noreg, noreg, noreg, AS_RAW);  \/\/ store the oop\n@@ -2103,0 +2121,8 @@\n+    \/\/ Check for flat inline type array -> return -1\n+    __ tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    __ br(Assembler::NE, L_failed);\n+\n+    \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n+    __ tst(lh, Klass::_lh_null_free_array_bit_inplace);\n+    __ br(Assembler::NE, L_failed);\n+\n@@ -7795,0 +7821,128 @@\n+  \/\/ Call here from the interpreter or compiled code to either load\n+  \/\/ multiple returned values from the inline type instance being\n+  \/\/ returned to registers or to store returned values to a newly\n+  \/\/ allocated inline type instance.\n+  address generate_return_value_stub(address destination, const char* name, bool has_res) {\n+    \/\/ We need to save all registers the calling convention may use so\n+    \/\/ the runtime calls read or update those registers. This needs to\n+    \/\/ be in sync with SharedRuntime::java_return_convention().\n+    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+    enum layout {\n+      j_rarg7_off = 0, j_rarg7_2,    \/\/ j_rarg7 is r0\n+      j_rarg6_off, j_rarg6_2,\n+      j_rarg5_off, j_rarg5_2,\n+      j_rarg4_off, j_rarg4_2,\n+      j_rarg3_off, j_rarg3_2,\n+      j_rarg2_off, j_rarg2_2,\n+      j_rarg1_off, j_rarg1_2,\n+      j_rarg0_off, j_rarg0_2,\n+\n+      j_farg7_off, j_farg7_2,\n+      j_farg6_off, j_farg6_2,\n+      j_farg5_off, j_farg5_2,\n+      j_farg4_off, j_farg4_2,\n+      j_farg3_off, j_farg3_2,\n+      j_farg2_off, j_farg2_2,\n+      j_farg1_off, j_farg1_2,\n+      j_farg0_off, j_farg0_2,\n+\n+      rfp_off, rfp_off2,\n+      return_off, return_off2,\n+\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    CodeBuffer code(name, 512, 64);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+    assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+    int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+    int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg7_off), j_rarg7->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg6_off), j_rarg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+    address start = __ pc();\n+\n+    __ enter(); \/\/ Save FP and LR before call\n+\n+    __ stpd(j_farg1, j_farg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg3, j_farg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg5, j_farg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg7, j_farg6, Address(__ pre(sp, -2 * wordSize)));\n+\n+    __ stp(j_rarg1, j_rarg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg3, j_rarg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg5, j_rarg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg7, j_rarg6, Address(__ pre(sp, -2 * wordSize)));\n+\n+    int frame_complete = __ offset();\n+\n+    \/\/ Set up last_Java_sp and last_Java_fp\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+    \/\/ Call runtime\n+    __ mov(c_rarg1, r0);\n+    __ mov(c_rarg0, rthread);\n+\n+    __ mov(rscratch1, destination);\n+    __ blr(rscratch1);\n+\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    __ reset_last_Java_frame(false);\n+\n+    __ ldp(j_rarg7, j_rarg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg5, j_rarg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg3, j_rarg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg1, j_rarg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ ldpd(j_farg7, j_farg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg5, j_farg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg3, j_farg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg1, j_farg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ leave();\n+\n+    \/\/ check for pending exceptions\n+    Label pending;\n+    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    __ cbnz(rscratch1, pending);\n+\n+    if (has_res) {\n+      __ get_vm_result(r0, rthread);\n+    }\n+\n+    __ ret(lr);\n+\n+    __ bind(pending);\n+    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+    \/\/ -------------\n+    \/\/ make sure all code is generated\n+    masm->flush();\n+\n+    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, frame_size_in_words, oop_maps, false);\n+    return stub->entry_point();\n+  }\n+\n@@ -7844,0 +7998,7 @@\n+\n+    if (InlineTypeReturnedAsFields) {\n+      StubRoutines::_load_inline_type_fields_in_regs =\n+         generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs), \"load_inline_type_fields_in_regs\", false);\n+      StubRoutines::_store_inline_type_fields_to_buf =\n+         generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf), \"store_inline_type_fields_to_buf\", true);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":175,"deletions":14,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -441,0 +442,5 @@\n+\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    __ store_inline_type_fields_to_buf(NULL, true);\n+  }\n+\n@@ -546,0 +552,1 @@\n+  case T_PRIMITIVE_OBJECT: \/\/ fall through (value types are handled with oops)\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  __ store_heap_oop(dst, val, r10, r1, decorators);\n+  __ store_heap_oop(dst, val, r10, r1, noreg, decorators);\n@@ -171,0 +171,1 @@\n+  case Bytecodes::_fast_qputfield:\n@@ -330,0 +331,1 @@\n+  __ andr(r3, r3, ~JVM_CONSTANT_QDescBit);\n@@ -747,4 +749,4 @@\n-    \/\/ ??? convention: move array into r3 for exception message\n-  __ mov(r3, array);\n-  __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n-  __ br(rscratch1);\n+  \/\/ ??? convention: move array into r3 for exception message\n+   __ mov(r3, array);\n+   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n+   __ br(rscratch1);\n@@ -810,5 +812,17 @@\n-  __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n-  do_oop_load(_masm,\n-              Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),\n-              r0,\n-              IS_ARRAY);\n+  __ profile_array(r2, r0, r4);\n+  if (UseFlatArray) {\n+    Label is_flat_array, done;\n+\n+    __ test_flattened_array_oop(r0, r8 \/*temp*\/, is_flat_array);\n+    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n+    do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);\n+\n+    __ b(done);\n+    __ bind(is_flat_array);\n+    __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), r0, r1);\n+    __ bind(done);\n+  } else {\n+    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n+    do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);\n+  }\n+  __ profile_element(r2, r0, r4);\n@@ -1101,1 +1115,1 @@\n-  Label is_null, ok_is_subtype, done;\n+  Label is_null, is_flat_array, ok_is_subtype, done;\n@@ -1108,2 +1122,4 @@\n-  Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));\n-\n+\n+  __ profile_array(r4, r3, r5);\n+  __ profile_element(r4, r0, r5);\n+\n@@ -1112,0 +1128,2 @@\n+  Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));\n+  \/\/ Be careful not to clobber r4 below\n@@ -1116,0 +1134,8 @@\n+  \/\/ Move array class to r5\n+  __ load_klass(r5, r3);\n+\n+  if (UseFlatArray) {\n+    __ ldrw(r6, Address(r5, Klass::layout_helper_offset()));\n+    __ test_flattened_array_layout(r6, is_flat_array);\n+  }\n+\n@@ -1118,4 +1144,3 @@\n-  \/\/ Move superklass into r0\n-  __ load_klass(r0, r3);\n-  __ ldr(r0, Address(r0,\n-                     ObjArrayKlass::element_klass_offset()));\n+\n+  \/\/ Move array element superklass into r0\n+  __ ldr(r0, Address(r5, ObjArrayKlass::element_klass_offset()));\n@@ -1126,1 +1151,3 @@\n-  __ gen_subtype_check(r1, ok_is_subtype);\n+\n+  \/\/ is \"r1 <: r0\" ? (value subclass <: array element superclass)\n+  __ gen_subtype_check(r1, ok_is_subtype, false);\n@@ -1143,1 +1170,12 @@\n-  __ profile_null_seen(r2);\n+  if (EnableValhalla) {\n+    Label is_null_into_value_array_npe, store_null;\n+\n+    \/\/ No way to store null in flat null-free array\n+    __ test_null_free_array_oop(r3, r8, is_null_into_value_array_npe);\n+    __ b(store_null);\n+\n+    __ bind(is_null_into_value_array_npe);\n+    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+\n+    __ bind(store_null);\n+  }\n@@ -1147,0 +1185,41 @@\n+  __ b(done);\n+\n+  if (EnableValhalla) {\n+     Label is_type_ok;\n+    __ bind(is_flat_array); \/\/ Store non-null value to flat\n+\n+    \/\/ Simplistic type check...\n+    \/\/ r0 - value, r2 - index, r3 - array.\n+\n+    \/\/ Profile the not-null value's klass.\n+    \/\/ Load value class\n+     __ load_klass(r1, r0);\n+\n+    \/\/ Move element klass into r7\n+     __ ldr(r7, Address(r5, ArrayKlass::element_klass_offset()));\n+\n+    \/\/ flat value array needs exact type match\n+    \/\/ is \"r1 == r7\" (value subclass == array element superclass)\n+\n+     __ cmp(r7, r1);\n+     __ br(Assembler::EQ, is_type_ok);\n+\n+     __ b(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n+\n+     __ bind(is_type_ok);\n+    \/\/ r1: value's klass\n+    \/\/ r3: array\n+    \/\/ r5: array klass\n+    __ test_klass_is_empty_inline_type(r1, r7, done);\n+\n+    \/\/ calc dst for copy\n+    __ ldrw(r7, at_tos_p1()); \/\/ index\n+    __ data_for_value_array_index(r3, r5, r7, r7);\n+\n+    \/\/ ...and src for copy\n+    __ ldr(r6, at_tos());  \/\/ value\n+    __ data_for_oop(r6, r6, r1);\n+\n+    __ mov(r4, r1);  \/\/ Shuffle arguments to avoid conflict with c_rarg1\n+    __ access_value_copy(IN_HEAP, r6, r7, r4);\n+  }\n@@ -1957,2 +2036,1 @@\n-void TemplateTable::if_acmp(Condition cc)\n-{\n+void TemplateTable::if_acmp(Condition cc) {\n@@ -1961,1 +2039,1 @@\n-  Label not_taken;\n+  Label taken, not_taken;\n@@ -1963,0 +2041,38 @@\n+\n+  __ profile_acmp(r2, r1, r0, r4);\n+\n+  Register is_inline_type_mask = rscratch1;\n+  __ mov(is_inline_type_mask, markWord::inline_type_pattern);\n+\n+  if (EnableValhalla) {\n+    __ cmp(r1, r0);\n+    __ br(Assembler::EQ, (cc == equal) ? taken : not_taken);\n+\n+    \/\/ might be substitutable, test if either r0 or r1 is null\n+    __ andr(r2, r0, r1);\n+    __ cbz(r2, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ and both are values ?\n+    __ ldr(r2, Address(r1, oopDesc::mark_offset_in_bytes()));\n+    __ andr(r2, r2, is_inline_type_mask);\n+    __ ldr(r4, Address(r0, oopDesc::mark_offset_in_bytes()));\n+    __ andr(r4, r4, is_inline_type_mask);\n+    __ andr(r2, r2, r4);\n+    __ cmp(r2,  is_inline_type_mask);\n+    __ br(Assembler::NE, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ same value klass ?\n+    __ load_metadata(r2, r1);\n+    __ load_metadata(r4, r0);\n+    __ cmp(r2, r4);\n+    __ br(Assembler::NE, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ Know both are the same type, let's test for substitutability...\n+    if (cc == equal) {\n+      invoke_is_substitutable(r0, r1, taken, not_taken);\n+    } else {\n+      invoke_is_substitutable(r0, r1, not_taken, taken);\n+    }\n+    __ stop(\"Not reachable\");\n+  }\n+\n@@ -1965,0 +2081,1 @@\n+  __ bind(taken);\n@@ -1967,1 +2084,10 @@\n-  __ profile_not_taken_branch(r0);\n+  __ profile_not_taken_branch(r0, true);\n+}\n+\n+void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,\n+                                            Label& is_subst, Label& not_subst) {\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);\n+  \/\/ Restored... r0 answer, jmp to outcome...\n+  __ cbz(r0, not_subst);\n+  __ b(is_subst);\n@@ -1970,0 +2096,1 @@\n+\n@@ -2307,1 +2434,1 @@\n-                                          ConstantPoolCacheEntry::f2_offset())));\n+                                      ConstantPoolCacheEntry::f2_offset())));\n@@ -2310,1 +2437,1 @@\n-                                           ConstantPoolCacheEntry::flags_offset())));\n+                                         ConstantPoolCacheEntry::flags_offset())));\n@@ -2408,0 +2535,2 @@\n+  const Register klass = r5;\n+  const Register inline_klass = r7;\n@@ -2440,0 +2569,5 @@\n+  if (!is_static) {\n+    __ ldr(klass, Address(cache, in_bytes(ConstantPoolCache::base_offset() +\n+                                          ConstantPoolCacheEntry::f1_offset())));\n+  }\n+\n@@ -2442,2 +2576,1 @@\n-  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,\n-           ConstantPoolCacheEntry::tos_state_bits);\n+  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift, ConstantPoolCacheEntry::tos_state_bits);\n@@ -2478,4 +2611,70 @@\n-  do_oop_load(_masm, field, r0, IN_HEAP);\n-  __ push(atos);\n-  if (rc == may_rewrite) {\n-    patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+  if (!EnableValhalla) {\n+    do_oop_load(_masm, field, r0, IN_HEAP);\n+    __ push(atos);\n+    if (rc == may_rewrite) {\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+    }\n+    __ b(Done);\n+  } else { \/\/ Valhalla\n+    if (is_static) {\n+      __ load_heap_oop(r0, field);\n+      Label is_null_free_inline_type, uninitialized;\n+      \/\/ Issue below if the static field has not been initialized yet\n+      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_null_free_inline_type);\n+        \/\/ field is not a null free inline type\n+        __ push(atos);\n+        __ b(Done);\n+      \/\/ field is a null free inline type, must not return null even if uninitialized\n+      __ bind(is_null_free_inline_type);\n+        __ cbz(r0, uninitialized);\n+          __ push(atos);\n+          __ b(Done);\n+        __ bind(uninitialized);\n+          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+          Label slow_case, finish;\n+          __ ldrb(rscratch1, Address(cache, InstanceKlass::init_state_offset()));\n+          __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);\n+          __ br(Assembler::NE, slow_case);\n+          __ get_default_value_oop(klass, off \/* temp *\/, r0);\n+        __ b(finish);\n+        __ bind(slow_case);\n+          __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, raw_flags);\n+          __ bind(finish);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+          __ b(Done);\n+    } else {\n+      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_inline_type);\n+        \/\/ Non-inline field case\n+        __ load_heap_oop(r0, field);\n+        __ push(atos);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+        }\n+        __ b(Done);\n+      __ bind(is_inline_type);\n+        __ test_field_is_inlined(raw_flags, noreg \/* temp *\/, is_inlined);\n+         \/\/ field is not inlined\n+          __ load_heap_oop(r0, field);\n+          __ cbnz(r0, nonnull);\n+            __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+            __ get_inline_type_field_klass(klass, raw_flags, inline_klass);\n+            __ get_default_value_oop(inline_klass, klass \/* temp *\/, r0);\n+          __ bind(nonnull);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+          __ b(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+          __ mov(r0, obj);\n+          __ read_inlined_field(klass, raw_flags, off, inline_klass \/* temp *\/, r0);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+      __ bind(rewrite_inline);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);\n+      }\n+      __ b(Done);\n+    }\n@@ -2483,1 +2682,0 @@\n-  __ b(Done);\n@@ -2653,0 +2851,1 @@\n+  const Register flags2 = r6;\n@@ -2654,0 +2853,1 @@\n+  const Register inline_klass = r5;\n@@ -2675,0 +2875,2 @@\n+  __ mov(flags2, flags);\n+\n@@ -2717,8 +2919,54 @@\n-    __ pop(atos);\n-    if (!is_static) pop_and_check_object(obj);\n-    \/\/ Store into the field\n-    do_oop_store(_masm, field, r0, IN_HEAP);\n-    if (rc == may_rewrite) {\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);\n-    }\n-    __ b(Done);\n+     if (!EnableValhalla) {\n+      __ pop(atos);\n+      if (!is_static) pop_and_check_object(obj);\n+      \/\/ Store into the field\n+      do_oop_store(_masm, field, r0, IN_HEAP);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);\n+      }\n+      __ b(Done);\n+     } else { \/\/ Valhalla\n+      __ pop(atos);\n+      if (is_static) {\n+        Label is_inline_type;\n+         __ test_field_is_not_null_free_inline_type(flags2, noreg \/* temp *\/, is_inline_type);\n+         __ null_check(r0);\n+         __ bind(is_inline_type);\n+         do_oop_store(_masm, field, r0, IN_HEAP);\n+         __ b(Done);\n+      } else {\n+        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        __ test_field_is_null_free_inline_type(flags2, noreg \/*temp*\/, is_inline_type);\n+        \/\/ Not an inline type\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, r0, IN_HEAP);\n+        __ bind(rewrite_not_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, r19, true, byte_no);\n+        }\n+        __ b(Done);\n+        \/\/ Implementation of the inline type semantic\n+        __ bind(is_inline_type);\n+        __ null_check(r0);\n+        __ test_field_is_inlined(flags2, noreg \/*temp*\/, is_inlined);\n+        \/\/ field is not inlined\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, r0, IN_HEAP);\n+        __ b(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+        pop_and_check_object(obj);\n+        assert_different_registers(r0, inline_klass, obj, off);\n+        __ load_klass(inline_klass, r0);\n+        __ data_for_oop(r0, r0, inline_klass);\n+        __ add(obj, obj, off);\n+        __ access_value_copy(IN_HEAP, r0, obj, inline_klass);\n+        __ bind(rewrite_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_qputfield, bc, r19, true, byte_no);\n+        }\n+        __ b(Done);\n+      }\n+     }  \/\/ Valhalla\n@@ -2864,0 +3112,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -2890,0 +3139,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -2943,0 +3193,17 @@\n+  case Bytecodes::_fast_qputfield: \/\/fall through\n+   {\n+      Label is_inlined, done;\n+      __ null_check(r0);\n+      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n+      \/\/ field is not inlined\n+      do_oop_store(_masm, field, r0, IN_HEAP);\n+      __ b(done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+      __ load_klass(r4, r0);\n+      __ data_for_oop(r0, r0, r4);\n+      __ lea(rscratch1, field);\n+      __ access_value_copy(IN_HEAP, r0, rscratch1, r4);\n+      __ bind(done);\n+    }\n+    break;\n@@ -3040,0 +3307,26 @@\n+  case Bytecodes::_fast_qgetfield:\n+    {\n+      Register index = r4, klass = r5, inline_klass = r6, tmp = r7;\n+      Label is_inlined, nonnull, Done;\n+      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n+        \/\/ field is not inlined\n+        __ load_heap_oop(r0, field);\n+        __ cbnz(r0, nonnull);\n+          __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n+          __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n+                                             ConstantPoolCacheEntry::f1_offset())));\n+          __ get_inline_type_field_klass(klass, index, inline_klass);\n+          __ get_default_value_oop(inline_klass, tmp \/* temp *\/, r0);\n+        __ bind(nonnull);\n+        __ verify_oop(r0);\n+        __ b(Done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+        __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n+        __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n+                                           ConstantPoolCacheEntry::f1_offset())));\n+        __ read_inlined_field(klass, index, r1, tmp \/* temp *\/, r0);\n+        __ verify_oop(r0);\n+      __ bind(Done);\n+    }\n+    break;\n@@ -3470,0 +3763,1 @@\n+  Label is_not_value;\n@@ -3486,0 +3780,8 @@\n+  __ ldrb(rscratch1, Address(r4, InstanceKlass::kind_offset()));\n+  __ cmp(rscratch1, (u1)InlineKlassKind);\n+  __ br(Assembler::NE, is_not_value);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n+\n+  __ bind(is_not_value);\n+\n@@ -3492,57 +3794,2 @@\n-  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n-  __ ldrw(r3,\n-          Address(r4,\n-                  Klass::layout_helper_offset()));\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n-  __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);\n-\n-  \/\/ Allocate the instance:\n-  \/\/  If TLAB is enabled:\n-  \/\/    Try to allocate in the TLAB.\n-  \/\/    If fails, go to the slow path.\n-  \/\/    Initialize the allocation.\n-  \/\/    Exit.\n-  \/\/\n-  \/\/  Go to slow path.\n-\n-  if (UseTLAB) {\n-    __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);\n-\n-    if (ZeroTLAB) {\n-      \/\/ the fields have been already cleared\n-      __ b(initialize_header);\n-    }\n-\n-    \/\/ The object is initialized before the header.  If the object size is\n-    \/\/ zero, go directly to the header initialization.\n-    __ sub(r3, r3, sizeof(oopDesc));\n-    __ cbz(r3, initialize_header);\n-\n-    \/\/ Initialize object fields\n-    {\n-      __ add(r2, r0, sizeof(oopDesc));\n-      Label loop;\n-      __ bind(loop);\n-      __ str(zr, Address(__ post(r2, BytesPerLong)));\n-      __ sub(r3, r3, BytesPerLong);\n-      __ cbnz(r3, loop);\n-    }\n-\n-    \/\/ initialize object header only.\n-    __ bind(initialize_header);\n-    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n-    __ store_klass_gap(r0, zr);  \/\/ zero klass gap for compressed oops\n-    __ store_klass(r0, r4);      \/\/ store klass last\n-\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false);\n-      \/\/ Trigger dtrace event for fastpath\n-      __ push(atos); \/\/ save the return value\n-      __ call_VM_leaf(\n-           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), r0);\n-      __ pop(atos); \/\/ restore the return value\n-\n-    }\n-    __ b(done);\n-  }\n+  __ allocate_instance(r4, r0, r3, r1, true, slow_case);\n+  __ b(done);\n@@ -3563,0 +3810,29 @@\n+void TemplateTable::aconst_init() {\n+  transition(vtos, atos);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  __ get_constant_pool(c_rarg1);\n+  call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n+          c_rarg1, c_rarg2);\n+  __ verify_oop(r0);\n+  \/\/ Must prevent reordering of stores for object initialization with stores that publish the new object.\n+  __ membar(Assembler::StoreStore);\n+}\n+\n+void TemplateTable::withfield() {\n+  transition(vtos, atos);\n+  resolve_cache_and_index(f2_byte, c_rarg1 \/*cache*\/, c_rarg2 \/*index*\/, sizeof(u2));\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  \/\/ n.b. unlike x86 cache is now rcpool plus the indexed offset\n+  __ lea(c_rarg1, Address(c_rarg1, in_bytes(cp_base_offset)));\n+\n+  __ lea(c_rarg2, at_tos());\n+  call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), c_rarg1, c_rarg2);\n+  \/\/ new value type is returned in r1\n+  \/\/ stack adjustment is returned in r0\n+  __ verify_oop(r1);\n+  __ add(esp, esp, r0);\n+  __ mov(r0, r1);\n+}\n+\n@@ -3603,0 +3879,1 @@\n+  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -3634,0 +3911,3 @@\n+  __ b(done);\n+  __ bind(is_null);\n+\n@@ -3636,4 +3916,16 @@\n-    __ b(done);\n-    __ bind(is_null);\n-  } else {\n-    __ bind(is_null);   \/\/ same as 'done'\n+\n+  if (EnableValhalla) {\n+    \/\/ Get cpool & tags index\n+    __ get_cpool_and_tags(r2, r3); \/\/ r2=cpool, r3=tags array\n+    __ get_unsigned_2_byte_index_at_bcp(r19, 1); \/\/ r19=index\n+     \/\/ See if bytecode has already been quicked\n+    __ add(rscratch1, r3, Array<u1>::base_offset_in_bytes());\n+    __ lea(r1, Address(rscratch1, r19));\n+    __ ldarb(r1, r1);\n+    \/\/ See if CP entry is a Q-descriptor\n+    __ andr (r1, r1, JVM_CONSTANT_QDescBit);\n+    __ cmp(r1, (u1) JVM_CONSTANT_QDescBit);\n+    __ br(Assembler::NE, done);\n+    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+  }\n+\n@@ -3657,0 +3949,1 @@\n+  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -3760,0 +4053,4 @@\n+  Label is_inline_type;\n+  __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+  __ test_markword_is_inline_type(rscratch1, is_inline_type);\n+\n@@ -3853,0 +4150,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -3863,0 +4165,12 @@\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  Label has_identity;\n+  __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+  __ mov(rscratch2, is_inline_type_mask);\n+  __ andr(rscratch1, rscratch1, rscratch2);\n+  __ cmp(rscratch1, rscratch2);\n+  __ br(Assembler::NE, has_identity);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n+  __ bind(has_identity);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":415,"deletions":101,"binary":false,"changes":516,"status":"modified"},{"patch":"@@ -2571,0 +2571,4 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3202,0 +3202,3 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);\n+define_pd_global(bool, InlineTypeReturnedAsFields, false);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1813,1 +1813,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n@@ -1854,1 +1854,1 @@\n-    profile_obj_type(ret, R28_mdx, -in_bytes(ReturnTypeEntry::size()), tmp1, tmp2);\n+    profile_obj_type(ret, R28_mdx, -in_bytes(SingleTypeEntry::size()), tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3083,0 +3083,4 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1761,1 +1761,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n@@ -1810,1 +1810,1 @@\n-    Address mdo_ret_addr(mdp, -in_bytes(ReturnTypeEntry::size()));\n+    Address mdo_ret_addr(mdp, -in_bytes(SingleTypeEntry::size()));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+    case T_PRIMITIVE_OBJECT : i = 8; break;\n@@ -156,0 +157,1 @@\n+    case T_PRIMITIVE_OBJECT : i = 10; break;\n","filename":"src\/hotspot\/cpu\/x86\/abstractInterpreter_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -198,1 +200,1 @@\n-    if (const_opr->type() == T_OBJECT) {\n+    if (const_opr->type() == T_OBJECT || const_opr->type() == T_PRIMITIVE_OBJECT) {\n@@ -482,1 +484,1 @@\n-  __ remove_frame(initial_frame_size_in_bytes());\n+  __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());\n@@ -520,0 +522,16 @@\n+  ciMethod* method = compilation()->method();\n+  if (InlineTypeReturnedAsFields && method->return_type()->is_inlinetype()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n+    if (vk->can_be_returned_as_fields()) {\n+#ifndef _LP64\n+      Unimplemented();\n+#else\n+      address unpack_handler = vk->unpack_handler();\n+      assert(unpack_handler != NULL, \"must be\");\n+      __ call(RuntimeAddress(unpack_handler));\n+      \/\/ At this point, rax points to the value object (for interpreter or C1 caller).\n+      \/\/ The fields of the object are copied into registers (for C2 caller).\n+#endif\n+    }\n+  }\n+\n@@ -521,1 +539,1 @@\n-  __ remove_frame(initial_frame_size_in_bytes());\n+  __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());\n@@ -543,0 +561,4 @@\n+int LIR_Assembler::store_inline_type_fields_to_buf(ciInlineKlass* vk) {\n+  return (__ store_inline_type_fields_to_buf(vk, false));\n+}\n+\n@@ -603,0 +625,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -693,0 +716,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -732,0 +756,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -820,1 +845,1 @@\n-    if (src->type() == T_OBJECT) {\n+    if (src->type() == T_OBJECT || src->type() == T_PRIMITIVE_OBJECT) {\n@@ -1006,0 +1031,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1178,1 +1204,1 @@\n-  if (addr->base()->type() == T_OBJECT) {\n+  if (addr->base()->type() == T_OBJECT || addr->base()->type() == T_PRIMITIVE_OBJECT) {\n@@ -1239,0 +1265,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1615,1 +1642,1 @@\n-  if (UseSlowPath ||\n+  if (UseSlowPath || op->type() == T_PRIMITIVE_OBJECT ||\n@@ -1714,14 +1741,16 @@\n-  __ cmpptr(obj, (int32_t)NULL_WORD);\n-  if (op->should_profile()) {\n-    Label not_null;\n-    __ jccb(Assembler::notEqual, not_null);\n-    \/\/ Object is null; update MDO and exit\n-    Register mdo  = klass_RInfo;\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address data_addr(mdo, md->byte_offset_of_slot(data, DataLayout::flags_offset()));\n-    int header_bits = BitData::null_seen_byte_constant();\n-    __ orb(data_addr, header_bits);\n-    __ jmp(*obj_is_null);\n-    __ bind(not_null);\n-  } else {\n-    __ jcc(Assembler::equal, *obj_is_null);\n+  if (op->need_null_check()) {\n+    __ cmpptr(obj, (int32_t)NULL_WORD);\n+    if (op->should_profile()) {\n+      Label not_null;\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n+      Register mdo  = klass_RInfo;\n+      __ mov_metadata(mdo, md->constant_encoding());\n+      Address data_addr(mdo, md->byte_offset_of_slot(data, DataLayout::flags_offset()));\n+      int header_bits = BitData::null_seen_byte_constant();\n+      __ orb(data_addr, header_bits);\n+      __ jmp(*obj_is_null);\n+      __ bind(not_null);\n+    } else {\n+      __ jcc(Assembler::equal, *obj_is_null);\n+    }\n@@ -1939,0 +1968,124 @@\n+void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {\n+  \/\/ We are loading\/storing from\/to an array that *may* be flattened (the\n+  \/\/ declared type is Object[], abstract[], interface[] or VT.ref[]).\n+  \/\/ If this array is flattened, take the slow path.\n+  Register klass = op->tmp()->as_register();\n+  if (UseArrayMarkWordCheck) {\n+    __ test_flattened_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n+    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ testl(klass, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    __ jcc(Assembler::notZero, *op->stub()->entry());\n+  }\n+  if (!op->value()->is_illegal()) {\n+    \/\/ The array is not flattened, but it might be null-free. If we are storing\n+    \/\/ a null into a null-free array, take the slow path (which will throw NPE).\n+    Label skip;\n+    __ cmpptr(op->value()->as_register(), (int32_t)NULL_WORD);\n+    __ jcc(Assembler::notEqual, skip);\n+    if (UseArrayMarkWordCheck) {\n+      __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+    } else {\n+      __ testl(klass, Klass::_lh_null_free_array_bit_inplace);\n+      __ jcc(Assembler::notZero, *op->stub()->entry());\n+    }\n+    __ bind(skip);\n+  }\n+}\n+\n+void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {\n+  \/\/ We are storing into an array that *may* be null-free (the declared type is\n+  \/\/ Object[], abstract[], interface[] or VT.ref[]).\n+  if (UseArrayMarkWordCheck) {\n+    Label test_mark_word;\n+    Register tmp = op->tmp()->as_register();\n+    __ movptr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n+    __ testl(tmp, markWord::unlocked_value);\n+    __ jccb(Assembler::notZero, test_mark_word);\n+    __ load_prototype_header(tmp, op->array()->as_register(), rscratch1);\n+    __ bind(test_mark_word);\n+    __ testl(tmp, markWord::null_free_array_bit_in_place);\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    Register klass = op->tmp()->as_register();\n+    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n+    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ testl(klass, Klass::_lh_null_free_array_bit_inplace);\n+  }\n+}\n+\n+void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {\n+  Label L_oops_equal;\n+  Label L_oops_not_equal;\n+  Label L_end;\n+\n+  Register left  = op->left()->as_register();\n+  Register right = op->right()->as_register();\n+\n+  __ cmpptr(left, right);\n+  __ jcc(Assembler::equal, L_oops_equal);\n+\n+  \/\/ (1) Null check -- if one of the operands is null, the other must not be null (because\n+  \/\/     the two references are not equal), so they are not substitutable,\n+  \/\/     FIXME: do null check only if the operand is nullable\n+  __ testptr(left, right);\n+  __ jcc(Assembler::zero, L_oops_not_equal);\n+\n+  ciKlass* left_klass = op->left_klass();\n+  ciKlass* right_klass = op->right_klass();\n+\n+  \/\/ (2) Inline type check -- if either of the operands is not a inline type,\n+  \/\/     they are not substitutable. We do this only if we are not sure that the\n+  \/\/     operands are inline type\n+  if ((left_klass == NULL || right_klass == NULL) ||\/\/ The klass is still unloaded, or came from a Phi node.\n+      !left_klass->is_inlinetype() || !right_klass->is_inlinetype()) {\n+    Register tmp1  = op->tmp1()->as_register();\n+    __ movptr(tmp1, (intptr_t)markWord::inline_type_pattern);\n+    __ andptr(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));\n+    __ cmpptr(tmp1, (intptr_t)markWord::inline_type_pattern);\n+    __ jcc(Assembler::notEqual, L_oops_not_equal);\n+  }\n+\n+  \/\/ (3) Same klass check: if the operands are of different klasses, they are not substitutable.\n+  if (left_klass != NULL && left_klass->is_inlinetype() && left_klass == right_klass) {\n+    \/\/ No need to load klass -- the operands are statically known to be the same inline klass.\n+    __ jmp(*op->stub()->entry());\n+  } else {\n+    Register left_klass_op = op->left_klass_op()->as_register();\n+    Register right_klass_op = op->right_klass_op()->as_register();\n+\n+    if (UseCompressedClassPointers) {\n+      __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));\n+      __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));\n+      __ cmpl(left_klass_op, right_klass_op);\n+    } else {\n+      __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));\n+      __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));\n+      __ cmpptr(left_klass_op, right_klass_op);\n+    }\n+\n+    __ jcc(Assembler::equal, *op->stub()->entry()); \/\/ same klass -> do slow check\n+    \/\/ fall through to L_oops_not_equal\n+  }\n+\n+  __ bind(L_oops_not_equal);\n+  move(op->not_equal_result(), op->result_opr());\n+  __ jmp(L_end);\n+\n+  __ bind(L_oops_equal);\n+  move(op->equal_result(), op->result_opr());\n+  __ jmp(L_end);\n+\n+  \/\/ We've returned from the stub. RAX contains 0x0 IFF the two\n+  \/\/ operands are not substitutable. (Don't compare against 0x1 in case the\n+  \/\/ C compiler is naughty)\n+  __ bind(*op->stub()->continuation());\n+  __ cmpl(rax, 0);\n+  __ jcc(Assembler::equal, L_oops_not_equal); \/\/ (call_stub() == 0x0) -> not_equal\n+  move(op->equal_result(), op->result_opr()); \/\/ (call_stub() != 0x0) -> equal\n+  \/\/ fall-through\n+  __ bind(L_end);\n+}\n@@ -1999,0 +2152,15 @@\n+void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {\n+  assert(dst->is_cpu_register(), \"must be\");\n+  assert(dst->type() == src->type(), \"must be\");\n+\n+  if (src->is_cpu_register()) {\n+    reg2reg(src, dst);\n+  } else if (src->is_stack()) {\n+    stack2reg(src, dst, dst->type());\n+  } else if (src->is_constant()) {\n+    const2reg(src, dst, lir_patch_none, NULL);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n@@ -2866,1 +3034,1 @@\n-  add_call_info(code_offset(), op->info());\n+  add_call_info(code_offset(), op->info(), op->maybe_return_as_fields());\n@@ -2873,1 +3041,1 @@\n-  add_call_info(code_offset(), op->info());\n+  add_call_info(code_offset(), op->info(), op->maybe_return_as_fields());\n@@ -3054,0 +3222,26 @@\n+void LIR_Assembler::arraycopy_inlinetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {\n+  if (null_check) {\n+    __ testptr(obj, obj);\n+    __ jcc(Assembler::zero, *slow_path->entry());\n+  }\n+  if (UseArrayMarkWordCheck) {\n+    if (is_dest) {\n+      __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n+    } else {\n+      __ test_flattened_array_oop(obj, tmp, *slow_path->entry());\n+    }\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(tmp, obj, tmp_load_klass);\n+    __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));\n+    if (is_dest) {\n+      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains NULLs.\n+      __ testl(tmp, Klass::_lh_null_free_array_bit_inplace);\n+    } else {\n+      __ testl(tmp, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    }\n+    __ jcc(Assembler::notZero, *slow_path->entry());\n+  }\n+}\n+\n+\n@@ -3072,0 +3266,6 @@\n+  if (flags & LIR_OpArrayCopy::always_slow_path) {\n+    __ jmp(*stub->entry());\n+    __ bind(*stub->continuation());\n+    return;\n+  }\n+\n@@ -3165,0 +3365,8 @@\n+  \/\/ Handle inline type arrays\n+  if (flags & LIR_OpArrayCopy::src_inlinetype_check) {\n+    arraycopy_inlinetype_check(src, tmp, stub, false, (flags & LIR_OpArrayCopy::src_null_check));\n+  }\n+  if (flags & LIR_OpArrayCopy::dst_inlinetype_check) {\n+    arraycopy_inlinetype_check(dst, tmp, stub, true, (flags & LIR_OpArrayCopy::dst_null_check));\n+  }\n+\n@@ -3765,0 +3973,20 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Register obj = op->obj()->as_register();\n+  Register tmp = op->tmp()->as_pointer_register();\n+  Address mdo_addr = as_Address(op->mdp()->as_address_ptr());\n+  bool not_null = op->not_null();\n+  int flag = op->flag();\n+\n+  Label not_inline_type;\n+  if (!not_null) {\n+    __ testptr(obj, obj);\n+    __ jccb(Assembler::zero, not_inline_type);\n+  }\n+\n+  __ test_oop_is_not_inline_type(obj, tmp, not_inline_type);\n+\n+  __ orb(mdo_addr, flag);\n+\n+  __ bind(not_inline_type);\n+}\n+\n@@ -4026,0 +4254,3 @@\n+void LIR_Assembler::check_orig_pc() {\n+  __ cmpptr(frame_map()->address_for_orig_pc_addr(), (int32_t)NULL_WORD);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":253,"deletions":22,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -119,0 +120,13 @@\n+void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr& tmp1, LIR_Opr& tmp2) {\n+  \/\/ We just need one 32-bit temp register for x86\/x64, to check whether both\n+  \/\/ oops have markWord::always_locked_pattern. See LIR_Assembler::emit_opSubstitutabilityCheck().\n+  \/\/ @temp = %r10d\n+  \/\/ mov $0x405, %r10d\n+  \/\/ and (%left), %r10d   \/* if need to check left *\/\n+  \/\/ and (%right), %r10d  \/* if need to check right *\/\n+  \/\/ cmp $0x405, $r10d\n+  \/\/ jne L_oops_not_equal\n+  tmp1 = new_register(T_INT);\n+  tmp2 = LIR_OprFact::illegalOpr;\n+}\n+\n@@ -314,0 +328,5 @@\n+  \/\/ Need a scratch register for inline types on x86\n+  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n+  if (EnableValhalla && x->maybe_inlinetype()) {\n+    scratch = new_register(T_INT);\n+  }\n@@ -319,0 +338,6 @@\n+\n+  CodeStub* throw_imse_stub = x->maybe_inlinetype() ?\n+      new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id,\n+                              LIR_OprFact::illegalOpr, state_for(x))\n+    : NULL;\n+\n@@ -322,2 +347,2 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n-                        x->monitor_no(), info_for_exception, info);\n+  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+                x->monitor_no(), info_for_exception, info, throw_imse_stub);\n@@ -1301,5 +1326,6 @@\n-                       FrameMap::rcx_oop_opr,\n-                       FrameMap::rdi_oop_opr,\n-                       FrameMap::rsi_oop_opr,\n-                       LIR_OprFact::illegalOpr,\n-                       FrameMap::rdx_metadata_opr, info);\n+               \/* allow_inline *\/ false,\n+               FrameMap::rcx_oop_opr,\n+               FrameMap::rdi_oop_opr,\n+               FrameMap::rsi_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::rdx_metadata_opr, info);\n@@ -1310,0 +1336,15 @@\n+void LIRGenerator::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n+  \/\/ Mapping to do_NewInstance (same code) but use state_before for reexecution.\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+  x->set_to_object_type();\n+  LIR_Opr reg = result_register_for(x->type());\n+  new_instance(reg, x->klass(), false,\n+               \/* allow_inline *\/ true,\n+               FrameMap::rcx_oop_opr,\n+               FrameMap::rdi_oop_opr,\n+               FrameMap::rsi_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::rdx_metadata_opr, info);\n+  LIR_Opr result = rlock_result(x);\n+  __ move(reg, result);\n+}\n@@ -1357,2 +1398,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);\n-  ciKlass* obj = (ciKlass*) ciObjArrayKlass::make(x->klass());\n+  ciKlass* obj = (ciKlass*) x->exact_type();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n@@ -1363,1 +1404,5 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n+  if (x->is_null_free()) {\n+    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_PRIMITIVE_OBJECT, klass_reg, slow_path);\n+  } else {\n+    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n+  }\n@@ -1442,0 +1487,4 @@\n+  if (x->is_null_free()) {\n+    __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));\n+  }\n+\n@@ -1460,1 +1509,1 @@\n-               x->profiled_method(), x->profiled_bci());\n+               x->profiled_method(), x->profiled_bci(), x->is_null_free());\n@@ -1511,1 +1560,1 @@\n-  } else if (tag == longTag || tag == floatTag || tag == doubleTag) {\n+  } else if (tag == longTag || tag == floatTag || tag == doubleTag || x->substitutability_check()) {\n@@ -1531,1 +1580,5 @@\n-  __ cmp(lir_cond(cond), left, right);\n+  if (x->substitutability_check()) {\n+    substitutability_check(x, *xin, *yin);\n+  } else {\n+    __ cmp(lir_cond(cond), left, right);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":66,"deletions":13,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/frame.inline.hpp\"\n@@ -67,0 +68,4 @@\n+  if (EnableValhalla) {\n+    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+    andptr(hdr, ~((int) markWord::inline_type_bit_in_place));\n+  }\n@@ -149,2 +154,9 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n+  if (EnableValhalla) {\n+    \/\/ Need to copy markWord::prototype header for klass\n+    assert_different_registers(obj, klass, len, t1, t2);\n+    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+  } else {\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n+  }\n@@ -305,0 +317,12 @@\n+void C1_MacroAssembler::build_frame_helper(int frame_size_in_bytes, int sp_inc, bool needs_stack_repair) {\n+  push(rbp);\n+  if (PreserveFramePointer) {\n+    mov(rbp, rsp);\n+  }\n+#if !defined(_LP64) && defined(COMPILER2)\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n+      \/\/ c2 leaves fpu stack dirty. Clean it on entry\n+      empty_FPU_stack();\n+    }\n+#endif \/\/ !_LP64 && COMPILER2\n+  decrement(rsp, frame_size_in_bytes);\n@@ -306,2 +330,16 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n-  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n+  if (needs_stack_repair) {\n+    \/\/ Save stack increment (also account for fixed framesize and rbp)\n+    assert((sp_inc & (StackAlignmentInBytes-1)) == 0, \"stack increment not aligned\");\n+    int real_frame_size = sp_inc + frame_size_in_bytes + wordSize;\n+    movptr(Address(rsp, frame_size_in_bytes - wordSize), real_frame_size);\n+  }\n+}\n+\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, bool needs_stack_repair, bool has_scalarized_args, Label* verified_inline_entry_label) {\n+  if (has_scalarized_args) {\n+    \/\/ Initialize orig_pc to detect deoptimization during buffering in the entry points\n+    movptr(Address(rsp, sp_offset_for_orig_pc - frame_size_in_bytes - wordSize), 0);\n+  }\n+  if (!needs_stack_repair && verified_inline_entry_label != NULL) {\n+    bind(*verified_inline_entry_label);\n+  }\n@@ -313,0 +351,1 @@\n+  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n@@ -315,11 +354,1 @@\n-  push(rbp);\n-  if (PreserveFramePointer) {\n-    mov(rbp, rsp);\n-  }\n-#if !defined(_LP64) && defined(COMPILER2)\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n-    \/\/ c2 leaves fpu stack dirty. Clean it on entry\n-    empty_FPU_stack();\n-  }\n-#endif \/\/ !_LP64 && COMPILER2\n-  decrement(rsp, frame_size_in_bytes); \/\/ does not emit code for frame_size == 0\n+  build_frame_helper(frame_size_in_bytes, 0, needs_stack_repair);\n@@ -330,5 +359,5 @@\n-}\n-\n-void C1_MacroAssembler::remove_frame(int frame_size_in_bytes) {\n-  increment(rsp, frame_size_in_bytes);  \/\/ Does not emit code for frame_size == 0\n-  pop(rbp);\n+  if (needs_stack_repair && verified_inline_entry_label != NULL) {\n+    \/\/ Jump here from the scalarized entry points that require additional stack space\n+    \/\/ for packing scalarized arguments and therefore already created the frame.\n+    bind(*verified_inline_entry_label);\n+  }\n@@ -338,1 +367,0 @@\n-\n@@ -355,0 +383,62 @@\n+int C1_MacroAssembler::scalarized_entry(const CompiledEntrySignature* ces, int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, Label& verified_inline_entry_label, bool is_inline_ro_entry) {\n+  assert(InlineTypePassFieldsAsArgs, \"sanity\");\n+  \/\/ Make sure there is enough stack space for this method's activation.\n+  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n+  generate_stack_overflow_check(bang_size_in_bytes);\n+\n+  GrowableArray<SigEntry>* sig    = &ces->sig();\n+  GrowableArray<SigEntry>* sig_cc = is_inline_ro_entry ? &ces->sig_cc_ro() : &ces->sig_cc();\n+  VMRegPair* regs      = ces->regs();\n+  VMRegPair* regs_cc   = is_inline_ro_entry ? ces->regs_cc_ro() : ces->regs_cc();\n+  int args_on_stack    = ces->args_on_stack();\n+  int args_on_stack_cc = is_inline_ro_entry ? ces->args_on_stack_cc_ro() : ces->args_on_stack_cc();\n+\n+  assert(sig->length() <= sig_cc->length(), \"Zero-sized inline class not allowed!\");\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig_cc->length());\n+  int args_passed = sig->length();\n+  int args_passed_cc = SigEntry::fill_sig_bt(sig_cc, sig_bt);\n+\n+  \/\/ Check if we need to extend the stack for packing\n+  int sp_inc = 0;\n+  if (args_on_stack > args_on_stack_cc) {\n+    sp_inc = extend_stack_for_inline_args(args_on_stack);\n+  }\n+\n+  \/\/ Create a temp frame so we can call into the runtime. It must be properly set up to accommodate GC.\n+  build_frame_helper(frame_size_in_bytes, sp_inc, ces->c1_needs_stack_repair());\n+\n+  \/\/ Initialize orig_pc to detect deoptimization during buffering in below runtime call\n+  movptr(Address(rsp, sp_offset_for_orig_pc), 0);\n+\n+  \/\/ The runtime call might safepoint, make sure nmethod entry barrier is executed\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+\n+  \/\/ FIXME -- call runtime only if we cannot in-line allocate all the incoming inline type args.\n+  movptr(rbx, (intptr_t)(ces->method()));\n+  if (is_inline_ro_entry) {\n+    call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id)));\n+  } else {\n+    call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_id)));\n+  }\n+  int rt_call_offset = offset();\n+\n+  \/\/ Remove the temp frame\n+  addptr(rsp, frame_size_in_bytes);\n+  pop(rbp);\n+\n+  shuffle_inline_args(true, is_inline_ro_entry, sig_cc,\n+                      args_passed_cc, args_on_stack_cc, regs_cc, \/\/ from\n+                      args_passed, args_on_stack, regs,          \/\/ to\n+                      sp_inc, rax);\n+\n+  if (ces->c1_needs_stack_repair()) {\n+    \/\/ Create the real frame. Below jump will then skip over the stack banging and frame\n+    \/\/ setup code in the verified_inline_entry (which has a different real_frame_size).\n+    build_frame_helper(frame_size_in_bytes, sp_inc, true);\n+  }\n+\n+  jmp(verified_inline_entry_label);\n+  return rt_call_offset;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":111,"deletions":21,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -1018,0 +1018,1 @@\n+    case new_instance_no_inline_id:\n@@ -1026,0 +1027,2 @@\n+        } else if (id == new_instance_no_inline_id) {\n+          __ set_info(\"new_instance_no_inline\", dont_gc_arguments);\n@@ -1035,1 +1038,6 @@\n-        int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n+        int call_offset;\n+        if (id == new_instance_no_inline_id) {\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance_no_inline), klass);\n+        } else {\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n+        }\n@@ -1068,0 +1076,1 @@\n+    case new_flat_array_id:\n@@ -1075,1 +1084,1 @@\n-        } else {\n+        } else if (id == new_object_array_id) {\n@@ -1077,0 +1086,2 @@\n+        } else {\n+          __ set_info(\"new_flat_array\", dont_gc_arguments);\n@@ -1086,6 +1097,23 @@\n-          int tag = ((id == new_type_array_id)\n-                     ? Klass::_lh_array_tag_type_value\n-                     : Klass::_lh_array_tag_obj_value);\n-          __ cmpl(t0, tag);\n-          __ jcc(Assembler::equal, ok);\n-          __ stop(\"assert(is an array klass)\");\n+          switch (id) {\n+          case new_type_array_id:\n+            __ cmpl(t0, Klass::_lh_array_tag_type_value);\n+            __ jcc(Assembler::equal, ok);\n+            __ stop(\"assert(is a type array klass)\");\n+            break;\n+          case new_object_array_id:\n+            __ cmpl(t0, Klass::_lh_array_tag_obj_value); \/\/ new \"[Ljava\/lang\/Object;\"\n+            __ jcc(Assembler::equal, ok);\n+            __ cmpl(t0, Klass::_lh_array_tag_vt_value);  \/\/ new \"[LVT;\"\n+            __ jcc(Assembler::equal, ok);\n+            __ stop(\"assert(is an object or inline type array klass)\");\n+            break;\n+          case new_flat_array_id:\n+            \/\/ new \"[QVT;\"\n+            __ cmpl(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be flattened.\n+            __ jcc(Assembler::equal, ok);\n+            __ cmpl(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)\n+            __ jcc(Assembler::equal, ok);\n+            __ stop(\"assert(is an object or inline type array klass)\");\n+            break;\n+          default:  ShouldNotReachHere();\n+          }\n@@ -1102,1 +1130,1 @@\n-        } else {\n+        } else if (id == new_object_array_id) {\n@@ -1104,0 +1132,3 @@\n+        } else {\n+          assert(id == new_flat_array_id, \"must be\");\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_flat_array), klass, length);\n@@ -1135,0 +1166,77 @@\n+    case load_flattened_array_id:\n+      {\n+        StubFrame f(sasm, \"load_flattened_array\", dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm, 3);\n+\n+        \/\/ Called with store_parameter and not C abi\n+\n+        f.load_argument(1, rax); \/\/ rax,: array\n+        f.load_argument(0, rbx); \/\/ rbx,: index\n+        int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, load_flattened_array), rax, rbx);\n+\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_rax(sasm);\n+\n+        \/\/ rax,: loaded element at array[index]\n+        __ verify_oop(rax);\n+      }\n+      break;\n+\n+    case store_flattened_array_id:\n+      {\n+        StubFrame f(sasm, \"store_flattened_array\", dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm, 4);\n+\n+        \/\/ Called with store_parameter and not C abi\n+\n+        f.load_argument(2, rax); \/\/ rax,: array\n+        f.load_argument(1, rbx); \/\/ rbx,: index\n+        f.load_argument(0, rcx); \/\/ rcx,: value\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flattened_array), rax, rbx, rcx);\n+\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_rax(sasm);\n+      }\n+      break;\n+\n+    case substitutability_check_id:\n+      {\n+        StubFrame f(sasm, \"substitutability_check\", dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm, 3);\n+\n+        \/\/ Called with store_parameter and not C abi\n+\n+        f.load_argument(1, rax); \/\/ rax,: left\n+        f.load_argument(0, rbx); \/\/ rbx,: right\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, substitutability_check), rax, rbx);\n+\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_rax(sasm);\n+\n+        \/\/ rax,: are the two operands substitutable\n+      }\n+      break;\n+\n+\n+    case buffer_inline_args_id:\n+    case buffer_inline_args_no_receiver_id:\n+      {\n+        const char* name = (id == buffer_inline_args_id) ?\n+          \"buffer_inline_args\" : \"buffer_inline_args_no_receiver\";\n+        StubFrame f(sasm, name, dont_gc_arguments);\n+        OopMap* map = save_live_registers(sasm, 2);\n+        Register method = rbx;\n+        address entry = (id == buffer_inline_args_id) ?\n+          CAST_FROM_FN_PTR(address, buffer_inline_args) :\n+          CAST_FROM_FN_PTR(address, buffer_inline_args_no_receiver);\n+        int call_offset = __ call_RT(rax, noreg, entry, method);\n+        oop_maps = new OopMapSet();\n+        oop_maps->add_gc_map(call_offset, map);\n+        restore_live_registers_except_rax(sasm);\n+        __ verify_oop(rax);  \/\/ rax: an array of buffered value objects\n+      }\n+      break;\n+\n@@ -1237,1 +1345,1 @@\n-      { StubFrame f(sasm, \"throw_incompatible_class_cast_exception\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"throw_incompatible_class_change_error\", dont_gc_arguments);\n@@ -1242,0 +1350,6 @@\n+    case throw_illegal_monitor_state_exception_id:\n+      { StubFrame f(sasm, \"throw_illegal_monitor_state_exception\", dont_gc_arguments);\n+        oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_illegal_monitor_state_exception), false);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":124,"deletions":10,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -48,1 +48,5 @@\n-void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {\n+void C2_MacroAssembler::verified_entry(Compile* C, int sp_inc) {\n+  int framesize = C->output()->frame_size_in_bytes();\n+  int bangsize = C->output()->bang_size_in_bytes();\n+  bool fp_mode_24b = false;\n+  int stack_bang_size = C->output()->need_stack_bang(bangsize) ? bangsize : 0;\n@@ -101,0 +105,6 @@\n+  if (C->needs_stack_repair()) {\n+    \/\/ Save stack increment just below the saved rbp (also account for fixed framesize and rbp)\n+    assert((sp_inc & (StackAlignmentInBytes-1)) == 0, \"stack increment not aligned\");\n+    movptr(Address(rsp, framesize - wordSize), sp_inc + framesize + wordSize);\n+  }\n+\n@@ -129,23 +139,0 @@\n-\n-  if (!is_stub) {\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n- #ifdef _LP64\n-    if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n-      \/\/ We put the non-hot code of the nmethod entry barrier out-of-line in a stub.\n-      Label dummy_slow_path;\n-      Label dummy_continuation;\n-      Label* slow_path = &dummy_slow_path;\n-      Label* continuation = &dummy_continuation;\n-      if (!Compile::current()->output()->in_scratch_emit_size()) {\n-        \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n-        continuation = &stub->continuation();\n-      }\n-      bs->nmethod_entry_barrier(this, slow_path, continuation);\n-    }\n-#else\n-    \/\/ Don't bother with out-of-line nmethod entry barrier stub for x86_32.\n-    bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n-#endif\n-  }\n@@ -616,0 +603,4 @@\n+    if (EnableValhalla) {\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      andptr(tmpReg, ~((int) markWord::inline_type_bit_in_place));\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);\n+  void verified_entry(Compile* C, int sp_inc = 0);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,0 @@\n-      sender_unextended_sp = sender_sp;\n@@ -150,2 +149,2 @@\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n-    }\n+      intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n+      saved_fp = *saved_fp_addr;\n@@ -153,0 +152,4 @@\n+      \/\/ Repair the sender sp if this is a method with scalarized inline type args\n+      sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);\n+      sender_unextended_sp = sender_sp;\n+    }\n@@ -551,0 +554,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -654,0 +658,15 @@\n+\/\/ Check for a method with scalarized inline type arguments that needs\n+\/\/ a stack repair and return the repaired sender stack pointer.\n+intptr_t* frame::repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const {\n+  CompiledMethod* cm = _cb->as_compiled_method_or_null();\n+  if (cm != NULL && cm->needs_stack_repair()) {\n+    \/\/ The stack increment resides just below the saved rbp on the stack\n+    \/\/ and does not account for the return address.\n+    intptr_t* real_frame_size_addr = (intptr_t*) (saved_fp_addr - 1);\n+    int real_frame_size = ((*real_frame_size_addr) + wordSize) \/ wordSize;\n+    assert(real_frame_size >= _cb->frame_size() && real_frame_size <= 1000000, \"invalid frame size\");\n+    sender_sp = unextended_sp() + real_frame_size;\n+  }\n+  return sender_sp;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -140,0 +140,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  intptr_t* repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const;\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -407,2 +410,3 @@\n-  \/\/ On Intel the return_address is always the word on the stack\n-  address sender_pc = (address) *(sender_sp-1);\n+#ifdef ASSERT\n+  address sender_pc_copy = (address) *(sender_sp-1);\n+#endif\n@@ -415,0 +419,16 @@\n+  \/\/ Repair the sender sp if the frame has been extended\n+  sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);\n+\n+  \/\/ On Intel the return_address is always the word on the stack\n+  address sender_pc = (address) *(sender_sp-1);\n+\n+#ifdef ASSERT\n+  if (sender_pc != sender_pc_copy) {\n+    \/\/ When extending the stack in the callee method entry to make room for unpacking of value\n+    \/\/ type args, we keep a copy of the sender pc at the expected location in the callee frame.\n+    \/\/ If the sender pc is patched due to deoptimization, the copy is not consistent anymore.\n+    nmethod* nm = CodeCache::find_blob(sender_pc)->as_nmethod();\n+    assert(sender_pc == nm->deopt_mh_handler_begin() || sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+  }\n+#endif\n+\n@@ -419,2 +439,20 @@\n-    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n-      map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+    bool c1_buffering = false;\n+#ifdef COMPILER1\n+    nmethod* nm = _cb->as_nmethod_or_null();\n+    if (nm != NULL && nm->is_compiled_by_c1() && nm->method()->has_scalarized_args() &&\n+        pc() < nm->verified_inline_entry_point()) {\n+      \/\/ The VEP and VIEP(RO) of C1-compiled methods call buffer_inline_args_xxx\n+      \/\/ before doing any argument shuffling, so we need to scan the oops\n+      \/\/ as the caller passes them.\n+      c1_buffering = true;\n+#ifdef ASSERT\n+      NativeCall* call = nativeCall_before(pc());\n+      address dest = call->destination();\n+      assert(dest == Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id) ||\n+             dest == Runtime1::entry_for(Runtime1::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n+#endif\n+    }\n+#endif\n+    if (!_cb->is_compiled() || c1_buffering) { \/\/ compiled frames do not use callee-saved registers\n+      bool caller_args = _cb->caller_must_gc_arguments(map->thread()) || c1_buffering;\n+      map->set_include_argument_oops(caller_args);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -213,1 +213,0 @@\n-\n@@ -228,2 +227,18 @@\n-  \/\/ Determine and save the live input values\n-  __ push_call_clobbered_registers();\n+  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n+    \/\/ Barriers might be emitted when converting between (scalarized) calling conventions for inline\n+    \/\/ types. Save all argument registers before calling into the runtime.\n+    \/\/ TODO: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64 )\n+    __ pusha();\n+    __ subptr(rsp, 64);\n+    __ movdbl(Address(rsp, 0),  j_farg0);\n+    __ movdbl(Address(rsp, 8),  j_farg1);\n+    __ movdbl(Address(rsp, 16), j_farg2);\n+    __ movdbl(Address(rsp, 24), j_farg3);\n+    __ movdbl(Address(rsp, 32), j_farg4);\n+    __ movdbl(Address(rsp, 40), j_farg5);\n+    __ movdbl(Address(rsp, 48), j_farg6);\n+    __ movdbl(Address(rsp, 56), j_farg7);\n+  } else {\n+    \/\/ Determine and save the live input values\n+    __ push_call_clobbered_registers();\n+  }\n@@ -261,1 +276,15 @@\n-  __ pop_call_clobbered_registers();\n+  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n+    \/\/ Restore registers\n+    __ movdbl(j_farg0, Address(rsp, 0));\n+    __ movdbl(j_farg1, Address(rsp, 8));\n+    __ movdbl(j_farg2, Address(rsp, 16));\n+    __ movdbl(j_farg3, Address(rsp, 24));\n+    __ movdbl(j_farg4, Address(rsp, 32));\n+    __ movdbl(j_farg5, Address(rsp, 40));\n+    __ movdbl(j_farg6, Address(rsp, 48));\n+    __ movdbl(j_farg7, Address(rsp, 56));\n+    __ addptr(rsp, 64);\n+    __ popa();\n+  } else {\n+    __ pop_call_clobbered_registers();\n+  }\n@@ -334,3 +363,18 @@\n-  \/\/ save the live input values\n-  RegSet saved = RegSet::of(store_addr NOT_LP64(COMMA thread));\n-  __ push_set(saved);\n+  \/\/ Barriers might be emitted when converting between (scalarized) calling conventions for inline\n+  \/\/ types. Save all argument registers before calling into the runtime.\n+  \/\/ TODO: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64)\n+  __ pusha();\n+  __ subptr(rsp, 64);\n+  __ movdbl(Address(rsp, 0),  j_farg0);\n+  __ movdbl(Address(rsp, 8),  j_farg1);\n+  __ movdbl(Address(rsp, 16), j_farg2);\n+  __ movdbl(Address(rsp, 24), j_farg3);\n+  __ movdbl(Address(rsp, 32), j_farg4);\n+  __ movdbl(Address(rsp, 40), j_farg5);\n+  __ movdbl(Address(rsp, 48), j_farg6);\n+  __ movdbl(Address(rsp, 56), j_farg7);\n+\n+#ifdef _LP64\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);\n+#else\n+  __ push(thread);\n@@ -338,1 +382,14 @@\n-  __ pop_set(saved);\n+  __ pop(thread);\n+#endif\n+\n+  \/\/ Restore registers\n+  __ movdbl(j_farg0, Address(rsp, 0));\n+  __ movdbl(j_farg1, Address(rsp, 8));\n+  __ movdbl(j_farg2, Address(rsp, 16));\n+  __ movdbl(j_farg3, Address(rsp, 24));\n+  __ movdbl(j_farg4, Address(rsp, 32));\n+  __ movdbl(j_farg5, Address(rsp, 40));\n+  __ movdbl(j_farg6, Address(rsp, 48));\n+  __ movdbl(j_farg7, Address(rsp, 56));\n+  __ addptr(rsp, 64);\n+  __ popa();\n@@ -347,0 +404,1 @@\n+  bool dest_uninitialized = (decorators & IS_DEST_UNINITIALIZED) != 0;\n@@ -348,1 +406,1 @@\n-  bool needs_pre_barrier = as_normal;\n+  bool needs_pre_barrier = as_normal && !dest_uninitialized;\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":67,"deletions":9,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/macroAssembler.inline.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/shared\/barrierSetRuntime.hpp\"\n@@ -47,0 +49,1 @@\n+  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n@@ -112,0 +115,1 @@\n+  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n@@ -198,0 +202,13 @@\n+void BarrierSetAssembler::value_copy(MacroAssembler* masm, DecoratorSet decorators,\n+                                     Register src, Register dst, Register value_klass) {\n+  \/\/ value_copy implementation is fairly complex, and there are not any\n+  \/\/ \"short-cuts\" to be made from asm. What there is, appears to have the same\n+  \/\/ cost in C++, so just \"call_VM_leaf\" for now rather than maintain hundreds\n+  \/\/ of hand-rolled instructions...\n+  if (decorators & IS_DEST_UNINITIALIZED) {\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized), src, dst, value_klass);\n+  } else {\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy), src, dst, value_klass);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,3 @@\n+  virtual void value_copy(MacroAssembler* masm, DecoratorSet decorators,\n+                          Register src, Register dst, Register value_klass);\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+define_pd_global(bool, InlineTypePassFieldsAsArgs, LP64_ONLY(true) NOT_LP64(false));\n+define_pd_global(bool, InlineTypeReturnedAsFields, LP64_ONLY(true) NOT_LP64(false));\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -154,1 +155,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n@@ -199,1 +200,1 @@\n-    Address mdo_ret_addr(mdp, -in_bytes(ReturnTypeEntry::size()));\n+    Address mdo_ret_addr(mdp, -in_bytes(SingleTypeEntry::size()));\n@@ -559,1 +560,2 @@\n-                                                  Label& ok_is_subtype) {\n+                                                  Label& ok_is_subtype,\n+                                                  bool profile) {\n@@ -567,1 +569,3 @@\n-  profile_typecheck(rcx, Rsub_klass, rdi); \/\/ blows rcx, reloads rdi\n+  if (profile) {\n+    profile_typecheck(rcx, Rsub_klass, rdi); \/\/ blows rcx, reloads rdi\n+  }\n@@ -573,1 +577,3 @@\n-  profile_typecheck_failed(rcx); \/\/ blows rcx\n+  if (profile) {\n+    profile_typecheck_failed(rcx); \/\/ blows rcx\n+  }\n@@ -1019,1 +1025,1 @@\n- \/\/ get method access flags\n+  \/\/ get method access flags\n@@ -1143,4 +1149,2 @@\n-  \/\/ remove activation\n-  \/\/ get sender sp\n-  movptr(rbx,\n-         Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    movptr(rbx,\n+               Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -1168,0 +1172,41 @@\n+\n+  \/\/ remove activation\n+  \/\/ get sender sp\n+  movptr(rbx,\n+         Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+    Label skip;\n+    test_oop_is_not_inline_type(rax, rscratch1, skip);\n+\n+#ifndef _LP64\n+    super_call_VM_leaf(StubRoutines::load_inline_type_fields_in_regs());\n+#else\n+    \/\/ Load fields from a buffered value with an inline class specific handler\n+    load_klass(rdi, rax, rscratch1);\n+    movptr(rdi, Address(rdi, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    movptr(rdi, Address(rdi, InlineKlass::unpack_handler_offset()));\n+    \/\/ Unpack handler can be null if inline type is not scalarizable in returns\n+    testptr(rdi, rdi);\n+    jcc(Assembler::zero, skip);\n+    call(rdi);\n+#endif\n+#ifdef ASSERT\n+    if (StressInlineTypeReturnedAsFields) {\n+      \/\/ TODO 8284443 Enable this for value class returns (L-type descriptor)\n+      Label skip_stress;\n+      movptr(rscratch1, Address(rbp, frame::interpreter_frame_method_offset * wordSize));\n+      movptr(rscratch1, Address(rscratch1, Method::const_offset()));\n+      load_unsigned_byte(rscratch1, Address(rscratch1, ConstMethod::result_type_offset()));\n+      cmpl(rscratch1, T_PRIMITIVE_OBJECT);\n+      jcc(Assembler::notEqual, skip_stress);\n+      load_klass(rax, rax, rscratch1);\n+      orptr(rax, 1);\n+      bind(skip_stress);\n+    }\n+#endif\n+    \/\/ call above kills the value in rbx. Reload it.\n+    movptr(rbx, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    bind(skip);\n+  }\n@@ -1188,0 +1233,106 @@\n+void InterpreterMacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                                  Register t1, Register t2,\n+                                                  bool clear_fields, Label& alloc_failed) {\n+  MacroAssembler::allocate_instance(klass, new_obj, t1, t2, clear_fields, alloc_failed);\n+  {\n+    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0);\n+    \/\/ Trigger dtrace event for fastpath\n+    push(atos);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), new_obj);\n+    pop(atos);\n+  }\n+}\n+\n+\n+void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n+                                                     Register field_index, Register field_offset,\n+                                                     Register obj) {\n+  Label alloc_failed, empty_value, done;\n+  const Register src = field_offset;\n+  const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);\n+  const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);\n+  assert_different_registers(obj, holder_klass, field_index, field_offset, dst_temp);\n+\n+  \/\/ Grap the inline field klass\n+  push(holder_klass);\n+  const Register field_klass = holder_klass;\n+  get_inline_type_field_klass(holder_klass, field_index, field_klass);\n+\n+  \/\/check for empty value klass\n+  test_klass_is_empty_inline_type(field_klass, dst_temp, empty_value);\n+\n+  \/\/ allocate buffer\n+  push(obj); \/\/ save holder\n+  allocate_instance(field_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n+\n+  \/\/ Have an oop instance buffer, copy into it\n+  data_for_oop(obj, dst_temp, field_klass);\n+  pop(alloc_temp);             \/\/ restore holder\n+  lea(src, Address(alloc_temp, field_offset));\n+  \/\/ call_VM_leaf, clobbers a few regs, save restore new obj\n+  push(obj);\n+  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, field_klass);\n+  pop(obj);\n+  pop(holder_klass);\n+  jmp(done);\n+\n+  bind(empty_value);\n+  get_empty_inline_type_oop(field_klass, dst_temp, obj);\n+  pop(holder_klass);\n+  jmp(done);\n+\n+  bind(alloc_failed);\n+  pop(obj);\n+  pop(holder_klass);\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+          obj, field_index, holder_klass);\n+\n+  bind(done);\n+}\n+\n+void InterpreterMacroAssembler::read_flattened_element(Register array, Register index,\n+                                                       Register t1, Register t2,\n+                                                       Register obj) {\n+  assert_different_registers(array, index, t1, t2);\n+  Label alloc_failed, empty_value, done;\n+  const Register array_klass = t2;\n+  const Register elem_klass = t1;\n+  const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);\n+  const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);\n+\n+  \/\/ load in array->klass()->element_klass()\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  load_klass(array_klass, array, tmp_load_klass);\n+  movptr(elem_klass, Address(array_klass, ArrayKlass::element_klass_offset()));\n+\n+  \/\/check for empty value klass\n+  test_klass_is_empty_inline_type(elem_klass, dst_temp, empty_value);\n+\n+  \/\/ calc source into \"array_klass\" and free up some regs\n+  const Register src = array_klass;\n+  push(index); \/\/ preserve index reg in case alloc_failed\n+  data_for_value_array_index(array, array_klass, index, src);\n+\n+  allocate_instance(elem_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n+  \/\/ Have an oop instance buffer, copy into it\n+  store_ptr(0, obj); \/\/ preserve obj (overwrite index, no longer needed)\n+  data_for_oop(obj, dst_temp, elem_klass);\n+  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, elem_klass);\n+  pop(obj);\n+  jmp(done);\n+\n+  bind(empty_value);\n+  get_empty_inline_type_oop(elem_klass, dst_temp, obj);\n+  jmp(done);\n+\n+  bind(alloc_failed);\n+  pop(index);\n+  if (array == c_rarg2) {\n+    mov(elem_klass, array);\n+    array = elem_klass;\n+  }\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), array, index);\n+\n+  bind(done);\n+}\n+\n@@ -1232,0 +1383,4 @@\n+    if (EnableValhalla) {\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      andptr(swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+    }\n@@ -1578,1 +1733,1 @@\n-void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp) {\n+void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp, bool acmp) {\n@@ -1590,1 +1745,1 @@\n-    update_mdp_by_constant(mdp, in_bytes(BranchData::branch_data_size()));\n+    update_mdp_by_constant(mdp, acmp ? in_bytes(ACmpData::acmp_data_size()): in_bytes(BranchData::branch_data_size()));\n@@ -1965,0 +2120,78 @@\n+void InterpreterMacroAssembler::profile_array(Register mdp,\n+                                              Register array,\n+                                              Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, array);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::array_offset())));\n+\n+    Label not_flat;\n+    test_non_flattened_array_oop(array, tmp, not_flat);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::flat_array_byte_constant());\n+\n+    bind(not_flat);\n+\n+    Label not_null_free;\n+    test_non_null_free_array_oop(array, tmp, not_null_free);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::null_free_array_byte_constant());\n+\n+    bind(not_null_free);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_element(Register mdp,\n+                                                Register element,\n+                                                Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, element);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::element_offset())));\n+\n+    \/\/ The method data pointer needs to be updated.\n+    update_mdp_by_constant(mdp, in_bytes(ArrayLoadStoreData::array_load_store_data_size()));\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_acmp(Register mdp,\n+                                             Register left,\n+                                             Register right,\n+                                             Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, left);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::left_offset())));\n+\n+    Label left_not_inline_type;\n+    test_oop_is_not_inline_type(left, tmp, left_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::left_inline_type_byte_constant());\n+    bind(left_not_inline_type);\n+\n+    mov(tmp, right);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::right_offset())));\n+\n+    Label right_not_inline_type;\n+    test_oop_is_not_inline_type(right, tmp, right_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::right_inline_type_byte_constant());\n+    bind(right_not_inline_type);\n+\n+    bind(profile_continue);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":245,"deletions":12,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-  void gen_subtype_check( Register sub_klass, Label &ok_is_subtype );\n+  void gen_subtype_check(Register sub_klass, Label &ok_is_subtype, bool profile = true);\n@@ -236,0 +236,23 @@\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+  \/\/ Allocate instance in \"obj\" and read in the content of the inline field\n+  \/\/ NOTES:\n+  \/\/   - input holder object via \"obj\", which must be rax,\n+  \/\/     will return new instance via the same reg\n+  \/\/   - assumes holder_klass and valueKlass field klass have both been resolved\n+  \/\/   - 32 bits: kills rdi and rsi\n+  void read_inlined_field(Register holder_klass,\n+                            Register field_index, Register field_offset,\n+                            Register obj = rax);\n+\n+  \/\/ Allocate value buffer in \"obj\" and read in flattened element at the given index\n+  \/\/ NOTES:\n+  \/\/   - Return via \"obj\" must be rax\n+  \/\/   - kills all given regs\n+  \/\/   - 32 bits: kills rdi and rsi\n+  void read_flattened_element(Register array, Register index,\n+                              Register t1, Register t2,\n+                              Register obj = rax);\n+\n@@ -274,1 +297,1 @@\n-  void profile_not_taken_branch(Register mdp);\n+  void profile_not_taken_branch(Register mdp, bool acmp = false);\n@@ -287,0 +310,3 @@\n+  void profile_array(Register mdp, Register array, Register tmp);\n+  void profile_element(Register mdp, Register element, Register tmp);\n+  void profile_acmp(Register mdp, Register left, Register right, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -53,0 +54,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n@@ -54,0 +56,1 @@\n+#include \"vmreg_x86.inline.hpp\"\n@@ -56,0 +59,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/output.hpp\"\n+#endif\n@@ -1677,0 +1683,4 @@\n+void MacroAssembler::super_call_VM_leaf(address entry_point) {\n+  MacroAssembler::call_VM_leaf_base(entry_point, 1);\n+}\n+\n@@ -2777,0 +2787,140 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  andptr(markword, markWord::inline_type_mask_in_place);\n+  cmpptr(markword, markWord::inline_type_pattern);\n+  jcc(Assembler::equal, is_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n+  movl(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  testl(temp_reg, JVM_ACC_VALUE);\n+  jcc(Assembler::notZero, is_inline_type);\n+}\n+\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+  testptr(object, object);\n+  jcc(Assembler::zero, not_inline_type);\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  movptr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  andptr(tmp, is_inline_type_mask);\n+  cmpptr(tmp, is_inline_type_mask);\n+  jcc(Assembler::notEqual, not_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(klass, temp_reg, done_check);\n+    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n+  testl(temp_reg, InstanceKlass::misc_flag_is_empty_inline_type());\n+  jcc(Assembler::notZero, is_empty_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n+  movl(temp_reg, flags);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n+  andl(temp_reg, 0x1);\n+  testl(temp_reg, temp_reg);\n+  jcc(Assembler::notZero, is_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n+  movl(temp_reg, flags);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n+  andl(temp_reg, 0x1);\n+  testl(temp_reg, temp_reg);\n+  jcc(Assembler::zero, not_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label& is_inlined) {\n+  movl(temp_reg, flags);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_inlined_shift);\n+  andl(temp_reg, 0x1);\n+  testl(temp_reg, temp_reg);\n+  jcc(Assembler::notZero, is_inlined);\n+}\n+\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  movptr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  testl(temp_reg, markWord::unlocked_value);\n+  jccb(Assembler::notZero, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  push(rscratch1);\n+  load_prototype_header(temp_reg, oop, rscratch1);\n+  pop(rscratch1);\n+\n+  bind(test_mark_word);\n+  testl(temp_reg, test_bit);\n+  jcc((jmp_set) ? Assembler::notZero : Assembler::zero, jmp_label);\n+}\n+\n+void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,\n+                                              Label&is_flattened_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_flattened_array_layout(temp_reg, is_flattened_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,\n+                                                  Label&is_non_flattened_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_non_flattened_array_layout(temp_reg, is_non_flattened_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&is_null_free_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_null_free_array_layout(temp_reg, is_null_free_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_non_null_free_array_layout(temp_reg, is_non_null_free_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_flattened_array_layout(Register lh, Label& is_flattened_array) {\n+  testl(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  jcc(Assembler::notZero, is_flattened_array);\n+}\n+\n+void MacroAssembler::test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array) {\n+  testl(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  jcc(Assembler::zero, is_non_flattened_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_layout(Register lh, Label& is_null_free_array) {\n+  testl(lh, Klass::_lh_null_free_array_bit_inplace);\n+  jcc(Assembler::notZero, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array) {\n+  testl(lh, Klass::_lh_null_free_array_bit_inplace);\n+  jcc(Assembler::zero, is_non_null_free_array);\n+}\n+\n+\n@@ -3727,0 +3877,115 @@\n+\/\/ Object \/ value buffer allocation...\n+\/\/\n+\/\/ Kills klass and rsi on LP64\n+void MacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                       Register t1, Register t2,\n+                                       bool clear_fields, Label& alloc_failed)\n+{\n+  Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;\n+  Register layout_size = t1;\n+  assert(new_obj == rax, \"needs to be rax\");\n+  assert_different_registers(klass, new_obj, t1, t2);\n+\n+  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n+  movl(layout_size, Address(klass, Klass::layout_helper_offset()));\n+  \/\/ test to see if it has a finalizer or is malformed in some way\n+  testl(layout_size, Klass::_lh_instance_slow_path_bit);\n+  jcc(Assembler::notZero, slow_case_no_pop);\n+\n+  \/\/ Allocate the instance:\n+  \/\/  If TLAB is enabled:\n+  \/\/    Try to allocate in the TLAB.\n+  \/\/    If fails, go to the slow path.\n+  \/\/  Else If inline contiguous allocations are enabled:\n+  \/\/    Try to allocate in eden.\n+  \/\/    If fails due to heap end, go to slow path.\n+  \/\/\n+  \/\/  If TLAB is enabled OR inline contiguous is enabled:\n+  \/\/    Initialize the allocation.\n+  \/\/    Exit.\n+  \/\/\n+  \/\/  Go to slow path.\n+\n+  push(klass);\n+  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);\n+#ifndef _LP64\n+  if (UseTLAB) {\n+    get_thread(thread);\n+  }\n+#endif \/\/ _LP64\n+\n+  if (UseTLAB) {\n+    tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);\n+    if (ZeroTLAB || (!clear_fields)) {\n+      \/\/ the fields have been already cleared\n+      jmp(initialize_header);\n+    } else {\n+      \/\/ initialize both the header and fields\n+      jmp(initialize_object);\n+    }\n+  } else {\n+    jmp(slow_case);\n+  }\n+\n+  \/\/ If UseTLAB is true, the object is created above and there is an initialize need.\n+  \/\/ Otherwise, skip and go to the slow path.\n+  if (UseTLAB) {\n+    if (clear_fields) {\n+      \/\/ The object is initialized before the header.  If the object size is\n+      \/\/ zero, go directly to the header initialization.\n+      bind(initialize_object);\n+      decrement(layout_size, sizeof(oopDesc));\n+      jcc(Assembler::zero, initialize_header);\n+\n+      \/\/ Initialize topmost object field, divide size by 8, check if odd and\n+      \/\/ test if zero.\n+      Register zero = klass;\n+      xorl(zero, zero);    \/\/ use zero reg to clear memory (shorter code)\n+      shrl(layout_size, LogBytesPerLong); \/\/ divide by 2*oopSize and set carry flag if odd\n+\n+  #ifdef ASSERT\n+      \/\/ make sure instance_size was multiple of 8\n+      Label L;\n+      \/\/ Ignore partial flag stall after shrl() since it is debug VM\n+      jcc(Assembler::carryClear, L);\n+      stop(\"object size is not multiple of 2 - adjust this code\");\n+      bind(L);\n+      \/\/ must be > 0, no extra check needed here\n+  #endif\n+\n+      \/\/ initialize remaining object fields: instance_size was a multiple of 8\n+      {\n+        Label loop;\n+        bind(loop);\n+        movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);\n+        NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));\n+        decrement(layout_size);\n+        jcc(Assembler::notZero, loop);\n+      }\n+    } \/\/ clear_fields\n+\n+    \/\/ initialize object header only.\n+    bind(initialize_header);\n+    pop(klass);\n+    Register mark_word = t2;\n+    movptr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+#ifdef _LP64\n+    xorl(rsi, rsi);                 \/\/ use zero reg to clear memory (shorter code)\n+    store_klass_gap(new_obj, rsi);  \/\/ zero klass gap for compressed oops\n+#endif\n+    movptr(t2, klass);         \/\/ preserve klass\n+    Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    store_klass(new_obj, t2, tmp_store_klass);  \/\/ src klass reg is potentially compressed\n+\n+    jmp(done);\n+  }\n+\n+  bind(slow_case);\n+  pop(klass);\n+  bind(slow_case_no_pop);\n+  jmp(alloc_failed);\n+\n+  bind(done);\n+}\n+\n@@ -3979,0 +4244,50 @@\n+void MacroAssembler::get_inline_type_field_klass(Register klass, Register index, Register inline_klass) {\n+  movptr(inline_klass, Address(klass, InstanceKlass::inline_type_field_klasses_offset()));\n+#ifdef ASSERT\n+  {\n+    Label done;\n+    cmpptr(inline_klass, 0);\n+    jcc(Assembler::notEqual, done);\n+    stop(\"get_inline_type_field_klass contains no inline klass\");\n+    bind(done);\n+  }\n+#endif\n+  movptr(inline_klass, Address(inline_klass, index, Address::times_ptr));\n+}\n+\n+void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_default_value_oop from non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  Register offset = temp_reg;\n+  \/\/ Getting the offset of the pre-allocated default value\n+  movptr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n+  movl(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));\n+\n+  \/\/ Getting the mirror\n+  movptr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n+  resolve_oop_handle(obj, inline_klass);\n+\n+  \/\/ Getting the pre-allocated default value from the mirror\n+  Address field(obj, offset, Address::times_1);\n+  load_heap_oop(obj, field);\n+}\n+\n+void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_empty_value from non-empty inline klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  get_default_value_oop(inline_klass, temp_reg, obj);\n+}\n+\n+\n@@ -4327,1 +4642,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -4386,1 +4705,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -4878,0 +5201,8 @@\n+void MacroAssembler::load_metadata(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -4887,1 +5218,6 @@\n-    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+}\n+\n+void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n+  load_klass(dst, src, tmp);\n+  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n@@ -4926,0 +5262,40 @@\n+void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,\n+                                       Register inline_klass) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->value_copy(this, decorators, src, dst, inline_klass);\n+}\n+\n+void MacroAssembler::first_field_offset(Register inline_klass, Register offset) {\n+  movptr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+  movl(offset, Address(offset, InlineKlass::first_field_offset_offset()));\n+}\n+\n+void MacroAssembler::data_for_oop(Register oop, Register data, Register inline_klass) {\n+  \/\/ ((address) (void*) o) + vk->first_field_offset();\n+  Register offset = (data == oop) ? rscratch1 : data;\n+  first_field_offset(inline_klass, offset);\n+  if (data == oop) {\n+    addptr(data, offset);\n+  } else {\n+    lea(data, Address(oop, offset));\n+  }\n+}\n+\n+void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,\n+                                                Register index, Register data) {\n+  assert(index != rcx, \"index needs to shift by rcx\");\n+  assert_different_registers(array, array_klass, index);\n+  assert_different_registers(rcx, array, index);\n+\n+  \/\/ array->base() + (index << Klass::layout_helper_log2_element_size(lh));\n+  movl(rcx, Address(array_klass, Klass::layout_helper_offset()));\n+\n+  \/\/ Klass::layout_helper_log2_element_size(lh)\n+  \/\/ (lh >> _lh_log2_element_size_shift) & _lh_log2_element_size_mask;\n+  shrl(rcx, Klass::_lh_log2_element_size_shift);\n+  andl(rcx, Klass::_lh_log2_element_size_mask);\n+  shlptr(index); \/\/ index << rcx\n+\n+  lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT)));\n+}\n+\n@@ -5266,1 +5642,1 @@\n-void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, KRegister mask) {\n+void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, KRegister mask) {\n@@ -5272,1 +5648,1 @@\n-    vpxor(xtmp, xtmp, xtmp, AVX_512bit);\n+    evpbroadcastq(xtmp, val, AVX_512bit);\n@@ -5274,1 +5650,3 @@\n-    vpxor(xtmp, xtmp, xtmp, AVX_256bit);\n+    movdq(xtmp, val);\n+    punpcklqdq(xtmp, xtmp);\n+    vinserti128_high(xtmp, xtmp);\n@@ -5276,1 +5654,2 @@\n-    pxor(xtmp, xtmp);\n+    movdq(xtmp, val);\n+    punpcklqdq(xtmp, xtmp);\n@@ -5299,1 +5678,1 @@\n-    fill64_masked(3, base, 0, xtmp, mask, cnt, rtmp, true);\n+    fill64_masked(3, base, 0, xtmp, mask, cnt, val, true);\n@@ -5318,1 +5697,1 @@\n-    fill32_masked(3, base, 0, xtmp, mask, cnt, rtmp);\n+    fill32_masked(3, base, 0, xtmp, mask, cnt, val);\n@@ -5331,0 +5710,399 @@\n+int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  \/\/ An inline type might be returned. If fields are in registers we\n+  \/\/ need to allocate an inline type instance and initialize it with\n+  \/\/ the value of the fields.\n+  Label skip;\n+  \/\/ We only need a new buffered inline type if a new one is not returned\n+  testptr(rax, 1);\n+  jcc(Assembler::zero, skip);\n+  int call_offset = -1;\n+\n+#ifdef _LP64\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != NULL, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(rscratch1, rax); \/\/ save rax for slow_case since *_allocate may corrupt it when allocation failed\n+  if (vk != NULL) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(rbx, (intptr_t)vk->get_InlineKlass());\n+    jint obj_size = vk->layout_helper();\n+    assert(obj_size != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB) {\n+      tlab_allocate(r15_thread, rax, noreg, obj_size, r13, r14, slow_case);\n+    } else {\n+      jmp(slow_case);\n+    }\n+  } else {\n+    \/\/ Call from interpreter. RAX contains ((the InlineKlass* of the return type) | 0x01)\n+    mov(rbx, rax);\n+    andptr(rbx, -2);\n+    movl(r14, Address(rbx, Klass::layout_helper_offset()));\n+    if (UseTLAB) {\n+      tlab_allocate(r15_thread, rax, r14, 0, r13, r14, slow_case);\n+    } else {\n+      jmp(slow_case);\n+    }\n+  }\n+  if (UseTLAB) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = rax;\n+    movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::inline_type_prototype().value());\n+    xorl(r13, r13);\n+    store_klass_gap(buffer_obj, r13);\n+    if (vk == NULL) {\n+      \/\/ store_klass corrupts rbx(klass), so save it in r13 for later use (interpreter case only).\n+      mov(r13, rbx);\n+    }\n+    Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    store_klass(buffer_obj, rbx, tmp_store_klass);\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n+    if (vk != NULL) {\n+      call(RuntimeAddress(vk->pack_handler())); \/\/ no need for call info as this will not safepoint.\n+    } else {\n+      movptr(rbx, Address(r13, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      movptr(rbx, Address(rbx, InlineKlass::pack_handler_offset()));\n+      call(rbx);\n+    }\n+    jmp(skip);\n+  }\n+  bind(slow_case);\n+  \/\/ We failed to allocate a new inline type, fall back to a runtime\n+  \/\/ call. Some oop field may be live in some registers but we can't\n+  \/\/ tell. That runtime call will take care of preserving them\n+  \/\/ across a GC if there's one.\n+  mov(rax, rscratch1);\n+#endif\n+\n+  if (from_interpreter) {\n+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());\n+  } else {\n+    call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n+    call_offset = offset();\n+  }\n+\n+  bind(skip);\n+  return call_offset;\n+}\n+\n+\/\/ Move a value between registers\/stack slots and update the reg_state\n+bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]) {\n+  assert(from->is_valid() && to->is_valid(), \"source and destination must be valid\");\n+  if (reg_state[to->value()] == reg_written) {\n+    return true; \/\/ Already written\n+  }\n+  if (from != to && bt != T_VOID) {\n+    if (reg_state[to->value()] == reg_readonly) {\n+      return false; \/\/ Not yet writable\n+    }\n+    if (from->is_reg()) {\n+      if (to->is_reg()) {\n+        if (from->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to->as_XMMRegister(), from->as_XMMRegister());\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to->as_XMMRegister(), from->as_XMMRegister());\n+          }\n+        } else {\n+          movq(to->as_Register(), from->as_Register());\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        Address to_addr = Address(rsp, st_off);\n+        if (from->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to_addr, from->as_XMMRegister());\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to_addr, from->as_XMMRegister());\n+          }\n+        } else {\n+          movq(to_addr, from->as_Register());\n+        }\n+      }\n+    } else {\n+      Address from_addr = Address(rsp, from->reg2stack() * VMRegImpl::stack_slot_size + wordSize);\n+      if (to->is_reg()) {\n+        if (to->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to->as_XMMRegister(), from_addr);\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to->as_XMMRegister(), from_addr);\n+          }\n+        } else {\n+          movq(to->as_Register(), from_addr);\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(r13, from_addr);\n+        movq(Address(rsp, st_off), r13);\n+      }\n+    }\n+  }\n+  \/\/ Update register states\n+  reg_state[from->value()] = reg_writable;\n+  reg_state[to->value()] = reg_written;\n+  return true;\n+}\n+\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  \/\/ Two additional slots to account for return address\n+  int sp_inc = (args_on_stack + 2) * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  \/\/ Save the return address, adjust the stack (make sure it is properly\n+  \/\/ 16-byte aligned) and copy the return address to the new top of the stack.\n+  \/\/ The stack will be repaired on return (see MacroAssembler::remove_frame).\n+  assert(sp_inc > 0, \"sanity\");\n+  pop(r13);\n+  subptr(rsp, sp_inc);\n+  push(r13);\n+  return sp_inc;\n+}\n+\n+\/\/ Read all fields from an inline type buffer and store the field values in registers\/stack slots.\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                                          VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                                          RegState reg_state[]) {\n+  assert(sig->at(sig_index)._bt == T_VOID, \"should be at end delimiter\");\n+  assert(from->is_valid(), \"source must be valid\");\n+  bool progress = false;\n+#ifdef ASSERT\n+  const int start_offset = offset();\n+#endif\n+\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n+  Register fromReg = noreg;\n+  ScalarizedInlineArgsStream stream(sig, sig_index, to, to_count, to_index, -1);\n+  bool done = true;\n+  bool mark_done = true;\n+  VMReg toReg;\n+  BasicType bt;\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n+  while (stream.next(toReg, bt)) {\n+    assert(toReg->is_valid(), \"destination must be valid\");\n+    int idx = (int)toReg->value();\n+    if (reg_state[idx] == reg_readonly) {\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n+    } else if (reg_state[idx] == reg_written) {\n+      continue;\n+    }\n+    assert(reg_state[idx] == reg_writable, \"must be writable\");\n+    reg_state[idx] = reg_written;\n+    progress = true;\n+\n+    if (fromReg == noreg) {\n+      if (from->is_reg()) {\n+        fromReg = from->as_Register();\n+      } else {\n+        int st_off = from->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(tmp1, Address(rsp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        testptr(fromReg, fromReg);\n+        jcc(Assembler::zero, L_null);\n+      }\n+    }\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), 1);\n+      } else {\n+        movq(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n+    Address fromAddr = Address(fromReg, off);\n+    if (!toReg->is_XMMRegister()) {\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n+      if (is_reference_type(bt)) {\n+        load_heap_oop(dst, fromAddr);\n+      } else {\n+        bool is_signed = (bt != T_CHAR) && (bt != T_BOOLEAN);\n+        load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);\n+      }\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), dst);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      movdbl(toReg->as_XMMRegister(), fromAddr);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      movflt(toReg->as_XMMRegister(), fromAddr);\n+    }\n+  }\n+  if (progress && null_check) {\n+    if (done) {\n+      jmp(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+            movq(Address(rsp, st_off), 0);\n+          } else {\n+            xorq(toReg->as_Register(), toReg->as_Register());\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n+  sig_index = stream.sig_index();\n+  to_index = stream.regs_index();\n+\n+  if (mark_done && reg_state[from->value()] != reg_written) {\n+    \/\/ This is okay because no one else will write to that slot\n+    reg_state[from->value()] = reg_writable;\n+  }\n+  from_index--;\n+  assert(progress || (start_offset == offset()), \"should not emit code\");\n+  return done;\n+}\n+\n+bool MacroAssembler::pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                                        VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                                        RegState reg_state[], Register val_array) {\n+  assert(sig->at(sig_index)._bt == T_PRIMITIVE_OBJECT, \"should be at end delimiter\");\n+  assert(to->is_valid(), \"destination must be valid\");\n+\n+  if (reg_state[to->value()] == reg_written) {\n+    skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+    return true; \/\/ Already written\n+  }\n+\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n+  Register val_obj_tmp = r11;\n+  Register from_reg_tmp = r14;\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n+  Register tmp3 = rbx;\n+  Register val_obj = to->is_stack() ? val_obj_tmp : to->as_Register();\n+\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n+  if (reg_state[to->value()] == reg_readonly) {\n+    if (!is_reg_in_unpacked_fields(sig, sig_index, to, from, from_count, from_index)) {\n+      skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+      return false; \/\/ Not yet writable\n+    }\n+    val_obj = val_obj_tmp;\n+  }\n+\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_PRIMITIVE_OBJECT);\n+  load_heap_oop(val_obj, Address(val_array, index));\n+\n+  ScalarizedInlineArgsStream stream(sig, sig_index, from, from_count, from_index);\n+  VMReg fromReg;\n+  BasicType bt;\n+  Label L_null;\n+  while (stream.next(fromReg, bt)) {\n+    assert(fromReg->is_valid(), \"source must be valid\");\n+    reg_state[fromReg->value()] = reg_writable;\n+\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        testb(Address(rsp, ld_off), 1);\n+      } else {\n+        testb(fromReg->as_Register(), 1);\n+      }\n+      jcc(Assembler::notZero, L_notNull);\n+      movptr(val_obj, 0);\n+      jmp(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n+    assert(off > 0, \"offset in object should be positive\");\n+    size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+\n+    Address dst(val_obj, off);\n+    if (!fromReg->is_XMMRegister()) {\n+      Register src;\n+      if (fromReg->is_stack()) {\n+        src = from_reg_tmp;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        load_sized_value(src, Address(rsp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+      } else {\n+        src = fromReg->as_Register();\n+      }\n+      assert_different_registers(dst.base(), src, tmp1, tmp2, tmp3, val_array);\n+      if (is_reference_type(bt)) {\n+        store_heap_oop(dst, src, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        store_sized_value(dst, src, size_in_bytes);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      movdbl(dst, fromReg->as_XMMRegister());\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      movflt(dst, fromReg->as_XMMRegister());\n+    }\n+  }\n+  bind(L_null);\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+\n+  assert(reg_state[to->value()] == reg_writable, \"must have already been read\");\n+  bool success = move_helper(val_obj->as_VMReg(), to, T_OBJECT, reg_state);\n+  assert(success, \"to register must be writeable\");\n+  return true;\n+}\n+\n+VMReg MacroAssembler::spill_reg_for(VMReg reg) {\n+  return reg->is_XMMRegister() ? xmm8->as_VMReg() : r14->as_VMReg();\n+}\n+\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair) {\n+  assert((initial_framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+  if (needs_stack_repair) {\n+    movq(rbp, Address(rsp, initial_framesize));\n+    \/\/ The stack increment resides just below the saved rbp\n+    addq(rsp, Address(rsp, initial_framesize - wordSize));\n+  } else {\n+    if (initial_framesize > 0) {\n+      addq(rsp, initial_framesize);\n+    }\n+    pop(rbp);\n+  }\n+}\n+\n@@ -5420,2 +6198,2 @@\n-void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp,\n-                               bool is_large, KRegister mask) {\n+void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp,\n+                               bool is_large, bool word_copy_only, KRegister mask) {\n@@ -5426,1 +6204,1 @@\n-  assert(tmp==rax,   \"tmp register must be eax for rep stos\");\n+  assert(val==rax,   \"val register must be eax for rep stos\");\n@@ -5432,3 +6210,0 @@\n-  if (!is_large || !UseXMMForObjInit) {\n-    xorptr(tmp, tmp);\n-  }\n@@ -5448,1 +6223,1 @@\n-    movptr(Address(base, cnt, Address::times_ptr), tmp);\n+    movptr(Address(base, cnt, Address::times_ptr), val);\n@@ -5457,1 +6232,1 @@\n-  if (UseFastStosb) {\n+  if (UseFastStosb && !word_copy_only) {\n@@ -5461,1 +6236,1 @@\n-    xmm_clear_mem(base, cnt, tmp, xtmp, mask);\n+    xmm_clear_mem(base, cnt, val, xtmp, mask);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":793,"deletions":18,"binary":false,"changes":811,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -36,0 +37,2 @@\n+class ciInlineKlass;\n+\n@@ -105,0 +108,31 @@\n+  \/\/ markWord tests, kills markWord reg\n+  void test_markword_is_inline_type(Register markword, Label& is_inline_type);\n+\n+  \/\/ inlineKlass queries, kills temp_reg\n+  void test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type);\n+  void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type);\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n+\n+  \/\/ Get the default value oop for the given InlineKlass\n+  void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);\n+  \/\/ The empty value oop, for the given InlineKlass (\"empty\" as in no instance fields)\n+  \/\/ get_default_value_oop with extra assertion for empty inline klass\n+  void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);\n+\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n+  void test_field_is_inlined(Register flags, Register temp_reg, Label& is_inlined);\n+\n+  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  void test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label);\n+  void test_flattened_array_oop(Register oop, Register temp_reg, Label&is_flattened_array);\n+  void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&is_non_flattened_array);\n+  void test_null_free_array_oop(Register oop, Register temp_reg, Label&is_null_free_array);\n+  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array);\n+\n+  \/\/ Check array klass layout helper for flatten or null-free arrays...\n+  void test_flattened_array_layout(Register lh, Label& is_flattened_array);\n+  void test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array);\n+  void test_null_free_array_layout(Register lh, Label& is_null_free_array);\n+  void test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array);\n+\n@@ -348,0 +382,1 @@\n+  void load_metadata(Register dst, Register src);\n@@ -356,0 +391,10 @@\n+  void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);\n+\n+  \/\/ inline type data payload offsets...\n+  void first_field_offset(Register inline_klass, Register offset);\n+  void data_for_oop(Register oop, Register data, Register inline_klass);\n+  \/\/ get data payload ptr a flat value array at index, kills rcx and index\n+  void data_for_value_array_index(Register array, Register array_klass,\n+                                  Register index, Register data);\n+\n+\n@@ -367,0 +412,2 @@\n+  void load_prototype_header(Register dst, Register src, Register tmp);\n+\n@@ -568,0 +615,9 @@\n+\n+  \/\/ Object \/ value buffer allocation...\n+  \/\/ Allocate instance of klass, assumes klass initialized by caller\n+  \/\/ new_obj prefers to be rax\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+\n@@ -579,0 +635,3 @@\n+  \/\/ For field \"index\" within \"klass\", return inline_klass ...\n+  void get_inline_type_field_klass(Register klass, Register index, Register inline_klass);\n+\n@@ -729,1 +788,2 @@\n-  void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }\n+  void andptr(Register dst, Register src) { LP64_ONLY(andq(dst, src)) NOT_LP64(andl(dst, src)) ; }\n+  void andptr(Register dst, Address src) { LP64_ONLY(andq(dst, src)) NOT_LP64(andl(dst, src)) ; }\n@@ -1877,0 +1937,15 @@\n+  \/\/ Inline type specific methods\n+  #include \"asm\/macroAssembler_common.hpp\"\n+\n+  int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);\n+  bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]);\n+  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                            VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                            RegState reg_state[]);\n+  bool pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                          VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                          RegState reg_state[], Register val_array);\n+  int extend_stack_for_inline_args(int args_on_stack);\n+  void remove_frame(int initial_framesize, bool needs_stack_repair);\n+  VMReg spill_reg_for(VMReg reg);\n+\n@@ -1879,1 +1954,1 @@\n-  void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large, KRegister mask=knoreg);\n+  void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only, KRegister mask=knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":77,"deletions":2,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -156,1 +156,5 @@\n-  const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_offset() :\n+  \/\/ The following jump might pass an inline type argument that was erased to Object as oop to a\n+  \/\/ callee that expects inline type arguments to be passed as fields. We need to call the compiled\n+  \/\/ value entry (_code->inline_entry_point() or _adapter->c2i_inline_entry()) which will take care\n+  \/\/ of translating between the calling conventions.\n+  const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_inline_offset() :\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -485,0 +485,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -535,0 +536,9 @@\n+const uint SharedRuntime::java_return_convention_max_int = 1;\n+const uint SharedRuntime::java_return_convention_max_float = 1;\n+int SharedRuntime::java_return_convention(const BasicType *sig_bt,\n+                                          VMRegPair *regs,\n+                                          int total_args_passed) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n@@ -596,3 +606,1 @@\n-                            int total_args_passed,\n-                            int comp_args_on_stack,\n-                            const BasicType *sig_bt,\n+                            const GrowableArray<SigEntry>& sig_extended,\n@@ -600,1 +608,5 @@\n-                            Label& skip_fixup) {\n+                            Label& skip_fixup,\n+                            address start,\n+                            OopMapSet*& oop_maps,\n+                            int& frame_complete,\n+                            int& frame_size_in_words) {\n@@ -622,1 +634,1 @@\n-  int extraspace = total_args_passed * Interpreter::stackElementSize;\n+  int extraspace = sig_extended.length() * Interpreter::stackElementSize;\n@@ -633,3 +645,3 @@\n-  for (int i = 0; i < total_args_passed; i++) {\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n+  for (int i = 0; i < sig_extended.length(); i++) {\n+    if (sig_extended.at(i)._bt == T_VOID) {\n+      assert(i > 0 && (sig_extended.at(i-1)._bt == T_LONG || sig_extended.at(i-1)._bt == T_DOUBLE), \"missing half\");\n@@ -640,1 +652,1 @@\n-    int st_off = ((total_args_passed - 1) - i) * Interpreter::stackElementSize;\n+    int st_off = ((sig_extended.length() - 1) - i) * Interpreter::stackElementSize;\n@@ -690,1 +702,1 @@\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n+        if (sig_extended.at(i)._bt == T_LONG || sig_extended.at(i)._bt == T_DOUBLE) {\n@@ -707,1 +719,1 @@\n-        assert(sig_bt[i] == T_DOUBLE || sig_bt[i] == T_LONG, \"wrong type\");\n+        assert(sig_extended.at(i)._bt == T_DOUBLE || sig_extended.at(i)._bt == T_LONG, \"wrong type\");\n@@ -740,2 +752,1 @@\n-                                    int total_args_passed,\n-                                    const BasicType *sig_bt,\n+                                    const GrowableArray<SigEntry>& sig_extended,\n@@ -744,0 +755,1 @@\n+\n@@ -832,2 +844,2 @@\n-  for (int i = 0; i < total_args_passed; i++) {\n-    if (sig_bt[i] == T_VOID) {\n+  for (int i = 0; i < sig_extended.length(); i++) {\n+    if (sig_extended.at(i)._bt == T_VOID) {\n@@ -836,1 +848,1 @@\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n+      assert(i > 0 && (sig_extended.at(i-1)._bt == T_LONG || sig_extended.at(i-1)._bt == T_DOUBLE), \"missing half\");\n@@ -845,1 +857,1 @@\n-    int ld_off = (total_args_passed - i) * Interpreter::stackElementSize;\n+    int ld_off = (sig_extended.length() - i) * Interpreter::stackElementSize;\n@@ -886,1 +898,1 @@\n-        const int offset = (NOT_LP64(true ||) sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n+        const int offset = (NOT_LP64(true ||) sig_extended.at(i)._bt==T_LONG||sig_extended.at(i)._bt==T_DOUBLE)?\n@@ -904,1 +916,1 @@\n-        const int offset = (NOT_LP64(true ||) sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n+        const int offset = (NOT_LP64(true ||) sig_extended.at(i)._bt==T_LONG||sig_extended.at(i)._bt==T_DOUBLE)?\n@@ -952,2 +964,1 @@\n-                                                            int total_args_passed,\n-                                                            const BasicType *sig_bt,\n+                                                            const GrowableArray<SigEntry>& sig_extended,\n@@ -956,1 +967,2 @@\n-                                                            AdapterFingerPrint* fingerprint) {\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter) {\n@@ -959,1 +971,1 @@\n-  gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);\n+  gen_i2c_adapter(masm, comp_args_on_stack, sig_extended, regs);\n@@ -999,1 +1011,4 @@\n-  gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);\n+  OopMapSet* oop_maps = NULL;\n+  int frame_complete = CodeOffsets::frame_never_safe;\n+  int frame_size_in_words = 0;\n+  gen_c2i_adapter(masm, sig_extended, regs, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words);\n@@ -1002,0 +1017,1 @@\n+  new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps);\n@@ -1025,0 +1041,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -1608,0 +1625,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1782,0 +1800,1 @@\n+  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n@@ -2869,0 +2888,5 @@\n+\n+BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {\n+  Unimplemented();\n+  return NULL;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":48,"deletions":24,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -530,0 +531,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -563,0 +565,82 @@\n+\/\/ Same as java_calling_convention() but for multiple return\n+\/\/ values. There's no way to store them on the stack so if we don't\n+\/\/ have enough registers, multiple values can't be returned.\n+const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;\n+const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;\n+int SharedRuntime::java_return_convention(const BasicType *sig_bt,\n+                                          VMRegPair *regs,\n+                                          int total_args_passed) {\n+  \/\/ Create the mapping between argument positions and\n+  \/\/ registers.\n+  static const Register INT_ArgReg[java_return_convention_max_int] = {\n+    rax, j_rarg5, j_rarg4, j_rarg3, j_rarg2, j_rarg1, j_rarg0\n+  };\n+  static const XMMRegister FP_ArgReg[java_return_convention_max_float] = {\n+    j_farg0, j_farg1, j_farg2, j_farg3,\n+    j_farg4, j_farg5, j_farg6, j_farg7\n+  };\n+\n+\n+  uint int_args = 0;\n+  uint fp_args = 0;\n+\n+  for (int i = 0; i < total_args_passed; i++) {\n+    switch (sig_bt[i]) {\n+    case T_BOOLEAN:\n+    case T_CHAR:\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+      if (int_args < Argument::n_int_register_parameters_j+1) {\n+        regs[i].set1(INT_ArgReg[int_args]->as_VMReg());\n+        int_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_VOID:\n+      \/\/ halves of T_LONG or T_DOUBLE\n+      assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+      regs[i].set_bad();\n+      break;\n+    case T_LONG:\n+      assert(sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      \/\/ fall through\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT:\n+    case T_ARRAY:\n+    case T_ADDRESS:\n+    case T_METADATA:\n+      if (int_args < Argument::n_int_register_parameters_j+1) {\n+        regs[i].set2(INT_ArgReg[int_args]->as_VMReg());\n+        int_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_FLOAT:\n+      if (fp_args < Argument::n_float_register_parameters_j) {\n+        regs[i].set1(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_DOUBLE:\n+      assert(sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      if (fp_args < Argument::n_float_register_parameters_j) {\n+        regs[i].set2(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  return int_args + fp_args;\n+}\n+\n@@ -605,0 +689,106 @@\n+\/\/ For each inline type argument, sig includes the list of fields of\n+\/\/ the inline type. This utility function computes the number of\n+\/\/ arguments for the call if inline types are passed by reference (the\n+\/\/ calling convention the interpreter expects).\n+static int compute_total_args_passed_int(const GrowableArray<SigEntry>* sig_extended) {\n+  int total_args_passed = 0;\n+  if (InlineTypePassFieldsAsArgs) {\n+    for (int i = 0; i < sig_extended->length(); i++) {\n+      BasicType bt = sig_extended->at(i)._bt;\n+      if (bt == T_PRIMITIVE_OBJECT) {\n+        \/\/ In sig_extended, an inline type argument starts with:\n+        \/\/ T_PRIMITIVE_OBJECT, followed by the types of the fields of the\n+        \/\/ inline type and T_VOID to mark the end of the value\n+        \/\/ type. Inline types are flattened so, for instance, in the\n+        \/\/ case of an inline type with an int field and an inline type\n+        \/\/ field that itself has 2 fields, an int and a long:\n+        \/\/ T_PRIMITIVE_OBJECT T_INT T_PRIMITIVE_OBJECT T_INT T_LONG T_VOID (second\n+        \/\/ slot for the T_LONG) T_VOID (inner T_PRIMITIVE_OBJECT) T_VOID\n+        \/\/ (outer T_PRIMITIVE_OBJECT)\n+        total_args_passed++;\n+        int vt = 1;\n+        do {\n+          i++;\n+          BasicType bt = sig_extended->at(i)._bt;\n+          BasicType prev_bt = sig_extended->at(i-1)._bt;\n+          if (bt == T_PRIMITIVE_OBJECT) {\n+            vt++;\n+          } else if (bt == T_VOID &&\n+                     prev_bt != T_LONG &&\n+                     prev_bt != T_DOUBLE) {\n+            vt--;\n+          }\n+        } while (vt != 0);\n+      } else {\n+        total_args_passed++;\n+      }\n+    }\n+  } else {\n+    total_args_passed = sig_extended->length();\n+  }\n+  return total_args_passed;\n+}\n+\n+\n+static void gen_c2i_adapter_helper(MacroAssembler* masm,\n+                                   BasicType bt,\n+                                   BasicType prev_bt,\n+                                   size_t size_in_bytes,\n+                                   const VMRegPair& reg_pair,\n+                                   const Address& to,\n+                                   int extraspace,\n+                                   bool is_oop) {\n+  assert(bt != T_PRIMITIVE_OBJECT || !InlineTypePassFieldsAsArgs, \"no inline type here\");\n+  if (bt == T_VOID) {\n+    assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, \"missing half\");\n+    return;\n+  }\n+\n+  \/\/ Say 4 args:\n+  \/\/ i   st_off\n+  \/\/ 0   32 T_LONG\n+  \/\/ 1   24 T_VOID\n+  \/\/ 2   16 T_OBJECT\n+  \/\/ 3    8 T_BOOL\n+  \/\/ -    0 return address\n+  \/\/\n+  \/\/ However to make thing extra confusing. Because we can fit a long\/double in\n+  \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n+  \/\/ leaves one slot empty and only stores to a single slot. In this case the\n+  \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n+\n+  bool wide = (size_in_bytes == wordSize);\n+  VMReg r_1 = reg_pair.first();\n+  VMReg r_2 = reg_pair.second();\n+  assert(r_2->is_valid() == wide, \"invalid size\");\n+  if (!r_1->is_valid()) {\n+    assert(!r_2->is_valid(), \"must be invalid\");\n+    return;\n+  }\n+\n+  if (!r_1->is_XMMRegister()) {\n+    Register val = rax;\n+    if (r_1->is_stack()) {\n+      int ld_off = r_1->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+      __ load_sized_value(val, Address(rsp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+    } else {\n+      val = r_1->as_Register();\n+    }\n+    assert_different_registers(to.base(), val, rscratch1);\n+    if (is_oop) {\n+      __ push(r13);\n+      __ push(rbx);\n+      __ store_heap_oop(to, val, rscratch1, r13, rbx, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      __ pop(rbx);\n+      __ pop(r13);\n+    } else {\n+      __ store_sized_value(to, val, size_in_bytes);\n+    }\n+  } else {\n+    if (wide) {\n+      __ movdbl(to, r_1->as_XMMRegister());\n+    } else {\n+      __ movflt(to, r_1->as_XMMRegister());\n+    }\n+  }\n+}\n@@ -607,3 +797,1 @@\n-                            int total_args_passed,\n-                            int comp_args_on_stack,\n-                            const BasicType *sig_bt,\n+                            const GrowableArray<SigEntry>* sig_extended,\n@@ -611,1 +799,6 @@\n-                            Label& skip_fixup) {\n+                            Label& skip_fixup,\n+                            address start,\n+                            OopMapSet* oop_maps,\n+                            int& frame_complete,\n+                            int& frame_size_in_words,\n+                            bool alloc_inline_receiver) {\n@@ -621,0 +814,42 @@\n+  if (InlineTypePassFieldsAsArgs) {\n+    \/\/ Is there an inline type argument?\n+    bool has_inline_argument = false;\n+    for (int i = 0; i < sig_extended->length() && !has_inline_argument; i++) {\n+      has_inline_argument = (sig_extended->at(i)._bt == T_PRIMITIVE_OBJECT);\n+    }\n+    if (has_inline_argument) {\n+      \/\/ There is at least an inline type argument: we're coming from\n+      \/\/ compiled code so we have no buffers to back the inline types.\n+      \/\/ Allocate the buffers here with a runtime call.\n+      OopMap* map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ false);\n+\n+      frame_complete = __ offset();\n+\n+      __ set_last_Java_frame(noreg, noreg, NULL);\n+\n+      __ mov(c_rarg0, r15_thread);\n+      __ mov(c_rarg1, rbx);\n+      __ mov64(c_rarg2, (int64_t)alloc_inline_receiver);\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));\n+\n+      oop_maps->add_gc_map((int)(__ pc() - start), map);\n+      __ reset_last_Java_frame(false);\n+\n+      RegisterSaver::restore_live_registers(masm);\n+\n+      Label no_exception;\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+      __ jcc(Assembler::equal, no_exception);\n+\n+      __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);\n+      __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+      __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+      __ bind(no_exception);\n+\n+      \/\/ We get an array of objects from the runtime call\n+      __ get_vm_result(rscratch2, r15_thread); \/\/ Use rscratch2 (r11) as temporary because rscratch1 (r10) is trashed by movptr()\n+      __ get_vm_result_2(rbx, r15_thread); \/\/ TODO: required to keep the callee Method live?\n+    }\n+  }\n+\n@@ -625,1 +860,1 @@\n-\n+  int total_args_passed = compute_total_args_passed_int(sig_extended);\n@@ -643,46 +878,24 @@\n-  for (int i = 0; i < total_args_passed; i++) {\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n-      continue;\n-    }\n-\n-    \/\/ offset to start parameters\n-    int st_off   = (total_args_passed - i) * Interpreter::stackElementSize;\n-    int next_off = st_off - Interpreter::stackElementSize;\n-\n-    \/\/ Say 4 args:\n-    \/\/ i   st_off\n-    \/\/ 0   32 T_LONG\n-    \/\/ 1   24 T_VOID\n-    \/\/ 2   16 T_OBJECT\n-    \/\/ 3    8 T_BOOL\n-    \/\/ -    0 return address\n-    \/\/\n-    \/\/ However to make thing extra confusing. Because we can fit a long\/double in\n-    \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n-    \/\/ leaves one slot empty and only stores to a single slot. In this case the\n-    \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n-\n-    VMReg r_1 = regs[i].first();\n-    VMReg r_2 = regs[i].second();\n-    if (!r_1->is_valid()) {\n-      assert(!r_2->is_valid(), \"\");\n-      continue;\n-    }\n-    if (r_1->is_stack()) {\n-      \/\/ memory to memory use rax\n-      int ld_off = r_1->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n-      if (!r_2->is_valid()) {\n-        \/\/ sign extend??\n-        __ movl(rax, Address(rsp, ld_off));\n-        __ movptr(Address(rsp, st_off), rax);\n-\n-      } else {\n-\n-        __ movq(rax, Address(rsp, ld_off));\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ ld_off == LSW, ld_off+wordSize == MSW\n-          \/\/ st_off == MSW, next_off == LSW\n-          __ movq(Address(rsp, next_off), rax);\n+  \/\/ next_arg_comp is the next argument from the compiler point of\n+  \/\/ view (inline type fields are passed in registers\/on the stack). In\n+  \/\/ sig_extended, an inline type argument starts with: T_PRIMITIVE_OBJECT,\n+  \/\/ followed by the types of the fields of the inline type and T_VOID\n+  \/\/ to mark the end of the inline type. ignored counts the number of\n+  \/\/ T_PRIMITIVE_OBJECT\/T_VOID. next_vt_arg is the next inline type argument:\n+  \/\/ used to get the buffer for that argument from the pool of buffers\n+  \/\/ we allocated above and want to pass to the\n+  \/\/ interpreter. next_arg_int is the next argument from the\n+  \/\/ interpreter point of view (inline types are passed by reference).\n+  for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;\n+       next_arg_comp < sig_extended->length(); next_arg_comp++) {\n+    assert(ignored <= next_arg_comp, \"shouldn't skip over more slots than there are arguments\");\n+    assert(next_arg_int <= total_args_passed, \"more arguments for the interpreter than expected?\");\n+    BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+    int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;\n+    if (!InlineTypePassFieldsAsArgs || bt != T_PRIMITIVE_OBJECT) {\n+      int next_off = st_off - Interpreter::stackElementSize;\n+      const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;\n+      const VMRegPair reg_pair = regs[next_arg_comp-ignored];\n+      size_t size_in_bytes = reg_pair.second()->is_valid() ? 8 : 4;\n+      gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                             size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);\n+      next_arg_int++;\n@@ -691,7 +904,4 @@\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov64(rax, CONST64(0xdeadffffdeadaaaa));\n-          __ movptr(Address(rsp, st_off), rax);\n-#endif \/* ASSERT *\/\n-        } else {\n-          __ movq(Address(rsp, st_off), rax);\n-        }\n+      if (bt == T_LONG || bt == T_DOUBLE) {\n+        \/\/ Overwrite the unused slot with known junk\n+        __ mov64(rax, CONST64(0xdeadffffdeadaaaa));\n+        __ movptr(Address(rsp, st_off), rax);\n@@ -699,16 +909,26 @@\n-    } else if (r_1->is_Register()) {\n-      Register r = r_1->as_Register();\n-      if (!r_2->is_valid()) {\n-        \/\/ must be only an int (or less ) so move only 32bits to slot\n-        \/\/ why not sign extend??\n-        __ movl(Address(rsp, st_off), r);\n-      } else {\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ long\/double in gpr\n-#ifdef ASSERT\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov64(rax, CONST64(0xdeadffffdeadaaab));\n-          __ movptr(Address(rsp, st_off), rax);\n-          __ movq(Address(rsp, next_off), r);\n+    } else {\n+      ignored++;\n+      \/\/ get the buffer from the just allocated pool of buffers\n+      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_PRIMITIVE_OBJECT);\n+      __ load_heap_oop(r14, Address(rscratch2, index));\n+      next_vt_arg++; next_arg_int++;\n+      int vt = 1;\n+      \/\/ write fields we get from compiled code in registers\/stack\n+      \/\/ slots to the buffer: we know we are done with that inline type\n+      \/\/ argument when we hit the T_VOID that acts as an end of inline\n+      \/\/ type delimiter for this inline type. Inline types are flattened\n+      \/\/ so we might encounter embedded inline types. Each entry in\n+      \/\/ sig_extended contains a field offset in the buffer.\n+      Label L_null;\n+      do {\n+        next_arg_comp++;\n+        BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+        BasicType prev_bt = sig_extended->at(next_arg_comp-1)._bt;\n+        if (bt == T_PRIMITIVE_OBJECT) {\n+          vt++;\n+          ignored++;\n+        } else if (bt == T_VOID &&\n+                   prev_bt != T_LONG &&\n+                   prev_bt != T_DOUBLE) {\n+          vt--;\n+          ignored++;\n@@ -717,1 +937,22 @@\n-          __ movptr(Address(rsp, st_off), r);\n+          int off = sig_extended->at(next_arg_comp)._offset;\n+          if (off == -1) {\n+            \/\/ Nullable inline type argument, emit null check\n+            VMReg reg = regs[next_arg_comp-ignored].first();\n+            Label L_notNull;\n+            if (reg->is_stack()) {\n+              int ld_off = reg->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+              __ testb(Address(rsp, ld_off), 1);\n+            } else {\n+              __ testb(reg->as_Register(), 1);\n+            }\n+            __ jcc(Assembler::notZero, L_notNull);\n+            __ movptr(Address(rsp, st_off), 0);\n+            __ jmp(L_null);\n+            __ bind(L_notNull);\n+            continue;\n+          }\n+          assert(off > 0, \"offset in object should be positive\");\n+          size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+          bool is_oop = is_reference_type(bt);\n+          gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                                 size_in_bytes, regs[next_arg_comp-ignored], Address(r14, off), extraspace, is_oop);\n@@ -719,14 +960,4 @@\n-      }\n-    } else {\n-      assert(r_1->is_XMMRegister(), \"\");\n-      if (!r_2->is_valid()) {\n-        \/\/ only a float use just part of the slot\n-        __ movflt(Address(rsp, st_off), r_1->as_XMMRegister());\n-      } else {\n-#ifdef ASSERT\n-        \/\/ Overwrite the unused slot with known junk\n-        __ mov64(rax, CONST64(0xdeadffffdeadaaac));\n-        __ movptr(Address(rsp, st_off), rax);\n-#endif \/* ASSERT *\/\n-        __ movdbl(Address(rsp, next_off), r_1->as_XMMRegister());\n-      }\n+      } while (vt != 0);\n+      \/\/ pass the buffer to the interpreter\n+      __ movptr(Address(rsp, st_off), r14);\n+      __ bind(L_null);\n@@ -755,2 +986,1 @@\n-                                    int total_args_passed,\n-                                    const BasicType *sig_bt,\n+                                    const GrowableArray<SigEntry>* sig,\n@@ -849,1 +1079,1 @@\n-  __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_offset())));\n+  __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_inline_offset())));\n@@ -863,0 +1093,2 @@\n+  int total_args_passed = sig->length();\n+\n@@ -866,1 +1098,3 @@\n-    if (sig_bt[i] == T_VOID) {\n+    BasicType bt = sig->at(i)._bt;\n+    assert(bt != T_PRIMITIVE_OBJECT, \"i2c adapter doesn't unpack inline type args\");\n+    if (bt == T_VOID) {\n@@ -869,1 +1103,2 @@\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n+      BasicType prev_bt = (i > 0) ? sig->at(i-1)._bt : T_ILLEGAL;\n+      assert(i > 0 && (prev_bt == T_LONG || prev_bt == T_DOUBLE), \"missing half\");\n@@ -911,1 +1146,1 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n+        const int offset = (bt==T_LONG||bt==T_DOUBLE)?\n@@ -926,1 +1161,1 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n+        const int offset = (bt==T_LONG||bt==T_DOUBLE)?\n@@ -959,1 +1194,1 @@\n-  \/\/ only needed because eof c2 resolve stubs return Method* as a result in\n+  \/\/ only needed because of c2 resolve stubs return Method* as a result in\n@@ -965,0 +1200,22 @@\n+static void gen_inline_cache_check(MacroAssembler *masm, Label& skip_fixup) {\n+  Label ok;\n+\n+  Register holder = rax;\n+  Register receiver = j_rarg0;\n+  Register temp = rbx;\n+\n+  __ load_klass(temp, receiver, rscratch1);\n+  __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));\n+  __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));\n+  __ jcc(Assembler::equal, ok);\n+  __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+\n+  __ bind(ok);\n+  \/\/ Method might have been compiled since the call site was patched to\n+  \/\/ interpreted if that is the case treat it as a miss so we can get\n+  \/\/ the call site corrected.\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::equal, skip_fixup);\n+  __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+}\n+\n@@ -966,2 +1223,1 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n@@ -969,3 +1225,9 @@\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+                                                            const GrowableArray<SigEntry>* sig,\n+                                                            const VMRegPair* regs,\n+                                                            const GrowableArray<SigEntry>* sig_cc,\n+                                                            const VMRegPair* regs_cc,\n+                                                            const GrowableArray<SigEntry>* sig_cc_ro,\n+                                                            const VMRegPair* regs_cc_ro,\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n@@ -973,2 +1235,1 @@\n-\n-  gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);\n+  gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);\n@@ -987,4 +1248,1 @@\n-  Label ok;\n-  Register holder = rax;\n-  Register receiver = j_rarg0;\n-  Register temp = rbx;\n+  gen_inline_cache_check(masm, skip_fixup);\n@@ -993,6 +1251,3 @@\n-  {\n-    __ load_klass(temp, receiver, rscratch1);\n-    __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));\n-    __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));\n-    __ jcc(Assembler::equal, ok);\n-    __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+  OopMapSet* oop_maps = new OopMapSet();\n+  int frame_complete = CodeOffsets::frame_never_safe;\n+  int frame_size_in_words = 0;\n@@ -1000,7 +1255,5 @@\n-    __ bind(ok);\n-    \/\/ Method might have been compiled since the call site was patched to\n-    \/\/ interpreted if that is the case treat it as a miss so we can get\n-    \/\/ the call site corrected.\n-    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n-    __ jcc(Assembler::equal, skip_fixup);\n-    __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+  \/\/ Scalarized c2i adapter with non-scalarized receiver (i.e., don't pack receiver)\n+  address c2i_inline_ro_entry = __ pc();\n+  if (regs_cc != regs_cc_ro) {\n+    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+    skip_fixup.reset();\n@@ -1009,0 +1262,1 @@\n+  \/\/ Scalarized c2i adapter\n@@ -1037,1 +1291,14 @@\n-  gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);\n+  gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);\n+\n+  address c2i_unverified_inline_entry = c2i_unverified_entry;\n+\n+  \/\/ Non-scalarized c2i adapter\n+  address c2i_inline_entry = c2i_entry;\n+  if (regs != regs_cc) {\n+    Label inline_entry_skip_fixup;\n+    c2i_unverified_inline_entry = __ pc();\n+    gen_inline_cache_check(masm, inline_entry_skip_fixup);\n+\n+    c2i_inline_entry = __ pc();\n+    gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+  }\n@@ -1040,1 +1307,9 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+\n+  \/\/ The c2i adapters might safepoint and trigger a GC. The caller must make sure that\n+  \/\/ the GC knows about the location of oop argument locations passed to the c2i adapter.\n+  if (allocate_code_blob) {\n+    bool caller_must_gc_arguments = (regs != regs_cc);\n+    new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  }\n+\n+  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -1098,0 +1373,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1855,0 +2131,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1980,0 +2257,4 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        __ andptr(swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+      }\n@@ -2041,0 +2322,1 @@\n+  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n@@ -3532,0 +3814,110 @@\n+BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {\n+  BufferBlob* buf = BufferBlob::create(\"inline types pack\/unpack\", 16 * K);\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  int pack_fields_jobject_off = __ offset();\n+  \/\/ Resolve pre-allocated buffer from JNI handle.\n+  \/\/ We cannot do this in generate_call_stub() because it requires GC code to be initialized.\n+  __ movptr(rax, Address(r13, 0));\n+  __ resolve_jobject(rax \/* value *\/,\n+                     r15_thread \/* thread *\/,\n+                     r12 \/* tmp *\/);\n+  __ movptr(Address(r13, 0), rax);\n+\n+  int pack_fields_off = __ offset();\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address to(rax, off);\n+    if (bt == T_FLOAT) {\n+      __ movflt(to, r_1->as_XMMRegister());\n+    } else if (bt == T_DOUBLE) {\n+      __ movdbl(to, r_1->as_XMMRegister());\n+    } else {\n+      Register val = r_1->as_Register();\n+      assert_different_registers(to.base(), val, r14, r13, rbx, rscratch1);\n+      if (is_reference_type(bt)) {\n+        __ store_heap_oop(to, val, r14, r13, rbx, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        __ store_sized_value(to, r_1->as_Register(), type2aelembytes(bt));\n+      }\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ ret(0);\n+\n+  int unpack_fields_off = __ offset();\n+\n+  Label skip;\n+  __ testptr(rax, rax);\n+  __ jcc(Assembler::zero, skip);\n+\n+  j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address from(rax, off);\n+    if (bt == T_FLOAT) {\n+      __ movflt(r_1->as_XMMRegister(), from);\n+    } else if (bt == T_DOUBLE) {\n+      __ movdbl(r_1->as_XMMRegister(), from);\n+    } else if (bt == T_OBJECT || bt == T_ARRAY) {\n+      assert_different_registers(rax, r_1->as_Register());\n+      __ load_heap_oop(r_1->as_Register(), from);\n+    } else {\n+      assert(is_java_primitive(bt), \"unexpected basic type\");\n+      assert_different_registers(rax, r_1->as_Register());\n+      size_t size_in_bytes = type2aelembytes(bt);\n+      __ load_sized_value(r_1->as_Register(), from, size_in_bytes, bt != T_CHAR && bt != T_BOOLEAN);\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ bind(skip);\n+  __ ret(0);\n+\n+  __ flush();\n+\n+  return BufferedInlineTypeBlob::create(&buffer, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":515,"deletions":123,"binary":false,"changes":638,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/assembler.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"register_x86.hpp\"\n@@ -52,0 +54,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include \"vmreg_x86.inline.hpp\"\n@@ -65,0 +69,1 @@\n+\n@@ -355,7 +360,9 @@\n-    \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n-    __ movptr(c_rarg0, result);\n-    Label is_long, is_float, is_double, exit;\n-    __ movl(c_rarg1, result_type);\n-    __ cmpl(c_rarg1, T_OBJECT);\n-    __ jcc(Assembler::equal, is_long);\n-    __ cmpl(c_rarg1, T_LONG);\n+    \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+    __ movptr(r13, result);\n+    Label is_long, is_float, is_double, check_prim, exit;\n+    __ movl(rbx, result_type);\n+    __ cmpl(rbx, T_OBJECT);\n+    __ jcc(Assembler::equal, check_prim);\n+    __ cmpl(rbx, T_PRIMITIVE_OBJECT);\n+    __ jcc(Assembler::equal, check_prim);\n+    __ cmpl(rbx, T_LONG);\n@@ -363,1 +370,1 @@\n-    __ cmpl(c_rarg1, T_FLOAT);\n+    __ cmpl(rbx, T_FLOAT);\n@@ -365,1 +372,1 @@\n-    __ cmpl(c_rarg1, T_DOUBLE);\n+    __ cmpl(rbx, T_DOUBLE);\n@@ -369,1 +376,1 @@\n-    __ movl(Address(c_rarg0, 0), rax);\n+    __ movl(Address(r13, 0), rax);\n@@ -433,0 +440,13 @@\n+    __ BIND(check_prim);\n+    if (InlineTypeReturnedAsFields) {\n+      \/\/ Check for scalarized return value\n+      __ testptr(rax, 1);\n+      __ jcc(Assembler::zero, is_long);\n+      \/\/ Load pack handler address\n+      __ andptr(rax, -2);\n+      __ movptr(rax, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      __ movptr(rbx, Address(rax, InlineKlass::pack_handler_jobject_offset()));\n+      \/\/ Call pack handler to initialize the buffer\n+      __ call(rbx);\n+      __ jmp(exit);\n+    }\n@@ -434,1 +454,1 @@\n-    __ movq(Address(c_rarg0, 0), rax);\n+    __ movq(Address(r13, 0), rax);\n@@ -438,1 +458,1 @@\n-    __ movflt(Address(c_rarg0, 0), xmm0);\n+    __ movflt(Address(r13, 0), xmm0);\n@@ -442,1 +462,1 @@\n-    __ movdbl(Address(c_rarg0, 0), xmm0);\n+    __ movdbl(Address(r13, 0), xmm0);\n@@ -3233,0 +3253,8 @@\n+    \/\/ Check for flat inline type array -> return -1\n+    __ testl(rax_lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    __ jcc(Assembler::notZero, L_failed);\n+\n+    \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n+    __ testl(rax_lh, Klass::_lh_null_free_array_bit_inplace);\n+    __ jcc(Assembler::notZero, L_objArray);\n+\n@@ -3242,2 +3270,4 @@\n-      __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift));\n-      __ jcc(Assembler::greaterEqual, L);\n+      __ movl(rklass_tmp, rax_lh);\n+      __ sarl(rklass_tmp, Klass::_lh_array_tag_shift);\n+      __ cmpl(rklass_tmp, Klass::_lh_array_tag_type_value);\n+      __ jcc(Assembler::equal, L);\n@@ -3351,0 +3381,1 @@\n+      \/\/ This check also fails for flat\/null-free arrays which are not supported.\n@@ -3354,0 +3385,13 @@\n+#ifdef ASSERT\n+      {\n+        BLOCK_COMMENT(\"assert not null-free array {\");\n+        Label L;\n+        __ movl(rklass_tmp, Address(rax, lh_offset));\n+        __ testl(rklass_tmp, Klass::_lh_null_free_array_bit_inplace);\n+        __ jcc(Assembler::zero, L);\n+        __ stop(\"unexpected null-free array\");\n+        __ bind(L);\n+        BLOCK_COMMENT(\"} assert not null-free array\");\n+      }\n+#endif\n+\n@@ -7868,0 +7912,144 @@\n+  \/\/ Call here from the interpreter or compiled code to either load\n+  \/\/ multiple returned values from the inline type instance being\n+  \/\/ returned to registers or to store returned values to a newly\n+  \/\/ allocated inline type instance.\n+  \/\/ Register is a class, but it would be assigned numerical value.\n+  \/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+  PRAGMA_DIAG_PUSH\n+  PRAGMA_NONNULL_IGNORED\n+  address generate_return_value_stub(address destination, const char* name, bool has_res) {\n+    \/\/ We need to save all registers the calling convention may use so\n+    \/\/ the runtime calls read or update those registers. This needs to\n+    \/\/ be in sync with SharedRuntime::java_return_convention().\n+    enum layout {\n+      pad_off = frame::arg_reg_save_area_bytes\/BytesPerInt, pad_off_2,\n+      rax_off, rax_off_2,\n+      j_rarg5_off, j_rarg5_2,\n+      j_rarg4_off, j_rarg4_2,\n+      j_rarg3_off, j_rarg3_2,\n+      j_rarg2_off, j_rarg2_2,\n+      j_rarg1_off, j_rarg1_2,\n+      j_rarg0_off, j_rarg0_2,\n+      j_farg0_off, j_farg0_2,\n+      j_farg1_off, j_farg1_2,\n+      j_farg2_off, j_farg2_2,\n+      j_farg3_off, j_farg3_2,\n+      j_farg4_off, j_farg4_2,\n+      j_farg5_off, j_farg5_2,\n+      j_farg6_off, j_farg6_2,\n+      j_farg7_off, j_farg7_2,\n+      rbp_off, rbp_off_2,\n+      return_off, return_off_2,\n+\n+      framesize\n+    };\n+\n+    CodeBuffer buffer(name, 1000, 512);\n+    MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+    int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+    assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+    int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+    int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+    OopMapSet *oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(rax_off), rax->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+    int start = __ offset();\n+\n+    __ subptr(rsp, frame_size_in_bytes - 8 \/* return address*\/);\n+\n+    __ movptr(Address(rsp, rbp_off * BytesPerInt), rbp);\n+    __ movdbl(Address(rsp, j_farg7_off * BytesPerInt), j_farg7);\n+    __ movdbl(Address(rsp, j_farg6_off * BytesPerInt), j_farg6);\n+    __ movdbl(Address(rsp, j_farg5_off * BytesPerInt), j_farg5);\n+    __ movdbl(Address(rsp, j_farg4_off * BytesPerInt), j_farg4);\n+    __ movdbl(Address(rsp, j_farg3_off * BytesPerInt), j_farg3);\n+    __ movdbl(Address(rsp, j_farg2_off * BytesPerInt), j_farg2);\n+    __ movdbl(Address(rsp, j_farg1_off * BytesPerInt), j_farg1);\n+    __ movdbl(Address(rsp, j_farg0_off * BytesPerInt), j_farg0);\n+\n+    __ movptr(Address(rsp, j_rarg0_off * BytesPerInt), j_rarg0);\n+    __ movptr(Address(rsp, j_rarg1_off * BytesPerInt), j_rarg1);\n+    __ movptr(Address(rsp, j_rarg2_off * BytesPerInt), j_rarg2);\n+    __ movptr(Address(rsp, j_rarg3_off * BytesPerInt), j_rarg3);\n+    __ movptr(Address(rsp, j_rarg4_off * BytesPerInt), j_rarg4);\n+    __ movptr(Address(rsp, j_rarg5_off * BytesPerInt), j_rarg5);\n+    __ movptr(Address(rsp, rax_off * BytesPerInt), rax);\n+\n+    int frame_complete = __ offset();\n+\n+    __ set_last_Java_frame(noreg, noreg, NULL);\n+\n+    __ mov(c_rarg0, r15_thread);\n+    __ mov(c_rarg1, rax);\n+\n+    __ call(RuntimeAddress(destination));\n+\n+    \/\/ Set an oopmap for the call site.\n+\n+    oop_maps->add_gc_map( __ offset() - start, map);\n+\n+    \/\/ clear last_Java_sp\n+    __ reset_last_Java_frame(false);\n+\n+    __ movptr(rbp, Address(rsp, rbp_off * BytesPerInt));\n+    __ movdbl(j_farg7, Address(rsp, j_farg7_off * BytesPerInt));\n+    __ movdbl(j_farg6, Address(rsp, j_farg6_off * BytesPerInt));\n+    __ movdbl(j_farg5, Address(rsp, j_farg5_off * BytesPerInt));\n+    __ movdbl(j_farg4, Address(rsp, j_farg4_off * BytesPerInt));\n+    __ movdbl(j_farg3, Address(rsp, j_farg3_off * BytesPerInt));\n+    __ movdbl(j_farg2, Address(rsp, j_farg2_off * BytesPerInt));\n+    __ movdbl(j_farg1, Address(rsp, j_farg1_off * BytesPerInt));\n+    __ movdbl(j_farg0, Address(rsp, j_farg0_off * BytesPerInt));\n+\n+    __ movptr(j_rarg0, Address(rsp, j_rarg0_off * BytesPerInt));\n+    __ movptr(j_rarg1, Address(rsp, j_rarg1_off * BytesPerInt));\n+    __ movptr(j_rarg2, Address(rsp, j_rarg2_off * BytesPerInt));\n+    __ movptr(j_rarg3, Address(rsp, j_rarg3_off * BytesPerInt));\n+    __ movptr(j_rarg4, Address(rsp, j_rarg4_off * BytesPerInt));\n+    __ movptr(j_rarg5, Address(rsp, j_rarg5_off * BytesPerInt));\n+    __ movptr(rax, Address(rsp, rax_off * BytesPerInt));\n+\n+    __ addptr(rsp, frame_size_in_bytes-8);\n+\n+    \/\/ check for pending exceptions\n+    Label pending;\n+    __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    __ jcc(Assembler::notEqual, pending);\n+\n+    if (has_res) {\n+      __ get_vm_result(rax, r15_thread);\n+    }\n+\n+    __ ret(0);\n+\n+    __ bind(pending);\n+\n+    __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+    \/\/ -------------\n+    \/\/ make sure all code is generated\n+    masm->flush();\n+\n+    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, false);\n+    return stub->entry_point();\n+  }\n+\n@@ -7883,2 +8071,8 @@\n-    StubRoutines::_call_stub_entry =\n-      generate_call_stub(StubRoutines::_call_stub_return_address);\n+    \/\/ Generate these first because they are called from other stubs\n+    if (InlineTypeReturnedAsFields) {\n+      StubRoutines::_load_inline_type_fields_in_regs =\n+        generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs), \"load_inline_type_fields_in_regs\", false);\n+      StubRoutines::_store_inline_type_fields_to_buf =\n+        generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf), \"store_inline_type_fields_to_buf\", true);\n+    }\n+    StubRoutines::_call_stub_entry = generate_call_stub(StubRoutines::_call_stub_return_address);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":211,"deletions":17,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -63,1 +64,1 @@\n-int TemplateInterpreter::InterpreterCodeSize = JVMCI_ONLY(268) NOT_JVMCI(256) * 1024;\n+int TemplateInterpreter::InterpreterCodeSize = JVMCI_ONLY(280) NOT_JVMCI(268) * 1024;\n@@ -211,0 +212,4 @@\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    __ store_inline_type_fields_to_buf(NULL);\n+  }\n+\n@@ -353,0 +358,1 @@\n+  case T_PRIMITIVE_OBJECT: \/\/ fall through (inline types are handled with oops)\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -178,0 +179,1 @@\n+  case Bytecodes::_fast_qputfield:\n@@ -370,0 +372,1 @@\n+  __ andl(rdx, ~JVM_CONSTANT_QDescBit);\n@@ -821,9 +824,27 @@\n-  \/\/ rax: index\n-  \/\/ rdx: array\n-  index_check(rdx, rax); \/\/ kills rbx\n-  do_oop_load(_masm,\n-              Address(rdx, rax,\n-                      UseCompressedOops ? Address::times_4 : Address::times_ptr,\n-                      arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n-              rax,\n-              IS_ARRAY);\n+  Register array = rdx;\n+  Register index = rax;\n+\n+  index_check(array, index); \/\/ kills rbx\n+  __ profile_array(rbx, array, rcx);\n+  if (UseFlatArray) {\n+    Label is_flat_array, done;\n+    __ test_flattened_array_oop(array, rbx, is_flat_array);\n+    do_oop_load(_masm,\n+                Address(array, index,\n+                        UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+                        arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n+                rax,\n+                IS_ARRAY);\n+    __ jmp(done);\n+    __ bind(is_flat_array);\n+    __ read_flattened_element(array, index, rbx, rcx, rax);\n+    __ bind(done);\n+  } else {\n+    do_oop_load(_masm,\n+                Address(array, index,\n+                        UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+                        arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n+                rax,\n+                IS_ARRAY);\n+  }\n+  __ profile_element(rbx, rax, rcx);\n@@ -1115,1 +1136,1 @@\n-  Label is_null, ok_is_subtype, done;\n+  Label is_null, is_flat_array, ok_is_subtype, done;\n@@ -1127,0 +1148,4 @@\n+\n+  __ profile_array(rdi, rdx, rbx);\n+  __ profile_element(rdi, rax, rbx);\n+\n@@ -1130,0 +1155,1 @@\n+  \/\/ Move array class to rdi\n@@ -1131,0 +1157,6 @@\n+  __ load_klass(rdi, rdx, tmp_load_klass);\n+  if (UseFlatArray) {\n+    __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));\n+    __ test_flattened_array_layout(rbx, is_flat_array);\n+  }\n+\n@@ -1133,3 +1165,2 @@\n-  \/\/ Move superklass into rax\n-  __ load_klass(rax, rdx, tmp_load_klass);\n-  __ movptr(rax, Address(rax,\n+  \/\/ Move array element superklass into rax\n+  __ movptr(rax, Address(rdi,\n@@ -1140,1 +1171,2 @@\n-  __ gen_subtype_check(rbx, ok_is_subtype);\n+  \/\/ is \"rbx <: rax\" ? (value subclass <: array element superclass)\n+  __ gen_subtype_check(rbx, ok_is_subtype, false);\n@@ -1158,1 +1190,2 @@\n-  __ profile_null_seen(rbx);\n+  if (EnableValhalla) {\n+    Label is_null_into_value_array_npe, store_null;\n@@ -1160,0 +1193,9 @@\n+    \/\/ No way to store null in null-free array\n+    __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);\n+    __ jmp(store_null);\n+\n+    __ bind(is_null_into_value_array_npe);\n+    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+\n+    __ bind(store_null);\n+  }\n@@ -1162,0 +1204,7 @@\n+  __ jmp(done);\n+\n+  if (EnableValhalla) {\n+    Label is_type_ok;\n+    __ bind(is_flat_array); \/\/ Store non-null value to flat\n+\n+    \/\/ Simplistic type check...\n@@ -1163,0 +1212,27 @@\n+    \/\/ Profile the not-null value's klass.\n+    __ load_klass(rbx, rax, tmp_load_klass);\n+    \/\/ Move element klass into rax\n+    __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));\n+    \/\/ flat value array needs exact type match\n+    \/\/ is \"rax == rbx\" (value subclass == array element superclass)\n+    __ cmpptr(rax, rbx);\n+    __ jccb(Assembler::equal, is_type_ok);\n+\n+    __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n+\n+    __ bind(is_type_ok);\n+    \/\/ rbx: value's klass\n+    \/\/ rdx: array\n+    \/\/ rdi: array klass\n+    __ test_klass_is_empty_inline_type(rbx, rax, done);\n+\n+    \/\/ calc dst for copy\n+    __ movl(rax, at_tos_p1()); \/\/ index\n+    __ data_for_value_array_index(rdx, rdi, rax, rax);\n+\n+    \/\/ ...and src for copy\n+    __ movptr(rcx, at_tos());  \/\/ value\n+    __ data_for_oop(rcx, rcx, rbx);\n+\n+    __ access_value_copy(IN_HEAP, rcx, rax, rbx);\n+  }\n@@ -2332,1 +2408,1 @@\n-  Label not_taken;\n+  Label taken, not_taken;\n@@ -2334,0 +2410,36 @@\n+\n+  __ profile_acmp(rbx, rdx, rax, rcx);\n+\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  if (EnableValhalla) {\n+    __ cmpoop(rdx, rax);\n+    __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);\n+\n+    \/\/ might be substitutable, test if either rax or rdx is null\n+    __ testptr(rax, rax);\n+    __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);\n+    __ testptr(rdx, rdx);\n+    __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ and both are values ?\n+    __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(rbx, is_inline_type_mask);\n+    __ cmpptr(rbx, is_inline_type_mask);\n+    __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ same value klass ?\n+    __ load_metadata(rbx, rdx);\n+    __ load_metadata(rcx, rax);\n+    __ cmpptr(rbx, rcx);\n+    __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ Know both are the same type, let's test for substitutability...\n+    if (cc == equal) {\n+      invoke_is_substitutable(rax, rdx, taken, not_taken);\n+    } else {\n+      invoke_is_substitutable(rax, rdx, not_taken, taken);\n+    }\n+    __ stop(\"Not reachable\");\n+  }\n+\n@@ -2336,0 +2448,1 @@\n+  __ bind(taken);\n@@ -2338,1 +2451,10 @@\n-  __ profile_not_taken_branch(rax);\n+  __ profile_not_taken_branch(rax, true);\n+}\n+\n+void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,\n+                                            Label& is_subst, Label& not_subst) {\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);\n+  \/\/ Restored...rax answer, jmp to outcome...\n+  __ testl(rax, rax);\n+  __ jcc(Assembler::zero, not_subst);\n+  __ jmp(is_subst);\n@@ -2609,1 +2731,2 @@\n-  __ remove_activation(state, rbcp);\n+\n+  __ remove_activation(state, rbcp, true, true, true);\n@@ -2807,0 +2930,1 @@\n+  const Register flags2 = rdx;\n@@ -2812,2 +2936,0 @@\n-  if (!is_static) pop_and_check_object(obj);\n-\n@@ -2816,1 +2938,9 @@\n-  Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;\n+  Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notInlineType;\n+\n+  if (!is_static) {\n+    __ movptr(rcx, Address(cache, index, Address::times_ptr,\n+                           in_bytes(ConstantPoolCache::base_offset() +\n+                                    ConstantPoolCacheEntry::f1_offset())));\n+  }\n+\n+  __ movl(flags2, flags);\n@@ -2826,0 +2956,1 @@\n+  if (!is_static) pop_and_check_object(obj);\n@@ -2835,0 +2966,1 @@\n+\n@@ -2837,1 +2969,1 @@\n-\n+   if (!is_static) pop_and_check_object(obj);\n@@ -2852,4 +2984,89 @@\n-  do_oop_load(_masm, field, rax);\n-  __ push(atos);\n-  if (!is_static && rc == may_rewrite) {\n-    patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+  if (!EnableValhalla) {\n+    if (!is_static) pop_and_check_object(obj);\n+    do_oop_load(_masm, field, rax);\n+    __ push(atos);\n+    if (!is_static && rc == may_rewrite) {\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+    }\n+    __ jmp(Done);\n+  } else {\n+    if (is_static) {\n+      __ load_heap_oop(rax, field);\n+      if (EnableValhalla) {\n+        Label is_null_free_inline_type, uninitialized;\n+        \/\/ Issue below if the static field has not been initialized yet\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+          \/\/ field is not a null free inline type\n+          __ push(atos);\n+          __ jmp(Done);\n+        \/\/ field is a null free inline type, must not return null even if uninitialized\n+        __ bind(is_null_free_inline_type);\n+           __ testptr(rax, rax);\n+          __ jcc(Assembler::zero, uninitialized);\n+            __ push(atos);\n+            __ jmp(Done);\n+          __ bind(uninitialized);\n+            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+  #ifdef _LP64\n+            Label slow_case, finish;\n+            __ movptr(rbx, Address(obj, java_lang_Class::klass_offset()));\n+            __ cmpb(Address(rbx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+            __ jcc(Assembler::notEqual, slow_case);\n+          __ get_default_value_oop(rbx, rscratch1, rax);\n+          __ jmp(finish);\n+          __ bind(slow_case);\n+  #endif \/\/ LP64\n+            __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field),\n+                  obj, flags2);\n+  #ifdef _LP64\n+            __ bind(finish);\n+  #endif \/\/ _LP64\n+      }\n+        __ verify_oop(rax);\n+        __ push(atos);\n+        __ jmp(Done);\n+    } else {\n+      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      if (EnableValhalla) {\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+      }\n+      \/\/ field is not a null free inline type\n+      pop_and_check_object(obj);\n+      __ load_heap_oop(rax, field);\n+      __ push(atos);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+      }\n+      __ jmp(Done);\n+      if (EnableValhalla) {\n+        __ bind(is_inline_type);\n+          __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+            \/\/ field is not inlined\n+            __ movptr(rax, rcx);  \/\/ small dance required to preserve the klass_holder somewhere\n+            pop_and_check_object(obj);\n+            __ push(rax);\n+            __ load_heap_oop(rax, field);\n+            __ pop(rcx);\n+            __ testptr(rax, rax);\n+            __ jcc(Assembler::notZero, nonnull);\n+              __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+              __ get_inline_type_field_klass(rcx, flags2, rbx);\n+              __ get_default_value_oop(rbx, rcx, rax);\n+            __ bind(nonnull);\n+            __ verify_oop(rax);\n+            __ push(atos);\n+            __ jmp(rewrite_inline);\n+          __ bind(is_inlined);\n+          \/\/ field is inlined\n+            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+            pop_and_check_object(rax);\n+            __ read_inlined_field(rcx, flags2, rbx, rax);\n+            __ verify_oop(rax);\n+            __ push(atos);\n+        __ bind(rewrite_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);\n+        }\n+        __ jmp(Done);\n+      }\n+    }\n@@ -2857,1 +3074,0 @@\n-  __ jmp(Done);\n@@ -2860,0 +3076,3 @@\n+\n+  if (!is_static) pop_and_check_object(obj);\n+\n@@ -2959,0 +3178,22 @@\n+void TemplateTable::withfield() {\n+  transition(vtos, atos);\n+\n+  Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n+  Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n+\n+  resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));\n+\n+  Register cpentry = rbx;\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  __ lea(cpentry, Address(cache, index, Address::times_ptr,\n+                         in_bytes(cp_base_offset)));\n+  __ lea(rax, at_tos());\n+  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cpentry, rax);\n+  \/\/ new value type is returned in rbx\n+  \/\/ stack adjustment is returned in rax\n+  __ verify_oop(rbx);\n+  __ addptr(rsp, rax);\n+  __ movptr(rax, rbx);\n+}\n@@ -3054,0 +3295,1 @@\n+  const Register flags2 = rdx;\n@@ -3070,0 +3312,1 @@\n+  __ movl(flags2, flags);\n@@ -3072,1 +3315,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n@@ -3078,1 +3321,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n@@ -3084,1 +3327,1 @@\n-                                              Register obj, Register off, Register flags) {\n+                                              Register obj, Register off, Register flags, Register flags2) {\n@@ -3091,1 +3334,1 @@\n-        notLong, notFloat, notObj;\n+        notLong, notFloat, notObj, notInlineType;\n@@ -3134,6 +3377,59 @@\n-    __ pop(atos);\n-    if (!is_static) pop_and_check_object(obj);\n-    \/\/ Store into the field\n-    do_oop_store(_masm, field, rax);\n-    if (!is_static && rc == may_rewrite) {\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+    if (!EnableValhalla) {\n+      __ pop(atos);\n+      if (!is_static) pop_and_check_object(obj);\n+      \/\/ Store into the field\n+      do_oop_store(_masm, field, rax);\n+      if (!is_static && rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+      }\n+      __ jmp(Done);\n+    } else {\n+      __ pop(atos);\n+      if (is_static) {\n+        Label is_inline_type;\n+        if (EnableValhalla) {\n+          __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+          __ null_check(rax);\n+          __ bind(is_inline_type);\n+        }\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(Done);\n+      } else {\n+        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        if (EnableValhalla) {\n+          __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        }\n+        \/\/ Not an inline type\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        __ bind(rewrite_not_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+        }\n+        __ jmp(Done);\n+        if (EnableValhalla) {\n+          \/\/ Implementation of the inline type semantic\n+          __ bind(is_inline_type);\n+          __ null_check(rax);\n+          __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+          \/\/ field is not inlined\n+          pop_and_check_object(obj);\n+          \/\/ Store into the field\n+          do_oop_store(_masm, field, rax);\n+          __ jmp(rewrite_inline);\n+          __ bind(is_inlined);\n+          \/\/ field is inlined\n+          pop_and_check_object(obj);\n+          assert_different_registers(rax, rdx, obj, off);\n+          __ load_klass(rdx, rax, rscratch1);\n+          __ data_for_oop(rax, rax, rdx);\n+          __ addptr(obj, off);\n+          __ access_value_copy(IN_HEAP, rax, obj, rdx);\n+          __ bind(rewrite_inline);\n+          if (rc == may_rewrite) {\n+            patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);\n+          }\n+          __ jmp(Done);\n+        }\n+      }\n@@ -3141,1 +3437,0 @@\n-    __ jmp(Done);\n@@ -3280,0 +3575,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -3305,0 +3601,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/ fall through\n@@ -3344,0 +3641,4 @@\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rscratch2, rdx);  \/\/ saving flags for is_inlined test\n+  }\n+\n@@ -3357,1 +3658,4 @@\n-  fast_storefield_helper(field, rax);\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+  }\n+  fast_storefield_helper(field, rax, rdx);\n@@ -3363,1 +3667,4 @@\n-  fast_storefield_helper(field, rax);\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+  }\n+  fast_storefield_helper(field, rax, rdx);\n@@ -3368,1 +3675,1 @@\n-void TemplateTable::fast_storefield_helper(Address field, Register rax) {\n+void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {\n@@ -3372,0 +3679,17 @@\n+  case Bytecodes::_fast_qputfield:\n+    {\n+      Label is_inlined, done;\n+      __ null_check(rax);\n+      __ test_field_is_inlined(flags, rscratch1, is_inlined);\n+      \/\/ field is not inlined\n+      do_oop_store(_masm, field, rax);\n+      __ jmp(done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+      __ load_klass(rdx, rax, rscratch1);\n+      __ data_for_oop(rax, rax, rdx);\n+      __ lea(rcx, field);\n+      __ access_value_copy(IN_HEAP, rax, rcx, rdx);\n+      __ bind(done);\n+    }\n+    break;\n@@ -3373,1 +3697,3 @@\n-    do_oop_store(_masm, field, rax);\n+    {\n+      do_oop_store(_masm, field, rax);\n+    }\n@@ -3443,1 +3769,1 @@\n-  __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,\n+  __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,\n@@ -3450,1 +3776,1 @@\n-  Address field(rax, rbx, Address::times_1);\n+  Address field(rax, rdx, Address::times_1);\n@@ -3454,0 +3780,39 @@\n+  case Bytecodes::_fast_qgetfield:\n+    {\n+      Label is_inlined, nonnull, Done;\n+      __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,\n+                                   in_bytes(ConstantPoolCache::base_offset() +\n+                                            ConstantPoolCacheEntry::flags_offset())));\n+      __ test_field_is_inlined(rscratch1, rscratch2, is_inlined);\n+        \/\/ field is not inlined\n+        __ load_heap_oop(rax, field);\n+        __ testptr(rax, rax);\n+        __ jcc(Assembler::notZero, nonnull);\n+          __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n+                             in_bytes(ConstantPoolCache::base_offset() +\n+                                      ConstantPoolCacheEntry::flags_offset())));\n+          __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n+          __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n+                                       in_bytes(ConstantPoolCache::base_offset() +\n+                                                ConstantPoolCacheEntry::f1_offset())));\n+          __ get_inline_type_field_klass(rcx, rdx, rbx);\n+          __ get_default_value_oop(rbx, rcx, rax);\n+        __ bind(nonnull);\n+        __ verify_oop(rax);\n+        __ jmp(Done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+        __ push(rdx); \/\/ save offset\n+        __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n+                           in_bytes(ConstantPoolCache::base_offset() +\n+                                    ConstantPoolCacheEntry::flags_offset())));\n+        __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n+        __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n+                                     in_bytes(ConstantPoolCache::base_offset() +\n+                                              ConstantPoolCacheEntry::f1_offset())));\n+        __ pop(rbx); \/\/ restore offset\n+        __ read_inlined_field(rcx, rdx, rbx, rax);\n+      __ bind(Done);\n+      __ verify_oop(rax);\n+    }\n+    break;\n@@ -3922,2 +4287,1 @@\n-  Label slow_case_no_pop;\n-  Label initialize_header;\n+  Label is_not_value;\n@@ -3933,1 +4297,1 @@\n-  __ jcc(Assembler::notEqual, slow_case_no_pop);\n+  __ jcc(Assembler::notEqual, slow_case);\n@@ -3937,1 +4301,7 @@\n-  __ push(rcx);  \/\/ save the contexts of klass for initializing the header\n+\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InlineKlassKind);\n+  __ jcc(Assembler::notEqual, is_not_value);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n+\n+  __ bind(is_not_value);\n@@ -3940,1 +4310,0 @@\n-  \/\/ make sure klass is fully initialized\n@@ -3944,14 +4313,2 @@\n-  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n-  __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n-  __ testl(rdx, Klass::_lh_instance_slow_path_bit);\n-  __ jcc(Assembler::notZero, slow_case);\n-\n-  \/\/ Allocate the instance:\n-  \/\/  If TLAB is enabled:\n-  \/\/    Try to allocate in the TLAB.\n-  \/\/    If fails, go to the slow path.\n-  \/\/    Initialize the allocation.\n-  \/\/    Exit.\n-  \/\/\n-  \/\/  Go to slow path.\n+  __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);\n+  __ jmp(done);\n@@ -3959,1 +4316,2 @@\n-  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n+  \/\/ slow case\n+  __ bind(slow_case);\n@@ -3961,7 +4319,2 @@\n-  if (UseTLAB) {\n-    NOT_LP64(__ get_thread(thread);)\n-    __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);\n-    if (ZeroTLAB) {\n-      \/\/ the fields have been already cleared\n-      __ jmp(initialize_header);\n-    }\n+  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n@@ -3969,4 +4322,4 @@\n-    \/\/ The object is initialized before the header.  If the object size is\n-    \/\/ zero, go directly to the header initialization.\n-    __ decrement(rdx, sizeof(oopDesc));\n-    __ jcc(Assembler::zero, initialize_header);\n+  __ get_constant_pool(rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n+   __ verify_oop(rax);\n@@ -3974,4 +4327,3 @@\n-    \/\/ Initialize topmost object field, divide rdx by 8, check if odd and\n-    \/\/ test if zero.\n-    __ xorl(rcx, rcx);    \/\/ use zero reg to clear memory (shorter code)\n-    __ shrl(rdx, LogBytesPerLong); \/\/ divide by 2*oopSize and set carry flag if odd\n+  \/\/ continue\n+  __ bind(done);\n+}\n@@ -3979,10 +4331,2 @@\n-    \/\/ rdx must have been multiple of 8\n-#ifdef ASSERT\n-    \/\/ make sure rdx was multiple of 8\n-    Label L;\n-    \/\/ Ignore partial flag stall after shrl() since it is debug VM\n-    __ jcc(Assembler::carryClear, L);\n-    __ stop(\"object size is not multiple of 2 - adjust this code\");\n-    __ bind(L);\n-    \/\/ rdx must be > 0, no extra check needed here\n-#endif\n+void TemplateTable::aconst_init() {\n+  transition(vtos, atos);\n@@ -3990,8 +4334,3 @@\n-    \/\/ initialize remaining object fields: rdx was a multiple of 8\n-    { Label loop;\n-    __ bind(loop);\n-    __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));\n-    __ decrement(rdx);\n-    __ jcc(Assembler::notZero, loop);\n-    }\n+  Label slow_case;\n+  Label done;\n+  Label is_value;\n@@ -3999,11 +4338,2 @@\n-    \/\/ initialize object header only.\n-    __ bind(initialize_header);\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n-              (intptr_t)markWord::prototype().value()); \/\/ header\n-    __ pop(rcx);   \/\/ get saved klass back in the register.\n-#ifdef _LP64\n-    __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n-    __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n-#endif\n-    Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    __ store_klass(rax, rcx, tmp_store_klass);  \/\/ klass\n+  __ get_unsigned_2_byte_index_at_bcp(rdx, 1);\n+  __ get_cpool_and_tags(rcx, rax);\n@@ -4011,8 +4341,6 @@\n-    {\n-      SkipIfEqual skip_if(_masm, &DTraceAllocProbes, 0);\n-      \/\/ Trigger dtrace event for fastpath\n-      __ push(atos);\n-      __ call_VM_leaf(\n-           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), rax);\n-      __ pop(atos);\n-    }\n+  \/\/ Make sure the class we're about to instantiate has been resolved.\n+  \/\/ This is done before loading InstanceKlass to be consistent with the order\n+  \/\/ how Constant Pool is updated (see ConstantPool::klass_at_put)\n+  const int tags_offset = Array<u1>::base_offset_in_bytes();\n+  __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);\n+  __ jcc(Assembler::notEqual, slow_case);\n@@ -4020,2 +4348,18 @@\n-    __ jmp(done);\n-  }\n+  \/\/ get InstanceKlass\n+  __ load_resolved_klass_at_index(rcx, rcx, rdx);\n+\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InlineKlassKind);\n+  __ jcc(Assembler::equal, is_value);\n+\n+  \/\/ in the future, aconst_init will just return null instead of throwing an exception\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));\n+\n+  __ bind(is_value);\n+\n+  \/\/ make sure klass is fully initialized\n+  __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+  __ jcc(Assembler::notEqual, slow_case);\n+\n+  \/\/ have a resolved InlineKlass in rcx, return the default value oop from it\n+  __ get_default_value_oop(rcx, rdx, rax);\n+  __ jmp(done);\n@@ -4023,4 +4367,1 @@\n-  \/\/ slow case\n-  __ pop(rcx);   \/\/ restore stack pointer to what it was when we came in.\n-  __ bind(slow_case_no_pop);\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n@@ -4031,3 +4372,4 @@\n-  __ get_constant_pool(rarg1);\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n-   __ verify_oop(rax);\n+  __ get_constant_pool(rarg1);\n+\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n+      rarg1, rarg2);\n@@ -4036,1 +4378,1 @@\n-  \/\/ continue\n+  __ verify_oop(rax);\n@@ -4076,4 +4418,5 @@\n-  __ cmpb(Address(rdx, rbx,\n-                  Address::times_1,\n-                  Array<u1>::base_offset_in_bytes()),\n-          JVM_CONSTANT_Class);\n+  __ movzbl(rdx, Address(rdx, rbx,\n+      Address::times_1,\n+      Array<u1>::base_offset_in_bytes()));\n+  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n+  __ cmpl(rdx, JVM_CONSTANT_Class);\n@@ -4118,0 +4461,3 @@\n+  __ jmp(done);\n+\n+  __ bind(is_null);\n@@ -4121,4 +4467,15 @@\n-    __ jmp(done);\n-    __ bind(is_null);\n-  } else {\n-    __ bind(is_null);   \/\/ same as 'done'\n+\n+  if (EnableValhalla) {\n+    \/\/ Get cpool & tags index\n+    __ get_cpool_and_tags(rcx, rdx); \/\/ rcx=cpool, rdx=tags array\n+    __ get_unsigned_2_byte_index_at_bcp(rbx, 1); \/\/ rbx=index\n+    \/\/ See if CP entry is a Q-descriptor\n+    __ movzbl(rcx, Address(rdx, rbx,\n+        Address::times_1,\n+        Array<u1>::base_offset_in_bytes()));\n+    __ andl (rcx, JVM_CONSTANT_QDescBit);\n+    __ cmpl(rcx, JVM_CONSTANT_QDescBit);\n+    __ jcc(Assembler::notEqual, done);\n+    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+  }\n+\n@@ -4140,4 +4497,5 @@\n-  __ cmpb(Address(rdx, rbx,\n-                  Address::times_1,\n-                  Array<u1>::base_offset_in_bytes()),\n-          JVM_CONSTANT_Class);\n+  __ movzbl(rdx, Address(rdx, rbx,\n+        Address::times_1,\n+        Array<u1>::base_offset_in_bytes()));\n+  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n+  __ cmpl(rdx, JVM_CONSTANT_Class);\n@@ -4196,1 +4554,0 @@\n-\n@@ -4258,0 +4615,4 @@\n+  Label is_inline_type;\n+  __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+  __ test_markword_is_inline_type(rbx, is_inline_type);\n+\n@@ -4347,0 +4708,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -4355,0 +4721,11 @@\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  Label has_identity;\n+  __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+  __ andptr(rbx, is_inline_type_mask);\n+  __ cmpl(rbx, is_inline_type_mask);\n+  __ jcc(Assembler::notEqual, has_identity);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n+  __ bind(has_identity);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":516,"deletions":139,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -1762,1 +1762,1 @@\n-  if (!UseFastStosb && UseSSE >= 2 && UseUnalignedLoadStores) {\n+  if (UseSSE >= 2 && UseUnalignedLoadStores) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2792,0 +2792,36 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      C2_MacroAssembler _masm(&cbuf);\n+      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+        uint con = (tf()->range_cc()->cnt() - 1);\n+        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = fast_out(i)->as_Proj();\n+          if (proj->_con == con) {\n+            \/\/ Set IsInit if rax is non-null (a non-null value is returned buffered or scalarized)\n+            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+            __ testq(rax, rax);\n+            __ set_byte_if_not_zero(toReg);\n+            __ movzbl(toReg, toReg);\n+            if (reg->is_stack()) {\n+              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+              __ movq(Address(rsp, st_off), toReg);\n+            }\n+            break;\n+          }\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ rax &= (rax & 1) - 1\n+        __ movptr(rscratch1, rax);\n+        __ andptr(rscratch1, 0x1);\n+        __ subptr(rscratch1, 0x1);\n+        __ andptr(rax, rscratch1);\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -613,4 +613,1 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  int bangsize = C->output()->bang_size_in_bytes();\n-\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != NULL);\n+  __ verified_entry(C);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -485,0 +485,4 @@\n+  if (_entry_point == NULL) {\n+    \/\/ CallLeafNoFPInDirect\n+    return 3; \/\/ callq (register)\n+  }\n@@ -491,0 +495,1 @@\n+\n@@ -899,3 +904,0 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  int bangsize = C->output()->bang_size_in_bytes();\n-\n@@ -917,1 +919,25 @@\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != NULL);\n+  __ verified_entry(C);\n+  __ bind(*_verified_entry);\n+\n+  if (C->stub_function() == NULL) {\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+ #ifdef _LP64\n+    if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n+      \/\/ We put the non-hot code of the nmethod entry barrier out-of-line in a stub.\n+      Label dummy_slow_path;\n+      Label dummy_continuation;\n+      Label* slow_path = &dummy_slow_path;\n+      Label* continuation = &dummy_continuation;\n+      if (!Compile::current()->output()->in_scratch_emit_size()) {\n+        \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n+        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n+        slow_path = &stub->slow_path();\n+        continuation = &stub->continuation();\n+      }\n+      bs->nmethod_entry_barrier(&_masm, slow_path, continuation);\n+    }\n+#else\n+    \/\/ Don't bother with out-of-line nmethod entry barrier stub for x86_32.\n+    bs->nmethod_entry_barrier(&_masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+#endif\n+  }\n@@ -929,6 +955,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -982,23 +1002,3 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  \/\/ Remove word for return adr already pushed\n-  \/\/ and RBP\n-  framesize -= 2*wordSize;\n-\n-  \/\/ Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here\n-\n-  if (framesize) {\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    if (framesize < 0x80) {\n-      emit_opcode(cbuf, 0x83); \/\/ addq rsp, #framesize\n-      emit_rm(cbuf, 0x3, 0x00, RSP_enc);\n-      emit_d8(cbuf, framesize);\n-    } else {\n-      emit_opcode(cbuf, 0x81); \/\/ addq rsp, #framesize\n-      emit_rm(cbuf, 0x3, 0x00, RSP_enc);\n-      emit_d32(cbuf, framesize);\n-    }\n-  }\n-\n-  \/\/ popq rbp\n-  emit_opcode(cbuf, 0x58 | RBP_enc);\n+  \/\/ Subtract two words to account for return address and rbp\n+  int initial_framesize = C->output()->frame_size_in_bytes() - 2*wordSize;\n+  __ remove_frame(initial_framesize, C->needs_stack_repair());\n@@ -1022,6 +1022,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -1660,0 +1654,30 @@\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"MachVEPNode\");\n+}\n+#endif\n+\n+void MachVEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+{\n+  C2_MacroAssembler _masm(&cbuf);\n+  if (!_verified) {\n+    uint insts_size = cbuf.insts_size();\n+    if (UseCompressedClassPointers) {\n+      __ load_klass(rscratch1, j_rarg0, rscratch2);\n+      __ cmpptr(rax, rscratch1);\n+    } else {\n+      __ cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));\n+    }\n+    __ jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+  } else {\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    __ jmp(*_verified_entry);\n+  }\n+}\n+\n@@ -1702,7 +1726,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n-\n@@ -3992,0 +4009,16 @@\n+\/\/ Indirect Narrow Oop Operand\n+operand indCompressedOop(rRegN reg) %{\n+  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(DecodeN reg);\n+\n+  op_cost(10);\n+  format %{\"[R12 + $reg << 3] (compressed oop addressing)\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0xc); \/\/ R12\n+    index($reg);\n+    scale(0x3);\n+    disp(0x0);\n+  %}\n+%}\n+\n@@ -4338,1 +4371,1 @@\n-               indCompressedOopOffset,\n+               indCompressedOop, indCompressedOopOffset,\n@@ -6880,0 +6913,13 @@\n+instruct castN2X(rRegL dst, rRegN src)\n+%{\n+  match(Set dst (CastP2X src));\n+\n+  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movptr($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n@@ -11703,0 +11749,1 @@\n+\n@@ -11705,1 +11752,1 @@\n-instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,\n+instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n@@ -11708,3 +11755,120 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                            Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Small ClearArray AVX512 non-constant length.\n+instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                       Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  ins_cost(125);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11758,2 +11922,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, false, knoreg);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false, $ktmp$$KRegister);\n@@ -11764,3 +11928,2 @@\n-\/\/ Small ClearArray AVX512 non-constant length.\n-instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegI zero,\n-                       Universe dummy, rFlagsReg cr)\n+instruct rep_stos_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                 Universe dummy, rFlagsReg cr)\n@@ -11768,2 +11931,2 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (UseAVX > 2));\n-  match(Set dummy (ClearArray cnt base));\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n@@ -11771,1 +11934,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11819,2 +11982,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, false, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true, $ktmp$$KRegister);\n@@ -11826,1 +11989,1 @@\n-instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,\n+instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n@@ -11829,3 +11992,99 @@\n-  predicate((UseAVX <=2) && ((ClearArrayNode*)n)->is_large());\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                                  Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large ClearArray AVX512.\n+instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                             Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11870,2 +12129,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, true, knoreg);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false, $ktmp$$KRegister);\n@@ -11876,3 +12135,2 @@\n-\/\/ Large ClearArray AVX512.\n-instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegI zero,\n-                             Universe dummy, rFlagsReg cr)\n+instruct rep_stos_large_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                       Universe dummy, rFlagsReg cr)\n@@ -11880,3 +12138,3 @@\n-  predicate((UseAVX > 2) && ((ClearArrayNode*)n)->is_large());\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11921,2 +12179,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, true, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true, $ktmp$$KRegister);\n@@ -11928,1 +12186,1 @@\n-instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rRegI zero, kReg ktmp, Universe dummy, rFlagsReg cr)\n+instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, kReg ktmp, Universe dummy, rFlagsReg cr)\n@@ -11930,3 +12188,3 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() &&\n-              ((UseAVX > 2) && VM_Version::supports_avx512vlbw()));\n-  match(Set dummy (ClearArray cnt base));\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() &&\n+            ((UseAVX > 2) && VM_Version::supports_avx512vlbw()));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n@@ -11934,1 +12192,1 @@\n-  effect(TEMP tmp, TEMP zero, TEMP ktmp, KILL cr);\n+  effect(TEMP tmp, USE_KILL val, TEMP ktmp, KILL cr);\n@@ -11937,1 +12195,1 @@\n-   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n@@ -13740,0 +13998,15 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPInDirect(rRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == NULL);\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf_nofp,runtime indirect \" %}\n+  ins_encode %{\n+     __ call($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -13743,0 +14016,1 @@\n+  predicate(n->as_Call()->entry_point() != NULL);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":355,"deletions":81,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);\n+define_pd_global(bool, InlineTypeReturnedAsFields, false);\n+\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -802,1 +802,1 @@\n-  return  false;\n+  return false;\n@@ -892,1 +892,2 @@\n-      strcmp(_matrule->_opType,\"Halt\"      )==0 )\n+      strcmp(_matrule->_opType,\"Halt\"      )==0 ||\n+      strcmp(_matrule->_opType,\"CallLeafNoFP\")==0)\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+  AD.addInclude(AD._CPP_file, \"gc\/shared\/barrierSetAssembler.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+                 Inline_Entry,\n+                 Verified_Inline_Entry,\n+                 Verified_Inline_Entry_RO,\n@@ -63,0 +66,1 @@\n+  void check(int e) const { assert(0 <= e && e < max_Entries, \"must be\"); }\n@@ -68,0 +72,3 @@\n+    _values[Inline_Entry  ] = 0;\n+    _values[Verified_Inline_Entry] = -1;\n+    _values[Verified_Inline_Entry_RO] = -1;\n@@ -76,2 +83,2 @@\n-  int value(Entries e) { return _values[e]; }\n-  void set_value(Entries e, int val) { _values[e] = val; }\n+  int value(Entries e) const { check(e); return _values[e]; }\n+  void set_value(Entries e, int val) { check(e); _values[e] = val; }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -247,0 +247,77 @@\n+class LoadFlattenedArrayStub: public CodeStub {\n+ private:\n+  LIR_Opr          _array;\n+  LIR_Opr          _index;\n+  LIR_Opr          _result;\n+  LIR_Opr          _scratch_reg;\n+  CodeEmitInfo*    _info;\n+\n+ public:\n+  LoadFlattenedArrayStub(LIR_Opr array, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);\n+  virtual void emit_code(LIR_Assembler* e);\n+  virtual CodeEmitInfo* info() const             { return _info; }\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_slow_case(_info);\n+    visitor->do_input(_array);\n+    visitor->do_input(_index);\n+    visitor->do_output(_result);\n+    if (_scratch_reg != LIR_OprFact::illegalOpr) {\n+      visitor->do_temp(_scratch_reg);\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  virtual void print_name(outputStream* out) const { out->print(\"LoadFlattenedArrayStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+\n+\n+class StoreFlattenedArrayStub: public CodeStub {\n+ private:\n+  LIR_Opr          _array;\n+  LIR_Opr          _index;\n+  LIR_Opr          _value;\n+  LIR_Opr          _scratch_reg;\n+  CodeEmitInfo*    _info;\n+\n+ public:\n+  StoreFlattenedArrayStub(LIR_Opr array, LIR_Opr index, LIR_Opr value, CodeEmitInfo* info);\n+  virtual void emit_code(LIR_Assembler* e);\n+  virtual CodeEmitInfo* info() const             { return _info; }\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_slow_case(_info);\n+    visitor->do_input(_array);\n+    visitor->do_input(_index);\n+    visitor->do_input(_value);\n+    if (_scratch_reg != LIR_OprFact::illegalOpr) {\n+      visitor->do_temp(_scratch_reg);\n+    }\n+  }\n+#ifndef PRODUCT\n+  virtual void print_name(outputStream* out) const { out->print(\"StoreFlattenedArrayStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+\n+class SubstitutabilityCheckStub: public CodeStub {\n+ private:\n+  LIR_Opr          _left;\n+  LIR_Opr          _right;\n+  LIR_Opr          _scratch_reg;\n+  CodeEmitInfo*    _info;\n+ public:\n+  SubstitutabilityCheckStub(LIR_Opr left, LIR_Opr right, CodeEmitInfo* info);\n+  virtual void emit_code(LIR_Assembler* e);\n+  virtual CodeEmitInfo* info() const             { return _info; }\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_slow_case(_info);\n+    visitor->do_input(_left);\n+    visitor->do_input(_right);\n+    if (_scratch_reg != LIR_OprFact::illegalOpr) {\n+      visitor->do_temp(_scratch_reg);\n+    }\n+  }\n+#ifndef PRODUCT\n+  virtual void print_name(outputStream* out) const { out->print(\"SubstitutabilityCheckStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+\n@@ -299,1 +376,1 @@\n-\n+  bool           _is_null_free;\n@@ -301,1 +378,1 @@\n-  NewObjectArrayStub(LIR_Opr klass_reg, LIR_Opr length, LIR_Opr result, CodeEmitInfo* info);\n+  NewObjectArrayStub(LIR_Opr klass_reg, LIR_Opr length, LIR_Opr result, CodeEmitInfo* info, bool is_null_free);\n@@ -336,0 +413,2 @@\n+  CodeStub* _throw_imse_stub;\n+  LIR_Opr _scratch_reg;\n@@ -338,1 +417,1 @@\n-  MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info);\n+  MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info, CodeStub* throw_imse_stub = NULL, LIR_Opr scratch_reg = LIR_OprFact::illegalOpr);\n@@ -345,0 +424,3 @@\n+    if (_scratch_reg != LIR_OprFact::illegalOpr) {\n+      visitor->do_temp(_scratch_reg);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":85,"deletions":3,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -581,0 +581,1 @@\n+, _compiled_entry_signature(method->get_Method())\n@@ -598,0 +599,4 @@\n+  {\n+    ResetNoHandleMark rnhm; \/\/ Huh? Required when doing class lookup of the Q-types\n+    _compiled_entry_signature.compute_calling_conventions(false);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -95,0 +96,1 @@\n+  CompiledEntrySignature _compiled_entry_signature;\n@@ -265,0 +267,4 @@\n+  bool profile_array_accesses() {\n+    return env()->comp_level() == CompLevel_full_profile &&\n+      C1UpdateMethodData;\n+  }\n@@ -293,0 +299,7 @@\n+\n+  const CompiledEntrySignature* compiled_entry_signature() const {\n+    return &_compiled_entry_signature;\n+  }\n+  bool needs_stack_repair() const {\n+    return compiled_entry_signature()->c1_needs_stack_repair();\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  bool finalize_frame(int nof_slots);\n+  bool finalize_frame(int nof_slots, bool needs_stack_repair);\n@@ -215,0 +215,3 @@\n+  Address address_for_orig_pc_addr() const {\n+    return make_new_address(sp_offset_for_monitor_base(_num_monitors));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -727,0 +729,11 @@\n+  \/\/ Record this newly allocated object\n+  void new_instance(NewInlineTypeInstance* object) {\n+    int index = _newobjects.length();\n+    _newobjects.append(object);\n+    if (_fields.at_grow(index, NULL) == NULL) {\n+      _fields.at_put(index, new FieldBuffer());\n+    } else {\n+      _fields.at(index)->kill();\n+    }\n+  }\n+\n@@ -1026,0 +1039,7 @@\n+  if (x->as_NewInlineTypeInstance() != NULL && x->as_NewInlineTypeInstance()->in_larval_state()) {\n+    if (x->as_NewInlineTypeInstance()->on_stack_count() == 1) {\n+      x->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+    } else {\n+      x->as_NewInlineTypeInstance()->increment_on_stack_count();\n+    }\n+  }\n@@ -1032,0 +1052,3 @@\n+  if (x->as_NewInlineTypeInstance() != NULL) {\n+    x->as_NewInlineTypeInstance()->set_local_index(index);\n+  }\n@@ -1060,0 +1083,3 @@\n+  if (x->as_NewInlineTypeInstance() != NULL) {\n+    x->as_NewInlineTypeInstance()->set_local_index(index);\n+  }\n@@ -1065,1 +1091,9 @@\n-  ValueStack* state_before = copy_state_indexed_access();\n+  ValueStack* state_before = NULL;\n+  int array_idx = state()->stack_size() - 2;\n+  if (type == T_OBJECT && state()->stack_at(array_idx)->maybe_flattened_array()) {\n+    \/\/ Save the entire state and re-execute on deopt when accessing flattened arrays\n+    state_before = copy_state_before();\n+    state_before->set_should_reexecute(true);\n+  } else {\n+    state_before = copy_state_indexed_access();\n+  }\n@@ -1077,1 +1111,61 @@\n-  push(as_ValueType(type), append(new LoadIndexed(array, index, length, type, state_before)));\n+\n+  bool need_membar = false;\n+  LoadIndexed* load_indexed = NULL;\n+  Instruction* result = NULL;\n+  if (array->is_loaded_flattened_array()) {\n+    ciType* array_type = array->declared_type();\n+    ciInlineKlass* elem_klass = array_type->as_flat_array_klass()->element_klass()->as_inline_klass();\n+\n+    bool can_delay_access = false;\n+    ciBytecodeStream s(method());\n+    s.force_bci(bci());\n+    s.next();\n+    if (s.cur_bc() == Bytecodes::_getfield) {\n+      bool will_link;\n+      ciField* next_field = s.get_field(will_link);\n+      bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                 !next_field->will_link(method(), Bytecodes::_getfield) ||\n+                                 PatchALot;\n+      can_delay_access = C1UseDelayedFlattenedFieldReads && !next_needs_patching;\n+    }\n+    if (can_delay_access) {\n+      \/\/ potentially optimizable array access, storing information for delayed decision\n+      LoadIndexed* li = new LoadIndexed(array, index, length, type, state_before);\n+      DelayedLoadIndexed* dli = new DelayedLoadIndexed(li, state_before);\n+      li->set_delayed(dli);\n+      set_pending_load_indexed(dli);\n+      return; \/\/ Nothing else to do for now\n+    } else {\n+      if (elem_klass->is_empty()) {\n+        \/\/ No need to create a new instance, the default instance will be used instead\n+        load_indexed = new LoadIndexed(array, index, length, type, state_before);\n+        apush(append(load_indexed));\n+      } else {\n+        NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before);\n+        _memory->new_instance(new_instance);\n+        apush(append_split(new_instance));\n+        load_indexed = new LoadIndexed(array, index, length, type, state_before);\n+        load_indexed->set_vt(new_instance);\n+        \/\/ The LoadIndexed node will initialise this instance by copying from\n+        \/\/ the flattened field.  Ensure these stores are visible before any\n+        \/\/ subsequent store that publishes this reference.\n+        need_membar = true;\n+      }\n+    }\n+  } else {\n+    load_indexed = new LoadIndexed(array, index, length, type, state_before);\n+    if (profile_array_accesses() && is_reference_type(type)) {\n+      compilation()->set_would_profile(true);\n+      load_indexed->set_should_profile(true);\n+      load_indexed->set_profiled_method(method());\n+      load_indexed->set_profiled_bci(bci());\n+    }\n+  }\n+  result = append(load_indexed);\n+  if (need_membar) {\n+    append(new MemBar(lir_membar_storestore));\n+  }\n+  assert(!load_indexed->should_profile() || load_indexed == result, \"should not be optimized out\");\n+  if (!array->is_loaded_flattened_array()) {\n+    push(as_ValueType(type), result);\n+  }\n@@ -1083,1 +1177,9 @@\n-  ValueStack* state_before = copy_state_indexed_access();\n+  ValueStack* state_before = NULL;\n+  int array_idx = state()->stack_size() - 3;\n+  if (type == T_OBJECT && state()->stack_at(array_idx)->maybe_flattened_array()) {\n+    \/\/ Save the entire state and re-execute on deopt when accessing flattened arrays\n+    state_before = copy_state_before();\n+    state_before->set_should_reexecute(true);\n+  } else {\n+    state_before = copy_state_indexed_access();\n+  }\n@@ -1108,5 +1210,2 @@\n-  StoreIndexed* result = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);\n-  append(result);\n-  _memory->store_value(value);\n-  if (type == T_OBJECT && is_profiling()) {\n-    \/\/ Note that we'd collect profile data in this method if we wanted it.\n+  StoreIndexed* store_indexed = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);\n+  if (profile_array_accesses() && is_reference_type(type) && !array->is_loaded_flattened_array()) {\n@@ -1115,6 +1214,3 @@\n-\n-    if (profile_checkcasts()) {\n-      result->set_profiled_method(method());\n-      result->set_profiled_bci(bci());\n-      result->set_should_profile(true);\n-    }\n+    store_indexed->set_should_profile(true);\n+    store_indexed->set_profiled_method(method());\n+    store_indexed->set_profiled_bci(bci());\n@@ -1122,0 +1218,3 @@\n+  Instruction* result = append(store_indexed);\n+  assert(!store_indexed->should_profile() || store_indexed == result, \"should not be optimized out\");\n+  _memory->store_value(value);\n@@ -1124,1 +1223,0 @@\n-\n@@ -1128,1 +1226,2 @@\n-      { state()->raw_pop();\n+      { Value w = state()->raw_pop();\n+        update_larva_stack_count(w);\n@@ -1132,2 +1231,4 @@\n-      { state()->raw_pop();\n-        state()->raw_pop();\n+      { Value w1 = state()->raw_pop();\n+        Value w2 = state()->raw_pop();\n+        update_larva_stack_count(w1);\n+        update_larva_stack_count(w2);\n@@ -1138,0 +1239,1 @@\n+        update_larval_state(w);\n@@ -1145,0 +1247,1 @@\n+        update_larval_state(w1);\n@@ -1154,0 +1257,11 @@\n+        \/\/ special handling for the dup_x2\/pop sequence (see JDK-8251046)\n+        if (w1 != NULL && w1->as_NewInlineTypeInstance() != NULL) {\n+          ciBytecodeStream s(method());\n+          s.force_bci(bci());\n+          s.next();\n+          if (s.cur_bc() != Bytecodes::_pop) {\n+            w1->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+          }  else {\n+            w1->as_NewInlineTypeInstance()->increment_on_stack_count();\n+           }\n+        }\n@@ -1163,0 +1277,2 @@\n+        update_larval_state(w1);\n+        update_larval_state(w2);\n@@ -1173,0 +1289,2 @@\n+        update_larval_state(w1);\n+        update_larval_state(w2);\n@@ -1185,0 +1303,2 @@\n+        update_larval_state(w1);\n+        update_larval_state(w2);\n@@ -1312,0 +1432,27 @@\n+\n+  bool subst_check = false;\n+  if (EnableValhalla && (stream()->cur_bc() == Bytecodes::_if_acmpeq || stream()->cur_bc() == Bytecodes::_if_acmpne)) {\n+    ValueType* left_vt = x->type();\n+    ValueType* right_vt = y->type();\n+    if (left_vt->is_object()) {\n+      assert(right_vt->is_object(), \"must be\");\n+      ciKlass* left_klass = x->as_loaded_klass_or_null();\n+      ciKlass* right_klass = y->as_loaded_klass_or_null();\n+\n+      if (left_klass == NULL || right_klass == NULL) {\n+        \/\/ The klass is still unloaded, or came from a Phi node. Go slow case;\n+        subst_check = true;\n+      } else if (left_klass->can_be_inline_klass() || right_klass->can_be_inline_klass()) {\n+        \/\/ Either operand may be a value object, but we're not sure. Go slow case;\n+        subst_check = true;\n+      } else {\n+        \/\/ No need to do substitutability check\n+      }\n+    }\n+  }\n+  if ((stream()->cur_bc() == Bytecodes::_if_acmpeq || stream()->cur_bc() == Bytecodes::_if_acmpne) &&\n+      is_profiling() && profile_branches()) {\n+    compilation()->set_would_profile(true);\n+    append(new ProfileACmpTypes(method(), bci(), x, y));\n+  }\n+\n@@ -1314,1 +1461,1 @@\n-  Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()->is_optimistic()) ? state_before : NULL, is_bb));\n+  Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()->is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));\n@@ -1565,1 +1712,1 @@\n-  if (method()->name() == ciSymbols::object_initializer_name() &&\n+  if ((method()->is_object_constructor() || method()->is_static_init_factory()) &&\n@@ -1716,0 +1863,13 @@\n+void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before, ciField* enclosing_field) {\n+  for (int i = 0; i < vk->nof_nonstatic_fields(); i++) {\n+    ciField* inner_field = vk->nonstatic_field_at(i);\n+    assert(!inner_field->is_flattened(), \"the iteration over nested fields is handled by the loop itself\");\n+    int off = inner_field->offset() - vk->first_field_offset();\n+    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n+    Value replacement = append(load);\n+    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n+    store->set_enclosing_field(enclosing_field);\n+    append(store);\n+  }\n+}\n+\n@@ -1722,0 +1882,1 @@\n+\n@@ -1725,1 +1886,1 @@\n-                              PatchALot;\n+                              (!field->is_flattened() && PatchALot);\n@@ -1744,1 +1905,1 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield)) {\n+  if (field->is_final() && code == Bytecodes::_putfield) {\n@@ -1755,1 +1916,1 @@\n-  const int offset = !needs_patching ? field->offset() : -1;\n+  int offset = !needs_patching ? field->offset() : -1;\n@@ -1765,0 +1926,4 @@\n+      } else if (field->is_null_free() && field->type()->as_instance_klass()->is_initialized() &&\n+                 field->type()->as_inline_klass()->is_empty()) {\n+        \/\/ Loading from a field of an empty inline type. Just return the default instance.\n+        constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1772,2 +1937,3 @@\n-        push(type, append(new LoadField(append(obj), offset, field, true,\n-                                        state_before, needs_patching)));\n+        LoadField* load_field = new LoadField(append(obj), offset, field, true,\n+                                        state_before, needs_patching);\n+        push(type, append(load_field));\n@@ -1782,1 +1948,1 @@\n-      if (field->type()->basic_type() == T_BOOLEAN) {\n+      if (field_type == T_BOOLEAN) {\n@@ -1786,0 +1952,4 @@\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n+        \/\/ Storing to a field of an empty inline type. Ignore.\n+        break;\n+      }\n@@ -1792,14 +1962,31 @@\n-      obj = apop();\n-      ObjectType* obj_type = obj->type()->as_ObjectType();\n-      if (field->is_constant() && obj_type->is_constant() && !PatchALot) {\n-        ciObject* const_oop = obj_type->constant_value();\n-        if (!const_oop->is_null_object() && const_oop->is_loaded()) {\n-          ciConstant field_value = field->constant_value_of(const_oop);\n-          if (field_value.is_valid()) {\n-            constant = make_constant(field_value, field);\n-            \/\/ For CallSite objects add a dependency for invalidation of the optimization.\n-            if (field->is_call_site_target()) {\n-              ciCallSite* call_site = const_oop->as_call_site();\n-              if (!call_site->is_fully_initialized_constant_call_site()) {\n-                ciMethodHandle* target = field_value.as_object()->as_method_handle();\n-                dependency_recorder()->assert_call_site_target_value(call_site, target);\n+      if (state_before == NULL && field->is_flattened()) {\n+        \/\/ Save the entire state and re-execute on deopt when accessing flattened fields\n+        assert(Interpreter::bytecode_should_reexecute(code), \"should reexecute\");\n+        state_before = copy_state_before();\n+      }\n+      if (!has_pending_field_access() && !has_pending_load_indexed()) {\n+        obj = apop();\n+        ObjectType* obj_type = obj->type()->as_ObjectType();\n+        if (field->is_null_free() && field->type()->as_instance_klass()->is_initialized()\n+            && field->type()->as_inline_klass()->is_empty()) {\n+          \/\/ Loading from a field of an empty inline type. Just return the default instance.\n+          null_check(obj);\n+          constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+        } else if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {\n+          ciObject* const_oop = obj_type->constant_value();\n+          if (!const_oop->is_null_object() && const_oop->is_loaded()) {\n+            ciConstant field_value = field->constant_value_of(const_oop);\n+            if (field_value.is_valid()) {\n+              if (field->is_null_free() && field_value.is_null_or_zero()) {\n+                \/\/ Non-flattened inline type field. Replace null by the default value.\n+                constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+              } else {\n+                constant = make_constant(field_value, field);\n+              }\n+              \/\/ For CallSite objects add a dependency for invalidation of the optimization.\n+              if (field->is_call_site_target()) {\n+                ciCallSite* call_site = const_oop->as_call_site();\n+                if (!call_site->is_fully_initialized_constant_call_site()) {\n+                  ciMethodHandle* target = field_value.as_object()->as_method_handle();\n+                  dependency_recorder()->assert_call_site_target_value(call_site, target);\n+                }\n@@ -1817,19 +2004,15 @@\n-        LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);\n-        Value replacement = !needs_patching ? _memory->load(load) : load;\n-        if (replacement != load) {\n-          assert(replacement->is_linked() || !replacement->can_be_linked(), \"should already by linked\");\n-          \/\/ Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing\n-          \/\/ conversion. Emit an explicit conversion here to get the correct field value after the write.\n-          BasicType bt = field->type()->basic_type();\n-          switch (bt) {\n-          case T_BOOLEAN:\n-          case T_BYTE:\n-            replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));\n-            break;\n-          case T_CHAR:\n-            replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));\n-            break;\n-          case T_SHORT:\n-            replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));\n-            break;\n-          default:\n+        if (!field->is_flattened()) {\n+          if (has_pending_field_access()) {\n+            assert(!needs_patching, \"Can't patch delayed field access\");\n+            obj = pending_field_access()->obj();\n+            offset += pending_field_access()->offset() - field->holder()->as_inline_klass()->first_field_offset();\n+            field = pending_field_access()->holder()->get_field_by_offset(offset, false);\n+            assert(field != NULL, \"field not found\");\n+            set_pending_field_access(NULL);\n+          } else if (has_pending_load_indexed()) {\n+            assert(!needs_patching, \"Can't patch delayed field access\");\n+            pending_load_indexed()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+            LoadIndexed* li = pending_load_indexed()->load_instr();\n+            li->set_type(type);\n+            push(type, append(li));\n+            set_pending_load_indexed(NULL);\n@@ -1838,1 +2021,24 @@\n-          push(type, replacement);\n+          LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);\n+          Value replacement = !needs_patching ? _memory->load(load) : load;\n+          if (replacement != load) {\n+            assert(replacement->is_linked() || !replacement->can_be_linked(), \"should already by linked\");\n+            \/\/ Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing\n+            \/\/ conversion. Emit an explicit conversion here to get the correct field value after the write.\n+            switch (field_type) {\n+            case T_BOOLEAN:\n+            case T_BYTE:\n+              replacement = append(new Convert(Bytecodes::_i2b, replacement, type));\n+              break;\n+            case T_CHAR:\n+              replacement = append(new Convert(Bytecodes::_i2c, replacement, type));\n+              break;\n+            case T_SHORT:\n+              replacement = append(new Convert(Bytecodes::_i2s, replacement, type));\n+              break;\n+            default:\n+              break;\n+            }\n+            push(type, replacement);\n+          } else {\n+            push(type, append(load));\n+          }\n@@ -1840,1 +2046,66 @@\n-          push(type, append(load));\n+          \/\/ Look at the next bytecode to check if we can delay the field access\n+          bool can_delay_access = false;\n+          ciBytecodeStream s(method());\n+          s.force_bci(bci());\n+          s.next();\n+          if (s.cur_bc() == Bytecodes::_getfield && !needs_patching) {\n+            ciField* next_field = s.get_field(will_link);\n+            bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                       !next_field->will_link(method(), Bytecodes::_getfield) ||\n+                                       PatchALot;\n+            can_delay_access = C1UseDelayedFlattenedFieldReads && !next_needs_patching;\n+          }\n+          if (can_delay_access) {\n+            if (has_pending_load_indexed()) {\n+              pending_load_indexed()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+            } else if (has_pending_field_access()) {\n+              pending_field_access()->inc_offset(offset - field->holder()->as_inline_klass()->first_field_offset());\n+            } else {\n+              null_check(obj);\n+              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field->holder(), field->offset());\n+              set_pending_field_access(dfa);\n+            }\n+          } else {\n+            ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+            scope()->set_wrote_final();\n+            scope()->set_wrote_fields();\n+            bool need_membar = false;\n+            if (inline_klass->is_initialized() && inline_klass->is_empty()) {\n+              apush(append(new Constant(new InstanceConstant(inline_klass->default_instance()))));\n+              if (has_pending_field_access()) {\n+                set_pending_field_access(NULL);\n+              } else if (has_pending_load_indexed()) {\n+                set_pending_load_indexed(NULL);\n+              }\n+            } else if (has_pending_load_indexed()) {\n+              assert(!needs_patching, \"Can't patch delayed field access\");\n+              pending_load_indexed()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+              NewInlineTypeInstance* vt = new NewInlineTypeInstance(inline_klass, pending_load_indexed()->state_before());\n+              _memory->new_instance(vt);\n+              pending_load_indexed()->load_instr()->set_vt(vt);\n+              apush(append_split(vt));\n+              append(pending_load_indexed()->load_instr());\n+              set_pending_load_indexed(NULL);\n+              need_membar = true;\n+            } else {\n+              NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before);\n+              _memory->new_instance(new_instance);\n+              apush(append_split(new_instance));\n+              assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+              if (has_pending_field_access()) {\n+                copy_inline_content(inline_klass, pending_field_access()->obj(),\n+                                    pending_field_access()->offset() + field->offset() - field->holder()->as_inline_klass()->first_field_offset(),\n+                                    new_instance, inline_klass->first_field_offset(), state_before);\n+                set_pending_field_access(NULL);\n+              } else {\n+                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(), state_before);\n+              }\n+              need_membar = true;\n+            }\n+            if (need_membar) {\n+              \/\/ If we allocated a new instance ensure the stores to copy the\n+              \/\/ field contents are visible before any subsequent store that\n+              \/\/ publishes this reference.\n+              append(new MemBar(lir_membar_storestore));\n+            }\n+          }\n@@ -1851,1 +2122,1 @@\n-      if (field->type()->basic_type() == T_BOOLEAN) {\n+      if (field_type == T_BOOLEAN) {\n@@ -1855,4 +2126,13 @@\n-      StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);\n-      if (!needs_patching) store = _memory->store(store);\n-      if (store != NULL) {\n-        append(store);\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n+        \/\/ Storing to a field of an empty inline type. Ignore.\n+        null_check(obj);\n+      } else if (!field->is_flattened()) {\n+        StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);\n+        if (!needs_patching) store = _memory->store(store);\n+        if (store != NULL) {\n+          append(store);\n+        }\n+      } else {\n+        assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+        ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, offset, state_before, field);\n@@ -1868,0 +2148,74 @@\n+\/\/ Baseline version of withfield, allocate every time\n+void GraphBuilder::withfield(int field_index) {\n+  \/\/ Save the entire state and re-execute on deopt\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_should_reexecute(true);\n+\n+  bool will_link;\n+  ciField* field_modify = stream()->get_field(will_link);\n+  ciInstanceKlass* holder = field_modify->holder();\n+  BasicType field_type = field_modify->type()->basic_type();\n+  ValueType* type = as_ValueType(field_type);\n+  Value val = pop(type);\n+  Value obj = apop();\n+  null_check(obj);\n+\n+  if (!holder->is_loaded() || !holder->is_inlinetype() || !will_link) {\n+    apush(append_split(new Deoptimize(holder, state_before)));\n+    return;\n+  }\n+\n+  \/\/ call will_link again to determine if the field is valid.\n+  const bool needs_patching = !field_modify->will_link(method(), Bytecodes::_withfield) ||\n+                              (!field_modify->is_flattened() && PatchALot);\n+  const int offset_modify = !needs_patching ? field_modify->offset() : -1;\n+\n+  scope()->set_wrote_final();\n+  scope()->set_wrote_fields();\n+\n+  NewInlineTypeInstance* new_instance;\n+  if (obj->as_NewInlineTypeInstance() != NULL && obj->as_NewInlineTypeInstance()->in_larval_state()) {\n+    new_instance = obj->as_NewInlineTypeInstance();\n+    apush(append_split(new_instance));\n+  } else {\n+    new_instance = new NewInlineTypeInstance(holder->as_inline_klass(), state_before);\n+    _memory->new_instance(new_instance);\n+    apush(append_split(new_instance));\n+\n+    \/\/ Initialize fields which are not modified\n+    for (int i = 0; i < holder->nof_nonstatic_fields(); i++) {\n+      ciField* field = holder->nonstatic_field_at(i);\n+      int offset = field->offset();\n+      \/\/ Don't use offset_modify here, it might be set to -1 if needs_patching\n+      if (offset != field_modify->offset()) {\n+        if (field->is_flattened()) {\n+          ciInlineKlass* vk = field->type()->as_inline_klass();\n+          if (!vk->is_empty()) {\n+            copy_inline_content(vk, obj, offset, new_instance, vk->first_field_offset(), state_before, field);\n+          }\n+        } else {\n+          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n+          Value replacement = append(load);\n+          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n+          append(store);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Field to modify\n+  if (field_type == T_BOOLEAN) {\n+    Value mask = append(new Constant(new IntConstant(1)));\n+    val = append(new LogicOp(Bytecodes::_iand, val, mask));\n+  }\n+  if (field_modify->is_flattened()) {\n+    assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+    ciInlineKlass* vk = field_modify->type()->as_inline_klass();\n+    if (!vk->is_empty()) {\n+      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, offset_modify, state_before, field_modify);\n+    }\n+  } else {\n+    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n+    append(store);\n+  }\n+}\n@@ -1985,1 +2339,1 @@\n-    } else if (bc_raw == Bytecodes::_invokespecial && !target->is_object_initializer() && calling_klass->is_interface()) {\n+    } else if (bc_raw == Bytecodes::_invokespecial && !target->is_object_constructor() && calling_klass->is_interface()) {\n@@ -2220,1 +2574,2 @@\n-  Invoke* result = new Invoke(code, result_type, recv, args, target, state_before);\n+  Invoke* result = new Invoke(code, result_type, recv, args, target, state_before,\n+                              declared_signature->returns_null_free_inline_type());\n@@ -2243,0 +2598,11 @@\n+void GraphBuilder::default_value(int klass_index) {\n+  bool will_link;\n+  ciKlass* klass = stream()->get_klass(will_link);\n+  if (!stream()->is_unresolved_klass() && klass->is_inlinetype() &&\n+      klass->as_inline_klass()->is_initialized()) {\n+    ciInlineKlass* vk = klass->as_inline_klass();\n+    apush(append(new Constant(new InstanceConstant(vk->default_instance()))));\n+  } else {\n+    apush(append_split(new Deoptimize(klass, copy_state_before())));\n+  }\n+}\n@@ -2253,0 +2619,1 @@\n+  bool null_free = stream()->has_Q_signature();\n@@ -2254,1 +2621,1 @@\n-  NewArray* n = new NewObjectArray(klass, ipop(), state_before);\n+  NewArray* n = new NewObjectArray(klass, ipop(), state_before, null_free);\n@@ -2279,0 +2646,1 @@\n+  bool null_free = stream()->has_Q_signature();\n@@ -2280,1 +2648,1 @@\n-  CheckCast* c = new CheckCast(klass, apop(), state_before);\n+  CheckCast* c = new CheckCast(klass, apop(), state_before, null_free);\n@@ -2319,0 +2687,19 @@\n+  bool maybe_inlinetype = false;\n+  if (bci == InvocationEntryBci) {\n+    \/\/ Called by GraphBuilder::inline_sync_entry.\n+#ifdef ASSERT\n+    ciType* obj_type = x->declared_type();\n+    assert(obj_type == NULL || !obj_type->is_inlinetype(), \"inline types cannot have synchronized methods\");\n+#endif\n+  } else {\n+    \/\/ We are compiling a monitorenter bytecode\n+    if (EnableValhalla) {\n+      ciType* obj_type = x->declared_type();\n+      if (obj_type == NULL || obj_type->as_klass()->can_be_inline_klass()) {\n+        \/\/ If we're (possibly) locking on an inline type, check for markWord::always_locked_pattern\n+        \/\/ and throw IMSE. (obj_type is null for Phi nodes, so let's just be conservative).\n+        maybe_inlinetype = true;\n+      }\n+    }\n+  }\n+\n@@ -2322,1 +2709,1 @@\n-  append_with_bci(new MonitorEnter(x, state()->lock(x), state_before), bci);\n+  append_with_bci(new MonitorEnter(x, state()->lock(x), state_before, maybe_inlinetype), bci);\n@@ -2458,1 +2845,1 @@\n-  if (value->as_NewArray() != NULL || value->as_NewInstance() != NULL) {\n+  if (value->as_NewArray() != NULL || value->as_NewInstance() != NULL || value->as_NewInlineTypeInstance() != NULL) {\n@@ -2471,0 +2858,1 @@\n+    if (value->is_null_free()) return;\n@@ -2496,1 +2884,3 @@\n-    assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data->stream()->cur_bci(), \"invalid bci\");\n+    assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data->stream()->cur_bci()\n+           || has_pending_field_access() || has_pending_load_indexed(), \"invalid bci\");\n+\n@@ -2984,0 +3374,2 @@\n+      case Bytecodes::_aconst_init   : default_value(s.get_index_u2()); break;\n+      case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;\n@@ -3272,1 +3664,2 @@\n-    state->store_local(idx, new Local(method()->holder(), objectType, idx, true));\n+    state->store_local(idx, new Local(method()->holder(), objectType, idx,\n+             \/*receiver*\/ true, \/*null_free*\/ method()->holder()->is_flat_array_klass()));\n@@ -3284,1 +3677,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false));\n+    state->store_local(idx, new Local(type, vt, idx, false, sig->is_null_free_at(i)));\n@@ -3304,0 +3697,2 @@\n+  , _pending_field_access(NULL)\n+  , _pending_load_indexed(NULL)\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":470,"deletions":75,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -38,0 +38,15 @@\n+class DelayedFieldAccess : public CompilationResourceObj {\n+private:\n+  Value            _obj;\n+  ciInstanceKlass* _holder;\n+  int              _offset;\n+public:\n+  DelayedFieldAccess(Value obj, ciInstanceKlass* holder, int offset)\n+  : _obj(obj), _holder(holder) , _offset(offset) { }\n+\n+  Value obj() const               { return _obj; }\n+  ciInstanceKlass* holder() const { return _holder; }\n+  int offset() const              { return _offset; }\n+  void inc_offset(int offset)     { _offset += offset; }\n+};\n+\n@@ -195,0 +210,4 @@\n+  \/\/ support for optimization of accesses to flattened fields and arrays\n+  DelayedFieldAccess* _pending_field_access;\n+  DelayedLoadIndexed* _pending_load_indexed;\n+\n@@ -212,0 +231,6 @@\n+  bool              has_pending_field_access()   { return _pending_field_access != NULL; }\n+  DelayedFieldAccess* pending_field_access()     { return _pending_field_access; }\n+  void              set_pending_field_access(DelayedFieldAccess* delayed) { _pending_field_access = delayed; }\n+  bool              has_pending_load_indexed()   { return _pending_load_indexed != NULL; }\n+  DelayedLoadIndexed* pending_load_indexed()     { return _pending_load_indexed; }\n+  void              set_pending_load_indexed(DelayedLoadIndexed* delayed) { _pending_load_indexed = delayed; }\n@@ -271,0 +296,5 @@\n+  \/\/ inline types\n+  void default_value(int klass_index);\n+  void withfield(int field_index);\n+  void copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before, ciField* encloding_field = NULL);\n+\n@@ -364,0 +394,13 @@\n+  \/\/ Inline type support\n+  void update_larval_state(Value v) {\n+    if (v != NULL && v->as_NewInlineTypeInstance() != NULL) {\n+      v->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+    }\n+  }\n+  void update_larva_stack_count(Value v) {\n+    if (v != NULL && v->as_NewInlineTypeInstance() != NULL &&\n+        v->as_NewInlineTypeInstance()->in_larval_state()) {\n+      v->as_NewInlineTypeInstance()->decrement_on_stack_count();\n+    }\n+  }\n+\n@@ -398,0 +441,1 @@\n+  bool profile_array_accesses(){ return _compilation->profile_array_accesses();}\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -174,0 +174,3 @@\n+  if (_should_reexecute) {\n+    return true;\n+  }\n@@ -183,1 +186,0 @@\n-\n@@ -217,1 +219,1 @@\n-void CodeEmitInfo::record_debug_info(DebugInformationRecorder* recorder, int pc_offset) {\n+void CodeEmitInfo::record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool maybe_return_as_fields) {\n@@ -221,1 +223,1 @@\n-  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, _is_method_handle_invoke);\n+  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, _is_method_handle_invoke, maybe_return_as_fields);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+  bool                          _should_reexecute;\n@@ -216,1 +217,2 @@\n-                   IRScopeDebugInfo*             caller):\n+                   IRScopeDebugInfo*             caller,\n+                   bool                          should_reexecute):\n@@ -222,1 +224,2 @@\n-    , _caller(caller) {}\n+    , _caller(caller)\n+    , _should_reexecute(should_reexecute) {}\n@@ -235,1 +238,1 @@\n-  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool is_method_handle_invoke = false) {\n+  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool is_method_handle_invoke = false, bool maybe_return_as_fields = false) {\n@@ -244,1 +247,6 @@\n-    bool return_oop = false; \/\/ This flag will be ignored since it used only for C2 with escape analysis.\n+    bool return_oop = false;\n+    bool return_scalarized = false;\n+    if (maybe_return_as_fields) {\n+      return_oop = true;\n+      return_scalarized = true;\n+    }\n@@ -249,1 +257,1 @@\n-                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop,\n+                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop, return_scalarized,\n@@ -287,1 +295,1 @@\n-  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset);\n+  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool maybe_return_as_fields = false);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -109,1 +111,1 @@\n-  ciType* t =  declared_type();\n+  ciType* t = declared_type();\n@@ -116,0 +118,60 @@\n+ciKlass* Instruction::as_loaded_klass_or_null() const {\n+  ciType* type = declared_type();\n+  if (type != NULL && type->is_klass()) {\n+    ciKlass* klass = type->as_klass();\n+    if (klass->is_loaded()) {\n+      return klass;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+bool Instruction::is_loaded_flattened_array() const {\n+  if (UseFlatArray) {\n+    ciType* type = declared_type();\n+    return type != NULL && type->is_flat_array_klass();\n+  }\n+  return false;\n+}\n+\n+bool Instruction::maybe_flattened_array() {\n+  if (UseFlatArray) {\n+    ciType* type = declared_type();\n+    if (type != NULL) {\n+      if (type->is_obj_array_klass() && !type->as_obj_array_klass()->is_elem_null_free()) {\n+        \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n+        ciKlass* element_klass = type->as_obj_array_klass()->element_klass();\n+        if (element_klass->can_be_inline_klass() && (!element_klass->is_inlinetype() || element_klass->as_inline_klass()->flatten_array())) {\n+          return true;\n+        }\n+      } else if (type->is_flat_array_klass()) {\n+        return true;\n+      } else if (type->is_klass() && type->as_klass()->is_java_lang_Object()) {\n+        \/\/ This can happen as a parameter to System.arraycopy()\n+        return true;\n+      }\n+    } else {\n+      \/\/ Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a\n+      \/\/ flattened array, so we should do a runtime check.\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Instruction::maybe_null_free_array() {\n+  ciType* type = declared_type();\n+  if (type != NULL) {\n+    if (type->is_obj_array_klass()) {\n+      \/\/ Due to array covariance, the runtime type might be a null-free array.\n+      if (type->as_obj_array_klass()->can_be_inline_array_klass()) {\n+        return true;\n+      }\n+    }\n+  } else {\n+    \/\/ Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a\n+    \/\/ null-free array, so we should do a runtime check.\n+    return true;\n+  }\n+  return false;\n+}\n@@ -176,1 +238,1 @@\n-  if (array_type != NULL) {\n+  if (delayed() == NULL && array_type != NULL) {\n@@ -190,1 +252,3 @@\n-\n+  if (delayed() != NULL) {\n+    return delayed()->field()->type();\n+  }\n@@ -201,0 +265,14 @@\n+bool StoreIndexed::is_exact_flattened_array_store() const {\n+  if (array()->is_loaded_flattened_array() && value()->as_Constant() == NULL && value()->declared_type() != NULL) {\n+    ciKlass* element_klass = array()->declared_type()->as_flat_array_klass()->element_klass();\n+    ciKlass* actual_klass = value()->declared_type()->as_klass();\n+\n+    \/\/ The following check can fail with inlining:\n+    \/\/     void test45_inline(Object[] oa, Object o, int index) { oa[index] = o; }\n+    \/\/     void test45(MyValue1[] va, int index, MyValue2 v) { test45_inline(va, v, index); }\n+    if (element_klass == actual_klass) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n@@ -212,1 +290,5 @@\n-  return ciObjArrayKlass::make(klass());\n+  return ciArrayKlass::make(klass(), is_null_free());\n+}\n+\n+ciType* NewMultiArray::exact_type() const {\n+  return _klass;\n@@ -227,0 +309,8 @@\n+ciType* NewInlineTypeInstance::exact_type() const {\n+  return klass();\n+}\n+\n+ciType* NewInlineTypeInstance::declared_type() const {\n+  return exact_type();\n+}\n+\n@@ -322,0 +412,35 @@\n+StoreField::StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,\n+                       ValueStack* state_before, bool needs_patching)\n+  : AccessField(obj, offset, field, is_static, state_before, needs_patching)\n+  , _value(value)\n+  , _enclosing_field(NULL)\n+{\n+  set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())->is_object());\n+#ifdef ASSERT\n+  AssertValues assert_value;\n+  values_do(&assert_value);\n+#endif\n+  pin();\n+  if (value->as_NewInlineTypeInstance() != NULL) {\n+    value->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+  }\n+}\n+\n+StoreIndexed::StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value,\n+                           ValueStack* state_before, bool check_boolean, bool mismatched)\n+  : AccessIndexed(array, index, length, elt_type, state_before, mismatched)\n+  , _value(value), _check_boolean(check_boolean)\n+{\n+  set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)->is_object()));\n+  set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)->is_object()));\n+#ifdef ASSERT\n+  AssertValues assert_value;\n+  values_do(&assert_value);\n+#endif\n+  pin();\n+  if (value->as_NewInlineTypeInstance() != NULL) {\n+    value->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+  }\n+}\n+\n+\n@@ -326,1 +451,1 @@\n-               ciMethod* target, ValueStack* state_before)\n+               ciMethod* target, ValueStack* state_before, bool null_free)\n@@ -335,0 +460,1 @@\n+  set_null_free(null_free);\n@@ -346,0 +472,3 @@\n+    if (receiver()->as_NewInlineTypeInstance() != NULL) {\n+      receiver()->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+    }\n@@ -348,1 +477,2 @@\n-    ValueType* t = argument_at(i)->type();\n+    Value v = argument_at(i);\n+    ValueType* t = v->type();\n@@ -351,0 +481,3 @@\n+    if (v->as_NewInlineTypeInstance() != NULL) {\n+      v->as_NewInlineTypeInstance()->set_not_larva_anymore();\n+    }\n@@ -832,0 +965,2 @@\n+          if (new_value->as_NewInlineTypeInstance() != NULL) {new_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n+          if (existing_value->as_NewInlineTypeInstance() != NULL) {existing_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n@@ -846,0 +981,2 @@\n+          if (new_value->as_NewInlineTypeInstance() != NULL) {new_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n+          if (existing_value->as_NewInlineTypeInstance() != NULL) {existing_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n@@ -991,0 +1128,1 @@\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":144,"deletions":6,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class     NewInlineTypeInstance;\n@@ -77,0 +78,1 @@\n+class     Deoptimize;\n@@ -101,0 +103,1 @@\n+class   ProfileACmpTypes;\n@@ -172,0 +175,1 @@\n+  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x) = 0;\n@@ -175,0 +179,1 @@\n+  virtual void do_Deoptimize     (Deoptimize*      x) = 0;\n@@ -196,0 +201,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes*  x) = 0;\n@@ -212,3 +218,4 @@\n-#define HASH2(x1, x2        )                    ((HASH1(x1        ) << 7) ^ HASH1(x2))\n-#define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) << 7) ^ HASH1(x3))\n-#define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) << 7) ^ HASH1(x4))\n+#define HASH2(x1, x2        )                    ((HASH1(x1            ) << 7) ^ HASH1(x2))\n+#define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) << 7) ^ HASH1(x3))\n+#define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) << 7) ^ HASH1(x4))\n+#define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) << 7) ^ HASH1(x5))\n@@ -273,0 +280,15 @@\n+#define HASHING4(class_name, enabled, f1, f2, f3, f4) \\\n+  virtual intx hash() const {                         \\\n+    return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \\\n+  }                                                   \\\n+  virtual bool is_equal(Value v) const {              \\\n+    if (!(enabled)  ) return false;                   \\\n+    class_name* _v = v->as_##class_name();            \\\n+    if (_v == NULL  ) return false;                   \\\n+    if (f1 != _v->f1) return false;                   \\\n+    if (f2 != _v->f2) return false;                   \\\n+    if (f3 != _v->f3) return false;                   \\\n+    if (f4 != _v->f4) return false;                   \\\n+    return true;                                      \\\n+  }                                                   \\\n+\n@@ -295,0 +317,1 @@\n+  friend class GraphBuilder;\n@@ -347,0 +370,1 @@\n+    NeverNullFlag,          \/\/ For \"Q\" signatures\n@@ -440,0 +464,2 @@\n+  void set_null_free(bool f)                     { set_flag(NeverNullFlag, f); }\n+  bool is_null_free() const                      { return check_flag(NeverNullFlag); }\n@@ -450,0 +476,1 @@\n+  ciKlass* as_loaded_klass_or_null() const;\n@@ -494,0 +521,4 @@\n+  bool is_loaded_flattened_array() const;\n+  bool maybe_flattened_array();\n+  bool maybe_null_free_array();\n+\n@@ -541,0 +572,1 @@\n+  virtual NewInlineTypeInstance* as_NewInlineTypeInstance() { return NULL; }\n@@ -545,0 +577,1 @@\n+  virtual Deoptimize*       as_Deoptimize()      { return NULL; }\n@@ -693,1 +726,1 @@\n-  Local(ciType* declared, ValueType* type, int index, bool receiver)\n+  Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)\n@@ -699,0 +732,1 @@\n+    set_null_free(null_free);\n@@ -820,1 +854,2 @@\n-            ValueStack* state_before, bool needs_patching)\n+            ValueStack* state_before, bool needs_patching,\n+            ciInlineKlass* inline_klass = NULL, Value default_value = NULL )\n@@ -822,1 +857,3 @@\n-  {}\n+  {\n+    set_null_free(field->is_null_free());\n+  }\n@@ -834,0 +871,1 @@\n+  ciField* _enclosing_field;   \/\/ enclosing field (the flattened one) for nested fields\n@@ -838,8 +876,1 @@\n-             ValueStack* state_before, bool needs_patching)\n-  : AccessField(obj, offset, field, is_static, state_before, needs_patching)\n-  , _value(value)\n-  {\n-    set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())->is_object());\n-    ASSERT_VALUES\n-    pin();\n-  }\n+             ValueStack* state_before, bool needs_patching);\n@@ -850,0 +881,2 @@\n+  ciField* enclosing_field() const               { return _enclosing_field; }\n+  void set_enclosing_field(ciField* field)       { _enclosing_field = field; }\n@@ -907,0 +940,2 @@\n+  ciMethod* _profiled_method;\n+  int       _profiled_bci;\n@@ -916,0 +951,1 @@\n+  , _profiled_method(NULL), _profiled_bci(0)\n@@ -931,1 +967,10 @@\n-  \/\/ generic\n+  \/\/ Helpers for MethodData* profiling\n+  void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }\n+  void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }\n+  void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }\n+  bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }\n+  ciMethod* profiled_method() const                  { return _profiled_method;     }\n+  int       profiled_bci() const                     { return _profiled_bci;        }\n+\n+\n+\/\/ generic\n@@ -935,0 +980,1 @@\n+class DelayedLoadIndexed;\n@@ -939,0 +985,2 @@\n+  NewInlineTypeInstance* _vt;\n+  DelayedLoadIndexed* _delayed;\n@@ -944,1 +992,1 @@\n-  , _explicit_null_check(NULL) {}\n+  , _explicit_null_check(NULL), _vt(NULL), _delayed(NULL) {}\n@@ -956,2 +1004,8 @@\n-  \/\/ generic;\n-  HASHING3(LoadIndexed, true, type()->tag(), array()->subst(), index()->subst())\n+  NewInlineTypeInstance* vt() const { return _vt; }\n+  void set_vt(NewInlineTypeInstance* vt) { _vt = vt; }\n+\n+  DelayedLoadIndexed* delayed() const { return _delayed; }\n+  void set_delayed(DelayedLoadIndexed* delayed) { _delayed = delayed; }\n+\n+  \/\/ generic\n+  HASHING4(LoadIndexed, delayed() == NULL && !should_profile(), type()->tag(), array()->subst(), index()->subst(), vt())\n@@ -960,0 +1014,23 @@\n+class DelayedLoadIndexed : public CompilationResourceObj {\n+private:\n+  LoadIndexed* _load_instr;\n+  ValueStack* _state_before;\n+  ciField* _field;\n+  int _offset;\n+ public:\n+  DelayedLoadIndexed(LoadIndexed* load, ValueStack* state_before)\n+  : _load_instr(load)\n+  , _state_before(state_before)\n+  , _field(NULL)\n+  , _offset(0) { }\n+\n+  void update(ciField* field, int offset) {\n+    _field = field;\n+    _offset += offset;\n+  }\n+\n+  LoadIndexed* load_instr() const { return _load_instr; }\n+  ValueStack* state_before() const { return _state_before; }\n+  ciField* field() const { return _field; }\n+  int offset() const { return _offset; }\n+};\n@@ -965,2 +1042,0 @@\n-  ciMethod* _profiled_method;\n-  int       _profiled_bci;\n@@ -972,9 +1047,1 @@\n-               bool check_boolean, bool mismatched = false)\n-  : AccessIndexed(array, index, length, elt_type, state_before, mismatched)\n-  , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)\n-  {\n-    set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)->is_object()));\n-    set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)->is_object()));\n-    ASSERT_VALUES\n-    pin();\n-  }\n+               bool check_boolean, bool mismatched = false);\n@@ -987,7 +1054,3 @@\n-  \/\/ Helpers for MethodData* profiling\n-  void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }\n-  void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }\n-  void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }\n-  bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }\n-  ciMethod* profiled_method() const                  { return _profiled_method;     }\n-  int       profiled_bci() const                     { return _profiled_bci;        }\n+\n+  \/\/ Flattened array support\n+  bool is_exact_flattened_array_store() const;\n@@ -1104,0 +1167,1 @@\n+  bool _substitutability_check;\n@@ -1107,1 +1171,1 @@\n-  IfOp(Value x, Condition cond, Value y, Value tval, Value fval)\n+  IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)\n@@ -1111,0 +1175,1 @@\n+  , _substitutability_check(substitutability_check)\n@@ -1114,0 +1179,1 @@\n+    set_state_before(state_before);\n@@ -1122,1 +1188,1 @@\n-\n+  bool substitutability_check() const             { return _substitutability_check; }\n@@ -1241,1 +1307,1 @@\n-         ciMethod* target, ValueStack* state_before);\n+         ciMethod* target, ValueStack* state_before, bool null_free);\n@@ -1299,0 +1365,48 @@\n+LEAF(NewInlineTypeInstance, StateSplit)\n+  ciInlineKlass* _klass;\n+  bool _in_larval_state;\n+  int _first_local_index;\n+  int _on_stack_count;\n+public:\n+\n+  \/\/ Default creation, always allocated for now\n+  NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before)\n+  : StateSplit(instanceType, state_before)\n+   , _klass(klass)\n+   , _in_larval_state(true)\n+   , _first_local_index(-1)\n+   , _on_stack_count(1)\n+  {\n+    set_null_free(true);\n+  }\n+\n+  \/\/ accessors\n+  ciInlineKlass* klass() const { return _klass; }\n+  virtual bool needs_exception_state() const     { return false; }\n+\n+  \/\/ generic\n+  virtual bool can_trap() const                  { return true; }\n+  ciType* exact_type() const;\n+  ciType* declared_type() const;\n+\n+  \/\/ Only done in LIR Generator -> map everything to object\n+  void set_to_object_type() { set_type(instanceType); }\n+\n+  void set_local_index(int index) {\n+    decrement_on_stack_count();\n+    if (_first_local_index != index) {\n+      if (_first_local_index == -1) {\n+        _first_local_index = index;\n+      } else {\n+        set_not_larva_anymore();\n+      }\n+    }\n+  }\n+\n+  bool in_larval_state() const { return _in_larval_state; }\n+  void set_not_larva_anymore() { _in_larval_state = false; }\n+\n+  int on_stack_count() const { return _on_stack_count; }\n+  void increment_on_stack_count() { _on_stack_count++; }\n+  void decrement_on_stack_count() { _on_stack_count--; }\n+};\n@@ -1350,1 +1464,4 @@\n-  NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before) : NewArray(length, state_before), _klass(klass) {}\n+  NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool null_free)\n+  : NewArray(length, state_before), _klass(klass) {\n+    set_null_free(null_free);\n+  }\n@@ -1385,0 +1502,2 @@\n+\n+  ciType* exact_type() const;\n@@ -1387,0 +1506,11 @@\n+LEAF(Deoptimize, StateSplit)\n+private:\n+  ciKlass*    _klass;\n+\n+ public:\n+  Deoptimize(ciKlass* klass, ValueStack* state_before)\n+  : StateSplit(objectType, state_before), _klass(klass) {}\n+\n+  \/\/ accessors\n+  ciKlass* klass() const                         { return _klass; }\n+};\n@@ -1431,2 +1561,4 @@\n-  CheckCast(ciKlass* klass, Value obj, ValueStack* state_before)\n-  : TypeCheck(klass, obj, objectType, state_before) {}\n+  CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool null_free = false)\n+  : TypeCheck(klass, obj, objectType, state_before) {\n+    set_null_free(null_free);\n+  }\n@@ -1490,0 +1622,1 @@\n+  bool _maybe_inlinetype;\n@@ -1492,1 +1625,1 @@\n-  MonitorEnter(Value obj, int monitor_no, ValueStack* state_before)\n+  MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_inlinetype)\n@@ -1494,0 +1627,1 @@\n+  , _maybe_inlinetype(maybe_inlinetype)\n@@ -1498,0 +1632,3 @@\n+  \/\/ accessors\n+  bool maybe_inlinetype() const                   { return _maybe_inlinetype; }\n+\n@@ -1957,0 +2094,1 @@\n+  bool        _substitutability_check;\n@@ -1960,1 +2098,1 @@\n-  If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint)\n+  If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)\n@@ -1968,0 +2106,1 @@\n+  , _substitutability_check(substitutability_check)\n@@ -1976,0 +2115,4 @@\n+    if (!_substitutability_check) {\n+      assert(x->as_NewInlineTypeInstance() == NULL || y->type() == objectNull, \"Sanity check\");\n+      assert(y->as_NewInlineTypeInstance() == NULL || x->type() == objectNull, \"Sanity check\");\n+    }\n@@ -2002,0 +2145,1 @@\n+  bool substitutability_check() const              { return _substitutability_check; }\n@@ -2336,1 +2480,1 @@\n-    \/\/ The ProfileType has side-effects and must occur precisely where located\n+    \/\/ The ProfileReturnType has side-effects and must occur precisely where located\n@@ -2352,0 +2496,42 @@\n+LEAF(ProfileACmpTypes, Instruction)\n+ private:\n+  ciMethod*        _method;\n+  int              _bci;\n+  Value            _left;\n+  Value            _right;\n+  bool             _left_maybe_null;\n+  bool             _right_maybe_null;\n+\n+ public:\n+  ProfileACmpTypes(ciMethod* method, int bci, Value left, Value right)\n+    : Instruction(voidType)\n+    , _method(method)\n+    , _bci(bci)\n+    , _left(left)\n+    , _right(right)\n+  {\n+    \/\/ The ProfileACmp has side-effects and must occur precisely where located\n+    pin();\n+    _left_maybe_null = true;\n+    _right_maybe_null = true;\n+  }\n+\n+  ciMethod* method()             const { return _method; }\n+  int bci()                      const { return _bci; }\n+  Value left()                   const { return _left; }\n+  Value right()                  const { return _right; }\n+  bool left_maybe_null()         const { return _left_maybe_null; }\n+  bool right_maybe_null()        const { return _right_maybe_null; }\n+  void set_left_maybe_null(bool v)     { _left_maybe_null = v; }\n+  void set_right_maybe_null(bool v)    { _right_maybe_null = v; }\n+\n+  virtual void input_values_do(ValueVisitor* f)   {\n+    if (_left != NULL) {\n+      f->visit(&_left);\n+    }\n+    if (_right != NULL) {\n+      f->visit(&_right);\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":231,"deletions":45,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -99,0 +100,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -155,0 +157,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -292,1 +295,1 @@\n-                                 CodeStub* stub)\n+                                 CodeStub* stub, bool need_null_check)\n@@ -308,0 +311,1 @@\n+  , _need_null_check(need_null_check)\n@@ -335,0 +339,1 @@\n+  , _need_null_check(true)\n@@ -344,0 +349,31 @@\n+LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)\n+  : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)\n+  , _array(array)\n+  , _value(value)\n+  , _tmp(tmp)\n+  , _stub(stub) {}\n+\n+\n+LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)\n+  : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)\n+  , _array(array)\n+  , _tmp(tmp) {}\n+\n+\n+LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,\n+                                                         LIR_Opr tmp1, LIR_Opr tmp2,\n+                                                         ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,\n+                                                         CodeEmitInfo* info, CodeStub* stub)\n+  : LIR_Op(lir_substitutability_check, result, info)\n+  , _left(left)\n+  , _right(right)\n+  , _equal_result(equal_result)\n+  , _not_equal_result(not_equal_result)\n+  , _tmp1(tmp1)\n+  , _tmp2(tmp2)\n+  , _left_klass(left_klass)\n+  , _right_klass(right_klass)\n+  , _left_klass_op(left_klass_op)\n+  , _right_klass_op(right_klass_op)\n+  , _stub(stub) {}\n+\n@@ -410,0 +446,1 @@\n+    case lir_check_orig_pc:            \/\/ result and info always invalid\n@@ -804,0 +841,1 @@\n+      do_stub(opLock->_throw_imse_stub);\n@@ -840,0 +878,45 @@\n+\/\/ LIR_OpFlattenedArrayCheck\n+    case lir_flattened_array_check: {\n+      assert(op->as_OpFlattenedArrayCheck() != NULL, \"must be\");\n+      LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;\n+\n+      if (opFlattenedArrayCheck->_array->is_valid()) do_input(opFlattenedArrayCheck->_array);\n+      if (opFlattenedArrayCheck->_value->is_valid()) do_input(opFlattenedArrayCheck->_value);\n+      if (opFlattenedArrayCheck->_tmp->is_valid())   do_temp(opFlattenedArrayCheck->_tmp);\n+                                                     do_stub(opFlattenedArrayCheck->_stub);\n+\n+      break;\n+    }\n+\n+\/\/ LIR_OpNullFreeArrayCheck\n+    case lir_null_free_array_check: {\n+      assert(op->as_OpNullFreeArrayCheck() != NULL, \"must be\");\n+      LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;\n+\n+      if (opNullFreeArrayCheck->_array->is_valid()) do_input(opNullFreeArrayCheck->_array);\n+      if (opNullFreeArrayCheck->_tmp->is_valid())   do_temp(opNullFreeArrayCheck->_tmp);\n+      break;\n+    }\n+\n+\/\/ LIR_OpSubstitutabilityCheck\n+    case lir_substitutability_check: {\n+      assert(op->as_OpSubstitutabilityCheck() != NULL, \"must be\");\n+      LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;\n+                                                                do_input(opSubstitutabilityCheck->_left);\n+                                                                do_temp (opSubstitutabilityCheck->_left);\n+                                                                do_input(opSubstitutabilityCheck->_right);\n+                                                                do_temp (opSubstitutabilityCheck->_right);\n+                                                                do_input(opSubstitutabilityCheck->_equal_result);\n+                                                                do_temp (opSubstitutabilityCheck->_equal_result);\n+                                                                do_input(opSubstitutabilityCheck->_not_equal_result);\n+                                                                do_temp (opSubstitutabilityCheck->_not_equal_result);\n+      if (opSubstitutabilityCheck->_tmp1->is_valid())           do_temp(opSubstitutabilityCheck->_tmp1);\n+      if (opSubstitutabilityCheck->_tmp2->is_valid())           do_temp(opSubstitutabilityCheck->_tmp2);\n+      if (opSubstitutabilityCheck->_left_klass_op->is_valid())  do_temp(opSubstitutabilityCheck->_left_klass_op);\n+      if (opSubstitutabilityCheck->_right_klass_op->is_valid()) do_temp(opSubstitutabilityCheck->_right_klass_op);\n+      if (opSubstitutabilityCheck->_result->is_valid())         do_output(opSubstitutabilityCheck->_result);\n+                                                                do_info(opSubstitutabilityCheck->_info);\n+                                                                do_stub(opSubstitutabilityCheck->_stub);\n+      break;\n+    }\n+\n@@ -916,1 +999,12 @@\n-  default:\n+\n+    \/\/ LIR_OpProfileInlineType:\n+    case lir_profile_inline_type: {\n+      assert(op->as_OpProfileInlineType() != NULL, \"must be\");\n+      LIR_OpProfileInlineType* opProfileInlineType = (LIR_OpProfileInlineType*)op;\n+\n+      do_input(opProfileInlineType->_mdp); do_temp(opProfileInlineType->_mdp);\n+      do_input(opProfileInlineType->_obj);\n+      do_temp(opProfileInlineType->_tmp);\n+      break;\n+    }\n+default:\n@@ -989,0 +1083,28 @@\n+bool LIR_OpJavaCall::maybe_return_as_fields(ciInlineKlass** vk_ret) const {\n+  ciType* return_type = method()->return_type();\n+  if (InlineTypeReturnedAsFields) {\n+    if (return_type->is_inlinetype()) {\n+      ciInlineKlass* vk = return_type->as_inline_klass();\n+      if (vk->can_be_returned_as_fields()) {\n+        if (vk_ret != NULL) {\n+          *vk_ret = vk;\n+        }\n+        return true;\n+      }\n+    } else if (return_type->is_instance_klass() &&\n+               (method()->is_method_handle_intrinsic() ||\n+                (!return_type->is_loaded() && !method()->holder()->is_loaded()))) {\n+      \/\/ An inline type might be returned from the call but we don't know its type.\n+      \/\/ This can happen with method handle intrinsics or when both the return type\n+      \/\/ and the method holder are unloaded (and therefore the preload logic did not\n+      \/\/ get a chance to load the return type). If an inline type is returned, we\n+      \/\/ either get an oop to a buffer and nothing needs to be done or one of the\n+      \/\/ values being returned is the klass of the inline type (RAX on x64, with LSB\n+      \/\/ set to 1) and we need to allocate an inline type instance of that type and\n+      \/\/ initialize it with other values being returned (in other registers).\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1049,0 +1171,18 @@\n+void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {\n+  masm->emit_opFlattenedArrayCheck(this);\n+  if (stub() != NULL) {\n+    masm->append_code_stub(stub());\n+  }\n+}\n+\n+void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {\n+  masm->emit_opNullFreeArrayCheck(this);\n+}\n+\n+void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {\n+  masm->emit_opSubstitutabilityCheck(this);\n+  if (stub() != NULL) {\n+    masm->append_code_stub(stub());\n+  }\n+}\n+\n@@ -1066,0 +1206,3 @@\n+  if (throw_imse_stub()) {\n+    masm->append_code_stub(throw_imse_stub());\n+  }\n@@ -1090,0 +1233,4 @@\n+void LIR_OpProfileInlineType::emit_code(LIR_Assembler* masm) {\n+  masm->emit_profile_inline_type(this);\n+}\n+\n@@ -1407,1 +1554,1 @@\n-void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info) {\n+void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {\n@@ -1415,1 +1562,2 @@\n-                    info));\n+                    info,\n+                    throw_imse_stub));\n@@ -1440,1 +1588,4 @@\n-                          ciMethod* profiled_method, int profiled_bci) {\n+                          ciMethod* profiled_method, int profiled_bci, bool is_null_free) {\n+  \/\/ If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check\n+  \/\/ on the object.\n+  bool need_null_check = !is_null_free;\n@@ -1442,1 +1593,2 @@\n-                                           tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);\n+                                           tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,\n+                                           need_null_check);\n@@ -1464,0 +1616,1 @@\n+  \/\/ FIXME -- if the types of the array and\/or the object are known statically, we can avoid loading the klass\n@@ -1485,0 +1638,21 @@\n+void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {\n+  LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);\n+  append(c);\n+}\n+\n+void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {\n+  LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);\n+  append(c);\n+}\n+\n+void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,\n+                                      LIR_Opr tmp1, LIR_Opr tmp2,\n+                                      ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,\n+                                      CodeEmitInfo* info, CodeStub* stub) {\n+  LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,\n+                                                                   tmp1, tmp2,\n+                                                                   left_klass, right_klass, left_klass_op, right_klass_op,\n+                                                                   info, stub);\n+  append(c);\n+}\n+\n@@ -1701,0 +1875,1 @@\n+     case lir_check_orig_pc:         s = \"check_orig_pc\"; break;\n@@ -1767,0 +1942,6 @@\n+     \/\/ LIR_OpFlattenedArrayCheck\n+     case lir_flattened_array_check: s = \"flattened_array_check\"; break;\n+     \/\/ LIR_OpNullFreeArrayCheck\n+     case lir_null_free_array_check: s = \"null_free_array_check\"; break;\n+     \/\/ LIR_OpSubstitutabilityCheck\n+     case lir_substitutability_check: s = \"substitutability_check\"; break;\n@@ -1775,0 +1956,2 @@\n+     \/\/ LIR_OpProfileInlineType\n+     case lir_profile_inline_type:   s = \"profile_inline_type\"; break;\n@@ -2006,0 +2189,38 @@\n+void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {\n+  array()->print(out);                   out->print(\" \");\n+  value()->print(out);                   out->print(\" \");\n+  tmp()->print(out);                     out->print(\" \");\n+  if (stub() != NULL) {\n+    out->print(\"[label:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  }\n+}\n+\n+void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {\n+  array()->print(out);                   out->print(\" \");\n+  tmp()->print(out);                     out->print(\" \");\n+}\n+\n+void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {\n+  result_opr()->print(out);              out->print(\" \");\n+  left()->print(out);                    out->print(\" \");\n+  right()->print(out);                   out->print(\" \");\n+  equal_result()->print(out);            out->print(\" \");\n+  not_equal_result()->print(out);        out->print(\" \");\n+  tmp1()->print(out);                    out->print(\" \");\n+  tmp2()->print(out);                    out->print(\" \");\n+  if (left_klass() == NULL) {\n+    out->print(\"unknown \");\n+  } else {\n+    left_klass()->print(out);            out->print(\" \");\n+  }\n+  if (right_klass() == NULL) {\n+    out->print(\"unknown \");\n+  } else {\n+    right_klass()->print(out);           out->print(\" \");\n+  }\n+  left_klass_op()->print(out);           out->print(\" \");\n+  right_klass_op()->print(out);          out->print(\" \");\n+  if (stub() != NULL) {\n+    out->print(\"[label:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  }\n+}\n@@ -2081,0 +2302,8 @@\n+\/\/ LIR_OpProfileInlineType\n+void LIR_OpProfileInlineType::print_instr(outputStream* out) const {\n+  out->print(\" flag = %x \", flag());\n+  mdp()->print(out);          out->print(\" \");\n+  obj()->print(out);          out->print(\" \");\n+  tmp()->print(out);          out->print(\" \");\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":235,"deletions":6,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -490,0 +491,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -681,0 +683,1 @@\n+      case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -785,0 +788,1 @@\n+      case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -899,0 +903,3 @@\n+class    LIR_OpFlattenedArrayCheck;\n+class    LIR_OpNullFreeArrayCheck;\n+class    LIR_OpSubstitutabilityCheck;\n@@ -903,0 +910,1 @@\n+class    LIR_OpProfileInlineType;\n@@ -927,0 +935,1 @@\n+      , lir_check_orig_pc\n@@ -1006,0 +1015,9 @@\n+  , begin_opFlattenedArrayCheck\n+    , lir_flattened_array_check\n+  , end_opFlattenedArrayCheck\n+  , begin_opNullFreeArrayCheck\n+    , lir_null_free_array_check\n+  , end_opNullFreeArrayCheck\n+  , begin_opSubstitutabilityCheck\n+    , lir_substitutability_check\n+  , end_opSubstitutabilityCheck\n@@ -1014,0 +1032,1 @@\n+    , lir_profile_inline_type\n@@ -1162,0 +1181,3 @@\n+  virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return NULL; }\n+  virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return NULL; }\n+  virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return NULL; }\n@@ -1166,0 +1188,1 @@\n+  virtual LIR_OpProfileInlineType* as_OpProfileInlineType() { return NULL; }\n@@ -1238,0 +1261,2 @@\n+\n+  bool maybe_return_as_fields(ciInlineKlass** vk = NULL) const;\n@@ -1289,1 +1314,4 @@\n-    all_flags              = (1 << 12) - 1\n+    always_slow_path       = 1 << 12,\n+    src_inlinetype_check   = 1 << 13,\n+    dst_inlinetype_check   = 1 << 14,\n+    all_flags              = (1 << 15) - 1\n@@ -1552,0 +1580,1 @@\n+  bool          _need_null_check;\n@@ -1556,1 +1585,1 @@\n-                  CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub);\n+                  CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub, bool need_null_check = true);\n@@ -1578,1 +1607,1 @@\n-\n+  bool      need_null_check() const              { return _need_null_check;   }\n@@ -1585,0 +1614,76 @@\n+\/\/ LIR_OpFlattenedArrayCheck\n+class LIR_OpFlattenedArrayCheck: public LIR_Op {\n+ friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr       _array;\n+  LIR_Opr       _value;\n+  LIR_Opr       _tmp;\n+  CodeStub*     _stub;\n+public:\n+  LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);\n+  LIR_Opr array() const                          { return _array;         }\n+  LIR_Opr value() const                          { return _value;         }\n+  LIR_Opr tmp() const                            { return _tmp;           }\n+  CodeStub* stub() const                         { return _stub;          }\n+\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return this; }\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+\n+\/\/ LIR_OpNullFreeArrayCheck\n+class LIR_OpNullFreeArrayCheck: public LIR_Op {\n+ friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr       _array;\n+  LIR_Opr       _tmp;\n+public:\n+  LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp);\n+  LIR_Opr array() const                          { return _array;         }\n+  LIR_Opr tmp() const                            { return _tmp;           }\n+\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return this; }\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+\n+class LIR_OpSubstitutabilityCheck: public LIR_Op {\n+ friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr       _left;\n+  LIR_Opr       _right;\n+  LIR_Opr       _equal_result;\n+  LIR_Opr       _not_equal_result;\n+  LIR_Opr       _tmp1;\n+  LIR_Opr       _tmp2;\n+  ciKlass*      _left_klass;\n+  ciKlass*      _right_klass;\n+  LIR_Opr       _left_klass_op;\n+  LIR_Opr       _right_klass_op;\n+  CodeStub*     _stub;\n+public:\n+  LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,\n+                              LIR_Opr tmp1, LIR_Opr tmp2,\n+                              ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,\n+                              CodeEmitInfo* info, CodeStub* stub);\n+\n+  LIR_Opr left() const             { return _left; }\n+  LIR_Opr right() const            { return _right; }\n+  LIR_Opr equal_result() const     { return _equal_result; }\n+  LIR_Opr not_equal_result() const { return _not_equal_result; }\n+  LIR_Opr tmp1() const             { return _tmp1; }\n+  LIR_Opr tmp2() const             { return _tmp2; }\n+  ciKlass* left_klass() const      { return _left_klass; }\n+  ciKlass* right_klass() const     { return _right_klass; }\n+  LIR_Opr left_klass_op() const    { return _left_klass_op; }\n+  LIR_Opr right_klass_op() const   { return _right_klass_op; }\n+  CodeStub* stub() const           { return _stub; }\n+\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return this; }\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+\n@@ -1879,0 +1984,1 @@\n+  CodeStub* _throw_imse_stub;\n@@ -1880,1 +1986,1 @@\n-  LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info)\n+  LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL)\n@@ -1886,1 +1992,2 @@\n-    , _stub(stub)                      {}\n+    , _stub(stub)\n+    , _throw_imse_stub(throw_imse_stub)                    {}\n@@ -1893,0 +2000,1 @@\n+  CodeStub* throw_imse_stub() const              { return _throw_imse_stub; }\n@@ -2076,0 +2184,32 @@\n+\/\/ LIR_OpProfileInlineType\n+class LIR_OpProfileInlineType : public LIR_Op {\n+ friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr      _mdp;\n+  LIR_Opr      _obj;\n+  int          _flag;\n+  LIR_Opr      _tmp;\n+  bool         _not_null;      \/\/ true if we know statically that _obj cannot be null\n+\n+ public:\n+  \/\/ Destroys recv\n+  LIR_OpProfileInlineType(LIR_Opr mdp, LIR_Opr obj, int flag, LIR_Opr tmp, bool not_null)\n+    : LIR_Op(lir_profile_inline_type, LIR_OprFact::illegalOpr, NULL)  \/\/ no result, no info\n+    , _mdp(mdp)\n+    , _obj(obj)\n+    , _flag(flag)\n+    , _tmp(tmp)\n+    , _not_null(not_null) { }\n+\n+  LIR_Opr      mdp()              const             { return _mdp;              }\n+  LIR_Opr      obj()              const             { return _obj;              }\n+  int          flag()             const             { return _flag;             }\n+  LIR_Opr      tmp()              const             { return _tmp;              }\n+  bool         not_null()         const             { return _not_null;         }\n+\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_OpProfileInlineType* as_OpProfileInlineType() { return this; }\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+\n@@ -2348,1 +2488,1 @@\n-  void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info);\n+  void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL);\n@@ -2358,0 +2498,6 @@\n+  void check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);\n+  void check_null_free_array(LIR_Opr array, LIR_Opr tmp);\n+  void substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,\n+                              LIR_Opr tmp1, LIR_Opr tmp2,\n+                              ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,\n+                              CodeEmitInfo* info, CodeStub* stub);\n@@ -2362,1 +2508,1 @@\n-                  ciMethod* profiled_method, int profiled_bci);\n+                  ciMethod* profiled_method, int profiled_bci, bool is_null_free);\n@@ -2370,0 +2516,3 @@\n+  void profile_inline_type(LIR_Address* mdp, LIR_Opr obj, int flag, LIR_Opr tmp, bool not_null) {\n+    append(new LIR_OpProfileInlineType(LIR_OprFact::address(mdp), obj, flag, tmp, not_null));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":156,"deletions":7,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -57,0 +59,1 @@\n+      case Bytecodes::_withfield:\n@@ -64,0 +67,1 @@\n+      case Bytecodes::_aconst_init:\n@@ -121,0 +125,1 @@\n+  _verified_inline_entry.reset();\n@@ -332,1 +337,0 @@\n-\n@@ -342,2 +346,1 @@\n-\n-void LIR_Assembler::add_call_info(int pc_offset, CodeEmitInfo* cinfo) {\n+void LIR_Assembler::add_call_info(int pc_offset, CodeEmitInfo* cinfo, bool maybe_return_as_fields) {\n@@ -345,1 +348,1 @@\n-  cinfo->record_debug_info(compilation()->debug_info_recorder(), pc_offset);\n+  cinfo->record_debug_info(compilation()->debug_info_recorder(), pc_offset, maybe_return_as_fields);\n@@ -490,0 +493,6 @@\n+  ciInlineKlass* vk = NULL;\n+  if (op->maybe_return_as_fields(&vk)) {\n+    int offset = store_inline_type_fields_to_buf(vk);\n+    add_call_info(offset, op->info(), true);\n+  }\n+\n@@ -596,0 +605,135 @@\n+void LIR_Assembler::add_scalarized_entry_info(int pc_offset) {\n+  flush_debug_info(pc_offset);\n+  DebugInformationRecorder* debug_info = compilation()->debug_info_recorder();\n+  \/\/ The VEP and VIEP(RO) of a C1-compiled method call buffer_inline_args_xxx()\n+  \/\/ before doing any argument shuffling. This call may cause GC. When GC happens,\n+  \/\/ all the parameters are still as passed by the caller, so we just use\n+  \/\/ map->set_include_argument_oops() inside frame::sender_for_compiled_frame(RegisterMap* map).\n+  \/\/ There's no need to build a GC map here.\n+  OopMap* oop_map = new OopMap(0, 0);\n+  debug_info->add_safepoint(pc_offset, oop_map);\n+  DebugToken* locvals = debug_info->create_scope_values(NULL); \/\/ FIXME is this needed (for Java debugging to work properly??)\n+  DebugToken* expvals = debug_info->create_scope_values(NULL); \/\/ FIXME is this needed (for Java debugging to work properly??)\n+  DebugToken* monvals = debug_info->create_monitor_values(NULL); \/\/ FIXME: need testing with synchronized method\n+  bool reexecute = false;\n+  bool return_oop = false; \/\/ This flag will be ignored since it used only for C2 with escape analysis.\n+  bool rethrow_exception = false;\n+  bool is_method_handle_invoke = false;\n+  debug_info->describe_scope(pc_offset, methodHandle(), method(), 0, reexecute, rethrow_exception, is_method_handle_invoke, return_oop, false, locvals, expvals, monvals);\n+  debug_info->end_safepoint(pc_offset);\n+}\n+\n+\/\/ The entries points of C1-compiled methods can have the following types:\n+\/\/ (1) Methods with no inline type args\n+\/\/ (2) Methods with inline type receiver but no inline type args\n+\/\/     VIEP_RO is the same as VIEP\n+\/\/ (3) Methods with non-inline type receiver and some inline type args\n+\/\/     VIEP_RO is the same as VEP\n+\/\/ (4) Methods with inline type receiver and other inline type args\n+\/\/     Separate VEP, VIEP and VIEP_RO\n+\/\/\n+\/\/ (1)               (2)                 (3)                    (4)\n+\/\/ UEP\/UIEP:         VEP:                UEP:                   UEP:\n+\/\/   check_icache      pack receiver       check_icache           check_icache\n+\/\/ VEP\/VIEP\/VIEP_RO    jump to VIEP      VEP\/VIEP_RO:           VIEP_RO:\n+\/\/   body            UEP\/UIEP:             pack inline args       pack inline args (except receiver)\n+\/\/                     check_icache        jump to VIEP           jump to VIEP\n+\/\/                   VIEP\/VIEP_RO        UIEP:                  VEP:\n+\/\/                     body                check_icache           pack all inline args\n+\/\/                                       VIEP:                    jump to VIEP\n+\/\/                                         body                 UIEP:\n+\/\/                                                                check_icache\n+\/\/                                                              VIEP:\n+\/\/                                                                body\n+void LIR_Assembler::emit_std_entries() {\n+  offsets()->set_value(CodeOffsets::OSR_Entry, _masm->offset());\n+\n+  _masm->align(CodeEntryAlignment);\n+  const CompiledEntrySignature* ces = compilation()->compiled_entry_signature();\n+  if (ces->has_scalarized_args()) {\n+    assert(InlineTypePassFieldsAsArgs && method()->get_Method()->has_scalarized_args(), \"must be\");\n+    CodeOffsets::Entries ro_entry_type = ces->c1_inline_ro_entry_type();\n+\n+    \/\/ UEP: check icache and fall-through\n+    if (ro_entry_type != CodeOffsets::Verified_Inline_Entry) {\n+      offsets()->set_value(CodeOffsets::Entry, _masm->offset());\n+      if (needs_icache(method())) {\n+        check_icache();\n+      }\n+    }\n+\n+    \/\/ VIEP_RO: pack all value parameters, except the receiver\n+    if (ro_entry_type == CodeOffsets::Verified_Inline_Entry_RO) {\n+      emit_std_entry(CodeOffsets::Verified_Inline_Entry_RO, ces);\n+    }\n+\n+    \/\/ VEP: pack all value parameters\n+    _masm->align(CodeEntryAlignment);\n+    emit_std_entry(CodeOffsets::Verified_Entry, ces);\n+\n+    \/\/ UIEP: check icache and fall-through\n+    _masm->align(CodeEntryAlignment);\n+    offsets()->set_value(CodeOffsets::Inline_Entry, _masm->offset());\n+    if (ro_entry_type == CodeOffsets::Verified_Inline_Entry) {\n+      \/\/ Special case if we have VIEP == VIEP(RO):\n+      \/\/ this means UIEP (called by C1) == UEP (called by C2).\n+      offsets()->set_value(CodeOffsets::Entry, _masm->offset());\n+    }\n+    if (needs_icache(method())) {\n+      check_icache();\n+    }\n+\n+    \/\/ VIEP: all value parameters are passed as refs - no packing.\n+    emit_std_entry(CodeOffsets::Verified_Inline_Entry, NULL);\n+\n+    if (ro_entry_type != CodeOffsets::Verified_Inline_Entry_RO) {\n+      \/\/ The VIEP(RO) is the same as VEP or VIEP\n+      assert(ro_entry_type == CodeOffsets::Verified_Entry ||\n+             ro_entry_type == CodeOffsets::Verified_Inline_Entry, \"must be\");\n+      offsets()->set_value(CodeOffsets::Verified_Inline_Entry_RO,\n+                           offsets()->value(ro_entry_type));\n+    }\n+  } else {\n+    \/\/ All 3 entries are the same (no inline type packing)\n+    offsets()->set_value(CodeOffsets::Entry, _masm->offset());\n+    offsets()->set_value(CodeOffsets::Inline_Entry, _masm->offset());\n+    if (needs_icache(method())) {\n+      check_icache();\n+    }\n+    emit_std_entry(CodeOffsets::Verified_Inline_Entry, NULL);\n+    offsets()->set_value(CodeOffsets::Verified_Entry, offsets()->value(CodeOffsets::Verified_Inline_Entry));\n+    offsets()->set_value(CodeOffsets::Verified_Inline_Entry_RO, offsets()->value(CodeOffsets::Verified_Inline_Entry));\n+  }\n+}\n+\n+void LIR_Assembler::emit_std_entry(CodeOffsets::Entries entry, const CompiledEntrySignature* ces) {\n+  offsets()->set_value(entry, _masm->offset());\n+  _masm->verified_entry(compilation()->directive()->BreakAtExecuteOption);\n+  switch (entry) {\n+  case CodeOffsets::Verified_Entry: {\n+    if (needs_clinit_barrier_on_entry(method())) {\n+      clinit_barrier(method());\n+    }\n+    int rt_call_offset = _masm->verified_entry(ces, initial_frame_size_in_bytes(), bang_size_in_bytes(), in_bytes(frame_map()->sp_offset_for_orig_pc()), _verified_inline_entry);\n+    add_scalarized_entry_info(rt_call_offset);\n+    break;\n+  }\n+  case CodeOffsets::Verified_Inline_Entry_RO: {\n+    assert(!needs_clinit_barrier_on_entry(method()), \"can't be static\");\n+    int rt_call_offset = _masm->verified_inline_ro_entry(ces, initial_frame_size_in_bytes(), bang_size_in_bytes(), in_bytes(frame_map()->sp_offset_for_orig_pc()), _verified_inline_entry);\n+    add_scalarized_entry_info(rt_call_offset);\n+    break;\n+  }\n+  case CodeOffsets::Verified_Inline_Entry: {\n+    if (needs_clinit_barrier_on_entry(method())) {\n+      clinit_barrier(method());\n+    }\n+    build_frame();\n+    offsets()->set_value(CodeOffsets::Frame_Complete, _masm->offset());\n+    break;\n+  }\n+  default:\n+    ShouldNotReachHere();\n+    break;\n+  }\n+}\n@@ -609,13 +753,1 @@\n-      \/\/ init offsets\n-      offsets()->set_value(CodeOffsets::OSR_Entry, _masm->offset());\n-      _masm->align(CodeEntryAlignment);\n-      if (needs_icache(compilation()->method())) {\n-        check_icache();\n-      }\n-      offsets()->set_value(CodeOffsets::Verified_Entry, _masm->offset());\n-      _masm->verified_entry(compilation()->directive()->BreakAtExecuteOption);\n-      if (needs_clinit_barrier_on_entry(compilation()->method())) {\n-        clinit_barrier(compilation()->method());\n-      }\n-      build_frame();\n-      offsets()->set_value(CodeOffsets::Frame_Complete, _masm->offset());\n+      emit_std_entries();\n@@ -675,0 +807,4 @@\n+    case lir_check_orig_pc:\n+      check_orig_pc();\n+      break;\n+\n@@ -773,1 +909,2 @@\n-  _masm->build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n+  _masm->build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), in_bytes(frame_map()->sp_offset_for_orig_pc()),\n+                     needs_stack_repair(), method()->has_scalarized_args(), &_verified_inline_entry);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":155,"deletions":18,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class CompiledEntrySignature;\n@@ -50,0 +51,1 @@\n+  Label              _verified_inline_entry;\n@@ -94,0 +96,4 @@\n+  bool needs_stack_repair() const {\n+    return compilation()->needs_stack_repair();\n+  }\n+\n@@ -100,1 +106,1 @@\n-  void add_call_info(int pc_offset, CodeEmitInfo* cinfo);\n+  void add_call_info(int pc_offset, CodeEmitInfo* cinfo, bool maybe_return_as_fields = false);\n@@ -197,0 +203,3 @@\n+  void emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op);\n+  void emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op);\n+  void emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op);\n@@ -205,0 +214,1 @@\n+  void emit_profile_inline_type(LIR_OpProfileInlineType* op);\n@@ -206,0 +216,3 @@\n+  void emit_std_entries();\n+  void emit_std_entry(CodeOffsets::Entries entry, const CompiledEntrySignature* ces);\n+  void add_scalarized_entry_info(int call_offset);\n@@ -227,0 +240,1 @@\n+  int  store_inline_type_fields_to_buf(ciInlineKlass* vk);\n@@ -253,0 +267,1 @@\n+  void check_orig_pc();\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -213,0 +215,2 @@\n+  assert(!_gen->in_conditional_code(), \"LIRItem cannot be loaded in conditional code\");\n+\n@@ -608,1 +612,2 @@\n-void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info) {\n+void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no,\n+                                 CodeEmitInfo* info_for_exception, CodeEmitInfo* info, CodeStub* throw_imse_stub) {\n@@ -611,1 +616,1 @@\n-  CodeStub* slow_path = new MonitorEnterStub(object, lock, info);\n+  CodeStub* slow_path = new MonitorEnterStub(object, lock, info, throw_imse_stub, scratch);\n@@ -614,1 +619,1 @@\n-  __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception);\n+  __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception, throw_imse_stub);\n@@ -638,4 +643,9 @@\n-void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {\n-  klass2reg_with_patching(klass_reg, klass, info, is_unresolved);\n-  \/\/ If klass is not loaded we do not know if the klass has finalizers:\n-  if (UseFastNewInstance && klass->is_loaded()\n+void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, bool allow_inline, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {\n+  if (allow_inline) {\n+    assert(!is_unresolved && klass->is_loaded(), \"inline type klass should be resolved\");\n+    __ metadata2reg(klass->constant_encoding(), klass_reg);\n+  } else {\n+    klass2reg_with_patching(klass_reg, klass, info, is_unresolved);\n+  }\n+  \/\/ If klass is not loaded we do not know if the klass has finalizers or is an unexpected inline klass\n+  if (UseFastNewInstance && klass->is_loaded() && (allow_inline || !klass->is_inlinetype())\n@@ -655,2 +665,2 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);\n-    __ branch(lir_cond_always, slow_path);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, allow_inline ? Runtime1::new_instance_id : Runtime1::new_instance_no_inline_id);\n+    __ jump(slow_path);\n@@ -756,0 +766,10 @@\n+  if (!src->is_loaded_flattened_array() && !dst->is_loaded_flattened_array()) {\n+    flags &= ~LIR_OpArrayCopy::always_slow_path;\n+  }\n+  if (!src->maybe_flattened_array()) {\n+    flags &= ~LIR_OpArrayCopy::src_inlinetype_check;\n+  }\n+  if (!dst->maybe_flattened_array() && !dst->maybe_null_free_array()) {\n+    flags &= ~LIR_OpArrayCopy::dst_inlinetype_check;\n+  }\n+\n@@ -1560,2 +1580,4 @@\n-  _constants.append(c);\n-  _reg_for_constants.append(result);\n+  if (!in_conditional_code()) {\n+    _constants.append(c);\n+    _reg_for_constants.append(result);\n+  }\n@@ -1565,0 +1587,6 @@\n+void LIRGenerator::set_in_conditional_code(bool v) {\n+  assert(v != _in_conditional_code, \"must change state\");\n+  _in_conditional_code = v;\n+}\n+\n+\n@@ -1656,0 +1684,5 @@\n+  if (!inline_type_field_access_prolog(x)) {\n+    \/\/ Field store will always deopt due to unloaded field or holder klass\n+    return;\n+  }\n+\n@@ -1677,0 +1710,173 @@\n+\/\/ FIXME -- I can't find any other way to pass an address to access_load_at().\n+class TempResolvedAddress: public Instruction {\n+ public:\n+  TempResolvedAddress(ValueType* type, LIR_Opr addr) : Instruction(type) {\n+    set_operand(addr);\n+  }\n+  virtual void input_values_do(ValueVisitor*) {}\n+  virtual void visit(InstructionVisitor* v)   {}\n+  virtual const char* name() const  { return \"TempResolvedAddress\"; }\n+};\n+\n+LIR_Opr LIRGenerator::get_and_load_element_address(LIRItem& array, LIRItem& index) {\n+  ciType* array_type = array.value()->declared_type();\n+  ciFlatArrayKlass* flat_array_klass = array_type->as_flat_array_klass();\n+  assert(flat_array_klass->is_loaded(), \"must be\");\n+\n+  int array_header_size = flat_array_klass->array_header_in_bytes();\n+  int shift = flat_array_klass->log2_element_size();\n+\n+#ifndef _LP64\n+  LIR_Opr index_op = new_register(T_INT);\n+  \/\/ FIXME -- on 32-bit, the shift below can overflow, so we need to check that\n+  \/\/ the top (shift+1) bits of index_op must be zero, or\n+  \/\/ else throw ArrayIndexOutOfBoundsException\n+  if (index.result()->is_constant()) {\n+    jint const_index = index.result()->as_jint();\n+    __ move(LIR_OprFact::intConst(const_index << shift), index_op);\n+  } else {\n+    __ shift_left(index_op, shift, index.result());\n+  }\n+#else\n+  LIR_Opr index_op = new_register(T_LONG);\n+  if (index.result()->is_constant()) {\n+    jint const_index = index.result()->as_jint();\n+    __ move(LIR_OprFact::longConst(const_index << shift), index_op);\n+  } else {\n+    __ convert(Bytecodes::_i2l, index.result(), index_op);\n+    \/\/ Need to shift manually, as LIR_Address can scale only up to 3.\n+    __ shift_left(index_op, shift, index_op);\n+  }\n+#endif\n+\n+  LIR_Opr elm_op = new_pointer_register();\n+  LIR_Address* elm_address = generate_address(array.result(), index_op, 0, array_header_size, T_ADDRESS);\n+  __ leal(LIR_OprFact::address(elm_address), elm_op);\n+  return elm_op;\n+}\n+\n+void LIRGenerator::access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset) {\n+  assert(field != NULL, \"Need a subelement type specified\");\n+\n+  \/\/ Find the starting address of the source (inside the array)\n+  LIR_Opr elm_op = get_and_load_element_address(array, index);\n+\n+  BasicType subelt_type = field->type()->basic_type();\n+  TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(subelt_type), elm_op);\n+  LIRItem elm_item(elm_resolved_addr, this);\n+\n+  DecoratorSet decorators = IN_HEAP;\n+  access_load_at(decorators, subelt_type,\n+                     elm_item, LIR_OprFact::intConst(sub_offset), result,\n+                     NULL, NULL);\n+\n+  if (field->is_null_free()) {\n+    assert(field->type()->is_loaded(), \"Must be\");\n+    assert(field->type()->is_inlinetype(), \"Must be if loaded\");\n+    assert(field->type()->as_inline_klass()->is_initialized(), \"Must be\");\n+    LabelObj* L_end = new LabelObj();\n+    __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n+    __ branch(lir_cond_notEqual, L_end->label());\n+    set_in_conditional_code(true);\n+    Constant* default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+    if (default_value->is_pinned()) {\n+      __ move(LIR_OprFact::value_type(default_value->type()), result);\n+    } else {\n+      __ move(load_constant(default_value), result);\n+    }\n+    __ branch_destination(L_end->label());\n+    set_in_conditional_code(false);\n+  }\n+}\n+\n+void LIRGenerator::access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item,\n+                                          ciField* field, int sub_offset) {\n+  assert(sub_offset == 0 || field != NULL, \"Sanity check\");\n+\n+  \/\/ Find the starting address of the source (inside the array)\n+  LIR_Opr elm_op = get_and_load_element_address(array, index);\n+\n+  ciInlineKlass* elem_klass = NULL;\n+  if (field != NULL) {\n+    elem_klass = field->type()->as_inline_klass();\n+  } else {\n+    elem_klass = array.value()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass();\n+  }\n+  for (int i = 0; i < elem_klass->nof_nonstatic_fields(); i++) {\n+    ciField* inner_field = elem_klass->nonstatic_field_at(i);\n+    assert(!inner_field->is_flattened(), \"flattened fields must have been expanded\");\n+    int obj_offset = inner_field->offset();\n+    int elm_offset = obj_offset - elem_klass->first_field_offset() + sub_offset; \/\/ object header is not stored in array.\n+    BasicType field_type = inner_field->type()->basic_type();\n+\n+    \/\/ Types which are smaller than int are still passed in an int register.\n+    BasicType reg_type = field_type;\n+    switch (reg_type) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+    case T_SHORT:\n+    case T_CHAR:\n+      reg_type = T_INT;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+    LIR_Opr temp = new_register(reg_type);\n+    TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(field_type), elm_op);\n+    LIRItem elm_item(elm_resolved_addr, this);\n+\n+    DecoratorSet decorators = IN_HEAP;\n+    if (is_load) {\n+      access_load_at(decorators, field_type,\n+                     elm_item, LIR_OprFact::intConst(elm_offset), temp,\n+                     NULL, NULL);\n+      access_store_at(decorators, field_type,\n+                      obj_item, LIR_OprFact::intConst(obj_offset), temp,\n+                      NULL, NULL);\n+    } else {\n+      access_load_at(decorators, field_type,\n+                     obj_item, LIR_OprFact::intConst(obj_offset), temp,\n+                     NULL, NULL);\n+      access_store_at(decorators, field_type,\n+                      elm_item, LIR_OprFact::intConst(elm_offset), temp,\n+                      NULL, NULL);\n+    }\n+  }\n+}\n+\n+void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {\n+  LIR_Opr tmp = new_register(T_METADATA);\n+  __ check_flattened_array(array, value, tmp, slow_path);\n+}\n+\n+void LIRGenerator::check_null_free_array(LIRItem& array, LIRItem& value, CodeEmitInfo* info) {\n+  LabelObj* L_end = new LabelObj();\n+  LIR_Opr tmp = new_register(T_METADATA);\n+  __ check_null_free_array(array.result(), tmp);\n+  __ branch(lir_cond_equal, L_end->label());\n+  __ null_check(value.result(), info);\n+  __ branch_destination(L_end->label());\n+}\n+\n+bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {\n+  if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {\n+    ciType* type = x->value()->declared_type();\n+    if (type != NULL && type->is_klass()) {\n+      ciKlass* klass = type->as_klass();\n+      if (!klass->can_be_inline_klass() || (klass->is_inlinetype() && !klass->as_inline_klass()->flatten_array())) {\n+        \/\/ This is known to be a non-flattened object. If the array is flattened,\n+        \/\/ it will be caught by the code generated by array_store_check().\n+        return false;\n+      }\n+    }\n+    \/\/ We're not 100% sure, so let's do the flattened_array_store_check.\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool LIRGenerator::needs_null_free_array_store_check(StoreIndexed* x) {\n+  return x->elt_type() == T_OBJECT && x->array()->maybe_null_free_array();\n+}\n+\n@@ -1679,0 +1885,2 @@\n+  assert(x->elt_type() != T_ARRAY, \"never used\");\n+  bool is_loaded_flattened_array = x->array()->is_loaded_flattened_array();\n@@ -1682,3 +1890,3 @@\n-  bool needs_store_check = obj_store && (x->value()->as_Constant() == NULL ||\n-                                         !get_jobject_constant(x->value())->is_null_object() ||\n-                                         x->should_profile());\n+  bool needs_store_check = obj_store && !(is_loaded_flattened_array && x->is_exact_flattened_array_store()) &&\n+                                        (x->value()->as_Constant() == NULL ||\n+                                         !get_jobject_constant(x->value())->is_null_object());\n@@ -1697,2 +1905,3 @@\n-\n-  if (needs_store_check || x->check_boolean()) {\n+\n+  if (needs_store_check || x->check_boolean()\n+      || is_loaded_flattened_array || needs_flattened_array_store_check(x) || needs_null_free_array_store_check(x)) {\n@@ -1727,0 +1936,16 @@\n+  if (x->should_profile()) {\n+    if (x->array()->is_loaded_flattened_array()) {\n+      \/\/ No need to profile a store to a flattened array of known type. This can happen if\n+      \/\/ the type only became known after optimizations (for example, after the PhiSimplifier).\n+      x->set_should_profile(false);\n+    } else {\n+      ciMethodData* md = NULL;\n+      ciArrayLoadStoreData* load_store = NULL;\n+      profile_array_type(x, md, load_store);\n+      if (x->array()->maybe_null_free_array()) {\n+        profile_null_free_array(array, md, load_store);\n+      }\n+      profile_element_type(x->value(), md, load_store);\n+    }\n+  }\n+\n@@ -1729,1 +1954,1 @@\n-    array_store_check(value.result(), array.result(), store_check_info, x->profiled_method(), x->profiled_bci());\n+    array_store_check(value.result(), array.result(), store_check_info, NULL, -1);\n@@ -1732,4 +1957,21 @@\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n-  if (x->check_boolean()) {\n-    decorators |= C1_MASK_BOOLEAN;\n-  }\n+  if (is_loaded_flattened_array) {\n+    if (!x->value()->is_null_free()) {\n+      __ null_check(value.result(), new CodeEmitInfo(range_check_info));\n+    }\n+    \/\/ If array element is an empty inline type, no need to copy anything\n+    if (!x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_empty()) {\n+      access_flattened_array(false, array, index, value);\n+    }\n+  } else {\n+    StoreFlattenedArrayStub* slow_path = NULL;\n+\n+    if (needs_flattened_array_store_check(x)) {\n+      \/\/ Check if we indeed have a flattened array\n+      index.load_item();\n+      slow_path = new StoreFlattenedArrayStub(array.result(), index.result(), value.result(), state_for(x, x->state_before()));\n+      check_flattened_array(array.result(), value.result(), slow_path);\n+      set_in_conditional_code(true);\n+    } else if (needs_null_free_array_store_check(x)) {\n+      CodeEmitInfo* info = new CodeEmitInfo(range_check_info);\n+      check_null_free_array(array, value, info);\n+    }\n@@ -1737,2 +1979,12 @@\n-  access_store_at(decorators, x->elt_type(), array, index.result(), value.result(),\n-                  NULL, null_check_info);\n+    DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+    if (x->check_boolean()) {\n+      decorators |= C1_MASK_BOOLEAN;\n+    }\n+\n+    access_store_at(decorators, x->elt_type(), array, index.result(), value.result(),\n+                    NULL, null_check_info);\n+    if (slow_path != NULL) {\n+      __ branch_destination(slow_path->continuation());\n+      set_in_conditional_code(false);\n+    }\n+  }\n@@ -1819,0 +2071,25 @@\n+bool LIRGenerator::inline_type_field_access_prolog(AccessField* x) {\n+  ciField* field = x->field();\n+  assert(!field->is_flattened(), \"Flattened field access should have been expanded\");\n+  if (!field->is_null_free()) {\n+    return true; \/\/ Not an inline type field\n+  }\n+  \/\/ Deoptimize if the access is non-static and requires patching (holder not loaded\n+  \/\/ or not accessible) because then we only have partial field information and the\n+  \/\/ field could be flattened (see ciField constructor).\n+  bool could_be_flat = !x->is_static() && x->needs_patching();\n+  \/\/ Deoptimize if we load from a static field with an uninitialized type because we\n+  \/\/ need to throw an exception if initialization of the type failed.\n+  bool not_initialized = x->is_static() && x->as_LoadField() != NULL &&\n+      !field->type()->as_instance_klass()->is_initialized();\n+  if (could_be_flat || not_initialized) {\n+    CodeEmitInfo* info = state_for(x, x->state_before());\n+    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n+                                        Deoptimization::Reason_unloaded,\n+                                        Deoptimization::Action_make_not_entrant);\n+    __ jump(stub);\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -1848,0 +2125,7 @@\n+  if (!inline_type_field_access_prolog(x)) {\n+    \/\/ Field load will always deopt due to unloaded field or holder klass\n+    LIR_Opr result = rlock_result(x, field_type);\n+    __ move(LIR_OprFact::oopConst(NULL), result);\n+    return;\n+  }\n+\n@@ -1876,0 +2160,33 @@\n+\n+  ciField* field = x->field();\n+  if (field->is_null_free()) {\n+    \/\/ Load from non-flattened inline type field requires\n+    \/\/ a null check to replace null with the default value.\n+    ciInstanceKlass* holder = field->holder();\n+    if (field->is_static() && holder->is_loaded()) {\n+      ciObject* val = holder->java_mirror()->field_value(field).as_object();\n+      if (!val->is_null_object()) {\n+        \/\/ Static field is initialized, we don't need to perform a null check.\n+        return;\n+      }\n+    }\n+    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+    if (inline_klass->is_initialized()) {\n+      LabelObj* L_end = new LabelObj();\n+      __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n+      __ branch(lir_cond_notEqual, L_end->label());\n+      set_in_conditional_code(true);\n+      Constant* default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n+      if (default_value->is_pinned()) {\n+        __ move(LIR_OprFact::value_type(default_value->type()), result);\n+      } else {\n+        __ move(load_constant(default_value), result);\n+      }\n+      __ branch_destination(L_end->label());\n+      set_in_conditional_code(false);\n+    } else {\n+      __ cmp(lir_cond_equal, result, LIR_OprFact::oopConst(NULL));\n+      __ branch(lir_cond_equal, new DeoptimizeStub(info, Deoptimization::Reason_uninitialized,\n+                                                         Deoptimization::Action_make_not_entrant));\n+    }\n+  }\n@@ -2020,1 +2337,68 @@\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+  ciMethodData* md = NULL;\n+  ciArrayLoadStoreData* load_store = NULL;\n+  if (x->should_profile()) {\n+    if (x->array()->is_loaded_flattened_array()) {\n+      \/\/ No need to profile a load from a flattened array of known type. This can happen if\n+      \/\/ the type only became known after optimizations (for example, after the PhiSimplifier).\n+      x->set_should_profile(false);\n+    } else {\n+      profile_array_type(x, md, load_store);\n+    }\n+  }\n+\n+  Value element;\n+  if (x->vt() != NULL) {\n+    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    \/\/ Find the destination address (of the NewInlineTypeInstance).\n+    LIRItem obj_item(x->vt(), this);\n+\n+    access_flattened_array(true, array, index, obj_item,\n+                           x->delayed() == NULL ? 0 : x->delayed()->field(),\n+                           x->delayed() == NULL ? 0 : x->delayed()->offset());\n+    set_no_result(x);\n+  } else if (x->delayed() != NULL) {\n+    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    LIR_Opr result = rlock_result(x, x->delayed()->field()->type()->basic_type());\n+    access_sub_element(array, index, result, x->delayed()->field(), x->delayed()->offset());\n+  } else if (x->array() != NULL && x->array()->is_loaded_flattened_array() &&\n+             x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_initialized() &&\n+             x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_empty()) {\n+    \/\/ Load the default instance instead of reading the element\n+    ciInlineKlass* elem_klass = x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass();\n+    LIR_Opr result = rlock_result(x, x->elt_type());\n+    assert(elem_klass->is_initialized(), \"Must be\");\n+    Constant* default_value = new Constant(new InstanceConstant(elem_klass->default_instance()));\n+    if (default_value->is_pinned()) {\n+      __ move(LIR_OprFact::value_type(default_value->type()), result);\n+    } else {\n+      __ move(load_constant(default_value), result);\n+    }\n+  } else {\n+    LIR_Opr result = rlock_result(x, x->elt_type());\n+    LoadFlattenedArrayStub* slow_path = NULL;\n+\n+    if (x->should_profile() && x->array()->maybe_null_free_array()) {\n+      profile_null_free_array(array, md, load_store);\n+    }\n+\n+    if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {\n+      assert(x->delayed() == NULL, \"Delayed LoadIndexed only apply to loaded_flattened_arrays\");\n+      index.load_item();\n+      \/\/ if we are loading from flattened array, load it using a runtime call\n+      slow_path = new LoadFlattenedArrayStub(array.result(), index.result(), result, state_for(x, x->state_before()));\n+      check_flattened_array(array.result(), LIR_OprFact::illegalOpr, slow_path);\n+      set_in_conditional_code(true);\n+    }\n+\n+    DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+    access_load_at(decorators, x->elt_type(),\n+                   array, index.result(), result,\n+                   NULL, null_check_info);\n+\n+    if (slow_path != NULL) {\n+      __ branch_destination(slow_path->continuation());\n+      set_in_conditional_code(false);\n+    }\n+\n+    element = x;\n+  }\n@@ -2022,4 +2406,3 @@\n-  LIR_Opr result = rlock_result(x, x->elt_type());\n-  access_load_at(decorators, x->elt_type(),\n-                 array, index.result(), result,\n-                 NULL, null_check_info);\n+  if (x->should_profile()) {\n+    profile_element_type(element, md, load_store);\n+  }\n@@ -2028,0 +2411,12 @@\n+void LIRGenerator::do_Deoptimize(Deoptimize* x) {\n+  \/\/ This happens only when a class X uses the withfield\/aconst_init bytecode\n+  \/\/ to refer to an inline class V, where V has not yet been loaded\/resolved.\n+  \/\/ This is not a common case. Let's just deoptimize.\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+  CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n+                                      Deoptimization::Reason_unloaded,\n+                                      Deoptimization::Action_make_not_entrant);\n+  __ jump(stub);\n+  LIR_Opr reg = rlock_result(x, T_OBJECT);\n+  __ move(LIR_OprFact::oopConst(NULL), reg);\n+}\n@@ -2526,1 +2921,1 @@\n-  if (do_update) {\n+  if (do_update && signature_at_call_k != NULL) {\n@@ -2611,0 +3006,46 @@\n+void LIRGenerator::profile_flags(ciMethodData* md, ciProfileData* data, int flag, LIR_Condition condition) {\n+  assert(md != NULL && data != NULL, \"should have been initialized\");\n+  LIR_Opr mdp = new_register(T_METADATA);\n+  __ metadata2reg(md->constant_encoding(), mdp);\n+  LIR_Address* addr = new LIR_Address(mdp, md->byte_offset_of_slot(data, DataLayout::flags_offset()), T_BYTE);\n+  LIR_Opr flags = new_register(T_INT);\n+  __ move(addr, flags);\n+  if (condition != lir_cond_always) {\n+    LIR_Opr update = new_register(T_INT);\n+    __ cmove(condition, LIR_OprFact::intConst(0), LIR_OprFact::intConst(flag), update, T_INT);\n+  } else {\n+    __ logical_or(flags, LIR_OprFact::intConst(flag), flags);\n+  }\n+  __ store(flags, addr);\n+}\n+\n+void LIRGenerator::profile_null_free_array(LIRItem array, ciMethodData* md, ciArrayLoadStoreData* load_store) {\n+  assert(compilation()->profile_array_accesses(), \"array access profiling is disabled\");\n+  LabelObj* L_end = new LabelObj();\n+  LIR_Opr tmp = new_register(T_METADATA);\n+  __ check_null_free_array(array.result(), tmp);\n+\n+  profile_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), lir_cond_equal);\n+}\n+\n+void LIRGenerator::profile_array_type(AccessIndexed* x, ciMethodData*& md, ciArrayLoadStoreData*& load_store) {\n+  assert(compilation()->profile_array_accesses(), \"array access profiling is disabled\");\n+  int bci = x->profiled_bci();\n+  md = x->profiled_method()->method_data();\n+  assert(md != NULL, \"Sanity\");\n+  ciProfileData* data = md->bci_to_data(bci);\n+  assert(data != NULL && data->is_ArrayLoadStoreData(), \"incorrect profiling entry\");\n+  load_store = (ciArrayLoadStoreData*)data;\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(load_store, ArrayLoadStoreData::array_offset()), 0,\n+               load_store->array()->type(), x->array(), mdp, true, NULL, NULL);\n+}\n+\n+void LIRGenerator::profile_element_type(Value element, ciMethodData* md, ciArrayLoadStoreData* load_store) {\n+  assert(compilation()->profile_array_accesses(), \"array access profiling is disabled\");\n+  assert(md != NULL && load_store != NULL, \"should have been initialized\");\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(load_store, ArrayLoadStoreData::element_offset()), 0,\n+               load_store->element()->type(), element, mdp, false, NULL, NULL);\n+}\n+\n@@ -2695,0 +3136,8 @@\n+  if (method()->has_scalarized_args()) {\n+    \/\/ Check if deoptimization was triggered (i.e. orig_pc was set) while buffering scalarized inline type arguments\n+    \/\/ in the entry point (see comments in frame::deoptimize). If so, deoptimize only now that we have the right state.\n+    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, 0), NULL, false);\n+    CodeStub* deopt_stub = new DeoptimizeStub(info, Deoptimization::Reason_none, Deoptimization::Action_none);\n+    __ append(new LIR_Op0(lir_check_orig_pc));\n+    __ branch(lir_cond_notEqual, deopt_stub);\n+  }\n@@ -2710,0 +3159,14 @@\n+void LIRGenerator::invoke_load_one_argument(LIRItem* param, LIR_Opr loc) {\n+  if (loc->is_register()) {\n+    param->load_item_force(loc);\n+  } else {\n+    LIR_Address* addr = loc->as_address_ptr();\n+    param->load_for_store(addr->type());\n+    assert(addr->type() != T_PRIMITIVE_OBJECT, \"not supported yet\");\n+    if (addr->type() == T_OBJECT) {\n+      __ move_wide(param->result(), addr);\n+    } else {\n+      __ move(param->result(), addr);\n+    }\n+  }\n+}\n@@ -2717,10 +3180,1 @@\n-    if (loc->is_register()) {\n-      param->load_item_force(loc);\n-    } else {\n-      LIR_Address* addr = loc->as_address_ptr();\n-      param->load_for_store(addr->type());\n-      if (addr->type() == T_OBJECT) {\n-        __ move_wide(param->result(), addr);\n-      } else\n-        __ move(param->result(), addr);\n-    }\n+    invoke_load_one_argument(param, loc);\n@@ -2892,1 +3346,1 @@\n-  if (can_inline_as_constant(right.value())) {\n+  if (can_inline_as_constant(right.value()) && !x->substitutability_check()) {\n@@ -2895,0 +3349,1 @@\n+    \/\/ substitutability_check() needs to use right as a base register.\n@@ -2902,3 +3357,60 @@\n-  LIR_Opr reg = rlock_result(x);\n-  __ cmp(lir_cond(x->cond()), left.result(), right.result());\n-  __ cmove(lir_cond(x->cond()), t_val.result(), f_val.result(), reg, as_BasicType(x->x()->type()));\n+  if (x->substitutability_check()) {\n+    substitutability_check(x, left, right, t_val, f_val);\n+  } else {\n+    LIR_Opr reg = rlock_result(x);\n+    __ cmp(lir_cond(x->cond()), left.result(), right.result());\n+    __ cmove(lir_cond(x->cond()), t_val.result(), f_val.result(), reg, as_BasicType(x->x()->type()));\n+  }\n+}\n+\n+void LIRGenerator::substitutability_check(IfOp* x, LIRItem& left, LIRItem& right, LIRItem& t_val, LIRItem& f_val) {\n+  assert(x->cond() == If::eql || x->cond() == If::neq, \"must be\");\n+  bool is_acmpeq = (x->cond() == If::eql);\n+  LIR_Opr equal_result     = is_acmpeq ? t_val.result() : f_val.result();\n+  LIR_Opr not_equal_result = is_acmpeq ? f_val.result() : t_val.result();\n+  LIR_Opr result = rlock_result(x);\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+\n+  substitutability_check_common(x->x(), x->y(), left, right, equal_result, not_equal_result, result, info);\n+}\n+\n+void LIRGenerator::substitutability_check(If* x, LIRItem& left, LIRItem& right) {\n+  LIR_Opr equal_result     = LIR_OprFact::intConst(1);\n+  LIR_Opr not_equal_result = LIR_OprFact::intConst(0);\n+  LIR_Opr result = new_register(T_INT);\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+\n+  substitutability_check_common(x->x(), x->y(), left, right, equal_result, not_equal_result, result, info);\n+\n+  assert(x->cond() == If::eql || x->cond() == If::neq, \"must be\");\n+  __ cmp(lir_cond(x->cond()), result, equal_result);\n+}\n+\n+void LIRGenerator::substitutability_check_common(Value left_val, Value right_val, LIRItem& left, LIRItem& right,\n+                                                 LIR_Opr equal_result, LIR_Opr not_equal_result, LIR_Opr result,\n+                                                 CodeEmitInfo* info) {\n+  LIR_Opr tmp1 = LIR_OprFact::illegalOpr;\n+  LIR_Opr tmp2 = LIR_OprFact::illegalOpr;\n+  LIR_Opr left_klass_op = LIR_OprFact::illegalOpr;\n+  LIR_Opr right_klass_op = LIR_OprFact::illegalOpr;\n+\n+  ciKlass* left_klass  = left_val ->as_loaded_klass_or_null();\n+  ciKlass* right_klass = right_val->as_loaded_klass_or_null();\n+\n+  if ((left_klass == NULL || right_klass == NULL) ||\/\/ The klass is still unloaded, or came from a Phi node.\n+      !left_klass->is_inlinetype() || !right_klass->is_inlinetype()) {\n+    init_temps_for_substitutability_check(tmp1, tmp2);\n+  }\n+\n+  if (left_klass != NULL && left_klass->is_inlinetype() && left_klass == right_klass) {\n+    \/\/ No need to load klass -- the operands are statically known to be the same inline klass.\n+  } else {\n+    BasicType t_klass = UseCompressedOops ? T_INT : T_METADATA;\n+    left_klass_op = new_register(t_klass);\n+    right_klass_op = new_register(t_klass);\n+  }\n+\n+  CodeStub* slow_path = new SubstitutabilityCheckStub(left.result(), right.result(), info);\n+  __ substitutability_check(result, left.result(), right.result(), equal_result, not_equal_result,\n+                            tmp1, tmp2,\n+                            left_klass, right_klass, left_klass_op, right_klass_op, info, slow_path);\n@@ -3179,1 +3691,1 @@\n-    ciReturnTypeEntry* ret = data->is_CallTypeData() ? ((ciCallTypeData*)data)->ret() : ((ciVirtualCallTypeData*)data)->ret();\n+    ciSingleTypeEntry* ret = data->is_CallTypeData() ? ((ciCallTypeData*)data)->ret() : ((ciVirtualCallTypeData*)data)->ret();\n@@ -3200,0 +3712,47 @@\n+bool LIRGenerator::profile_inline_klass(ciMethodData* md, ciProfileData* data, Value value, int flag) {\n+  ciKlass* klass = value->as_loaded_klass_or_null();\n+  if (klass != NULL) {\n+    if (klass->is_inlinetype()) {\n+      profile_flags(md, data, flag, lir_cond_always);\n+    } else if (klass->can_be_inline_klass()) {\n+      return false;\n+    }\n+  } else {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\n+void LIRGenerator::do_ProfileACmpTypes(ProfileACmpTypes* x) {\n+  ciMethod* method = x->method();\n+  assert(method != NULL, \"method should be set if branch is profiled\");\n+  ciMethodData* md = method->method_data_or_null();\n+  assert(md != NULL, \"Sanity\");\n+  ciProfileData* data = md->bci_to_data(x->bci());\n+  assert(data != NULL, \"must have profiling data\");\n+  assert(data->is_ACmpData(), \"need BranchData for two-way branches\");\n+  ciACmpData* acmp = (ciACmpData*)data;\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(acmp, ACmpData::left_offset()), 0,\n+               acmp->left()->type(), x->left(), mdp, !x->left_maybe_null(), NULL, NULL);\n+  int flags_offset = md->byte_offset_of_slot(data, DataLayout::flags_offset());\n+  if (!profile_inline_klass(md, acmp, x->left(), ACmpData::left_inline_type_byte_constant())) {\n+    LIR_Opr mdp = new_register(T_METADATA);\n+    __ metadata2reg(md->constant_encoding(), mdp);\n+    LIRItem value(x->left(), this);\n+    value.load_item();\n+    __ profile_inline_type(new LIR_Address(mdp, flags_offset, T_INT), value.result(), ACmpData::left_inline_type_byte_constant(), new_register(T_INT), !x->left_maybe_null());\n+  }\n+  profile_type(md, md->byte_offset_of_slot(acmp, ACmpData::left_offset()),\n+               in_bytes(ACmpData::right_offset()) - in_bytes(ACmpData::left_offset()),\n+               acmp->right()->type(), x->right(), mdp, !x->right_maybe_null(), NULL, NULL);\n+  if (!profile_inline_klass(md, acmp, x->right(), ACmpData::right_inline_type_byte_constant())) {\n+    LIR_Opr mdp = new_register(T_METADATA);\n+    __ metadata2reg(md->constant_encoding(), mdp);\n+    LIRItem value(x->right(), this);\n+    value.load_item();\n+    __ profile_inline_type(new LIR_Address(mdp, flags_offset, T_INT), value.result(), ACmpData::right_inline_type_byte_constant(), new_register(T_INT), !x->left_maybe_null());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":603,"deletions":44,"binary":false,"changes":647,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  bool          _in_conditional_code;\n@@ -198,0 +199,1 @@\n+  void set_in_conditional_code(bool v);\n@@ -217,0 +219,1 @@\n+  bool in_conditional_code() { return _in_conditional_code; }\n@@ -277,0 +280,14 @@\n+  bool inline_type_field_access_prolog(AccessField* x);\n+  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = NULL, int offset = 0);\n+  void access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset);\n+  LIR_Opr get_and_load_element_address(LIRItem& array, LIRItem& index);\n+  bool needs_flattened_array_store_check(StoreIndexed* x);\n+  void check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path);\n+  bool needs_null_free_array_store_check(StoreIndexed* x);\n+  void check_null_free_array(LIRItem& array, LIRItem& value,  CodeEmitInfo* info);\n+  void substitutability_check(IfOp* x, LIRItem& left, LIRItem& right, LIRItem& t_val, LIRItem& f_val);\n+  void substitutability_check(If* x, LIRItem& left, LIRItem& right);\n+  void substitutability_check_common(Value left_val, Value right_val, LIRItem& left, LIRItem& right,\n+                                     LIR_Opr equal_result, LIR_Opr not_equal_result, LIR_Opr result, CodeEmitInfo* info);\n+  void init_temps_for_substitutability_check(LIR_Opr& tmp1, LIR_Opr& tmp2);\n+\n@@ -330,1 +347,1 @@\n-\n+  void invoke_load_one_argument(LIRItem* param, LIR_Opr loc);\n@@ -366,1 +383,1 @@\n-  void monitor_enter (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info);\n+  void monitor_enter (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info, CodeStub* throw_imse_stub);\n@@ -369,1 +386,1 @@\n-  void new_instance    (LIR_Opr  dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr  scratch1, LIR_Opr  scratch2, LIR_Opr  scratch3,  LIR_Opr scratch4, LIR_Opr  klass_reg, CodeEmitInfo* info);\n+  void new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, bool allow_inline, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info);\n@@ -486,0 +503,5 @@\n+  void profile_flags(ciMethodData* md, ciProfileData* load_store, int flag, LIR_Condition condition = lir_cond_always);\n+  void profile_null_free_array(LIRItem array, ciMethodData* md, ciArrayLoadStoreData* load_store);\n+  void profile_array_type(AccessIndexed* x, ciMethodData*& md, ciArrayLoadStoreData*& load_store);\n+  void profile_element_type(Value element, ciMethodData* md, ciArrayLoadStoreData* load_store);\n+  bool profile_inline_klass(ciMethodData* md, ciProfileData* data, Value value, int flag);\n@@ -513,0 +535,1 @@\n+    , _in_conditional_code(false)\n@@ -566,0 +589,1 @@\n+  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n@@ -569,0 +593,1 @@\n+  virtual void do_Deoptimize     (Deoptimize*      x);\n@@ -591,0 +616,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};\n+static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, 2, -1};\n@@ -68,1 +68,1 @@\n-static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};\n+static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, 1, -1};\n@@ -263,1 +263,1 @@\n-  if (!frame_map()->finalize_frame(max_spills())) {\n+  if (!frame_map()->finalize_frame(max_spills(), compilation()->needs_stack_repair())) {\n@@ -2950,1 +2950,1 @@\n-  return new IRScopeDebugInfo(cur_scope, cur_state->bci(), locals, expressions, monitors, caller_debug_info);\n+  return new IRScopeDebugInfo(cur_scope, cur_state->bci(), locals, expressions, monitors, caller_debug_info, cur_state->should_reexecute());\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  Value make_ifop(Value x, Instruction::Condition cond, Value y, Value tval, Value fval);\n+  Value make_ifop(Value x, Instruction::Condition cond, Value y, Value tval, Value fval,\n+                  ValueStack* state_before, bool substitutability_check);\n@@ -221,1 +222,2 @@\n-  Value result = make_ifop(if_->x(), if_->cond(), if_->y(), t_value, f_value);\n+  Value result = make_ifop(if_->x(), if_->cond(), if_->y(), t_value, f_value,\n+                           if_->state_before(), if_->substitutability_check());\n@@ -276,1 +278,2 @@\n-Value CE_Eliminator::make_ifop(Value x, Instruction::Condition cond, Value y, Value tval, Value fval) {\n+Value CE_Eliminator::make_ifop(Value x, Instruction::Condition cond, Value y, Value tval, Value fval,\n+                               ValueStack* state_before, bool substitutability_check) {\n@@ -278,1 +281,1 @@\n-    return new IfOp(x, cond, y, tval, fval);\n+    return new IfOp(x, cond, y, tval, fval, state_before, substitutability_check);\n@@ -313,1 +316,1 @@\n-            return new IfOp(x_ifop->x(), x_ifop_cond, x_ifop->y(), new_tval, new_fval);\n+            return new IfOp(x_ifop->x(), x_ifop_cond, x_ifop->y(), new_tval, new_fval, state_before, substitutability_check);\n@@ -329,1 +332,1 @@\n-  return new IfOp(x, cond, y, tval, fval);\n+  return new IfOp(x, cond, y, tval, fval, state_before, substitutability_check);\n@@ -469,1 +472,1 @@\n-      if (con && ifop) {\n+      if (con && ifop && !ifop->substitutability_check()) {\n@@ -494,1 +497,1 @@\n-                                 tblock, fblock, if_->state_before(), if_->is_safepoint());\n+                                 tblock, fblock, if_->state_before(), if_->is_safepoint(), ifop->substitutability_check());\n@@ -565,0 +568,1 @@\n+  void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n@@ -568,0 +572,1 @@\n+  void do_Deoptimize     (Deoptimize*      x);\n@@ -589,0 +594,1 @@\n+  void do_ProfileACmpTypes(ProfileACmpTypes*  x);\n@@ -710,0 +716,1 @@\n+  void handle_NewInlineTypeInstance(NewInlineTypeInstance* x);\n@@ -717,0 +724,1 @@\n+  void handle_ProfileACmpTypes(ProfileACmpTypes* x);\n@@ -748,0 +756,1 @@\n+void NullCheckVisitor::do_NewInlineTypeInstance(NewInlineTypeInstance* x) { nce()->handle_NewInlineTypeInstance(x); }\n@@ -751,0 +760,1 @@\n+void NullCheckVisitor::do_Deoptimize     (Deoptimize*      x) {}\n@@ -774,0 +784,1 @@\n+void NullCheckVisitor::do_ProfileACmpTypes(ProfileACmpTypes* x) { nce()->handle_ProfileACmpTypes(x); }\n@@ -1097,0 +1108,7 @@\n+void NullCheckEliminator::handle_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n+  set_put(x);\n+  if (PrintNullCheckElimination) {\n+    tty->print_cr(\"NewInlineTypeInstance %d is non-null\", x->id());\n+  }\n+}\n+\n@@ -1201,0 +1219,5 @@\n+void NullCheckEliminator::handle_ProfileACmpTypes(ProfileACmpTypes* x) {\n+  x->set_left_maybe_null(!set_contains(x->left()));\n+  x->set_right_maybe_null(!set_contains(x->right()));\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -125,0 +127,1 @@\n+int Runtime1::_new_flat_array_slowcase_cnt = 0;\n@@ -127,0 +130,5 @@\n+int Runtime1::_load_flattened_array_slowcase_cnt = 0;\n+int Runtime1::_store_flattened_array_slowcase_cnt = 0;\n+int Runtime1::_substitutability_check_slowcase_cnt = 0;\n+int Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n+int Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n@@ -136,0 +144,1 @@\n+int Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n@@ -352,2 +361,1 @@\n-\n-JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n+static void allocate_instance(JavaThread* current, Klass* klass, TRAPS) {\n@@ -356,1 +364,1 @@\n-    _new_instance_slowcase_cnt++;\n+    Runtime1::_new_instance_slowcase_cnt++;\n@@ -370,0 +378,12 @@\n+JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n+  allocate_instance(current, klass, CHECK);\n+JRT_END\n+\n+\/\/ Same as new_instance but throws error for inline klasses\n+JRT_ENTRY(void, Runtime1::new_instance_no_inline(JavaThread* current, Klass* klass))\n+  if (klass->is_inline_klass()) {\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_InstantiationError());\n+  } else {\n+    allocate_instance(current, klass, CHECK);\n+  }\n+JRT_END\n@@ -404,1 +424,1 @@\n-  Klass* elem_klass = ObjArrayKlass::cast(array_klass)->element_klass();\n+  Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();\n@@ -415,0 +435,22 @@\n+JRT_ENTRY(void, Runtime1::new_flat_array(JavaThread* current, Klass* array_klass, jint length))\n+  NOT_PRODUCT(_new_flat_array_slowcase_cnt++;)\n+\n+  \/\/ Note: no handle for klass needed since they are not used\n+  \/\/       anymore after new_objArray() and no GC can happen before.\n+  \/\/       (This may have to change if this code changes!)\n+  assert(array_klass->is_klass(), \"not a class\");\n+  Handle holder(THREAD, array_klass->klass_holder()); \/\/ keep the klass alive\n+  Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();\n+  assert(elem_klass->is_inline_klass(), \"must be\");\n+  \/\/ Logically creates elements, ensure klass init\n+  elem_klass->initialize(CHECK);\n+  arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);\n+  current->set_vm_result(obj);\n+  \/\/ This is pretty rare but this runtime patch is stressful to deoptimization\n+  \/\/ if we deoptimize here so force a deopt to stress the path.\n+  if (DeoptimizeALot) {\n+    deopt_caller(current);\n+  }\n+JRT_END\n+\n+\n@@ -429,0 +471,81 @@\n+static void profile_flat_array(JavaThread* current) {\n+  ResourceMark rm(current);\n+  vframeStream vfst(current, true);\n+  assert(!vfst.at_end(), \"Java frame must exist\");\n+  \/\/ Check if array access profiling is enabled\n+  if (vfst.nm()->comp_level() != CompLevel_full_profile || !C1UpdateMethodData) {\n+    return;\n+  }\n+  int bci = vfst.bci();\n+  Method* method = vfst.method();\n+  MethodData* md = method->method_data();\n+  if (md != NULL) {\n+    ProfileData* data = md->bci_to_data(bci);\n+    assert(data != NULL && data->is_ArrayLoadStoreData(), \"incorrect profiling entry\");\n+    ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;\n+    load_store->set_flat_array();\n+  }\n+}\n+\n+JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index))\n+  assert(array->klass()->is_flatArray_klass(), \"should not be called\");\n+  profile_flat_array(current);\n+\n+  NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)\n+  assert(array->length() > 0 && index < array->length(), \"already checked\");\n+  flatArrayHandle vah(current, array);\n+  oop obj = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);\n+  current->set_vm_result(obj);\n+JRT_END\n+\n+\n+JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value))\n+  if (array->klass()->is_flatArray_klass()) {\n+    profile_flat_array(current);\n+  }\n+\n+  NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)\n+  if (value == NULL) {\n+    assert(array->klass()->is_flatArray_klass() || array->klass()->is_null_free_array_klass(), \"should not be called\");\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException());\n+  } else {\n+    assert(array->klass()->is_flatArray_klass(), \"should not be called\");\n+    array->value_copy_to_index(value, index);\n+  }\n+JRT_END\n+\n+\n+JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* current, oopDesc* left, oopDesc* right))\n+  NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)\n+  JavaCallArguments args;\n+  args.push_oop(Handle(THREAD, left));\n+  args.push_oop(Handle(THREAD, right));\n+  JavaValue result(T_BOOLEAN);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::PrimitiveObjectMethods_klass(),\n+                         vmSymbols::isSubstitutable_name(),\n+                         vmSymbols::object_object_boolean_signature(),\n+                         &args, CHECK_0);\n+  return result.get_jboolean() ? 1 : 0;\n+JRT_END\n+\n+\n+extern \"C\" void ps();\n+\n+void Runtime1::buffer_inline_args_impl(JavaThread* current, Method* m, bool allocate_receiver) {\n+  JavaThread* THREAD = current;\n+  methodHandle method(current, m); \/\/ We are inside the verified_entry or verified_inline_ro_entry of this method.\n+  oop obj = SharedRuntime::allocate_inline_types_impl(current, method, allocate_receiver, CHECK);\n+  current->set_vm_result(obj);\n+}\n+\n+JRT_ENTRY(void, Runtime1::buffer_inline_args(JavaThread* current, Method* method))\n+  NOT_PRODUCT(_buffer_inline_args_slowcase_cnt++;)\n+  buffer_inline_args_impl(current, method, true);\n+JRT_END\n+\n+JRT_ENTRY(void, Runtime1::buffer_inline_args_no_receiver(JavaThread* current, Method* method))\n+  NOT_PRODUCT(_buffer_inline_args_no_receiver_slowcase_cnt++;)\n+  buffer_inline_args_impl(current, method, false);\n+JRT_END\n+\n@@ -752,0 +875,6 @@\n+JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* current))\n+  NOT_PRODUCT(_throw_illegal_monitor_state_exception_count++;)\n+  ResourceMark rm(current);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IllegalMonitorStateException());\n+JRT_END\n+\n@@ -972,0 +1101,1 @@\n+    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n@@ -1014,0 +1144,5 @@\n+      case Bytecodes::_aconst_init:\n+        { Bytecode_aconst_init baconst_init(caller_method(), caller_method->bcp_from(bci));\n+          k = caller_method->constants()->klass_at(baconst_init.index(), CHECK);\n+        }\n+        break;\n@@ -1017,0 +1152,4 @@\n+          if (k->name()->is_Q_array_signature()) {\n+            \/\/ Logically creates elements, ensure klass init\n+            k->initialize(CHECK);\n+          }\n@@ -1495,0 +1634,1 @@\n+  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %d\", _new_flat_array_slowcase_cnt);\n@@ -1497,0 +1637,6 @@\n+  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %d\", _load_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %d\", _store_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _substitutability_check_slowcase_cnt: %d\", _substitutability_check_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%d\", _buffer_inline_args_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%d\", _buffer_inline_args_no_receiver_slowcase_cnt);\n+\n@@ -1507,0 +1653,1 @@\n+  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %d:\", _throw_illegal_monitor_state_exception_count);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":151,"deletions":4,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -320,1 +320,4 @@\n-          \"print control flow graph to a separate file during compilation\")\n+          \"print control flow graph to a separate file during compilation\") \\\n+                                                                            \\\n+  develop(bool, C1UseDelayedFlattenedFieldReads, true,                      \\\n+          \"Use delayed reads of flattened field to reduce buffering\")\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -425,1 +425,0 @@\n-    assert(type == _method_entry_ref, \"only special type allowed for now\");\n@@ -428,1 +427,1 @@\n-    _builder->add_special_ref(type, src_obj, field_offset);\n+    _builder->add_special_ref(type, src_obj, field_offset, ref->size() * BytesPerWord);\n@@ -472,4 +471,0 @@\n-void ArchiveBuilder::add_special_ref(MetaspaceClosure::SpecialRef type, address src_obj, size_t field_offset) {\n-  _special_refs->append(SpecialRefInfo(type, src_obj, field_offset));\n-}\n-\n@@ -667,2 +662,18 @@\n-    assert(s.type() == MetaspaceClosure::_method_entry_ref, \"only special type allowed for now\");\n-    assert(*src_p == *dst_p, \"must be a copy\");\n+\n+    MetaspaceClosure::assert_valid(s.type());\n+    switch (s.type()) {\n+    case MetaspaceClosure::_method_entry_ref:\n+      assert(*src_p == *dst_p, \"must be a copy\");\n+      break;\n+    case MetaspaceClosure::_internal_pointer_ref:\n+      {\n+        \/\/ *src_p points to a location inside src_obj. Let's make *dst_p point to\n+        \/\/ the same location inside dst_obj.\n+        size_t off = pointer_delta(*((address*)src_p), src_obj, sizeof(u1));\n+        assert(off < s.src_obj_size_in_bytes(), \"must point to internal address\");\n+        *((address*)dst_p) = dst_obj + off;\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -55,0 +57,1 @@\n+\/\/ NOTE: this table must be in-sync with sun.jvm.hotspot.memory.FileMapInfo::populateMetadataTypeArray().\n@@ -64,1 +67,3 @@\n-  f(TypeArrayKlass)\n+  f(TypeArrayKlass) \\\n+  f(FlatArrayKlass) \\\n+  f(InlineKlass)\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -133,0 +133,65 @@\n+inline void CDSMustMatchFlags::do_print(outputStream* st, bool v) {\n+  st->print(\"%s\", v ? \"true\" : \"false\");\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, intx v) {\n+  st->print(INTX_FORMAT, v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, uintx v) {\n+  st->print(UINTX_FORMAT, v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, double v) {\n+  st->print(\"%f\", v);\n+}\n+\n+void CDSMustMatchFlags::init() {\n+  Arguments::assert_is_dumping_archive();\n+  _max_name_width = 0;\n+\n+#define INIT_CDS_MUST_MATCH_FLAG(n) \\\n+  _v_##n = n; \\\n+  _max_name_width = MAX2(_max_name_width,strlen(#n));\n+  CDS_MUST_MATCH_FLAGS_DO(INIT_CDS_MUST_MATCH_FLAG);\n+#undef INIT_CDS_MUST_MATCH_FLAG\n+}\n+\n+bool CDSMustMatchFlags::runtime_check() const {\n+#define CHECK_CDS_MUST_MATCH_FLAG(n) \\\n+  if (_v_##n != n) { \\\n+    ResourceMark rm; \\\n+    stringStream ss; \\\n+    ss.print(\"VM option %s is different between dumptime (\", #n);  \\\n+    do_print(&ss, _v_ ## n); \\\n+    ss.print(\") and runtime (\"); \\\n+    do_print(&ss, n); \\\n+    ss.print(\")\"); \\\n+    FileMapInfo::fail_continue(\"%s\", ss.as_string()); \\\n+    return false; \\\n+  }\n+  CDS_MUST_MATCH_FLAGS_DO(CHECK_CDS_MUST_MATCH_FLAG);\n+#undef CHECK_CDS_MUST_MATCH_FLAG\n+\n+  return true;\n+}\n+\n+void CDSMustMatchFlags::print_info() const {\n+  LogTarget(Info, cds) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Recorded VM flags during dumptime:\");\n+    print(&ls);\n+  }\n+}\n+\n+void CDSMustMatchFlags::print(outputStream* st) const {\n+#define PRINT_CDS_MUST_MATCH_FLAG(n) \\\n+  st->print(\"- %-s \", #n);                   \\\n+  st->sp(int(_max_name_width - strlen(#n))); \\\n+  do_print(st, _v_##n);                      \\\n+  st->cr();\n+  CDS_MUST_MATCH_FLAGS_DO(PRINT_CDS_MUST_MATCH_FLAG);\n+#undef PRINT_CDS_MUST_MATCH_FLAG\n+}\n+\n@@ -290,0 +355,1 @@\n+  _must_match.init();\n@@ -351,0 +417,1 @@\n+  _must_match.print(st);\n@@ -1387,0 +1454,4 @@\n+  if (!header()->check_must_match_flags()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -332,3 +332,4 @@\n-    int hash_original = obj->identity_hash();\n-    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original));\n-    assert(archived_oop->mark().is_unlocked(), \"sanity\");\n+    if (!(EnableValhalla && obj->mark().is_inline_type())) {\n+      int hash_original = obj->identity_hash();\n+      archived_oop->set_mark(archived_oop->klass()->prototype_header().copy_set_hash(hash_original));\n+      assert(archived_oop->mark().is_unlocked(), \"sanity\");\n@@ -336,2 +337,3 @@\n-    DEBUG_ONLY(int hash_archived = archived_oop->identity_hash());\n-    assert(hash_original == hash_archived, \"Different hash codes: original %x, archived %x\", hash_original, hash_archived);\n+      DEBUG_ONLY(int hash_archived = archived_oop->identity_hash());\n+      assert(hash_original == hash_archived, \"Different hash codes: original %x, archived %x\", hash_original, hash_archived);\n+    }\n@@ -573,1 +575,1 @@\n-    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::set_mark(mem, k->prototype_header());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+class    ciWrapper;\n@@ -65,0 +66,1 @@\n+class       ciInlineKlass;\n@@ -66,0 +68,1 @@\n+class       ciFlatArrayKlass;\n@@ -115,0 +118,1 @@\n+friend class  ciWrapper;               \\\n@@ -117,0 +121,1 @@\n+friend class ciInlineKlass;            \\\n@@ -118,0 +123,1 @@\n+friend class ciFlatArrayKlass;         \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -543,1 +544,3 @@\n-      (sym->char_at(1) == JVM_SIGNATURE_ARRAY || sym->char_at(1) == JVM_SIGNATURE_CLASS)) {\n+      (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||\n+       sym->char_at(1) == JVM_SIGNATURE_CLASS ||\n+       sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT )) {\n@@ -556,1 +559,2 @@\n-      return ciObjArrayKlass::make_impl(elem_klass);\n+      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+      return ciArrayKlass::make(elem_klass, null_free_array);\n@@ -582,0 +586,15 @@\n+  int i = 0;\n+  while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {\n+    i++;\n+  }\n+  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+    \/\/ An unloaded array class of inline types is an ObjArrayKlass, an\n+    \/\/ unloaded inline type class is an InstanceKlass. For consistency,\n+    \/\/ make the signature of the unloaded array of inline type use L\n+    \/\/ rather than Q.\n+    char* new_name = name_buffer(sym->utf8_length()+1);\n+    strncpy(new_name, (char*)sym->base(), sym->utf8_length());\n+    new_name[i] = JVM_SIGNATURE_CLASS;\n+    new_name[sym->utf8_length()] = '\\0';\n+    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));\n+  }\n@@ -670,0 +689,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::is_inline_klass\n+\/\/\n+\/\/ Check if the klass is an inline klass.\n+bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n+  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)\n+}\n+\n@@ -766,1 +793,5 @@\n-    return ciConstant(T_OBJECT, mirror);\n+    if (klass->is_loaded() && tag.is_Qdescriptor_klass()) {\n+      return ciConstant(T_OBJECT, klass->as_inline_klass()->val_mirror());\n+    } else {\n+      return ciConstant(T_OBJECT, mirror);\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+  bool       has_Q_signature(const constantPoolHandle& cpool,\n+                             int klass_index);\n@@ -215,0 +217,4 @@\n+  ciFlatArrayKlass* get_flat_array_klass(Klass* o) {\n+    if (o == NULL) return NULL;\n+    return get_metadata(o)->as_flat_array_klass();\n+  }\n@@ -512,0 +518,4 @@\n+  ciWrapper* make_null_free_wrapper(ciType* type) {\n+    return _factory->make_null_free_wrapper(type);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+  _original_holder(NULL), _is_flattened(false), _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n@@ -108,0 +108,3 @@\n+  \/\/ this is needed if the field class is not yet loaded.\n+  _is_null_free = _signature->is_Q_signature();\n+\n@@ -219,0 +222,25 @@\n+\/\/ Special copy constructor used to flatten inline type fields by\n+\/\/ copying the fields of the inline type to a new holder klass.\n+ciField::ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) {\n+  assert(field->holder()->is_inlinetype(), \"should only be used for inline type field flattening\");\n+  \/\/ Set the is_final flag\n+  jint final = is_final ? JVM_ACC_FINAL : ~JVM_ACC_FINAL;\n+  AccessFlags flags(field->flags().as_int() & final);\n+  _flags = ciFlags(flags);\n+  _holder = holder;\n+  _offset = offset;\n+  \/\/ Copy remaining fields\n+  _name = field->_name;\n+  _signature = field->_signature;\n+  _type = field->_type;\n+  \/\/ Trust final flattened fields\n+  _is_constant = is_final;\n+  _known_to_link_with_put = field->_known_to_link_with_put;\n+  _known_to_link_with_get = field->_known_to_link_with_get;\n+  _constant_value = field->_constant_value;\n+  assert(!field->is_flattened(), \"field must not be flattened\");\n+  _is_flattened = false;\n+  _is_null_free = field->_is_null_free;\n+  _original_holder = (field->_original_holder != NULL) ? field->_original_holder : field->_holder;\n+}\n+\n@@ -236,0 +264,3 @@\n+  \/\/ Trust final fields in inline type buffers\n+  if (holder->is_inlinetype())\n+    return true;\n@@ -263,0 +294,3 @@\n+  _is_flattened = fd->is_inlined();\n+  _is_null_free = fd->signature()->is_Q_signature();\n+  _original_holder = NULL;\n@@ -346,1 +380,3 @@\n-  ciKlass* type = CURRENT_ENV->get_klass_by_name_impl(_holder, constantPoolHandle(), _signature, false);\n+  \/\/ Use original holder for fields that came in through flattening\n+  ciKlass* accessing_klass = (_original_holder != NULL) ? _original_holder : _holder;\n+  ciKlass* type = CURRENT_ENV->get_klass_by_name_impl(accessing_klass, constantPoolHandle(), _signature, false);\n@@ -375,2 +411,2 @@\n-         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield,\n-         \"unexpected bytecode\");\n+         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield  ||\n+         bc == Bytecodes::_withfield, \"unexpected bytecode\");\n@@ -459,0 +495,2 @@\n+  tty->print(\" is_flattened=%s\", bool_to_str(_is_flattened));\n+  tty->print(\" is_null_free=%s\", bool_to_str(_is_null_free));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -121,2 +124,3 @@\n-                                 jobject loader, jobject protection_domain)\n-  : ciKlass(name, T_OBJECT)\n+                                 jobject loader, jobject protection_domain,\n+                                 BasicType bt)\n+  : ciKlass(name, bt)\n@@ -127,1 +131,1 @@\n-  _nonstatic_fields = NULL;\n+  _nonstatic_fields = NULL;            \/\/ initialized lazily by compute_nonstatic_fields\n@@ -339,1 +343,1 @@\n-    _flags.print_klass_flags();\n+    _flags.print_klass_flags(st);\n@@ -343,1 +347,1 @@\n-      _super->print_name();\n+      _super->print_name_on(st);\n@@ -439,0 +443,23 @@\n+ciField* ciInstanceKlass::get_non_flattened_field_by_offset(int field_offset) {\n+  if (super() != NULL && super()->has_nonstatic_fields()) {\n+    ciField* f = super()->get_non_flattened_field_by_offset(field_offset);\n+    if (f != NULL) {\n+      return f;\n+    }\n+  }\n+\n+  VM_ENTRY_MARK;\n+  InstanceKlass* k = get_instanceKlass();\n+  Arena* arena = CURRENT_ENV->arena();\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static())  continue;\n+    fieldDescriptor& fd = fs.field_descriptor();\n+    if (fd.offset() == field_offset) {\n+      ciField* f = new (arena) ciField(&fd);\n+      return f;\n+    }\n+  }\n+\n+  return NULL;\n+}\n+\n@@ -497,6 +524,1 @@\n-  int flen = fields->length();\n-\n-  \/\/ Now sort them by offset, ascending.\n-  \/\/ (In principle, they could mix with superclass fields.)\n-  fields->sort(sort_field_by_offset);\n-  return flen;\n+  return fields->length();\n@@ -506,3 +528,1 @@\n-GrowableArray<ciField*>*\n-ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>*\n-                                               super_fields) {\n+GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool flatten) {\n@@ -526,0 +546,1 @@\n+\n@@ -534,2 +555,22 @@\n-    ciField* field = new (arena) ciField(&fd);\n-    fields->append(field);\n+    if (fd.is_inlined() && flatten) {\n+      \/\/ Inline type fields are embedded\n+      int field_offset = fd.offset();\n+      \/\/ Get InlineKlass and adjust number of fields\n+      Klass* k = get_instanceKlass()->get_inline_type_field_klass(fd.index());\n+      ciInlineKlass* vk = CURRENT_ENV->get_klass(k)->as_inline_klass();\n+      flen += vk->nof_nonstatic_fields() - 1;\n+      \/\/ Iterate over fields of the flattened inline type and copy them to 'this'\n+      for (int i = 0; i < vk->nof_nonstatic_fields(); ++i) {\n+        ciField* flattened_field = vk->nonstatic_field_at(i);\n+        \/\/ Adjust offset to account for missing oop header\n+        int offset = field_offset + (flattened_field->offset() - vk->first_field_offset());\n+        \/\/ A flattened field can be treated as final if the non-flattened\n+        \/\/ field is declared final or the holder klass is an inline type itself.\n+        bool is_final = fd.is_final() || is_inlinetype();\n+        ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        fields->append(field);\n+      }\n+    } else {\n+      ciField* field = new (arena) ciField(&fd);\n+      fields->append(field);\n+    }\n@@ -538,0 +579,3 @@\n+  \/\/ Now sort them by offset, ascending.\n+  \/\/ (In principle, they could mix with superclass fields.)\n+  fields->sort(sort_field_by_offset);\n@@ -644,0 +688,16 @@\n+bool ciInstanceKlass::can_be_inline_klass(bool is_exact) {\n+  if (!EnableValhalla) {\n+    return false;\n+  }\n+  if (!is_loaded() || is_inlinetype()) {\n+    \/\/ Not loaded or known to be an inline klass\n+    return true;\n+  }\n+  if (!is_exact) {\n+    \/\/ Not exact, check if this is a valid super for an inline klass\n+    VM_ENTRY_MARK;\n+    return !get_instanceKlass()->carries_identity_modifier();\n+  }\n+  return false;\n+}\n+\n@@ -652,1 +712,2 @@\n-class StaticFinalFieldPrinter : public FieldClosure {\n+class StaticFieldPrinter : public FieldClosure {\n+protected:\n@@ -654,0 +715,8 @@\n+public:\n+  StaticFieldPrinter(outputStream* out) :\n+    _out(out) {\n+  }\n+  void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);\n+};\n+\n+class StaticFinalFieldPrinter : public StaticFieldPrinter {\n@@ -657,2 +726,1 @@\n-    _out(out),\n-    _holder(holder) {\n+    StaticFieldPrinter(out), _holder(holder) {\n@@ -663,46 +731,58 @@\n-      oop mirror = fd->field_holder()->java_mirror();\n-      _out->print(\"staticfield %s %s %s \", _holder, fd->name()->as_quoted_ascii(), fd->signature()->as_quoted_ascii());\n-      switch (fd->field_type()) {\n-        case T_BYTE:    _out->print_cr(\"%d\", mirror->byte_field(fd->offset()));   break;\n-        case T_BOOLEAN: _out->print_cr(\"%d\", mirror->bool_field(fd->offset()));   break;\n-        case T_SHORT:   _out->print_cr(\"%d\", mirror->short_field(fd->offset()));  break;\n-        case T_CHAR:    _out->print_cr(\"%d\", mirror->char_field(fd->offset()));   break;\n-        case T_INT:     _out->print_cr(\"%d\", mirror->int_field(fd->offset()));    break;\n-        case T_LONG:    _out->print_cr(INT64_FORMAT, (int64_t)(mirror->long_field(fd->offset())));   break;\n-        case T_FLOAT: {\n-          float f = mirror->float_field(fd->offset());\n-          _out->print_cr(\"%d\", *(int*)&f);\n-          break;\n-        }\n-        case T_DOUBLE: {\n-          double d = mirror->double_field(fd->offset());\n-          _out->print_cr(INT64_FORMAT, *(int64_t*)&d);\n-          break;\n-        }\n-        case T_ARRAY:  \/\/ fall-through\n-        case T_OBJECT: {\n-          oop value =  mirror->obj_field_acquire(fd->offset());\n-          if (value == NULL) {\n-            _out->print_cr(\"null\");\n-          } else if (value->is_instance()) {\n-            assert(fd->field_type() == T_OBJECT, \"\");\n-            if (value->is_a(vmClasses::String_klass())) {\n-              const char* ascii_value = java_lang_String::as_quoted_ascii(value);\n-              _out->print_cr(\"\\\"%s\\\"\", (ascii_value != NULL) ? ascii_value : \"\");\n-            } else {\n-              const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n-              _out->print_cr(\"%s\", klass_name);\n-            }\n-          } else if (value->is_array()) {\n-            typeArrayOop ta = (typeArrayOop)value;\n-            _out->print(\"%d\", ta->length());\n-            if (value->is_objArray()) {\n-              objArrayOop oa = (objArrayOop)value;\n-              const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n-              _out->print(\" %s\", klass_name);\n-            }\n-            _out->cr();\n-          } else {\n-            ShouldNotReachHere();\n-          }\n-          break;\n+      InstanceKlass* holder = fd->field_holder();\n+      oop mirror = holder->java_mirror();\n+      _out->print(\"staticfield %s %s \", _holder, fd->name()->as_quoted_ascii());\n+      BasicType bt = fd->field_type();\n+      if (bt != T_OBJECT && bt != T_ARRAY) {\n+        _out->print(\"%s \", fd->signature()->as_quoted_ascii());\n+      }\n+      do_field_helper(fd, mirror, false);\n+      _out->cr();\n+    }\n+  }\n+};\n+\n+class InlineTypeFieldPrinter : public StaticFieldPrinter {\n+  oop _obj;\n+public:\n+  InlineTypeFieldPrinter(outputStream* out, oop obj) :\n+    StaticFieldPrinter(out), _obj(obj) {\n+  }\n+  void do_field(fieldDescriptor* fd) {\n+    do_field_helper(fd, _obj, true);\n+    _out->print(\" \");\n+  }\n+};\n+\n+void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool flattened) {\n+  BasicType bt = fd->field_type();\n+  switch (bt) {\n+    case T_BYTE:    _out->print(\"%d\", mirror->byte_field(fd->offset()));   break;\n+    case T_BOOLEAN: _out->print(\"%d\", mirror->bool_field(fd->offset()));   break;\n+    case T_SHORT:   _out->print(\"%d\", mirror->short_field(fd->offset()));  break;\n+    case T_CHAR:    _out->print(\"%d\", mirror->char_field(fd->offset()));   break;\n+    case T_INT:     _out->print(\"%d\", mirror->int_field(fd->offset()));    break;\n+    case T_LONG:    _out->print(INT64_FORMAT, (int64_t)(mirror->long_field(fd->offset())));   break;\n+    case T_FLOAT: {\n+      float f = mirror->float_field(fd->offset());\n+      _out->print(\"%d\", *(int*)&f);\n+      break;\n+    }\n+    case T_DOUBLE: {\n+      double d = mirror->double_field(fd->offset());\n+      _out->print(INT64_FORMAT, *(int64_t*)&d);\n+      break;\n+    }\n+    case T_ARRAY:  \/\/ fall-through\n+    case T_OBJECT: {\n+      _out->print(\"%s \", fd->signature()->as_quoted_ascii());\n+      oop value =  mirror->obj_field_acquire(fd->offset());\n+      if (value == NULL) {\n+        _out->print_cr(\"null\");\n+      } else if (value->is_instance()) {\n+        assert(fd->field_type() == T_OBJECT, \"\");\n+        if (value->is_a(vmClasses::String_klass())) {\n+          const char* ascii_value = java_lang_String::as_quoted_ascii(value);\n+          _out->print(\"\\\"%s\\\"\", (ascii_value != NULL) ? ascii_value : \"\");\n+         } else {\n+          const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n+          _out->print(\"%s\", klass_name);\n@@ -710,2 +790,7 @@\n-        default:\n-          ShouldNotReachHere();\n+      } else if (value->is_array()) {\n+        typeArrayOop ta = (typeArrayOop)value;\n+        _out->print(\"%d\", ta->length());\n+        if (value->is_objArray() || value->is_flatArray()) {\n+          objArrayOop oa = (objArrayOop)value;\n+          const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n+          _out->print(\" %s\", klass_name);\n@@ -713,0 +798,4 @@\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+      break;\n@@ -714,0 +803,25 @@\n+    case T_PRIMITIVE_OBJECT: {\n+      ResetNoHandleMark rnhm;\n+      Thread* THREAD = Thread::current();\n+      SignatureStream ss(fd->signature(), false);\n+      Symbol* name = ss.as_symbol();\n+      assert(!HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+      InstanceKlass* holder = fd->field_holder();\n+      InstanceKlass* k = SystemDictionary::find_instance_klass(name,\n+                                                               Handle(THREAD, holder->class_loader()),\n+                                                               Handle(THREAD, holder->protection_domain()));\n+      assert(k != NULL && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+      InlineKlass* vk = InlineKlass::cast(k);\n+      oop obj;\n+      if (flattened) {\n+        int field_offset = fd->offset() - vk->first_field_offset();\n+        obj = cast_to_oop(cast_from_oop<address>(mirror) + field_offset);\n+      } else {\n+        obj = mirror->obj_field_acquire(fd->offset());\n+      }\n+      InlineTypeFieldPrinter print_field(_out, obj);\n+      vk->do_nonstatic_fields(&print_field);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n@@ -715,1 +829,1 @@\n-};\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":182,"deletions":68,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+\n@@ -85,1 +86,1 @@\n-  ciInstanceKlass(ciSymbol* name, jobject loader, jobject protection_domain);\n+  ciInstanceKlass(ciSymbol* name, jobject loader, jobject protection_domain, BasicType bt = T_OBJECT); \/\/ for unloaded klasses\n@@ -109,2 +110,2 @@\n-  int  compute_nonstatic_fields();\n-  GrowableArray<ciField*>* compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields);\n+  virtual int compute_nonstatic_fields();\n+  GrowableArray<ciField*>* compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool flatten = true);\n@@ -208,0 +209,2 @@\n+  \/\/ get field descriptor at field_offset ignoring flattening\n+  ciField* get_non_flattened_field_by_offset(int field_offset);\n@@ -211,1 +214,1 @@\n-    if (_nonstatic_fields == NULL)\n+    if (_nonstatic_fields == NULL) {\n@@ -213,1 +216,1 @@\n-    else\n+    } else {\n@@ -215,0 +218,1 @@\n+    }\n@@ -245,1 +249,0 @@\n-  bool is_super       () { return flags().is_super(); }\n@@ -262,0 +265,2 @@\n+  virtual bool can_be_inline_klass(bool is_exact = false);\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -662,0 +663,33 @@\n+bool ciMethod::array_access_profiled_type(int bci, ciKlass*& array_type, ciKlass*& element_type, ProfilePtrKind& element_ptr, bool &flat_array, bool &null_free_array) {\n+  if (method_data() != NULL && method_data()->is_mature()) {\n+    ciProfileData* data = method_data()->bci_to_data(bci);\n+    if (data != NULL && data->is_ArrayLoadStoreData()) {\n+      ciArrayLoadStoreData* array_access = (ciArrayLoadStoreData*)data->as_ArrayLoadStoreData();\n+      array_type = array_access->array()->valid_type();\n+      element_type = array_access->element()->valid_type();\n+      element_ptr = array_access->element()->ptr_kind();\n+      flat_array = array_access->flat_array();\n+      null_free_array = array_access->null_free_array();\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool ciMethod::acmp_profiled_type(int bci, ciKlass*& left_type, ciKlass*& right_type, ProfilePtrKind& left_ptr, ProfilePtrKind& right_ptr, bool &left_inline_type, bool &right_inline_type) {\n+  if (method_data() != NULL && method_data()->is_mature()) {\n+    ciProfileData* data = method_data()->bci_to_data(bci);\n+    if (data != NULL && data->is_ACmpData()) {\n+      ciACmpData* acmp = (ciACmpData*)data->as_ACmpData();\n+      left_type = acmp->left()->valid_type();\n+      right_type = acmp->right()->valid_type();\n+      left_ptr = acmp->left()->ptr_kind();\n+      right_ptr = acmp->right()->ptr_kind();\n+      left_inline_type = acmp->left_inline_type();\n+      right_inline_type = acmp->right_inline_type();\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -960,1 +994,1 @@\n-\/\/ ciMethod::is_object_initializer\n+\/\/ ciMethod::is_object_constructor\n@@ -962,2 +996,15 @@\n-bool ciMethod::is_object_initializer() const {\n-   return name() == ciSymbols::object_initializer_name();\n+bool ciMethod::is_object_constructor() const {\n+   return (name() == ciSymbols::object_initializer_name()\n+           && signature()->return_type()->is_void());\n+   \/\/ Note:  We can't test is_static, because that would\n+   \/\/ require the method to be loaded.  Sometimes it isn't.\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::is_static_init_factory\n+\/\/\n+bool ciMethod::is_static_init_factory() const {\n+   return (name() == ciSymbols::object_initializer_name()\n+           && !signature()->return_type()->is_void());\n+   \/\/ Note:  We can't test is_static, because that would\n+   \/\/ require the method to be loaded.  Sometimes it isn't.\n@@ -1242,1 +1289,1 @@\n-bool ciMethod::is_initializer () const {         FETCH_FLAG_FROM_VM(is_initializer); }\n+bool ciMethod::is_object_constructor_or_class_initializer() const { FETCH_FLAG_FROM_VM(is_object_constructor_or_class_initializer); }\n@@ -1402,0 +1449,1 @@\n+  if (bt == T_PRIMITIVE_OBJECT)   return T_OBJECT;\n@@ -1489,0 +1537,18 @@\n+\n+bool ciMethod::is_scalarized_arg(int idx) const {\n+  VM_ENTRY_MARK;\n+  return get_Method()->is_scalarized_arg(idx);\n+}\n+\n+bool ciMethod::has_scalarized_args() const {\n+  VM_ENTRY_MARK;\n+  return get_Method()->has_scalarized_args();\n+}\n+\n+const GrowableArray<SigEntry>* ciMethod::get_sig_cc() const {\n+  VM_ENTRY_MARK;\n+  if (get_Method()->adapter() == NULL) {\n+    return NULL;\n+  }\n+  return get_Method()->adapter()->get_sig_cc();\n+}\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":70,"deletions":4,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  ProfileUnknownNull,\n@@ -206,1 +207,1 @@\n-  bool is_static_initializer()  const { return get_Method()->is_static_initializer();  }\n+  bool is_class_initializer()   const { return get_Method()->is_class_initializer();   }\n@@ -276,1 +277,4 @@\n-\n+  bool          array_access_profiled_type(int bci, ciKlass*& array_type, ciKlass*& element_type, ProfilePtrKind& element_ptr, bool &flat_array, bool &null_free);\n+  bool          acmp_profiled_type(int bci, ciKlass*& left_type, ciKlass*& right_type,\n+                                   ProfilePtrKind& left_ptr, ProfilePtrKind& right_ptr,\n+                                   bool &left_inline_type, bool &right_inline_type);\n@@ -347,0 +351,1 @@\n+  bool has_vararg     () const                   { return flags().has_vararg(); }\n@@ -358,1 +363,0 @@\n-  bool is_initializer () const;\n@@ -364,0 +368,3 @@\n+  bool is_object_constructor() const;\n+  bool is_static_init_factory() const;\n+  bool is_object_constructor_or_class_initializer() const;\n@@ -365,1 +372,0 @@\n-  bool is_object_initializer() const;\n@@ -388,0 +394,5 @@\n+\n+  \/\/ Support for the inline type calling convention\n+  bool is_scalarized_arg(int idx) const;\n+  bool has_scalarized_args() const;\n+  const GrowableArray<SigEntry>* get_sig_cc() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-void ciReturnTypeEntry::translate_type_data_from(const ReturnTypeEntry* ret) {\n+void ciSingleTypeEntry::translate_type_data_from(const SingleTypeEntry* ret) {\n@@ -310,1 +310,1 @@\n-    set_type(ReturnTypeEntry::with_status((Klass*)NULL, k));\n+    set_type(SingleTypeEntry::with_status((Klass*)NULL, k));\n@@ -361,0 +361,4 @@\n+  case DataLayout::array_load_store_data_tag:\n+    return new ciArrayLoadStoreData(data_layout);\n+  case DataLayout::acmp_data_tag:\n+    return new ciACmpData(data_layout);\n@@ -752,0 +756,13 @@\n+      } else if (pdata->is_ArrayLoadStoreData()) {\n+        ciArrayLoadStoreData* array_load_store_data = (ciArrayLoadStoreData*)pdata;\n+        dump_replay_data_type_helper(out, round, count, array_load_store_data, ciArrayLoadStoreData::array_offset(),\n+                                     array_load_store_data->array()->valid_type());\n+        dump_replay_data_type_helper(out, round, count, array_load_store_data, ciArrayLoadStoreData::element_offset(),\n+                                     array_load_store_data->element()->valid_type());\n+      } else if (pdata->is_ACmpData()) {\n+        ciACmpData* acmp_data = (ciACmpData*)pdata;\n+        dump_replay_data_type_helper(out, round, count, acmp_data, ciACmpData::left_offset(),\n+                                     acmp_data->left()->valid_type());\n+        dump_replay_data_type_helper(out, round, count, acmp_data, ciACmpData::right_offset(),\n+                                     acmp_data->right()->valid_type());\n+\n@@ -834,1 +851,1 @@\n-void ciReturnTypeEntry::print_data_on(outputStream* st) const {\n+void ciSingleTypeEntry::print_data_on(outputStream* st) const {\n@@ -907,0 +924,21 @@\n+\n+void ciArrayLoadStoreData::print_data_on(outputStream* st, const char* extra) const {\n+  print_shared(st, \"ciArrayLoadStoreData\", extra);\n+  tab(st, true);\n+  st->print(\"array\");\n+  array()->print_data_on(st);\n+  tab(st, true);\n+  st->print(\"element\");\n+  element()->print_data_on(st);\n+}\n+\n+void ciACmpData::print_data_on(outputStream* st, const char* extra) const {\n+  BranchData::print_data_on(st, extra);\n+  st->cr();\n+  tab(st, true);\n+  st->print(\"left\");\n+  left()->print_data_on(st);\n+  tab(st, true);\n+  st->print(\"right\");\n+  right()->print_data_on(st);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-class ciReturnTypeEntry : public ReturnTypeEntry, ciTypeEntries {\n+class ciSingleTypeEntry : public SingleTypeEntry, ciTypeEntries {\n@@ -129,1 +129,1 @@\n-  void translate_type_data_from(const ReturnTypeEntry* ret);\n+  void translate_type_data_from(const SingleTypeEntry* ret);\n@@ -149,1 +149,1 @@\n-  ciReturnTypeEntry* ret() const { return (ciReturnTypeEntry*)CallTypeData::ret(); }\n+  ciSingleTypeEntry* ret() const { return (ciSingleTypeEntry*)CallTypeData::ret(); }\n@@ -261,1 +261,1 @@\n-  ciReturnTypeEntry* ret() const { return (ciReturnTypeEntry*)VirtualCallTypeData::ret(); }\n+  ciSingleTypeEntry* ret() const { return (ciSingleTypeEntry*)VirtualCallTypeData::ret(); }\n@@ -365,0 +365,34 @@\n+class ciArrayLoadStoreData : public ArrayLoadStoreData {\n+public:\n+  ciArrayLoadStoreData(DataLayout* layout) : ArrayLoadStoreData(layout) {}\n+\n+  ciSingleTypeEntry* array() const { return (ciSingleTypeEntry*)ArrayLoadStoreData::array(); }\n+  ciSingleTypeEntry* element() const { return (ciSingleTypeEntry*)ArrayLoadStoreData::element(); }\n+\n+  virtual void translate_from(const ProfileData* data) {\n+    array()->translate_type_data_from(data->as_ArrayLoadStoreData()->array());\n+    element()->translate_type_data_from(data->as_ArrayLoadStoreData()->element());\n+  }\n+\n+#ifndef PRODUCT\n+  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+#endif\n+};\n+\n+class ciACmpData : public ACmpData {\n+public:\n+  ciACmpData(DataLayout* layout) : ACmpData(layout) {}\n+\n+  ciSingleTypeEntry* left() const { return (ciSingleTypeEntry*)ACmpData::left(); }\n+  ciSingleTypeEntry* right() const { return (ciSingleTypeEntry*)ACmpData::right(); }\n+\n+  virtual void translate_from(const ProfileData* data) {\n+    left()->translate_type_data_from(data->as_ACmpData()->left());\n+    right()->translate_type_data_from(data->as_ACmpData()->right());\n+  }\n+\n+#ifndef PRODUCT\n+  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -56,0 +57,1 @@\n+  _null_free = k->name()->is_Q_array_signature() && k->name()->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n@@ -67,8 +69,10 @@\n-    _base_element_klass = base_element_klass;\n-    assert(_base_element_klass->is_instance_klass() ||\n-           _base_element_klass->is_type_array_klass(), \"bad base klass\");\n-    if (dimension == 1) {\n-      _element_klass = base_element_klass;\n-    } else {\n-      _element_klass = NULL;\n-    }\n+  _base_element_klass = base_element_klass;\n+  assert(_base_element_klass->is_instance_klass() ||\n+         _base_element_klass->is_type_array_klass() ||\n+         _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n+  if (dimension == 1) {\n+    _element_klass = base_element_klass;\n+  } else {\n+    _element_klass = NULL;\n+  }\n+  _null_free = array_name->is_Q_array_signature() && array_name->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n@@ -119,1 +123,1 @@\n-\n+  assert(base_name_sym->char_at(0) != JVM_SIGNATURE_PRIMITIVE_OBJECT, \"unloaded array klass element should not have Q-type\");\n@@ -138,1 +142,0 @@\n-\n@@ -151,2 +154,1 @@\n-  \/\/ The array klass was unable to be made or the element klass was\n-  \/\/ not loaded.\n+  \/\/ The array klass was unable to be made or the element klass was not loaded.\n@@ -179,0 +181,4 @@\n+  \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+  if (!is_elem_null_free() && (!is_loaded() || element_klass()->is_inlinetype())) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  bool     _null_free;\n@@ -79,0 +80,6 @@\n+\n+  virtual bool can_be_inline_array_klass() {\n+    return element_klass()->can_be_inline_klass();\n+  }\n+\n+  virtual bool is_elem_null_free() const { return _null_free; }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"ci\/ciFlatArray.hpp\"\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -44,0 +46,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -358,0 +361,3 @@\n+  } else if (o->is_flatArray()) {\n+    flatArrayHandle h_ta(THREAD, (flatArrayOop)o);\n+    return new (arena()) ciFlatArray(h_ta);\n@@ -377,1 +383,3 @@\n-    if (k->is_instance_klass()) {\n+    if (k->is_inline_klass()) {\n+      return new (arena()) ciInlineKlass(k);\n+    } else if (k->is_instance_klass()) {\n@@ -380,0 +388,2 @@\n+    } else if (k->is_flatArray_klass()) {\n+      return new (arena()) ciFlatArrayKlass(k);\n@@ -489,1 +499,1 @@\n-    if (element_type == T_OBJECT) {\n+    if (element_type == T_OBJECT || element_type == T_PRIMITIVE_OBJECT) {\n@@ -620,0 +630,6 @@\n+ciWrapper* ciObjectFactory::make_null_free_wrapper(ciType* type) {\n+  ciWrapper* wrapper = new (arena()) ciWrapper(type);\n+  init_ident_of(wrapper);\n+  return wrapper;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -988,0 +989,1 @@\n+\n@@ -1034,27 +1036,79 @@\n-  \/\/ staticfield <klass> <name> <signature> <value>\n-  \/\/\n-  \/\/ Initialize a class and fill in the value for a static field.\n-  \/\/ This is useful when the compile was dependent on the value of\n-  \/\/ static fields but it's impossible to properly rerun the static\n-  \/\/ initializer.\n-  void process_staticfield(TRAPS) {\n-    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n-\n-    if (k == NULL || ReplaySuppressInitializers == 0 ||\n-        (ReplaySuppressInitializers == 2 && k->class_loader() == NULL)) {\n-      skip_remaining();\n-      return;\n-    }\n-\n-    assert(k->is_initialized(), \"must be\");\n-\n-    const char* field_name = parse_escaped_string();\n-    const char* field_signature = parse_string();\n-    fieldDescriptor fd;\n-    Symbol* name = SymbolTable::new_symbol(field_name);\n-    Symbol* sig = SymbolTable::new_symbol(field_signature);\n-    if (!k->find_local_field(name, sig, &fd) ||\n-        !fd.is_static() ||\n-        fd.has_initial_value()) {\n-      report_error(field_name);\n-      return;\n+  class InlineTypeFieldInitializer : public FieldClosure {\n+    oop _vt;\n+    CompileReplay* _replay;\n+  public:\n+    InlineTypeFieldInitializer(oop vt, CompileReplay* replay)\n+  : _vt(vt), _replay(replay) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      BasicType bt = fd->field_type();\n+      const char* string_value = bt != T_PRIMITIVE_OBJECT ? _replay->parse_escaped_string() : NULL;\n+      switch (bt) {\n+      case T_BYTE: {\n+        int value = atoi(string_value);\n+        _vt->byte_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_BOOLEAN: {\n+        int value = atoi(string_value);\n+        _vt->bool_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_SHORT: {\n+        int value = atoi(string_value);\n+        _vt->short_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_CHAR: {\n+        int value = atoi(string_value);\n+        _vt->char_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_INT: {\n+        int value = atoi(string_value);\n+        _vt->int_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_LONG: {\n+        jlong value;\n+        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+          break;\n+        }\n+        _vt->long_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_FLOAT: {\n+        float value = atof(string_value);\n+        _vt->float_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        double value = atof(string_value);\n+        _vt->double_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_ARRAY:\n+      case T_OBJECT: {\n+        JavaThread* THREAD = JavaThread::current();\n+        bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n+        assert(res, \"should succeed for arrays & objects\");\n+        break;\n+      }\n+      case T_PRIMITIVE_OBJECT: {\n+        InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+        if (fd->is_inlined()) {\n+          int field_offset = fd->offset() - vk->first_field_offset();\n+          oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+          InlineTypeFieldInitializer init_fields(obj, _replay);\n+          vk->do_nonstatic_fields(&init_fields);\n+        } else {\n+          oop value = vk->allocate_instance(JavaThread::current());\n+          _vt->obj_field_put(fd->offset(), value);\n+        }\n+        break;\n+      }\n+      default: {\n+        fatal(\"Unhandled type: %s\", type2name(bt));\n+      }\n+      }\n@@ -1062,0 +1116,1 @@\n+  };\n@@ -1063,1 +1118,1 @@\n-    oop java_mirror = k->java_mirror();\n+  bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {\n@@ -1070,4 +1125,2 @@\n-        ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);\n-        if (kelem == NULL) {\n-          return;\n-        }\n+        Klass* k = resolve_klass(field_signature, CHECK_(true));\n+        ArrayKlass* kelem = (ArrayKlass *)k;\n@@ -1083,1 +1136,1 @@\n-        value = kelem->multi_allocate(rank, dims, CHECK);\n+        value = kelem->multi_allocate(rank, dims, CHECK_(true));\n@@ -1086,1 +1139,1 @@\n-          value = oopFactory::new_byteArray(length, CHECK);\n+          value = oopFactory::new_byteArray(length, CHECK_(true));\n@@ -1088,1 +1141,1 @@\n-          value = oopFactory::new_boolArray(length, CHECK);\n+          value = oopFactory::new_boolArray(length, CHECK_(true));\n@@ -1090,1 +1143,1 @@\n-          value = oopFactory::new_charArray(length, CHECK);\n+          value = oopFactory::new_charArray(length, CHECK_(true));\n@@ -1092,1 +1145,1 @@\n-          value = oopFactory::new_shortArray(length, CHECK);\n+          value = oopFactory::new_shortArray(length, CHECK_(true));\n@@ -1094,1 +1147,1 @@\n-          value = oopFactory::new_floatArray(length, CHECK);\n+          value = oopFactory::new_floatArray(length, CHECK_(true));\n@@ -1096,1 +1149,1 @@\n-          value = oopFactory::new_doubleArray(length, CHECK);\n+          value = oopFactory::new_doubleArray(length, CHECK_(true));\n@@ -1098,1 +1151,1 @@\n-          value = oopFactory::new_intArray(length, CHECK);\n+          value = oopFactory::new_intArray(length, CHECK_(true));\n@@ -1100,1 +1153,1 @@\n-          value = oopFactory::new_longArray(length, CHECK);\n+          value = oopFactory::new_longArray(length, CHECK_(true));\n@@ -1103,2 +1156,6 @@\n-          Klass* kelem = resolve_klass(field_signature + 1, CHECK);\n-          value = oopFactory::new_objArray(kelem, length, CHECK);\n+          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n+          value = oopFactory::new_objArray(kelem, length, CHECK_(true));\n+        } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&\n+                   field_signature[1] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n+          value = oopFactory::new_valueArray(kelem, length, CHECK_(true));\n@@ -1109,0 +1166,87 @@\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value());\n+      return true;\n+    } else if (field_signature[0] == 'L') {\n+      const char* instance = parse_escaped_string();\n+      Klass* k = resolve_klass(instance, CHECK_(true));\n+      oop value = InstanceKlass::cast(k)->allocate_instance(CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Initialize a class and fill in the value for a static field.\n+  \/\/ This is useful when the compile was dependent on the value of\n+  \/\/ static fields but it's impossible to properly rerun the static\n+  \/\/ initializer.\n+  void process_staticfield(TRAPS) {\n+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n+\n+    if (k == NULL || ReplaySuppressInitializers == 0 ||\n+        (ReplaySuppressInitializers == 2 && k->class_loader() == NULL)) {\n+        skip_remaining();\n+      return;\n+    }\n+\n+    assert(k->is_initialized(), \"must be\");\n+\n+    const char* field_name = parse_escaped_string();\n+    const char* field_signature = parse_string();\n+    fieldDescriptor fd;\n+    Symbol* name = SymbolTable::new_symbol(field_name);\n+    Symbol* sig = SymbolTable::new_symbol(field_signature);\n+    if (!k->find_local_field(name, sig, &fd) ||\n+        !fd.is_static() ||\n+        fd.has_initial_value()) {\n+      report_error(field_name);\n+      return;\n+    }\n+\n+    oop java_mirror = k->java_mirror();\n+    if (strcmp(field_signature, \"I\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->int_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"B\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->byte_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"C\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->char_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"S\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->short_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"Z\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->bool_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"J\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      jlong value;\n+      if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+        fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+        return;\n+      }\n+      java_mirror->long_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"F\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      float value = atof(string_value);\n+      java_mirror->float_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"D\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      double value = atof(string_value);\n+      java_mirror->double_field_put(fd.offset(), value);\n+    } else if (field_signature[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+      Klass* kelem = resolve_klass(field_signature, CHECK);\n+      InlineKlass* vk = InlineKlass::cast(kelem);\n+      oop value = vk->allocate_instance(CHECK);\n+      InlineTypeFieldInitializer init_fields(value, this);\n+      vk->do_nonstatic_fields(&init_fields);\n@@ -1111,37 +1255,2 @@\n-      const char* string_value = parse_escaped_string();\n-      if (strcmp(field_signature, \"I\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->int_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"B\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->byte_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"C\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->char_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"S\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->short_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Z\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->bool_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"J\") == 0) {\n-        jlong value;\n-        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n-          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n-          return;\n-        }\n-        java_mirror->long_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"F\") == 0) {\n-        float value = atof(string_value);\n-        java_mirror->float_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"D\") == 0) {\n-        double value = atof(string_value);\n-        java_mirror->double_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n-        Handle value = java_lang_String::create_from_str(string_value, CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value());\n-      } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n-        Klass* k = resolve_klass(string_value, CHECK);\n-        oop value = InstanceKlass::cast(k)->allocate_instance(CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value);\n-      } else {\n+      bool res = process_staticfield_reference(field_signature, java_mirror, &fd, CHECK);\n+      if (!res)  {\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":189,"deletions":80,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  case Bytecodes::_aconst_init:\n@@ -194,0 +195,10 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciBytecodeStream::is_inline_klass\n+\/\/\n+\/\/ Check if the klass is an inline klass.\n+bool ciBytecodeStream::has_Q_signature() const {\n+  VM_ENTRY_MARK;\n+  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n+  return CURRENT_ENV->has_Q_signature(cpool, get_klass_index());\n+}\n+\n@@ -284,1 +295,2 @@\n-         cur_bc() == Bytecodes::_putstatic, \"wrong bc\");\n+         cur_bc() == Bytecodes::_putstatic ||\n+         cur_bc() == Bytecodes::_withfield, \"wrong bc\");\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+  bool has_Q_signature() const;\n@@ -330,0 +331,8 @@\n+  bool is_null_free() {\n+    if (at_return_type()) {\n+      return _sig->returns_null_free_inline_type();\n+    } else {\n+      return _sig->is_null_free_at(_pos);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  friend class ciFlatArrayKlass;\n@@ -82,0 +83,8 @@\n+  bool starts_with(char prefix_char) const;\n+\n+  \/\/ Tests if the symbol ends with the given suffix.\n+  bool ends_with(const char* suffix, int len) const;\n+  bool ends_with(char suffix_char) const;\n+\n+  bool is_Q_signature() const;\n+  bool is_Q_array_signature() const;\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -277,1 +278,11 @@\n-  } else if (t1->is_primitive_type() || t2->is_primitive_type()) {\n+  }\n+  \/\/ Unwrap after saving nullness information and handling top meets\n+  bool null_free1 = t1->is_null_free();\n+  bool null_free2 = t2->is_null_free();\n+  if (t1->unwrap() == t2->unwrap() && null_free1 == null_free2) {\n+    return t1;\n+  }\n+  t1 = t1->unwrap();\n+  t2 = t2->unwrap();\n+\n+  if (t1->is_primitive_type() || t2->is_primitive_type()) {\n@@ -279,1 +290,1 @@\n-    \/\/ is T.  null_type meet null_type is null_type.\n+    \/\/ is T. null_type meet null_type is null_type.\n@@ -293,35 +304,38 @@\n-  } else {\n-    \/\/ Both types are non-top non-primitive types.  That is,\n-    \/\/ both types are either instanceKlasses or arrayKlasses.\n-    ciKlass* object_klass = analyzer->env()->Object_klass();\n-    ciKlass* k1 = t1->as_klass();\n-    ciKlass* k2 = t2->as_klass();\n-    if (k1->equals(object_klass) || k2->equals(object_klass)) {\n-      return object_klass;\n-    } else if (!k1->is_loaded() || !k2->is_loaded()) {\n-      \/\/ Unloaded classes fall to java.lang.Object at a merge.\n-      return object_klass;\n-    } else if (k1->is_interface() != k2->is_interface()) {\n-      \/\/ When an interface meets a non-interface, we get Object;\n-      \/\/ This is what the verifier does.\n-      return object_klass;\n-    } else if (k1->is_array_klass() || k2->is_array_klass()) {\n-      \/\/ When an array meets a non-array, we get Object.\n-      \/\/ When objArray meets typeArray, we also get Object.\n-      \/\/ And when typeArray meets different typeArray, we again get Object.\n-      \/\/ But when objArray meets objArray, we look carefully at element types.\n-      if (k1->is_obj_array_klass() && k2->is_obj_array_klass()) {\n-        \/\/ Meet the element types, then construct the corresponding array type.\n-        ciKlass* elem1 = k1->as_obj_array_klass()->element_klass();\n-        ciKlass* elem2 = k2->as_obj_array_klass()->element_klass();\n-        ciKlass* elem  = type_meet_internal(elem1, elem2, analyzer)->as_klass();\n-        \/\/ Do an easy shortcut if one type is a super of the other.\n-        if (elem == elem1) {\n-          assert(k1 == ciObjArrayKlass::make(elem), \"shortcut is OK\");\n-          return k1;\n-        } else if (elem == elem2) {\n-          assert(k2 == ciObjArrayKlass::make(elem), \"shortcut is OK\");\n-          return k2;\n-        } else {\n-          return ciObjArrayKlass::make(elem);\n-        }\n+  }\n+\n+  \/\/ Both types are non-top non-primitive types.  That is,\n+  \/\/ both types are either instanceKlasses or arrayKlasses.\n+  ciKlass* object_klass = analyzer->env()->Object_klass();\n+  ciKlass* k1 = t1->as_klass();\n+  ciKlass* k2 = t2->as_klass();\n+  if (k1->equals(object_klass) || k2->equals(object_klass)) {\n+    return object_klass;\n+  } else if (!k1->is_loaded() || !k2->is_loaded()) {\n+    \/\/ Unloaded classes fall to java.lang.Object at a merge.\n+    return object_klass;\n+  } else if (k1->is_interface() != k2->is_interface()) {\n+    \/\/ When an interface meets a non-interface, we get Object;\n+    \/\/ This is what the verifier does.\n+    return object_klass;\n+  } else if (k1->is_array_klass() || k2->is_array_klass()) {\n+    \/\/ When an array meets a non-array, we get Object.\n+    \/\/ When (obj\/flat)Array meets typeArray, we also get Object.\n+    \/\/ And when typeArray meets different typeArray, we again get Object.\n+    \/\/ But when (obj\/flat)Array meets (obj\/flat)Array, we look carefully at element types.\n+    if ((k1->is_obj_array_klass() || k1->is_flat_array_klass()) &&\n+        (k2->is_obj_array_klass() || k2->is_flat_array_klass())) {\n+      bool null_free = k1->as_array_klass()->is_elem_null_free() &&\n+                       k2->as_array_klass()->is_elem_null_free();\n+      ciType* elem1 = k1->as_array_klass()->element_klass();\n+      ciType* elem2 = k2->as_array_klass()->element_klass();\n+      ciType* elem = elem1;\n+      if (elem1 != elem2) {\n+        elem = type_meet_internal(elem1, elem2, analyzer)->as_klass();\n+      }\n+      \/\/ Do an easy shortcut if one type is a super of the other.\n+      if (elem == elem1 && !elem->is_inlinetype()) {\n+        assert(k1 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n+        return k1;\n+      } else if (elem == elem2 && !elem->is_inlinetype()) {\n+        assert(k2 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n+        return k2;\n@@ -329,1 +343,1 @@\n-        return object_klass;\n+        return ciArrayKlass::make(elem, null_free);\n@@ -332,4 +346,9 @@\n-      \/\/ Must be two plain old instance klasses.\n-      assert(k1->is_instance_klass(), \"previous cases handle non-instances\");\n-      assert(k2->is_instance_klass(), \"previous cases handle non-instances\");\n-      return k1->least_common_ancestor(k2);\n+      return object_klass;\n+    }\n+  } else {\n+    \/\/ Must be two plain old instance klasses.\n+    assert(k1->is_instance_klass(), \"previous cases handle non-instances\");\n+    assert(k2->is_instance_klass(), \"previous cases handle non-instances\");\n+    ciType* result = k1->least_common_ancestor(k2);\n+    if (null_free1 && null_free2 && result->is_inlinetype()) {\n+      result = analyzer->mark_as_null_free(result);\n@@ -337,0 +356,1 @@\n+    return result;\n@@ -398,1 +418,6 @@\n-    state->push(method()->holder());\n+    ciType* holder = method()->holder();\n+    if (holder->is_inlinetype()) {\n+      \/\/ The receiver is null-free\n+      holder = mark_as_null_free(holder);\n+    }\n+    state->push(holder);\n@@ -404,1 +429,5 @@\n-    state->push_translate(str.type());\n+    ciType* arg = str.type();\n+    if (str.is_null_free()) {\n+      arg = mark_as_null_free(arg);\n+    }\n+    state->push_translate(arg);\n@@ -550,2 +579,2 @@\n-\/\/ ciTypeFlow::StateVector::do_aaload\n-void ciTypeFlow::StateVector::do_aaload(ciBytecodeStream* str) {\n+\/\/ ciTypeFlow::StateVector::do_aload\n+void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {\n@@ -553,1 +582,1 @@\n-  ciObjArrayKlass* array_klass = pop_objArray();\n+  ciArrayKlass* array_klass = pop_objOrFlatArray();\n@@ -555,1 +584,1 @@\n-    \/\/ Did aaload on a null reference; push a null and ignore the exception.\n+    \/\/ Did aload on a null reference; push a null and ignore the exception.\n@@ -580,1 +609,5 @@\n-    push_object(element_klass);\n+    if (array_klass->is_elem_null_free()) {\n+      push(outer()->mark_as_null_free(element_klass));\n+    } else {\n+      push_object(element_klass);\n+    }\n@@ -590,0 +623,1 @@\n+  bool null_free = str->has_Q_signature();\n@@ -591,6 +625,13 @@\n-    \/\/ VM's interpreter will not load 'klass' if object is NULL.\n-    \/\/ Type flow after this block may still be needed in two situations:\n-    \/\/ 1) C2 uses do_null_assert() and continues compilation for later blocks\n-    \/\/ 2) C2 does an OSR compile in a later block (see bug 4778368).\n-    pop_object();\n-    do_null_assert(klass);\n+    if (null_free) {\n+      trap(str, klass,\n+           Deoptimization::make_trap_request\n+           (Deoptimization::Reason_unloaded,\n+            Deoptimization::Action_reinterpret));\n+    } else {\n+      \/\/ VM's interpreter will not load 'klass' if object is NULL.\n+      \/\/ Type flow after this block may still be needed in two situations:\n+      \/\/ 1) C2 uses do_null_assert() and continues compilation for later blocks\n+      \/\/ 2) C2 does an OSR compile in a later block (see bug 4778368).\n+      pop_object();\n+      do_null_assert(klass);\n+    }\n@@ -598,2 +639,13 @@\n-    pop_object();\n-    push_object(klass);\n+    ciType* type = pop_value();\n+    null_free |= type->is_null_free();\n+    type = type->unwrap();\n+    if (type->is_loaded() && klass->is_loaded() &&\n+        type != klass && type->is_subtype_of(klass)) {\n+      \/\/ Useless cast, propagate more precise type of object\n+      klass = type->as_klass();\n+    }\n+    if (klass->is_inlinetype() && null_free) {\n+      push(outer()->mark_as_null_free(klass));\n+    } else {\n+      push_object(klass);\n+    }\n@@ -620,1 +672,10 @@\n-    if (!field_type->is_loaded()) {\n+    if (field->is_static() && field->is_null_free() &&\n+        !field_type->as_instance_klass()->is_initialized()) {\n+      \/\/ Deoptimize if we load from a static field with an uninitialized inline type\n+      \/\/ because we need to throw an exception if initialization of the type failed.\n+      trap(str, field_type->as_klass(),\n+           Deoptimization::make_trap_request\n+           (Deoptimization::Reason_unloaded,\n+            Deoptimization::Action_reinterpret));\n+      return;\n+    } else if (!field_type->is_loaded()) {\n@@ -641,0 +702,3 @@\n+      if (field->is_null_free()) {\n+        field_type = outer()->mark_as_null_free(field_type);\n+      }\n@@ -708,0 +772,3 @@\n+        if (sigstr.is_null_free()) {\n+          return_type = outer()->mark_as_null_free(return_type);\n+        }\n@@ -738,1 +805,5 @@\n-        push_object(obj->klass());\n+        ciType* type = obj->klass();\n+        if (type->is_inlinetype()) {\n+          type = outer()->mark_as_null_free(type);\n+        }\n+        push(type);\n@@ -773,1 +844,1 @@\n-  if (!will_link || str->is_unresolved_klass()) {\n+  if (!will_link || str->is_unresolved_klass() || klass->is_inlinetype()) {\n@@ -780,0 +851,33 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciTypeFlow::StateVector::do_aconst_init\n+void ciTypeFlow::StateVector::do_aconst_init(ciBytecodeStream* str) {\n+  bool will_link;\n+  ciKlass* klass = str->get_klass(will_link);\n+  if (!will_link || str->is_unresolved_klass() || !klass->is_inlinetype()) {\n+    trap(str, klass, str->get_klass_index());\n+  } else {\n+    push(outer()->mark_as_null_free(klass));\n+  }\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciTypeFlow::StateVector::do_withfield\n+void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {\n+  bool will_link;\n+  ciField* field = str->get_field(will_link);\n+  ciKlass* klass = field->holder();\n+  if (!will_link) {\n+    trap(str, klass, str->get_field_holder_index());\n+  } else {\n+    ciType* type = pop_value();\n+    ciType* field_type = field->type();\n+    if (field_type->is_two_word()) {\n+      ciType* type2 = pop_value();\n+      assert(type2->is_two_word(), \"must be 2nd half\");\n+      assert(type == half_type(type2), \"must be 2nd half\");\n+    }\n+    pop_object();\n+    push(outer()->mark_as_null_free(klass));\n+  }\n+}\n+\n@@ -885,1 +989,1 @@\n-  case Bytecodes::_aaload: do_aaload(str);                       break;\n+  case Bytecodes::_aaload: do_aload(str);                           break;\n@@ -891,1 +995,1 @@\n-      pop_objArray();\n+      pop_objOrFlatArray();\n@@ -913,1 +1017,2 @@\n-        push_object(ciObjArrayKlass::make(element_klass));\n+        bool null_free = str->has_Q_signature();\n+        push_object(ciArrayKlass::make(element_klass, null_free));\n@@ -1445,0 +1550,3 @@\n+  case Bytecodes::_aconst_init: do_aconst_init(str);              break;\n+  case Bytecodes::_withfield: do_withfield(str);                    break;\n+\n@@ -1472,0 +1580,1 @@\n+\n@@ -1492,1 +1601,1 @@\n-  ciType* type = type_at(c);\n+  ciType* type = type_at(c)->unwrap();\n@@ -1754,3 +1863,6 @@\n-      case Bytecodes::_athrow:     case Bytecodes::_ireturn:\n-      case Bytecodes::_lreturn:    case Bytecodes::_freturn:\n-      case Bytecodes::_dreturn:    case Bytecodes::_areturn:\n+      case Bytecodes::_athrow:\n+      case Bytecodes::_ireturn:\n+      case Bytecodes::_lreturn:\n+      case Bytecodes::_freturn:\n+      case Bytecodes::_dreturn:\n+      case Bytecodes::_areturn:\n@@ -3114,0 +3226,5 @@\n+ciType* ciTypeFlow::mark_as_null_free(ciType* type) {\n+  \/\/ Wrap the type to carry the information that it is null-free\n+  return env()->make_null_free_wrapper(type);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":184,"deletions":67,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -334,2 +334,2 @@\n-    \/\/ pop_objArray and pop_typeArray narrow the tos to ciObjArrayKlass\n-    \/\/ or ciTypeArrayKlass (resp.).  In the rare case that an explicit\n+    \/\/ pop_objOrFlatArray and pop_typeArray narrow the tos to ciObjArrayKlass,\n+    \/\/ ciFlatArrayKlass or ciTypeArrayKlass (resp.). In the rare case that an explicit\n@@ -337,1 +337,1 @@\n-    ciObjArrayKlass* pop_objArray() {\n+    ciArrayKlass* pop_objOrFlatArray() {\n@@ -340,2 +340,3 @@\n-      assert(array->is_obj_array_klass(), \"must be object array type\");\n-      return array->as_obj_array_klass();\n+      assert(array->is_obj_array_klass() || array->is_flat_array_klass(),\n+             \"must be a flat or an object array type\");\n+      return array->as_array_klass();\n@@ -355,1 +356,1 @@\n-    void do_aaload(ciBytecodeStream* str);\n+    void do_aload(ciBytecodeStream* str);\n@@ -364,0 +365,2 @@\n+    void do_aconst_init(ciBytecodeStream* str);\n+    void do_withfield(ciBytecodeStream* str);\n@@ -845,0 +848,2 @@\n+  ciType* mark_as_null_free(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -52,0 +53,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -85,0 +87,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -146,0 +149,2 @@\n+#define CONSTANT_CLASS_DESCRIPTORS        64\n+\n@@ -185,1 +190,1 @@\n-      case JVM_CONSTANT_Class : {\n+      case JVM_CONSTANT_Class: {\n@@ -506,1 +511,8 @@\n-        cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n+\n+        Symbol* const name = cp->symbol_at(class_index);\n+        const unsigned int name_len = name->utf8_length();\n+        if (name->is_Q_signature()) {\n+          cp->unresolved_qdescriptor_at_put(index, class_index, num_klasses++);\n+        } else {\n+          cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n+        }\n@@ -706,1 +718,2 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature\n+          \/\/ unless it's an inline type.\n@@ -715,2 +728,6 @@\n-            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n-              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            } else if (!Signature::is_void_method(signature)) {\n+              \/\/ if return type is non-void then it cannot be a basic primitive\n+              \/\/ and primitve types must be supported.\n+              if (!signature->ends_with(JVM_SIGNATURE_ENDCLASS) || !EnableValhalla) {\n+                throwIllegalSignature(\"Method\", name, signature, CHECK);\n+              }\n@@ -735,2 +752,2 @@\n-            if (ref_kind == JVM_REF_newInvokeSpecial) {\n-              if (name != vmSymbols::object_initializer_name()) {\n+            if (name != vmSymbols::object_initializer_name()) {\n+              if (ref_kind == JVM_REF_newInvokeSpecial) {\n@@ -743,1 +760,12 @@\n-              if (name == vmSymbols::object_initializer_name()) {\n+              \/\/ The allowed invocation mode of <init> depends on its signature.\n+              \/\/ This test corresponds to verify_invoke_instructions in the verifier.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature()\n+                  && ref_kind == JVM_REF_newInvokeSpecial) {\n+                \/\/ OK, could be a constructor call\n+              } else if (!signature->is_void_method_signature()\n+                         && ref_kind == JVM_REF_invokeStatic) {\n+                \/\/ also OK, could be a static factory call\n+              } else {\n@@ -820,4 +848,31 @@\n-\/\/ Side-effects: populates the _local_interfaces field\n-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,\n-                                       const int itfs_len,\n-                                       ConstantPool* const cp,\n+static void check_identity_and_value_modifiers(ClassFileParser* current, const InstanceKlass* super_type, TRAPS) {\n+  assert(super_type != NULL,\"Method doesn't support null super type\");\n+  if (super_type->carries_identity_modifier()) {\n+    if (current->carries_value_modifier()) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(\n+          THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_IncompatibleClassChangeError(),\n+          \"Value type %s has an identity type as supertype\",\n+          current->class_name()->as_klass_external_name());\n+        return;\n+      }\n+    current->set_carries_identity_modifier();\n+  }\n+  if (super_type->carries_value_modifier()) {\n+    if (current->carries_identity_modifier()) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_IncompatibleClassChangeError(),\n+        \"Identity type %s has a value type as supertype\",\n+        current->class_name()->as_klass_external_name());\n+      return;\n+    }\n+    current->set_carries_value_modifier();\n+  }\n+}\n+\n+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,\n+                                       int itfs_len,\n+                                       ConstantPool* cp,\n@@ -825,0 +880,7 @@\n+                                       \/\/ FIXME: lots of these functions\n+                                       \/\/ declare their parameters as const,\n+                                       \/\/ which adds only noise to the code.\n+                                       \/\/ Remove the spurious const modifiers.\n+                                       \/\/ Many are of the form \"const int x\"\n+                                       \/\/ or \"T* const x\".\n+                                       bool* const is_declared_atomic,\n@@ -832,0 +894,1 @@\n+\n@@ -834,3 +897,2 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);\n-\n-    int index;\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len, mtNone);\n+    int index = 0;\n@@ -839,1 +901,0 @@\n-      Klass* interf;\n@@ -844,32 +905,1 @@\n-      if (cp->tag_at(interface_index).is_klass()) {\n-        interf = cp->resolved_klass_at(interface_index);\n-      } else {\n-        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n-\n-        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n-        \/\/ But need to make sure it's not an array type.\n-        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n-                           \"Bad interface name in class file %s\", CHECK);\n-\n-        \/\/ Call resolve_super so class circularity is checked\n-        interf = SystemDictionary::resolve_super_or_fail(\n-                                                  _class_name,\n-                                                  unresolved_klass,\n-                                                  Handle(THREAD, _loader_data->class_loader()),\n-                                                  _protection_domain,\n-                                                  false,\n-                                                  CHECK);\n-      }\n-\n-      if (!interf->is_interface()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n-                          _class_name->as_klass_external_name(),\n-                          interf->external_name(),\n-                          interf->class_in_module_of_loader()));\n-      }\n-\n-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n-        *has_nonstatic_concrete_methods = true;\n-      }\n-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));\n+      _local_interface_indexes->at_put_grow(index, interface_index);\n@@ -893,2 +923,1 @@\n-        const InstanceKlass* const k = _local_interfaces->at(index);\n-        name = k->name();\n+        name = cp->klass_name_at(_local_interface_indexes->at(index));\n@@ -1380,0 +1409,1 @@\n+  STATIC_INLINE,        \/\/ inline type field\n@@ -1385,0 +1415,1 @@\n+  NONSTATIC_INLINE,\n@@ -1404,6 +1435,7 @@\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n+  NONSTATIC_OOP,       \/\/ T_PRIMITIVE_OBJECT = 14,\n+  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n+  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n+  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n+  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20,\n@@ -1424,6 +1456,7 @@\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n+  STATIC_OOP,          \/\/ T_PRIMITIVE_OBJECT = 14,\n+  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n+  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n+  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n+  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20\n@@ -1432,1 +1465,1 @@\n-static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {\n+static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {\n@@ -1436,0 +1469,3 @@\n+  if (is_inline_type) {\n+    result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;\n+  }\n@@ -1449,2 +1485,2 @@\n-  void update(bool is_static, BasicType type) {\n-    FieldAllocationType atype = basic_type_to_atype(is_static, type);\n+  void update(bool is_static, BasicType type, bool is_inline_type) {\n+    FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);\n@@ -1462,1 +1498,1 @@\n-                                   bool is_interface,\n+                                   AccessFlags class_access_flags,\n@@ -1478,0 +1514,1 @@\n+  bool is_inline_type = class_access_flags.is_value_class() && !class_access_flags.is_abstract();\n@@ -1485,1 +1522,5 @@\n-  const int total_fields = length + num_injected;\n+\n+  \/\/ two more slots are required for inline classes:\n+  \/\/ one for the static field with a reference to the pre-allocated default value\n+  \/\/ one for the field the JVM injects when detecting an empty inline class\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);\n@@ -1515,0 +1556,1 @@\n+  int instance_fields_count = 0;\n@@ -1519,0 +1561,4 @@\n+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;\n+\n+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    verify_legal_field_modifiers(flags, class_access_flags, CHECK);\n@@ -1520,2 +1566,0 @@\n-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n-    verify_legal_field_modifiers(flags, is_interface, CHECK);\n@@ -1537,0 +1581,1 @@\n+    if (!access_flags.is_static()) instance_fields_count++;\n@@ -1596,1 +1641,1 @@\n-    fac->update(is_static, type);\n+    fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n@@ -1640,1 +1685,1 @@\n-      fac->update(false, type);\n+      fac->update(false, type, false);\n@@ -1645,0 +1690,27 @@\n+  if (is_inline_type) {\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n+                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n+                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                      0);\n+    const BasicType type = Signature::basic_type(vmSymbols::object_signature());\n+    fac->update(true, type, false);\n+    index++;\n+  }\n+\n+  if (is_inline_type && instance_fields_count == 0) {\n+    _is_empty_inline_type = true;\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+    field->initialize(JVM_ACC_FIELD_INTERNAL,\n+        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n+        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n+        0);\n+    const BasicType type = Signature::basic_type(vmSymbols::byte_signature());\n+    fac->update(false, type, false);\n+    index++;\n+  }\n+\n+  if (instance_fields_count > 0) {\n+    _has_nonstatic_fields = true;\n+  }\n+\n@@ -1962,0 +2034,5 @@\n+  const char* class_note = \"\";\n+  if (is_inline_type() && name == vmSymbols::object_initializer_name()) {\n+    class_note = \" (an inline class)\";\n+  }\n+\n@@ -1965,2 +2042,2 @@\n-      \"%s \\\"%s\\\" in class %s has illegal signature \\\"%s\\\"\", type,\n-      name->as_C_string(), _class_name->as_C_string(), sig->as_C_string());\n+      \"%s \\\"%s\\\" in class %s%s has illegal signature \\\"%s\\\"\", type,\n+      name->as_C_string(), _class_name->as_C_string(), class_note, sig->as_C_string());\n@@ -2269,0 +2346,2 @@\n+                                      bool is_value_class,\n+                                      bool is_abstract_class,\n@@ -2310,1 +2389,1 @@\n-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);\n+    verify_legal_method_modifiers(flags, access_flags() , name, CHECK_NULL);\n@@ -2313,3 +2392,57 @@\n-  if (name == vmSymbols::object_initializer_name() && is_interface) {\n-    classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n-    return NULL;\n+  if (name == vmSymbols::object_initializer_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n+      return NULL;\n+    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n+      \/\/ OK, a constructor\n+    } else if (is_value_class && !signature->is_void_method_signature()) {\n+      \/\/ also OK, a static factory, as long as the return value is good\n+      bool ok = false;\n+      SignatureStream ss((Symbol*) signature, true);\n+      while (!ss.at_return_type())  ss.next();\n+      if (ss.is_reference()) {\n+        Symbol* ret = ss.as_symbol();\n+        const Symbol* required = class_name();\n+        if (is_hidden()) {\n+          \/\/ The original class name in hidden classes gets changed.  So using\n+          \/\/ the original name in the return type is no longer valid.\n+          \/\/ Note that expecting the return type for inline hidden class factory\n+          \/\/ methods to be java.lang.Object works around a JVM Spec issue for\n+          \/\/ hidden classes.\n+          required = vmSymbols::java_lang_Object();\n+        }\n+        ok = (ret == required);\n+      }\n+      if (!ok) {\n+        throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+      }\n+    } else {\n+      \/\/ not OK, so throw the same error as in verify_legal_method_signature.\n+      throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+    }\n+    \/\/ A declared <init> method must always be either a non-static\n+    \/\/ object constructor, with a void return, or else it must be a\n+    \/\/ static factory method, with a non-void return.  No other\n+    \/\/ definition of <init> is possible.\n+    \/\/\n+    \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+    \/\/ signature of any attempt to invoke <init>, and ensures that it\n+    \/\/ returns non-void if and only if it is being invoked by\n+    \/\/ invokestatic, and void if and only if it is being invoked by\n+    \/\/ invokespecial.\n+    \/\/\n+    \/\/ When a symbolic reference to <init> is resolved for a\n+    \/\/ particular invocation mode (special or static), the mode is\n+    \/\/ matched to the JVM_ACC_STATIC modifier of the <init> method.\n+    \/\/ Thus, it is impossible to statically invoke a constructor, and\n+    \/\/ impossible to \"new + invokespecial\" a static factory, either\n+    \/\/ through bytecode or through reflection.\n+  }\n+\n+  if (EnableValhalla) {\n+    if (((flags & JVM_ACC_SYNCHRONIZED) == JVM_ACC_SYNCHRONIZED)\n+        && ((flags & JVM_ACC_STATIC) == 0 )\n+        && !carries_identity_modifier()) {\n+      classfile_parse_error(\"Invalid synchronized method in non-identity class %s\", THREAD);\n+        return NULL;\n+    }\n@@ -2885,0 +3018,2 @@\n+                                    bool is_value_class,\n+                                    bool is_abstract_type,\n@@ -2909,0 +3044,2 @@\n+                                    is_value_class,\n+                                    is_abstract_type,\n@@ -3185,2 +3322,2 @@\n-    \/\/ Access flags\n-    jint flags;\n+\n+    jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n@@ -3189,3 +3326,1 @@\n-      flags = cfs->get_u2_fast() & (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-    } else {\n-      flags = cfs->get_u2_fast() & RECOGNIZED_INNER_CLASS_MODIFIERS;\n+      recognized_modifiers |= JVM_ACC_MODULE;\n@@ -3193,0 +3328,8 @@\n+    \/\/ JVM_ACC_VALUE, JVM_ACC_PRIMITIVE, and JVM_ACC_IDENTITY are defined for class file version 62 and later\n+    if (supports_inline_types()) {\n+      recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY;\n+    }\n+\n+    \/\/ Access flags\n+    jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+\n@@ -3197,1 +3340,3 @@\n-    verify_legal_class_modifiers(flags, CHECK_0);\n+\n+    const char* name = inner_name_index == 0 ? \"unnamed\" : cp->symbol_at(inner_name_index)->as_utf8();\n+    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n@@ -3301,0 +3446,33 @@\n+u2 ClassFileParser::parse_classfile_preload_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const preload_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (preload_attribute_start != NULL) {\n+    cfs->set_current(preload_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  const int size = length;\n+  Array<u2>* const preload_classes = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _preload_classes = preload_classes;\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 class_info_index = cfs->get_u2_fast();\n+      check_property(\n+        valid_klass_reference_at(class_info_index),\n+        \"Preload class_info_index %u has bad constant type in class file %s\",\n+        class_info_index, CHECK_0);\n+      preload_classes->at_put(index++, class_info_index);\n+    }\n+    assert(index == size, \"wrong size\");\n+  }\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3585,0 +3763,2 @@\n+  \/\/ Set _preload_classes attribute to default sentinel\n+  _preload_classes = Universe::the_empty_short_array();\n@@ -3591,0 +3771,1 @@\n+  bool parsed_preload_attribute = false;\n@@ -3616,0 +3797,2 @@\n+  const u1* preload_attribute_start = NULL;\n+  u4  preload_attribute_length = 0;\n@@ -3842,0 +4025,9 @@\n+            if (EnableValhalla && tag == vmSymbols::tag_preload()) {\n+              if (parsed_preload_attribute) {\n+                classfile_parse_error(\"Multiple Preload attributes in class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_preload_attribute = true;\n+              preload_attribute_start = cfs->current();\n+              preload_attribute_length = attribute_length;\n+            }\n@@ -3922,0 +4114,12 @@\n+  if (parsed_preload_attribute) {\n+    const u2 num_classes = parse_classfile_preload_attribute(\n+                            cfs,\n+                            preload_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        preload_attribute_length == sizeof(num_classes) + sizeof(u2) * num_classes,\n+        \"Wrong Preload attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3986,0 +4190,1 @@\n+  this_klass->set_preload_classes(_preload_classes);\n@@ -4037,2 +4242,1 @@\n-                   \"Invalid superclass index %u in class file %s\",\n-                   super_class_index,\n+                   \"Invalid superclass index 0 in class file %s\",\n@@ -4047,1 +4251,0 @@\n-    bool is_array = false;\n@@ -4050,4 +4253,0 @@\n-      if (need_verify)\n-        is_array = super_klass->is_array_klass();\n-    } else if (need_verify) {\n-      is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -4056,0 +4255,1 @@\n+      bool is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -4179,0 +4379,19 @@\n+void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,\n+                                                const char* msg,\n+                                                const Symbol* name,\n+                                                const Symbol* sig) const {\n+\n+  ResourceMark rm(THREAD);\n+  if (name == NULL || sig == NULL) {\n+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"class: %s - %s\", _class_name->as_C_string(), msg);\n+  }\n+  else {\n+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"\\\"%s\\\" sig: \\\"%s\\\" class: %s - %s\", name->as_C_string(), sig->as_C_string(),\n+        _class_name->as_C_string(), msg);\n+  }\n+}\n+\n@@ -4213,0 +4432,5 @@\n+      if (ik->is_inline_klass()) {\n+        JavaThread *THREAD = JavaThread::current();\n+        throwInlineTypeLimitation(THREAD_AND_LOCATION, \"Inline Types do not support Cloneable\");\n+        return;\n+      }\n@@ -4253,0 +4477,6 @@\n+bool ClassFileParser::supports_inline_types() const {\n+  \/\/ Inline types are only supported by class file version 61.65535 and later\n+  return _major_version > JAVA_20_VERSION ||\n+         (_major_version == JAVA_20_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+}\n+\n@@ -4296,3 +4526,4 @@\n-  } else if (max_transitive_size == local_size) {\n-    \/\/ only local interfaces added, share local interface array\n-    return local_ifs;\n+    \/\/ The three lines below are commented to work around bug JDK-8245487\n+\/\/  } else if (max_transitive_size == local_size) {\n+\/\/    \/\/ only local interfaces added, share local interface array\n+\/\/    return local_ifs;\n@@ -4319,0 +4550,1 @@\n+\n@@ -4347,0 +4579,10 @@\n+    \/\/ The JVMS says that super classes for value types must not have the ACC_IDENTITY\n+    \/\/ flag set. But, java.lang.Object must still be allowed to be a direct super class\n+    \/\/ for a value classes.  So, it is treated as a special case for now.\n+    if (this_klass->access_flags().is_value_class() &&\n+        super_ik->name() != vmSymbols::java_lang_Object() &&\n+        super_ik->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super_ik, THREAD);\n+      return;\n+    }\n+\n@@ -4530,1 +4772,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n@@ -4532,0 +4774,4 @@\n+  const bool is_value_class = (flags & JVM_ACC_VALUE) != 0;\n+  const bool is_primitive_class = (flags & JVM_ACC_PRIMITIVE) != 0;\n+  const bool is_identity_class = (flags & JVM_ACC_IDENTITY) != 0;\n+  const bool is_inner_class = name != NULL;\n@@ -4533,0 +4779,2 @@\n+  assert(supports_inline_types() || !is_value_class, \"JVM_ACC_VALUE should not be set\");\n+  assert(supports_inline_types() || !is_primitive_class, \"JVM_ACC_PRIMITIVE should not be set\");\n@@ -4543,1 +4791,15 @@\n-  if (!_need_verify) { return; }\n+  if (!EnableValhalla) {\n+    if (is_value_class || is_primitive_class) {\n+      const char* bad_flag = is_primitive_class ? \"ACC_PRIMITIVE\" : \"ACC_VALUE\";\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Class modifier %s in class %s requires option -XX:+EnableValhalla\",\n+        bad_flag, _class_name->as_C_string()\n+      );\n+    }\n+    return;\n+  }\n+\n+  \/\/ if (!_need_verify) { return; }\n@@ -4555,2 +4817,6 @@\n-      (is_interface && major_gte_1_5 && (is_super || is_enum)) ||\n-      (!is_interface && major_gte_1_5 && is_annotation)) {\n+      (is_interface && major_gte_1_5 && ((is_super && !supports_inline_types()) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation) ||\n+      (is_value_class && is_enum) ||\n+      (is_identity_class && is_value_class) ||\n+      (supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n+      (supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n@@ -4558,7 +4824,21 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Illegal class modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags\n-    );\n-    return;\n+    const char* class_note = \"\";\n+    if (is_value_class)  class_note = \" (a value class)\";\n+    if (is_primitive_class)  class_note = \" (a primitive class)\";\n+    if (is_value_class && is_identity_class) class_note = \" (a value and identity class)\";\n+    if (name == NULL) { \/\/ Not an inner class\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in class %s%s: 0x%X\",\n+        _class_name->as_C_string(), class_note, flags\n+      );\n+      return;\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in declaration of inner class %s%s of class %s: 0x%X\",\n+        name, class_note, _class_name->as_C_string(), flags\n+      );\n+      return;\n+    }\n@@ -4630,2 +4910,2 @@\n-void ClassFileParser::verify_legal_field_modifiers(jint flags,\n-                                                   bool is_interface,\n+void ClassFileParser:: verify_legal_field_modifiers(jint flags,\n+                                                   AccessFlags class_access_flags,\n@@ -4645,0 +4925,5 @@\n+  const bool is_interface = class_access_flags.is_interface();\n+  const bool is_abstract = class_access_flags.is_abstract();\n+  const bool is_value_class = class_access_flags.is_value_class();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+\n@@ -4656,0 +4941,6 @@\n+    } else {\n+      if (is_value_class && !is_abstract && !is_static && !is_final) {\n+        is_illegal = true;\n+      } else if (is_abstract && !is_identity_class && !is_static) {\n+        is_illegal = true;\n+      }\n@@ -4671,1 +4962,1 @@\n-                                                    bool is_interface,\n+                                                    AccessFlags class_access_flags,\n@@ -4690,0 +4981,4 @@\n+  const bool is_interface    = class_access_flags.is_interface();\n+  const bool is_value_class  = class_access_flags.is_value_class();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+  const bool is_abstract_class = class_access_flags.is_abstract();\n@@ -4693,0 +4988,1 @@\n+  const char* class_note = \"\";\n@@ -4727,1 +5023,1 @@\n-        if (is_static || is_final || is_synchronized || is_native ||\n+        if (is_final || is_synchronized || is_native ||\n@@ -4731,0 +5027,9 @@\n+        if (!is_static && (!is_value_class || is_abstract_class)) {\n+          \/\/ OK, an object constructor in a regular class or an abstract value class\n+        } else if (is_static && is_value_class) {\n+          \/\/ OK, a static init factory in an inline class\n+        } else {\n+          \/\/ but no other combinations are allowed\n+          is_illegal = true;\n+          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n+        }\n@@ -4732,4 +5037,9 @@\n-        if (is_abstract) {\n-          if ((is_final || is_native || is_private || is_static ||\n-              (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n-            is_illegal = true;\n+        if (!is_identity_class && is_synchronized && !is_static) {\n+          is_illegal = true;\n+          class_note = \" (not an identity class)\";\n+        } else {\n+          if (is_abstract) {\n+            if ((is_final || is_native || is_private || is_static ||\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n+              is_illegal = true;\n+            }\n@@ -4747,2 +5057,2 @@\n-      \"Method %s in class %s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), flags);\n+      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+      name->as_C_string(), _class_name->as_C_string(), class_note, flags);\n@@ -4906,1 +5216,12 @@\n-    case JVM_SIGNATURE_CLASS: {\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n+      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators.\n+      \/\/ For now, compare to class file version 51 so old verifier doesn't see Q signatures.\n+      if (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) {\n+        classfile_parse_error(\"Class name contains illegal Q-signature \"\n+                              \"in descriptor in class file %s\",\n+                              CHECK_0);\n+        return NULL;\n+      }\n+      \/\/ fall through\n+    case JVM_SIGNATURE_CLASS:\n+    {\n@@ -4917,1 +5238,1 @@\n-        \/\/ Skip leading 'L' and ignore first appearance of ';'\n+        \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -4973,0 +5294,4 @@\n+    } else if ((_major_version >= CONSTANT_CLASS_DESCRIPTORS || _class_name->starts_with(\"jdk\/internal\/reflect\/\"))\n+                   && bytes[length - 1] == ';' ) {\n+      \/\/ Support for L...; and Q...; descriptors\n+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);\n@@ -5070,0 +5395,3 @@\n+  if (!supports_inline_types() && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n+    throwIllegalSignature(\"Field\", name, signature, CHECK);\n+  }\n@@ -5097,2 +5425,3 @@\n-  int sig_length = signature->utf8_length();\n-  if (name->utf8_length() > 0 &&\n+  if (!is_value_class()) {\n+    int sig_length = signature->utf8_length();\n+    if (name->utf8_length() > 0 &&\n@@ -5102,1 +5431,2 @@\n-    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+      throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    }\n@@ -5278,1 +5608,0 @@\n-\n@@ -5314,0 +5643,10 @@\n+  if (_field_info->_is_naturally_atomic && ik->is_inline_klass()) {\n+    ik->set_is_naturally_atomic();\n+  }\n+\n+  if (carries_identity_modifier()) {\n+    ik->set_carries_identity_modifier();\n+  } else if (carries_value_modifier()) {\n+    ik->set_carries_value_modifier();\n+  }\n+\n@@ -5315,1 +5654,1 @@\n-  ik->set_static_oop_field_count(_fac->count[STATIC_OOP]);\n+  ik->set_static_oop_field_count(_fac->count[STATIC_OOP] + _fac->count[STATIC_INLINE]);\n@@ -5332,0 +5671,1 @@\n+  assert(NULL == _preload_classes, \"invariant\");\n@@ -5365,0 +5705,3 @@\n+  if (_is_declared_atomic) {\n+    ik->set_is_declared_atomic();\n+  }\n@@ -5472,0 +5815,27 @@\n+  bool all_fields_empty = true;\n+  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static()) {\n+      if (fs.field_descriptor().is_inline_type()) {\n+        Klass* k = _inline_type_field_klasses->at(fs.index());\n+        ik->set_inline_type_field_klass(fs.index(), k);\n+        if (!InlineKlass::cast(k)->is_empty_inline_type()) { all_fields_empty = false; }\n+      } else {\n+        all_fields_empty = false;\n+      }\n+    } else if (is_inline_type() && (fs.name() == vmSymbols::default_value_name())) {\n+      InlineKlass::cast(ik)->set_default_value_offset(ik->field_offset(fs.index()));\n+    }\n+  }\n+\n+  if (_is_empty_inline_type || (is_inline_type() && all_fields_empty)) {\n+    ik->set_is_empty_inline_type();\n+  }\n+\n+  if (is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(ik);\n+    vk->set_alignment(_alignment);\n+    vk->set_first_field_offset(_first_field_offset);\n+    vk->set_exact_size_in_bytes(_exact_size_in_bytes);\n+    InlineKlass::cast(ik)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -5562,0 +5932,1 @@\n+  _preload_classes(NULL),\n@@ -5564,0 +5935,1 @@\n+  _local_interface_indexes(NULL),\n@@ -5575,0 +5947,1 @@\n+  _inline_type_field_klasses(NULL),\n@@ -5601,0 +5974,7 @@\n+  _has_inline_type_fields(false),\n+  _has_nonstatic_fields(false),\n+  _is_empty_inline_type(false),\n+  _is_naturally_atomic(false),\n+  _is_declared_atomic(false),\n+  _carries_value_modifier(false),\n+  _carries_identity_modifier(false),\n@@ -5650,0 +6030,1 @@\n+  _preload_classes = NULL;\n@@ -5667,0 +6048,4 @@\n+  if (_inline_type_field_klasses != NULL) {\n+     MetadataFactory::free_array<InlineKlass*>(_loader_data, _inline_type_field_klasses);\n+  }\n+\n@@ -5689,0 +6074,4 @@\n+  if (_preload_classes != NULL && _preload_classes != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _preload_classes);\n+  }\n+\n@@ -5773,2 +6162,1 @@\n-  \/\/ Access flags\n-  jint flags;\n+  jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n@@ -5777,3 +6165,5 @@\n-    flags = stream->get_u2_fast() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-  } else {\n-    flags = stream->get_u2_fast() & JVM_RECOGNIZED_CLASS_MODIFIERS;\n+    recognized_modifiers |= JVM_ACC_MODULE;\n+  }\n+  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE are defined for class file version 55 and later\n+  if (supports_inline_types()) {\n+    recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE;\n@@ -5782,0 +6172,3 @@\n+  \/\/ Access flags\n+  jint flags = stream->get_u2_fast() & recognized_modifiers;\n+\n@@ -5787,10 +6180,0 @@\n-  verify_legal_class_modifiers(flags, CHECK);\n-\n-  short bad_constant = class_bad_constant_seen();\n-  if (bad_constant != 0) {\n-    \/\/ Do not throw CFE until after the access_flags are checked because if\n-    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n-    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n-    return;\n-  }\n-\n@@ -5810,0 +6193,27 @@\n+  bool is_java_lang_Object = class_name_in_cp == vmSymbols::java_lang_Object();\n+\n+  verify_legal_class_modifiers(flags, NULL, is_java_lang_Object, CHECK);\n+\n+  if (EnableValhalla) {\n+    if(!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface) {\n+        flags |= JVM_ACC_IDENTITY;\n+      }\n+    }\n+    if (_access_flags.is_identity_class()) set_carries_identity_modifier();\n+    if (_access_flags.is_value_class()) set_carries_value_modifier();\n+    if (carries_identity_modifier() && carries_value_modifier()) {\n+      classfile_parse_error(\"Class %s has both ACC_IDENTITY and ACC_VALUE modifiers\", THREAD);\n+    }\n+  }\n+\n+  short bad_constant = class_bad_constant_seen();\n+  if (bad_constant != 0) {\n+    \/\/ Do not throw CFE until after the access_flags are checked because if\n+    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n+    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n+    return;\n+  }\n+\n@@ -5887,0 +6297,1 @@\n+                   &_is_declared_atomic,\n@@ -5889,2 +6300,0 @@\n-  assert(_local_interfaces != NULL, \"invariant\");\n-\n@@ -5894,1 +6303,1 @@\n-               _access_flags.is_interface(),\n+               _access_flags,\n@@ -5906,1 +6315,3 @@\n-                _access_flags.is_interface(),\n+                is_interface(),\n+                is_value_class(),\n+                is_abstract_class(),\n@@ -5989,2 +6400,2 @@\n-                   \"java.lang.Object cannot implement an interface in class file %s\",\n-                   CHECK);\n+        \"java.lang.Object cannot implement an interface in class file %s\",\n+        CHECK);\n@@ -5995,1 +6406,1 @@\n-    if (_access_flags.is_interface()) {\n+    if (is_interface()) {\n@@ -6013,0 +6424,9 @@\n+    if (_super_klass->is_interface()) {\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (EnableValhalla) {\n+      check_identity_and_value_modifiers(this, _super_klass, CHECK);\n+    }\n+\n@@ -6016,0 +6436,4 @@\n+    if (_super_klass->is_declared_atomic()) {\n+      _is_declared_atomic = true;\n+    }\n+  }\n@@ -6017,3 +6441,9 @@\n-    if (_super_klass->is_interface()) {\n-      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n-      return;\n+  if (_class_name == vmSymbols::java_lang_NonTearable() && _loader_data->class_loader() == NULL) {\n+    \/\/ This is the original source of this condition.\n+    \/\/ It propagates by inheritance, as if testing \"instanceof NonTearable\".\n+    _is_declared_atomic = true;\n+  } else if (*ForceNonTearable != '\\0') {\n+    \/\/ Allow a command line switch to force the same atomicity property:\n+    const char* class_name_str = _class_name->as_C_string();\n+    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+      _is_declared_atomic = true;\n@@ -6023,0 +6453,50 @@\n+  int itfs_len = _local_interface_indexes == NULL ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);\n+  if (_local_interface_indexes != NULL) {\n+    for (int i = 0; i < _local_interface_indexes->length(); i++) {\n+      u2 interface_index = _local_interface_indexes->at(i);\n+      Klass* interf;\n+      if (cp->tag_at(interface_index).is_klass()) {\n+        interf = cp->resolved_klass_at(interface_index);\n+      } else {\n+        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n+\n+        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n+        \/\/ But need to make sure it's not an array type.\n+        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                            \"Bad interface name in class file %s\", CHECK);\n+\n+        \/\/ Call resolve_super so class circularity is checked\n+        interf = SystemDictionary::resolve_super_or_fail(\n+                                                  _class_name,\n+                                                  unresolved_klass,\n+                                                  Handle(THREAD, _loader_data->class_loader()),\n+                                                  _protection_domain,\n+                                                  false,\n+                                                  CHECK);\n+      }\n+\n+      if (!interf->is_interface()) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n+                          _class_name->as_klass_external_name(),\n+                          interf->external_name(),\n+                          interf->class_in_module_of_loader()));\n+      }\n+\n+      if (EnableValhalla) {\n+        \/\/ Check modifiers and set carries_identity_modifier\/carries_value_modifier flags\n+        check_identity_and_value_modifiers(this, InstanceKlass::cast(interf), CHECK);\n+      }\n+\n+      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n+        _has_nonstatic_concrete_methods = true;\n+      }\n+      if (InstanceKlass::cast(interf)->is_declared_atomic()) {\n+        _is_declared_atomic = true;\n+      }\n+      _local_interfaces->at_put(i, InstanceKlass::cast(interf));\n+    }\n+  }\n+  assert(_local_interfaces != NULL, \"invariant\");\n+\n@@ -6050,1 +6530,1 @@\n-  _itable_size = _access_flags.is_interface() ? 0 :\n+  _itable_size = is_interface() ? 0 :\n@@ -6056,0 +6536,26 @@\n+\n+  if (EnableValhalla) {\n+    _inline_type_field_klasses = MetadataFactory::new_array<InlineKlass*>(_loader_data,\n+                                                   java_fields_count(),\n+                                                   NULL,\n+                                                   CHECK);\n+    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT && !fs.access_flags().is_static()) {\n+        \/\/ Pre-load inline class\n+        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+            Handle(THREAD, _loader_data->class_loader()),\n+            _protection_domain, true, CHECK);\n+        assert(klass != NULL, \"Sanity check\");\n+        if (!klass->access_flags().is_value_class()) {\n+          assert(klass->is_instance_klass(), \"Sanity check\");\n+          ResourceMark rm(THREAD);\n+            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                      err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                      _class_name->as_C_string(),\n+                      InstanceKlass::cast(klass)->external_name()));\n+        }\n+        _inline_type_field_klasses->at_put(fs.index(), InlineKlass::cast(klass));\n+      }\n+    }\n+  }\n+\n@@ -6058,2 +6564,9 @@\n-                        _parsed_annotations->is_contended(), _field_info);\n-  lb.build_layout();\n+      _parsed_annotations->is_contended(), is_inline_type(),\n+      _field_info, _inline_type_field_klasses);\n+  lb.build_layout(CHECK);\n+  if (is_inline_type()) {\n+    _alignment = lb.get_alignment();\n+    _first_field_offset = lb.get_first_field_offset();\n+    _exact_size_in_bytes = lb.get_exact_size_in_byte();\n+  }\n+  _has_inline_type_fields = _field_info->_has_inline_fields;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":662,"deletions":149,"binary":false,"changes":811,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+  bool  _is_naturally_atomic;\n+  bool _has_inline_fields;\n@@ -131,0 +133,1 @@\n+  Array<u2>* _preload_classes;\n@@ -133,0 +136,1 @@\n+  GrowableArray<u2>* _local_interface_indexes;\n@@ -145,0 +149,1 @@\n+  Array<InlineKlass*>* _inline_type_field_klasses;\n@@ -157,0 +162,4 @@\n+  int _alignment;\n+  int _first_field_offset;\n+  int _exact_size_in_bytes;\n+\n@@ -194,0 +203,8 @@\n+  bool _has_inline_type_fields;\n+  bool _has_nonstatic_fields;\n+  bool _is_empty_inline_type;\n+  bool _is_naturally_atomic;\n+  bool _is_declared_atomic;\n+  bool _carries_value_modifier;      \/\/ Has ACC_VALUE mddifier or one of its super types has\n+  bool _carries_identity_modifier;   \/\/ Has ACC_IDENTITY modifier or one of its super types has\n+\n@@ -241,0 +258,1 @@\n+                        bool* is_declared_atomic,\n@@ -260,1 +278,1 @@\n-                    bool is_interface,\n+                    AccessFlags class_access_flags,\n@@ -270,0 +288,2 @@\n+                       bool is_value_class,\n+                       bool is_abstract_class,\n@@ -276,0 +296,2 @@\n+                     bool is_value_class,\n+                     bool is_abstract_class,\n@@ -330,0 +352,4 @@\n+  u2 parse_classfile_preload_attribute(const ClassFileStream* const cfs,\n+                                                    const u1* const preload_attribute_start,\n+                                                    TRAPS);\n+\n@@ -448,0 +474,5 @@\n+  void throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,\n+                                 const char* msg,\n+                                 const Symbol* name = NULL,\n+                                 const Symbol* sig  = NULL) const;\n+\n@@ -470,2 +501,4 @@\n-  void verify_legal_class_modifiers(jint flags, TRAPS) const;\n-  void verify_legal_field_modifiers(jint flags, bool is_interface, TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const;\n+  void verify_legal_field_modifiers(jint flags,\n+                                    AccessFlags class_access_flags,\n+                                    TRAPS) const;\n@@ -473,1 +506,1 @@\n-                                     bool is_interface,\n+                                     AccessFlags class_access_flags,\n@@ -531,0 +564,3 @@\n+  \/\/ Check if the class file supports inline types\n+  bool supports_inline_types() const;\n+\n@@ -558,0 +594,12 @@\n+  bool is_inline_type() const { return _access_flags.is_value_class() && !_access_flags.is_interface() && !_access_flags.is_abstract(); }\n+  bool is_value_class() const { return _access_flags.is_value_class(); }\n+  bool is_abstract_class() const { return _access_flags.is_abstract(); }\n+  bool is_identity_class() const { return _access_flags.is_identity_class(); }\n+  bool is_value_capable_class() const;\n+  bool has_inline_fields() const { return _has_inline_type_fields; }\n+  bool carries_identity_modifier() const { return _carries_identity_modifier; }\n+  void set_carries_identity_modifier() { _carries_identity_modifier = true; }\n+  bool carries_value_modifier() const { return _carries_value_modifier; }\n+  void set_carries_value_modifier() { _carries_value_modifier = true; }\n+\n+  u2 java_fields_count() const { return _java_fields_count; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":53,"deletions":5,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-    if (*start == JVM_SIGNATURE_CLASS) {\n+    if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -397,0 +398,10 @@\n+void ClassLoaderData::inline_classes_do(void f(InlineKlass*)) {\n+  \/\/ Lock-free access requires load_acquire\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+    if (k->is_inline_klass()) {\n+      f(InlineKlass::cast(k));\n+    }\n+    assert(k != k->next_link(), \"no loops!\");\n+  }\n+}\n+\n@@ -563,0 +574,2 @@\n+  inline_classes_do(InlineKlass::cleanup);\n+\n@@ -866,1 +879,5 @@\n-        MetadataFactory::free_metadata(this, (InstanceKlass*)m);\n+        if (!((Klass*)m)->is_inline_klass()) {\n+          MetadataFactory::free_metadata(this, (InstanceKlass*)m);\n+        } else {\n+          MetadataFactory::free_metadata(this, (InlineKlass*)m);\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+  void inline_classes_do(void f(InlineKlass*));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -54,1 +56,1 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.inline.hpp\"\n@@ -781,0 +783,2 @@\n+int java_lang_Class::_primary_mirror_offset;\n+int java_lang_Class::_secondary_mirror_offset;\n@@ -1004,1 +1008,6 @@\n-      if (k->is_typeArray_klass()) {\n+      if (k->is_flatArray_klass()) {\n+        Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n+        assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n+      } else if (k->is_typeArray_klass()) {\n@@ -1011,1 +1020,6 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        oop comp_oop = element_klass->java_mirror();\n+        if (element_klass->is_inline_klass()) {\n+          InlineKlass* ik = InlineKlass::cast(element_klass);\n+          comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        }\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1051,0 +1065,6 @@\n+\n+    if (k->is_inline_klass()) {\n+      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n+      set_primary_mirror(mirror(), mirror());\n+      set_secondary_mirror(mirror(), secondary_mirror);\n+    }\n@@ -1056,0 +1076,19 @@\n+\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n+\/\/ instance with the same value as the primary mirror\n+oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n+  assert(k->is_inline_klass(), \"primitive class\");\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n+  Handle secondary_mirror(THREAD, mirror_oop);\n+\n+  java_lang_Class::set_klass(secondary_mirror(), k);\n+  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n+\n+  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n+  set_class_loader(secondary_mirror(), class_loader(mirror()));\n+  \/\/ ## handle if java.base is not yet defined\n+  set_module(secondary_mirror(), module(mirror()));\n+  set_primary_mirror(secondary_mirror(), mirror());\n+  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n+  return secondary_mirror();\n+}\n@@ -1103,0 +1142,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1198,0 +1238,6 @@\n+  if (k->is_inline_klass()) {\n+    \/\/ Inline types have a primary mirror and a secondary mirror. Don't handle this for now. TODO:CDS\n+    k->clear_java_mirror_handle();\n+    return NULL;\n+  }\n+\n@@ -1397,0 +1443,20 @@\n+oop java_lang_Class::primary_mirror(oop java_class) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_primary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_primary_mirror_offset, mirror);\n+}\n+\n+oop java_lang_Class::secondary_mirror(oop java_class) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_secondary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n+}\n+\n@@ -1481,0 +1547,1 @@\n+  bool is_Q_descriptor = false;\n@@ -1486,0 +1553,1 @@\n+    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1492,1 +1560,3 @@\n-  if (is_instance)  st->print(\"L\");\n+  if (is_instance)  {\n+    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n+  }\n@@ -1513,2 +1583,7 @@\n-      const char* sigstr = k->signature_name();\n-      int         siglen = (int) strlen(sigstr);\n+      const char* sigstr;\n+      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n+        sigstr = InlineKlass::cast(k)->val_signature_name();\n+      } else {\n+        sigstr = k->signature_name();\n+      }\n+      int siglen = (int) strlen(sigstr);\n@@ -1594,0 +1669,2 @@\n+  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n+  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n@@ -2841,1 +2918,1 @@\n-      if (method->name() == vmSymbols::object_initializer_name() &&\n+      if (method->is_object_constructor() &&\n@@ -4427,1 +4504,1 @@\n-  return (flags(mname) & (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) > 0;\n+  return (flags(mname) & (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) > 0;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":85,"deletions":8,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -231,0 +231,3 @@\n+  static int _primary_mirror_offset;\n+  static int _secondary_mirror_offset;\n+\n@@ -244,0 +247,3 @@\n+  static void set_primary_mirror(oop java_class, oop comp_mirror);\n+  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n+\n@@ -256,0 +262,1 @@\n+  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -290,0 +297,3 @@\n+  static int component_mirror_offset()     { CHECK_INIT(_component_mirror_offset); }\n+  static int primary_mirror_offset()       { CHECK_INIT(_primary_mirror_offset); }\n+  static int secondary_mirror_offset()     { CHECK_INIT(_secondary_mirror_offset); }\n@@ -296,0 +306,5 @@\n+  static oop  primary_mirror(oop java_class);\n+  static oop  secondary_mirror(oop java_class);\n+  static bool is_primary_mirror(oop java_class);\n+  static bool is_secondary_mirror(oop java_class);\n+\n@@ -302,2 +317,0 @@\n-  static int component_mirror_offset() { return _component_mirror_offset; }\n-\n@@ -1309,1 +1322,1 @@\n-    MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ constructor\n+    MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ constructor\n@@ -1314,0 +1327,1 @@\n+    MN_FLATTENED             = 0x00400000, \/\/ flattened field\n@@ -1852,1 +1866,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -294,0 +294,18 @@\n+inline bool java_lang_Class::is_primary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == primary_mirror(java_class);\n+  } else {\n+    return true;\n+  }\n+}\n+\n+inline bool java_lang_Class::is_secondary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == secondary_mirror(java_class);\n+  } else {\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+\/\/ For INLINE_FIELD, set when loading inline type fields for\n+\/\/ class circularity checking.\n@@ -84,0 +86,3 @@\n+    case PlaceholderTable::PRIMITIVE_OBJECT_FIELD:\n+       queuehead = _inlineTypeFieldQ;\n+       break;\n@@ -100,0 +105,3 @@\n+    case PlaceholderTable::PRIMITIVE_OBJECT_FIELD:\n+       _inlineTypeFieldQ = seenthread;\n+       break;\n@@ -187,0 +195,1 @@\n+  entry->set_inlineTypeFieldQ(NULL);\n@@ -267,0 +276,1 @@\n+  case PlaceholderTable::PRIMITIVE_OBJECT_FIELD: return \"PRIMITIVE_OBJECT_FIELD\";\n@@ -332,1 +342,2 @@\n-          && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n+          && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)\n+          && (probe->inlineTypeFieldQ() == NULL)) {\n@@ -387,0 +398,3 @@\n+  st->print(\"inlineTypeFieldQ threads:\");\n+  inlineTypeFieldQ()->print_action_queue(st);\n+  st->cr();\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -192,1 +192,11 @@\n-    return VerificationType::reference_type(_cp->klass_name_at(class_index));\n+    Symbol* klass_name = _cp->klass_name_at(class_index);\n+    if (klass_name->is_Q_signature()) {\n+      Symbol* fund_name = klass_name->fundamental_name(THREAD);\n+      if (fund_name == NULL) {\n+        _stream->stackmap_format_error(\"TBD something bad happened\", THREAD);\n+        return VerificationType::bogus_type();\n+      }\n+      return VerificationType::inline_type(fund_name);\n+    } else {\n+      return VerificationType::reference_type(klass_name);\n+    }\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -68,0 +69,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -75,0 +77,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -279,1 +282,1 @@\n-      \/\/ Ignore wrapping L and ;.\n+      \/\/ Ignore wrapping L and ; (and Q and ; for value types).\n@@ -308,1 +311,8 @@\n-      k = k->array_klass(ndims, CHECK_NULL);\n+      if (class_name->is_Q_array_signature()) {\n+        if (!k->is_inline_klass()) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n+        }\n+        k = InlineKlass::cast(k)->value_array_klass(ndims, CHECK_NULL);\n+      } else {\n+        k = k->array_klass(ndims, CHECK_NULL);\n+      }\n@@ -438,0 +448,44 @@\n+Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,\n+                                                           Handle class_loader,\n+                                                           Handle protection_domain,\n+                                                           bool throw_error,\n+                                                           TRAPS) {\n+  Symbol* class_name = fs->signature()->fundamental_name(THREAD);\n+  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n+  ClassLoaderData* loader_data = class_loader_data(class_loader);\n+  unsigned int p_hash = placeholders()->compute_hash(class_name);\n+  bool throw_circularity_error = false;\n+  PlaceholderEntry* oldprobe;\n+\n+  {\n+    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    oldprobe = placeholders()->get_entry(p_hash, class_name, loader_data);\n+    if (oldprobe != NULL &&\n+      oldprobe->check_seen_thread(THREAD, PlaceholderTable::PRIMITIVE_OBJECT_FIELD)) {\n+      throw_circularity_error = true;\n+\n+    } else {\n+      placeholders()->find_and_add(p_hash, class_name, loader_data,\n+                                   PlaceholderTable::PRIMITIVE_OBJECT_FIELD, NULL, THREAD);\n+    }\n+  }\n+\n+  Klass* klass = NULL;\n+  if (!throw_circularity_error) {\n+    klass = SystemDictionary::resolve_or_fail(class_name, class_loader,\n+                                               protection_domain, true, THREAD);\n+  } else {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name->as_C_string());\n+  }\n+\n+  {\n+    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    placeholders()->find_and_remove(p_hash, class_name, loader_data,\n+                                    PlaceholderTable::PRIMITIVE_OBJECT_FIELD, THREAD);\n+  }\n+\n+  class_name->decrement_refcount();\n+  return klass;\n+}\n+\n@@ -795,1 +849,1 @@\n-    if (t != T_OBJECT) {\n+    if (t != T_OBJECT && t != T_PRIMITIVE_OBJECT) {\n@@ -801,1 +855,5 @@\n-      k = k->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        k = InlineKlass::cast(k)->value_array_klass_or_null(ndims);\n+      } else {\n+        k = k->array_klass_or_null(ndims);\n+      }\n@@ -1152,0 +1210,18 @@\n+\n+  if (ik->has_inline_type_fields()) {\n+    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+        if (!fs.access_flags().is_static()) {\n+          \/\/ Pre-load inline class\n+          Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+            class_loader, protection_domain, true, CHECK_NULL);\n+          Klass* k = ik->get_inline_type_field_klass_or_null(fs.index());\n+          if (real_k != k) {\n+            \/\/ oops, the app has substituted a different version of k!\n+            return NULL;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1187,0 +1263,1 @@\n+\n@@ -1772,1 +1849,1 @@\n-    if (t != T_OBJECT) {\n+    if (t != T_OBJECT && t != T_PRIMITIVE_OBJECT) {\n@@ -1780,1 +1857,5 @@\n-      klass = klass->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        klass = InlineKlass::cast(klass)->value_array_klass_or_null(ndims);\n+      } else {\n+        klass = klass->array_klass_or_null(ndims);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":87,"deletions":6,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class AllFieldStream;\n@@ -137,0 +138,6 @@\n+  static Klass* resolve_inline_type_field_or_fail(AllFieldStream* fs,\n+                                                  Handle class_loader,\n+                                                  Handle protection_domain,\n+                                                  bool throw_error,\n+                                                  TRAPS);\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,3 +71,3 @@\n-      \/\/ Bottom two bits determine if the type is a reference, primitive,\n-      \/\/ uninitialized or a query-type.\n-      TypeMask           = 0x00000003,\n+      \/\/ Bottom three bits determine if the type is a reference, inline type,\n+      \/\/ primitive, uninitialized or a query-type.\n+      TypeMask           = 0x00000007,\n@@ -76,1 +76,1 @@\n-      Reference          = 0x0,        \/\/ _sym contains the name\n+      Reference          = 0x0,        \/\/ _sym contains the name of an object\n@@ -80,0 +80,1 @@\n+      InlineType         = 0x4,        \/\/ _sym contains the name of an inline type\n@@ -86,0 +87,2 @@\n+      InlineTypeFlag     = 0x08,       \/\/ For inline type query types\n+      NonScalarFlag      = 0x10,       \/\/ For either inline type or reference queries\n@@ -117,1 +120,3 @@\n-      Category2_2ndQuery = (Category2_2ndFlag << 1 * BitsPerByte) | TypeQuery\n+      Category2_2ndQuery = (Category2_2ndFlag << 1 * BitsPerByte) | TypeQuery,\n+      InlineTypeQuery    = (InlineTypeFlag    << 1 * BitsPerByte) | TypeQuery,\n+      NonScalarQuery     = (NonScalarFlag     << 1 * BitsPerByte) | TypeQuery\n@@ -150,0 +155,2 @@\n+  static VerificationType inline_type_check()\n+    { return VerificationType(InlineTypeQuery); }\n@@ -156,0 +163,2 @@\n+  static VerificationType nonscalar_check()\n+    { return VerificationType(NonScalarQuery); }\n@@ -159,1 +168,1 @@\n-      assert(((uintptr_t)sh & 0x3) == 0, \"Symbols must be aligned\");\n+      assert(((uintptr_t)sh & TypeMask) == 0, \"Symbols must be aligned\");\n@@ -170,0 +179,11 @@\n+  \/\/ For inline types, store the actual Symbol* and set the 3rd bit.\n+  \/\/ Provides a way for an inline type to be distinguished from a reference type.\n+  static VerificationType inline_type(Symbol* sh) {\n+      assert(((uintptr_t)sh & TypeMask) == 0, \"Symbols must be aligned\");\n+      assert((uintptr_t)sh != 0, \"Null is not a valid inline type\");\n+      \/\/ If the above assert fails in the future because oop* isn't aligned,\n+      \/\/ then this type encoding system will have to change to have a tag value\n+      \/\/ to discriminate between oops and primitives.\n+      return VerificationType((uintptr_t)sh | InlineType);\n+  }\n+\n@@ -185,1 +205,2 @@\n-  bool is_reference() const { return ((_u._data & TypeMask) == Reference); }\n+  bool is_reference() const { return (((_u._data & TypeMask) == Reference) && !is_inline_type_check()); }\n+  bool is_inline_type() const { return ((_u._data & TypeMask) == InlineType); }\n@@ -188,2 +209,2 @@\n-    \/\/ primitives, and references (including uninitialized refs).  Though\n-    \/\/ the 'query' types should technically return 'false' here, if we\n+    \/\/ primitives, references (including uninitialized refs) and inline types.\n+    \/\/ Though the 'query' types should technically return 'false' here, if we\n@@ -203,0 +224,2 @@\n+  bool is_inline_type_check() const { return _u._data == InlineTypeQuery; }\n+  bool is_nonscalar_check() const { return _u._data == NonScalarQuery; }\n@@ -221,0 +244,1 @@\n+  bool is_inline_type_array() const { return is_x_array(JVM_SIGNATURE_PRIMITIVE_OBJECT); }\n@@ -223,0 +247,2 @@\n+  bool is_nonscalar_array() const\n+    { return is_object_array() || is_array_array() || is_inline_type_array(); }\n@@ -239,0 +265,6 @@\n+  static VerificationType change_ref_to_inline_type(VerificationType ref) {\n+    assert(ref.is_reference(), \"Bad arg\");\n+    assert(!ref.is_null(), \"Unexpected NULL\");\n+    return inline_type(ref.name());\n+  }\n+\n@@ -245,2 +277,2 @@\n-    assert(is_reference() && !is_null(), \"Must be a non-null reference\");\n-    return _u._sym;\n+    assert(!is_null() && (is_reference() || is_inline_type()), \"Must be a non-null reference or an inline type\");\n+    return (is_reference() ? _u._sym : ((Symbol*)(_u._data & ~(uintptr_t)InlineType)));\n@@ -251,2 +283,4 @@\n-      (is_reference() && t.is_reference() && !is_null() && !t.is_null() &&\n-       name() == t.name()));\n+            (((is_reference() && t.is_reference()) ||\n+             (is_inline_type() && t.is_inline_type())) &&\n+              !is_null() && !t.is_null() && name() == t.name()));\n+\n@@ -281,0 +315,5 @@\n+        case NonScalarQuery:\n+          return from.is_reference() || from.is_uninitialized() ||\n+                 from.is_inline_type();\n+        case InlineTypeQuery:\n+          return from.is_inline_type();\n@@ -288,1 +327,5 @@\n-          if (is_reference() && from.is_reference()) {\n+          if (is_inline_type()) {\n+            return is_inline_type_assignable_from(from);\n+          } else if (is_reference() && from.is_inline_type()) {\n+            return is_ref_assignable_from_inline_type(from, context, THREAD);\n+          } else if (is_reference() && from.is_reference()) {\n@@ -336,0 +379,5 @@\n+  bool is_inline_type_assignable_from(const VerificationType& from) const;\n+\n+  bool is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const;\n+\n+\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":62,"deletions":14,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#define INLINE_TYPE_MAJOR_VERSION                       56\n@@ -278,1 +279,1 @@\n-    \/\/ We need to skip the following four for bootstraping\n+    \/\/ We need to skip the following four for bootstrapping\n@@ -501,0 +502,7 @@\n+    case WRONG_INLINE_TYPE:\n+      ss->print(\"Type \");\n+      _type.details(ss);\n+      ss->print(\" and type \");\n+      _expected.details(ss);\n+      ss->print(\" must be identical inline types.\");\n+      break;\n@@ -595,0 +603,8 @@\n+VerificationType reference_or_inline_type(InstanceKlass* klass) {\n+  if (klass->is_inline_klass()) {\n+    return VerificationType::inline_type(klass->name());\n+  } else {\n+    return VerificationType::reference_type(klass->name());\n+  }\n+}\n+\n@@ -598,1 +614,1 @@\n-  _this_type = VerificationType::reference_type(klass->name());\n+  _this_type = reference_or_inline_type(klass);\n@@ -1038,1 +1054,1 @@\n-          if (!atype.is_reference_array()) {\n+          if (!atype.is_nonscalar_array()) {\n@@ -1211,1 +1227,1 @@\n-          if (!atype.is_reference_array()) {\n+          if (!atype.is_nonscalar_array()) {\n@@ -1611,1 +1627,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1616,1 +1632,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1667,1 +1683,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1679,1 +1695,1 @@\n-          if (_method->name() == vmSymbols::object_initializer_name() &&\n+          if (_method->is_object_constructor() &&\n@@ -1699,0 +1715,11 @@\n+        case Bytecodes::_withfield :\n+          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n+            class_format_error(\n+              \"withfield not supported by this class file version (%d.%d), class %s\",\n+              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n+            return;\n+          }\n+          \/\/ pass FALSE, operand can't be an array type for withfield.\n+          verify_field_instructions(\n+            &bcs, &current_frame, cp, false, CHECK_VERIFY(this));\n+          no_control_flow = false; break;\n@@ -1702,4 +1729,0 @@\n-          verify_invoke_instructions(\n-            &bcs, code_length, &current_frame, (bci >= ex_min && bci < ex_max),\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n-          no_control_flow = false; break;\n@@ -1710,1 +1733,1 @@\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n+            &this_uninit, cp, &stackmap_table, CHECK_VERIFY(this));\n@@ -1728,0 +1751,22 @@\n+        case Bytecodes::_aconst_init :\n+        {\n+          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n+            class_format_error(\n+              \"aconst_init not supported by this class file version (%d.%d), class %s\",\n+              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n+            return;\n+          }\n+          index = bcs.get_index_u2();\n+          verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));\n+          VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));\n+          if (!ref_type.is_object()) {\n+            verify_error(ErrorContext::bad_type(bci,\n+                TypeOrigin::cp(index, ref_type)),\n+                \"Illegal aconst_init instruction\");\n+            return;\n+          }\n+          VerificationType inline_type =\n+            VerificationType::change_ref_to_inline_type(ref_type);\n+          current_frame.push_stack(inline_type, CHECK_VERIFY(this));\n+          no_control_flow = false; break;\n+        }\n@@ -1768,3 +1813,3 @@\n-        case Bytecodes::_monitorexit :\n-          current_frame.pop_stack(\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+        case Bytecodes::_monitorexit : {\n+          VerificationType ref = current_frame.pop_stack(\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1772,0 +1817,1 @@\n+        }\n@@ -2036,0 +2082,1 @@\n+\n@@ -2150,1 +2197,1 @@\n-            | (1 << JVM_CONSTANT_String)  | (1 << JVM_CONSTANT_Class)\n+            | (1 << JVM_CONSTANT_String) | (1 << JVM_CONSTANT_Class)\n@@ -2325,1 +2372,1 @@\n-    (!allow_arrays || !ref_class_type.is_array())) {\n+      (!allow_arrays || !ref_class_type.is_array())) {\n@@ -2332,0 +2379,1 @@\n+\n@@ -2361,0 +2409,11 @@\n+    case Bytecodes::_withfield: {\n+      for (int i = n - 1; i >= 0; i--) {\n+        current_frame->pop_stack(field_type[i], CHECK_VERIFY(this));\n+      }\n+      \/\/ Check that the receiver is a subtype of the referenced class.\n+      current_frame->pop_stack(target_class_type, CHECK_VERIFY(this));\n+      VerificationType target_inline_type =\n+        VerificationType::change_ref_to_inline_type(target_class_type);\n+      current_frame->push_stack(target_inline_type, CHECK_VERIFY(this));\n+      break;\n+    }\n@@ -2782,1 +2841,1 @@\n-    bool in_try_block, bool *this_uninit, VerificationType return_type,\n+    bool in_try_block, bool *this_uninit,\n@@ -2814,1 +2873,1 @@\n-  \/\/ Get referenced class type\n+  \/\/ Get referenced class\n@@ -2880,2 +2939,4 @@\n-    \/\/ Make sure <init> can only be invoked by invokespecial\n-    if (opcode != Bytecodes::_invokespecial ||\n+    \/\/ Make sure <init> can only be invoked by invokespecial or invokestatic.\n+    \/\/ The allowed invocation mode of <init> depends on its signature.\n+    if ((opcode != Bytecodes::_invokespecial &&\n+         opcode != Bytecodes::_invokestatic) ||\n@@ -2890,1 +2951,1 @@\n-                  current_class()->super()->name()))) {\n+                  current_class()->super()->name()))) { \/\/ super() can never be an inline_type.\n@@ -2922,0 +2983,1 @@\n+      \/\/ (use of <init> as a static factory is handled under invokestatic)\n@@ -2974,4 +3036,3 @@\n-    if (method_name == vmSymbols::object_initializer_name()) {\n-      \/\/ <init> method must have a void return type\n-      \/* Unreachable?  Class file parser verifies that methods with '<' have\n-       * void return *\/\n+    if (method_name == vmSymbols::object_initializer_name() &&\n+        opcode != Bytecodes::_invokestatic) {\n+      \/\/ an <init> method must have a void return type, unless it's a static factory\n@@ -2990,0 +3051,8 @@\n+  } else {\n+    \/\/ an <init> method may not have a void return type, if it's a static factory\n+    if (method_name == vmSymbols::object_initializer_name() &&\n+        opcode != Bytecodes::_invokespecial) {\n+      verify_error(ErrorContext::bad_code(bci),\n+          \"Return type must be non-void in <init> static factory method\");\n+      return;\n+    }\n@@ -3037,1 +3106,2 @@\n-    \/\/ add one dimension to component with 'L' prepended and ';' postpended.\n+    char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_PRIMITIVE_OBJECT : JVM_SIGNATURE_CLASS;\n+    \/\/ add one dimension to component with 'L' or 'Q' prepended and ';' appended.\n@@ -3041,1 +3111,1 @@\n-                         JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);\n+                         JVM_SIGNATURE_ARRAY, Q_or_L, component_name);\n@@ -3083,1 +3153,1 @@\n-    index, VerificationType::reference_check(), CHECK_VERIFY(this));\n+    index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -3120,1 +3190,1 @@\n-    VerificationType::reference_check(), CHECK_VERIFY(this));\n+    VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":101,"deletions":31,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    DYNAMICCONSTANT_MAJOR_VERSION       = 55\n+    DYNAMICCONSTANT_MAJOR_VERSION       = 55,\n@@ -158,0 +158,1 @@\n+    WRONG_INLINE_TYPE,    \/\/ Mismatched inline type\n@@ -221,0 +222,3 @@\n+  static ErrorContext bad_inline_type(u2 bci, TypeOrigin type, TypeOrigin exp) {\n+    return ErrorContext(bci, WRONG_INLINE_TYPE, type, exp);\n+  }\n@@ -351,1 +355,1 @@\n-    bool in_try_block, bool* this_uninit, VerificationType return_type,\n+    bool in_try_block, bool* this_uninit,\n@@ -448,1 +452,8 @@\n-    return VerificationType::reference_type(cp->klass_name_at(index));\n+    Symbol* name = cp->klass_name_at(index);\n+    if (name->is_Q_signature()) {\n+      \/\/ Remove the Q and ;\n+      \/\/ TBD need error msg if fundamental_name() returns NULL?\n+      Symbol* fund_name = name->fundamental_name(CHECK_(VerificationType::bogus_type()));\n+      return VerificationType::inline_type(fund_name);\n+    }\n+    return VerificationType::reference_type(name);\n@@ -486,2 +497,10 @@\n-        *inference_type =\n-          VerificationType::reference_type(name_copy);\n+        *inference_type = VerificationType::reference_type(name_copy);\n+        return 1;\n+      }\n+    case T_PRIMITIVE_OBJECT:\n+      {\n+        Symbol* vname = sig_type->as_symbol();\n+        \/\/ Create another symbol to save as signature stream unreferences this symbol.\n+        Symbol* vname_copy = create_temporary_symbol(vname);\n+        assert(vname_copy == vname, \"symbols don't match\");\n+        *inference_type = VerificationType::inline_type(vname_copy);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  do_klass(PrimitiveObjectMethods_klass,                java_lang_runtime_PrimitiveObjectMethods              ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -248,0 +248,2 @@\n+  case vmIntrinsics::_asPrimaryType:\n+  case vmIntrinsics::_asValueType:\n@@ -318,0 +320,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:\n+  case vmIntrinsics::_finishPrivateBuffer:\n@@ -327,0 +331,1 @@\n+  case vmIntrinsics::_getValue:\n@@ -336,0 +341,1 @@\n+  case vmIntrinsics::_putValue:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -287,0 +287,4 @@\n+  do_intrinsic(_asPrimaryType,            java_lang_Class,        asPrimaryType_name, void_class_signature,      F_R)   \\\n+   do_name(     asPrimaryType_name,                              \"asPrimaryType\")                                       \\\n+  do_intrinsic(_asValueType,              java_lang_Class,        asValueType_name, void_class_signature,        F_R)   \\\n+   do_name(     asValueType_name,                                \"asValueType\")                                         \\\n@@ -623,0 +627,2 @@\n+  do_signature(getValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;)Ljava\/lang\/Object;\")                   \\\n+  do_signature(putValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;Ljava\/lang\/Object;)V\")                  \\\n@@ -633,0 +639,3 @@\n+  do_name(getValue_name,\"getValue\")             do_name(putValue_name,\"putValue\")                                       \\\n+  do_name(makePrivateBuffer_name,\"makePrivateBuffer\")                                                                   \\\n+  do_name(finishPrivateBuffer_name,\"finishPrivateBuffer\")                                                               \\\n@@ -643,0 +652,1 @@\n+  do_intrinsic(_getValue,           jdk_internal_misc_Unsafe,     getValue_name, getValue_signature,             F_RN)  \\\n@@ -652,0 +662,4 @@\n+  do_intrinsic(_putValue,           jdk_internal_misc_Unsafe,     putValue_name, putValue_signature,             F_RN)  \\\n+                                                                                                                        \\\n+  do_intrinsic(_makePrivateBuffer,  jdk_internal_misc_Unsafe,     makePrivateBuffer_name, object_object_signature, F_RN)   \\\n+  do_intrinsic(_finishPrivateBuffer,  jdk_internal_misc_Unsafe,   finishPrivateBuffer_name, object_object_signature, F_RN) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  template(java_lang_NonTearable,                     \"java\/lang\/NonTearable\")                    \\\n@@ -180,0 +181,1 @@\n+  template(tag_preload,                               \"Preload\")                                  \\\n@@ -529,0 +531,2 @@\n+  template(default_value_name,                        \".default\")                                 \\\n+  template(empty_marker_name,                         \".empty\")                                   \\\n@@ -615,0 +619,1 @@\n+  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\") \\\n@@ -752,0 +757,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n@@ -778,0 +785,4 @@\n+  template(java_lang_runtime_PrimitiveObjectMethods,        \"java\/lang\/runtime\/PrimitiveObjectMethods\")           \\\n+  template(isSubstitutable_name,                            \"isSubstitutable\")                                    \\\n+  template(primitiveObjectHashCode_name,                    \"primitiveObjectHashCode\")                            \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -270,2 +270,2 @@\n-BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)\n-  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)\n+BufferBlob::BufferBlob(const char* name, int header_size, int size, CodeBuffer* cb)\n+  : RuntimeBlob(name, cb, header_size, size, CodeOffsets::frame_never_safe, 0, NULL)\n@@ -282,1 +282,1 @@\n-    blob = new (size) BufferBlob(name, size, cb);\n+    blob = new (size) BufferBlob(name, sizeof(BufferBlob), size, cb);\n@@ -298,0 +298,4 @@\n+BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments)\n+  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)\n+{}\n+\n@@ -302,2 +306,2 @@\n-AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :\n-  BufferBlob(\"I2C\/C2I adapters\", size, cb) {\n+AdapterBlob::AdapterBlob(int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+  BufferBlob(\"I2C\/C2I adapters\", size, cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {\n@@ -307,1 +311,1 @@\n-AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {\n+AdapterBlob* AdapterBlob::create(CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) {\n@@ -314,1 +318,1 @@\n-    blob = new (size) AdapterBlob(size, cb);\n+    blob = new (size) AdapterBlob(size, cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);\n@@ -392,0 +396,25 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of BufferedInlineTypeBlob\n+BufferedInlineTypeBlob::BufferedInlineTypeBlob(int size, CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off) :\n+  BufferBlob(\"buffered inline type\", sizeof(BufferedInlineTypeBlob), size, cb),\n+  _pack_fields_off(pack_fields_off),\n+  _pack_fields_jobject_off(pack_fields_jobject_off),\n+  _unpack_fields_off(unpack_fields_off) {\n+  CodeCache::commit(this);\n+}\n+\n+BufferedInlineTypeBlob* BufferedInlineTypeBlob::create(CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  BufferedInlineTypeBlob* blob = NULL;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferedInlineTypeBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) BufferedInlineTypeBlob(size, cb, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  virtual bool is_buffered_inline_type_blob() const   { return false; }\n@@ -412,0 +413,1 @@\n+  friend class BufferedInlineTypeBlob;\n@@ -418,1 +420,2 @@\n-  BufferBlob(const char* name, int size, CodeBuffer* cb);\n+  BufferBlob(const char* name, int header_size, int size, CodeBuffer* cb);\n+  BufferBlob(const char* name, int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments = false);\n@@ -451,1 +454,1 @@\n-  AdapterBlob(int size, CodeBuffer* cb);\n+  AdapterBlob(int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments = false);\n@@ -455,1 +458,5 @@\n-  static AdapterBlob* create(CodeBuffer* cb);\n+  static AdapterBlob* create(CodeBuffer* cb,\n+                             int frame_complete,\n+                             int frame_size,\n+                             OopMapSet* oop_maps,\n+                             bool caller_must_gc_arguments = false);\n@@ -459,0 +466,2 @@\n+\n+  bool caller_must_gc_arguments(JavaThread* thread) const { return true; }\n@@ -491,0 +500,22 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ BufferedInlineTypeBlob : used for pack\/unpack handlers\n+\n+class BufferedInlineTypeBlob: public BufferBlob {\n+private:\n+  const int _pack_fields_off;\n+  const int _pack_fields_jobject_off;\n+  const int _unpack_fields_off;\n+\n+  BufferedInlineTypeBlob(int size, CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off);\n+\n+public:\n+  \/\/ Creation\n+  static BufferedInlineTypeBlob* create(CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off);\n+\n+  address pack_fields() const { return code_begin() + _pack_fields_off; }\n+  address pack_fields_jobject() const { return code_begin() + _pack_fields_jobject_off; }\n+  address unpack_fields() const { return code_begin() + _unpack_fields_off; }\n+\n+  \/\/ Typing\n+  virtual bool is_buffered_inline_type_blob() const { return true; }\n+};\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-                                    bool& needs_ic_stub_refill, TRAPS) {\n+                                    bool& needs_ic_stub_refill, bool caller_is_c1, TRAPS) {\n@@ -257,1 +257,1 @@\n-    entry = VtableStubs::find_itable_stub(itable_index);\n+    entry = VtableStubs::find_itable_stub(itable_index, caller_is_c1);\n@@ -280,1 +280,1 @@\n-    entry = VtableStubs::find_vtable_stub(vtable_index);\n+    entry = VtableStubs::find_vtable_stub(vtable_index, caller_is_c1);\n@@ -514,0 +514,1 @@\n+                                           bool caller_is_c1,\n@@ -539,1 +540,1 @@\n-      entry      = method_code->verified_entry_point();\n+      entry      = caller_is_c1 ? method_code->verified_inline_entry_point() : method_code->verified_entry_point();\n@@ -541,1 +542,1 @@\n-      entry      = method_code->entry_point();\n+      entry      = caller_is_c1 ? method_code->inline_entry_point() : method_code->entry_point();\n@@ -550,1 +551,2 @@\n-      info.set_interpreter_entry(method()->get_c2i_entry(), method());\n+      address entry = caller_is_c1 ? method()->get_c2i_inline_entry() : method()->get_c2i_entry();\n+      info.set_interpreter_entry(entry, method());\n@@ -555,1 +557,2 @@\n-      info.set_icholder_entry(method()->get_c2i_unverified_entry(), holder);\n+      entry = (caller_is_c1)? method()->get_c2i_unverified_inline_entry() : method()->get_c2i_unverified_entry();\n+      info.set_icholder_entry(entry, holder);\n@@ -642,1 +645,2 @@\n-void CompiledStaticCall::compute_entry(const methodHandle& m, bool caller_is_nmethod, StaticCallInfo& info) {\n+void CompiledStaticCall::compute_entry(const methodHandle& m, CompiledMethod* caller_nm, StaticCallInfo& info) {\n+  bool caller_is_nmethod = caller_nm->is_nmethod();\n@@ -647,1 +651,5 @@\n-    info._entry  = m_code->verified_entry_point();\n+    if (caller_nm->is_compiled_by_c1()) {\n+      info._entry = m_code->verified_inline_entry_point();\n+    } else {\n+      info._entry = m_code->verified_entry_point();\n+    }\n@@ -653,1 +661,8 @@\n-    info._entry      = m()->get_c2i_entry();\n+\n+    if (caller_nm->is_compiled_by_c1()) {\n+      \/\/ C1 -> interp: values passed as oops\n+      info._entry = m()->get_c2i_inline_entry();\n+    } else {\n+      \/\/ C2 -> interp: values passed fields\n+      info._entry = m()->get_c2i_entry();\n+    }\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  bool set_to_megamorphic(CallInfo* call_info, Bytecodes::Code bytecode, bool& needs_ic_stub_refill, TRAPS);\n+  bool set_to_megamorphic(CallInfo* call_info, Bytecodes::Code bytecode, bool& needs_ic_stub_refill, bool caller_is_c1, TRAPS);\n@@ -268,1 +268,1 @@\n-                                        CompiledICInfo& info, TRAPS);\n+                                        bool caller_is_c1, CompiledICInfo& info, TRAPS);\n@@ -316,1 +316,1 @@\n-\/\/    compilled code <------------> interpreted code\n+\/\/    compiled code <------------> interpreted code\n@@ -347,1 +347,1 @@\n-  static void compute_entry(const methodHandle& m, bool caller_is_nmethod, StaticCallInfo& info);\n+  static void compute_entry(const methodHandle& m, CompiledMethod* caller_nm, StaticCallInfo& info);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -388,1 +388,12 @@\n-      signature    = callee->signature();\n+      signature = callee->signature();\n+\n+      \/\/ If inline types are passed as fields, use the extended signature\n+      \/\/ which contains the types of all (oop) fields of the inline type.\n+      if (is_compiled_by_c2() && callee->has_scalarized_args()) {\n+        const GrowableArray<SigEntry>* sig = callee->adapter()->get_sig_cc();\n+        assert(sig != NULL, \"sig should never be null\");\n+        TempNewSymbol tmp_sig = SigEntry::create_symbol(sig);\n+        has_receiver = false; \/\/ The extended signature contains the receiver type\n+        fr.oops_compiled_arguments_do(tmp_sig, has_receiver, has_appendix, reg_map, f);\n+        return;\n+      }\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -203,0 +203,10 @@\n+  bool  needs_stack_repair() const {\n+    if (is_compiled_by_c1()) {\n+      return method()->c1_needs_stack_repair();\n+    } else if (is_compiled_by_c2()) {\n+      return method()->c2_needs_stack_repair();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n@@ -219,0 +229,2 @@\n+  virtual address verified_inline_entry_point() const = 0;\n+  virtual address verified_inline_ro_entry_point() const = 0;\n@@ -225,0 +237,1 @@\n+  virtual address inline_entry_point() const = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+  _is_init = read_from(stream);\n@@ -170,0 +171,5 @@\n+    if (_is_init == NULL) {\n+      \/\/ MarkerValue is used for null-free objects\n+      _is_init = new MarkerValue();\n+    }\n+    _is_init->write_on(stream);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  ScopeValue*                _is_init;\n@@ -130,1 +131,1 @@\n-  ObjectValue(int id, ScopeValue* klass)\n+  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = NULL)\n@@ -133,0 +134,1 @@\n+     , _is_init(is_init)\n@@ -142,0 +144,1 @@\n+     , _is_init(NULL)\n@@ -150,0 +153,1 @@\n+  ScopeValue*                 is_init() const           { return _is_init; }\n@@ -155,0 +159,1 @@\n+  bool                        maybe_null() const        { return !_is_init->is_marker(); }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+                                              bool        return_scalarized,\n@@ -309,0 +310,1 @@\n+  last_pd->set_return_scalarized(return_scalarized);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+                      bool        return_scalarized = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -654,0 +654,6 @@\n+\n+    assert(!method->has_scalarized_args(), \"scalarized native wrappers not supported yet\"); \/\/ for the next 3 fields\n+    _inline_entry_point       = _entry_point;\n+    _verified_inline_entry_point = _verified_entry_point;\n+    _verified_inline_ro_entry_point = _verified_entry_point;\n+\n@@ -830,0 +836,3 @@\n+    _inline_entry_point       = code_begin()         + offsets->value(CodeOffsets::Inline_Entry);\n+    _verified_inline_entry_point = code_begin()      + offsets->value(CodeOffsets::Verified_Inline_Entry);\n+    _verified_inline_ro_entry_point = code_begin()   + offsets->value(CodeOffsets::Verified_Inline_Entry_RO);\n@@ -3247,0 +3256,1 @@\n+  if (pos == inline_entry_point())                                      label = \"[Inline Entry Point]\";\n@@ -3248,0 +3258,2 @@\n+  if (pos == verified_inline_entry_point())                             label = \"[Verified Inline Entry Point]\";\n+  if (pos == verified_inline_ro_entry_point())                          label = \"[Verified Inline Entry Point (RO)]\";\n@@ -3257,0 +3269,10 @@\n+static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {\n+  if (pos == entry) {\n+    stream->bol();\n+    stream->print_cr(\"%s\", label);\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n@@ -3259,33 +3281,12 @@\n-    const char* label = nmethod_section_label(block_begin);\n-    if (label != NULL) {\n-      stream->bol();\n-      stream->print_cr(\"%s\", label);\n-    }\n-  }\n-\n-  if (block_begin == entry_point()) {\n-    Method* m = method();\n-    if (m != NULL) {\n-      stream->print(\"  # \");\n-      m->print_value_on(stream);\n-      stream->cr();\n-    }\n-    if (m != NULL && !is_osr_method()) {\n-      ResourceMark rm;\n-      int sizeargs = m->size_of_parameters();\n-      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);\n-      VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);\n-      {\n-        int sig_index = 0;\n-        if (!m->is_static())\n-          sig_bt[sig_index++] = T_OBJECT; \/\/ 'this'\n-        for (SignatureStream ss(m->signature()); !ss.at_return_type(); ss.next()) {\n-          BasicType t = ss.type();\n-          sig_bt[sig_index++] = t;\n-          if (type2size[t] == 2) {\n-            sig_bt[sig_index++] = T_VOID;\n-          } else {\n-            assert(type2size[t] == 1, \"size is 1 or 2\");\n-          }\n-        }\n-        assert(sig_index == sizeargs, \"\");\n+    int n = 0;\n+    \/\/ Multiple entry points may be at the same position. Print them all.\n+    n += maybe_print_entry_label(stream, block_begin, entry_point(),                    \"[Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             \"[Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),           \"[Verified Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    \"[Verified Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), \"[Verified Inline Entry Point (RO)]\");\n+    if (n == 0) {\n+      const char* label = nmethod_section_label(block_begin);\n+      if (label != NULL) {\n+        stream->bol();\n+        stream->print_cr(\"%s\", label);\n@@ -3293,54 +3294,63 @@\n-      const char* spname = \"sp\"; \/\/ make arch-specific?\n-      intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n-      int stack_slot_offset = this->frame_size() * wordSize;\n-      int tab1 = 14, tab2 = 24;\n-      int sig_index = 0;\n-      int arg_index = (m->is_static() ? 0 : -1);\n-      bool did_old_sp = false;\n-      for (SignatureStream ss(m->signature()); !ss.at_return_type(); ) {\n-        bool at_this = (arg_index == -1);\n-        bool at_old_sp = false;\n-        BasicType t = (at_this ? T_OBJECT : ss.type());\n-        assert(t == sig_bt[sig_index], \"sigs in sync\");\n-        if (at_this)\n-          stream->print(\"  # this: \");\n-        else\n-          stream->print(\"  # parm%d: \", arg_index);\n-        stream->move_to(tab1);\n-        VMReg fst = regs[sig_index].first();\n-        VMReg snd = regs[sig_index].second();\n-        if (fst->is_reg()) {\n-          stream->print(\"%s\", fst->name());\n-          if (snd->is_valid())  {\n-            stream->print(\":%s\", snd->name());\n-          }\n-        } else if (fst->is_stack()) {\n-          int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n-          if (offset == stack_slot_offset)  at_old_sp = true;\n-          stream->print(\"[%s+0x%x]\", spname, offset);\n-        } else {\n-          stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n-        }\n-        stream->print(\" \");\n-        stream->move_to(tab2);\n-        stream->print(\"= \");\n-        if (at_this) {\n-          m->method_holder()->print_value_on(stream);\n-        } else {\n-          bool did_name = false;\n-          if (!at_this && ss.is_reference()) {\n-            Symbol* name = ss.as_symbol();\n-            name->print_value_on(stream);\n-            did_name = true;\n-          }\n-          if (!did_name)\n-            stream->print(\"%s\", type2name(t));\n-        }\n-        if (at_old_sp) {\n-          stream->print(\"  (%s of caller)\", spname);\n-          did_old_sp = true;\n-        }\n-        stream->cr();\n-        sig_index += type2size[t];\n-        arg_index += 1;\n-        if (!at_this)  ss.next();\n+    }\n+  }\n+\n+  Method* m = method();\n+  if (m == NULL || is_osr_method()) {\n+    return;\n+  }\n+\n+  \/\/ Print the name of the method (only once)\n+  address low = MIN4(entry_point(), verified_entry_point(), verified_inline_entry_point(), verified_inline_ro_entry_point());\n+  low = MIN2(low, inline_entry_point());\n+  assert(low != 0, \"sanity\");\n+  if (block_begin == low) {\n+    stream->print(\"  # \");\n+    m->print_value_on(stream);\n+    stream->cr();\n+  }\n+\n+  \/\/ Print the arguments for the 3 types of verified entry points\n+  CompiledEntrySignature ces(m);\n+  ces.compute_calling_conventions();\n+  const GrowableArray<SigEntry>* sig_cc;\n+  const VMRegPair* regs;\n+  if (block_begin == verified_entry_point()) {\n+    sig_cc = &ces.sig_cc();\n+    regs = ces.regs_cc();\n+  } else if (block_begin == verified_inline_entry_point()) {\n+    sig_cc = &ces.sig();\n+    regs = ces.regs();\n+  } else if (block_begin == verified_inline_ro_entry_point()) {\n+    sig_cc = &ces.sig_cc_ro();\n+    regs = ces.regs_cc_ro();\n+  } else {\n+    return;\n+  }\n+\n+  bool has_this = !m->is_static();\n+  if (ces.has_inline_recv() && block_begin == verified_entry_point()) {\n+    \/\/ <this> argument is scalarized for verified_entry_point()\n+    has_this = false;\n+  }\n+  const char* spname = \"sp\"; \/\/ make arch-specific?\n+  int stack_slot_offset = this->frame_size() * wordSize;\n+  int tab1 = 14, tab2 = 24;\n+  int sig_index = 0;\n+  int arg_index = has_this ? -1 : 0;\n+  bool did_old_sp = false;\n+  for (ExtendedSignature sig = ExtendedSignature(sig_cc, SigEntryFilter()); !sig.at_end(); ++sig) {\n+    bool at_this = (arg_index == -1);\n+    bool at_old_sp = false;\n+    BasicType t = (*sig)._bt;\n+    if (at_this) {\n+      stream->print(\"  # this: \");\n+    } else {\n+      stream->print(\"  # parm%d: \", arg_index);\n+    }\n+    stream->move_to(tab1);\n+    VMReg fst = regs[sig_index].first();\n+    VMReg snd = regs[sig_index].second();\n+    if (fst->is_reg()) {\n+      stream->print(\"%s\", fst->name());\n+      if (snd->is_valid())  {\n+        stream->print(\":%s\", snd->name());\n@@ -3348,6 +3358,18 @@\n-      if (!did_old_sp) {\n-        stream->print(\"  # \");\n-        stream->move_to(tab1);\n-        stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n-        stream->print(\"  (%s of caller)\", spname);\n-        stream->cr();\n+    } else if (fst->is_stack()) {\n+      int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n+      if (offset == stack_slot_offset)  at_old_sp = true;\n+      stream->print(\"[%s+0x%x]\", spname, offset);\n+    } else {\n+      stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n+    }\n+    stream->print(\" \");\n+    stream->move_to(tab2);\n+    stream->print(\"= \");\n+    if (at_this) {\n+      m->method_holder()->print_value_on(stream);\n+    } else {\n+      bool did_name = false;\n+      if (is_reference_type(t)) {\n+        Symbol* name = (*sig)._symbol;\n+        name->print_value_on(stream);\n+        did_name = true;\n@@ -3355,0 +3377,2 @@\n+      if (!did_name)\n+        stream->print(\"%s\", type2name(t));\n@@ -3356,0 +3380,14 @@\n+    if (at_old_sp) {\n+      stream->print(\"  (%s of caller)\", spname);\n+      did_old_sp = true;\n+    }\n+    stream->cr();\n+    sig_index += type2size[t];\n+    arg_index += 1;\n+  }\n+  if (!did_old_sp) {\n+    stream->print(\"  # \");\n+    stream->move_to(tab1);\n+    stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n+    stream->print(\"  (%s of caller)\", spname);\n+    stream->cr();\n@@ -3479,1 +3517,1 @@\n-      st->print(\" {reexecute=%d rethrow=%d return_oop=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop());\n+      st->print(\" {reexecute=%d rethrow=%d return_oop=%d return_scalarized=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop(), sd->return_scalarized());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":132,"deletions":94,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/compilerDefinitions.hpp\"\n@@ -199,0 +200,3 @@\n+  address _inline_entry_point;               \/\/ inline type entry point (unpack all inline type args) with class check\n+  address _verified_inline_entry_point;      \/\/ inline type entry point (unpack all inline type args) without class check\n+  address _verified_inline_ro_entry_point;   \/\/ inline type entry point (unpack receiver only) without class check\n@@ -451,2 +455,5 @@\n-  address entry_point() const                     { return _entry_point;             } \/\/ normal entry point\n-  address verified_entry_point() const            { return _verified_entry_point;    } \/\/ if klass is correct\n+  address entry_point() const                     { return _entry_point;             }        \/\/ normal entry point\n+  address verified_entry_point() const            { return _verified_entry_point;    }        \/\/ normal entry point without class check\n+  address inline_entry_point() const              { return _inline_entry_point; }             \/\/ inline type entry point (unpack all inline type args)\n+  address verified_inline_entry_point() const     { return _verified_inline_entry_point; }    \/\/ inline type entry point (unpack all inline type args) without class check\n+  address verified_inline_ro_entry_point() const  { return _verified_inline_ro_entry_point; } \/\/ inline type entry point (only unpack receiver) without class check\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-    PCDESC_arg_escape                = 1 << 5\n+    PCDESC_arg_escape                = 1 << 5,\n+    PCDESC_return_scalarized         = 1 << 6\n@@ -94,0 +95,2 @@\n+  bool     return_scalarized()             const { return (_flags & PCDESC_return_scalarized) != 0; }\n+  void set_return_scalarized(bool z)             { set_flag(PCDESC_return_scalarized, z); }\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  bool return_scalarized() const { return _return_scalarized; }\n@@ -108,0 +109,1 @@\n+  bool          _return_scalarized;\n@@ -111,1 +113,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1273,1 +1273,1 @@\n-          if (vfst.method()->is_static_initializer() ||\n+        if (vfst.method()->is_class_initializer() ||\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -475,0 +475,2 @@\n+    case Bytecodes::_aconst_init:\n+    case Bytecodes::_withfield:\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  assert(bt == T_OBJECT, \"or we shouldn't be here\");\n+  assert(bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT, \"or we shouldn't be here\");\n@@ -667,1 +667,1 @@\n-void G1BarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n+void G1BarrierSetC2::eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const {\n@@ -695,1 +695,1 @@\n-    macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+    igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n@@ -703,18 +703,16 @@\n-      int ind = 1;\n-      if (!this_region->in(ind)->is_IfFalse()) {\n-        ind = 2;\n-      }\n-      if (this_region->in(ind)->is_IfFalse() &&\n-          this_region->in(ind)->in(0)->Opcode() == Op_If) {\n-        Node* bol = this_region->in(ind)->in(0)->in(1);\n-        assert(bol->is_Bool(), \"\");\n-        cmpx = bol->in(1);\n-        if (bol->as_Bool()->_test._test == BoolTest::ne &&\n-            cmpx->is_Cmp() && cmpx->in(2) == macro->intcon(0) &&\n-            cmpx->in(1)->is_Load()) {\n-          Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n-          const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-          if (adr->is_AddP() && adr->in(AddPNode::Base) == macro->top() &&\n-              adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n-              adr->in(AddPNode::Offset) == macro->MakeConX(marking_offset)) {\n-            macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+      for (int i = 1; i < 3; ++i) {\n+        if (this_region->in(i)->is_IfFalse() &&\n+            this_region->in(i)->in(0)->is_If() &&\n+            this_region->in(i)->in(0)->in(1)->is_Bool()) {\n+          Node* bol = this_region->in(i)->in(0)->in(1);\n+          cmpx = bol->in(1);\n+          if (bol->as_Bool()->_test._test == BoolTest::ne &&\n+              cmpx->is_Cmp() && cmpx->in(2) == igvn->intcon(0) &&\n+              cmpx->in(1)->is_Load()) {\n+            Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n+            const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n+            if (adr->is_AddP() && adr->in(AddPNode::Base) == igvn->C->top() &&\n+                adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n+                adr->in(AddPNode::Offset) == igvn->MakeConX(marking_offset)) {\n+              igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+            }\n@@ -739,1 +737,1 @@\n-    macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+    igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n@@ -745,1 +743,1 @@\n-  macro->replace_node(node, macro->top());\n+  igvn->replace_node(node, igvn->C->top());\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -518,1 +518,2 @@\n-    if (klass->is_array_klass()) {\n+    \/\/ CMH: Valhalla flat arrays can split this work up, but for now, doesn't\n+    if (klass->is_array_klass() && !klass->is_flatArray_klass()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -29,0 +30,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -54,0 +57,27 @@\n+void BarrierSet::throw_array_null_pointer_store_exception(arrayOop src, arrayOop dst, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Klass* bound = ObjArrayKlass::cast(dst->klass())->element_klass();\n+  stringStream ss;\n+  ss.print(\"arraycopy: can not copy null values into %s[]\",\n+           bound->external_name());\n+  THROW_MSG(vmSymbols::java_lang_NullPointerException(), ss.as_string());\n+}\n+\n+void BarrierSet::throw_array_store_exception(arrayOop src, arrayOop dst, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Klass* bound = ObjArrayKlass::cast(dst->klass())->element_klass();\n+  Klass* stype = ObjArrayKlass::cast(src->klass())->element_klass();\n+  stringStream ss;\n+  if (!bound->is_subtype_of(stype)) {\n+    ss.print(\"arraycopy: type mismatch: can not copy %s[] into %s[]\",\n+             stype->external_name(), bound->external_name());\n+  } else {\n+    \/\/ oop_arraycopy should return the index in the source array that\n+    \/\/ contains the problematic oop.\n+    ss.print(\"arraycopy: element type mismatch: can not cast one of the elements\"\n+             \" of %s[] to the type of the destination array, %s\",\n+             stype->external_name(), bound->external_name());\n+  }\n+  THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/exceptions.hpp\"\n@@ -119,0 +120,3 @@\n+  static void throw_array_null_pointer_store_exception(arrayOop src, arrayOop dst, TRAPS);\n+  static void throw_array_store_exception(arrayOop src, arrayOop dst, TRAPS);\n+\n@@ -277,1 +281,1 @@\n-    static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+    static void oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -308,0 +312,5 @@\n+\n+    static void value_copy_in_heap(void* src, void* dst, InlineKlass* md) {\n+      Raw::value_copy(src, dst, md);\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n@@ -37,1 +39,1 @@\n-inline bool BarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+inline void BarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -43,1 +45,2 @@\n-  if (!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) {\n+  if ((!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) &&\n+      (!HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value)) {\n@@ -45,1 +48,2 @@\n-    return Raw::oop_arraycopy(NULL, 0, src, NULL, 0, dst, length);\n+    Raw::oop_arraycopy(NULL, 0, src, NULL, 0, dst, length);\n+    return;\n@@ -52,2 +56,8 @@\n-    if (!oopDesc::is_instanceof_or_null(CompressedOops::decode(elem), dst_klass)) {\n-      return false;\n+    if (HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value && CompressedOops::is_null(elem)) {\n+      throw_array_null_pointer_store_exception(src_obj, dst_obj, JavaThread::current());\n+      return;\n+    }\n+    if (HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value &&\n+        (!oopDesc::is_instanceof_or_null(CompressedOops::decode(elem), dst_klass))) {\n+      throw_array_store_exception(src_obj, dst_obj, JavaThread::current());\n+      return;\n@@ -57,2 +67,0 @@\n-\n-  return true;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.inline.hpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/barrierSetRuntime.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+JRT_LEAF(void, BarrierSetRuntime::value_copy(void* src, void* dst, InlineKlass* md))\n+  assert(md->is_inline_klass(), \"invariant\");\n+  HeapAccess<>::value_copy(src, dst, md);\n+JRT_END\n+\n+JRT_LEAF(void, BarrierSetRuntime::value_copy_is_dest_uninitialized(void* src, void* dst, InlineKlass* md))\n+  assert(md->is_inline_klass(), \"invariant\");\n+  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(src, dst, md);\n+JRT_END\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetRuntime.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -46,0 +46,4 @@\n+Node* C2ParseAccess::control() const {\n+  return _ctl == NULL ? _kit->control() : _ctl;\n+}\n+\n@@ -156,1 +160,1 @@\n-    Node* control = control_dependent ? kit->control() : NULL;\n+    Node* control = control_dependent ? parse_access.control() : NULL;\n@@ -682,1 +686,1 @@\n-  ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset,  dst_base, offset, payload_size, true, false);\n+  ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset, dst_base, offset, payload_size, true, false);\n@@ -783,1 +787,1 @@\n-  phase->igvn().replace_node(ac, call);\n+  phase->replace_node(ac, call);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  Node* _ctl;\n@@ -154,1 +155,2 @@\n-                BasicType type, Node* base, C2AccessValuePtr& addr) :\n+                BasicType type, Node* base, C2AccessValuePtr& addr,\n+                Node* ctl = NULL) :\n@@ -156,1 +158,2 @@\n-    _kit(kit) {\n+    _kit(kit),\n+    _ctl(ctl) {\n@@ -161,0 +164,1 @@\n+  Node* control() const;\n@@ -238,1 +242,1 @@\n-  virtual void clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const;\n+  virtual void clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* size, bool is_array) const;\n@@ -265,1 +269,1 @@\n-  virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const { }\n+  virtual void eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const { }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -289,0 +289,1 @@\n+  oop obj_buffer_allocate(Klass* klass, size_t size, TRAPS); \/\/ doesn't clear memory\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -406,2 +406,1 @@\n-  \/\/ May be bootstrapping\n-  oopDesc::set_mark(mem, markWord::prototype());\n+  oopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n@@ -420,0 +419,6 @@\n+oop ObjBufferAllocator::initialize(HeapWord* mem) const {\n+  oopDesc::set_klass_gap(mem, 0);\n+  return finish(mem);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,0 +87,8 @@\n+class ObjBufferAllocator: public MemAllocator {\n+public:\n+  ObjBufferAllocator(Klass* klass, size_t word_size, Thread* thread = Thread::current())\n+    : MemAllocator(klass, word_size, thread) {}\n+  virtual oop initialize(HeapWord* mem) const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-    Node* offset = phase->igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+    Node* offset = phase->MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n@@ -882,1 +882,1 @@\n-    phase->igvn().replace_node(ac, call);\n+    phase->replace_node(ac, call);\n@@ -908,1 +908,1 @@\n-void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {\n+void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseIterGVN* igvn, Node* n) const {\n@@ -910,1 +910,1 @@\n-    shenandoah_eliminate_wb_pre(n, &macro->igvn());\n+    shenandoah_eliminate_wb_pre(n, igvn);\n@@ -1043,1 +1043,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain_sig()->cnt();\n@@ -1128,1 +1128,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain_sig()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-        const TypeTuple* args = n->as_Call()->_tf->domain();\n+        const TypeTuple* args = n->as_Call()->_tf->domain_sig();\n@@ -585,1 +585,1 @@\n-      uint stop = n->is_Call() ? n->as_Call()->tf()->domain()->cnt() : n->req();\n+      uint stop = n->is_Call() ? n->as_Call()->tf()->domain_sig()->cnt() : n->req();\n@@ -805,6 +805,5 @@\n-        CallProjections projs;\n-        c->as_Call()->extract_projections(&projs, true, false);\n-        if (projs.fallthrough_memproj != NULL) {\n-          if (projs.fallthrough_memproj->adr_type() == TypePtr::BOTTOM) {\n-            if (projs.catchall_memproj == NULL) {\n-              mem = projs.fallthrough_memproj;\n+        CallProjections* projs = c->as_Call()->extract_projections(true, false);\n+        if (projs->fallthrough_memproj != NULL) {\n+          if (projs->fallthrough_memproj->adr_type() == TypePtr::BOTTOM) {\n+            if (projs->catchall_memproj == NULL) {\n+              mem = projs->fallthrough_memproj;\n@@ -812,2 +811,2 @@\n-              if (phase->is_dominator(projs.fallthrough_catchproj, ctrl)) {\n-                mem = projs.fallthrough_memproj;\n+              if (phase->is_dominator(projs->fallthrough_catchproj, ctrl)) {\n+                mem = projs->fallthrough_memproj;\n@@ -815,2 +814,2 @@\n-                assert(phase->is_dominator(projs.catchall_catchproj, ctrl), \"one proj must dominate barrier\");\n-                mem = projs.catchall_memproj;\n+                assert(phase->is_dominator(projs->catchall_catchproj, ctrl), \"one proj must dominate barrier\");\n+                mem = projs->catchall_memproj;\n@@ -1076,1 +1075,1 @@\n-static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections& projs, PhaseIdealLoop* phase) {\n+static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections* projs, PhaseIdealLoop* phase) {\n@@ -1088,1 +1087,1 @@\n-    if (phase->is_dominator(projs.fallthrough_catchproj, in)) {\n+    if (phase->is_dominator(projs->fallthrough_catchproj, in)) {\n@@ -1090,1 +1089,1 @@\n-    } else if (phase->is_dominator(projs.catchall_catchproj, in)) {\n+    } else if (phase->is_dominator(projs->catchall_catchproj, in)) {\n@@ -1206,3 +1205,1 @@\n-      CallProjections projs;\n-      call->extract_projections(&projs, false, false);\n-\n+      CallProjections* projs = call->extract_projections(false, false);\n@@ -1213,2 +1210,2 @@\n-      phase->register_new_node(lrb_clone, projs.catchall_catchproj);\n-      phase->set_ctrl(lrb, projs.fallthrough_catchproj);\n+      phase->register_new_node(lrb_clone, projs->catchall_catchproj);\n+      phase->set_ctrl(lrb, projs->fallthrough_catchproj);\n@@ -1236,1 +1233,1 @@\n-          if (phase->is_dominator(call, c) && phase->is_dominator(c, projs.fallthrough_proj)) {\n+          if (phase->is_dominator(call, c) && phase->is_dominator(c, projs->fallthrough_proj)) {\n@@ -1244,1 +1241,1 @@\n-            phase->register_new_node(u_clone, projs.catchall_catchproj);\n+            phase->register_new_node(u_clone, projs->catchall_catchproj);\n@@ -1246,1 +1243,1 @@\n-            phase->set_ctrl(u, projs.fallthrough_catchproj);\n+            phase->set_ctrl(u, projs->fallthrough_catchproj);\n@@ -1252,1 +1249,1 @@\n-                  if (phase->is_dominator(projs.catchall_catchproj, u->in(0)->in(k))) {\n+                  if (phase->is_dominator(projs->catchall_catchproj, u->in(0)->in(k))) {\n@@ -1255,1 +1252,1 @@\n-                  } else if (!phase->is_dominator(projs.fallthrough_catchproj, u->in(0)->in(k))) {\n+                  } else if (!phase->is_dominator(projs->fallthrough_catchproj, u->in(0)->in(k))) {\n@@ -1262,1 +1259,1 @@\n-              if (phase->is_dominator(projs.catchall_catchproj, c)) {\n+              if (phase->is_dominator(projs->catchall_catchproj, c)) {\n@@ -1267,1 +1264,1 @@\n-              } else if (!phase->is_dominator(projs.fallthrough_catchproj, c)) {\n+              } else if (!phase->is_dominator(projs->fallthrough_catchproj, c)) {\n@@ -2340,5 +2337,4 @@\n-    CallProjections projs;\n-    call->extract_projections(&projs, true, false);\n-    if (projs.catchall_memproj != NULL) {\n-      if (projs.fallthrough_memproj == n) {\n-        c = projs.fallthrough_catchproj;\n+    CallProjections* projs = call->extract_projections(true, false);\n+    if (projs->catchall_memproj != NULL) {\n+      if (projs->fallthrough_memproj == n) {\n+        c = projs->fallthrough_catchproj;\n@@ -2346,2 +2342,2 @@\n-        assert(projs.catchall_memproj == n, \"\");\n-        c = projs.catchall_catchproj;\n+        assert(projs->catchall_memproj == n, \"\");\n+        c = projs->catchall_catchproj;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-bool ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -334,1 +334,1 @@\n-  return Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);\n+  Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-    if (is_reference_type(bt)) {\n+    if (is_reference_type(bt) && (!ary_ptr->is_flat())) {\n@@ -303,1 +303,1 @@\n-        length = phase->transform_later(new SubLNode(length, phase->longcon(1))); \/\/ Size is in longs\n+        length = phase->transform_later(new SubXNode(length, phase->longcon(1))); \/\/ Size is in longs\n@@ -348,1 +348,1 @@\n-  phase->igvn().replace_node(ac, call);\n+  phase->replace_node(ac, call);\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    number_of_result_handlers = 10                              \/\/ number of result handlers for native calls\n+    number_of_result_handlers = 11                              \/\/ number of result handlers for native calls\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -556,0 +556,1 @@\n+    case Bytecodes::_withfield:\n@@ -580,0 +581,1 @@\n+    case Bytecodes::_aconst_init:\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+    case Bytecodes::_withfield:\n@@ -1114,0 +1115,1 @@\n+    case Bytecodes::_checkcast:\n@@ -1134,0 +1136,1 @@\n+    case Bytecodes::_withfield:\n@@ -1174,1 +1177,7 @@\n-    os->print(\"\\\" is null\");\n+    address code_base = _method->constMethod()->code_base();\n+    Bytecodes::Code code = Bytecodes::java_code_at(_method, code_base + bci);\n+    if (code == Bytecodes::_aastore) {\n+      os->print(\"\\\" is null or is a null-free array and there's an attempt to store null in it\");\n+    } else {\n+      os->print(\"\\\" is null\");\n+    }\n@@ -1424,0 +1433,1 @@\n+    case Bytecodes::_withfield:\n@@ -1436,0 +1446,5 @@\n+    case Bytecodes::_checkcast: {\n+        int cp_index = Bytes::get_Java_u2(code_base + pos);\n+        ConstantPool* cp = _method->constants();\n+        os->print(\"Cannot cast to null-free type \\\"%s\\\"\", cp->klass_at_noresolve(cp_index)->as_C_string());\n+      } break;\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -477,0 +477,2 @@\n+  def(_aconst_init        , \"aconst_init\"        , \"bkk\"  , NULL    , T_OBJECT ,  1, true);\n+  def(_withfield           , \"withfield\"           , \"bJJ\"  , NULL    , T_OBJECT , -1, true );\n@@ -482,0 +484,1 @@\n+  def(_fast_qgetfield      , \"fast_qgetfield\"      , \"bJJ\"  , NULL    , T_OBJECT ,  0, true , _getfield       );\n@@ -491,0 +494,1 @@\n+  def(_fast_qputfield      , \"fast_qputfield\"      , \"bJJ\"  , NULL    , T_OBJECT ,  0, true , _putfield       );\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -47,0 +48,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -77,0 +81,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -158,1 +163,3 @@\n-  oop java_class = klass->java_mirror();\n+  oop java_class = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(klass)->val_mirror()\n+                      : klass->java_mirror();\n@@ -222,0 +229,4 @@\n+  if (klass->is_inline_klass()) {\n+    THROW(vmSymbols::java_lang_InstantiationError());\n+  }\n+\n@@ -246,0 +257,194 @@\n+JRT_ENTRY(void, InterpreterRuntime::aconst_init(JavaThread* current, ConstantPool* pool, int index))\n+  \/\/ Getting the InlineKlass\n+  Klass* k = pool->klass_at(index, CHECK);\n+  if (!k->is_inline_klass()) {\n+    \/\/ inconsistency with 'new' which throws an InstantiationError\n+    \/\/ in the future, aconst_init will just return null instead of throwing an exception\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  }\n+  assert(k->is_inline_klass(), \"aconst_init argument must be the inline type class\");\n+  InlineKlass* vklass = InlineKlass::cast(k);\n+\n+  vklass->initialize(CHECK);\n+  oop res = vklass->default_value();\n+  current->set_vm_result(res);\n+JRT_END\n+\n+JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr))\n+  oop obj = NULL;\n+  int recv_offset = type2size[as_BasicType(cpe->flag_state())];\n+  assert(frame::interpreter_frame_expression_stack_direction() == -1, \"currently is -1 on all platforms\");\n+  int ret_adj = (recv_offset + type2size[T_OBJECT] )* AbstractInterpreter::stackElementSize;\n+  int offset = cpe->f2_as_offset();\n+  obj = (oopDesc*)(((uintptr_t*)ptr)[recv_offset * Interpreter::stackElementWords]);\n+  if (obj == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+  }\n+  assert(oopDesc::is_oop(obj), \"Verifying receiver\");\n+  assert(obj->klass()->is_inline_klass(), \"Must have been checked during resolution\");\n+  instanceHandle old_value_h(THREAD, (instanceOop)obj);\n+  oop ref = NULL;\n+  if (cpe->flag_state() == atos) {\n+    ref = *(oopDesc**)ptr;\n+  }\n+  Handle ref_h(THREAD, ref);\n+  InlineKlass* ik = InlineKlass::cast(old_value_h()->klass());\n+  \/\/ Ensure that the class is initialized or being initialized\n+  \/\/ If the class is in error state, the creation of a new value should not be allowed\n+  ik->initialize(CHECK_(ret_adj));\n+\n+  bool can_skip = false;\n+  switch(cpe->flag_state()) {\n+    case ztos:\n+      if (old_value_h()->bool_field(offset) == (jboolean)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case btos:\n+      if (old_value_h()->byte_field(offset) == (jbyte)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case ctos:\n+      if (old_value_h()->char_field(offset) == (jchar)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case stos:\n+      if (old_value_h()->short_field(offset) == (jshort)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case itos:\n+      if (old_value_h()->int_field(offset) == *(jint*)ptr) can_skip = true;\n+      break;\n+    case ltos:\n+      if (old_value_h()->long_field(offset) == *(jlong*)ptr) can_skip = true;\n+      break;\n+    case ftos:\n+      if (memcmp(old_value_h()->field_addr<jfloat>(offset), (jfloat*)ptr, sizeof(jfloat)) == 0) can_skip = true;\n+      break;\n+    case dtos:\n+      if (memcmp(old_value_h()->field_addr<jdouble>(offset), (jdouble*)ptr, sizeof(jdouble)) == 0) can_skip = true;\n+      break;\n+    case atos:\n+      if (!cpe->is_inlined() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n+      break;\n+    default:\n+      break;\n+  }\n+  if (can_skip) {\n+    current->set_vm_result(old_value_h());\n+    return ret_adj;\n+  }\n+\n+  instanceOop new_value = ik->allocate_instance_buffer(CHECK_(ret_adj));\n+  Handle new_value_h = Handle(THREAD, new_value);\n+  ik->inline_copy_oop_to_new_oop(old_value_h(), new_value_h());\n+  switch(cpe->flag_state()) {\n+    case ztos:\n+      new_value_h()->bool_field_put(offset, (jboolean)(*(jint*)ptr));\n+      break;\n+    case btos:\n+      new_value_h()->byte_field_put(offset, (jbyte)(*(jint*)ptr));\n+      break;\n+    case ctos:\n+      new_value_h()->char_field_put(offset, (jchar)(*(jint*)ptr));\n+      break;\n+    case stos:\n+      new_value_h()->short_field_put(offset, (jshort)(*(jint*)ptr));\n+      break;\n+    case itos:\n+      new_value_h()->int_field_put(offset, (*(jint*)ptr));\n+      break;\n+    case ltos:\n+      new_value_h()->long_field_put(offset, *(jlong*)ptr);\n+      break;\n+    case ftos:\n+      new_value_h()->float_field_put(offset, *(jfloat*)ptr);\n+      break;\n+    case dtos:\n+      new_value_h()->double_field_put(offset, *(jdouble*)ptr);\n+      break;\n+    case atos:\n+      {\n+        if (cpe->is_null_free_inline_type())  {\n+          if (!cpe->is_inlined()) {\n+              if (ref_h() == NULL) {\n+                THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+              }\n+              new_value_h()->obj_field_put(offset, ref_h());\n+            } else {\n+              int field_index = cpe->field_index();\n+              InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n+              field_ik->write_inlined_field(new_value_h(), offset, ref_h(), CHECK_(ret_adj));\n+            }\n+        } else {\n+          new_value_h()->obj_field_put(offset, ref_h());\n+        }\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  current->set_vm_result(new_value_h());\n+  return ret_adj;\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int index))\n+  \/\/ The interpreter tries to access an inline static field that has not been initialized.\n+  \/\/ This situation can happen in different scenarios:\n+  \/\/   1 - if the load or initialization of the field failed during step 8 of\n+  \/\/       the initialization of the holder of the field, in this case the access to the field\n+  \/\/       must fail\n+  \/\/   2 - it can also happen when the initialization of the holder class triggered the initialization of\n+  \/\/       another class which accesses this field in its static initializer, in this case the\n+  \/\/       access must succeed to allow circularity\n+  \/\/ The code below tries to load and initialize the field's class again before returning the default value.\n+  \/\/ If the field was not initialized because of an error, an exception should be thrown.\n+  \/\/ If the class is being initialized, the default value is returned.\n+  instanceHandle mirror_h(THREAD, (instanceOop)mirror);\n+  InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  assert(klass->field_signature(index)->is_Q_signature(), \"Sanity check\");\n+  if (klass->is_being_initialized() && klass->is_init_thread(THREAD)) {\n+    int offset = klass->field_offset(index);\n+    Klass* field_k = klass->get_inline_type_field_klass_or_null(index);\n+    if (field_k == NULL) {\n+      field_k = SystemDictionary::resolve_or_fail(klass->field_signature(index)->fundamental_name(THREAD),\n+          Handle(THREAD, klass->class_loader()),\n+          Handle(THREAD, klass->protection_domain()),\n+          true, CHECK);\n+      assert(field_k != NULL, \"Should have been loaded or an exception thrown above\");\n+      klass->set_inline_type_field_klass(index, field_k);\n+    }\n+    field_k->initialize(CHECK);\n+    oop defaultvalue = InlineKlass::cast(field_k)->default_value();\n+    \/\/ It is safe to initialize the static field because 1) the current thread is the initializing thread\n+    \/\/ and is the only one that can access it, and 2) the field is actually not initialized (i.e. null)\n+    \/\/ otherwise the JVM should not be executing this code.\n+    mirror_h()->obj_field_put(offset, defaultvalue);\n+    current->set_vm_result(defaultvalue);\n+  } else {\n+    assert(klass->is_in_error_state(), \"If not initializing, initialization must have failed to get there\");\n+    ResourceMark rm(THREAD);\n+    const char* desc = \"Could not initialize class \";\n+    const char* className = klass->external_name();\n+    size_t msglen = strlen(desc) + strlen(className) + 1;\n+    char* message = NEW_RESOURCE_ARRAY(char, msglen);\n+    if (NULL == message) {\n+      \/\/ Out of memory: can't create detailed error message\n+      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);\n+    } else {\n+      jio_snprintf(message, msglen, \"%s%s\", desc, className);\n+      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);\n+    }\n+  }\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::read_inlined_field(JavaThread* current, oopDesc* obj, int index, Klass* field_holder))\n+  Handle obj_h(THREAD, obj);\n+\n+  assert(oopDesc::is_oop(obj), \"Sanity check\");\n+\n+  assert(field_holder->is_instance_klass(), \"Sanity check\");\n+  InstanceKlass* klass = InstanceKlass::cast(field_holder);\n+\n+  assert(klass->field_is_inlined(index), \"Sanity check\");\n+\n+  InlineKlass* field_vklass = InlineKlass::cast(klass->get_inline_type_field_klass(index));\n+\n+  oop res = field_vklass->read_inlined_field(obj_h(), klass->field_offset(index), CHECK);\n+  current->set_vm_result(res);\n+JRT_END\n@@ -255,1 +460,8 @@\n-  objArrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n+  bool      is_qtype_desc = pool->tag_at(index).is_Qdescriptor_klass();\n+  arrayOop obj;\n+  if ((!klass->is_array_klass()) && is_qtype_desc) { \/\/ Logically creates elements, ensure klass init\n+    klass->initialize(CHECK);\n+    obj = oopFactory::new_valueArray(klass, size, CHECK);\n+  } else {\n+    obj = oopFactory::new_objArray(klass, size, CHECK);\n+  }\n@@ -259,0 +471,10 @@\n+JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* current, arrayOopDesc* array, int index))\n+  flatArrayHandle vah(current, (flatArrayOop)array);\n+  oop value_holder = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);\n+  current->set_vm_result(value_holder);\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index))\n+  assert(val != NULL, \"can't store null into flat array\");\n+  ((flatArrayOop)array)->value_copy_to_index(cast_to_oop(val), index);\n+JRT_END\n@@ -264,2 +486,3 @@\n-  int          i = last_frame.get_index_u2(Bytecodes::_multianewarray);\n-  Klass* klass   = constants->klass_at(i, CHECK);\n+  int i = last_frame.get_index_u2(Bytecodes::_multianewarray);\n+  Klass* klass = constants->klass_at(i, CHECK);\n+  bool is_qtype = klass->name()->is_Q_array_signature();\n@@ -270,0 +493,4 @@\n+  if (is_qtype) { \/\/ Logically creates elements, ensure klass init\n+    klass->initialize(CHECK);\n+  }\n+\n@@ -294,0 +521,23 @@\n+JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* current, oopDesc* aobj, oopDesc* bobj))\n+  assert(oopDesc::is_oop(aobj) && oopDesc::is_oop(bobj), \"must be valid oops\");\n+\n+  Handle ha(THREAD, aobj);\n+  Handle hb(THREAD, bobj);\n+  JavaValue result(T_BOOLEAN);\n+  JavaCallArguments args;\n+  args.push_oop(ha);\n+  args.push_oop(hb);\n+  methodHandle method(current, Universe::is_substitutable_method());\n+  JavaCalls::call(&result, method, &args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    \/\/ Something really bad happened because isSubstitutable() should not throw exceptions\n+    \/\/ If it is an error, just let it propagate\n+    \/\/ If it is an exception, wrap it into an InternalError\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+      Handle e(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in substitutability test\", e, false);\n+    }\n+  }\n+  return result.get_jboolean();\n+JRT_END\n@@ -624,0 +874,4 @@\n+JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* current))\n+  THROW(vmSymbols::java_lang_InstantiationError());\n+JRT_END\n+\n@@ -657,1 +911,1 @@\n-                    bytecode == Bytecodes::_putstatic);\n+                    bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);\n@@ -659,0 +913,1 @@\n+  bool is_inline_type  = bytecode == Bytecodes::_withfield;\n@@ -703,3 +958,9 @@\n-    get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);\n-    if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {\n-      put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);\n+    if (is_static) {\n+      get_code = Bytecodes::_getstatic;\n+    } else {\n+      get_code = Bytecodes::_getfield;\n+    }\n+    if (is_put && is_inline_type) {\n+        put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);\n+    } else if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {\n+        put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);\n@@ -717,1 +978,3 @@\n-    info.access_flags().is_volatile()\n+    info.access_flags().is_volatile(),\n+    info.is_inlined(),\n+    info.signature()->is_Q_signature() && info.is_inline_type()\n@@ -960,0 +1223,1 @@\n+  case Bytecodes::_withfield:\n@@ -1161,0 +1425,1 @@\n+  bool is_inlined = cp_entry->is_inlined();\n@@ -1169,1 +1434,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static, is_inlined);\n@@ -1199,0 +1464,6 @@\n+\n+  \/\/ Both Q-signatures and L-signatures are mapped to atos\n+  if (cp_entry->flag_state() == atos && ik->field_signature(index)->is_Q_signature()) {\n+    sig_type = JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+  }\n+\n@@ -1200,0 +1471,1 @@\n+  bool is_inlined = cp_entry->is_inlined();\n@@ -1202,1 +1474,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static, is_inlined);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":283,"deletions":11,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static void    anewarray     (JavaThread* current, ConstantPool* pool, int index, jint size);\n+  static void    anewarray     (JavaThread* threcurrentad, ConstantPool* pool, int index, jint size);\n@@ -67,0 +67,10 @@\n+  static void    aconst_init  (JavaThread* current, ConstantPool* pool, int index);\n+  static int     withfield     (JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr);\n+  static void    uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int offset);\n+  static void    write_heap_copy (JavaThread* current, oopDesc* value, int offset, oopDesc* rcv);\n+  static void    read_inlined_field(JavaThread* current, oopDesc* value, int index, Klass* field_holder);\n+\n+  static void value_array_load(JavaThread* current, arrayOopDesc* array, int index);\n+  static void value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index);\n+\n+  static jboolean is_substitutable(JavaThread* current, oopDesc* aobj, oopDesc* bobj);\n@@ -78,0 +88,1 @@\n+  static void    throw_InstantiationError(JavaThread* current);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -963,0 +963,1 @@\n+         byte == Bytecodes::_withfield ||\n@@ -967,1 +968,2 @@\n-  bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic || byte == Bytecodes::_nofast_putfield);\n+  bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic ||\n+                    byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);\n@@ -978,0 +980,14 @@\n+  if (byte == Bytecodes::_withfield && !resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode withfield cannot be used on identity class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n+  if (is_put && !is_static && byte != Bytecodes::_withfield && resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode putfield cannot be used on primitive class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n@@ -1005,0 +1021,2 @@\n+    \/\/ (3) by withfield when field is in a value type and the\n+    \/\/     selected class and current class are nest mates.\n@@ -1008,6 +1026,15 @@\n-        ResourceMark rm(THREAD);\n-        stringStream ss;\n-        ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n-                 is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n-                current_klass->external_name());\n-        THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        \/\/ If byte code is a withfield check if they are nestmates.\n+        bool are_nestmates = false;\n+        if (sel_klass->is_instance_klass() &&\n+            InstanceKlass::cast(sel_klass)->is_inline_klass() &&\n+            current_klass->is_instance_klass()) {\n+          are_nestmates = InstanceKlass::cast(current_klass)->has_nestmate_access_to(InstanceKlass::cast(sel_klass), THREAD);\n+        }\n+        if (!are_nestmates) {\n+          ResourceMark rm(THREAD);\n+          stringStream ss;\n+          ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n+                   is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n+                    current_klass->external_name());\n+          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        }\n@@ -1021,1 +1048,1 @@\n-                                                   !m->is_static_initializer());\n+                                                   !m->is_class_initializer());\n@@ -1024,1 +1051,1 @@\n-                                                     !m->is_object_initializer());\n+                                                     !m->is_object_constructor());\n@@ -1152,0 +1179,2 @@\n+  \/\/ Since this method is never inherited from a super, any appearance here under\n+  \/\/ the wrong class would be an error.\n@@ -1222,1 +1251,1 @@\n-      \/\/ check if the method is not <init>\n+      \/\/ check if the method is not <init>, which is never inherited\n@@ -1644,2 +1673,2 @@\n-                             const methodHandle& attached_method,\n-                             Bytecodes::Code byte, TRAPS) {\n+                                  const methodHandle& attached_method,\n+                                  Bytecodes::Code byte, bool check_null_and_abstract, TRAPS) {\n@@ -1650,0 +1679,1 @@\n+  Klass* recv_klass = recv.is_null() ? defc : recv->klass();\n@@ -1652,2 +1682,2 @@\n-      resolve_virtual_call(result, recv, recv->klass(), link_info,\n-                           \/*check_null_and_abstract=*\/true, CHECK);\n+      resolve_virtual_call(result, recv, recv_klass, link_info,\n+                           check_null_and_abstract, CHECK);\n@@ -1656,2 +1686,2 @@\n-      resolve_interface_call(result, recv, recv->klass(), link_info,\n-                             \/*check_null_and_abstract=*\/true, CHECK);\n+      resolve_interface_call(result, recv, recv_klass, link_info,\n+                             check_null_and_abstract, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-                             Bytecodes::Code byte, TRAPS);\n+                             Bytecodes::Code byte, bool check_null_and_abstract, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-    bool v2 = vars[i].is_reference()  ? true : false;\n+    bool v2 = vars[i].is_reference();\n@@ -295,1 +295,1 @@\n-    bool v2 = stack[j].is_reference() ? true : false;\n+    bool v2 = stack[j].is_reference();\n@@ -378,1 +378,1 @@\n-    if ( cell->is_reference()) {\n+    if (cell->is_reference()) {\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  assert(number_of_states == 10, \"check the code below\");\n+  assert(number_of_states == 10 , \"check the code below\");\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-  T_OBJECT\n+  T_OBJECT ,\n+  T_PRIMITIVE_OBJECT\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1100,0 +1100,1 @@\n+      const bool return_scalarized     = false;\n@@ -1103,1 +1104,1 @@\n-                                      has_ea_local_in_scope, arg_escape,\n+                                      return_scalarized, has_ea_local_in_scope, arg_escape,\n@@ -1238,0 +1239,2 @@\n+      _offsets.set_value(CodeOffsets::Verified_Inline_Entry, pc_offset);\n+      _offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, pc_offset);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,4 @@\n-    if (!mh->is_native() && !mh->is_static() && !mh->is_initializer()) {\n+    if (!mh->is_native() &&\n+        !mh->is_static() &&\n+        !mh->is_object_constructor() &&\n+        !mh->is_class_initializer()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false, CHECK_NULL);\n@@ -1601,1 +1601,1 @@\n-  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);\n+  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false, THREAD);\n@@ -1904,1 +1904,1 @@\n-    if (m->is_initializer() && !m->is_static()) {\n+    if (m->is_object_constructor()) {\n@@ -1934,1 +1934,1 @@\n-    if (!m->is_initializer() && !m->is_overpass()) {\n+    if (!(m->is_object_constructor() || m->is_class_initializer()) && !m->is_overpass()) {\n@@ -2613,2 +2613,1 @@\n-  if (m->is_initializer()) {\n-    if (m->is_static_initializer()) {\n+  if (m->is_class_initializer()) {\n@@ -2617,1 +2616,2 @@\n-    }\n+  }\n+  else if (m->is_object_constructor() || m->is_static_init_factory()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  nonstatic_field(InstanceKlass,               _misc_flags,                                   u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _misc_flags,                                   u4)                                    \\\n@@ -599,0 +599,2 @@\n+  declare_constant(DataLayout::array_load_store_data_tag)                 \\\n+  declare_constant(DataLayout::acmp_data_tag)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  LOG_TAG(preload)   \/* Trace successfull class preloading *\/ \\\n@@ -200,0 +201,1 @@\n+  LOG_TAG(valuetypes) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,0 +161,1 @@\n+  mtValueTypes,        \/\/ memory for buffered value types\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"runtime\/reflectionUtils.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -512,0 +515,132 @@\n+\n+class FindClassByNameClosure : public KlassInfoClosure {\n+ private:\n+  GrowableArray<Klass*>* _klasses;\n+  Symbol* _classname;\n+ public:\n+  FindClassByNameClosure(GrowableArray<Klass*>* klasses, Symbol* classname) :\n+    _klasses(klasses), _classname(classname) { }\n+\n+  void do_cinfo(KlassInfoEntry* cie) {\n+    if (cie->klass()->name() == _classname) {\n+      _klasses->append(cie->klass());\n+    }\n+  }\n+};\n+\n+class FieldDesc {\n+private:\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _offset;\n+  int _index;\n+  InstanceKlass* _holder;\n+  AccessFlags _access_flags;\n+ public:\n+  FieldDesc() {\n+    _name = NULL;\n+    _signature = NULL;\n+    _offset = -1;\n+    _index = -1;\n+    _holder = NULL;\n+    _access_flags = AccessFlags();\n+  }\n+  FieldDesc(fieldDescriptor& fd) {\n+    _name = fd.name();\n+    _signature = fd.signature();\n+    _offset = fd.offset();\n+    _index = fd.index();\n+    _holder = fd.field_holder();\n+    _access_flags = fd.access_flags();\n+  }\n+  const Symbol* name() { return _name;}\n+  const Symbol* signature() { return _signature; }\n+  const int offset() { return _offset; }\n+  const int index() { return _index; }\n+  const InstanceKlass* holder() { return _holder; }\n+  const AccessFlags& access_flags() { return _access_flags; }\n+  const bool is_inline_type() { return Signature::basic_type(_signature) == T_PRIMITIVE_OBJECT; }\n+};\n+\n+static int compare_offset(FieldDesc* f1, FieldDesc* f2) {\n+   return f1->offset() > f2->offset() ? 1 : -1;\n+}\n+\n+static void print_field(outputStream* st, int level, int offset, FieldDesc& fd, bool is_inline_type, bool is_inlined ) {\n+  const char* inlined_msg = \"\";\n+  if (is_inline_type) {\n+    inlined_msg = is_inlined ? \"inlined\" : \"not inlined\";\n+  }\n+  st->print_cr(\"  @ %d %*s \\\"%s\\\" %s %s %s\",\n+      offset, level * 3, \"\",\n+      fd.name()->as_C_string(),\n+      fd.signature()->as_C_string(),\n+      is_inline_type ? \" \/\/ inline type \" : \"\",\n+      inlined_msg);\n+}\n+\n+static void print_inlined_field(outputStream* st, int level, int offset, InstanceKlass* klass) {\n+  assert(klass->is_inline_klass(), \"Only inline types can be inlined\");\n+  InlineKlass* vklass = InlineKlass::cast(klass);\n+  GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+  for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {\n+    if (!fd.access_flags().is_static()) {\n+      fields->append(FieldDesc(fd.field_descriptor()));\n+    }\n+  }\n+  fields->sort(compare_offset);\n+  for(int i = 0; i < fields->length(); i++) {\n+    FieldDesc fd = fields->at(i);\n+    int offset2 = offset + fd.offset() - vklass->first_field_offset();\n+    print_field(st, level, offset2, fd,\n+        fd.is_inline_type(), fd.holder()->field_is_inlined(fd.index()));\n+    if (fd.holder()->field_is_inlined(fd.index())) {\n+      print_inlined_field(st, level + 1, offset2 ,\n+          InstanceKlass::cast(fd.holder()->get_inline_type_field_klass(fd.index())));\n+    }\n+  }\n+}\n+\n+void PrintClassLayout::print_class_layout(outputStream* st, char* class_name) {\n+  KlassInfoTable cit(true);\n+  if (cit.allocation_failed()) {\n+    st->print_cr(\"ERROR: Ran out of C-heap; hierarchy not generated\");\n+    return;\n+  }\n+\n+  Thread* THREAD = Thread::current();\n+\n+  Symbol* classname = SymbolTable::probe(class_name, (int)strlen(class_name));\n+\n+  GrowableArray<Klass*>* klasses = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<Klass*>(100, mtServiceability);\n+\n+  FindClassByNameClosure fbnc(klasses, classname);\n+  cit.iterate(&fbnc);\n+\n+  for(int i = 0; i < klasses->length(); i++) {\n+    Klass* klass = klasses->at(i);\n+    if (!klass->is_instance_klass()) continue;  \/\/ Skip\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    int tab = 1;\n+    st->print_cr(\"Class %s [@%s]:\", klass->name()->as_C_string(),\n+        klass->class_loader_data()->loader_name());\n+    ResourceMark rm;\n+    GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+    for (FieldStream fd(ik, false, false); !fd.eos(); fd.next()) {\n+      if (!fd.access_flags().is_static()) {\n+        fields->append(FieldDesc(fd.field_descriptor()));\n+      }\n+    }\n+    fields->sort(compare_offset);\n+    for(int i = 0; i < fields->length(); i++) {\n+      FieldDesc fd = fields->at(i);\n+      print_field(st, 0, fd.offset(), fd, fd.is_inline_type(), fd.holder()->field_is_inlined(fd.index()));\n+      if (fd.holder()->field_is_inlined(fd.index())) {\n+        print_inlined_field(st, 1, fd.offset(),\n+            InstanceKlass::cast(fd.holder()->get_inline_type_field_klass(fd.index())));\n+      }\n+    }\n+  }\n+  st->cr();\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+  virtual void do_oop_no_buffering(oop* o) { do_oop(o); }\n+  virtual void do_oop_no_buffering(narrowOop* o) { do_oop(o); }\n@@ -133,0 +135,5 @@\n+class BufferedValueClosure : public Closure {\n+public:\n+  virtual void do_buffered_value(oop* p) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n@@ -146,0 +147,1 @@\n+      set_init_function<InlineKlass>();\n@@ -152,0 +154,1 @@\n+      set_init_function<FlatArrayKlass>();\n@@ -209,0 +212,1 @@\n+      set_init_function<InlineKlass>();\n@@ -215,0 +219,1 @@\n+      set_init_function<FlatArrayKlass>();\n@@ -272,0 +277,1 @@\n+      set_init_function<InlineKlass>();\n@@ -278,0 +284,1 @@\n+      set_init_function<FlatArrayKlass>();\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -133,0 +133,2 @@\n+LatestMethodCache* Universe::_is_substitutable_cache  = NULL;\n+LatestMethodCache* Universe::_primitive_type_hash_code_cache = NULL;\n@@ -236,0 +238,2 @@\n+  _is_substitutable_cache->metaspace_pointers_do(it);\n+  _primitive_type_hash_code_cache->metaspace_pointers_do(it);\n@@ -284,0 +288,2 @@\n+  _is_substitutable_cache->serialize(f);\n+  _primitive_type_hash_code_cache->serialize(f);\n@@ -364,0 +370,1 @@\n+\n@@ -778,1 +785,0 @@\n-\n@@ -798,0 +804,2 @@\n+  Universe::_is_substitutable_cache = new LatestMethodCache();\n+  Universe::_primitive_type_hash_code_cache = new LatestMethodCache();\n@@ -965,0 +973,11 @@\n+\n+  \/\/ Set up substitutability testing\n+  ResourceMark rm;\n+  initialize_known_method(_is_substitutable_cache,\n+                          vmClasses::PrimitiveObjectMethods_klass(),\n+                          vmSymbols::isSubstitutable_name()->as_C_string(),\n+                          vmSymbols::object_object_boolean_signature(), true, CHECK);\n+  initialize_known_method(_primitive_type_hash_code_cache,\n+                          vmClasses::PrimitiveObjectMethods_klass(),\n+                          vmSymbols::primitiveObjectHashCode_name()->as_C_string(),\n+                          vmSymbols::object_int_signature(), true, CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+  static LatestMethodCache* _is_substitutable_cache;   \/\/ PrimitiveObjectMethods.isSubstitutable() method\n+  static LatestMethodCache* _primitive_type_hash_code_cache;  \/\/ PrimitiveObjectMethods.primitiveObjectHashCode() method\n@@ -154,0 +156,1 @@\n+\n@@ -266,0 +269,3 @@\n+  static Method*      is_substitutable_method()       { return _is_substitutable_cache->get_method(); }\n+  static Method*      primitive_type_hash_code_method()  { return _primitive_type_hash_code_cache->get_method(); }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,8 @@\n+\/\/ This meta-function returns either oop or narrowOop depending on whether\n+\/\/ a back-end needs to consider compressed oops types or not.\n+template <DecoratorSet decorators>\n+struct ValueOopType: AllStatic {\n+  static const bool needs_oop_compress = HasDecorator<decorators, INTERNAL_RT_USE_COMPRESSED_OOPS>::value;\n+  typedef typename Conditional<needs_oop_compress, narrowOop, oop>::type type;\n+};\n+\n@@ -66,1 +74,2 @@\n-    BARRIER_CLONE\n+    BARRIER_CLONE,\n+    BARRIER_VALUE_COPY\n@@ -112,1 +121,1 @@\n-    typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+    typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -116,0 +125,1 @@\n+    typedef void (*value_copy_func_t)(void* src, void* dst, InlineKlass* md);\n@@ -120,1 +130,1 @@\n-    typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,\n+    typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,\n@@ -142,0 +152,1 @@\n+  ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_VALUE_COPY, value_copy_func_t);\n@@ -341,1 +352,1 @@\n-  static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+  static void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -386,1 +397,1 @@\n-  static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+  static void oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -391,0 +402,2 @@\n+  static void value_copy(void* src, void* dst, InlineKlass* md);\n+\n@@ -560,1 +573,1 @@\n-    static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+    static void arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -564,1 +577,1 @@\n-    static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+    static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -587,0 +600,12 @@\n+  template <DecoratorSet decorators, typename T>\n+  struct RuntimeDispatch<decorators, T, BARRIER_VALUE_COPY>: AllStatic {\n+    typedef typename AccessFunction<decorators, T, BARRIER_VALUE_COPY>::type func_t;\n+    static func_t _value_copy_func;\n+\n+    static void value_copy_init(void* src, void* dst, InlineKlass* md);\n+\n+    static inline void value_copy(void* src, void* dst, InlineKlass* md) {\n+      _value_copy_func(src, dst, md);\n+    }\n+  };\n+\n@@ -628,0 +653,4 @@\n+  template <DecoratorSet decorators, typename T>\n+  typename AccessFunction<decorators, T, BARRIER_VALUE_COPY>::type\n+  RuntimeDispatch<decorators, T, BARRIER_VALUE_COPY>::_value_copy_func = &value_copy_init;\n+\n@@ -875,1 +904,1 @@\n-      HasDecorator<decorators, AS_RAW>::value && CanHardwireRaw<decorators>::value, bool>::type\n+      HasDecorator<decorators, AS_RAW>::value && CanHardwireRaw<decorators>::value, void>::type\n@@ -881,3 +910,3 @@\n-        return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,\n-                                  dst_obj, dst_offset_in_bytes, dst_raw,\n-                                  length);\n+        Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,\n+                           dst_obj, dst_offset_in_bytes, dst_raw,\n+                           length);\n@@ -885,3 +914,3 @@\n-        return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,\n-                              dst_obj, dst_offset_in_bytes, dst_raw,\n-                              length);\n+        Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,\n+                       dst_obj, dst_offset_in_bytes, dst_raw,\n+                       length);\n@@ -893,1 +922,1 @@\n-      HasDecorator<decorators, AS_RAW>::value && !CanHardwireRaw<decorators>::value, bool>::type\n+      HasDecorator<decorators, AS_RAW>::value && !CanHardwireRaw<decorators>::value, void>::type\n@@ -899,3 +928,3 @@\n-        return PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n-                                                                  dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                                  length);\n+        PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n+                                                           dst_obj, dst_offset_in_bytes, dst_raw,\n+                                                           length);\n@@ -904,3 +933,3 @@\n-        return PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n-                                                                  dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                                  length);\n+        PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n+                                                           dst_obj, dst_offset_in_bytes, dst_raw,\n+                                                           length);\n@@ -912,1 +941,1 @@\n-      !HasDecorator<decorators, AS_RAW>::value, bool>::type\n+      !HasDecorator<decorators, AS_RAW>::value, void>::type\n@@ -918,3 +947,3 @@\n-        return PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n-                                                                  dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                                  length);\n+        PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n+                                                           dst_obj, dst_offset_in_bytes, dst_raw,\n+                                                           length);\n@@ -922,3 +951,3 @@\n-        return RuntimeDispatch<decorators, T, BARRIER_ARRAYCOPY>::arraycopy(src_obj, src_offset_in_bytes, src_raw,\n-                                                                            dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                                            length);\n+        RuntimeDispatch<decorators, T, BARRIER_ARRAYCOPY>::arraycopy(src_obj, src_offset_in_bytes, src_raw,\n+                                                                     dst_obj, dst_offset_in_bytes, dst_raw,\n+                                                                     length);\n@@ -942,0 +971,16 @@\n+\n+    template <DecoratorSet decorators>\n+    inline static typename EnableIf<\n+      HasDecorator<decorators, AS_RAW>::value>::type\n+    value_copy(void* src, void* dst, InlineKlass* md) {\n+      typedef RawAccessBarrier<decorators & RAW_DECORATOR_MASK> Raw;\n+      Raw::value_copy(src, dst, md);\n+    }\n+\n+    template <DecoratorSet decorators>\n+    inline static typename EnableIf<\n+      !HasDecorator<decorators, AS_RAW>::value>::type\n+      value_copy(void* src, void* dst, InlineKlass* md) {\n+      const DecoratorSet expanded_decorators = decorators;\n+      RuntimeDispatch<expanded_decorators, void*, BARRIER_VALUE_COPY>::value_copy(src, dst, md);\n+    }\n@@ -1056,1 +1101,1 @@\n-  inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+  inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -1059,3 +1104,3 @@\n-    return PreRuntimeDispatch::arraycopy<decorators>(src_obj, src_offset_in_bytes, src_raw,\n-                                                     dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                     length);\n+    PreRuntimeDispatch::arraycopy<decorators>(src_obj, src_offset_in_bytes, src_raw,\n+                                              dst_obj, dst_offset_in_bytes, dst_raw,\n+                                              length);\n@@ -1065,1 +1110,1 @@\n-  inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,\n+  inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,\n@@ -1069,3 +1114,3 @@\n-    return PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n-                                                              dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                              length);\n+    PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n+                                                       dst_obj, dst_offset_in_bytes, dst_raw,\n+                                                       length);\n@@ -1075,1 +1120,1 @@\n-  inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,\n+  inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,\n@@ -1080,3 +1125,3 @@\n-    return PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n-                                                              dst_obj, dst_offset_in_bytes, dst_raw,\n-                                                              length);\n+    PreRuntimeDispatch::arraycopy<expanded_decorators>(src_obj, src_offset_in_bytes, src_raw,\n+                                                       dst_obj, dst_offset_in_bytes, dst_raw,\n+                                                       length);\n@@ -1215,1 +1260,1 @@\n-  inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,\n+  inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,\n@@ -1223,3 +1268,3 @@\n-    return arraycopy_reduce_types<expanded_decorators>(src_obj, src_offset_in_bytes, const_cast<DecayedT*>(src_raw),\n-                                                       dst_obj, dst_offset_in_bytes, const_cast<DecayedT*>(dst_raw),\n-                                                       length);\n+    arraycopy_reduce_types<expanded_decorators>(src_obj, src_offset_in_bytes, const_cast<DecayedT*>(src_raw),\n+                                                dst_obj, dst_offset_in_bytes, const_cast<DecayedT*>(dst_raw),\n+                                                length);\n@@ -1234,0 +1279,6 @@\n+  template <DecoratorSet decorators>\n+  inline void value_copy(void* src, void* dst, InlineKlass* md) {\n+    const DecoratorSet expanded_decorators = DecoratorFixup<decorators>::value;\n+    PreRuntimeDispatch::value_copy<expanded_decorators>(src, dst, md);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":95,"deletions":44,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -194,0 +194,2 @@\n+\/\/ * ARRAYCOPY_NOTNULL: This property means that the source array may contain null elements\n+\/\/   but the destination does not allow null elements (i.e. throw NPE)\n@@ -200,5 +202,6 @@\n-const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) << 24;\n-const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) << 25;\n-const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) << 26;\n-const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) << 27;\n-const DecoratorSet ARRAYCOPY_DECORATOR_MASK       = ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT |\n+const DecoratorSet ARRAYCOPY_NOTNULL              = UCONST64(1) << 24;\n+const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) << 25;\n+const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) << 26;\n+const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) << 27;\n+const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) << 28;\n+const DecoratorSet ARRAYCOPY_DECORATOR_MASK       = ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL |\n@@ -212,2 +215,2 @@\n-const DecoratorSet ACCESS_READ                    = UCONST64(1) << 28;\n-const DecoratorSet ACCESS_WRITE                   = UCONST64(1) << 29;\n+const DecoratorSet ACCESS_READ                    = UCONST64(1) << 29;\n+const DecoratorSet ACCESS_WRITE                   = UCONST64(1) << 30;\n@@ -216,1 +219,1 @@\n-const DecoratorSet DECORATOR_LAST = UCONST64(1) << 29;\n+const DecoratorSet DECORATOR_LAST = UCONST64(1) << 30;\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -101,0 +103,23 @@\n+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Symbol* name = NULL;\n+  char *name_str = element_klass->name()->as_C_string();\n+  int len = element_klass->name()->utf8_length();\n+  char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);\n+  int idx = 0;\n+  new_str[idx++] = JVM_SIGNATURE_ARRAY;\n+  if (element_klass->is_instance_klass()) { \/\/ it could be an array or simple type\n+    if (qdesc) {\n+      new_str[idx++] = JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+    } else {\n+      new_str[idx++] = JVM_SIGNATURE_CLASS;\n+    }\n+  }\n+  memcpy(&new_str[idx], name_str, len * sizeof(char));\n+  idx += len;\n+  if (element_klass->is_instance_klass()) {\n+    new_str[idx++] = JVM_SIGNATURE_ENDCLASS;\n+  }\n+  new_str[idx++] = '\\0';\n+  return SymbolTable::new_symbol(new_str);\n+}\n@@ -138,0 +163,4 @@\n+oop ArrayKlass::component_mirror() const {\n+  return java_lang_Class::component_mirror(java_mirror());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,0 +45,7 @@\n+  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n+                                    \/\/ The element type must be registered for both object arrays\n+                                    \/\/ (incl. object arrays with value type elements) and value type\n+                                    \/\/ arrays containing flattened value types. However, the element\n+                                    \/\/ type must not be registered for arrays of primitive types.\n+                                    \/\/ TODO: Update the class hierarchy so that element klass appears\n+                                    \/\/ only in array that contain non-primitive types.\n@@ -51,0 +58,3 @@\n+  \/\/ Create array_name for element klass\n+  static Symbol* create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS);\n+\n@@ -52,0 +62,11 @@\n+  \/\/ Instance variables\n+  virtual Klass* element_klass() const      { return _element_klass; }\n+  virtual void set_element_klass(Klass* k)  { _element_klass = k; }\n+\n+  \/\/ Compiler\/Interpreter offset\n+  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ArrayKlass, _element_klass)); }\n+\n+  \/\/ Are loads and stores to this concrete array type atomic?\n+  \/\/ Note that Object[] is naturally atomic, but its subtypes may not be.\n+  virtual bool element_access_is_atomic() { return true; }\n+\n@@ -102,0 +123,2 @@\n+  oop component_mirror() const;\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -232,1 +233,1 @@\n-      \/\/ All of these should have been reverted back to ClassIndex before calling\n+      \/\/ All of these should have been reverted back to Unresolved before calling\n@@ -251,0 +252,1 @@\n+  assert(!k->name()->is_Q_signature(), \"Q-type without JVM_CONSTANT_QDescBit\");\n@@ -394,0 +396,1 @@\n+    jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n@@ -395,1 +398,1 @@\n-      tag_at_put(index, JVM_CONSTANT_UnresolvedClass);\n+      tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n@@ -420,1 +423,1 @@\n-        tag_at_put(index, JVM_CONSTANT_UnresolvedClass);\n+        tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n@@ -470,0 +473,6 @@\n+void check_is_inline_type(Klass* k, TRAPS) {\n+  if (!k->is_inline_klass()) {\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  }\n+}\n+\n@@ -507,0 +516,5 @@\n+  bool inline_type_signature = false;\n+  if (name->is_Q_signature()) {\n+    name = name->fundamental_name(THREAD);\n+    inline_type_signature = true;\n+  }\n@@ -516,0 +530,3 @@\n+  if (inline_type_signature) {\n+    name->decrement_refcount();\n+  }\n@@ -524,0 +541,16 @@\n+  if (!HAS_PENDING_EXCEPTION && inline_type_signature) {\n+    check_is_inline_type(k, THREAD);\n+  }\n+\n+  if (!HAS_PENDING_EXCEPTION) {\n+    Klass* bottom_klass = NULL;\n+    if (k->is_objArray_klass()) {\n+      bottom_klass = ObjArrayKlass::cast(k)->bottom_klass();\n+      assert(bottom_klass != NULL, \"Should be set\");\n+      assert(bottom_klass->is_instance_klass() || bottom_klass->is_typeArray_klass(), \"Sanity check\");\n+    } else if (k->is_flatArray_klass()) {\n+      bottom_klass = FlatArrayKlass::cast(k)->element_klass();\n+      assert(bottom_klass != NULL, \"Should be set\");\n+    }\n+  }\n+\n@@ -527,1 +560,5 @@\n-    save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n+    jbyte tag = JVM_CONSTANT_UnresolvedClass;\n+    if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+      tag |= JVM_CONSTANT_QDescBit;\n+    }\n+    save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);\n@@ -546,0 +583,4 @@\n+  jbyte tag = JVM_CONSTANT_Class;\n+  if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+    tag |= JVM_CONSTANT_QDescBit;\n+  }\n@@ -550,1 +591,1 @@\n-                                  (jbyte)JVM_CONSTANT_Class);\n+                                  tag);\n@@ -983,1 +1024,3 @@\n-      result_oop = resolved->java_mirror();\n+      result_oop = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(resolved)->val_mirror()\n+                      : resolved->java_mirror();\n@@ -1901,0 +1944,6 @@\n+      case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {\n+        idx1 = Bytes::get_Java_u2(bytes);\n+        printf(\"qclass        #%03d\", idx1);\n+        ent_size = 2;\n+        break;\n+      }\n@@ -1942,0 +1991,4 @@\n+      }\n+      case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {\n+        printf(\"UnresolvedQClass: %s\", WARN_MSG);\n+        break;\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":59,"deletions":6,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-  \/\/ For temporary use while constructing constant pool\n+  \/\/ For temporary use while constructing constant pool. Used during a retransform\/class redefinition as well.\n@@ -294,0 +294,9 @@\n+  void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {\n+      release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);\n+\n+      assert((name_index & 0xffff0000) == 0, \"must be\");\n+      assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n+      *int_at_addr(which) =\n+        build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -140,1 +140,3 @@\n-                                       bool is_volatile) {\n+                                       bool is_volatile,\n+                                       bool is_inlined,\n+                                       bool is_null_free_inline_type) {\n@@ -145,0 +147,1 @@\n+  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n@@ -147,1 +150,3 @@\n-                  ((is_final    ? 1 : 0) << is_final_shift),\n+                  ((is_final    ? 1 : 0) << is_final_shift) |\n+                  ((is_inlined  ? 1 : 0) << is_inlined_shift) |\n+                  ((is_null_free_inline_type ? 1 : 0) << is_null_free_inline_type_shift),\n@@ -305,0 +310,1 @@\n+      invoke_code = Bytecodes::_invokevirtual;\n@@ -320,1 +326,1 @@\n-    set_bytecode_2(Bytecodes::_invokevirtual);\n+    set_bytecode_2(invoke_code);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-\/\/ _flags     [tos|0|F=1|0|0|0|f|v|0 |0000|field_index] (for field entries)\n+\/\/ _flags     [tos|0|F=1|0|I|i|f|v|0 |0000|field_index] (for field entries)\n@@ -78,0 +78,2 @@\n+\/\/ I  flag true if field is a null free inline type (must never be null)\n+\/\/ i  flag true if field is inlined\n@@ -185,0 +187,1 @@\n+    is_null_free_inline_type_shift = 24,  \/\/ (I) is the field a null free inline type (must never be null)\n@@ -186,0 +189,1 @@\n+    is_inlined_shift           = 23,  \/\/ (i) is the field inlined?\n@@ -224,1 +228,3 @@\n-    bool            is_volatile                  \/\/ the field is volatile\n+    bool            is_volatile,                 \/\/ the field is volatile\n+    bool            is_inlined,                  \/\/ the field is inlined\n+    bool            is_null_free_inline_type     \/\/ the field is an inline type (must never be null)\n@@ -313,0 +319,1 @@\n+      case Bytecodes::_withfield       :    \/\/ fall through\n@@ -340,0 +347,1 @@\n+  int       f2_as_offset() const                 { assert(is_field_entry(),  \"\"); return (int)_f2; }\n@@ -345,0 +353,1 @@\n+  bool is_inlined() const                        { return (_flags & (1 << is_inlined_shift))        != 0; }\n@@ -354,0 +363,1 @@\n+  bool is_null_free_inline_type() const          { return (_flags & (1 << is_null_free_inline_type_shift)) != 0; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,3 +49,4 @@\n-#define FIELDINFO_TAG_SIZE             2\n-#define FIELDINFO_TAG_OFFSET           1 << 0\n-#define FIELDINFO_TAG_CONTENDED        1 << 1\n+#define FIELDINFO_TAG_SIZE             3\n+#define FIELDINFO_TAG_OFFSET           (1 << 0)\n+#define FIELDINFO_TAG_CONTENDED        (1 << 1)\n+#define FIELDINFO_TAG_INLINED          (1 << 2)\n@@ -58,2 +59,2 @@\n-  \/\/    [--contention_group--]....................10  - contended field with contention group\n-  \/\/    [------------------offset----------------]01  - real field offset\n+  \/\/    [--contention_group--]...................I10  - contended field with contention group\n+  \/\/    [------------------offset---------------]I01  - real field offset\n@@ -64,0 +65,1 @@\n+  \/\/ Bit I indicates if the field has been inlined  (I=1) or not (I=0)\n@@ -145,0 +147,1 @@\n+    bool inlined = is_inlined();\n@@ -146,0 +149,1 @@\n+    if (inlined) set_inlined(true);\n@@ -147,0 +151,13 @@\n+    assert(is_inlined() || !inlined, \"just checking\");\n+  }\n+\n+  void set_inlined(bool b) {\n+    if (b) {\n+      _shorts[low_packed_offset] |= FIELDINFO_TAG_INLINED;\n+    } else {\n+      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_INLINED;\n+    }\n+  }\n+\n+  bool is_inlined() {\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_INLINED) != 0;\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,532 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/packageEntry.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/verifyOopClosure.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include \"oops\/flatArrayKlass.hpp\"\n+\n+\/\/ Allocation...\n+\n+FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, Kind) {\n+  assert(element_klass->is_inline_klass(), \"Expected Inline\");\n+\n+  set_element_klass(InlineKlass::cast(element_klass));\n+  set_class_loader_data(element_klass->class_loader_data());\n+\n+  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));\n+  assert(is_array_klass(), \"sanity\");\n+  assert(is_flatArray_klass(), \"sanity\");\n+  assert(is_null_free_array_klass(), \"sanity\");\n+\n+#ifdef _LP64\n+  set_prototype_header(markWord::flat_array_prototype());\n+  assert(prototype_header().is_flat_array(), \"sanity\");\n+#else\n+  set_prototype_header(markWord::inline_type_prototype());\n+#endif\n+\n+#ifndef PRODUCT\n+  if (PrintFlatArrayLayout) {\n+    print();\n+  }\n+#endif\n+}\n+\n+InlineKlass* FlatArrayKlass::element_klass() const {\n+  return InlineKlass::cast(_element_klass);\n+}\n+\n+void FlatArrayKlass::set_element_klass(Klass* k) {\n+  _element_klass = k;\n+}\n+\n+FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, TRAPS) {\n+  guarantee((!Universe::is_bootstrapping() || vmClasses::Object_klass_loaded()), \"Really ?!\");\n+  assert(UseFlatArray, \"Flatten array required\");\n+\n+  InlineKlass* element_klass = InlineKlass::cast(eklass);\n+  assert(element_klass->is_naturally_atomic() || (!InlineArrayAtomicAccess), \"Atomic by-default\");\n+\n+  \/*\n+   *  MVT->LWorld, now need to allocate secondaries array types, just like objArrayKlass...\n+   *  ...so now we are trying out covariant array types, just copy objArrayKlass\n+   *  TODO refactor any remaining commonality\n+   *\n+   *\/\n+  \/\/ Eagerly allocate the direct array supertype.\n+  Klass* super_klass = NULL;\n+  Klass* element_super = element_klass->super();\n+  if (element_super != NULL) {\n+    \/\/ The element type has a direct super.  E.g., String[] has direct super of Object[].\n+    super_klass = element_klass->array_klass_or_null();\n+    bool supers_exist = super_klass != NULL;\n+    \/\/ Also, see if the element has secondary supertypes.\n+    \/\/ We need an array type for each.\n+    const Array<Klass*>* element_supers = element_klass->secondary_supers();\n+    for( int i = element_supers->length()-1; i >= 0; i-- ) {\n+      Klass* elem_super = element_supers->at(i);\n+      if (elem_super->array_klass_or_null() == NULL) {\n+        supers_exist = false;\n+        break;\n+      }\n+    }\n+    if (!supers_exist) {\n+      \/\/ Oops.  Not allocated yet.  Back out, allocate it, and retry.\n+      Klass* ek = NULL;\n+      {\n+        MutexUnlocker mu(MultiArray_lock);\n+        super_klass = element_klass->array_klass(CHECK_NULL);\n+        for( int i = element_supers->length()-1; i >= 0; i-- ) {\n+          Klass* elem_super = element_supers->at(i);\n+          elem_super->array_klass(CHECK_NULL);\n+        }\n+        \/\/ Now retry from the beginning\n+        ek = element_klass->value_array_klass(CHECK_NULL);\n+      }  \/\/ re-lock\n+      return FlatArrayKlass::cast(ek);\n+    }\n+  }\n+\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, true, CHECK_NULL);\n+  ClassLoaderData* loader_data = element_klass->class_loader_data();\n+  int size = ArrayKlass::static_size(FlatArrayKlass::header_size());\n+  FlatArrayKlass* vak = new (loader_data, size, THREAD) FlatArrayKlass(element_klass, name);\n+\n+  ModuleEntry* module = vak->module();\n+  assert(module != NULL, \"No module entry for array\");\n+  complete_create_array_klass(vak, super_klass, module, CHECK_NULL);\n+\n+  loader_data->add_class(vak);\n+\n+  return vak;\n+}\n+\n+void FlatArrayKlass::initialize(TRAPS) {\n+  element_klass()->initialize(THREAD);\n+}\n+\n+void FlatArrayKlass::metaspace_pointers_do(MetaspaceClosure* it) {\n+  ArrayKlass::metaspace_pointers_do(it);\n+  it->push(&_element_klass);\n+}\n+\n+\/\/ Oops allocation...\n+flatArrayOop FlatArrayKlass::allocate(int length, TRAPS) {\n+  check_array_allocation_length(length, max_elements(), CHECK_NULL);\n+  int size = flatArrayOopDesc::object_size(layout_helper(), length);\n+  return (flatArrayOop) Universe::heap()->array_allocate(this, size, length, true, THREAD);\n+}\n+\n+\n+oop FlatArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {\n+  \/\/ For flatArrays this is only called for the last dimension\n+  assert(rank == 1, \"just checking\");\n+  int length = *last_size;\n+  return allocate(length, THREAD);\n+}\n+\n+jint FlatArrayKlass::array_layout_helper(InlineKlass* vk) {\n+  BasicType etype = T_PRIMITIVE_OBJECT;\n+  int esize = log2i_exact(round_up_power_of_2(vk->get_exact_size_in_bytes()));\n+  int hsize = arrayOopDesc::base_offset_in_bytes(etype);\n+\n+  int lh = Klass::array_layout_helper(_lh_array_tag_vt_value, true, hsize, etype, esize);\n+\n+  assert(lh < (int)_lh_neutral_value, \"must look like an array layout\");\n+  assert(layout_helper_is_array(lh), \"correct kind\");\n+  assert(layout_helper_is_flatArray(lh), \"correct kind\");\n+  assert(!layout_helper_is_typeArray(lh), \"correct kind\");\n+  assert(!layout_helper_is_objArray(lh), \"correct kind\");\n+  assert(layout_helper_is_null_free(lh), \"correct kind\");\n+  assert(layout_helper_header_size(lh) == hsize, \"correct decode\");\n+  assert(layout_helper_element_type(lh) == etype, \"correct decode\");\n+  assert(layout_helper_log2_element_size(lh) == esize, \"correct decode\");\n+  assert((1 << esize) < BytesPerLong || is_aligned(hsize, HeapWordsPerLong), \"unaligned base\");\n+\n+  return lh;\n+}\n+\n+size_t FlatArrayKlass::oop_size(oop obj) const {\n+  assert(obj->klass()->is_flatArray_klass(),\"must be an flat array\");\n+  flatArrayOop array = flatArrayOop(obj);\n+  return array->object_size();\n+}\n+\n+\/\/ For now return the maximum number of array elements that will not exceed:\n+\/\/ nof bytes = \"max_jint * HeapWord\" since the \"oopDesc::oop_iterate_size\"\n+\/\/ returns \"int\" HeapWords, need fix for JDK-4718400 and JDK-8233189\n+jint FlatArrayKlass::max_elements() const {\n+  \/\/ Check the max number of heap words limit first (because of int32_t in oopDesc_oop_size() etc)\n+  size_t max_size = max_jint;\n+  max_size -= arrayOopDesc::header_size(T_PRIMITIVE_OBJECT);\n+  max_size = align_down(max_size, MinObjAlignment);\n+  max_size <<= LogHeapWordSize;                                  \/\/ convert to max payload size in bytes\n+  max_size >>= layout_helper_log2_element_size(_layout_helper);  \/\/ divide by element size (in bytes) = max elements\n+  \/\/ Within int32_t heap words, still can't exceed Java array element limit\n+  if (max_size > max_jint) {\n+    max_size = max_jint;\n+  }\n+  assert((max_size >> LogHeapWordSize) <= max_jint, \"Overflow\");\n+  return (jint) max_size;\n+}\n+\n+oop FlatArrayKlass::protection_domain() const {\n+  return element_klass()->protection_domain();\n+}\n+\n+\/\/ Temp hack having this here: need to move towards Access API\n+static bool needs_backwards_copy(arrayOop s, int src_pos,\n+                                 arrayOop d, int dst_pos, int length) {\n+  return (s == d) && (dst_pos > src_pos) && (dst_pos - src_pos) < length;\n+}\n+\n+void FlatArrayKlass::copy_array(arrayOop s, int src_pos,\n+                                arrayOop d, int dst_pos, int length, TRAPS) {\n+\n+  assert(s->is_objArray() || s->is_flatArray(), \"must be obj or flat array\");\n+\n+   \/\/ Check destination\n+   if ((!d->is_flatArray()) && (!d->is_objArray())) {\n+     THROW(vmSymbols::java_lang_ArrayStoreException());\n+   }\n+\n+   \/\/ Check if all offsets and lengths are non negative\n+   if (src_pos < 0 || dst_pos < 0 || length < 0) {\n+     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n+   }\n+   \/\/ Check if the ranges are valid\n+   if  ( (((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length())\n+      || (((unsigned int) length + (unsigned int) dst_pos) > (unsigned int) d->length()) ) {\n+     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n+   }\n+   \/\/ Check zero copy\n+   if (length == 0)\n+     return;\n+\n+   ArrayKlass* sk = ArrayKlass::cast(s->klass());\n+   ArrayKlass* dk = ArrayKlass::cast(d->klass());\n+   Klass* d_elem_klass = dk->element_klass();\n+   Klass* s_elem_klass = sk->element_klass();\n+   \/**** CMH: compare and contrast impl, re-factor once we find edge cases... ****\/\n+\n+   if (sk->is_flatArray_klass()) {\n+     assert(sk == this, \"Unexpected call to copy_array\");\n+     \/\/ Check subtype, all src homogeneous, so just once\n+     if (!s_elem_klass->is_subtype_of(d_elem_klass)) {\n+       THROW(vmSymbols::java_lang_ArrayStoreException());\n+     }\n+\n+     flatArrayOop sa = flatArrayOop(s);\n+     InlineKlass* s_elem_vklass = element_klass();\n+\n+     \/\/ flatArray-to-flatArray\n+     if (dk->is_flatArray_klass()) {\n+       \/\/ element types MUST be exact, subtype check would be dangerous\n+       if (dk != this) {\n+         THROW(vmSymbols::java_lang_ArrayStoreException());\n+       }\n+\n+       flatArrayOop da = flatArrayOop(d);\n+       address dst = (address) da->value_at_addr(dst_pos, layout_helper());\n+       address src = (address) sa->value_at_addr(src_pos, layout_helper());\n+       if (contains_oops()) {\n+         int elem_incr = 1 << log2_element_size();\n+         address src_end = src + (length << log2_element_size());\n+         if (needs_backwards_copy(s, src_pos, d, dst_pos, length)) {\n+           swap(src, src_end);\n+           dst = dst + (length << log2_element_size());\n+           do {\n+             src -= elem_incr;\n+             dst -= elem_incr;\n+             HeapAccess<>::value_copy(src, dst, s_elem_vklass);\n+           } while (src > src_end);\n+         } else {\n+           address src_end = src + (length << log2_element_size());\n+           while (src < src_end) {\n+             HeapAccess<>::value_copy(src, dst, s_elem_vklass);\n+             src += elem_incr;\n+             dst += elem_incr;\n+           }\n+         }\n+       } else {\n+         \/\/ we are basically a type array...don't bother limiting element copy\n+         \/\/ it would have to be a lot wasted space to be worth value_store() calls, need a setting here ?\n+         Copy::conjoint_memory_atomic(src, dst, (size_t)length << log2_element_size());\n+       }\n+     }\n+     else { \/\/ flatArray-to-objArray\n+       assert(dk->is_objArray_klass(), \"Expected objArray here\");\n+       \/\/ Need to allocate each new src elem payload -> dst oop\n+       objArrayHandle dh(THREAD, (objArrayOop)d);\n+       flatArrayHandle sh(THREAD, sa);\n+       int dst_end = dst_pos + length;\n+       while (dst_pos < dst_end) {\n+         oop o = flatArrayOopDesc::value_alloc_copy_from_index(sh, src_pos, CHECK);\n+         dh->obj_at_put(dst_pos, o);\n+         dst_pos++;\n+         src_pos++;\n+       }\n+     }\n+   } else {\n+     assert(s->is_objArray(), \"Expected objArray\");\n+     objArrayOop sa = objArrayOop(s);\n+     assert(d->is_flatArray(), \"Excepted flatArray\");  \/\/ objArray-to-flatArray\n+     InlineKlass* d_elem_vklass = InlineKlass::cast(d_elem_klass);\n+     flatArrayOop da = flatArrayOop(d);\n+\n+     int src_end = src_pos + length;\n+     int delem_incr = 1 << dk->log2_element_size();\n+     address dst = (address) da->value_at_addr(dst_pos, layout_helper());\n+     while (src_pos < src_end) {\n+       oop se = sa->obj_at(src_pos);\n+       if (se == NULL) {\n+         THROW(vmSymbols::java_lang_NullPointerException());\n+       }\n+       \/\/ Check exact type per element\n+       if (se->klass() != d_elem_klass) {\n+         THROW(vmSymbols::java_lang_ArrayStoreException());\n+       }\n+       d_elem_vklass->inline_copy_oop_to_payload(se, dst);\n+       dst += delem_incr;\n+       src_pos++;\n+     }\n+   }\n+}\n+\n+\n+Klass* FlatArrayKlass::array_klass(int n, TRAPS) {\n+  assert(dimension() <= n, \"check order of chain\");\n+  int dim = dimension();\n+  if (dim == n) return this;\n+\n+  \/\/ lock-free read needs acquire semantics\n+  if (higher_dimension_acquire() == NULL) {\n+\n+    ResourceMark rm(THREAD);\n+    {\n+      \/\/ Ensure atomic creation of higher dimensions\n+      MutexLocker mu(THREAD, MultiArray_lock);\n+\n+      \/\/ Check if another thread beat us\n+      if (higher_dimension() == NULL) {\n+\n+        \/\/ Create multi-dim klass object and link them together\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, true, CHECK_NULL);\n+        ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n+        ak->set_lower_dimension(this);\n+        \/\/ use 'release' to pair with lock-free load\n+        release_set_higher_dimension(ak);\n+        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n+      }\n+    }\n+  }\n+\n+  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());\n+  JavaThread::cast(THREAD)->check_possible_safepoint();\n+  return ak->array_klass(n, THREAD);\n+}\n+\n+Klass* FlatArrayKlass::array_klass_or_null(int n) {\n+\n+  assert(dimension() <= n, \"check order of chain\");\n+  int dim = dimension();\n+  if (dim == n) return this;\n+\n+  \/\/ lock-free read needs acquire semantics\n+  if (higher_dimension_acquire() == NULL) {\n+    return NULL;\n+  }\n+\n+  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());\n+  return ak->array_klass_or_null(n);\n+}\n+\n+Klass* FlatArrayKlass::array_klass(TRAPS) {\n+  return array_klass(dimension() +  1, THREAD);\n+}\n+\n+Klass* FlatArrayKlass::array_klass_or_null() {\n+  return array_klass_or_null(dimension() +  1);\n+}\n+\n+\n+ModuleEntry* FlatArrayKlass::module() const {\n+  assert(element_klass() != NULL, \"FlatArrayKlass returned unexpected NULL bottom_klass\");\n+  \/\/ The array is defined in the module of its bottom class\n+  return element_klass()->module();\n+}\n+\n+PackageEntry* FlatArrayKlass::package() const {\n+  assert(element_klass() != NULL, \"FlatArrayKlass returned unexpected NULL bottom_klass\");\n+  return element_klass()->package();\n+}\n+\n+bool FlatArrayKlass::can_be_primary_super_slow() const {\n+    return true;\n+}\n+\n+GrowableArray<Klass*>* FlatArrayKlass::compute_secondary_supers(int num_extra_slots,\n+                                                                Array<InstanceKlass*>* transitive_interfaces) {\n+  assert(transitive_interfaces == NULL, \"sanity\");\n+  \/\/ interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };\n+  Array<Klass*>* elem_supers = element_klass()->secondary_supers();\n+  int num_elem_supers = elem_supers == NULL ? 0 : elem_supers->length();\n+  int num_secondaries = num_extra_slots + 2 + num_elem_supers;\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+2);\n+\n+  secondaries->push(vmClasses::Cloneable_klass());\n+  secondaries->push(vmClasses::Serializable_klass());\n+  for (int i = 0; i < num_elem_supers; i++) {\n+    Klass* elem_super = (Klass*) elem_supers->at(i);\n+    Klass* array_super = elem_super->array_klass_or_null();\n+    assert(array_super != NULL, \"must already have been created\");\n+    secondaries->push(array_super);\n+  }\n+  return secondaries;\n+}\n+\n+jint FlatArrayKlass::compute_modifier_flags() const {\n+  \/\/ The modifier for an flatArray is the same as its element\n+  jint element_flags = element_klass()->compute_modifier_flags();\n+\n+  return (element_flags & (JVM_ACC_PUBLIC | JVM_ACC_PRIVATE | JVM_ACC_PROTECTED))\n+                        | (JVM_ACC_ABSTRACT | JVM_ACC_FINAL);\n+}\n+\n+void FlatArrayKlass::print_on(outputStream* st) const {\n+#ifndef PRODUCT\n+  assert(!is_objArray_klass(), \"Unimplemented\");\n+\n+  st->print(\"Flat Type Array: \");\n+  Klass::print_on(st);\n+\n+  st->print(\" - element klass: \");\n+  element_klass()->print_value_on(st);\n+  st->cr();\n+\n+  int elem_size = element_byte_size();\n+  st->print(\" - element size %i \", elem_size);\n+  st->print(\"aligned layout size %i\", 1 << layout_helper_log2_element_size(layout_helper()));\n+  st->cr();\n+#endif \/\/PRODUCT\n+}\n+\n+void FlatArrayKlass::print_value_on(outputStream* st) const {\n+  assert(is_klass(), \"must be klass\");\n+\n+  element_klass()->print_value_on(st);\n+  st->print(\"[]\");\n+}\n+\n+\n+#ifndef PRODUCT\n+void FlatArrayKlass::oop_print_on(oop obj, outputStream* st) {\n+  ArrayKlass::oop_print_on(obj, st);\n+  flatArrayOop va = flatArrayOop(obj);\n+  InlineKlass* vk = element_klass();\n+  int print_len = MIN2((intx) va->length(), MaxElementPrintSize);\n+  for(int index = 0; index < print_len; index++) {\n+    int off = (address) va->value_at_addr(index, layout_helper()) - cast_from_oop<address>(obj);\n+    st->print_cr(\" - Index %3d offset %3d: \", index, off);\n+    oop obj = cast_to_oop((address)va->value_at_addr(index, layout_helper()) - vk->first_field_offset());\n+    FieldPrinter print_field(st, obj);\n+    vk->do_nonstatic_fields(&print_field);\n+    st->cr();\n+  }\n+  int remaining = va->length() - print_len;\n+  if (remaining > 0) {\n+    st->print_cr(\" - <%d more elements, increase MaxElementPrintSize to print>\", remaining);\n+  }\n+}\n+#endif \/\/PRODUCT\n+\n+void FlatArrayKlass::oop_print_value_on(oop obj, outputStream* st) {\n+  assert(obj->is_flatArray(), \"must be flatArray\");\n+  st->print(\"a \");\n+  element_klass()->print_value_on(st);\n+  int len = flatArrayOop(obj)->length();\n+  st->print(\"[%d] \", len);\n+  obj->print_address_on(st);\n+  if (PrintMiscellaneous && (WizardMode || Verbose)) {\n+    int lh = layout_helper();\n+    st->print(\"{\");\n+    for (int i = 0; i < len; i++) {\n+      if (i > 4) {\n+        st->print(\"...\"); break;\n+      }\n+      st->print(\" \" INTPTR_FORMAT, (intptr_t)(void*)flatArrayOop(obj)->value_at_addr(i , lh));\n+    }\n+    st->print(\" }\");\n+  }\n+}\n+\n+\/\/ Verification\n+class VerifyElementClosure: public BasicOopIterateClosure {\n+ public:\n+  virtual void do_oop(oop* p)       { VerifyOopClosure::verify_oop.do_oop(p); }\n+  virtual void do_oop(narrowOop* p) { VerifyOopClosure::verify_oop.do_oop(p); }\n+};\n+\n+void FlatArrayKlass::oop_verify_on(oop obj, outputStream* st) {\n+  ArrayKlass::oop_verify_on(obj, st);\n+  guarantee(obj->is_flatArray(), \"must be flatArray\");\n+\n+  if (contains_oops()) {\n+    flatArrayOop va = flatArrayOop(obj);\n+    VerifyElementClosure ec;\n+    va->oop_iterate(&ec);\n+  }\n+}\n+\n+void FlatArrayKlass::verify_on(outputStream* st) {\n+  ArrayKlass::verify_on(st);\n+  guarantee(element_klass()->is_inline_klass(), \"should be inline type klass\");\n+}\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":532,"deletions":0,"binary":false,"changes":532,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_OOPS_FLATARRAYKLASS_HPP\n+#define SHARE_VM_OOPS_FLATARRAYKLASS_HPP\n+\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/**\n+ * Array of inline types, gives a layout of typeArrayOop, but needs oops iterators\n+ *\/\n+class FlatArrayKlass : public ArrayKlass {\n+  friend class VMStructs;\n+\n+ public:\n+  static const KlassKind Kind = FlatArrayKlassKind;\n+\n+ private:\n+  \/\/ Constructor\n+  FlatArrayKlass(Klass* element_klass, Symbol* name);\n+\n+ public:\n+\n+  FlatArrayKlass() {}\n+\n+  \/\/ Returns the ObjArrayKlass for n'th dimension.\n+  virtual Klass* array_klass(int n, TRAPS);\n+  virtual Klass* array_klass_or_null(int n);\n+\n+  \/\/ Returns the array class with this class as element type.\n+  virtual Klass* array_klass(TRAPS);\n+  virtual Klass* array_klass_or_null();\n+\n+  virtual InlineKlass* element_klass() const;\n+  virtual void set_element_klass(Klass* k);\n+\n+  \/\/ Casting from Klass*\n+  static FlatArrayKlass* cast(Klass* k) {\n+    assert(k->is_flatArray_klass(), \"cast to FlatArrayKlass\");\n+    return (FlatArrayKlass*) k;\n+  }\n+\n+  \/\/ klass allocation\n+  static FlatArrayKlass* allocate_klass(Klass* element_klass, TRAPS);\n+\n+  void initialize(TRAPS);\n+\n+  ModuleEntry* module() const;\n+  PackageEntry* package() const;\n+\n+  bool can_be_primary_super_slow() const;\n+  GrowableArray<Klass*>* compute_secondary_supers(int num_extra_slots,\n+                                                  Array<InstanceKlass*>* transitive_interfaces);\n+\n+  int element_byte_size() const { return 1 << layout_helper_log2_element_size(_layout_helper); }\n+\n+  bool is_flatArray_klass_slow() const { return true; }\n+\n+  bool contains_oops() {\n+    return element_klass()->contains_oops();\n+  }\n+\n+  \/\/ Override.\n+  bool element_access_is_atomic() {\n+    return element_klass()->is_atomic();\n+  }\n+\n+  oop protection_domain() const;\n+\n+  virtual void metaspace_pointers_do(MetaspaceClosure* iter);\n+\n+  static jint array_layout_helper(InlineKlass* vklass); \/\/ layout helper for values\n+\n+  \/\/ sizing\n+  static int header_size()  { return sizeof(FlatArrayKlass)\/HeapWordSize; }\n+  int size() const          { return ArrayKlass::static_size(header_size()); }\n+\n+  jint max_elements() const;\n+\n+  size_t oop_size(oop obj) const;\n+\n+  \/\/ Oop Allocation\n+  flatArrayOop allocate(int length, TRAPS);\n+  oop multi_allocate(int rank, jint* sizes, TRAPS);\n+\n+  \/\/ Naming\n+  const char* internal_name() const { return external_name(); }\n+\n+  \/\/ Copying\n+  void copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);\n+\n+  \/\/ GC specific object visitors\n+  \/\/\n+  \/\/ Mark Sweep\n+  int oop_ms_adjust_pointers(oop obj);\n+\n+\n+  template <typename T, typename OopClosureType>\n+  inline void oop_oop_iterate(oop obj, OopClosureType* closure);\n+\n+  template <typename T, typename OopClosureType>\n+  inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);\n+\n+  template <typename T, typename OopClosureType>\n+  inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);\n+\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_elements(flatArrayOop a, OopClosureType* closure);\n+\n+private:\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_elements_specialized(flatArrayOop a, OopClosureType* closure);\n+\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_elements_bounded(flatArrayOop a, OopClosureType* closure, MemRegion mr);\n+\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_elements_specialized_bounded(flatArrayOop a, OopClosureType* closure, void* low, void* high);\n+\n+ public:\n+  jint compute_modifier_flags() const;\n+\n+  \/\/ Printing\n+  void print_on(outputStream* st) const;\n+  void print_value_on(outputStream* st) const;\n+\n+  void oop_print_value_on(oop obj, outputStream* st);\n+#ifndef PRODUCT\n+  void oop_print_on(oop obj, outputStream* st);\n+#endif\n+\n+  \/\/ Verification\n+  void verify_on(outputStream* st);\n+  void oop_verify_on(oop obj, outputStream* st);\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -142,1 +142,1 @@\n-    if (!is_static)\n+    if (!is_static) {\n@@ -144,0 +144,1 @@\n+    }\n@@ -840,1 +841,1 @@\n-  assert(cts.is_reference() || cts.is_value() || cts.is_address(),\n+  assert(cts.is_reference() || cts.is_inline_type() || cts.is_address(),\n@@ -1381,0 +1382,3 @@\n+    case Bytecodes::_aconst_init:      ppush1(CellTypeState::make_line_ref(itr->bci())); break;\n+    case Bytecodes::_withfield:         do_withfield(itr->get_index_u2_cpcache(), itr->bci()); break;\n+\n@@ -1594,2 +1598,2 @@\n-    case Bytecodes::_getstatic:         do_field(true,  true,  itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_putstatic:         do_field(false, true,  itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_getstatic:         do_field(true,  true, itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_putstatic:         do_field(false, true, itr->get_index_u2_cpcache(), itr->bci()); break;\n@@ -1599,0 +1603,1 @@\n+    case Bytecodes::_invokeinterface:\n@@ -1600,4 +1605,3 @@\n-    case Bytecodes::_invokespecial:     do_method(false, false, itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_invokestatic:      do_method(true,  false, itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_invokedynamic:     do_method(true,  false, itr->get_index_u4(),         itr->bci()); break;\n-    case Bytecodes::_invokeinterface:   do_method(false, true,  itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_invokespecial:     do_method(false, itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_invokestatic:      do_method(true , itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_invokedynamic:     do_method(true , itr->get_index_u4(),         itr->bci()); break;\n@@ -1623,0 +1627,1 @@\n+\n@@ -1729,1 +1734,1 @@\n-  assert(in.is_reference() | in.is_value(), \"sanity check\");\n+  assert(in.is_reference() || in.is_inline_type(), \"sanity check\");\n@@ -1948,1 +1953,3 @@\n-  if (!is_static) in[i++] = CellTypeState::ref;\n+  if (!is_static) {\n+    in[i++] = CellTypeState::ref;\n+  }\n@@ -1954,1 +1961,1 @@\n-void GenerateOopMap::do_method(int is_static, int is_interface, int idx, int bci) {\n+void GenerateOopMap::do_method(int is_static, int idx, int bci) {\n@@ -1991,0 +1998,27 @@\n+void GenerateOopMap::do_withfield(int idx, int bci) {\n+  \/\/ Dig up signature for field in constant pool\n+  ConstantPool* cp = method()->constants();\n+  int nameAndTypeIdx = cp->name_and_type_ref_index_at(idx);\n+  int signatureIdx = cp->signature_ref_index_at(nameAndTypeIdx);\n+  Symbol* signature = cp->symbol_at(signatureIdx);\n+\n+  \/\/ Parse signature (especially simple for fields)\n+  assert(signature->utf8_length() > 0,\n+      \"field signatures cannot have zero length\");\n+  \/\/ The signature is UFT8 encoded, but the first char is always ASCII for signatures.\n+  CellTypeState temp[4];\n+  CellTypeState *eff = signature_to_effect(signature, bci, temp);\n+\n+  CellTypeState in[4];\n+  int i = copy_cts(in, eff);\n+  in[i++] = CellTypeState::ref;\n+  in[i] = CellTypeState::bottom;\n+  assert(i <= 3, \"sanity check\");\n+\n+  CellTypeState out[2];\n+  out[0] = CellTypeState::ref;\n+  out[1] = CellTypeState::bottom;\n+\n+  pp(in, out);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  enum { info_mask            = right_n_bits(28),\n+  enum { info_mask            = right_n_bits(27),\n@@ -107,3 +107,3 @@\n-  enum { top_info_bit         = nth_bit(27),\n-         not_bottom_info_bit  = nth_bit(26),\n-         info_data_mask       = right_n_bits(26),\n+  enum { top_info_bit         = nth_bit(26),\n+         not_bottom_info_bit  = nth_bit(25),\n+         info_data_mask       = right_n_bits(25),\n@@ -114,2 +114,2 @@\n-  enum { ref_not_lock_bit     = nth_bit(25),  \/\/ 0 if this reference is locked as a monitor\n-         ref_slot_bit         = nth_bit(24),  \/\/ 1 if this reference is a \"slot\" reference,\n+  enum { ref_not_lock_bit     = nth_bit(24),  \/\/ 0 if this reference is locked as a monitor\n+         ref_slot_bit         = nth_bit(23),  \/\/ 1 if this reference is a \"slot\" reference,\n@@ -117,1 +117,1 @@\n-         ref_data_mask        = right_n_bits(24) };\n+         ref_data_mask        = right_n_bits(23) };\n@@ -119,0 +119,5 @@\n+  \/\/ Within the INFO data, these values are used to distinguish different\n+  \/\/ kinds of value types.\n+  enum { valuetype_slot_bit   = nth_bit(24),  \/\/ 1 if this reference is a \"slot\" value type,\n+    \/\/ 0 if it is a \"line\" value type.\n+    valuetype_data_mask  = right_n_bits(24) };\n@@ -199,1 +204,1 @@\n-  bool is_value() const                 { return ((_state & bits_mask) == val_bit); }\n+  bool is_inline_type() const           { return ((_state & bits_mask) == val_bit); }\n@@ -400,1 +405,2 @@\n-  void  do_method                           (int is_static, int is_interface, int idx, int bci);\n+  void  do_method                           (int is_static, int idx, int bci);\n+  void  do_withfield                       (int idx, int bci);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,553 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"oops\/access.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/copy.hpp\"\n+\n+  \/\/ Constructor\n+InlineKlass::InlineKlass(const ClassFileParser& parser)\n+    : InstanceKlass(parser, InlineKlass::Kind) {\n+  _adr_inlineklass_fixed_block = inlineklass_static_block();\n+  \/\/ Addresses used for inline type calling convention\n+  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n+  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n+  *((address*)adr_pack_handler()) = NULL;\n+  *((address*)adr_pack_handler_jobject()) = NULL;\n+  *((address*)adr_unpack_handler()) = NULL;\n+  assert(pack_handler() == NULL, \"pack handler not null\");\n+  *((int*)adr_default_value_offset()) = 0;\n+  *((address*)adr_value_array_klasses()) = NULL;\n+  set_prototype_header(markWord::inline_type_prototype());\n+  assert(is_inline_klass(), \"sanity\");\n+  assert(prototype_header().is_inline_type(), \"sanity\");\n+}\n+\n+oop InlineKlass::default_value() {\n+  assert(is_initialized() || is_being_initialized() || is_in_error_state(), \"default value is set at the beginning of initialization\");\n+  oop val = java_mirror()->obj_field_acquire(default_value_offset());\n+  assert(val != NULL, \"Sanity check\");\n+  assert(oopDesc::is_oop(val), \"Sanity check\");\n+  assert(val->is_inline_type(), \"Sanity check\");\n+  assert(val->klass() == this, \"sanity check\");\n+  return val;\n+}\n+\n+int InlineKlass::first_field_offset_old() {\n+#ifdef ASSERT\n+  int first_offset = INT_MAX;\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+    if (fs.offset() < first_offset) first_offset= fs.offset();\n+  }\n+#endif\n+  int base_offset = instanceOopDesc::base_offset_in_bytes();\n+  \/\/ The first field of line types is aligned on a long boundary\n+  base_offset = align_up(base_offset, BytesPerLong);\n+  assert(base_offset == first_offset, \"inconsistent offsets\");\n+  return base_offset;\n+}\n+\n+instanceOop InlineKlass::allocate_instance(TRAPS) {\n+  int size = size_helper();  \/\/ Query before forming handle.\n+\n+  instanceOop oop = (instanceOop)Universe::heap()->obj_allocate(this, size, CHECK_NULL);\n+  assert(oop->mark().is_inline_type(), \"Expected inline type\");\n+  return oop;\n+}\n+\n+instanceOop InlineKlass::allocate_instance_buffer(TRAPS) {\n+  int size = size_helper();  \/\/ Query before forming handle.\n+\n+  instanceOop oop = (instanceOop)Universe::heap()->obj_buffer_allocate(this, size, CHECK_NULL);\n+  assert(oop->mark().is_inline_type(), \"Expected inline type\");\n+  return oop;\n+}\n+\n+int InlineKlass::nonstatic_oop_count() {\n+  int oops = 0;\n+  int map_count = nonstatic_oop_map_count();\n+  OopMapBlock* block = start_of_nonstatic_oop_maps();\n+  OopMapBlock* end = block + map_count;\n+  while (block != end) {\n+    oops += block->count();\n+    block++;\n+  }\n+  return oops;\n+}\n+\n+oop InlineKlass::read_inlined_field(oop obj, int offset, TRAPS) {\n+  oop res = NULL;\n+  assert(is_initialized() || is_being_initialized()|| is_in_error_state(),\n+        \"Must be initialized, initializing or in a corner case of an escaped instance of a class that failed its initialization\");\n+  if (is_empty_inline_type()) {\n+    res = (instanceOop)default_value();\n+  } else {\n+    Handle obj_h(THREAD, obj);\n+    res = allocate_instance_buffer(CHECK_NULL);\n+    inline_copy_payload_to_new_oop(((char*)(oopDesc*)obj_h()) + offset, res);\n+  }\n+  assert(res != NULL, \"Must be set in one of two paths above\");\n+  return res;\n+}\n+\n+void InlineKlass::write_inlined_field(oop obj, int offset, oop value, TRAPS) {\n+  if (value == NULL) {\n+    THROW(vmSymbols::java_lang_NullPointerException());\n+  }\n+  if (!is_empty_inline_type()) {\n+    inline_copy_oop_to_payload(value, ((char*)(oopDesc*)obj) + offset);\n+  }\n+}\n+\n+\/\/ Arrays of...\n+\n+bool InlineKlass::flatten_array() {\n+  if (!UseFlatArray) {\n+    return false;\n+  }\n+  \/\/ Too big\n+  int elem_bytes = get_exact_size_in_bytes();\n+  if ((FlatArrayElementMaxSize >= 0) && (elem_bytes > FlatArrayElementMaxSize)) {\n+    return false;\n+  }\n+  \/\/ Too many embedded oops\n+  if ((FlatArrayElementMaxOops >= 0) && (nonstatic_oop_count() > FlatArrayElementMaxOops)) {\n+    return false;\n+  }\n+  \/\/ Declared atomic but not naturally atomic.\n+  if (is_declared_atomic() && !is_naturally_atomic()) {\n+    return false;\n+  }\n+  \/\/ VM enforcing InlineArrayAtomicAccess only...\n+  if (InlineArrayAtomicAccess && (!is_naturally_atomic())) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+Klass* InlineKlass::value_array_klass(int n, TRAPS) {\n+  if (Atomic::load_acquire(adr_value_array_klasses()) == NULL) {\n+    ResourceMark rm(THREAD);\n+    JavaThread *jt = JavaThread::cast(THREAD);\n+    {\n+      \/\/ Atomic creation of array_klasses\n+      MutexLocker ma(THREAD, MultiArray_lock);\n+\n+      \/\/ Check if update has already taken place\n+      if (value_array_klasses() == NULL) {\n+        ArrayKlass* k;\n+        if (flatten_array()) {\n+          k = FlatArrayKlass::allocate_klass(this, CHECK_NULL);\n+        } else {\n+          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, true, CHECK_NULL);\n+\n+        }\n+        \/\/ use 'release' to pair with lock-free load\n+        Atomic::release_store(adr_value_array_klasses(), k);\n+      }\n+    }\n+  }\n+  ArrayKlass* ak = value_array_klasses();\n+  return ak->array_klass(n, THREAD);\n+}\n+\n+Klass* InlineKlass::value_array_klass_or_null(int n) {\n+  \/\/ Need load-acquire for lock-free read\n+  ArrayKlass* ak = Atomic::load_acquire(adr_value_array_klasses());\n+  if (ak == NULL) {\n+    return NULL;\n+  } else {\n+    return ak->array_klass_or_null(n);\n+  }\n+}\n+\n+Klass* InlineKlass::value_array_klass(TRAPS) {\n+  return value_array_klass(1, THREAD);\n+}\n+\n+Klass* InlineKlass::value_array_klass_or_null() {\n+  return value_array_klass_or_null(1);\n+}\n+\n+\/\/ Inline type arguments are not passed by reference, instead each\n+\/\/ field of the inline type is passed as an argument. This helper\n+\/\/ function collects the inlined field (recursively)\n+\/\/ in a list. Included with the field's type is\n+\/\/ the offset of each field in the inline type: i2c and c2i adapters\n+\/\/ need that to load or store fields. Finally, the list of fields is\n+\/\/ sorted in order of increasing offsets: the adapters and the\n+\/\/ compiled code need to agree upon the order of fields.\n+\/\/\n+\/\/ The list of basic types that is returned starts with a T_PRIMITIVE_OBJECT\n+\/\/ and ends with an extra T_VOID. T_PRIMITIVE_OBJECT\/T_VOID pairs are used as\n+\/\/ delimiters. Every entry between the two is a field of the inline\n+\/\/ type. If there's an embedded inline type in the list, it also starts\n+\/\/ with a T_PRIMITIVE_OBJECT and ends with a T_VOID. This is so we can\n+\/\/ generate a unique fingerprint for the method's adapters and we can\n+\/\/ generate the list of basic types from the interpreter point of view\n+\/\/ (inline types passed as reference: iterate on the list until a\n+\/\/ T_PRIMITIVE_OBJECT, drop everything until and including the closing\n+\/\/ T_VOID) or the compiler point of view (each field of the inline\n+\/\/ types is an argument: drop all T_PRIMITIVE_OBJECT\/T_VOID from the list).\n+int InlineKlass::collect_fields(GrowableArray<SigEntry>* sig, int base_off) {\n+  int count = 0;\n+  SigEntry::add_entry(sig, T_PRIMITIVE_OBJECT, name(), base_off);\n+  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) continue;\n+    int offset = base_off + fs.offset() - (base_off > 0 ? first_field_offset() : 0);\n+    if (fs.is_inlined()) {\n+      \/\/ Resolve klass of inlined field and recursively collect fields\n+      Klass* vk = get_inline_type_field_klass(fs.index());\n+      count += InlineKlass::cast(vk)->collect_fields(sig, offset);\n+    } else {\n+      BasicType bt = Signature::basic_type(fs.signature());\n+      if (bt == T_PRIMITIVE_OBJECT) {\n+        bt = T_OBJECT;\n+      }\n+      SigEntry::add_entry(sig, bt, fs.signature(), offset);\n+      count += type2size[bt];\n+    }\n+  }\n+  int offset = base_off + size_helper()*HeapWordSize - (base_off > 0 ? first_field_offset() : 0);\n+  SigEntry::add_entry(sig, T_VOID, name(), offset);\n+  if (base_off == 0) {\n+    sig->sort(SigEntry::compare);\n+  }\n+  assert(sig->at(0)._bt == T_PRIMITIVE_OBJECT && sig->at(sig->length()-1)._bt == T_VOID, \"broken structure\");\n+  return count;\n+}\n+\n+void InlineKlass::initialize_calling_convention(TRAPS) {\n+  \/\/ Because the pack and unpack handler addresses need to be loadable from generated code,\n+  \/\/ they are stored at a fixed offset in the klass metadata. Since inline type klasses do\n+  \/\/ not have a vtable, the vtable offset is used to store these addresses.\n+  if (InlineTypeReturnedAsFields || InlineTypePassFieldsAsArgs) {\n+    ResourceMark rm;\n+    GrowableArray<SigEntry> sig_vk;\n+    int nb_fields = collect_fields(&sig_vk);\n+    Array<SigEntry>* extended_sig = MetadataFactory::new_array<SigEntry>(class_loader_data(), sig_vk.length(), CHECK);\n+    *((Array<SigEntry>**)adr_extended_sig()) = extended_sig;\n+    for (int i = 0; i < sig_vk.length(); i++) {\n+      extended_sig->at_put(i, sig_vk.at(i));\n+    }\n+    if (can_be_returned_as_fields(\/* init= *\/ true)) {\n+      nb_fields++;\n+      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nb_fields);\n+      sig_bt[0] = T_METADATA;\n+      SigEntry::fill_sig_bt(&sig_vk, sig_bt+1);\n+      VMRegPair* regs = NEW_RESOURCE_ARRAY(VMRegPair, nb_fields);\n+      int total = SharedRuntime::java_return_convention(sig_bt, regs, nb_fields);\n+\n+      if (total > 0) {\n+        Array<VMRegPair>* return_regs = MetadataFactory::new_array<VMRegPair>(class_loader_data(), nb_fields, CHECK);\n+        *((Array<VMRegPair>**)adr_return_regs()) = return_regs;\n+        for (int i = 0; i < nb_fields; i++) {\n+          return_regs->at_put(i, regs[i]);\n+        }\n+\n+        BufferedInlineTypeBlob* buffered_blob = SharedRuntime::generate_buffered_inline_type_adapter(this);\n+        *((address*)adr_pack_handler()) = buffered_blob->pack_fields();\n+        *((address*)adr_pack_handler_jobject()) = buffered_blob->pack_fields_jobject();\n+        *((address*)adr_unpack_handler()) = buffered_blob->unpack_fields();\n+        assert(CodeCache::find_blob(pack_handler()) == buffered_blob, \"lost track of blob\");\n+        assert(can_be_returned_as_fields(), \"sanity\");\n+      }\n+    }\n+    if (!can_be_returned_as_fields() && !can_be_passed_as_fields()) {\n+      MetadataFactory::free_array<SigEntry>(class_loader_data(), extended_sig);\n+      assert(return_regs() == NULL, \"sanity\");\n+    }\n+  }\n+}\n+\n+void InlineKlass::deallocate_contents(ClassLoaderData* loader_data) {\n+  if (extended_sig() != NULL) {\n+    MetadataFactory::free_array<SigEntry>(loader_data, extended_sig());\n+  }\n+  if (return_regs() != NULL) {\n+    MetadataFactory::free_array<VMRegPair>(loader_data, return_regs());\n+  }\n+  cleanup_blobs();\n+  InstanceKlass::deallocate_contents(loader_data);\n+}\n+\n+void InlineKlass::cleanup(InlineKlass* ik) {\n+  ik->cleanup_blobs();\n+}\n+\n+void InlineKlass::cleanup_blobs() {\n+  if (pack_handler() != NULL) {\n+    CodeBlob* buffered_blob = CodeCache::find_blob(pack_handler());\n+    assert(buffered_blob->is_buffered_inline_type_blob(), \"bad blob type\");\n+    BufferBlob::free((BufferBlob*)buffered_blob);\n+    *((address*)adr_pack_handler()) = NULL;\n+    *((address*)adr_pack_handler_jobject()) = NULL;\n+    *((address*)adr_unpack_handler()) = NULL;\n+  }\n+}\n+\n+\/\/ Can this inline type be passed as multiple values?\n+bool InlineKlass::can_be_passed_as_fields() const {\n+  return InlineTypePassFieldsAsArgs;\n+}\n+\n+\/\/ Can this inline type be returned as multiple values?\n+bool InlineKlass::can_be_returned_as_fields(bool init) const {\n+  return InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n+}\n+\n+\/\/ Create handles for all oop fields returned in registers that are going to be live across a safepoint\n+void InlineKlass::save_oop_fields(const RegisterMap& reg_map, GrowableArray<Handle>& handles) const {\n+  Thread* thread = Thread::current();\n+  const Array<SigEntry>* sig_vk = extended_sig();\n+  const Array<VMRegPair>* regs = return_regs();\n+  int j = 1;\n+\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_OBJECT || bt == T_ARRAY) {\n+      VMRegPair pair = regs->at(j);\n+      address loc = reg_map.location(pair.first(), nullptr);\n+      oop v = *(oop*)loc;\n+      assert(v == NULL || oopDesc::is_oop(v), \"not an oop?\");\n+      assert(Universe::heap()->is_in_or_null(v), \"must be heap pointer\");\n+      handles.push(Handle(thread, v));\n+    }\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID &&\n+        sig_vk->at(i-1)._bt != T_LONG &&\n+        sig_vk->at(i-1)._bt != T_DOUBLE) {\n+      continue;\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+}\n+\n+\/\/ Update oop fields in registers from handles after a safepoint\n+void InlineKlass::restore_oop_results(RegisterMap& reg_map, GrowableArray<Handle>& handles) const {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  const Array<SigEntry>* sig_vk = extended_sig();\n+  const Array<VMRegPair>* regs = return_regs();\n+  assert(regs != NULL, \"inconsistent\");\n+\n+  int j = 1;\n+  for (int i = 0, k = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_OBJECT || bt == T_ARRAY) {\n+      VMRegPair pair = regs->at(j);\n+      address loc = reg_map.location(pair.first(), nullptr);\n+      *(oop*)loc = handles.at(k++)();\n+    }\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID &&\n+        sig_vk->at(i-1)._bt != T_LONG &&\n+        sig_vk->at(i-1)._bt != T_DOUBLE) {\n+      continue;\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+}\n+\n+\/\/ Fields are in registers. Create an instance of the inline type and\n+\/\/ initialize it with the values of the fields.\n+oop InlineKlass::realloc_result(const RegisterMap& reg_map, const GrowableArray<Handle>& handles, TRAPS) {\n+  oop new_vt = allocate_instance(CHECK_NULL);\n+  const Array<SigEntry>* sig_vk = extended_sig();\n+  const Array<VMRegPair>* regs = return_regs();\n+\n+  int j = 1;\n+  int k = 0;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    address loc = reg_map.location(pair.first(), nullptr);\n+    switch(bt) {\n+    case T_BOOLEAN: {\n+      new_vt->bool_field_put(off, *(jboolean*)loc);\n+      break;\n+    }\n+    case T_CHAR: {\n+      new_vt->char_field_put(off, *(jchar*)loc);\n+      break;\n+    }\n+    case T_BYTE: {\n+      new_vt->byte_field_put(off, *(jbyte*)loc);\n+      break;\n+    }\n+    case T_SHORT: {\n+      new_vt->short_field_put(off, *(jshort*)loc);\n+      break;\n+    }\n+    case T_INT: {\n+      new_vt->int_field_put(off, *(jint*)loc);\n+      break;\n+    }\n+    case T_LONG: {\n+#ifdef _LP64\n+      new_vt->double_field_put(off,  *(jdouble*)loc);\n+#else\n+      Unimplemented();\n+#endif\n+      break;\n+    }\n+    case T_OBJECT:\n+    case T_ARRAY: {\n+      Handle handle = handles.at(k++);\n+      new_vt->obj_field_put(off, handle());\n+      break;\n+    }\n+    case T_FLOAT: {\n+      new_vt->float_field_put(off,  *(jfloat*)loc);\n+      break;\n+    }\n+    case T_DOUBLE: {\n+      new_vt->double_field_put(off, *(jdouble*)loc);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    *(intptr_t*)loc = 0xDEAD;\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+  assert(k == handles.length(), \"missed an oop?\");\n+  return new_vt;\n+}\n+\n+\/\/ Check the return register for an InlineKlass oop\n+InlineKlass* InlineKlass::returned_inline_klass(const RegisterMap& map) {\n+  BasicType bt = T_METADATA;\n+  VMRegPair pair;\n+  int nb = SharedRuntime::java_return_convention(&bt, &pair, 1);\n+  assert(nb == 1, \"broken\");\n+\n+  address loc = map.location(pair.first(), nullptr);\n+  intptr_t ptr = *(intptr_t*)loc;\n+  if (is_set_nth_bit(ptr, 0)) {\n+    \/\/ Oop is tagged, must be an InlineKlass oop\n+    clear_nth_bit(ptr, 0);\n+    assert(Metaspace::contains((void*)ptr), \"should be klass\");\n+    InlineKlass* vk = (InlineKlass*)ptr;\n+    assert(vk->can_be_returned_as_fields(), \"must be able to return as fields\");\n+    return vk;\n+  }\n+#ifdef ASSERT\n+  \/\/ Oop is not tagged, must be a valid oop\n+  if (VerifyOops) {\n+    oopDesc::verify(cast_to_oop(ptr));\n+  }\n+#endif\n+  return NULL;\n+}\n+\n+\/\/ CDS support\n+\n+void InlineKlass::metaspace_pointers_do(MetaspaceClosure* it) {\n+  InstanceKlass::metaspace_pointers_do(it);\n+\n+  InlineKlass* this_ptr = this;\n+  it->push_internal_pointer(&this_ptr, (intptr_t*)&_adr_inlineklass_fixed_block);\n+  it->push((Klass**)adr_value_array_klasses());\n+}\n+\n+void InlineKlass::remove_unshareable_info() {\n+  InstanceKlass::remove_unshareable_info();\n+\n+  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n+  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n+  *((address*)adr_pack_handler()) = NULL;\n+  *((address*)adr_pack_handler_jobject()) = NULL;\n+  *((address*)adr_unpack_handler()) = NULL;\n+  assert(pack_handler() == NULL, \"pack handler not null\");\n+  if (value_array_klasses() != NULL) {\n+    value_array_klasses()->remove_unshareable_info();\n+  }\n+}\n+\n+void InlineKlass::remove_java_mirror() {\n+  InstanceKlass::remove_java_mirror();\n+  if (value_array_klasses() != NULL) {\n+    value_array_klasses()->remove_java_mirror();\n+  }\n+}\n+\n+void InlineKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS) {\n+  InstanceKlass::restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK);\n+  if (value_array_klasses() != NULL) {\n+    value_array_klasses()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n+  }\n+}\n+\n+\/\/ oop verify\n+\n+void InlineKlass::verify_on(outputStream* st) {\n+  InstanceKlass::verify_on(st);\n+  guarantee(prototype_header().is_inline_type(), \"Prototype header is not inline type\");\n+}\n+\n+void InlineKlass::oop_verify_on(oop obj, outputStream* st) {\n+  InstanceKlass::oop_verify_on(obj, st);\n+  guarantee(obj->mark().is_inline_type(), \"Header is not inline type\");\n+}\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":553,"deletions":0,"binary":false,"changes":553,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_OOPS_INLINEKLASS_HPP\n+#define SHARE_VM_OOPS_INLINEKLASS_HPP\n+\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\/\/#include \"oops\/oop.inline.hpp\"\n+\n+\/\/ An InlineKlass is a specialized InstanceKlass for inline types.\n+\n+\n+class InlineKlass: public InstanceKlass {\n+  friend class VMStructs;\n+  friend class InstanceKlass;\n+\n+ public:\n+  static const KlassKind Kind = InlineKlassKind;\n+\n+  InlineKlass() { assert(DumpSharedSpaces || UseSharedSpaces, \"only for CDS\"); }\n+\n+ private:\n+\n+  \/\/ Constructor\n+  InlineKlass(const ClassFileParser& parser);\n+\n+  inline InlineKlassFixedBlock* inlineklass_static_block() const;\n+  inline address adr_return_regs() const;\n+\n+  address adr_extended_sig() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _extended_sig));\n+  }\n+\n+  \/\/ pack and unpack handlers for inline types return\n+  address adr_pack_handler() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _pack_handler));\n+  }\n+\n+  address adr_pack_handler_jobject() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _pack_handler_jobject));\n+  }\n+\n+  address adr_unpack_handler() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _unpack_handler));\n+  }\n+\n+  address adr_default_value_offset() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(default_value_offset_offset());\n+  }\n+\n+  ArrayKlass* volatile* adr_value_array_klasses() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return (ArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_free_inline_array_klasses));\n+  }\n+\n+  ArrayKlass* value_array_klasses() const {\n+    return *adr_value_array_klasses();\n+  }\n+\n+  address adr_alignment() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _alignment));\n+  }\n+\n+  address adr_first_field_offset() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _first_field_offset));\n+  }\n+\n+  address adr_exact_size_in_bytes() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _exact_size_in_bytes));\n+  }\n+\n+ public:\n+  int get_alignment() const {\n+    return *(int*)adr_alignment();\n+  }\n+\n+  void set_alignment(int alignment) {\n+    *(int*)adr_alignment() = alignment;\n+  }\n+\n+  int first_field_offset() const {\n+    int offset = *(int*)adr_first_field_offset();\n+    assert(offset != 0, \"Must be initialized before use\");\n+    return *(int*)adr_first_field_offset();\n+  }\n+\n+  void set_first_field_offset(int offset) {\n+    *(int*)adr_first_field_offset() = offset;\n+  }\n+\n+  int get_exact_size_in_bytes() const {\n+    return *(int*)adr_exact_size_in_bytes();\n+  }\n+\n+  void set_exact_size_in_bytes(int exact_size) {\n+    *(int*)adr_exact_size_in_bytes() = exact_size;\n+  }\n+\n+  int first_field_offset_old();\n+\n+  virtual void remove_unshareable_info();\n+  virtual void remove_java_mirror();\n+  virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it);\n+\n+ private:\n+  int collect_fields(GrowableArray<SigEntry>* sig, int base_off = 0);\n+\n+  void cleanup_blobs();\n+\n+ public:\n+  \/\/ Type testing\n+  bool is_inline_klass_slow() const        { return true; }\n+  bool is_null_free() const { return access_flags().is_primitive_class(); }\n+\n+  \/\/ ref and val mirror\n+  oop ref_mirror() const { return java_mirror(); }\n+  oop val_mirror() const { return java_lang_Class::secondary_mirror(java_mirror()); }\n+\n+  \/\/ naming\n+  const char* ref_signature_name() const {\n+    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+  }\n+  const char* val_signature_name() const {\n+    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_PRIMITIVE_OBJECT);\n+  }\n+\n+  \/\/ Casting from Klass*\n+  static InlineKlass* cast(Klass* k);\n+\n+  \/\/ Use this to return the size of an instance in heap words.\n+  \/\/ Note that this size only applies to heap allocated stand-alone instances.\n+  virtual int size_helper() const {\n+    return layout_helper_to_size_helper(layout_helper());\n+  }\n+\n+  \/\/ allocate_instance() allocates a stand alone value in the Java heap\n+  \/\/ initialized to default value (cleared memory)\n+  instanceOop allocate_instance(TRAPS);\n+  \/\/ allocates a stand alone inline buffer in the Java heap\n+  \/\/ DOES NOT have memory cleared, user MUST initialize payload before\n+  \/\/ returning to Java (i.e.: inline_copy)\n+  instanceOop allocate_instance_buffer(TRAPS);\n+\n+  address data_for_oop(oop o) const;\n+\n+  \/\/ Query if this class promises atomicity one way or another\n+  bool is_atomic() { return is_naturally_atomic() || is_declared_atomic(); }\n+\n+  bool flatten_array();\n+\n+  bool contains_oops() const { return nonstatic_oop_map_count() > 0; }\n+  int nonstatic_oop_count();\n+\n+  \/\/ null free inline arrays...\n+  \/\/\n+\n+  \/\/ null free inline array klass, akin to InstanceKlass::array_klass()\n+  \/\/ Returns the array class for the n'th dimension\n+  Klass* value_array_klass(int n, TRAPS);\n+  Klass* value_array_klass_or_null(int n);\n+\n+  \/\/ Returns the array class with this class as element type\n+  Klass* value_array_klass(TRAPS);\n+  Klass* value_array_klass_or_null();\n+\n+\n+  \/\/ General store methods\n+  \/\/\n+  \/\/ Normally loads and store methods would be found in *Oops classes, but since values can be\n+  \/\/ \"in-lined\" (flattened) into containing oops, these methods reside here in InlineKlass.\n+  \/\/\n+  \/\/ \"inline_copy_*_to_new_*\" assume new memory (i.e. IS_DEST_UNINITIALIZED for write barriers)\n+\n+  void inline_copy_payload_to_new_oop(void* src, oop dst);\n+  void inline_copy_oop_to_new_oop(oop src, oop dst);\n+  void inline_copy_oop_to_new_payload(oop src, void* dst);\n+  void inline_copy_oop_to_payload(oop src, void* dst);\n+\n+  oop read_inlined_field(oop obj, int offset, TRAPS);\n+  void write_inlined_field(oop obj, int offset, oop value, TRAPS);\n+\n+  \/\/ oop iterate raw inline type data pointer (where oop_addr may not be an oop, but backing\/array-element)\n+  template <typename T, class OopClosureType>\n+  inline void oop_iterate_specialized(const address oop_addr, OopClosureType* closure);\n+\n+  template <typename T, class OopClosureType>\n+  inline void oop_iterate_specialized_bounded(const address oop_addr, OopClosureType* closure, void* lo, void* hi);\n+\n+  \/\/ calling convention support\n+  void initialize_calling_convention(TRAPS);\n+  Array<SigEntry>* extended_sig() const {\n+    return *((Array<SigEntry>**)adr_extended_sig());\n+  }\n+  inline Array<VMRegPair>* return_regs() const;\n+  bool can_be_passed_as_fields() const;\n+  bool can_be_returned_as_fields(bool init = false) const;\n+  void save_oop_fields(const RegisterMap& map, GrowableArray<Handle>& handles) const;\n+  void restore_oop_results(RegisterMap& map, GrowableArray<Handle>& handles) const;\n+  oop realloc_result(const RegisterMap& reg_map, const GrowableArray<Handle>& handles, TRAPS);\n+  static InlineKlass* returned_inline_klass(const RegisterMap& reg_map);\n+\n+  address pack_handler() const {\n+    return *(address*)adr_pack_handler();\n+  }\n+\n+  address unpack_handler() const {\n+    return *(address*)adr_unpack_handler();\n+  }\n+\n+  \/\/ pack and unpack handlers. Need to be loadable from generated code\n+  \/\/ so at a fixed offset from the base of the klass pointer.\n+  static ByteSize pack_handler_offset() {\n+    return byte_offset_of(InlineKlassFixedBlock, _pack_handler);\n+  }\n+\n+  static ByteSize pack_handler_jobject_offset() {\n+    return byte_offset_of(InlineKlassFixedBlock, _pack_handler_jobject);\n+  }\n+\n+  static ByteSize unpack_handler_offset() {\n+    return byte_offset_of(InlineKlassFixedBlock, _unpack_handler);\n+  }\n+\n+  static ByteSize default_value_offset_offset() {\n+    return byte_offset_of(InlineKlassFixedBlock, _default_value_offset);\n+  }\n+\n+  static ByteSize first_field_offset_offset() {\n+    return byte_offset_of(InlineKlassFixedBlock, _first_field_offset);\n+  }\n+\n+  void set_default_value_offset(int offset) {\n+    *((int*)adr_default_value_offset()) = offset;\n+  }\n+\n+  int default_value_offset() {\n+    int offset = *((int*)adr_default_value_offset());\n+    assert(offset != 0, \"must not be called if not initialized\");\n+    return offset;\n+  }\n+\n+  void set_default_value(oop val) {\n+    java_mirror()->obj_field_put(default_value_offset(), val);\n+  }\n+\n+  oop default_value();\n+  void deallocate_contents(ClassLoaderData* loader_data);\n+  static void cleanup(InlineKlass* ik) ;\n+\n+  \/\/ Verification\n+  void verify_on(outputStream* st);\n+  void oop_verify_on(oop obj, outputStream* st);\n+\n+};\n+\n+#endif \/* SHARE_VM_OOPS_INLINEKLASS_HPP *\/\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_VM_OOPS_INLINEKLASS_INLINE_HPP\n+#define SHARE_VM_OOPS_INLINEKLASS_INLINE_HPP\n+\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/devirtualizer.inline.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+inline InlineKlassFixedBlock* InlineKlass::inlineklass_static_block() const {\n+  address adr_jf = adr_inline_type_field_klasses();\n+  if (adr_jf != NULL) {\n+    return (InlineKlassFixedBlock*)(adr_jf + this->java_fields_count() * sizeof(Klass*));\n+  }\n+\n+  InstanceKlass* volatile* adr_impl = adr_implementor();\n+  if (adr_impl != NULL) {\n+    return (InlineKlassFixedBlock*)(adr_impl + 1);\n+  }\n+\n+  return (InlineKlassFixedBlock*)end_of_nonstatic_oop_maps();\n+}\n+\n+inline address InlineKlass::adr_return_regs() const {\n+  InlineKlassFixedBlock* vkst = inlineklass_static_block();\n+  return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _return_regs));\n+}\n+\n+inline Array<VMRegPair>* InlineKlass::return_regs() const {\n+  return *((Array<VMRegPair>**)adr_return_regs());\n+}\n+\n+\n+inline InlineKlass* InlineKlass::cast(Klass* k) {\n+  assert(k->is_inline_klass(), \"cast to InlineKlass\");\n+  return (InlineKlass*) k;\n+}\n+\n+inline address InlineKlass::data_for_oop(oop o) const {\n+  return ((address) (void*) o) + first_field_offset();\n+}\n+\n+inline void InlineKlass::inline_copy_payload_to_new_oop(void* src, oop dst) {\n+  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(src, data_for_oop(dst), this);\n+}\n+\n+inline void InlineKlass::inline_copy_oop_to_new_oop(oop src, oop dst) {\n+  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(data_for_oop(src), data_for_oop(dst), this);\n+}\n+\n+inline void InlineKlass::inline_copy_oop_to_new_payload(oop src, void* dst) {\n+  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(data_for_oop(src), dst, this);\n+}\n+\n+inline void InlineKlass::inline_copy_oop_to_payload(oop src, void* dst) {\n+  HeapAccess<>::value_copy(data_for_oop(src), dst, this);\n+}\n+\n+\n+template <typename T, class OopClosureType>\n+void InlineKlass::oop_iterate_specialized(const address oop_addr, OopClosureType* closure) {\n+  OopMapBlock* map = start_of_nonstatic_oop_maps();\n+  OopMapBlock* const end_map = map + nonstatic_oop_map_count();\n+\n+  for (; map < end_map; map++) {\n+    T* p = (T*) (oop_addr + map->offset());\n+    T* const end = p + map->count();\n+    for (; p < end; ++p) {\n+      Devirtualizer::do_oop(closure, p);\n+    }\n+  }\n+}\n+\n+template <typename T, class OopClosureType>\n+inline void InlineKlass::oop_iterate_specialized_bounded(const address oop_addr, OopClosureType* closure, void* lo, void* hi) {\n+  OopMapBlock* map = start_of_nonstatic_oop_maps();\n+  OopMapBlock* const end_map = map + nonstatic_oop_map_count();\n+\n+  T* const l   = (T*) lo;\n+  T* const h   = (T*) hi;\n+\n+  for (; map < end_map; map++) {\n+    T* p = (T*) (oop_addr + map->offset());\n+    T* end = p + map->count();\n+    if (p < l) {\n+      p = l;\n+    }\n+    if (end > h) {\n+      end = h;\n+    }\n+    for (; p < end; ++p) {\n+      Devirtualizer::do_oop(closure, p);\n+    }\n+  }\n+}\n+\n+\n+#endif \/\/ SHARE_VM_OOPS_INLINEKLASS_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -167,0 +168,2 @@\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_PRIMITIVE_OBJECT; }\n+\n@@ -438,1 +441,3 @@\n-                                       parser.is_interface());\n+                                       parser.is_interface(),\n+                                       parser.has_inline_fields() ? parser.java_fields_count() : 0,\n+                                       parser.is_inline_type());\n@@ -460,0 +465,3 @@\n+  } else if (parser.is_inline_type()) {\n+    \/\/ inline type\n+    ik = new (loader_data, size, THREAD) InlineKlass(parser);\n@@ -471,0 +479,7 @@\n+#ifdef ASSERT\n+  assert(ik->size() == size, \"\");\n+  ik->bounds_check((address) ik->start_of_vtable(), false, size);\n+  ik->bounds_check((address) ik->start_of_itable(), false, size);\n+  ik->bounds_check((address) ik->end_of_itable(), true, size);\n+  ik->bounds_check((address) ik->end_of_nonstatic_oop_maps(), true, size);\n+#endif \/\/ASSERT\n@@ -474,0 +489,23 @@\n+#ifndef PRODUCT\n+bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {\n+  const char* bad = NULL;\n+  address end = NULL;\n+  if (addr < (address)this) {\n+    bad = \"before\";\n+  } else if (addr == (address)this) {\n+    if (edge_ok)  return true;\n+    bad = \"just before\";\n+  } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes < 0 ? size() : size_in_bytes))) {\n+    if (edge_ok)  return true;\n+    bad = \"just after\";\n+  } else if (addr > end) {\n+    bad = \"after\";\n+  } else {\n+    return true;\n+  }\n+  tty->print_cr(\"%s object bounds: \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \"..\" INTPTR_FORMAT \"]\",\n+      bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);\n+  Verbose = WizardMode = true; this->print(); \/\/@@\n+  return false;\n+}\n+#endif \/\/PRODUCT\n@@ -513,1 +551,4 @@\n-  _init_thread(NULL)\n+  _init_thread(NULL),\n+  _inline_type_field_klasses(NULL),\n+  _preload_classes(NULL),\n+  _adr_inlineklass_fixed_block(NULL)\n@@ -520,0 +561,4 @@\n+    if (parser.has_inline_fields()) {\n+      set_has_inline_type_fields();\n+    }\n+    _java_fields_count = parser.java_fields_count();\n@@ -524,0 +569,4 @@\n+\n+  if (has_inline_type_fields()) {\n+    _inline_type_field_klasses = (const Klass**) adr_inline_type_field_klasses();\n+  }\n@@ -689,0 +738,6 @@\n+  if (preload_classes() != NULL &&\n+      preload_classes() != Universe::the_empty_short_array() &&\n+      !preload_classes()->is_shared()) {\n+    MetadataFactory::free_array<jushort>(loader_data, preload_classes());\n+  }\n+\n@@ -839,0 +894,76 @@\n+\n+  \/\/ If a class declares a method that uses an inline class as an argument\n+  \/\/ type or return inline type, this inline class must be loaded during the\n+  \/\/ linking of this class because size and properties of the inline class\n+  \/\/ must be known in order to be able to perform inline type optimizations.\n+  \/\/ The implementation below is an approximation of this rule, the code\n+  \/\/ iterates over all methods of the current class (including overridden\n+  \/\/ methods), not only the methods declared by this class. This\n+  \/\/ approximation makes the code simpler, and doesn't change the semantic\n+  \/\/ because classes declaring methods overridden by the current class are\n+  \/\/ linked (and have performed their own pre-loading) before the linking\n+  \/\/ of the current class.\n+\n+\n+  \/\/ Note:\n+  \/\/ Inline class types are loaded during\n+  \/\/ the loading phase (see ClassFileParser::post_process_parsed_stream()).\n+  \/\/ Inline class types used as element types for array creation\n+  \/\/ are not pre-loaded. Their loading is triggered by either anewarray\n+  \/\/ or multianewarray bytecodes.\n+\n+  \/\/ Could it be possible to do the following processing only if the\n+  \/\/ class uses inline types?\n+  if (EnableValhalla) {\n+    ResourceMark rm(THREAD);\n+    for (int i = 0; i < methods()->length(); i++) {\n+      Method* m = methods()->at(i);\n+      for (SignatureStream ss(m->signature()); !ss.is_done(); ss.next()) {\n+        if (ss.is_reference()) {\n+          if (ss.is_array()) {\n+            continue;\n+          }\n+          if (ss.type() == T_PRIMITIVE_OBJECT) {\n+            Symbol* symb = ss.as_symbol();\n+            if (symb == name()) continue;\n+            oop loader = class_loader();\n+            oop protection_domain = this->protection_domain();\n+            Klass* klass = SystemDictionary::resolve_or_fail(symb,\n+                                                             Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n+                                                             CHECK_false);\n+            if (klass == NULL) {\n+              THROW_(vmSymbols::java_lang_LinkageError(), false);\n+            }\n+            if (!klass->is_inline_klass()) {\n+              Exceptions::fthrow(\n+                THREAD_AND_LOCATION,\n+                vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                \"class %s is not an inline type\",\n+                klass->external_name());\n+            }\n+          }\n+        }\n+      }\n+    }\n+    \/\/ Aggressively preloading all classes from the Preload attribute\n+    if (preload_classes() != NULL) {\n+      for (int i = 0; i < preload_classes()->length(); i++) {\n+        if (constants()->tag_at(preload_classes()->at(i)).is_klass()) continue;\n+        Symbol* class_name = constants()->klass_at_noresolve(preload_classes()->at(i));\n+        if (class_name == name()) continue;\n+        oop loader = class_loader();\n+        oop protection_domain = this->protection_domain();\n+        Klass* klass = SystemDictionary::resolve_or_null(class_name,\n+                                                          Handle(THREAD, loader), Handle(THREAD, protection_domain), THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+        }\n+        if (klass != NULL) {\n+          log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute\", class_name->as_C_string(), name()->as_C_string());\n+        } else {\n+          log_warning(class, preload)(\"Preloading of class %s during linking of class %s (Preload attribute) failed\", class_name->as_C_string(), name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1083,0 +1214,19 @@\n+  \/\/ Pre-allocating an instance of the default value\n+  if (is_inline_klass()) {\n+      InlineKlass* vk = InlineKlass::cast(this);\n+      oop val = vk->allocate_instance(THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          {\n+              EXCEPTION_MARK;\n+              add_initialization_error(THREAD, e);\n+              \/\/ Locks object, set state, and notify all waiting threads\n+              set_initialization_state_and_notify(initialization_error, THREAD);\n+              CLEAR_PENDING_EXCEPTION;\n+          }\n+          THROW_OOP(e());\n+      }\n+      vk->set_default_value(val);\n+  }\n+\n@@ -1115,1 +1265,41 @@\n-\n+  \/\/ Initialize classes of inline fields\n+  if (EnableValhalla) {\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+        Klass* klass = get_inline_type_field_klass_or_null(fs.index());\n+        if (fs.access_flags().is_static() && klass == NULL) {\n+          klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())->fundamental_name(THREAD),\n+              Handle(THREAD, class_loader()),\n+              Handle(THREAD, protection_domain()),\n+              true, THREAD);\n+          set_inline_type_field_klass(fs.index(), klass);\n+        }\n+\n+        if (!HAS_PENDING_EXCEPTION) {\n+          assert(klass != NULL, \"Must  be\");\n+          InstanceKlass::cast(klass)->initialize(THREAD);\n+          if (fs.access_flags().is_static()) {\n+            if (java_mirror()->obj_field(fs.offset()) == NULL) {\n+              java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n+            }\n+          }\n+        }\n+\n+        if (HAS_PENDING_EXCEPTION) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          {\n+            EXCEPTION_MARK;\n+            add_initialization_error(THREAD, e);\n+            \/\/ Locks object, set state, and notify all waiting threads\n+            set_initialization_state_and_notify(initialization_error, THREAD);\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+          THROW_OOP(e());\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  \/\/ Step 9\n@@ -1138,1 +1328,1 @@\n-  \/\/ Step 9\n+  \/\/ Step 10\n@@ -1144,1 +1334,1 @@\n-    \/\/ Step 10 and 11\n+    \/\/ Step 11 and 12\n@@ -1413,1 +1603,2 @@\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this,\n+                                                                  false, false, CHECK_NULL);\n@@ -1420,2 +1611,2 @@\n-  ObjArrayKlass* oak = array_klasses();\n-  return oak->array_klass(n, THREAD);\n+  ArrayKlass* ak = array_klasses();\n+  return ak->array_klass(n, THREAD);\n@@ -1426,2 +1617,2 @@\n-  ObjArrayKlass* oak = array_klasses_acquire();\n-  if (oak == NULL) {\n+  ArrayKlass* ak = array_klasses_acquire();\n+  if (ak == NULL) {\n@@ -1430,1 +1621,1 @@\n-    return oak->array_klass_or_null(n);\n+    return ak->array_klass_or_null(n);\n@@ -1447,1 +1638,1 @@\n-  if (clinit != NULL && clinit->has_valid_initializer_flags()) {\n+  if (clinit != NULL && clinit->is_class_initializer()) {\n@@ -1496,1 +1687,1 @@\n-    MutexLocker x(OopMapCacheAlloc_lock);\n+    MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);\n@@ -1508,5 +1699,0 @@\n-bool InstanceKlass::contains_field_offset(int offset) {\n-  fieldDescriptor fd;\n-  return find_field_from_offset(offset, false, &fd);\n-}\n-\n@@ -1583,0 +1769,9 @@\n+bool InstanceKlass::contains_field_offset(int offset) {\n+  if (this->is_inline_klass()) {\n+    InlineKlass* vk = InlineKlass::cast(this);\n+    return offset >= vk->first_field_offset() && offset < (vk->first_field_offset() + vk->get_exact_size_in_bytes());\n+  } else {\n+    fieldDescriptor fd;\n+    return find_field_from_offset(offset, false, &fd);\n+  }\n+}\n@@ -1975,0 +2170,3 @@\n+    if (name == vmSymbols::object_initializer_name()) {\n+      break;  \/\/ <init> is never inherited, not even as a static factory\n+    }\n@@ -2456,0 +2654,1 @@\n+  it->push(&_preload_classes);\n@@ -2457,0 +2656,6 @@\n+\n+  if (has_inline_type_fields()) {\n+    for (int i = 0; i < java_fields_count(); i++) {\n+      it->push(&((Klass**)adr_inline_type_field_klasses())[i]);\n+    }\n+  }\n@@ -2499,0 +2704,8 @@\n+  if (has_inline_type_fields()) {\n+    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+        reset_inline_type_field_klass(fs.index());\n+      }\n+    }\n+  }\n+\n@@ -2561,0 +2774,4 @@\n+  if (is_inline_klass()) {\n+    InlineKlass::cast(this)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -2770,0 +2987,4 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n+\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -2779,1 +3000,1 @@\n-  \/\/ Add L as type indicator\n+  \/\/ Add L or Q as type indicator\n@@ -2781,1 +3002,1 @@\n-  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n@@ -3129,2 +3350,1 @@\n-  \/\/ Remember to strip ACC_SUPER bit\n-  return (access & (~JVM_ACC_SUPER)) & JVM_ACC_WRITTEN_FLAGS;\n+  return (access & JVM_ACC_WRITTEN_FLAGS);\n@@ -3387,1 +3607,4 @@\n-static void print_vtable(intptr_t* start, int len, outputStream* st) {\n+static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {\n+  ResourceMark rm;\n+  int* forward_refs = NEW_RESOURCE_ARRAY(int, len);\n+  for (int i = 0; i < len; i++)  forward_refs[i] = 0;\n@@ -3391,0 +3614,5 @@\n+    if (forward_refs[i] != 0) {\n+      int from = forward_refs[i];\n+      int off = (int) start[from];\n+      st->print(\" (offset %d <= [%d])\", off, from);\n+    }\n@@ -3394,0 +3622,6 @@\n+    } else if (self != NULL && e > 0 && e < 0x10000) {\n+      address location = self + e;\n+      int index = (int)((intptr_t*)location - start);\n+      st->print(\" (offset %d => [%d])\", (int)e, index);\n+      if (index >= 0 && index < len)\n+        forward_refs[index] = i;\n@@ -3400,1 +3634,22 @@\n-  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n+  return print_vtable(NULL, reinterpret_cast<intptr_t*>(start), len, st);\n+}\n+\n+template<typename T>\n+ static void print_array_on(outputStream* st, Array<T>* array) {\n+   if (array == NULL) { st->print_cr(\"NULL\"); return; }\n+   array->print_value_on(st); st->cr();\n+   if (Verbose || WizardMode) {\n+     for (int i = 0; i < array->length(); i++) {\n+       st->print(\"%d : \", i); array->at(i)->print_value_on(st); st->cr();\n+     }\n+   }\n+ }\n+\n+static void print_array_on(outputStream* st, Array<int>* array) {\n+  if (array == NULL) { st->print_cr(\"NULL\"); return; }\n+  array->print_value_on(st); st->cr();\n+  if (Verbose || WizardMode) {\n+    for (int i = 0; i < array->length(); i++) {\n+      st->print(\"%d : %d\", i, array->at(i)); st->cr();\n+    }\n+  }\n@@ -3414,0 +3669,1 @@\n+  st->print(BULLET\"misc flags:        0x%x\", _misc_flags);                        st->cr();\n@@ -3440,15 +3696,3 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);                  st->cr();\n-  if (Verbose || WizardMode) {\n-    Array<Method*>* method_array = methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-    }\n-  }\n-  st->print(BULLET\"method ordering:   \"); method_ordering()->print_value_on(st);      st->cr();\n-  st->print(BULLET\"default_methods:   \"); default_methods()->print_value_on(st);      st->cr();\n-  if (Verbose && default_methods() != NULL) {\n-    Array<Method*>* method_array = default_methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-    }\n-  }\n+  st->print(BULLET\"methods:           \"); print_array_on(st, methods());\n+  st->print(BULLET\"method ordering:   \"); print_array_on(st, method_ordering());\n+  st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n@@ -3456,1 +3700,1 @@\n-    st->print(BULLET\"default vtable indices:   \"); default_vtable_indices()->print_value_on(st);       st->cr();\n+    st->print(BULLET\"default vtable indices:   \"); print_array_on(st, default_vtable_indices());\n@@ -3458,2 +3702,2 @@\n-  st->print(BULLET\"local interfaces:  \"); local_interfaces()->print_value_on(st);      st->cr();\n-  st->print(BULLET\"trans. interfaces: \"); transitive_interfaces()->print_value_on(st); st->cr();\n+  st->print(BULLET\"local interfaces:  \"); print_array_on(st, local_interfaces());\n+  st->print(BULLET\"trans. interfaces: \"); print_array_on(st, transitive_interfaces());\n@@ -3505,0 +3749,1 @@\n+  st->print(BULLET\"preload classes:     \"); preload_classes()->print_value_on(st); st->cr();\n@@ -3515,1 +3760,1 @@\n-  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);\n+  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":288,"deletions":43,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -53,0 +54,2 @@\n+\/\/    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true\n+\/\/    [EMBEDDED InlineKlassFixedBlock] only if is an InlineKlass instance\n@@ -69,0 +72,1 @@\n+class BufferedInlineTypeBlob;\n@@ -129,0 +133,17 @@\n+class SigEntry;\n+\n+class InlineKlassFixedBlock {\n+  Array<SigEntry>** _extended_sig;\n+  Array<VMRegPair>** _return_regs;\n+  address* _pack_handler;\n+  address* _pack_handler_jobject;\n+  address* _unpack_handler;\n+  int* _default_value_offset;\n+  ArrayKlass** _null_free_inline_array_klasses;\n+  int _alignment;\n+  int _first_field_offset;\n+  int _exact_size_in_bytes;\n+\n+  friend class InlineKlass;\n+};\n+\n@@ -134,0 +155,1 @@\n+  friend class TemplateTable;\n@@ -168,1 +190,1 @@\n-  ObjArrayKlass* volatile _array_klasses;\n+  ArrayKlass* volatile _array_klasses;\n@@ -246,1 +268,9 @@\n-    _misc_has_contended_annotations           = 1 << 13  \/\/ has @Contended annotation\n+    _misc_has_contended_annotations           = 1 << 13, \/\/ has @Contended annotation\n+    _misc_has_inline_type_fields              = 1 << 14, \/\/ has inline fields and related embedded section is not empty\n+    _misc_is_empty_inline_type                = 1 << 15, \/\/ empty inline type (*)\n+    _misc_is_naturally_atomic                 = 1 << 16, \/\/ loaded\/stored in one instruction\n+    _misc_is_declared_atomic                  = 1 << 17, \/\/ implements jl.NonTearable\n+    \/\/ _misc_invalid_value_super                 = 1 << 18, \/\/ invalid super type for an value type\n+    \/\/ _misc_invalid_identity_super              = 1 << 19, \/\/ invalid super type for an identity type\n+    _misc_carries_value_modifier              = 1 << 20, \/\/ the class or one of its super types has the ACC_VALUE modifier\n+    _misc_carries_identity_modifier           = 1 << 21, \/\/ the class or one of its super types has the ACC_IDENTITY modifier\n@@ -248,0 +278,6 @@\n+\n+  \/\/ (*) An inline type is considered empty if it contains no non-static fields or\n+  \/\/ if it contains only empty inline fields. Note that JITs have a slightly different\n+  \/\/ definition: empty inline fields must be flattened otherwise the container won't\n+  \/\/ be considered empty\n+\n@@ -251,1 +287,1 @@\n-  u2              _misc_flags;           \/\/ There is more space in access_flags for more flags.\n+  u4              _misc_flags;           \/\/ There is more space in access_flags for more flags.\n@@ -305,0 +341,3 @@\n+  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, NULL if none present\n+  Array<u2>* _preload_classes;\n+  const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n@@ -374,0 +413,58 @@\n+  bool has_inline_type_fields() const          {\n+    return (_misc_flags & _misc_has_inline_type_fields) != 0;\n+  }\n+  void set_has_inline_type_fields()  {\n+    _misc_flags |= _misc_has_inline_type_fields;\n+  }\n+\n+  bool is_empty_inline_type() const {\n+    return (_misc_flags & _misc_is_empty_inline_type) != 0;\n+  }\n+  void set_is_empty_inline_type() {\n+    _misc_flags |= _misc_is_empty_inline_type;\n+  }\n+\n+  \/\/ Note:  The naturally_atomic property only applies to\n+  \/\/ inline classes; it is never true on identity classes.\n+  \/\/ The bit is placed on instanceKlass for convenience.\n+\n+  \/\/ Query if h\/w provides atomic load\/store for instances.\n+  bool is_naturally_atomic() const {\n+    return (_misc_flags & _misc_is_naturally_atomic) != 0;\n+  }\n+  \/\/ Initialized in the class file parser, not changed later.\n+  void set_is_naturally_atomic() {\n+    _misc_flags |= _misc_is_naturally_atomic;\n+  }\n+\n+  \/\/ Query if this class implements jl.NonTearable or was\n+  \/\/ mentioned in the JVM option ForceNonTearable.\n+  \/\/ This bit can occur anywhere, but is only significant\n+  \/\/ for inline classes *and* their super types.\n+  \/\/ It inherits from supers along with NonTearable.\n+  bool is_declared_atomic() const {\n+    return (_misc_flags & _misc_is_declared_atomic) != 0;\n+  }\n+  \/\/ Initialized in the class file parser, not changed later.\n+  void set_is_declared_atomic() {\n+    _misc_flags |= _misc_is_declared_atomic;\n+  }\n+\n+  bool carries_value_modifier() const {\n+    return (_misc_flags &  _misc_carries_value_modifier) != 0;\n+  }\n+\n+  \/\/ Initialized in the class file parser, not changed later.\n+  void set_carries_value_modifier() {\n+    _misc_flags |= _misc_carries_value_modifier;\n+  }\n+\n+  bool carries_identity_modifier() const {\n+    return (_misc_flags & _misc_carries_identity_modifier) != 0;\n+  }\n+\n+  \/\/ Initialized in the class file parser, not changed later.\n+  void set_carries_identity_modifier() {\n+    _misc_flags |= _misc_carries_identity_modifier;\n+  }\n+\n@@ -389,3 +486,3 @@\n-  ObjArrayKlass* array_klasses() const     { return _array_klasses; }\n-  inline ObjArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n-  inline void release_set_array_klasses(ObjArrayKlass* k); \/\/ store with release semantics\n+  ArrayKlass* array_klasses() const     { return _array_klasses; }\n+  inline ArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n+  inline void release_set_array_klasses(ArrayKlass* k); \/\/ store with release semantics\n@@ -435,0 +532,2 @@\n+  bool    field_is_inlined(int index) const { return field(index)->is_inlined(); }\n+  bool    field_is_null_free_inline_type(int index) const;\n@@ -446,0 +545,3 @@\n+  Array<u2>* preload_classes() const { return _preload_classes; }\n+  void set_preload_classes(Array<u2>* c) { _preload_classes = c; }\n+\n@@ -584,0 +686,4 @@\n+  static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }\n+  static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }\n+  static u4 misc_flag_is_empty_inline_type() { return _misc_is_empty_inline_type; }\n+\n@@ -964,0 +1070,3 @@\n+  static ByteSize inline_type_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _inline_type_field_klasses)); }\n+  static ByteSize adr_inlineklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_inlineklass_fixed_block)); }\n+\n@@ -1019,1 +1128,2 @@\n-                  bool is_interface) {\n+                  bool is_interface,\n+                  int java_fields, bool is_inline_type) {\n@@ -1024,1 +1134,3 @@\n-           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0));\n+           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0) +\n+           (java_fields * (int)sizeof(Klass*)\/wordSize) +\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n@@ -1030,1 +1142,3 @@\n-                                               is_interface());\n+                                               is_interface(),\n+                                               has_inline_type_fields() ? java_fields_count() : 0,\n+                                               is_inline_klass());\n@@ -1038,0 +1152,1 @@\n+  bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;\n@@ -1044,0 +1159,6 @@\n+  inline address adr_inline_type_field_klasses() const;\n+  inline Klass* get_inline_type_field_klass(int idx) const;\n+  inline Klass* get_inline_type_field_klass_or_null(int idx) const;\n+  inline void set_inline_type_field_klass(int idx, Klass* k);\n+  inline void reset_inline_type_field_klass(int idx);\n+\n@@ -1045,1 +1166,1 @@\n-  int size_helper() const {\n+  virtual int size_helper() const {\n@@ -1099,0 +1220,1 @@\n+  const char* signature_name_of_carrier(char c) const;\n@@ -1218,1 +1340,1 @@\n-  void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n+  virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -65,1 +65,46 @@\n-inline ObjArrayKlass* InstanceKlass::array_klasses_acquire() const {\n+inline address InstanceKlass::adr_inline_type_field_klasses() const {\n+  if (has_inline_type_fields()) {\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (address)(adr_impl + 1);\n+    }\n+\n+    return (address)end_of_nonstatic_oop_maps();\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+inline Klass* InstanceKlass::get_inline_type_field_klass(int idx) const {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n+  assert(k != NULL, \"Should always be set before being read\");\n+  assert(k->is_inline_klass(), \"Must be an inline type\");\n+  return k;\n+}\n+\n+inline Klass* InstanceKlass::get_inline_type_field_klass_or_null(int idx) const {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n+  assert(k == NULL || k->is_inline_klass(), \"Must be an inline type\");\n+  return k;\n+}\n+\n+inline void InstanceKlass::set_inline_type_field_klass(int idx, Klass* k) {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  assert(k != NULL, \"Should not be set to NULL\");\n+  assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, \"Should not be set twice\");\n+  ((Klass**)adr_inline_type_field_klasses())[idx] = k;\n+}\n+\n+inline void InstanceKlass::reset_inline_type_field_klass(int idx) {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;\n+}\n+\n+\n+inline ArrayKlass* InstanceKlass::array_klasses_acquire() const {\n@@ -69,1 +114,1 @@\n-inline void InstanceKlass::release_set_array_klasses(ObjArrayKlass* k) {\n+inline void InstanceKlass::release_set_array_klasses(ArrayKlass* k) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -205,1 +205,2 @@\n-                           _shared_class_path_index(-1) {\n+                               _prototype_header(markWord::prototype()),\n+                               _shared_class_path_index(-1) {\n@@ -219,1 +220,1 @@\n-  int lh = array_layout_helper(tag, hsize, etype, exact_log2(esize));\n+  int lh = array_layout_helper(tag, false, hsize, etype, exact_log2(esize));\n@@ -747,0 +748,2 @@\n+     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  InlineKlassKind,\n@@ -48,0 +49,1 @@\n+  FlatArrayKlassKind,\n@@ -102,1 +104,1 @@\n-  \/\/    tag is 0x80 if the elements are oops, 0xC0 if non-oops\n+  \/\/    tag is 0x80 if the elements are oops, 0xC0 if non-oops, 0xA0 if value types\n@@ -168,0 +170,1 @@\n+  markWord _prototype_header;  \/\/ inline type and inline array mark patterns\n@@ -396,1 +399,1 @@\n-  static const int _lh_array_tag_bits          = 2;\n+  static const int _lh_array_tag_bits          = 3;\n@@ -398,2 +401,10 @@\n-  static const int _lh_array_tag_obj_value     = ~0x01;   \/\/ 0x80000000 >> 30\n-  static const unsigned int _lh_array_tag_type_value = 0Xffffffff; \/\/ ~0x00,  \/\/ 0xC0000000 >> 30\n+  static const unsigned int _lh_array_tag_type_value = 0Xfffffffc;\n+  static const unsigned int _lh_array_tag_vt_value   = 0Xfffffffd;\n+  static const unsigned int _lh_array_tag_obj_value  = 0Xfffffffe;\n+\n+  \/\/ null-free array flag bit under the array tag bits, shift one more to get array tag value\n+  static const int _lh_null_free_shift = _lh_array_tag_shift - 1;\n+  static const int _lh_null_free_mask  = 1;\n+\n+  static const jint _lh_array_tag_flat_value_bit_inplace = (jint) (1 << _lh_array_tag_shift);\n+  static const jint _lh_null_free_array_bit_inplace = (jint) (_lh_null_free_mask << _lh_null_free_shift);\n@@ -417,2 +428,1 @@\n-    \/\/ _lh_array_tag_type_value == (lh >> _lh_array_tag_shift);\n-    return (juint)lh >= (juint)(_lh_array_tag_type_value << _lh_array_tag_shift);\n+    return (juint) _lh_array_tag_type_value == (juint)(lh >> _lh_array_tag_shift);\n@@ -421,2 +431,13 @@\n-    \/\/ _lh_array_tag_obj_value == (lh >> _lh_array_tag_shift);\n-    return (jint)lh < (jint)(_lh_array_tag_type_value << _lh_array_tag_shift);\n+    return (juint)_lh_array_tag_obj_value == (juint)(lh >> _lh_array_tag_shift);\n+  }\n+  static bool layout_helper_is_flatArray(jint lh) {\n+    return (juint)_lh_array_tag_vt_value == (juint)(lh >> _lh_array_tag_shift);\n+  }\n+  static bool layout_helper_is_null_free(jint lh) {\n+    assert(layout_helper_is_flatArray(lh) || layout_helper_is_objArray(lh), \"must be array of inline types\");\n+    return ((lh >> _lh_null_free_shift) & _lh_null_free_mask);\n+  }\n+  static jint layout_helper_set_null_free(jint lh) {\n+    lh |= (_lh_null_free_mask << _lh_null_free_shift);\n+    assert(layout_helper_is_null_free(lh), \"Bad encoding\");\n+    return lh;\n@@ -433,1 +454,1 @@\n-    assert(btvalue >= T_BOOLEAN && btvalue <= T_OBJECT, \"sanity\");\n+    assert((btvalue >= T_BOOLEAN && btvalue <= T_OBJECT) || btvalue == T_PRIMITIVE_OBJECT, \"sanity\");\n@@ -454,1 +475,1 @@\n-    assert(l2esz <= LogBytesPerLong,\n+    assert(layout_helper_element_type(lh) == T_PRIMITIVE_OBJECT || l2esz <= LogBytesPerLong,\n@@ -458,1 +479,1 @@\n-  static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {\n+  static jint array_layout_helper(jint tag, bool null_free, int hsize, BasicType etype, int log2_esize) {\n@@ -460,0 +481,1 @@\n+      |    ((null_free ? 1 : 0) <<  _lh_null_free_shift)\n@@ -608,0 +630,1 @@\n+  virtual bool is_flatArray_klass_slow()    const { return false; }\n@@ -609,0 +632,2 @@\n+  \/\/ current implementation uses this method even in non debug builds\n+  virtual bool is_inline_klass_slow()       const { return false; }\n@@ -623,0 +648,1 @@\n+  bool is_inline_klass()                const { return is_inline_klass_slow(); } \/\/temporary hack\n@@ -624,1 +650,1 @@\n-  bool is_other_instance_klass()        const { return _kind == InstanceKlassKind; }\n+  bool is_other_instance_klass()        const { return _kind <= InlineKlassKind; }\n@@ -630,0 +656,1 @@\n+  bool is_flatArray_klass()             const { return assert_same_query( _kind == FlatArrayKlassKind, is_flatArray_klass_slow()); }\n@@ -635,0 +662,2 @@\n+  inline bool is_null_free_array_klass()      const { return layout_helper_is_null_free(layout_helper()); }\n+\n@@ -643,1 +672,2 @@\n-  bool is_super() const                 { return _access_flags.is_super(); }\n+  bool is_value_class() const           { return _access_flags.is_value_class(); }\n+  bool is_identity_class() const        { return _access_flags.is_identity_class(); }\n@@ -666,0 +696,11 @@\n+  \/\/ inline types and inline type array patterns\n+  markWord prototype_header() const {\n+    return _prototype_header;\n+  }\n+  static inline markWord default_prototype_header(Klass* k) {\n+    return (k == NULL) ? markWord::prototype() : k->prototype_header();\n+  }\n+\n+  inline void set_prototype_header(markWord header);\n+  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -55,0 +55,18 @@\n+inline void Klass::set_prototype_header(markWord header) {\n+  assert(!is_inline_klass() || header.is_inline_type(), \"Unexpected prototype\");\n+  assert(_prototype_header.value() == 0 || _prototype_header == markWord::prototype(),\n+         \"Prototype already set\");\n+#ifdef _LP64\n+    assert(header == markWord::prototype() ||\n+           header.is_inline_type() ||\n+           header.is_flat_array() ||\n+           header.is_null_free_array(),\n+           \"unknown prototype header\");\n+#else\n+    assert(header == markWord::prototype() ||\n+           header.is_inline_type(),\n+           \"unknown prototype header\");\n+#endif\n+  _prototype_header = header;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1232,3 +1232,4 @@\n-  if (m->is_static())           return false;   \/\/ e.g., Stream.empty\n-  if (m->is_initializer())      return false;   \/\/ <init> or <clinit>\n-  if (m->is_private())          return false;   \/\/ uses direct call\n+  if (m->is_static())             return false;   \/\/ e.g., Stream.empty\n+  if (m->is_private())            return false;   \/\/ uses direct call\n+  if (m->is_object_constructor()) return false;   \/\/ <init>(...)V\n+  if (m->is_class_initializer())  return false;   \/\/ <clinit>()V\n@@ -1443,0 +1444,12 @@\n+int count_interface_methods_needing_itable_index(Array<Method*>* methods) {\n+  int method_count = 0;\n+  if (methods->length() > 0) {\n+    for (int i = methods->length(); --i >= 0; ) {\n+      if (interface_method_needs_itable_index(methods->at(i))) {\n+        method_count++;\n+      }\n+    }\n+  }\n+  return method_count;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -297,1 +297,4 @@\n-  int size_offset_table()                { return _size_offset_table; }\n+  InstanceKlass* klass() const          { return _klass; }\n+  int table_offset() const              { return _table_offset; }\n+  int size_offset_table() const         { return _size_offset_table; }\n+  int size_method_table() const         { return _size_method_table; }\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\/\/\n@@ -63,0 +64,64 @@\n+\/\/\n+\/\/\n+\/\/\n+\/\/  Valhalla\n+\/\/\n+\/\/  <CMH: merge this doc into the text above>\n+\/\/\n+\/\/  Project Valhalla has mark word encoding requirements for the following oops:\n+\/\/\n+\/\/  * inline types: have alternative bytecode behavior, e.g. can not be locked\n+\/\/    - \"larval state\": mutable state, but only during object init, observable\n+\/\/      by only by a single thread (generally do not mutate markWord)\n+\/\/\n+\/\/  * flat arrays: load\/decode of klass layout helper is expensive for aaload\n+\/\/\n+\/\/  * \"null free\" arrays: load\/decode of klass layout helper again for aaload\n+\/\/\n+\/\/  EnableValhalla\n+\/\/\n+\/\/  Formerly known as \"biased lock bit\", \"unused_gap\" is free to use: using this\n+\/\/  bit to indicate inline type, combined with \"unlocked\" lock bits, means we\n+\/\/  will not interfere with lock encodings (displaced, inflating, and monitor),\n+\/\/  since inline types can't be locked.\n+\/\/\n+\/\/  Further state encoding\n+\/\/\n+\/\/  32 bit plaforms currently have no further room for encoding. No room for\n+\/\/  \"denormalized layout helper bits\", these fast mark word tests can only be made on\n+\/\/  64 bit platforms. 32-bit platforms need to load the klass->_layout_helper. This\n+\/\/  said, the larval state bit is still required for operation, stealing from the hash\n+\/\/  code is simplest mechanism.\n+\/\/\n+\/\/  Valhalla specific encodings\n+\/\/\n+\/\/  Revised Bit-format of an object header (most significant first, big endian layout below):\n+\/\/\n+\/\/  32 bits:\n+\/\/  --------\n+\/\/  hash:24 ------------>| larval:1 age:4 inline_type:1 lock:2\n+\/\/\n+\/\/  64 bits:\n+\/\/  --------\n+\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 null_free_array:1 inline_type:1 lock:2\n+\/\/\n+\/\/  The \"fast\" static type bits (flat_array, null_free_array, and inline_type)\n+\/\/  are placed lowest next to lock bits to more easily decode forwarding pointers.\n+\/\/  G1 for example, implicitly clears age bits (\"G1FullGCCompactionPoint::forward()\")\n+\/\/  using \"oopDesc->forwardee()\", so it necessary for \"markWord::decode_pointer()\"\n+\/\/  to return a non-NULL for this case, but not confuse the static type bits for\n+\/\/  a pointer.\n+\/\/\n+\/\/  Static types bits are recorded in the \"klass->prototype_header()\", displaced\n+\/\/  mark should simply use the prototype header as \"slow path\", rather chasing\n+\/\/  monitor or stack lock races.\n+\/\/\n+\/\/  Lock patterns (note inline types can't be locked\/monitor\/inflating)...\n+\/\/\n+\/\/  [ptr            | 000]  locked             ptr points to real header on stack\n+\/\/  [header         | ?01]  unlocked           regular object header\n+\/\/  [ptr            | 010]  monitor            inflated lock (header is wapped out)\n+\/\/  [ptr            | ?11]  marked             used to mark an object\n+\/\/  [0 ............ | 000]  inflating          inflation in progress\n+\/\/\n+\/\/\n@@ -101,2 +166,1 @@\n-  \/\/ Constants\n-  static const int age_bits                       = 4;\n+  \/\/ Constants, in least significant bit order\n@@ -104,2 +168,9 @@\n-  static const int first_unused_gap_bits          = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n+  static const int first_unused_gap_bits          = 1; \/\/ When !EnableValhalla\n+  \/\/ EnableValhalla: static prototype header bits (fast path instead of klass layout_helper)\n+  static const int inline_type_bits               = 1;\n+  static const int null_free_array_bits           = LP64_ONLY(1) NOT_LP64(0);\n+  static const int flat_array_bits                = LP64_ONLY(1) NOT_LP64(0);\n+  \/\/ instance state\n+  static const int age_bits                       = 4;\n+  static const int larval_bits                    = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - null_free_array_bits;\n@@ -107,1 +178,1 @@\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n+  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0); \/\/ !EnableValhalla: unused\n@@ -110,2 +181,7 @@\n-  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n-  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n+  static const int inline_type_shift              = lock_bits;\n+  static const int null_free_array_shift          = inline_type_shift + inline_type_bits;\n+  static const int flat_array_shift               = null_free_array_shift + null_free_array_bits;\n+  static const int age_shift                      = flat_array_shift + flat_array_bits;\n+  static const int unused_gap_shift               = age_shift + age_bits; \/\/ !EnableValhalla: unused\n+  static const int larval_shift                   = age_shift + age_bits;\n+  static const int hash_shift                     = LP64_ONLY(32) NOT_LP64(larval_shift + larval_bits);\n@@ -115,0 +191,10 @@\n+  static const uintptr_t inline_type_mask         = right_n_bits(lock_bits + inline_type_bits);\n+  static const uintptr_t inline_type_mask_in_place = inline_type_mask << lock_shift;\n+  static const uintptr_t inline_type_bit_in_place = 1 << inline_type_shift;\n+  static const uintptr_t null_free_array_mask     = right_n_bits(null_free_array_bits);\n+  static const uintptr_t null_free_array_mask_in_place = (null_free_array_mask << null_free_array_shift) | lock_mask_in_place;\n+  static const uintptr_t null_free_array_bit_in_place  = (1 << null_free_array_shift);\n+  static const uintptr_t flat_array_mask          = right_n_bits(flat_array_bits);\n+  static const uintptr_t flat_array_mask_in_place = (flat_array_mask << flat_array_shift) | null_free_array_mask_in_place | lock_mask_in_place;\n+  static const uintptr_t flat_array_bit_in_place  = (1 << flat_array_shift);\n+\n@@ -117,0 +203,5 @@\n+\n+  static const uintptr_t larval_mask              = right_n_bits(larval_bits);\n+  static const uintptr_t larval_mask_in_place     = (larval_mask << larval_shift) | inline_type_mask_in_place;\n+  static const uintptr_t larval_bit_in_place      = (1 << larval_shift);\n+\n@@ -125,0 +216,10 @@\n+  static const uintptr_t inline_type_pattern      = inline_type_bit_in_place | unlocked_value;\n+  static const uintptr_t null_free_array_pattern  = null_free_array_bit_in_place | unlocked_value;\n+  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | null_free_array_pattern;\n+  \/\/ Has static klass prototype, used for decode\/encode pointer\n+  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + null_free_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n+  static const uintptr_t static_prototype_mask_in_place = static_prototype_mask << lock_bits;\n+  static const uintptr_t static_prototype_value_max = (1 << age_shift) - 1;\n+\n+  static const uintptr_t larval_pattern           = larval_bit_in_place | inline_type_pattern;\n+\n@@ -134,0 +235,4 @@\n+  bool is_inline_type() const {\n+    return (mask_bits(value(), inline_type_mask_in_place) == inline_type_pattern);\n+  }\n+\n@@ -144,0 +249,3 @@\n+\n+  \/\/ is unlocked and not an inline type (which cannot be involved in locking, displacement or inflation)\n+  \/\/ i.e. test both lock bits and the inline type bit together\n@@ -145,1 +253,1 @@\n-    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n+    return (mask_bits(value(), inline_type_mask_in_place) == unlocked_value);\n@@ -162,1 +270,1 @@\n-    return (!is_unlocked() || !has_no_hash());\n+    return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n@@ -234,0 +342,30 @@\n+  \/\/ private buffered value operations\n+  markWord enter_larval_state() const {\n+    return markWord(value() | larval_bit_in_place);\n+  }\n+  markWord exit_larval_state() const {\n+    return markWord(value() & ~larval_bit_in_place);\n+  }\n+  bool is_larval_state() const {\n+    return (mask_bits(value(), larval_mask_in_place) == larval_pattern);\n+  }\n+\n+#ifdef _LP64 \/\/ 64 bit encodings only\n+  bool is_flat_array() const {\n+    return (mask_bits(value(), flat_array_mask_in_place) == flat_array_pattern);\n+  }\n+\n+  bool is_null_free_array() const {\n+    return (mask_bits(value(), null_free_array_mask_in_place) == null_free_array_pattern);\n+  }\n+#else\n+  bool is_flat_array() const {\n+    fatal(\"Should not ask this for mark word, ask oopDesc\");\n+    return false;\n+  }\n+\n+  bool is_null_free_array() const {\n+    fatal(\"Should not ask this for mark word, ask oopDesc\");\n+    return false;\n+  }\n+#endif\n@@ -239,0 +377,14 @@\n+  static markWord inline_type_prototype() {\n+    return markWord(inline_type_pattern);\n+  }\n+\n+#ifdef _LP64 \/\/ 64 bit encodings only\n+  static markWord flat_array_prototype() {\n+    return markWord(flat_array_pattern);\n+  }\n+\n+  static markWord null_free_array_prototype() {\n+    return markWord(null_free_array_pattern);\n+  }\n+#endif\n+\n@@ -246,1 +398,4 @@\n-  inline void* decode_pointer() { return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() {\n+    return (EnableValhalla && _value < static_prototype_value_max) ? NULL :\n+      (void*) (clear_lock_bits().value());\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":165,"deletions":10,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -123,1 +124,0 @@\n-\n@@ -162,0 +162,5 @@\n+address Method::get_c2i_inline_entry() {\n+  assert(adapter() != NULL, \"must have\");\n+  return adapter()->get_c2i_inline_entry();\n+}\n+\n@@ -167,0 +172,5 @@\n+address Method::get_c2i_unverified_inline_entry() {\n+  assert(adapter() != NULL, \"must have\");\n+  return adapter()->get_c2i_unverified_inline_entry();\n+}\n+\n@@ -672,0 +682,13 @@\n+\/\/ InlineKlass the method is declared to return. This must not\n+\/\/ safepoint as it is called with references live on the stack at\n+\/\/ locations the GC is unaware of.\n+InlineKlass* Method::returns_inline_type(Thread* thread) const {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  NoSafepointVerifier nsv;\n+  SignatureStream ss(signature());\n+  while (!ss.at_return_type()) {\n+    ss.next();\n+  }\n+  return ss.as_inline_klass(method_holder());\n+}\n+\n@@ -677,1 +700,1 @@\n-  \/\/   aload_0\n+  \/\/   aload_0, _fast_aload_0, or _nofast_aload_0\n@@ -701,1 +724,2 @@\n-  if (cb[0] != Bytecodes::_aload_0 || cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {\n+  if ((cb[0] != Bytecodes::_aload_0 && cb[0] != Bytecodes::_fast_aload_0 && cb[0] != Bytecodes::_nofast_aload_0) ||\n+       cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {\n@@ -859,0 +883,5 @@\n+  if (has_scalarized_return()) {\n+    \/\/ Don't treat this as (trivial) getter method because the\n+    \/\/ inline type should be returned in a scalarized form.\n+    return false;\n+  }\n@@ -880,0 +909,5 @@\n+  if (has_scalarized_args()) {\n+    \/\/ Don't treat this as (trivial) setter method because the\n+    \/\/ inline type argument should be passed in a scalarized form.\n+    return false;\n+  }\n@@ -890,5 +924,2 @@\n-          Bytecodes::is_return(java_code_at(last_index)));\n-}\n-\n-bool Method::is_initializer() const {\n-  return is_object_initializer() || is_static_initializer();\n+          Bytecodes::is_return(java_code_at(last_index)) &&\n+          !has_scalarized_args());\n@@ -897,3 +928,2 @@\n-bool Method::has_valid_initializer_flags() const {\n-  return (is_static() ||\n-          method_holder()->major_version() < 51);\n+bool Method::is_object_constructor_or_class_initializer() const {\n+  return (is_object_constructor() || is_class_initializer());\n@@ -902,1 +932,1 @@\n-bool Method::is_static_initializer() const {\n+bool Method::is_class_initializer() const {\n@@ -906,2 +936,3 @@\n-  return name() == vmSymbols::class_initializer_name() &&\n-         has_valid_initializer_flags();\n+  return (name() == vmSymbols::class_initializer_name() &&\n+          (is_static() ||\n+           method_holder()->major_version() < 51));\n@@ -910,2 +941,8 @@\n-bool Method::is_object_initializer() const {\n-   return name() == vmSymbols::object_initializer_name();\n+\/\/ A method named <init>, if non-static, is a classic object constructor.\n+bool Method::is_object_constructor() const {\n+   return name() == vmSymbols::object_initializer_name() && !is_static();\n+}\n+\n+\/\/ A static method named <init> is a factory for an inline class.\n+bool Method::is_static_init_factory() const {\n+   return name() == vmSymbols::object_initializer_name() && is_static();\n@@ -969,1 +1006,1 @@\n-  if( constants()->tag_at(klass_index).is_unresolved_klass() ) {\n+  if( constants()->tag_at(klass_index).is_unresolved_klass()) {\n@@ -985,1 +1022,3 @@\n-    if (constants()->tag_at(klass_index).is_unresolved_klass()) return false;\n+    if (constants()->tag_at(klass_index).is_unresolved_klass()) {\n+      return false;\n+    }\n@@ -1154,0 +1193,2 @@\n+    _from_compiled_inline_entry = NULL;\n+    _from_compiled_inline_ro_entry = NULL;\n@@ -1156,0 +1197,2 @@\n+    _from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1190,0 +1233,2 @@\n+  _from_compiled_inline_entry = NULL;\n+  _from_compiled_inline_ro_entry = NULL;\n@@ -1228,0 +1273,3 @@\n+  if (InlineTypeReturnedAsFields && returns_inline_type(THREAD)) {\n+    set_has_scalarized_return(true);\n+  }\n@@ -1266,0 +1314,2 @@\n+  mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n+  mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n@@ -1273,1 +1323,1 @@\n-address Method::from_compiled_entry_no_trampoline() const {\n+address Method::from_compiled_entry_no_trampoline(bool caller_is_c1) const {\n@@ -1275,2 +1325,7 @@\n-  if (code) {\n-    return code->verified_entry_point();\n+  if (caller_is_c1) {\n+    \/\/ C1 - inline type arguments are passed as objects\n+    if (code) {\n+      return code->verified_inline_entry_point();\n+    } else {\n+      return adapter()->get_c2i_inline_entry();\n+    }\n@@ -1278,1 +1333,6 @@\n-    return adapter()->get_c2i_entry();\n+    \/\/ C2 - inline type arguments may be passed as fields\n+    if (code) {\n+      return code->verified_entry_point();\n+    } else {\n+      return adapter()->get_c2i_entry();\n+    }\n@@ -1295,0 +1355,12 @@\n+address Method::verified_inline_code_entry() {\n+  debug_only(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_entry != NULL, \"must be set\");\n+  return _from_compiled_inline_entry;\n+}\n+\n+address Method::verified_inline_ro_code_entry() {\n+  debug_only(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_ro_entry != NULL, \"must be set\");\n+  return _from_compiled_inline_ro_entry;\n+}\n+\n@@ -1326,0 +1398,2 @@\n+  mh->_from_compiled_inline_entry = code->verified_inline_entry_point();\n+  mh->_from_compiled_inline_ro_entry = code->verified_inline_ro_entry_point();\n@@ -2333,0 +2407,25 @@\n+bool Method::is_scalarized_arg(int idx) const {\n+  if (!has_scalarized_args()) {\n+    return false;\n+  }\n+  \/\/ Search through signature and check if argument is wrapped in T_PRIMITIVE_OBJECT\/T_VOID\n+  int depth = 0;\n+  const GrowableArray<SigEntry>* sig = adapter()->get_sig_cc();\n+  for (int i = 0; i < sig->length(); i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      depth++;\n+    }\n+    if (idx == 0) {\n+      break; \/\/ Argument found\n+    }\n+    if (bt == T_VOID && (sig->at(i-1)._bt != T_LONG && sig->at(i-1)._bt != T_DOUBLE)) {\n+      depth--;\n+    }\n+    if (depth == 0 && bt != T_LONG && bt != T_DOUBLE) {\n+      idx--; \/\/ Advance to next argument\n+    }\n+  }\n+  return depth != 0;\n+}\n+\n@@ -2364,0 +2463,4 @@\n+#ifdef ASSERT\n+  if (valid_itable_index())\n+    st->print_cr(\" - itable index:      %d\",   itable_index());\n+#endif\n@@ -2371,1 +2474,3 @@\n-  st->print_cr(\" - compiled entry     \" INTPTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled entry           \" INTPTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled inline entry    \" INTPTR_FORMAT, p2i(from_compiled_inline_entry()));\n+  st->print_cr(\" - compiled inline ro entry \" INTPTR_FORMAT, p2i(from_compiled_inline_ro_entry()));\n@@ -2441,0 +2546,1 @@\n+  if (WizardMode) access_flags().print_on(st);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":129,"deletions":23,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -95,3 +95,7 @@\n-    _scoped                 = 1 << 7,\n-    _changes_current_thread = 1 << 8,\n-    _jvmti_mount_transition = 1 << 9,\n+    _scalarized_args        = 1 << 7,\n+    _scalarized_return      = 1 << 8,\n+    _c1_needs_stack_repair  = 1 << 9,\n+    _c2_needs_stack_repair  = 1 << 10,\n+    _scoped                 = 1 << 11,\n+    _changes_current_thread = 1 << 12,\n+    _jvmti_mount_transition = 1 << 13,\n@@ -112,1 +116,3 @@\n-  volatile address _from_compiled_entry;        \/\/ Cache of: _code ? _code->entry_point() : _adapter->c2i_entry()\n+  volatile address _from_compiled_entry;           \/\/ Cache of: _code ? _code->verified_entry_point()           : _adapter->c2i_entry()\n+  volatile address _from_compiled_inline_ro_entry; \/\/ Cache of: _code ? _code->verified_inline_ro_entry_point() : _adapter->c2i_inline_ro_entry()\n+  volatile address _from_compiled_inline_entry;    \/\/ Cache of: _code ? _code->verified_inline_entry_point()    : _adapter->c2i_inline_entry()\n@@ -148,1 +154,3 @@\n-  address from_compiled_entry_no_trampoline() const;\n+  address from_compiled_inline_ro_entry() const;\n+  address from_compiled_inline_entry() const;\n+  address from_compiled_entry_no_trampoline(bool caller_is_c1) const;\n@@ -442,0 +450,2 @@\n+  address verified_inline_code_entry();\n+  address verified_inline_ro_code_entry();\n@@ -460,1 +470,7 @@\n-    _from_compiled_entry =  entry;\n+    _from_compiled_entry = entry;\n+  }\n+  void set_from_compiled_inline_ro_entry(address entry) {\n+    _from_compiled_inline_ro_entry = entry;\n+  }\n+  void set_from_compiled_inline_entry(address entry) {\n+    _from_compiled_inline_entry = entry;\n@@ -465,0 +481,1 @@\n+  address get_c2i_inline_entry();\n@@ -466,0 +483,1 @@\n+  address get_c2i_unverified_inline_entry();\n@@ -579,1 +597,1 @@\n-  bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }\n+  InlineKlass* returns_inline_type(Thread* thread) const;\n@@ -654,6 +672,0 @@\n-  \/\/ returns true if the method is an initializer (<init> or <clinit>).\n-  bool is_initializer() const;\n-\n-  \/\/ returns true if the method is static OR if the classfile version < 51\n-  bool has_valid_initializer_flags() const;\n-\n@@ -662,1 +674,8 @@\n-  bool is_static_initializer() const;\n+  bool is_class_initializer() const;\n+\n+  \/\/ returns true if the method name is <init> and the method is not a static factory\n+  bool is_object_constructor() const;\n+\n+  \/\/ returns true if the method is an object constructor or class initializer\n+  \/\/ (non-static <init> or <clinit>), but false for factories (static <init>).\n+  bool is_object_constructor_or_class_initializer() const;\n@@ -664,2 +683,2 @@\n-  \/\/ returns true if the method name is <init>\n-  bool is_object_initializer() const;\n+  \/\/ returns true if the method name is <init> and the method is static\n+  bool is_static_init_factory() const;\n@@ -687,0 +706,2 @@\n+  static ByteSize from_compiled_inline_offset()  { return byte_offset_of(Method, _from_compiled_inline_entry); }\n+  static ByteSize from_compiled_inline_ro_offset(){ return byte_offset_of(Method, _from_compiled_inline_ro_entry); }\n@@ -688,0 +709,1 @@\n+  static ByteSize flags_offset()                 { return byte_offset_of(Method, _flags); }\n@@ -905,0 +927,34 @@\n+  bool has_scalarized_args() const {\n+    return (_flags & _scalarized_args) != 0;\n+  }\n+\n+  void set_has_scalarized_args(bool x) {\n+    _flags = x ? (_flags | _scalarized_args) : (_flags & ~_scalarized_args);\n+  }\n+\n+  bool has_scalarized_return() const {\n+    return (_flags & _scalarized_return) != 0;\n+  }\n+\n+  void set_has_scalarized_return(bool x) {\n+    _flags = x ? (_flags | _scalarized_return) : (_flags & ~_scalarized_return);\n+  }\n+\n+  bool is_scalarized_arg(int idx) const;\n+\n+  bool c1_needs_stack_repair() {\n+    return (_flags & _c1_needs_stack_repair) != 0;\n+  }\n+\n+  bool c2_needs_stack_repair() {\n+    return (_flags & _c2_needs_stack_repair) != 0;\n+  }\n+\n+  void set_c1_needs_stack_repair(bool x) {\n+    _flags = x ? (_flags | _c1_needs_stack_repair) : (_flags & ~_c1_needs_stack_repair);\n+  }\n+\n+  void set_c2_needs_stack_repair(bool x) {\n+    _flags = x ? (_flags | _c2_needs_stack_repair) : (_flags & ~_c2_needs_stack_repair);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":72,"deletions":16,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    st->print(\"flags(%d) \", flags);\n+    st->print(\"flags(%d) %p\/%d\", flags, data(), in_bytes(DataLayout::flags_offset()));\n@@ -212,1 +212,1 @@\n-  assert(TypeStackSlotEntries::per_arg_count() > ReturnTypeEntry::static_cell_count(), \"code to test for arguments\/results broken\");\n+  assert(TypeStackSlotEntries::per_arg_count() > SingleTypeEntry::static_cell_count(), \"code to test for arguments\/results broken\");\n@@ -222,1 +222,1 @@\n-    ret_cell = ReturnTypeEntry::static_cell_count();\n+    ret_cell = SingleTypeEntry::static_cell_count();\n@@ -325,1 +325,1 @@\n-void ReturnTypeEntry::clean_weak_klass_links(bool always_clean) {\n+void SingleTypeEntry::clean_weak_klass_links(bool always_clean) {\n@@ -363,1 +363,1 @@\n-void ReturnTypeEntry::print_data_on(outputStream* st) const {\n+void SingleTypeEntry::print_data_on(outputStream* st) const {\n@@ -528,0 +528,4 @@\n+  if (data()->flags()) {\n+    tty->cr();\n+    tab(st);\n+  }\n@@ -653,0 +657,21 @@\n+void ArrayLoadStoreData::print_data_on(outputStream* st, const char* extra) const {\n+  print_shared(st, \"ArrayLoadStore\", extra);\n+  st->cr();\n+  tab(st, true);\n+  st->print(\"array\");\n+  _array.print_data_on(st);\n+  tab(st, true);\n+  st->print(\"element\");\n+  _element.print_data_on(st);\n+}\n+\n+void ACmpData::print_data_on(outputStream* st, const char* extra) const {\n+  BranchData::print_data_on(st, extra);\n+  tab(st, true);\n+  st->print(\"left\");\n+  _left.print_data_on(st);\n+  tab(st, true);\n+  st->print(\"right\");\n+  _right.print_data_on(st);\n+}\n+\n@@ -673,1 +698,0 @@\n-  case Bytecodes::_aastore:\n@@ -679,0 +703,3 @@\n+  case Bytecodes::_aaload:\n+  case Bytecodes::_aastore:\n+    return ArrayLoadStoreData::static_cell_count();\n@@ -718,2 +745,0 @@\n-  case Bytecodes::_if_acmpeq:\n-  case Bytecodes::_if_acmpne:\n@@ -723,0 +748,3 @@\n+  case Bytecodes::_if_acmpne:\n+  case Bytecodes::_if_acmpeq:\n+    return ACmpData::static_cell_count();\n@@ -781,0 +809,1 @@\n+  case Bytecodes::_aaload:\n@@ -984,1 +1013,0 @@\n-  case Bytecodes::_aastore:\n@@ -993,0 +1021,5 @@\n+  case Bytecodes::_aaload:\n+  case Bytecodes::_aastore:\n+    cell_count = ArrayLoadStoreData::static_cell_count();\n+    tag = DataLayout::array_load_store_data_tag;\n+    break;\n@@ -1064,2 +1097,0 @@\n-  case Bytecodes::_if_acmpeq:\n-  case Bytecodes::_if_acmpne:\n@@ -1071,0 +1102,5 @@\n+  case Bytecodes::_if_acmpeq:\n+  case Bytecodes::_if_acmpne:\n+    cell_count = ACmpData::static_cell_count();\n+    tag = DataLayout::acmp_data_tag;\n+    break;\n@@ -1138,0 +1174,4 @@\n+  case DataLayout::array_load_store_data_tag:\n+    return ((new ArrayLoadStoreData(this))->cell_count());\n+  case DataLayout::acmp_data_tag:\n+    return ((new ACmpData(this))->cell_count());\n@@ -1172,0 +1212,4 @@\n+  case DataLayout::array_load_store_data_tag:\n+    return new ArrayLoadStoreData(this);\n+  case DataLayout::acmp_data_tag:\n+    return new ACmpData(this);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":55,"deletions":11,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -131,1 +131,3 @@\n-    speculative_trap_data_tag\n+    speculative_trap_data_tag,\n+    array_load_store_data_tag,\n+    acmp_data_tag\n@@ -267,0 +269,1 @@\n+class       ACmpData;\n@@ -272,0 +275,1 @@\n+class   ArrayLoadStoreData;\n@@ -279,1 +283,1 @@\n-  friend class ReturnTypeEntry;\n+  friend class SingleTypeEntry;\n@@ -400,0 +404,2 @@\n+  virtual bool is_ArrayLoadStoreData() const { return false; }\n+  virtual bool is_ACmpData()           const { return false; }\n@@ -458,0 +464,8 @@\n+  ArrayLoadStoreData* as_ArrayLoadStoreData() const {\n+    assert(is_ArrayLoadStoreData(), \"wrong type\");\n+    return is_ArrayLoadStoreData() ? (ArrayLoadStoreData*)this : NULL;\n+  }\n+  ACmpData* as_ACmpData() const {\n+    assert(is_ACmpData(), \"wrong type\");\n+    return is_ACmpData() ? (ACmpData*)this : NULL;\n+  }\n@@ -612,1 +626,2 @@\n-      layout->tag() == DataLayout::branch_data_tag, \"wrong type\");\n+      layout->tag() == DataLayout::branch_data_tag ||\n+      layout->tag() == DataLayout::acmp_data_tag, \"wrong type\");\n@@ -848,1 +863,1 @@\n-class ReturnTypeEntry : public TypeEntries {\n+class SingleTypeEntry : public TypeEntries {\n@@ -856,1 +871,1 @@\n-  ReturnTypeEntry(int base_off)\n+  SingleTypeEntry(int base_off)\n@@ -890,1 +905,1 @@\n-\/\/ (TypeStackSlotEntries), a return type (ReturnTypeEntry) and a\n+\/\/ (TypeStackSlotEntries), a return type (SingleTypeEntry) and a\n@@ -944,1 +959,1 @@\n-    return ReturnTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);\n+    return SingleTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);\n@@ -959,1 +974,1 @@\n-  ReturnTypeEntry _ret;\n+  SingleTypeEntry _ret;\n@@ -978,1 +993,1 @@\n-    _ret(cell_count() - ReturnTypeEntry::static_cell_count())\n+    _ret(cell_count() - SingleTypeEntry::static_cell_count())\n@@ -991,1 +1006,1 @@\n-  const ReturnTypeEntry* ret() const {\n+  const SingleTypeEntry* ret() const {\n@@ -1262,1 +1277,1 @@\n-  ReturnTypeEntry _ret;\n+  SingleTypeEntry _ret;\n@@ -1281,1 +1296,1 @@\n-    _ret(cell_count() - ReturnTypeEntry::static_cell_count())\n+    _ret(cell_count() - SingleTypeEntry::static_cell_count())\n@@ -1294,1 +1309,1 @@\n-  const ReturnTypeEntry* ret() const {\n+  const SingleTypeEntry* ret() const {\n@@ -1496,1 +1511,1 @@\n-    assert(layout->tag() == DataLayout::branch_data_tag, \"wrong type\");\n+    assert(layout->tag() == DataLayout::branch_data_tag || layout->tag() == DataLayout::acmp_data_tag, \"wrong type\");\n@@ -1850,0 +1865,146 @@\n+  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+};\n+\n+class ArrayLoadStoreData : public ProfileData {\n+private:\n+  enum {\n+    flat_array_flag = DataLayout::first_flag,\n+    null_free_array_flag = flat_array_flag + 1,\n+  };\n+\n+  SingleTypeEntry _array;\n+  SingleTypeEntry _element;\n+\n+public:\n+  ArrayLoadStoreData(DataLayout* layout) :\n+    ProfileData(layout),\n+    _array(0),\n+    _element(SingleTypeEntry::static_cell_count()) {\n+    assert(layout->tag() == DataLayout::array_load_store_data_tag, \"wrong type\");\n+    _array.set_profile_data(this);\n+    _element.set_profile_data(this);\n+  }\n+\n+  const SingleTypeEntry* array() const {\n+    return &_array;\n+  }\n+\n+  const SingleTypeEntry* element() const {\n+    return &_element;\n+  }\n+\n+  virtual bool is_ArrayLoadStoreData() const { return true; }\n+\n+  static int static_cell_count() {\n+    return SingleTypeEntry::static_cell_count() * 2;\n+  }\n+\n+  virtual int cell_count() const {\n+    return static_cell_count();\n+  }\n+\n+  void set_flat_array() { set_flag_at(flat_array_flag); }\n+  bool flat_array() const { return flag_at(flat_array_flag); }\n+\n+  void set_null_free_array() { set_flag_at(null_free_array_flag); }\n+  bool null_free_array() const { return flag_at(null_free_array_flag); }\n+\n+  \/\/ Code generation support\n+  static int flat_array_byte_constant() {\n+    return flag_number_to_constant(flat_array_flag);\n+  }\n+\n+  static int null_free_array_byte_constant() {\n+    return flag_number_to_constant(null_free_array_flag);\n+  }\n+\n+  static ByteSize array_offset() {\n+    return cell_offset(0);\n+  }\n+\n+  static ByteSize element_offset() {\n+    return cell_offset(SingleTypeEntry::static_cell_count());\n+  }\n+\n+  virtual void clean_weak_klass_links(bool always_clean) {\n+    _array.clean_weak_klass_links(always_clean);\n+    _element.clean_weak_klass_links(always_clean);\n+  }\n+\n+  static ByteSize array_load_store_data_size() {\n+    return cell_offset(static_cell_count());\n+  }\n+\n+  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+};\n+\n+class ACmpData : public BranchData {\n+private:\n+  enum {\n+    left_inline_type_flag = DataLayout::first_flag,\n+    right_inline_type_flag\n+  };\n+\n+  SingleTypeEntry _left;\n+  SingleTypeEntry _right;\n+\n+public:\n+  ACmpData(DataLayout* layout) :\n+    BranchData(layout),\n+    _left(BranchData::static_cell_count()),\n+    _right(BranchData::static_cell_count() + SingleTypeEntry::static_cell_count()) {\n+    assert(layout->tag() == DataLayout::acmp_data_tag, \"wrong type\");\n+    _left.set_profile_data(this);\n+    _right.set_profile_data(this);\n+  }\n+\n+  const SingleTypeEntry* left() const {\n+    return &_left;\n+  }\n+\n+  const SingleTypeEntry* right() const {\n+    return &_right;\n+  }\n+\n+  virtual bool is_ACmpData() const { return true; }\n+\n+  static int static_cell_count() {\n+    return BranchData::static_cell_count() + SingleTypeEntry::static_cell_count() * 2;\n+  }\n+\n+  virtual int cell_count() const {\n+    return static_cell_count();\n+  }\n+\n+  void set_left_inline_type() { set_flag_at(left_inline_type_flag); }\n+  bool left_inline_type() const { return flag_at(left_inline_type_flag); }\n+\n+  void set_right_inline_type() { set_flag_at(right_inline_type_flag); }\n+  bool right_inline_type() const { return flag_at(right_inline_type_flag); }\n+\n+  \/\/ Code generation support\n+  static int left_inline_type_byte_constant() {\n+    return flag_number_to_constant(left_inline_type_flag);\n+  }\n+\n+  static int right_inline_type_byte_constant() {\n+    return flag_number_to_constant(right_inline_type_flag);\n+  }\n+\n+  static ByteSize left_offset() {\n+    return cell_offset(BranchData::static_cell_count());\n+  }\n+\n+  static ByteSize right_offset() {\n+    return cell_offset(BranchData::static_cell_count() + SingleTypeEntry::static_cell_count());\n+  }\n+\n+  virtual void clean_weak_klass_links(bool always_clean) {\n+    _left.clean_weak_klass_links(always_clean);\n+    _right.clean_weak_klass_links(always_clean);\n+  }\n+\n+  static ByteSize acmp_data_size() {\n+    return cell_offset(static_cell_count());\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":175,"deletions":14,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -48,1 +49,3 @@\n-ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {\n+ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n,\n+                                       Klass* k, Symbol* name, bool null_free,\n+                                       TRAPS) {\n@@ -54,1 +57,1 @@\n-  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);\n+  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name, null_free);\n@@ -58,1 +61,3 @@\n-                                                      int n, Klass* element_klass, TRAPS) {\n+                                                      int n, Klass* element_klass,\n+                                                      bool null_free, bool qdesc, TRAPS) {\n+  assert(!null_free || (n == 1 && element_klass->is_inline_klass() && qdesc), \"null-free unsupported\");\n@@ -66,1 +71,5 @@\n-      super_klass = element_super->array_klass_or_null();\n+      if (null_free) {\n+        super_klass = element_klass->array_klass_or_null();\n+      } else {\n+        super_klass = element_super->array_klass_or_null();\n+      }\n@@ -78,0 +87,5 @@\n+      if (null_free) {\n+        if (element_klass->array_klass_or_null() == NULL) {\n+          supers_exist = false;\n+        }\n+      }\n@@ -83,1 +97,5 @@\n-          super_klass = element_super->array_klass(CHECK_NULL);\n+          if (null_free) {\n+            element_klass->array_klass(CHECK_NULL);\n+          } else {\n+            element_super->array_klass(CHECK_NULL);\n+          }\n@@ -89,1 +107,5 @@\n-          ek = element_klass->array_klass(n, CHECK_NULL);\n+          if (null_free) {\n+            ek = InlineKlass::cast(element_klass)->value_array_klass(CHECK_NULL);\n+          } else {\n+            ek = element_klass->array_klass(n, CHECK_NULL);\n+          }\n@@ -100,19 +122,1 @@\n-  Symbol* name = NULL;\n-  {\n-    ResourceMark rm(THREAD);\n-    char *name_str = element_klass->name()->as_C_string();\n-    int len = element_klass->name()->utf8_length();\n-    char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);\n-    int idx = 0;\n-    new_str[idx++] = JVM_SIGNATURE_ARRAY;\n-    if (element_klass->is_instance_klass()) { \/\/ it could be an array or simple type\n-      new_str[idx++] = JVM_SIGNATURE_CLASS;\n-    }\n-    memcpy(&new_str[idx], name_str, len * sizeof(char));\n-    idx += len;\n-    if (element_klass->is_instance_klass()) {\n-      new_str[idx++] = JVM_SIGNATURE_ENDCLASS;\n-    }\n-    new_str[idx++] = '\\0';\n-    name = SymbolTable::new_symbol(new_str);\n-  }\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, qdesc, CHECK_NULL);\n@@ -121,1 +125,1 @@\n-  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, null_free, CHECK_NULL);\n@@ -139,1 +143,1 @@\n-ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, Kind) {\n+ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) : ArrayKlass(name, Kind) {\n@@ -143,0 +147,2 @@\n+  assert(!null_free || name->is_Q_array_signature(), \"sanity check\");\n+\n@@ -146,0 +152,2 @@\n+  } else if (element_klass->is_flatArray_klass()) {\n+    bk = FlatArrayKlass::cast(element_klass)->element_klass();\n@@ -153,1 +161,12 @@\n-  set_layout_helper(array_layout_helper(T_OBJECT));\n+  int lh = array_layout_helper(T_OBJECT);\n+  if (null_free) {\n+    assert(n == 1, \"Bytecode does not support null-free multi-dim\");\n+    lh = layout_helper_set_null_free(lh);\n+#ifdef _LP64\n+    set_prototype_header(markWord::null_free_array_prototype());\n+    assert(prototype_header().is_null_free_array(), \"sanity\");\n+#else\n+    set_prototype_header(markWord::inline_type_prototype());\n+#endif\n+  }\n+  set_layout_helper(lh);\n@@ -166,2 +185,17 @@\n-  return (objArrayOop)Universe::heap()->array_allocate(this, size, length,\n-                                                       \/* do_zero *\/ true, THREAD);\n+  bool populate_null_free = is_null_free_array_klass();\n+  objArrayOop array =  (objArrayOop)Universe::heap()->array_allocate(this, size, length,\n+                                                       \/* do_zero *\/ true, CHECK_NULL);\n+  objArrayHandle array_h(THREAD, array);\n+  if (populate_null_free) {\n+    assert(dimension() == 1, \"Can only populate the final dimension\");\n+    assert(element_klass()->is_inline_klass(), \"Unexpected\");\n+    assert(!element_klass()->is_array_klass(), \"ArrayKlass unexpected here\");\n+    assert(!InlineKlass::cast(element_klass())->flatten_array(), \"Expected flatArrayOop allocation\");\n+    element_klass()->initialize(CHECK_NULL);\n+    \/\/ Populate default values...\n+    instanceOop value = (instanceOop) InlineKlass::cast(element_klass())->default_value();\n+    for (int i = 0; i < length; i++) {\n+      array_h->obj_at_put(i, value);\n+    }\n+  }\n+  return array_h();\n@@ -172,0 +206,8 @@\n+  if (rank == 1) { \/\/ last dim may be flatArray, check if we have any special storage requirements\n+    if (name()->char_at(1) != JVM_SIGNATURE_ARRAY &&  name()->is_Q_array_signature()) {\n+      return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);\n+    } else {\n+      return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);\n+    }\n+  }\n+  guarantee(rank > 1, \"Rank below 1\");\n@@ -178,16 +220,14 @@\n-  if (rank > 1) {\n-    if (length != 0) {\n-      for (int index = 0; index < length; index++) {\n-        ArrayKlass* ak = ArrayKlass::cast(ld_klass);\n-        oop sub_array = ak->multi_allocate(rank-1, &sizes[1], CHECK_NULL);\n-        h_array->obj_at_put(index, sub_array);\n-      }\n-    } else {\n-      \/\/ Since this array dimension has zero length, nothing will be\n-      \/\/ allocated, however the lower dimension values must be checked\n-      \/\/ for illegal values.\n-      for (int i = 0; i < rank - 1; ++i) {\n-        sizes += 1;\n-        if (*sizes < 0) {\n-          THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(\"%d\", *sizes));\n-        }\n+  if (length != 0) {\n+    for (int index = 0; index < length; index++) {\n+      ArrayKlass* ak = ArrayKlass::cast(ld_klass);\n+      oop sub_array = ak->multi_allocate(rank-1, &sizes[1], CHECK_NULL);\n+      h_array->obj_at_put(index, sub_array);\n+    }\n+  } else {\n+    \/\/ Since this array dimension has zero length, nothing will be\n+    \/\/ allocated, however the lower dimension values must be checked\n+    \/\/ for illegal values.\n+    for (int i = 0; i < rank - 1; ++i) {\n+      sizes += 1;\n+      if (*sizes < 0) {\n+        THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(\"%d\", *sizes));\n@@ -211,0 +251,3 @@\n+    \/\/ Perform null check if dst is null-free but src has no such guarantee\n+    bool null_check = ((!s->klass()->is_null_free_array_klass()) &&\n+        d->klass()->is_null_free_array_klass());\n@@ -212,2 +255,5 @@\n-      \/\/ elements are guaranteed to be subtypes, so no check necessary\n-      ArrayAccess<ARRAYCOPY_DISJOINT>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n+      if (null_check) {\n+        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n+      } else {\n+        ArrayAccess<ARRAYCOPY_DISJOINT>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n+      }\n@@ -215,16 +261,4 @@\n-      \/\/ slow case: need individual subtype checks\n-      \/\/ note: don't use obj_at_put below because it includes a redundant store check\n-      if (!ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST>::oop_arraycopy(s, src_offset, d, dst_offset, length)) {\n-        ResourceMark rm(THREAD);\n-        stringStream ss;\n-        if (!bound->is_subtype_of(stype)) {\n-          ss.print(\"arraycopy: type mismatch: can not copy %s[] into %s[]\",\n-                   stype->external_name(), bound->external_name());\n-        } else {\n-          \/\/ oop_arraycopy should return the index in the source array that\n-          \/\/ contains the problematic oop.\n-          ss.print(\"arraycopy: element type mismatch: can not cast one of the elements\"\n-                   \" of %s[] to the type of the destination array, %s\",\n-                   stype->external_name(), bound->external_name());\n-        }\n-        THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+      if (null_check) {\n+        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n+      } else {\n+        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n@@ -240,0 +274,7 @@\n+  if (EnableValhalla) {\n+    if (d->is_flatArray()) {\n+      FlatArrayKlass::cast(d->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);\n+      return;\n+    }\n+  }\n+\n@@ -312,1 +353,0 @@\n-\n@@ -329,2 +369,2 @@\n-        Klass* k =\n-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n+                                                          false, this->name()->is_Q_array_signature(), CHECK_NULL);\n@@ -440,1 +480,1 @@\n-  st->print(\" - instance klass: \");\n+  st->print(\" - element klass: \");\n@@ -502,1 +542,2 @@\n-  guarantee(bk->is_instance_klass() || bk->is_typeArray_klass(),  \"invalid bottom klass\");\n+  guarantee(bk->is_instance_klass() || bk->is_typeArray_klass() || bk->is_flatArray_klass(),\n+            \"invalid bottom klass\");\n@@ -508,0 +549,1 @@\n+  guarantee(obj->is_null_free_array() || (!is_null_free_array_klass()), \"null-free klass but not object\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":111,"deletions":69,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n@@ -49,2 +48,2 @@\n-  ObjArrayKlass(int n, Klass* element_klass, Symbol* name);\n-  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);\n+  ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free);\n+  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, bool null_free, TRAPS);\n@@ -55,5 +54,0 @@\n-  \/\/ Instance variables\n-  Klass* element_klass() const      { return _element_klass; }\n-  void set_element_klass(Klass* k)  { _element_klass = k; }\n-  Klass** element_klass_addr()      { return &_element_klass; }\n-\n@@ -67,3 +61,0 @@\n-  \/\/ Compiler\/Interpreter offset\n-  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ObjArrayKlass, _element_klass)); }\n-\n@@ -79,1 +70,2 @@\n-                                                int n, Klass* element_klass, TRAPS);\n+                                                int n, Klass* element_klass,\n+                                                bool null_free, bool qdesc, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  return ObjectSynchronizer::identity_hash_value_for(object);\n+  return ObjectSynchronizer::FastHashCode(current, object());\n@@ -123,1 +123,1 @@\n-  return !SafepointSynchronize::is_at_safepoint();\n+  return !SafepointSynchronize::is_at_safepoint() ;\n@@ -142,6 +142,8 @@\n-bool oopDesc::is_instance_noinline()    const { return is_instance();    }\n-bool oopDesc::is_instanceRef_noinline() const { return is_instanceRef(); }\n-bool oopDesc::is_stackChunk_noinline()  const { return is_stackChunk();  }\n-bool oopDesc::is_array_noinline()       const { return is_array();       }\n-bool oopDesc::is_objArray_noinline()    const { return is_objArray();    }\n-bool oopDesc::is_typeArray_noinline()   const { return is_typeArray();   }\n+bool oopDesc::is_instance_noinline()        const { return is_instance();         }\n+bool oopDesc::is_instanceRef_noinline()     const { return is_instanceRef();      }\n+bool oopDesc::is_stackChunk_noinline()      const { return is_stackChunk();       }\n+bool oopDesc::is_array_noinline()           const { return is_array();            }\n+bool oopDesc::is_objArray_noinline()        const { return is_objArray();         }\n+bool oopDesc::is_typeArray_noinline()       const { return is_typeArray();        }\n+bool oopDesc::is_flatArray_noinline()       const { return is_flatArray();        }\n+bool oopDesc::is_null_free_array_noinline() const { return is_null_free_array();  }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,0 +44,10 @@\n+\/\/\n+\/\/ oopDesc::_mark - the \"oop mark word\" encoding to be found separately in markWord.hpp\n+\/\/\n+\/\/ oopDesc::_metadata - encodes the object's klass pointer, as a raw pointer in \"_klass\"\n+\/\/                      or compressed pointer in \"_compressed_klass\"\n+\/\/\n+\/\/ The overall size of the _metadata field is dependent on \"UseCompressedClassPointers\",\n+\/\/ hence the terms \"narrow\" (32 bits) vs \"wide\" (64 bits).\n+\/\/\n+\n@@ -110,6 +120,9 @@\n-  inline bool is_instance()    const;\n-  inline bool is_instanceRef() const;\n-  inline bool is_stackChunk()  const;\n-  inline bool is_array()       const;\n-  inline bool is_objArray()    const;\n-  inline bool is_typeArray()   const;\n+  inline bool is_instance()         const;\n+  inline bool is_inline_type()      const;\n+  inline bool is_instanceRef()      const;\n+  inline bool is_stackChunk()       const;\n+  inline bool is_array()            const;\n+  inline bool is_objArray()         const;\n+  inline bool is_typeArray()        const;\n+  inline bool is_flatArray()        const;\n+  inline bool is_null_free_array()  const;\n@@ -118,6 +131,8 @@\n-  bool is_instance_noinline()    const;\n-  bool is_instanceRef_noinline() const;\n-  bool is_stackChunk_noinline()  const;\n-  bool is_array_noinline()       const;\n-  bool is_objArray_noinline()    const;\n-  bool is_typeArray_noinline()   const;\n+  bool is_instance_noinline()         const;\n+  bool is_instanceRef_noinline()      const;\n+  bool is_stackChunk_noinline()       const;\n+  bool is_array_noinline()            const;\n+  bool is_objArray_noinline()         const;\n+  bool is_typeArray_noinline()        const;\n+  bool is_flatArray_noinline()        const;\n+  bool is_null_free_array_noinline()  const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  set_mark(markWord::prototype());\n+  set_mark(Klass::default_prototype_header(klass()));\n@@ -199,0 +199,15 @@\n+bool oopDesc::is_inline_type() const { return mark().is_inline_type(); }\n+#ifdef _LP64\n+bool oopDesc::is_flatArray() const {\n+  markWord mrk = mark();\n+  return (mrk.is_unlocked()) ? mrk.is_flat_array() : klass()->is_flatArray_klass();\n+}\n+bool oopDesc::is_null_free_array() const {\n+  markWord mrk = mark();\n+  return (mrk.is_unlocked()) ? mrk.is_null_free_array() : klass()->is_null_free_array_klass();\n+}\n+#else\n+bool oopDesc::is_flatArray()       const { return klass()->is_flatArray_klass(); }\n+bool oopDesc::is_null_free_array() const { return klass()->is_null_free_array_klass(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+typedef class     flatArrayOopDesc*           flatArrayOop;\n@@ -151,0 +152,1 @@\n+DEF_OOP(flatArray);\n@@ -179,0 +181,1 @@\n+class     InlineKlass;\n@@ -186,0 +189,1 @@\n+class     FlatArrayKlass;\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  bool starts_with(int prefix_char) const {\n+  bool starts_with(char prefix_char) const {\n@@ -233,0 +233,12 @@\n+  \/\/ True if this is a descriptor for a method with void return.\n+  \/\/ (Assumes it is a valid descriptor.)\n+  bool is_void_method_signature() const {\n+    return starts_with('(') && ends_with('V');\n+  }\n+\n+  bool is_Q_signature() const;\n+  bool is_Q_array_signature() const;\n+  bool is_Q_method_signature() const;\n+  Symbol* fundamental_name(TRAPS);\n+  bool is_same_fundamental_type(Symbol*) const;\n+\n@@ -276,0 +288,1 @@\n+  void print_Qvalue_on(outputStream* st) const;  \/\/ Second level print for Q-types.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-  \/\/ For typeArrays this is only called for the last dimension\n@@ -191,1 +190,1 @@\n-              class_loader_data(), dim + 1, this, CHECK_NULL);\n+              class_loader_data(), dim + 1, this, false, false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -663,0 +663,6 @@\n+  if (tp->isa_aryptr()) {\n+    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ own slice so we need to extract the field being accessed from\n+    \/\/ the address computation\n+    return tp->is_aryptr()->add_field_offset_and_offset(txoffset);\n+  }\n@@ -683,0 +689,6 @@\n+  if (p1->isa_aryptr()) {\n+    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ own slice so we need to extract the field being accessed from\n+    \/\/ the address computation\n+    return p1->is_aryptr()->add_field_offset_and_offset(p2offset);\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -117,3 +119,7 @@\n-  Node* src = in(ArrayCopyNode::Src);\n-  const Type* src_type = phase->type(src);\n-\n+    Node* src = in(ArrayCopyNode::Src);\n+    const Type* src_type = phase->type(src);\n+\n+    if (src_type == Type::TOP) {\n+      return -1;\n+    }\n+\n@@ -141,0 +147,1 @@\n+             (UseFlatArray && ary_src->elem()->make_oopptr() != NULL && ary_src->elem()->make_oopptr()->can_be_inline_type()) ||\n@@ -192,0 +199,1 @@\n+  phase->record_for_igvn(mem);\n@@ -275,2 +283,6 @@\n-    if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n-    if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n+    if (src_elem == T_ARRAY || src_elem == T_NARROWOOP || (src_elem == T_PRIMITIVE_OBJECT && !ary_src->is_flat())) {\n+      src_elem  = T_OBJECT;\n+    }\n+    if (dest_elem == T_ARRAY || dest_elem == T_NARROWOOP || (dest_elem == T_PRIMITIVE_OBJECT && !ary_dest->is_flat())) {\n+      dest_elem = T_OBJECT;\n+    }\n@@ -284,3 +296,4 @@\n-    if (bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, false, BarrierSetC2::Optimization)) {\n-      \/\/ It's an object array copy but we can't emit the card marking\n-      \/\/ that is needed\n+    if (bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, false, BarrierSetC2::Optimization) ||\n+        (src_elem == T_PRIMITIVE_OBJECT && ary_src->elem()->inline_klass()->contains_oops() &&\n+         bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, false, BarrierSetC2::Optimization))) {\n+      \/\/ It's an object array copy but we can't emit the card marking that is needed\n@@ -293,0 +306,4 @@\n+    if (dest_elem == T_PRIMITIVE_OBJECT) {\n+      ciFlatArrayKlass* vak = ary_src->klass()->as_flat_array_klass();\n+      shift = vak->log2_element_size();\n+    }\n@@ -326,0 +343,5 @@\n+    if (ary_src->elem()->make_oopptr() != NULL &&\n+        ary_src->elem()->make_oopptr()->can_be_inline_type()) {\n+      return false;\n+    }\n+\n@@ -327,1 +349,1 @@\n-    if (is_reference_type(elem, true)) {\n+    if (elem == T_ARRAY || elem == T_NARROWOOP || (elem == T_PRIMITIVE_OBJECT && !ary_src->is_flat())) {\n@@ -332,1 +354,4 @@\n-    if (bs->array_copy_requires_gc_barriers(true, elem, true, is_clone_inst(), BarrierSetC2::Optimization)) {\n+    if (bs->array_copy_requires_gc_barriers(true, elem, true, is_clone_inst(), BarrierSetC2::Optimization) ||\n+        (elem == T_PRIMITIVE_OBJECT && ary_src->elem()->inline_klass()->contains_oops() &&\n+         bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, is_clone_inst(), BarrierSetC2::Optimization))) {\n+      \/\/ It's an object array copy but we can't emit the card marking that is needed\n@@ -356,1 +381,1 @@\n-const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {\n+const TypeAryPtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {\n@@ -361,1 +386,1 @@\n-  return atp->add_offset(Type::OffsetBot);\n+  return atp->add_offset(Type::OffsetBot)->is_aryptr();\n@@ -364,2 +389,2 @@\n-void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*& forward_ctl, Node*& backward_ctl) {\n-  Node* ctl = in(TypeFunc::Control);\n+void ArrayCopyNode::array_copy_test_overlap(GraphKit& kit, bool disjoint_bases, int count, Node*& backward_ctl) {\n+  Node* ctl = kit.control();\n@@ -367,0 +392,1 @@\n+    PhaseGVN& gvn = kit.gvn();\n@@ -370,2 +396,2 @@\n-    Node* cmp = phase->transform(new CmpINode(src_offset, dest_offset));\n-    Node *bol = phase->transform(new BoolNode(cmp, BoolTest::lt));\n+    Node* cmp = gvn.transform(new CmpINode(src_offset, dest_offset));\n+    Node *bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n@@ -374,1 +400,1 @@\n-    phase->transform(iff);\n+    gvn.transform(iff);\n@@ -376,2 +402,38 @@\n-    forward_ctl = phase->transform(new IfFalseNode(iff));\n-    backward_ctl = phase->transform(new IfTrueNode(iff));\n+    kit.set_control(gvn.transform(new IfFalseNode(iff)));\n+    backward_ctl = gvn.transform(new IfTrueNode(iff));\n+  }\n+}\n+\n+void ArrayCopyNode::copy(GraphKit& kit,\n+                         const TypeAryPtr* atp_src,\n+                         const TypeAryPtr* atp_dest,\n+                         int i,\n+                         Node* base_src,\n+                         Node* base_dest,\n+                         Node* adr_src,\n+                         Node* adr_dest,\n+                         BasicType copy_type,\n+                         const Type* value_type) {\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  Node* ctl = kit.control();\n+  if (copy_type == T_PRIMITIVE_OBJECT) {\n+    ciFlatArrayKlass* vak = atp_src->klass()->as_flat_array_klass();\n+    ciInlineKlass* vk = vak->element_klass()->as_inline_klass();\n+    for (int j = 0; j < vk->nof_nonstatic_fields(); j++) {\n+      ciField* field = vk->nonstatic_field_at(j);\n+      int off_in_vt = field->offset() - vk->first_field_offset();\n+      Node* off  = kit.MakeConX(off_in_vt + i * vak->element_byte_size());\n+      ciType* ft = field->type();\n+      BasicType bt = type2field[ft->basic_type()];\n+      assert(!field->is_flattened(), \"flattened field encountered\");\n+      if (bt == T_PRIMITIVE_OBJECT) {\n+        bt = T_OBJECT;\n+      }\n+      const Type* rt = Type::get_const_type(ft);\n+      const TypePtr* adr_type = atp_src->with_field_offset(off_in_vt)->add_offset(Type::OffsetBot);\n+      assert(!bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, false, BarrierSetC2::Optimization), \"GC barriers required\");\n+      Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));\n+      Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));\n+      Node* v = load(bs, &kit.gvn(), ctl, kit.merged_memory(), next_src, adr_type, rt, bt);\n+      store(bs, &kit.gvn(), ctl, kit.merged_memory(), next_dest, adr_type, v, rt, bt);\n+    }\n@@ -379,1 +441,5 @@\n-    forward_ctl = ctl;\n+    Node* off = kit.MakeConX(type2aelembytes(copy_type) * i);\n+    Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));\n+    Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));\n+    Node* v = load(bs, &kit.gvn(), ctl, kit.merged_memory(), next_src, atp_src, value_type, copy_type);\n+    store(bs, &kit.gvn(), ctl, kit.merged_memory(), next_dest, atp_dest, v, value_type, copy_type);\n@@ -381,0 +447,1 @@\n+  kit.set_control(ctl);\n@@ -383,16 +450,13 @@\n-Node* ArrayCopyNode::array_copy_forward(PhaseGVN *phase,\n-                                        bool can_reshape,\n-                                        Node*& forward_ctl,\n-                                        Node* mem,\n-                                        const TypePtr* atp_src,\n-                                        const TypePtr* atp_dest,\n-                                        Node* adr_src,\n-                                        Node* base_src,\n-                                        Node* adr_dest,\n-                                        Node* base_dest,\n-                                        BasicType copy_type,\n-                                        const Type* value_type,\n-                                        int count) {\n-  if (!forward_ctl->is_top()) {\n-    \/\/ copy forward\n-    MergeMemNode* mm = MergeMemNode::make(mem);\n+void ArrayCopyNode::array_copy_forward(GraphKit& kit,\n+                                       bool can_reshape,\n+                                       const TypeAryPtr* atp_src,\n+                                       const TypeAryPtr* atp_dest,\n+                                       Node* adr_src,\n+                                       Node* base_src,\n+                                       Node* adr_dest,\n+                                       Node* base_dest,\n+                                       BasicType copy_type,\n+                                       const Type* value_type,\n+                                       int count) {\n+  if (!kit.stopped()) {\n+    \/\/ copy forward\n@@ -401,9 +465,2 @@\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      Node* v = load(bs, phase, forward_ctl, mm, adr_src, atp_src, value_type, copy_type);\n-      store(bs, phase, forward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);\n-      for (int i = 1; i < count; i++) {\n-        Node* off  = phase->MakeConX(type2aelembytes(copy_type) * i);\n-        Node* next_src = phase->transform(new AddPNode(base_src,adr_src,off));\n-        Node* next_dest = phase->transform(new AddPNode(base_dest,adr_dest,off));\n-        v = load(bs, phase, forward_ctl, mm, next_src, atp_src, value_type, copy_type);\n-        store(bs, phase, forward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);\n+      for (int i = 0; i < count; i++) {\n+        copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);\n@@ -412,3 +469,4 @@\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      igvn->_worklist.push(adr_src);\n-      igvn->_worklist.push(adr_dest);\n+      PhaseGVN& gvn = kit.gvn();\n+      assert(gvn.is_IterGVN(), \"\");\n+      gvn.record_for_igvn(adr_src);\n+      gvn.record_for_igvn(adr_dest);\n@@ -416,2 +474,0 @@\n-    return mm;\n-  return phase->C->top();\n@@ -421,14 +477,12 @@\n-Node* ArrayCopyNode::array_copy_backward(PhaseGVN *phase,\n-                                         bool can_reshape,\n-                                         Node*& backward_ctl,\n-                                         Node* mem,\n-                                         const TypePtr* atp_src,\n-                                         const TypePtr* atp_dest,\n-                                         Node* adr_src,\n-                                         Node* base_src,\n-                                         Node* adr_dest,\n-                                         Node* base_dest,\n-                                         BasicType copy_type,\n-                                         const Type* value_type,\n-                                         int count) {\n-  if (!backward_ctl->is_top()) {\n+void ArrayCopyNode::array_copy_backward(GraphKit& kit,\n+                                        bool can_reshape,\n+                                        const TypeAryPtr* atp_src,\n+                                        const TypeAryPtr* atp_dest,\n+                                        Node* adr_src,\n+                                        Node* base_src,\n+                                        Node* adr_dest,\n+                                        Node* base_dest,\n+                                        BasicType copy_type,\n+                                        const Type* value_type,\n+                                        int count) {\n+  if (!kit.stopped()) {\n@@ -436,4 +490,1 @@\n-    MergeMemNode* mm = MergeMemNode::make(mem);\n-\n-    BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-    assert(copy_type != T_OBJECT || !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, false, BarrierSetC2::Optimization), \"only tightly coupled allocations for object arrays\");\n+    PhaseGVN& gvn = kit.gvn();\n@@ -442,6 +493,2 @@\n-      for (int i = count-1; i >= 1; i--) {\n-        Node* off  = phase->MakeConX(type2aelembytes(copy_type) * i);\n-        Node* next_src = phase->transform(new AddPNode(base_src,adr_src,off));\n-        Node* next_dest = phase->transform(new AddPNode(base_dest,adr_dest,off));\n-        Node* v = load(bs, phase, backward_ctl, mm, next_src, atp_src, value_type, copy_type);\n-        store(bs, phase, backward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);\n+      for (int i = count-1; i >= 0; i--) {\n+        copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);\n@@ -449,6 +496,5 @@\n-      Node* v = load(bs, phase, backward_ctl, mm, adr_src, atp_src, value_type, copy_type);\n-      store(bs, phase, backward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);\n-    } else if (can_reshape) {\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      igvn->_worklist.push(adr_src);\n-      igvn->_worklist.push(adr_dest);\n+    } else if(can_reshape) {\n+      PhaseGVN& gvn = kit.gvn();\n+      assert(gvn.is_IterGVN(), \"\");\n+      gvn.record_for_igvn(adr_src);\n+      gvn.record_for_igvn(adr_dest);\n@@ -456,2 +502,0 @@\n-    return phase->transform(mm);\n-  return phase->C->top();\n@@ -483,2 +527,1 @@\n-      CallProjections callprojs;\n-      extract_projections(&callprojs, true, false);\n+      CallProjections* callprojs = extract_projections(true, false);\n@@ -486,2 +529,2 @@\n-      if (callprojs.fallthrough_ioproj != NULL) {\n-        igvn->replace_node(callprojs.fallthrough_ioproj, in(TypeFunc::I_O));\n+      if (callprojs->fallthrough_ioproj != NULL) {\n+        igvn->replace_node(callprojs->fallthrough_ioproj, in(TypeFunc::I_O));\n@@ -489,2 +532,2 @@\n-      if (callprojs.fallthrough_memproj != NULL) {\n-        igvn->replace_node(callprojs.fallthrough_memproj, mem);\n+      if (callprojs->fallthrough_memproj != NULL) {\n+        igvn->replace_node(callprojs->fallthrough_memproj, mem);\n@@ -492,2 +535,2 @@\n-      if (callprojs.fallthrough_catchproj != NULL) {\n-        igvn->replace_node(callprojs.fallthrough_catchproj, ctl);\n+      if (callprojs->fallthrough_catchproj != NULL) {\n+        igvn->replace_node(callprojs->fallthrough_catchproj, ctl);\n@@ -508,0 +551,9 @@\n+#ifdef ASSERT\n+      Node* src = in(ArrayCopyNode::Src);\n+      const Type* src_type = phase->type(src);\n+      const TypeAryPtr* ary_src = src_type->isa_aryptr();\n+      BasicType elem = ary_src != NULL ? ary_src->elem()->array_element_basic_type() : T_CONFLICT;\n+      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+      assert(!is_clonebasic() || bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, is_clone_inst(), BarrierSetC2::Optimization) ||\n+             (ary_src != NULL && elem == T_PRIMITIVE_OBJECT && ary_src->is_not_flat()), \"added control for clone?\");\n+#endif\n@@ -518,1 +570,5 @@\n-  if (remove_dead_region(phase, can_reshape))  return this;\n+  \/\/ Perform any generic optimizations first\n+  Node* result = SafePointNode::Ideal(phase, can_reshape);\n+  if (result != NULL) {\n+    return result;\n+  }\n@@ -560,0 +616,11 @@\n+  Node* src = in(ArrayCopyNode::Src);\n+  Node* dest = in(ArrayCopyNode::Dest);\n+  const Type* src_type = phase->type(src);\n+  const Type* dest_type = phase->type(dest);\n+\n+  if (src_type->isa_aryptr() && dest_type->isa_instptr()) {\n+    \/\/ clone used for load of unknown inline type can't be optimized at\n+    \/\/ this point\n+    return NULL;\n+  }\n+\n@@ -581,5 +648,21 @@\n-  Node* src = in(ArrayCopyNode::Src);\n-  Node* dest = in(ArrayCopyNode::Dest);\n-  const TypePtr* atp_src = get_address_type(phase, _src_type, src);\n-  const TypePtr* atp_dest = get_address_type(phase, _dest_type, dest);\n-  Node* in_mem = in(TypeFunc::Memory);\n+  JVMState* new_jvms = NULL;\n+  SafePointNode* new_map = NULL;\n+  if (!is_clonebasic()) {\n+    new_jvms = jvms()->clone_shallow(phase->C);\n+    new_map = new SafePointNode(req(), new_jvms);\n+    for (uint i = TypeFunc::FramePtr; i < req(); i++) {\n+      new_map->init_req(i, in(i));\n+    }\n+    new_jvms->set_map(new_map);\n+  } else {\n+    new_jvms = new (phase->C) JVMState(0);\n+    new_map = new SafePointNode(TypeFunc::Parms, new_jvms);\n+    new_jvms->set_map(new_map);\n+  }\n+  new_map->set_control(in(TypeFunc::Control));\n+  new_map->set_memory(MergeMemNode::make(in(TypeFunc::Memory)));\n+  new_map->set_i_o(in(TypeFunc::I_O));\n+  phase->record_for_igvn(new_map);\n+\n+  const TypeAryPtr* atp_src = get_address_type(phase, _src_type, src);\n+  const TypeAryPtr* atp_dest = get_address_type(phase, _dest_type, dest);\n@@ -592,0 +675,4 @@\n+  GraphKit kit(new_jvms, phase);\n+\n+  SafePointNode* backward_map = NULL;\n+  SafePointNode* forward_map = NULL;\n@@ -593,36 +680,36 @@\n-  Node* forward_ctl = phase->C->top();\n-  array_copy_test_overlap(phase, can_reshape, disjoint_bases, count, forward_ctl, backward_ctl);\n-\n-  Node* forward_mem = array_copy_forward(phase, can_reshape, forward_ctl,\n-                                         in_mem,\n-                                         atp_src, atp_dest,\n-                                         adr_src, base_src, adr_dest, base_dest,\n-                                         copy_type, value_type, count);\n-\n-  Node* backward_mem = array_copy_backward(phase, can_reshape, backward_ctl,\n-                                           in_mem,\n-                                           atp_src, atp_dest,\n-                                           adr_src, base_src, adr_dest, base_dest,\n-                                           copy_type, value_type, count);\n-\n-  Node* ctl = NULL;\n-  if (!forward_ctl->is_top() && !backward_ctl->is_top()) {\n-    ctl = new RegionNode(3);\n-    ctl->init_req(1, forward_ctl);\n-    ctl->init_req(2, backward_ctl);\n-    ctl = phase->transform(ctl);\n-    MergeMemNode* forward_mm = forward_mem->as_MergeMem();\n-    MergeMemNode* backward_mm = backward_mem->as_MergeMem();\n-    for (MergeMemStream mms(forward_mm, backward_mm); mms.next_non_empty2(); ) {\n-      if (mms.memory() != mms.memory2()) {\n-        Node* phi = new PhiNode(ctl, Type::MEMORY, phase->C->get_adr_type(mms.alias_idx()));\n-        phi->init_req(1, mms.memory());\n-        phi->init_req(2, mms.memory2());\n-        phi = phase->transform(phi);\n-        mms.set_memory(phi);\n-      }\n-    }\n-    mem = forward_mem;\n-  } else if (!forward_ctl->is_top()) {\n-    ctl = forward_ctl;\n-    mem = forward_mem;\n+\n+  array_copy_test_overlap(kit, disjoint_bases, count, backward_ctl);\n+\n+  {\n+    PreserveJVMState pjvms(&kit);\n+\n+    array_copy_forward(kit, can_reshape,\n+                       atp_src, atp_dest,\n+                       adr_src, base_src, adr_dest, base_dest,\n+                       copy_type, value_type, count);\n+\n+    forward_map = kit.stop();\n+  }\n+\n+  kit.set_control(backward_ctl);\n+  array_copy_backward(kit, can_reshape,\n+                      atp_src, atp_dest,\n+                      adr_src, base_src, adr_dest, base_dest,\n+                      copy_type, value_type, count);\n+\n+  backward_map = kit.stop();\n+\n+  if (!forward_map->control()->is_top() && !backward_map->control()->is_top()) {\n+    assert(forward_map->i_o() == backward_map->i_o(), \"need a phi on IO?\");\n+    Node* ctl = new RegionNode(3);\n+    Node* mem = new PhiNode(ctl, Type::MEMORY, TypePtr::BOTTOM);\n+    kit.set_map(forward_map);\n+    ctl->init_req(1, kit.control());\n+    mem->init_req(1, kit.reset_memory());\n+    kit.set_map(backward_map);\n+    ctl->init_req(2, kit.control());\n+    mem->init_req(2, kit.reset_memory());\n+    kit.set_control(phase->transform(ctl));\n+    kit.set_all_memory(phase->transform(mem));\n+  } else if (!forward_map->control()->is_top()) {\n+    kit.set_map(forward_map);\n@@ -630,3 +717,2 @@\n-    assert(!backward_ctl->is_top(), \"no copy?\");\n-    ctl = backward_ctl;\n-    mem = backward_mem;\n+    assert(!backward_map->control()->is_top(), \"no copy?\");\n+    kit.set_map(backward_map);\n@@ -640,2 +726,5 @@\n-  if (!finish_transform(phase, can_reshape, ctl, mem)) {\n-    if (can_reshape) {\n+  mem = kit.map()->memory();\n+  if (!finish_transform(phase, can_reshape, kit.control(), mem)) {\n+    if (!can_reshape) {\n+      phase->record_for_igvn(this);\n+    } else {\n@@ -742,0 +831,3 @@\n+  if (ary_t->klass()->is_flat_array_klass()) {\n+    elemsize = ary_t->klass()->as_flat_array_klass()->element_byte_size();\n+  }\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":229,"deletions":137,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-      if( t->is_ptr()->_offset == 0 ) { \/\/ Not derived?\n+      if (t->is_ptr()->offset() == 0) { \/\/ Not derived?\n@@ -262,1 +262,1 @@\n-          uint cnt = mcall->tf()->domain()->cnt();\n+          uint cnt = mcall->tf()->domain_cc()->cnt();\n@@ -328,1 +328,1 @@\n-        uint cnt = mcall->tf()->domain()->cnt();\n+        uint cnt = mcall->tf()->domain_cc()->cnt();\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  if (callee_method->is_initializer()) {\n+  if (callee_method->is_object_constructor()) {\n@@ -92,1 +92,1 @@\n-  if (caller_method->is_initializer() &&\n+  if (caller_method->is_object_constructor_or_class_initializer() &&\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -768,0 +768,6 @@\n+  product(bool, UseArrayLoadStoreProfile, true,                             \\\n+          \"Take advantage of profiling at array load\/store\")                \\\n+                                                                            \\\n+  product(bool, UseACmpProfile, true,                                       \\\n+          \"Take advantage of profiling at acmp\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -577,0 +577,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:\n+  case vmIntrinsics::_finishPrivateBuffer:\n@@ -586,0 +588,1 @@\n+  case vmIntrinsics::_getValue:\n@@ -595,0 +598,1 @@\n+  case vmIntrinsics::_putValue:\n@@ -679,0 +683,2 @@\n+  case vmIntrinsics::_asPrimaryType:\n+  case vmIntrinsics::_asValueType:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -120,1 +121,1 @@\n-  \/\/ paths to facilitate late inlinig.\n+  \/\/ paths to facilitate late inlining.\n@@ -129,0 +130,1 @@\n+      _call_node(NULL),\n@@ -131,0 +133,8 @@\n+    if (InlineTypeReturnedAsFields && method->is_method_handle_intrinsic()) {\n+      \/\/ If that call has not been optimized by the time optimizations are over,\n+      \/\/ we'll need to add a call to create an inline type instance from the klass\n+      \/\/ returned by the call (see PhaseMacroExpand::expand_mh_intrinsic_return).\n+      \/\/ Separating memory and I\/O projections for exceptions is required to\n+      \/\/ perform that graph transformation.\n+      _separate_io_proj = true;\n+    }\n@@ -145,0 +155,1 @@\n+  PhaseGVN& gvn = kit.gvn();\n@@ -177,1 +188,4 @@\n-  kit.set_arguments_for_java_call(call);\n+  kit.set_arguments_for_java_call(call, is_late_inline());\n+  if (kit.stopped()) {\n+    return kit.transfer_exceptions_into_jvms();\n+  }\n@@ -218,1 +232,0 @@\n-\n@@ -230,1 +243,1 @@\n-  if (kit.gvn().type(receiver)->higher_equal(TypePtr::NULL_PTR)) {\n+  if (!receiver->is_InlineType() && kit.gvn().type(receiver)->higher_equal(TypePtr::NULL_PTR)) {\n@@ -278,0 +291,3 @@\n+  if (kit.stopped()) {\n+    return kit.transfer_exceptions_into_jvms();\n+  }\n@@ -371,0 +387,4 @@\n+  virtual CallGenerator* inline_cg() {\n+    return _inline_cg;\n+  }\n+\n@@ -432,0 +452,8 @@\n+    \/\/ AlwaysIncrementalInline causes for_method_handle_inline() to\n+    \/\/ return a LateInlineCallGenerator. Extract the\n+    \/\/ InlineCallGenerator from it.\n+    if (AlwaysIncrementalInline && cg->is_late_inline() && !cg->is_virtual_late_inline()) {\n+      cg = cg->inline_cg();\n+      assert(cg != NULL, \"inline call generator expected\");\n+    }\n+\n@@ -594,3 +622,3 @@\n-  const TypeTuple *r = call->tf()->domain();\n-  for (int i1 = 0; i1 < method()->arg_size(); i1++) {\n-    if (call->in(TypeFunc::Parms + i1)->is_top() && r->field_at(TypeFunc::Parms + i1) != Type::HALF) {\n+  const TypeTuple* r = call->tf()->domain_cc();\n+  for (uint i1 = TypeFunc::Parms; i1 < r->cnt(); i1++) {\n+    if (call->in(i1)->is_top() && r->field_at(i1) != Type::HALF) {\n@@ -614,10 +642,8 @@\n-  CallProjections callprojs;\n-  call->extract_projections(&callprojs, true);\n-  if ((callprojs.fallthrough_catchproj == call->in(0)) ||\n-      (callprojs.catchall_catchproj    == call->in(0)) ||\n-      (callprojs.fallthrough_memproj   == call->in(TypeFunc::Memory)) ||\n-      (callprojs.catchall_memproj      == call->in(TypeFunc::Memory)) ||\n-      (callprojs.fallthrough_ioproj    == call->in(TypeFunc::I_O)) ||\n-      (callprojs.catchall_ioproj       == call->in(TypeFunc::I_O)) ||\n-      (callprojs.resproj != NULL && call->find_edge(callprojs.resproj) != -1) ||\n-      (callprojs.exobj   != NULL && call->find_edge(callprojs.exobj) != -1)) {\n+  CallProjections* callprojs = call->extract_projections(true);\n+  if ((callprojs->fallthrough_catchproj == call->in(0)) ||\n+      (callprojs->catchall_catchproj    == call->in(0)) ||\n+      (callprojs->fallthrough_memproj   == call->in(TypeFunc::Memory)) ||\n+      (callprojs->catchall_memproj      == call->in(TypeFunc::Memory)) ||\n+      (callprojs->fallthrough_ioproj    == call->in(TypeFunc::I_O)) ||\n+      (callprojs->catchall_ioproj       == call->in(TypeFunc::I_O)) ||\n+      (callprojs->exobj != NULL && call->find_edge(callprojs->exobj) != -1)) {\n@@ -633,3 +659,12 @@\n-  \/\/ The call is marked as pure (no important side effects), but result isn't used.\n-  \/\/ It's safe to remove the call.\n-  bool result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n+\n+  bool result_not_used = true;\n+  for (uint i = 0; i < callprojs->nb_resproj; i++) {\n+    if (callprojs->resproj[i] != NULL) {\n+      if (callprojs->resproj[i]->outcnt() != 0) {\n+        result_not_used = false;\n+      }\n+      if (call->find_edge(callprojs->resproj[i]) != -1) {\n+        return;\n+      }\n+    }\n+  }\n@@ -638,0 +673,2 @@\n+    \/\/ The call is marked as pure (no important side effects), but result isn't used.\n+    \/\/ It's safe to remove the call.\n@@ -650,0 +687,1 @@\n+    PhaseGVN& gvn = *C->initial_gvn();\n@@ -653,1 +691,1 @@\n-      C->initial_gvn()->set_type_bottom(mem);\n+      gvn.set_type_bottom(mem);\n@@ -657,4 +695,2 @@\n-    uint nargs = method()->arg_size();\n-    Node* top = C->top();\n-    for (uint i1 = 0; i1 < nargs; i1++) {\n-      map->set_req(TypeFunc::Parms + i1, top);\n+    for (uint i1 = TypeFunc::Parms; i1 < r->cnt(); i1++) {\n+      map->set_req(i1, C->top());\n@@ -668,0 +704,6 @@\n+    const TypeTuple* domain_sig = call->_tf->domain_sig();\n+    uint nargs = method()->arg_size();\n+    assert(domain_sig->cnt() - TypeFunc::Parms == nargs, \"inconsistent signature\");\n+\n+    uint j = TypeFunc::Parms;\n+    int arg_num = 0;\n@@ -669,1 +711,14 @@\n-      map->set_argument(jvms, i1, call->in(TypeFunc::Parms + i1));\n+      const Type* t = domain_sig->field_at(TypeFunc::Parms + i1);\n+      if (t->is_inlinetypeptr() && method()->is_scalarized_arg(arg_num)) {\n+        \/\/ Inline type arguments are not passed by reference: we get an argument per\n+        \/\/ field of the inline type. Build InlineTypeNodes from the inline type arguments.\n+        GraphKit arg_kit(jvms, &gvn);\n+        Node* vt = InlineTypeNode::make_from_multi(&arg_kit, call, t->inline_klass(), j, \/* in= *\/ true, \/* null_free= *\/ !t->maybe_null());\n+        map->set_control(arg_kit.control());\n+        map->set_argument(jvms, i1, vt);\n+      } else {\n+        map->set_argument(jvms, i1, call->in(j++));\n+      }\n+      if (t != Type::HALF) {\n+        arg_num++;\n+      }\n@@ -685,0 +740,20 @@\n+    \/\/ Check if we are late inlining a method handle call that returns an inline type as fields.\n+    Node* buffer_oop = NULL;\n+    ciMethod* inline_method = inline_cg()->method();\n+    ciType* return_type = inline_method->return_type();\n+    if (!call->tf()->returns_inline_type_as_fields() && is_mh_late_inline() &&\n+        return_type->is_inlinetype() && return_type->as_inline_klass()->can_be_returned_as_fields()) {\n+      \/\/ Allocate a buffer for the inline type returned as fields because the caller expects an oop return.\n+      \/\/ Do this before the method handle call in case the buffer allocation triggers deoptimization and\n+      \/\/ we need to \"re-execute\" the call in the interpreter (to make sure the call is only executed once).\n+      GraphKit arg_kit(jvms, &gvn);\n+      {\n+        PreserveReexecuteState preexecs(&arg_kit);\n+        arg_kit.jvms()->set_should_reexecute(true);\n+        arg_kit.inc_sp(nargs);\n+        Node* klass_node = arg_kit.makecon(TypeKlassPtr::make(return_type->as_inline_klass()));\n+        buffer_oop = arg_kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n+      }\n+      jvms = arg_kit.transfer_exceptions_into_jvms();\n+    }\n+\n@@ -709,2 +784,2 @@\n-      C->set_has_loops(C->has_loops() || inline_cg()->method()->has_loops());\n-      C->env()->notice_inlined_method(inline_cg()->method());\n+      C->set_has_loops(C->has_loops() || inline_method->has_loops());\n+      C->env()->notice_inlined_method(inline_method);\n@@ -714,0 +789,53 @@\n+\n+    \/\/ Handle inline type returns\n+    InlineTypeBaseNode* vt = result->isa_InlineTypeBase();\n+    if (vt != NULL) {\n+      if (call->tf()->returns_inline_type_as_fields()) {\n+        vt->replace_call_results(&kit, call, C, inline_method->signature()->returns_null_free_inline_type());\n+      } else if (vt->is_InlineType()) {\n+        \/\/ Result might still be allocated (for example, if it has been stored to a non-flattened field)\n+        if (!vt->is_allocated(&kit.gvn())) {\n+          assert(buffer_oop != NULL, \"should have allocated a buffer\");\n+          RegionNode* region = new RegionNode(3);\n+\n+          \/\/ Check if result is null\n+          Node* null_ctl = kit.top();\n+          if (!inline_method->signature()->returns_null_free_inline_type()) {\n+            kit.null_check_common(vt->get_is_init(), T_INT, false, &null_ctl);\n+          }\n+          region->init_req(1, null_ctl);\n+          PhiNode* oop = PhiNode::make(region, kit.gvn().zerocon(T_OBJECT), TypeInstPtr::make(TypePtr::BotPTR, vt->type()->inline_klass()));\n+          Node* init_mem = kit.reset_memory();\n+          PhiNode* mem = PhiNode::make(region, init_mem, Type::MEMORY, TypePtr::BOTTOM);\n+\n+          \/\/ Not null, initialize the buffer\n+          kit.set_all_memory(init_mem);\n+          vt->store(&kit, buffer_oop, buffer_oop, vt->type()->inline_klass());\n+          \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+          \/\/ store that would make this buffer accessible by other threads.\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop, &kit.gvn());\n+          assert(alloc != NULL, \"must have an allocation node\");\n+          kit.insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+          region->init_req(2, kit.control());\n+          oop->init_req(2, buffer_oop);\n+          mem->init_req(2, kit.merged_memory());\n+\n+          \/\/ Update oop input to buffer\n+          kit.gvn().hash_delete(vt);\n+          vt->set_oop(kit.gvn().transform(oop));\n+          vt = kit.gvn().transform(vt)->as_InlineTypeBase();\n+\n+          kit.set_control(kit.gvn().transform(region));\n+          kit.set_all_memory(kit.gvn().transform(mem));\n+          kit.record_for_igvn(region);\n+          kit.record_for_igvn(oop);\n+          kit.record_for_igvn(mem);\n+        }\n+        result = vt->as_ptr(&kit.gvn(), inline_method->signature()->returns_null_free_inline_type());\n+      }\n+      DEBUG_ONLY(buffer_oop = NULL);\n+    } else {\n+      assert(result->is_top() || !call->tf()->returns_inline_type_as_fields(), \"Unexpected return value\");\n+    }\n+    assert(buffer_oop == NULL, \"unused buffer allocation\");\n+\n@@ -936,0 +1064,22 @@\n+  \/\/ Allocate inline types if they are merged with objects (similar to Parse::merge_common())\n+  uint tos = kit.jvms()->stkoff() + kit.sp();\n+  uint limit = slow_map->req();\n+  for (uint i = TypeFunc::Parms; i < limit; i++) {\n+    Node* m = kit.map()->in(i);\n+    Node* n = slow_map->in(i);\n+    const Type* t = gvn.type(m)->meet_speculative(gvn.type(n));\n+    if (m->is_InlineType() && !t->isa_inlinetype()) {\n+      \/\/ Allocate inline type in fast path\n+      m = m->as_InlineType()->buffer(&kit);\n+      kit.map()->set_req(i, m);\n+    }\n+    if (n->is_InlineType() && !t->isa_inlinetype()) {\n+      \/\/ Allocate inline type in slow path\n+      PreserveJVMState pjvms(&kit);\n+      kit.set_map(slow_map);\n+      n = n->as_InlineType()->buffer(&kit);\n+      kit.map()->set_req(i, n);\n+      slow_map = kit.stop();\n+    }\n+  }\n+\n@@ -959,2 +1109,0 @@\n-  uint tos = kit.jvms()->stkoff() + kit.sp();\n-  uint limit = slow_map->req();\n@@ -996,2 +1144,2 @@\n-  if (IncrementalInlineMH && call_site_count > 0 &&\n-      (input_not_const || !C->inlining_incrementally() || C->over_inlining_cutoff())) {\n+  if (IncrementalInlineMH && (AlwaysIncrementalInline ||\n+                            (call_site_count > 0 && (input_not_const || !C->inlining_incrementally() || C->over_inlining_cutoff())))) {\n@@ -1005,0 +1153,19 @@\n+static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit, bool null_free) {\n+  PhaseGVN& gvn = kit.gvn();\n+  Node* arg = kit.argument(arg_nb);\n+  const Type* arg_type = arg->bottom_type();\n+  const Type* sig_type = TypeOopPtr::make_from_klass(t->as_klass());\n+  if (t->as_klass()->is_inlinetype() && null_free) {\n+    sig_type = sig_type->filter_speculative(TypePtr::NOTNULL);\n+  }\n+  if (arg_type->isa_oopptr() && !arg_type->higher_equal(sig_type)) {\n+    const Type* narrowed_arg_type = arg_type->filter_speculative(sig_type); \/\/ keep speculative part\n+    arg = gvn.transform(new CheckCastPPNode(kit.control(), arg, narrowed_arg_type));\n+    kit.set_argument(arg_nb, arg);\n+  }\n+  if (sig_type->is_inlinetypeptr() && !arg->is_InlineType()) {\n+    arg = InlineTypeNode::make_from_oop(&kit, arg, t->as_inline_klass(), !kit.gvn().type(arg)->maybe_null());\n+    kit.set_argument(arg_nb, arg);\n+  }\n+}\n+\n@@ -1056,0 +1223,1 @@\n+      int nargs = callee->arg_size();\n@@ -1057,1 +1225,1 @@\n-      Node* member_name = kit.argument(callee->arg_size() - 1);\n+      Node* member_name = kit.argument(nargs - 1);\n@@ -1077,8 +1245,1 @@\n-          Node* arg = kit.argument(0);\n-          const TypeOopPtr* arg_type = arg->bottom_type()->isa_oopptr();\n-          const Type*       sig_type = TypeOopPtr::make_from_klass(signature->accessing_klass());\n-          if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n-            const Type* recv_type = arg_type->filter_speculative(sig_type); \/\/ keep speculative part\n-            Node* cast_obj = gvn.transform(new CheckCastPPNode(kit.control(), arg, recv_type));\n-            kit.set_argument(0, cast_obj);\n-          }\n+          cast_argument(nargs, 0, signature->accessing_klass(), kit, false);\n@@ -1090,8 +1251,2 @@\n-            Node* arg = kit.argument(receiver_skip + j);\n-            const TypeOopPtr* arg_type = arg->bottom_type()->isa_oopptr();\n-            const Type*       sig_type = TypeOopPtr::make_from_klass(t->as_klass());\n-            if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n-              const Type* narrowed_arg_type = arg_type->filter_speculative(sig_type); \/\/ keep speculative part\n-              Node* cast_obj = gvn.transform(new CheckCastPPNode(kit.control(), arg, narrowed_arg_type));\n-              kit.set_argument(receiver_skip + j, cast_obj);\n-            }\n+            bool null_free = signature->is_null_free_at(i);\n+            cast_argument(nargs, receiver_skip + j, t, kit, null_free);\n@@ -1128,1 +1283,2 @@\n-                                              speculative_receiver_type);\n+                                              speculative_receiver_type,\n+                                              true);\n@@ -1203,1 +1359,1 @@\n-    Node* receiver = kit.null_check_receiver_before_call(method());\n+    kit.null_check_receiver_before_call(method());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":207,"deletions":51,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n@@ -89,0 +88,2 @@\n+  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -46,0 +48,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -81,1 +84,1 @@\n-Node *StartNode::match( const ProjNode *proj, const Matcher *match ) {\n+Node *StartNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {\n@@ -105,11 +108,0 @@\n-\/\/------------------------------StartOSRNode----------------------------------\n-\/\/ The method start node for an on stack replacement adapter\n-\n-\/\/------------------------------osr_domain-----------------------------\n-const TypeTuple *StartOSRNode::osr_domain() {\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  \/\/ address of osr buffer\n-\n-  return TypeTuple::make(TypeFunc::Parms+1, fields);\n-}\n-\n@@ -508,0 +500,8 @@\n+      } else if (cik->is_flat_array_klass()) {\n+        ciKlass* cie = cik->as_flat_array_klass()->base_element_klass();\n+        cie->print_name_on(st);\n+        st->print(\"[%d]\", spobj->n_fields());\n+        int ndim = cik->as_array_klass()->dimension() - 1;\n+        while (ndim-- > 0) {\n+          st->print(\"[]\");\n+        }\n@@ -513,0 +513,7 @@\n+        if (iklass != NULL && iklass->is_inlinetype()) {\n+          Node* init_node = mcall->in(first_ind++);\n+          if (!init_node->is_top()) {\n+            st->print(\" [is_init\");\n+            format_helper(regalloc, st, init_node, \":\", -1, NULL);\n+          }\n+        }\n@@ -726,1 +733,1 @@\n-const Type *CallNode::bottom_type() const { return tf()->range(); }\n+const Type *CallNode::bottom_type() const { return tf()->range_cc(); }\n@@ -728,2 +735,4 @@\n-  if (phase->type(in(0)) == Type::TOP)  return Type::TOP;\n-  return tf()->range();\n+  if (!in(0) || phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return tf()->range_cc();\n@@ -734,0 +743,7 @@\n+  if (_entry_point == StubRoutines::store_inline_type_fields_to_buf()) {\n+    \/\/ The call to that stub is a special case: its inputs are\n+    \/\/ multiple values returned from a call and so it should follow\n+    \/\/ the return convention.\n+    SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);\n+    return;\n+  }\n@@ -742,27 +758,26 @@\n-Node *CallNode::match( const ProjNode *proj, const Matcher *match ) {\n-  switch (proj->_con) {\n-  case TypeFunc::Control:\n-  case TypeFunc::I_O:\n-  case TypeFunc::Memory:\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n-\n-  case TypeFunc::Parms+1:       \/\/ For LONG & DOUBLE returns\n-    assert(tf()->range()->field_at(TypeFunc::Parms+1) == Type::HALF, \"\");\n-    \/\/ 2nd half of doubles and longs\n-    return new MachProjNode(this,proj->_con, RegMask::Empty, (uint)OptoReg::Bad);\n-\n-  case TypeFunc::Parms: {       \/\/ Normal returns\n-    uint ideal_reg = tf()->range()->field_at(TypeFunc::Parms)->ideal_reg();\n-    OptoRegPair regs = Opcode() == Op_CallLeafVector\n-      ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n-      : is_CallRuntime()\n-        ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n-        : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n-    RegMask rm = RegMask(regs.first());\n-\n-    if (Opcode() == Op_CallLeafVector) {\n-      \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n-      if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n-        if(OptoReg::is_valid(regs.second())) {\n-          for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n-            rm.Insert(r);\n+Node *CallNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {\n+  uint con = proj->_con;\n+  const TypeTuple* range_cc = tf()->range_cc();\n+  if (con >= TypeFunc::Parms) {\n+    if (tf()->returns_inline_type_as_fields()) {\n+      \/\/ The call returns multiple values (inline type fields): we\n+      \/\/ create one projection per returned value.\n+      assert(con <= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, \"only for multi value return\");\n+      uint ideal_reg = range_cc->field_at(con)->ideal_reg();\n+      return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);\n+    } else {\n+      if (con == TypeFunc::Parms) {\n+        uint ideal_reg = range_cc->field_at(TypeFunc::Parms)->ideal_reg();\n+        OptoRegPair regs = Opcode() == Op_CallLeafVector\n+          ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n+          : match->c_return_value(ideal_reg);\n+        RegMask rm = RegMask(regs.first());\n+\n+        if (Opcode() == Op_CallLeafVector) {\n+          \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n+          if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+            if(OptoReg::is_valid(regs.second())) {\n+              for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n+                rm.Insert(r);\n+              }\n+            }\n@@ -771,0 +786,9 @@\n+\n+        if (OptoReg::is_valid(regs.second())) {\n+          rm.Insert(regs.second());\n+        }\n+        return new MachProjNode(this,con,rm,ideal_reg);\n+      } else {\n+        assert(con == TypeFunc::Parms+1, \"only one return value\");\n+        assert(range_cc->field_at(TypeFunc::Parms+1) == Type::HALF, \"\");\n+        return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);\n@@ -773,4 +797,0 @@\n-\n-    if( OptoReg::is_valid(regs.second()) )\n-      rm.Insert( regs.second() );\n-    return new MachProjNode(this,proj->_con,rm,ideal_reg);\n@@ -779,0 +799,6 @@\n+  switch (con) {\n+  case TypeFunc::Control:\n+  case TypeFunc::I_O:\n+  case TypeFunc::Memory:\n+    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+\n@@ -799,1 +825,1 @@\n-    const TypeTuple* args = _tf->domain();\n+    const TypeTuple* args = _tf->domain_sig();\n@@ -848,1 +874,1 @@\n-      const TypeTuple* d = tf()->domain();\n+      const TypeTuple* d = tf()->domain_cc();\n@@ -863,2 +889,2 @@\n-bool CallNode::has_non_debug_use(Node *n) {\n-  const TypeTuple * d = tf()->domain();\n+bool CallNode::has_non_debug_use(Node* n) {\n+  const TypeTuple* d = tf()->domain_cc();\n@@ -866,2 +892,1 @@\n-    Node *arg = in(i);\n-    if (arg == n) {\n+    if (in(i) == n) {\n@@ -874,0 +899,11 @@\n+bool CallNode::has_debug_use(Node* n) {\n+  if (jvms() != NULL) {\n+    for (uint i = jvms()->debug_start(); i < jvms()->debug_end(); i++) {\n+      if (in(i) == n) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -905,10 +941,15 @@\n-void CallNode::extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts) {\n-  projs->fallthrough_proj      = NULL;\n-  projs->fallthrough_catchproj = NULL;\n-  projs->fallthrough_ioproj    = NULL;\n-  projs->catchall_ioproj       = NULL;\n-  projs->catchall_catchproj    = NULL;\n-  projs->fallthrough_memproj   = NULL;\n-  projs->catchall_memproj      = NULL;\n-  projs->resproj               = NULL;\n-  projs->exobj                 = NULL;\n+CallProjections* CallNode::extract_projections(bool separate_io_proj, bool do_asserts) {\n+  uint max_res = TypeFunc::Parms-1;\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    ProjNode *pn = fast_out(i)->as_Proj();\n+    max_res = MAX2(max_res, pn->_con);\n+  }\n+\n+  assert(max_res < _tf->range_cc()->cnt(), \"result out of bounds\");\n+\n+  uint projs_size = sizeof(CallProjections);\n+  if (max_res > TypeFunc::Parms) {\n+    projs_size += (max_res-TypeFunc::Parms)*sizeof(Node*);\n+  }\n+  char* projs_storage = resource_allocate_bytes(projs_size);\n+  CallProjections* projs = new(projs_storage)CallProjections(max_res - TypeFunc::Parms + 1);\n@@ -960,1 +1001,1 @@\n-      projs->resproj = pn;\n+      projs->resproj[0] = pn;\n@@ -963,1 +1004,3 @@\n-      assert(false, \"unexpected projection from allocation node.\");\n+      assert(pn->_con <= max_res, \"unexpected projection from allocation node.\");\n+      projs->resproj[pn->_con-TypeFunc::Parms] = pn;\n+      break;\n@@ -970,1 +1013,1 @@\n-  assert(projs->fallthrough_proj      != NULL, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_proj      != NULL, \"must be found\");\n@@ -980,0 +1023,1 @@\n+  return projs;\n@@ -1011,2 +1055,2 @@\n-  uint old_dbg_start = sfpt->is_Call() ? sfpt->as_Call()->tf()->domain()->cnt() : (uint)TypeFunc::Parms+1;\n-  uint new_dbg_start = tf()->domain()->cnt();\n+  uint old_dbg_start = sfpt->is_Call() ? sfpt->as_Call()->tf()->domain_sig()->cnt() : (uint)TypeFunc::Parms+1;\n+  uint new_dbg_start = tf()->domain_sig()->cnt();\n@@ -1053,0 +1097,4 @@\n+  Bytecodes::Code bc = jvms()->method()->java_code_at_bci(jvms()->bci());\n+  if (EnableValhalla && (bc == Bytecodes::_if_acmpeq || bc == Bytecodes::_if_acmpne)) {\n+    return true;\n+  }\n@@ -1086,0 +1134,10 @@\n+  if (can_reshape && uncommon_trap_request() != 0) {\n+    if (remove_useless_allocation(phase, in(0), in(TypeFunc::Memory), in(TypeFunc::Parms))) {\n+      if (!in(0)->is_Region()) {\n+        PhaseIterGVN* igvn = phase->is_IterGVN();\n+        igvn->replace_input_of(this, 0, phase->C->top());\n+      }\n+      return this;\n+    }\n+  }\n+\n@@ -1135,0 +1193,124 @@\n+bool CallStaticJavaNode::remove_useless_allocation(PhaseGVN *phase, Node* ctl, Node* mem, Node* unc_arg) {\n+  \/\/ Split if can cause the flattened array branch of an array load to\n+  \/\/ end in an uncommon trap. In that case, the allocation of the\n+  \/\/ loaded value and its initialization is useless. Eliminate it. use\n+  \/\/ the jvm state of the allocation to create a new uncommon trap\n+  \/\/ call at the load.\n+  if (ctl == NULL || ctl->is_top() || mem == NULL || mem->is_top() || !mem->is_MergeMem()) {\n+    return false;\n+  }\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (ctl->is_Region()) {\n+    bool res = false;\n+    for (uint i = 1; i < ctl->req(); i++) {\n+      MergeMemNode* mm = mem->clone()->as_MergeMem();\n+      for (MergeMemStream mms(mm); mms.next_non_empty(); ) {\n+        Node* m = mms.memory();\n+        if (m->is_Phi() && m->in(0) == ctl) {\n+          mms.set_memory(m->in(i));\n+        }\n+      }\n+      if (remove_useless_allocation(phase, ctl->in(i), mm, unc_arg)) {\n+        res = true;\n+        if (!ctl->in(i)->is_Region()) {\n+          igvn->replace_input_of(ctl, i, phase->C->top());\n+        }\n+      }\n+      igvn->remove_dead_node(mm);\n+    }\n+    return res;\n+  }\n+  \/\/ verify the control flow is ok\n+  Node* call = ctl;\n+  MemBarNode* membar = NULL;\n+  for (;;) {\n+    if (call == NULL || call->is_top()) {\n+      return false;\n+    }\n+    if (call->is_Proj() || call->is_Catch() || call->is_MemBar()) {\n+      call = call->in(0);\n+    } else if (call->Opcode() == Op_CallStaticJava &&\n+               call->as_Call()->entry_point() == OptoRuntime::load_unknown_inline_Java()) {\n+      assert(call->in(0)->is_Proj() && call->in(0)->in(0)->is_MemBar(), \"missing membar\");\n+      membar = call->in(0)->in(0)->as_MemBar();\n+      break;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  JVMState* jvms = call->jvms();\n+  if (phase->C->too_many_traps(jvms->method(), jvms->bci(), Deoptimization::trap_request_reason(uncommon_trap_request()))) {\n+    return false;\n+  }\n+\n+  Node* alloc_mem = call->in(TypeFunc::Memory);\n+  if (alloc_mem == NULL || alloc_mem->is_top()) {\n+    return false;\n+  }\n+  if (!alloc_mem->is_MergeMem()) {\n+    alloc_mem = MergeMemNode::make(alloc_mem);\n+    igvn->register_new_node_with_optimizer(alloc_mem);\n+  }\n+\n+  \/\/ and that there's no unexpected side effect\n+  for (MergeMemStream mms2(mem->as_MergeMem(), alloc_mem->as_MergeMem()); mms2.next_non_empty2(); ) {\n+    Node* m1 = mms2.is_empty() ? mms2.base_memory() : mms2.memory();\n+    Node* m2 = mms2.memory2();\n+\n+    for (uint i = 0; i < 100; i++) {\n+      if (m1 == m2) {\n+        break;\n+      } else if (m1->is_Proj()) {\n+        m1 = m1->in(0);\n+      } else if (m1->is_MemBar()) {\n+        m1 = m1->in(TypeFunc::Memory);\n+      } else if (m1->Opcode() == Op_CallStaticJava &&\n+                 m1->as_Call()->entry_point() == OptoRuntime::load_unknown_inline_Java()) {\n+        if (m1 != call) {\n+          return false;\n+        }\n+        break;\n+      } else if (m1->is_MergeMem()) {\n+        MergeMemNode* mm = m1->as_MergeMem();\n+        int idx = mms2.alias_idx();\n+        if (idx == Compile::AliasIdxBot) {\n+          m1 = mm->base_memory();\n+        } else {\n+          m1 = mm->memory_at(idx);\n+        }\n+      } else {\n+        return false;\n+      }\n+    }\n+  }\n+  if (alloc_mem->outcnt() == 0) {\n+    igvn->remove_dead_node(alloc_mem);\n+  }\n+\n+  \/\/ Remove membar preceding the call\n+  membar->remove(igvn);\n+\n+  address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\", NULL);\n+  unc->init_req(TypeFunc::Control, call->in(0));\n+  unc->init_req(TypeFunc::I_O, call->in(TypeFunc::I_O));\n+  unc->init_req(TypeFunc::Memory, call->in(TypeFunc::Memory));\n+  unc->init_req(TypeFunc::FramePtr,  call->in(TypeFunc::FramePtr));\n+  unc->init_req(TypeFunc::ReturnAdr, call->in(TypeFunc::ReturnAdr));\n+  unc->init_req(TypeFunc::Parms+0, unc_arg);\n+  unc->set_cnt(PROB_UNLIKELY_MAG(4));\n+  unc->copy_call_debug_info(igvn, call->as_CallStaticJava());\n+\n+  igvn->replace_input_of(call, 0, phase->C->top());\n+\n+  igvn->register_new_node_with_optimizer(unc);\n+\n+  Node* ctrl = phase->transform(new ProjNode(unc, TypeFunc::Control));\n+  Node* halt = phase->transform(new HaltNode(ctrl, call->in(TypeFunc::FramePtr), \"uncommon trap returned which should never happen\"));\n+  phase->C->root()->add_req(halt);\n+\n+  return true;\n+}\n+\n+\n@@ -1239,0 +1421,7 @@\n+  if (_entry_point == NULL) {\n+    \/\/ The call to that stub is a special case: its inputs are\n+    \/\/ multiple values returned from a call and so it should follow\n+    \/\/ the return convention.\n+    SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);\n+    return;\n+  }\n@@ -1244,1 +1433,1 @@\n-  assert(tf()->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+  assert(tf()->range_sig()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n@@ -1246,1 +1435,1 @@\n-  const TypeTuple* d = tf()->domain();\n+  const TypeTuple* d = tf()->domain_sig();\n@@ -1270,0 +1459,6 @@\n+uint CallLeafNoFPNode::match_edge(uint idx) const {\n+  \/\/ Null entry point is a special case for which the target is in a\n+  \/\/ register. Need to match that edge.\n+  return entry_point() == NULL && idx == TypeFunc::Parms;\n+}\n+\n@@ -1320,1 +1515,14 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  if (remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  \/\/ Scalarize inline types in safepoint debug info.\n+  \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info.\n+  if (phase->C->scalarize_in_safepoints() && can_reshape && jvms() != NULL) {\n+    for (uint i = jvms()->debug_start(); i < jvms()->debug_end(); i++) {\n+      Node* n = in(i)->uncast();\n+      if (n->is_InlineTypeBase()) {\n+        n->as_InlineTypeBase()->make_scalar_in_safepoints(phase->is_IterGVN());\n+      }\n+    }\n+  }\n+  return NULL;\n@@ -1497,1 +1705,1 @@\n-  if (!alloc->is_Allocate()\n+  if (alloc != NULL && !alloc->is_Allocate()\n@@ -1555,1 +1763,3 @@\n-                           Node *size, Node *klass_node, Node *initial_test)\n+                           Node *size, Node *klass_node,\n+                           Node* initial_test,\n+                           InlineTypeBaseNode* inline_type_node)\n@@ -1563,0 +1773,1 @@\n+  _larval = false;\n@@ -1574,0 +1785,3 @@\n+  init_req( InlineTypeNode     , inline_type_node);\n+  \/\/ DefaultValue defaults to NULL\n+  \/\/ RawDefaultValue defaults to NULL\n@@ -1581,3 +1795,2 @@\n-         initializer->is_initializer() &&\n-         !initializer->is_static(),\n-             \"unexpected initializer method\");\n+         initializer->is_object_constructor_or_class_initializer(),\n+         \"unexpected initializer method\");\n@@ -1594,1 +1807,2 @@\n-Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {\n+\n+Node* AllocateNode::make_ideal_mark(PhaseGVN* phase, Node* control, Node* mem) {\n@@ -1596,3 +1810,10 @@\n-  \/\/ For now only enable fast locking for non-array types\n-  mark_node = phase->MakeConX(markWord::prototype().value());\n-  return mark_node;\n+  if (EnableValhalla) {\n+    Node* klass_node = in(AllocateNode::KlassNode);\n+    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n+    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  } else {\n+    mark_node = phase->MakeConX(markWord::prototype().value());\n+  }\n+  mark_node = phase->transform(mark_node);\n+  \/\/ Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal\n+  return new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_bit_in_place : 0));\n@@ -1987,1 +2208,3 @@\n-  if (can_reshape && EliminateLocks && !is_non_esc_obj()) {\n+  const Type* obj_type = phase->type(obj_node());\n+  if (can_reshape && EliminateLocks && !is_non_esc_obj() &&\n+      !obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n@@ -2183,1 +2406,3 @@\n-  if (can_reshape && EliminateLocks && !is_non_esc_obj()) {\n+  const Type* obj_type = phase->type(obj_node());\n+  if (can_reshape && EliminateLocks && !is_non_esc_obj() &&\n+      !obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n@@ -2263,1 +2488,2 @@\n-    dest_t = dest_t->add_offset(Type::OffsetBot)->is_oopptr();\n+    dest_t = dest_t->is_aryptr()->with_field_offset(Type::OffsetBot)->add_offset(Type::OffsetBot)->is_oopptr();\n+    t_oop = t_oop->is_aryptr()->with_field_offset(Type::OffsetBot);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":308,"deletions":82,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);\n@@ -93,1 +93,0 @@\n-  static  const TypeTuple *osr_domain();\n@@ -564,1 +563,1 @@\n-class CallProjections : public StackObj {\n+class CallProjections {\n@@ -573,1 +572,19 @@\n-  Node* resproj;\n+  uint nb_resproj;\n+  Node* resproj[1]; \/\/ at least one projection\n+\n+  CallProjections(uint nbres) {\n+    fallthrough_proj      = NULL;\n+    fallthrough_catchproj = NULL;\n+    fallthrough_memproj   = NULL;\n+    fallthrough_ioproj    = NULL;\n+    catchall_catchproj    = NULL;\n+    catchall_memproj      = NULL;\n+    catchall_ioproj       = NULL;\n+    exobj                 = NULL;\n+    nb_resproj            = nbres;\n+    resproj[0]            = NULL;\n+    for (uint i = 1; i < nb_resproj; i++) {\n+      resproj[i]          = NULL;\n+    }\n+  }\n+\n@@ -596,1 +613,1 @@\n-    : SafePointNode(tf->domain()->cnt(), jvms, adr_type),\n+    : SafePointNode(tf->domain_cc()->cnt(), jvms, adr_type),\n@@ -623,1 +640,1 @@\n-  virtual Node*       match(const ProjNode* proj, const Matcher* m);\n+  virtual Node*       match(const ProjNode* proj, const Matcher* m, const RegMask* mask);\n@@ -637,0 +654,1 @@\n+  bool                has_debug_use(Node* n);\n@@ -643,2 +661,3 @@\n-    const TypeTuple* r = tf()->range();\n-    return (r->cnt() > TypeFunc::Parms &&\n+    const TypeTuple* r = tf()->range_sig();\n+    return (!tf()->returns_inline_type_as_fields() &&\n+            r->cnt() > TypeFunc::Parms &&\n@@ -651,1 +670,1 @@\n-  void extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts = true);\n+  CallProjections* extract_projections(bool separate_io_proj, bool do_asserts = true);\n@@ -721,0 +740,3 @@\n+\n+  bool remove_useless_allocation(PhaseGVN *phase, Node* ctl, Node* mem, Node* unc_arg);\n+\n@@ -729,0 +751,11 @@\n+    const TypeTuple *r = tf->range_sig();\n+    if (InlineTypeReturnedAsFields &&\n+        method != NULL &&\n+        method->is_method_handle_intrinsic() &&\n+        r->cnt() > TypeFunc::Parms &&\n+        r->field_at(TypeFunc::Parms)->isa_oopptr() &&\n+        r->field_at(TypeFunc::Parms)->is_oopptr()->can_be_inline_type()) {\n+      \/\/ Make sure this call is processed by PhaseMacroExpand::expand_mh_intrinsic_return\n+      init_flags(Flag_is_macro);\n+      C->add_macro_node(this);\n+    }\n@@ -838,0 +871,1 @@\n+  virtual uint match_edge(uint idx) const;\n@@ -879,0 +913,3 @@\n+    InlineTypeNode,                   \/\/ InlineTypeNode if this is an inline type allocation\n+    DefaultValue,                     \/\/ default value in case of non-flattened inline type array\n+    RawDefaultValue,                  \/\/ same as above but as raw machine word\n@@ -889,0 +926,3 @@\n+    fields[InlineTypeNode] = Type::BOTTOM;\n+    fields[DefaultValue] = TypeInstPtr::NOTNULL;\n+    fields[RawDefaultValue] = TypeX_X;\n@@ -907,0 +947,1 @@\n+  bool _larval;\n@@ -910,1 +951,2 @@\n-               Node *size, Node *klass_node, Node *initial_test);\n+               Node *size, Node *klass_node, Node *initial_test,\n+               InlineTypeBaseNode* inline_type_node = NULL);\n@@ -975,1 +1017,1 @@\n-  Node* make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem);\n+  Node* make_ideal_mark(PhaseGVN* phase, Node* control, Node* mem);\n@@ -984,4 +1026,4 @@\n-  AllocateArrayNode(Compile* C, const TypeFunc* atype, Node* ctrl, Node* mem, Node* abio, Node* size, Node* klass_node,\n-                    Node* initial_test, Node* count_val, Node* valid_length_test)\n-    : AllocateNode(C, atype, ctrl, mem, abio, size, klass_node,\n-                   initial_test)\n+  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio, Node* size, Node* klass_node,\n+                    Node* initial_test, Node* count_val, Node* valid_length_test,\n+                    Node* default_value, Node* raw_default_value)\n+    : AllocateNode(C, atype, ctrl, mem, abio, size, klass_node, initial_test)\n@@ -992,0 +1034,2 @@\n+    init_req(AllocateNode::DefaultValue,  default_value);\n+    init_req(AllocateNode::RawDefaultValue, raw_default_value);\n@@ -1112,1 +1156,1 @@\n-    return TypeFunc::make(domain,range);\n+    return TypeFunc::make(domain, range);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":60,"deletions":16,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"opto\/graphKit.hpp\"\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -82,1 +85,15 @@\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : NULL;\n+  if (in(0) && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  \/\/ Push cast through InlineTypePtrNode\n+  InlineTypePtrNode* vt = in(1)->isa_InlineTypePtr();\n+  if (vt != NULL && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+    Node* cast = clone();\n+    cast->set_req(1, vt->get_oop());\n+    vt = vt->clone()->as_InlineTypePtr();\n+    vt->set_oop(phase->transform(cast));\n+    return vt;\n+  }\n+\n+  return NULL;\n@@ -378,0 +395,3 @@\n+  if (in(1)->is_InlineTypeBase() && _type->isa_instptr() && phase->type(in(1))->inline_klass()->is_subtype_of(_type->is_instptr()->instance_klass())) {\n+    return in(1);\n+  }\n@@ -409,2 +429,11 @@\n-  if( in_type != NULL && my_type != NULL ) {\n-    TypePtr::PTR   in_ptr    = in_type->ptr();\n+  if (in_type != NULL && my_type != NULL) {\n+    if (!StressReflectiveCode && my_type->isa_aryptr() && in_type->isa_aryptr()) {\n+      \/\/ Propagate array properties (not flat\/null-free)\n+      \/\/ Don't do this when StressReflectiveCode is enabled because it might lead to\n+      \/\/ a dying data path while the corresponding flat\/null-free check is not folded.\n+      my_type = my_type->is_aryptr()->update_properties(in_type->is_aryptr());\n+      if (my_type == NULL) {\n+        return Type::TOP; \/\/ Inconsistent properties\n+      }\n+    }\n+    TypePtr::PTR in_ptr = in_type->ptr();\n@@ -565,0 +594,16 @@\n+\n+  if (t->is_zero_type() || !t->maybe_null()) {\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* u = fast_out(i);\n+      if (u->Opcode() == Op_OrL) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* cmp = u->fast_out(j);\n+          if (cmp->Opcode() == Op_CmpL) {\n+            \/\/ Give CmpL a chance to get optimized\n+            phase->record_for_igvn(cmp);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -219,2 +219,0 @@\n-\n-\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -396,1 +397,1 @@\n-bool RegionNode::try_clean_mem_phi(PhaseGVN *phase) {\n+Node* PhiNode::try_clean_mem_phi(PhaseGVN *phase) {\n@@ -416,2 +417,1 @@\n-  PhiNode* phi = has_unique_phi();\n-  if (phi && phi->type() == Type::MEMORY && req() == 3 && phi->is_diamond_phi(true)) {\n+  if (type() == Type::MEMORY && is_diamond_phi(true)) {\n@@ -419,1 +419,2 @@\n-    assert(phi->req() == 3, \"same as region\");\n+    assert(req() == 3, \"same as region\");\n+    Node* r = in(0);\n@@ -421,2 +422,2 @@\n-      Node *mem = phi->in(i);\n-      if (mem && mem->is_MergeMem() && in(i)->outcnt() == 1) {\n+      Node *mem = in(i);\n+      if (mem && mem->is_MergeMem() && r->in(i)->outcnt() == 1) {\n@@ -426,1 +427,1 @@\n-        Node* other = phi->in(j);\n+        Node* other = in(j);\n@@ -430,2 +431,1 @@\n-          phase->is_IterGVN()->replace_node(phi, m);\n-          return true;\n+          return m;\n@@ -436,1 +436,1 @@\n-  return false;\n+  return NULL;\n@@ -451,2 +451,9 @@\n-    if (has_phis && try_clean_mem_phi(phase)) {\n-      has_phis = false;\n+    if (has_phis) {\n+      PhiNode* phi = has_unique_phi();\n+      if (phi != NULL) {\n+        Node* m = phi->try_clean_mem_phi(phase);\n+        if (m != NULL) {\n+          phase->is_IterGVN()->replace_node(phi, m);\n+          has_phis = false;\n+        }\n+      }\n@@ -862,1 +869,2 @@\n-             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck()) {\n+             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck() ||\n+             cmp1->is_FlatArrayCheck() || cmp2->is_FlatArrayCheck()) {\n@@ -943,1 +951,1 @@\n-  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), \"flatten at\");\n+  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flattened_accesses_share_alias()), \"flatten at\");\n@@ -1080,0 +1088,8 @@\n+  \/\/ Flat array element shouldn't get their own memory slice until flattened_accesses_share_alias is cleared.\n+  \/\/ It could be the graph has no loads\/stores and flattened_accesses_share_alias is never cleared. EA could still\n+  \/\/ creates per element Phis but that wouldn't be a problem as there are no memory accesses for that array.\n+  assert(_adr_type == NULL || _adr_type->isa_aryptr() == NULL ||\n+         _adr_type->is_aryptr()->is_known_instance() ||\n+         !_adr_type->is_aryptr()->is_flat() ||\n+         !Compile::current()->flattened_accesses_share_alias() ||\n+         _adr_type == TypeAryPtr::INLINES, \"flat array element shouldn't get its own slice yet\");\n@@ -1419,0 +1435,8 @@\n+  if (phase->is_IterGVN()) {\n+    Node* m = try_clean_mem_phi(phase);\n+    if (m != NULL) {\n+      return m;\n+    }\n+  }\n+\n+\n@@ -1941,0 +1965,48 @@\n+\/\/ Push inline type input nodes (and null) down through the phi recursively (can handle data loops).\n+InlineTypeBaseNode* PhiNode::push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init) {\n+  InlineTypeBaseNode* vt = NULL;\n+  if (_type->isa_ptr()) {\n+    vt = InlineTypePtrNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), is_init);\n+  } else {\n+    vt = InlineTypeNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), is_init);\n+  }\n+  if (can_reshape) {\n+    \/\/ Replace phi right away to be able to use the inline\n+    \/\/ type node when reaching the phi again through data loops.\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* u = fast_out(i);\n+      igvn->rehash_node_delayed(u);\n+      imax -= u->replace_edge(this, vt);\n+      --i;\n+    }\n+    assert(outcnt() == 0, \"should be dead now\");\n+  }\n+  ResourceMark rm;\n+  Node_List casts;\n+  for (uint i = 1; i < req(); ++i) {\n+    Node* n = in(i);\n+    while (n->is_ConstraintCast()) {\n+      casts.push(n);\n+      n = n->in(1);\n+    }\n+    if (phase->type(n)->is_zero_type()) {\n+      n = InlineTypePtrNode::make_null(*phase, vk);\n+    } else if (n->is_Phi()) {\n+      assert(can_reshape, \"can only handle phis during IGVN\");\n+      n = phase->transform(n->as_Phi()->push_inline_types_through(phase, can_reshape, vk, is_init));\n+    }\n+    while (casts.size() != 0) {\n+      \/\/ Push the cast(s) through the InlineTypePtrNode\n+      Node* cast = casts.pop()->clone();\n+      cast->set_req_X(1, n->as_InlineTypePtr()->get_oop(), phase);\n+      n = n->clone();\n+      n->as_InlineTypePtr()->set_oop(phase->transform(cast));\n+      n = phase->transform(n);\n+    }\n+    bool transform = !can_reshape && (i == (req()-1)); \/\/ Transform phis on last merge\n+    vt->merge_with(phase, n->as_InlineTypeBase(), i, transform);\n+  }\n+  return vt;\n+}\n+\n@@ -2242,0 +2314,2 @@\n+    \/\/ TODO revisit this with JDK-8247216\n+    bool mergemem_only = true;\n@@ -2254,0 +2328,2 @@\n+      } else {\n+        mergemem_only = false;\n@@ -2258,1 +2334,1 @@\n-    if (!saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n+    if (!mergemem_only && !saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n@@ -2329,0 +2405,5 @@\n+            if (igvn) {\n+              \/\/ TODO revisit this with JDK-8247216\n+              \/\/ Put 'n' on the worklist because it might be modified by MergeMemStream::iteration_setup\n+              igvn->_worklist.push(n);\n+            }\n@@ -2447,0 +2528,72 @@\n+  \/\/ Check recursively if inputs are either an inline type, constant null\n+  \/\/ or another Phi (including self references through data loops). If so,\n+  \/\/ push the inline types down through the phis to enable folding of loads.\n+  if (EnableValhalla && (_type->isa_ptr() || _type->isa_inlinetype()) && req() > 2) {\n+    ResourceMark rm;\n+    Unique_Node_List worklist;\n+    worklist.push(this);\n+    bool can_optimize = true;\n+    ciInlineKlass* vk = NULL;\n+    \/\/ true if all IsInit inputs of all InlineType* nodes are true\n+    bool is_init = true;\n+    Node_List casts;\n+\n+    \/\/ TODO 8284443 We need to prevent endless pushing through\n+    \/\/ TestLWorld -XX:+UseZGC -DScenarios=0 -DTest=test69\n+    \/\/ TestLWorld -XX:-TieredCompilation -XX:-DoEscapeAnalysis -XX:+AlwaysIncrementalInline\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* n = fast_out(i);\n+      if (n->is_InlineTypePtr() && n->in(1) == this) {\n+        can_optimize = false;\n+        break;\n+      }\n+    }\n+    \/\/ TODO 8284443 We could revisit the same node over and over again, right?\n+    for (uint next = 0; next < worklist.size() && can_optimize; next++) {\n+      Node* phi = worklist.at(next);\n+      for (uint i = 1; i < phi->req() && can_optimize; i++) {\n+        Node* n = phi->in(i);\n+        if (n == NULL) {\n+          can_optimize = false;\n+          break;\n+        }\n+        while (n->is_ConstraintCast()) {\n+          if (n->in(0) != NULL && n->in(0)->is_top()) {\n+            \/\/ Will die, don't optimize\n+            can_optimize = false;\n+            break;\n+          }\n+          casts.push(n);\n+          n = n->in(1);\n+        }\n+        const Type* t = phase->type(n);\n+        if (n->is_InlineTypeBase() && n->as_InlineTypeBase()->can_merge() &&\n+            (vk == NULL || vk == t->inline_klass())) {\n+          vk = (vk == NULL) ? t->inline_klass() : vk;\n+          if (phase->find_int_con(n->as_InlineTypeBase()->get_is_init(), 0) != 1) {\n+            is_init = false;\n+          }\n+        } else if (n->is_Phi() && can_reshape && (n->bottom_type()->isa_ptr() || n->bottom_type()->isa_inlinetype())) {\n+          worklist.push(n);\n+        } else if (t->is_zero_type()) {\n+          is_init = false;\n+        } else {\n+          can_optimize = false;\n+        }\n+      }\n+    }\n+    \/\/ Check if cast nodes can be pushed through\n+    const Type* t = Type::get_const_type(vk);\n+    while (casts.size() != 0 && can_optimize && t != NULL) {\n+      Node* cast = casts.pop();\n+      if (t->filter(cast->bottom_type()) == Type::TOP) {\n+        can_optimize = false;\n+      }\n+    }\n+    if (can_optimize && vk != NULL) {\n+\/\/ TODO 8275400\n+\/\/      assert(!_type->isa_ptr() || _type->maybe_null() || is_init, \"Phi not null but a possible null was seen\");\n+      return push_inline_types_through(phase, can_reshape, vk, is_init);\n+    }\n+  }\n+\n@@ -2539,0 +2692,1 @@\n+\n@@ -2819,0 +2973,6 @@\n+\n+  \/\/ CheckCastPPNode::Ideal() for inline types reuses the exception\n+  \/\/ paths of a call to perform an allocation: we can see a Phi here.\n+  if (in(1)->is_Phi()) {\n+    return this;\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":175,"deletions":15,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-  bool try_clean_mem_phi(PhaseGVN* phase);\n@@ -220,0 +219,3 @@\n+  Node* try_clean_mem_phi(PhaseGVN *phase);\n+\n+  InlineTypeBaseNode* push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init);\n@@ -407,0 +409,2 @@\n+  bool is_flat_array_check(PhaseTransform* phase, Node** array = NULL);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1784,1 +1784,1 @@\n-          derived->bottom_type()->make_ptr()->is_ptr()->_offset == 0, \"sanity\");\n+         derived->bottom_type()->make_ptr()->is_ptr()->offset() == 0, \"sanity\");\n@@ -1787,1 +1787,1 @@\n-  if( tj == NULL || tj->_offset == 0 ) {\n+  if (tj == NULL || tj->offset() == 0) {\n@@ -1953,1 +1953,1 @@\n-                  derived->bottom_type()->make_ptr()->is_ptr()->_offset == 0, \"sanity\");\n+                 derived->bottom_type()->make_ptr()->is_ptr()->offset() == 0, \"sanity\");\n@@ -1955,1 +1955,1 @@\n-          if( tj && tj->_offset != 0 && tj->isa_oop_ptr() ) {\n+          if (tj && tj->offset() != 0 && tj->isa_oop_ptr()) {\n@@ -2245,1 +2245,1 @@\n-  const TypeTuple *domain = C->tf()->domain();\n+  const TypeTuple *domain = C->tf()->domain_cc();\n@@ -2454,1 +2454,1 @@\n-                  if (is_derived && check->bottom_type()->is_ptr()->_offset != 0) {\n+                  if (is_derived && check->bottom_type()->is_ptr()->offset() != 0) {\n@@ -2458,1 +2458,1 @@\n-                    assert(check->bottom_type()->is_ptr()->_offset == 0, \"Bad base pointer\");\n+                    assert(check->bottom_type()->is_ptr()->offset() == 0, \"Bad base pointer\");\n@@ -2467,1 +2467,1 @@\n-                } else if (check->bottom_type()->is_ptr()->_offset == 0) {\n+                } else if (check->bottom_type()->is_ptr()->offset() == 0) {\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+macro(FlatArrayCheck)\n@@ -371,0 +372,2 @@\n+macro(InlineType)\n+macro(InlineTypePtr)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -394,0 +395,3 @@\n+  if (dead->is_InlineTypeBase()) {\n+    remove_inline_type(dead);\n+  }\n@@ -409,1 +413,1 @@\n-void Compile::remove_useless_nodes(Unique_Node_List &useful) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n@@ -432,1 +436,4 @@\n-      record_for_igvn(n->unique_out());\n+      worklist->push(n->unique_out());\n+    }\n+    if (n->outcnt() == 0) {\n+      worklist->push(n);\n@@ -441,0 +448,6 @@\n+  remove_useless_nodes(_inline_type_nodes,  useful); \/\/ remove useless inline type nodes\n+#ifdef ASSERT\n+  if (_modified_nodes != NULL) {\n+    _modified_nodes->remove_useless_nodes(useful.member_set());\n+  }\n+#endif\n@@ -615,0 +628,1 @@\n+                  _inline_type_nodes (comp_arena(), 8, 0, NULL),\n@@ -720,4 +734,2 @@\n-      const TypeTuple *domain = StartOSRNode::osr_domain();\n-      const TypeTuple *range = TypeTuple::make_range(method()->signature());\n-      init_tf(TypeFunc::make(domain, range));\n-      StartNode* s = new StartOSRNode(root(), domain);\n+      init_tf(TypeFunc::make(method(), \/* is_osr_compilation = *\/ true));\n+      StartNode* s = new StartOSRNode(root(), tf()->domain_sig());\n@@ -730,1 +742,1 @@\n-      StartNode* s = new StartNode(root(), tf()->domain());\n+      StartNode* s = new StartNode(root(), tf()->domain_cc());\n@@ -849,0 +861,10 @@\n+  if (needs_stack_repair()) {\n+    \/\/ One extra slot for the special stack increment value\n+    next_slot += 2;\n+  }\n+  \/\/ TODO 8284443 Only reserve extra slot if needed\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ One extra slot to hold the IsInit information for a nullable\n+    \/\/ inline type return if we run out of registers.\n+    next_slot += 2;\n+  }\n@@ -1000,0 +1022,4 @@\n+  _has_flattened_accesses = false;\n+  _flattened_accesses_share_alias = true;\n+  _scalarize_in_safepoints = false;\n+\n@@ -1304,1 +1330,2 @@\n-    assert(InlineUnsafeOps || StressReflectiveCode, \"indeterminate pointers come only from unsafe ops\");\n+    bool default_value_load = EnableValhalla && tj->is_instptr()->instance_klass() == ciEnv::current()->Class_klass();\n+    assert(InlineUnsafeOps || StressReflectiveCode || default_value_load, \"indeterminate pointers come only from unsafe ops\");\n@@ -1317,0 +1344,9 @@\n+  if (ta && ta->is_not_flat()) {\n+    \/\/ Erase not flat property for alias analysis.\n+    tj = ta = ta->cast_to_not_flat(false);\n+  }\n+  if (ta && ta->is_not_null_free()) {\n+    \/\/ Erase not null free property for alias analysis.\n+    tj = ta = ta->cast_to_not_null_free(false);\n+  }\n+\n@@ -1330,0 +1366,2 @@\n+    \/\/ For flattened inline type array, each field has its own slice so\n+    \/\/ we must include the field offset.\n@@ -1370,1 +1408,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());\n@@ -1374,1 +1412,6 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());\n+    }\n+    \/\/ Initially all flattened array accesses share a single slice\n+    if (ta->is_flat() && ta->elem() != TypeInlineType::BOTTOM && _flattened_accesses_share_alias) {\n+      const TypeAry *tary = TypeAry::make(TypeInlineType::BOTTOM, ta->size());\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));\n@@ -1381,1 +1424,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,aklass,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,aklass,false,Type::Offset(offset), ta->field_offset());\n@@ -1431,1 +1474,1 @@\n-        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, offset);\n+        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, Type::Offset(offset));\n@@ -1446,1 +1489,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, offset, to->instance_id());\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder->flatten_array(), to->instance_id());\n@@ -1448,1 +1491,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, offset);\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, Type::Offset(offset));\n@@ -1464,1 +1507,1 @@\n-                                       offset);\n+                                       Type::Offset(offset));\n@@ -1470,1 +1513,1 @@\n-        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), offset);\n+        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), Type::Offset(offset));\n@@ -1472,1 +1515,1 @@\n-        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, offset);\n+        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_null_free());\n@@ -1630,1 +1673,1 @@\n-Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field) {\n+Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field, bool uncached) {\n@@ -1634,3 +1677,6 @@\n-  AliasCacheEntry* ace = probe_alias_cache(adr_type);\n-  if (ace->_adr_type == adr_type) {\n-    return alias_type(ace->_index);\n+  AliasCacheEntry* ace = NULL;\n+  if (!uncached) {\n+    ace = probe_alias_cache(adr_type);\n+    if (ace->_adr_type == adr_type) {\n+      return alias_type(ace->_index);\n+    }\n@@ -1686,0 +1732,1 @@\n+    ciField* field = NULL;\n@@ -1692,0 +1739,1 @@\n+      const Type* elemtype = flat->is_aryptr()->elem();\n@@ -1693,1 +1741,8 @@\n-        alias_type(idx)->set_element(flat->is_aryptr()->elem());\n+        alias_type(idx)->set_element(elemtype);\n+      }\n+      int field_offset = flat->is_aryptr()->field_offset().get();\n+      if (elemtype->isa_inlinetype() &&\n+          field_offset != Type::OffsetBot) {\n+        ciInlineKlass* vk = elemtype->inline_klass();\n+        field_offset += vk->first_field_offset();\n+        field = vk->get_field_by_offset(field_offset, false);\n@@ -1705,0 +1760,2 @@\n+      if (flat->offset() == in_bytes(Klass::layout_helper_offset()))\n+        alias_type(idx)->set_rewritable(false);\n@@ -1715,1 +1772,0 @@\n-      ciField* field;\n@@ -1722,0 +1778,4 @@\n+      } else if (tinst->is_inlinetypeptr()) {\n+        \/\/ Inline type field\n+        ciInlineKlass* vk = tinst->inline_klass();\n+        field = vk->get_field_by_offset(tinst->offset(), false);\n@@ -1726,7 +1786,14 @@\n-      assert(field == NULL ||\n-             original_field == NULL ||\n-             (field->holder() == original_field->holder() &&\n-              field->offset() == original_field->offset() &&\n-              field->is_static() == original_field->is_static()), \"wrong field?\");\n-      \/\/ Set field() and is_rewritable() attributes.\n-      if (field != NULL)  alias_type(idx)->set_field(field);\n+    }\n+    assert(field == NULL ||\n+           original_field == NULL ||\n+           (field->holder() == original_field->holder() &&\n+            field->offset() == original_field->offset() &&\n+            field->is_static() == original_field->is_static()), \"wrong field?\");\n+    \/\/ Set field() and is_rewritable() attributes.\n+    if (field != NULL) {\n+      alias_type(idx)->set_field(field);\n+      if (flat->isa_aryptr()) {\n+        \/\/ Fields of flat arrays are rewritable although they are declared final\n+        assert(flat->is_aryptr()->is_flat(), \"must be a flat array\");\n+        alias_type(idx)->set_rewritable(true);\n+      }\n@@ -1737,3 +1804,4 @@\n-  ace->_adr_type = adr_type;\n-  ace->_index    = idx;\n-  assert(alias_type(adr_type) == alias_type(idx),  \"type must be installed\");\n+  if (!uncached) {\n+    ace->_adr_type = adr_type;\n+    ace->_index    = idx;\n+    assert(alias_type(adr_type) == alias_type(idx),  \"type must be installed\");\n@@ -1741,6 +1809,7 @@\n-  \/\/ Might as well try to fill the cache for the flattened version, too.\n-  AliasCacheEntry* face = probe_alias_cache(flat);\n-  if (face->_adr_type == NULL) {\n-    face->_adr_type = flat;\n-    face->_index    = idx;\n-    assert(alias_type(flat) == alias_type(idx), \"flat type must work too\");\n+    \/\/ Might as well try to fill the cache for the flattened version, too.\n+    AliasCacheEntry* face = probe_alias_cache(flat);\n+    if (face->_adr_type == NULL) {\n+      face->_adr_type = flat;\n+      face->_index    = idx;\n+      assert(alias_type(flat) == alias_type(idx), \"flat type must work too\");\n+    }\n@@ -1863,0 +1932,405 @@\n+void Compile::add_inline_type(Node* n) {\n+  assert(n->is_InlineTypeBase(), \"unexpected node\");\n+  _inline_type_nodes.push(n);\n+}\n+\n+void Compile::remove_inline_type(Node* n) {\n+  assert(n->is_InlineTypeBase(), \"unexpected node\");\n+  if (_inline_type_nodes.contains(n)) {\n+    _inline_type_nodes.remove(n);\n+  }\n+}\n+\n+\/\/ Does the return value keep otherwise useless inline type allocations alive?\n+static bool return_val_keeps_allocations_alive(Node* ret_val) {\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(ret_val);\n+  bool some_allocations = false;\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    assert(!n->is_InlineType(), \"chain of inline type nodes\");\n+    if (n->outcnt() > 1) {\n+      \/\/ Some other use for the allocation\n+      return false;\n+    } else if (n->is_InlineTypePtr()) {\n+      wq.push(n->in(1));\n+    } else if (n->is_Phi()) {\n+      for (uint j = 1; j < n->req(); j++) {\n+        wq.push(n->in(j));\n+      }\n+    } else if (n->is_CheckCastPP() &&\n+               n->in(1)->is_Proj() &&\n+               n->in(1)->in(0)->is_Allocate()) {\n+      some_allocations = true;\n+    } else if (n->is_CheckCastPP()) {\n+      wq.push(n->in(1));\n+    }\n+  }\n+  return some_allocations;\n+}\n+\n+void Compile::process_inline_types(PhaseIterGVN &igvn, bool remove) {\n+  \/\/ Make sure that the return value does not keep an otherwise unused allocation alive\n+  if (tf()->returns_inline_type_as_fields()) {\n+    Node* ret = NULL;\n+    for (uint i = 1; i < root()->req(); i++) {\n+      Node* in = root()->in(i);\n+      if (in->Opcode() == Op_Return) {\n+        assert(ret == NULL, \"only one return\");\n+        ret = in;\n+      }\n+    }\n+    if (ret != NULL) {\n+      Node* ret_val = ret->in(TypeFunc::Parms);\n+      if (igvn.type(ret_val)->isa_oopptr() &&\n+          return_val_keeps_allocations_alive(ret_val)) {\n+        igvn.replace_input_of(ret, TypeFunc::Parms, InlineTypeNode::tagged_klass(igvn.type(ret_val)->inline_klass(), igvn));\n+        assert(ret_val->outcnt() == 0, \"should be dead now\");\n+        igvn.remove_dead_node(ret_val);\n+      }\n+    }\n+  }\n+  if (_inline_type_nodes.length() == 0) {\n+    return;\n+  }\n+  \/\/ Scalarize inline types in safepoint debug info.\n+  \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info.\n+  set_scalarize_in_safepoints(true);\n+  for (int i = _inline_type_nodes.length()-1; i >= 0; i--) {\n+    _inline_type_nodes.at(i)->as_InlineTypeBase()->make_scalar_in_safepoints(&igvn);\n+  }\n+  if (remove) {\n+    \/\/ Remove inline type nodes\n+    while (_inline_type_nodes.length() > 0) {\n+      InlineTypeBaseNode* vt = _inline_type_nodes.pop()->as_InlineTypeBase();\n+      if (vt->outcnt() == 0) {\n+        igvn.remove_dead_node(vt);\n+      } else if (vt->is_InlineTypePtr()) {\n+        igvn.replace_node(vt, vt->get_oop());\n+      } else {\n+        \/\/ Check if any users are blackholes. If so, rewrite them to use either the\n+        \/\/ allocated buffer, or individual components, instead of the inline type node\n+        \/\/ that goes away.\n+        for (DUIterator i = vt->outs(); vt->has_out(i); i++) {\n+          if (vt->out(i)->is_Blackhole()) {\n+            BlackholeNode* bh = vt->out(i)->as_Blackhole();\n+\n+            \/\/ Unlink the old input\n+            int idx = bh->find_edge(vt);\n+            assert(idx != -1, \"The edge should be there\");\n+            bh->del_req(idx);\n+            --i;\n+\n+            if (vt->is_allocated(&igvn)) {\n+              \/\/ Already has the allocated instance, blackhole that\n+              bh->add_req(vt->get_oop());\n+            } else {\n+              \/\/ Not allocated yet, blackhole the components\n+              for (uint c = 0; c < vt->field_count(); c++) {\n+                bh->add_req(vt->field_value(c));\n+              }\n+            }\n+\n+            \/\/ Node modified, record for IGVN\n+            igvn.record_for_igvn(bh);\n+          }\n+        }\n+\n+#ifdef ASSERT\n+        for (DUIterator_Fast imax, i = vt->fast_outs(imax); i < imax; i++) {\n+          assert(vt->fast_out(i)->is_InlineTypeBase(), \"Unexpected inline type user\");\n+        }\n+#endif\n+        igvn.replace_node(vt, igvn.C->top());\n+      }\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n+void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN& igvn) {\n+  if (!_has_flattened_accesses) {\n+    return;\n+  }\n+  \/\/ Initially, all flattened array accesses share the same slice to\n+  \/\/ keep dependencies with Object[] array accesses (that could be\n+  \/\/ to a flattened array) correct. We're done with parsing so we\n+  \/\/ now know all flattened array accesses in this compile\n+  \/\/ unit. Let's move flattened array accesses to their own slice,\n+  \/\/ one per element field. This should help memory access\n+  \/\/ optimizations.\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(root());\n+\n+  Node_List mergememnodes;\n+  Node_List memnodes;\n+\n+  \/\/ Alias index currently shared by all flattened memory accesses\n+  int index = get_alias_index(TypeAryPtr::INLINES);\n+\n+  \/\/ Find MergeMem nodes and flattened array accesses\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    if (n->is_Mem()) {\n+      const TypePtr* adr_type = NULL;\n+      if (n->Opcode() == Op_StoreCM) {\n+        adr_type = get_adr_type(get_alias_index(n->in(MemNode::OopStore)->adr_type()));\n+      } else {\n+        adr_type = get_adr_type(get_alias_index(n->adr_type()));\n+      }\n+      if (adr_type == TypeAryPtr::INLINES) {\n+        memnodes.push(n);\n+      }\n+    } else if (n->is_MergeMem()) {\n+      MergeMemNode* mm = n->as_MergeMem();\n+      if (mm->memory_at(index) != mm->base_memory()) {\n+        mergememnodes.push(n);\n+      }\n+    }\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* m = n->in(j);\n+      if (m != NULL) {\n+        wq.push(m);\n+      }\n+    }\n+  }\n+\n+  if (memnodes.size() > 0) {\n+    _flattened_accesses_share_alias = false;\n+\n+    \/\/ We are going to change the slice for the flattened array\n+    \/\/ accesses so we need to clear the cache entries that refer to\n+    \/\/ them.\n+    for (uint i = 0; i < AliasCacheSize; i++) {\n+      AliasCacheEntry* ace = &_alias_cache[i];\n+      if (ace->_adr_type != NULL &&\n+          ace->_adr_type->isa_aryptr() &&\n+          ace->_adr_type->is_aryptr()->is_flat()) {\n+        ace->_adr_type = NULL;\n+        ace->_index = (i != 0) ? 0 : AliasIdxTop; \/\/ Make sure the NULL adr_type resolves to AliasIdxTop\n+      }\n+    }\n+\n+    \/\/ Find what aliases we are going to add\n+    int start_alias = num_alias_types()-1;\n+    int stop_alias = 0;\n+\n+    for (uint i = 0; i < memnodes.size(); i++) {\n+      Node* m = memnodes.at(i);\n+      const TypePtr* adr_type = NULL;\n+      if (m->Opcode() == Op_StoreCM) {\n+        adr_type = m->in(MemNode::OopStore)->adr_type();\n+        if (adr_type != TypeAryPtr::INLINES) {\n+          \/\/ store was optimized out and we lost track of the adr_type\n+          Node* clone = new StoreCMNode(m->in(MemNode::Control), m->in(MemNode::Memory), m->in(MemNode::Address),\n+                                        m->adr_type(), m->in(MemNode::ValueIn), m->in(MemNode::OopStore),\n+                                        get_alias_index(adr_type));\n+          igvn.register_new_node_with_optimizer(clone);\n+          igvn.replace_node(m, clone);\n+        }\n+      } else {\n+        adr_type = m->adr_type();\n+#ifdef ASSERT\n+        m->as_Mem()->set_adr_type(adr_type);\n+#endif\n+      }\n+      int idx = get_alias_index(adr_type);\n+      start_alias = MIN2(start_alias, idx);\n+      stop_alias = MAX2(stop_alias, idx);\n+    }\n+\n+    assert(stop_alias >= start_alias, \"should have expanded aliases\");\n+\n+    Node_Stack stack(0);\n+#ifdef ASSERT\n+    VectorSet seen(Thread::current()->resource_area());\n+#endif\n+    \/\/ Now let's fix the memory graph so each flattened array access\n+    \/\/ is moved to the right slice. Start from the MergeMem nodes.\n+    uint last = unique();\n+    for (uint i = 0; i < mergememnodes.size(); i++) {\n+      MergeMemNode* current = mergememnodes.at(i)->as_MergeMem();\n+      Node* n = current->memory_at(index);\n+      MergeMemNode* mm = NULL;\n+      do {\n+        \/\/ Follow memory edges through memory accesses, phis and\n+        \/\/ narrow membars and push nodes on the stack. Once we hit\n+        \/\/ bottom memory, we pop element off the stack one at a\n+        \/\/ time, in reverse order, and move them to the right slice\n+        \/\/ by changing their memory edges.\n+        if ((n->is_Phi() && n->adr_type() != TypePtr::BOTTOM) || n->is_Mem() || n->adr_type() == TypeAryPtr::INLINES) {\n+          assert(!seen.test_set(n->_idx), \"\");\n+          \/\/ Uses (a load for instance) will need to be moved to the\n+          \/\/ right slice as well and will get a new memory state\n+          \/\/ that we don't know yet. The use could also be the\n+          \/\/ backedge of a loop. We put a place holder node between\n+          \/\/ the memory node and its uses. We replace that place\n+          \/\/ holder with the correct memory state once we know it,\n+          \/\/ i.e. when nodes are popped off the stack. Using the\n+          \/\/ place holder make the logic work in the presence of\n+          \/\/ loops.\n+          if (n->outcnt() > 1) {\n+            Node* place_holder = NULL;\n+            assert(!n->has_out_with(Op_Node), \"\");\n+            for (DUIterator k = n->outs(); n->has_out(k); k++) {\n+              Node* u = n->out(k);\n+              if (u != current && u->_idx < last) {\n+                bool success = false;\n+                for (uint l = 0; l < u->req(); l++) {\n+                  if (!stack.is_empty() && u == stack.node() && l == stack.index()) {\n+                    continue;\n+                  }\n+                  Node* in = u->in(l);\n+                  if (in == n) {\n+                    if (place_holder == NULL) {\n+                      place_holder = new Node(1);\n+                      place_holder->init_req(0, n);\n+                    }\n+                    igvn.replace_input_of(u, l, place_holder);\n+                    success = true;\n+                  }\n+                }\n+                if (success) {\n+                  --k;\n+                }\n+              }\n+            }\n+          }\n+          if (n->is_Phi()) {\n+            stack.push(n, 1);\n+            n = n->in(1);\n+          } else if (n->is_Mem()) {\n+            stack.push(n, n->req());\n+            n = n->in(MemNode::Memory);\n+          } else {\n+            assert(n->is_Proj() && n->in(0)->Opcode() == Op_MemBarCPUOrder, \"\");\n+            stack.push(n, n->req());\n+            n = n->in(0)->in(TypeFunc::Memory);\n+          }\n+        } else {\n+          assert(n->adr_type() == TypePtr::BOTTOM || (n->Opcode() == Op_Node && n->_idx >= last) || (n->is_Proj() && n->in(0)->is_Initialize()), \"\");\n+          \/\/ Build a new MergeMem node to carry the new memory state\n+          \/\/ as we build it. IGVN should fold extraneous MergeMem\n+          \/\/ nodes.\n+          mm = MergeMemNode::make(n);\n+          igvn.register_new_node_with_optimizer(mm);\n+          while (stack.size() > 0) {\n+            Node* m = stack.node();\n+            uint idx = stack.index();\n+            if (m->is_Mem()) {\n+              \/\/ Move memory node to its new slice\n+              const TypePtr* adr_type = m->adr_type();\n+              int alias = get_alias_index(adr_type);\n+              Node* prev = mm->memory_at(alias);\n+              igvn.replace_input_of(m, MemNode::Memory, prev);\n+              mm->set_memory_at(alias, m);\n+            } else if (m->is_Phi()) {\n+              \/\/ We need as many new phis as there are new aliases\n+              igvn.replace_input_of(m, idx, mm);\n+              if (idx == m->req()-1) {\n+                Node* r = m->in(0);\n+                for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n+                  const Type* adr_type = get_adr_type(j);\n+                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n+                    continue;\n+                  }\n+                  Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));\n+                  igvn.register_new_node_with_optimizer(phi);\n+                  for (uint k = 1; k < m->req(); k++) {\n+                    phi->init_req(k, m->in(k)->as_MergeMem()->memory_at(j));\n+                  }\n+                  mm->set_memory_at(j, phi);\n+                }\n+                Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);\n+                igvn.register_new_node_with_optimizer(base_phi);\n+                for (uint k = 1; k < m->req(); k++) {\n+                  base_phi->init_req(k, m->in(k)->as_MergeMem()->base_memory());\n+                }\n+                mm->set_base_memory(base_phi);\n+              }\n+            } else {\n+              \/\/ This is a MemBarCPUOrder node from\n+              \/\/ Parse::array_load()\/Parse::array_store(), in the\n+              \/\/ branch that handles flattened arrays hidden under\n+              \/\/ an Object[] array. We also need one new membar per\n+              \/\/ new alias to keep the unknown access that the\n+              \/\/ membars protect properly ordered with accesses to\n+              \/\/ known flattened array.\n+              assert(m->is_Proj(), \"projection expected\");\n+              Node* ctrl = m->in(0)->in(TypeFunc::Control);\n+              igvn.replace_input_of(m->in(0), TypeFunc::Control, top());\n+              for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n+                const Type* adr_type = get_adr_type(j);\n+                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n+                  continue;\n+                }\n+                MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);\n+                igvn.register_new_node_with_optimizer(mb);\n+                Node* mem = mm->memory_at(j);\n+                mb->init_req(TypeFunc::Control, ctrl);\n+                mb->init_req(TypeFunc::Memory, mem);\n+                ctrl = new ProjNode(mb, TypeFunc::Control);\n+                igvn.register_new_node_with_optimizer(ctrl);\n+                mem = new ProjNode(mb, TypeFunc::Memory);\n+                igvn.register_new_node_with_optimizer(mem);\n+                mm->set_memory_at(j, mem);\n+              }\n+              igvn.replace_node(m->in(0)->as_Multi()->proj_out(TypeFunc::Control), ctrl);\n+            }\n+            if (idx < m->req()-1) {\n+              idx += 1;\n+              stack.set_index(idx);\n+              n = m->in(idx);\n+              break;\n+            }\n+            \/\/ Take care of place holder nodes\n+            if (m->has_out_with(Op_Node)) {\n+              Node* place_holder = m->find_out_with(Op_Node);\n+              if (place_holder != NULL) {\n+                Node* mm_clone = mm->clone();\n+                igvn.register_new_node_with_optimizer(mm_clone);\n+                Node* hook = new Node(1);\n+                hook->init_req(0, mm);\n+                igvn.replace_node(place_holder, mm_clone);\n+                hook->destruct(&igvn);\n+              }\n+              assert(!m->has_out_with(Op_Node), \"place holder should be gone now\");\n+            }\n+            stack.pop();\n+          }\n+        }\n+      } while(stack.size() > 0);\n+      \/\/ Fix the memory state at the MergeMem we started from\n+      igvn.rehash_node_delayed(current);\n+      for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n+        const Type* adr_type = get_adr_type(j);\n+        if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {\n+          continue;\n+        }\n+        current->set_memory_at(j, mm);\n+      }\n+      current->set_memory_at(index, current->base_memory());\n+    }\n+    igvn.optimize();\n+  }\n+  print_method(PHASE_SPLIT_INLINES_ARRAY, 2);\n+#ifdef ASSERT\n+  if (!_flattened_accesses_share_alias) {\n+    wq.clear();\n+    wq.push(root());\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* n = wq.at(i);\n+      assert(n->adr_type() != TypeAryPtr::INLINES, \"should have been removed from the graph\");\n+      for (uint j = 0; j < n->req(); j++) {\n+        Node* m = n->in(j);\n+        if (m != NULL) {\n+          wq.push(m);\n+        }\n+      }\n+    }\n+  }\n+#endif\n+}\n+\n@@ -2152,1 +2626,4 @@\n-  assert(_modified_nodes == NULL, \"not allowed\");\n+#ifdef ASSERT\n+  Unique_Node_List* modified_nodes = _modified_nodes;\n+  _modified_nodes = NULL;\n+#endif\n@@ -2166,0 +2643,1 @@\n+  DEBUG_ONLY( _modified_nodes = modified_nodes; )\n@@ -2309,0 +2787,5 @@\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n+\n+  adjust_flattened_array_access_aliases(igvn);\n+\n@@ -2422,0 +2905,8 @@\n+  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n+\n+  if (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual and MH calls.\n+    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n+    process_late_inline_calls_no_inline(igvn);\n+  }\n+\n@@ -2432,0 +2923,4 @@\n+  \/\/ Process inline type nodes again and remove them. From here\n+  \/\/ on we don't need to keep track of field values anymore.\n+  process_inline_types(igvn, \/* remove= *\/ true);\n+\n@@ -2447,0 +2942,1 @@\n+  DEBUG_ONLY( _late_inlines.clear(); )\n@@ -2449,8 +2945,0 @@\n-\n-  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n-\n-  if (_late_inlines.length() > 0) {\n-    \/\/ More opportunities to optimize virtual and MH calls.\n-    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n-    process_late_inline_calls_no_inline(igvn);\n-  }\n@@ -3079,0 +3567,1 @@\n+\n@@ -3232,1 +3721,16 @@\n-      n->add_prec(prec);\n+      if (prec->is_MergeMem()) {\n+        MergeMemNode* mm = prec->as_MergeMem();\n+        Node* base = mm->base_memory();\n+        for (int i = AliasIdxRaw + 1; i < num_alias_types(); i++) {\n+          const Type* adr_type = get_adr_type(i);\n+          if (adr_type->isa_aryptr() && adr_type->is_aryptr()->is_flat()) {\n+            Node* m = mm->memory_at(i);\n+            n->add_prec(m);\n+          }\n+        }\n+        if (mm->outcnt() == 0) {\n+          mm->disconnect_inputs(this);\n+        }\n+      } else {\n+        n->add_prec(prec);\n+      }\n@@ -3846,0 +4350,8 @@\n+#ifdef ASSERT\n+  case Op_InlineTypePtr:\n+  case Op_InlineType: {\n+    n->dump(-1);\n+    assert(false, \"inline type node was not removed\");\n+    break;\n+  }\n+#endif\n@@ -4204,2 +4716,2 @@\n-      if (accessing_method->is_static_initializer() ||\n-          accessing_method->is_object_initializer() ||\n+      if (accessing_method->is_class_initializer() ||\n+          accessing_method->is_object_constructor() ||\n@@ -4213,1 +4725,1 @@\n-      if (accessing_method->is_static_initializer()) {\n+      if (accessing_method->is_class_initializer()) {\n@@ -4346,0 +4858,8 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Perform a full test.\n+  if (superk->isa_aryklassptr() && !superk->is_aryklassptr()->is_null_free() &&\n+      superk->is_aryklassptr()->elem()->isa_klassptr() && superk->is_aryklassptr()->elem()->is_klassptr()->klass()->is_inlinetype()) {\n+    return SSC_full_test;\n+  }\n+\n@@ -4882,0 +5402,21 @@\n+Node* Compile::optimize_acmp(PhaseGVN* phase, Node* a, Node* b) {\n+  const TypeInstPtr* ta = phase->type(a)->isa_instptr();\n+  const TypeInstPtr* tb = phase->type(b)->isa_instptr();\n+  if (!EnableValhalla || ta == NULL || tb == NULL ||\n+      ta->is_zero_type() || tb->is_zero_type() ||\n+      !ta->can_be_inline_type() || !tb->can_be_inline_type()) {\n+    \/\/ Use old acmp if one operand is null or not an inline type\n+    return new CmpPNode(a, b);\n+  } else if (ta->is_inlinetypeptr() || tb->is_inlinetypeptr()) {\n+    \/\/ We know that one operand is an inline type. Therefore,\n+    \/\/ new acmp will only return true if both operands are NULL.\n+    \/\/ Check if both operands are null by or'ing the oops.\n+    a = phase->transform(new CastP2XNode(NULL, a));\n+    b = phase->transform(new CastP2XNode(NULL, b));\n+    a = phase->transform(new OrXNode(a, b));\n+    return new CmpXNode(a, phase->MakeConX(0));\n+  }\n+  \/\/ Use new acmp\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":593,"deletions":52,"binary":false,"changes":645,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class CallNode;\n@@ -95,0 +96,1 @@\n+class InlineTypeBaseNode;\n@@ -347,0 +349,3 @@\n+  bool                  _has_flattened_accesses; \/\/ Any known flattened array accesses?\n+  bool                  _flattened_accesses_share_alias; \/\/ Initially all flattened array share a single slice\n+  bool                  _scalarize_in_safepoints; \/\/ Scalarize inline types in safepoint debug info\n@@ -362,0 +367,1 @@\n+  GrowableArray<Node*>  _inline_type_nodes;     \/\/ List of InlineType nodes\n@@ -637,0 +643,10 @@\n+  void          set_flattened_accesses()         { _has_flattened_accesses = true; }\n+  bool          flattened_accesses_share_alias() const { return _flattened_accesses_share_alias; }\n+  void          set_flattened_accesses_share_alias(bool z) { _flattened_accesses_share_alias = z; }\n+  bool          scalarize_in_safepoints() const { return _scalarize_in_safepoints; }\n+  void          set_scalarize_in_safepoints(bool z) { _scalarize_in_safepoints = z; }\n+\n+  \/\/ Support for scalarized inline type calling convention\n+  bool              has_scalarized_args() const  { return _method != NULL && _method->has_scalarized_args(); }\n+  bool              needs_stack_repair()  const  { return _method != NULL && _method->get_Method()->c2_needs_stack_repair(); }\n+\n@@ -738,0 +754,7 @@\n+  \/\/ Keep track of inline type nodes for later processing\n+  void add_inline_type(Node* n);\n+  void remove_inline_type(Node* n);\n+  void process_inline_types(PhaseIterGVN &igvn, bool remove = false);\n+\n+  void adjust_flattened_array_access_aliases(PhaseIterGVN& igvn);\n+\n@@ -882,1 +905,1 @@\n-  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL) { return find_alias_type(adr_type, false, field); }\n+  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL, bool uncached = false) { return find_alias_type(adr_type, false, field, uncached); }\n@@ -886,1 +909,1 @@\n-  int               get_alias_index(const TypePtr* at)  { return alias_type(at)->index(); }\n+  int               get_alias_index(const TypePtr* at, bool uncached = false) { return alias_type(at, NULL, uncached)->index(); }\n@@ -956,1 +979,1 @@\n-  void              remove_useless_nodes (Unique_Node_List &useful);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n@@ -1115,1 +1138,1 @@\n-  AliasType* find_alias_type(const TypePtr* adr_type, bool no_create, ciField* field);\n+  AliasType* find_alias_type(const TypePtr* adr_type, bool no_create, ciField* field, bool uncached = false);\n@@ -1188,1 +1211,3 @@\n-  \/\/ Auxiliary methods for randomized fuzzing\/stressing\n+  Node* optimize_acmp(PhaseGVN* phase, Node* a, Node* b);\n+\n+  \/\/ Auxiliary method for randomized fuzzing\/stressing\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -64,0 +65,10 @@\n+\/\/------------------------------Ideal------------------------------------------\n+Node* Conv2BNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1)->is_InlineTypePtr()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    set_req_X(1, in(1)->as_InlineTypePtr()->get_is_init(), phase);\n+    return this;\n+  }\n+  return NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1390,1 +1390,1 @@\n-Node *DivModINode::match( const ProjNode *proj, const Matcher *match ) {\n+Node *DivModINode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {\n@@ -1405,1 +1405,1 @@\n-Node *DivModLNode::match( const ProjNode *proj, const Matcher *match ) {\n+Node *DivModLNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {\n@@ -1443,1 +1443,1 @@\n-Node* UDivModINode::match( const ProjNode *proj, const Matcher *match ) {\n+Node* UDivModINode::match(const ProjNode* proj, const Matcher* match, const RegMask* mask) {\n@@ -1458,1 +1458,1 @@\n-Node* UDivModLNode::match( const ProjNode *proj, const Matcher *match ) {\n+Node* UDivModLNode::match( const ProjNode* proj, const Matcher* match, const RegMask* mask) {\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);\n@@ -229,1 +229,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);\n@@ -243,1 +243,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node* match(const ProjNode* proj, const Matcher* m, const RegMask* mask);\n@@ -256,1 +256,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node* match(const ProjNode* proj, const Matcher* m, const RegMask* mask);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -571,1 +572,6 @@\n-    const TypeOopPtr* receiver_type = _gvn.type(receiver_node)->isa_oopptr();\n+    const TypeOopPtr* receiver_type = NULL;\n+    if (receiver_node->is_InlineType()) {\n+      receiver_type = TypeInstPtr::make(TypePtr::NotNull, _gvn.type(receiver_node)->inline_klass());\n+    } else {\n+      receiver_type = _gvn.type(receiver_node)->isa_oopptr();\n+    }\n@@ -587,1 +593,1 @@\n-  if (iter().cur_bc_raw() == Bytecodes::_invokespecial && !orig_callee->is_object_initializer()) {\n+  if (iter().cur_bc_raw() == Bytecodes::_invokespecial && !orig_callee->is_object_constructor()) {\n@@ -656,1 +662,1 @@\n-  if (receiver != NULL && !call_does_dispatch && !cg->is_string_late_inline()) {\n+  if (receiver != NULL && !receiver->is_InlineType() && !call_does_dispatch && !cg->is_string_late_inline()) {\n@@ -717,1 +723,1 @@\n-          \/\/ It's OK for a method  to return a value that is discarded.\n+          \/\/ It's OK for a method to return a value that is discarded.\n@@ -729,1 +735,4 @@\n-            if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n+            if (declared_signature->returns_null_free_inline_type()) {\n+              sig_type = sig_type->join_speculative(TypePtr::NOTNULL);\n+            }\n+            if (arg_type != NULL && !arg_type->higher_equal(sig_type) && !peek()->is_InlineType()) {\n@@ -775,0 +784,5 @@\n+    if (rtype->basic_type() == T_PRIMITIVE_OBJECT && !peek()->is_InlineTypeBase()) {\n+      Node* retnode = pop();\n+      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass(), !gvn().type(retnode)->maybe_null());\n+      push_node(T_PRIMITIVE_OBJECT, retnode);\n+    }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -155,0 +156,10 @@\n+    if ((n->Opcode() == Op_LoadX || n->Opcode() == Op_StoreX) &&\n+        !n->in(MemNode::Address)->is_AddP() &&\n+        _igvn->type(n->in(MemNode::Address))->isa_oopptr()) {\n+      \/\/ Load\/Store at mark work address is at offset 0 so has no AddP which confuses EA\n+      Node* addp = new AddPNode(n->in(MemNode::Address), n->in(MemNode::Address), _igvn->MakeConX(0));\n+      _igvn->register_new_node_with_optimizer(addp);\n+      _igvn->replace_input_of(n, MemNode::Address, addp);\n+      ideal_nodes.push(addp);\n+      _nodes.at_put_grow(addp->_idx, NULL, NULL);\n+    }\n@@ -437,1 +448,1 @@\n-      const TypeTuple* d = call->tf()->domain();\n+      const TypeTuple* d = call->tf()->domain_sig();\n@@ -511,0 +522,11 @@\n+      } else if (n->as_Call()->tf()->returns_inline_type_as_fields()) {\n+        bool returns_oop = false;\n+        for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax && !returns_oop; i++) {\n+          ProjNode* pn = n->fast_out(i)->as_Proj();\n+          if (pn->_con >= TypeFunc::Parms && pn->bottom_type()->isa_ptr()) {\n+            returns_oop = true;\n+          }\n+        }\n+        if (returns_oop) {\n+          add_call_node(n->as_Call());\n+        }\n@@ -542,0 +564,1 @@\n+    case Op_InlineTypePtr:\n@@ -613,2 +636,4 @@\n-      if (n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->is_Call() &&\n-          n->in(0)->as_Call()->returns_pointer()) {\n+      if (n->as_Proj()->_con >= TypeFunc::Parms && n->in(0)->is_Call() &&\n+          (n->in(0)->as_Call()->returns_pointer() || n->bottom_type()->isa_ptr())) {\n+        assert((n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->as_Call()->returns_pointer()) ||\n+               n->in(0)->as_Call()->tf()->returns_inline_type_as_fields(), \"what kind of oop return is it?\");\n@@ -715,0 +740,1 @@\n+    case Op_InlineTypePtr:\n@@ -770,2 +796,2 @@\n-      assert(n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->is_Call() &&\n-             n->in(0)->as_Call()->returns_pointer(), \"Unexpected node type\");\n+      assert((n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->as_Call()->returns_pointer()) ||\n+             n->in(0)->as_Call()->tf()->returns_inline_type_as_fields(), \"what kind of oop return is it?\");\n@@ -947,1 +973,1 @@\n-  assert(call->returns_pointer(), \"only for call which returns pointer\");\n+  assert(call->returns_pointer() || call->tf()->returns_inline_type_as_fields(), \"only for call which returns pointer\");\n@@ -1023,1 +1049,2 @@\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0, \"TODO: add failed case check\");\n+      assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+             strncmp(name, \"_load_unknown_inline\", 20) == 0, \"TODO: add failed case check\");\n@@ -1051,1 +1078,1 @@\n-        const TypeTuple* d = call->tf()->domain();\n+        const TypeTuple* d = call->tf()->domain_cc();\n@@ -1099,1 +1126,1 @@\n-      const TypeTuple * d = call->tf()->domain();\n+      const TypeTuple * d = call->tf()->domain_sig();\n@@ -1130,1 +1157,4 @@\n-                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != NULL)));\n+                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != NULL)) ||\n+                               (aat->isa_aryptr() && aat->isa_aryptr()->elem() != NULL &&\n+                                                               aat->isa_aryptr()->is_flat() &&\n+                                                               aat->isa_aryptr()->elem()->inline_klass()->contains_oops()));\n@@ -1177,0 +1207,3 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"vectorizedMismatch\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"load_unknown_inline\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"store_unknown_inline\") == 0 ||\n@@ -1239,1 +1272,1 @@\n-        const TypeTuple* d = call->tf()->domain();\n+        const TypeTuple* d = call->tf()->domain_cc();\n@@ -1283,1 +1316,1 @@\n-      const TypeTuple* d = call->tf()->domain();\n+      const TypeTuple* d = call->tf()->domain_cc();\n@@ -1696,0 +1729,1 @@\n+  PointsToNode* init_val = phantom_obj;\n@@ -1701,1 +1735,8 @@\n-    return 0;\n+    if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+      \/\/ Non-flattened inline type arrays are initialized with\n+      \/\/ the default value instead of null. Handle them here.\n+      init_val = ptnode_adr(alloc->as_Allocate()->in(AllocateNode::DefaultValue)->_idx);\n+      assert(init_val != NULL, \"default value should be registered\");\n+    } else {\n+      return 0;\n+    }\n@@ -1703,1 +1744,2 @@\n-  assert(pta->arraycopy_dst() || alloc->as_CallStaticJava(), \"sanity\");\n+  \/\/ Non-escaped allocation returned from Java or runtime call has unknown values in fields.\n+  assert(pta->arraycopy_dst() || alloc->is_CallStaticJava() || init_val != phantom_obj, \"sanity\");\n@@ -1705,1 +1747,1 @@\n-  if (!pta->arraycopy_dst() && alloc->as_CallStaticJava()->method() == NULL) {\n+  if (alloc->is_CallStaticJava() && alloc->as_CallStaticJava()->method() == NULL) {\n@@ -1707,1 +1749,2 @@\n-    assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n+    assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+           strncmp(name, \"_load_unknown_inline\", 20) == 0, \"sanity\");\n@@ -1715,1 +1758,1 @@\n-      if (add_edge(field, phantom_obj)) {\n+      if (add_edge(field, init_val)) {\n@@ -1730,1 +1773,1 @@\n-  if (!alloc->is_Allocate()) {\n+  if (!alloc->is_Allocate() || alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n@@ -1816,1 +1859,1 @@\n-                tty->print_cr(\"----------missed referernce to object-----------\");\n+                tty->print_cr(\"----------missed reference to object------------\");\n@@ -1818,1 +1861,1 @@\n-                tty->print_cr(\"----------object referernced by init store -----\");\n+                tty->print_cr(\"----------object referenced by init store-------\");\n@@ -2050,1 +2093,3 @@\n-          if (not_global_escape(alock->obj_node())) {\n+          const Type* obj_type = igvn->type(alock->obj_node());\n+          if (not_global_escape(alock->obj_node()) &&\n+              !obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n@@ -2091,5 +2136,10 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n-      mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n-      mb->init_req(TypeFunc::Control, storestore->in(TypeFunc::Control));\n-      igvn->register_new_node_with_optimizer(mb);\n-      igvn->replace_node(storestore, mb);\n+      if (alloc->in(AllocateNode::InlineTypeNode) != NULL) {\n+        \/\/ Non-escaping inline type buffer allocations don't require a membar\n+        storestore->as_MemBar()->remove(_igvn);\n+      } else {\n+        MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n+        mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n+        mb->init_req(TypeFunc::Control, storestore->in(TypeFunc::Control));\n+        igvn->register_new_node_with_optimizer(mb);\n+        igvn->replace_node(storestore, mb);\n+      }\n@@ -2248,0 +2298,1 @@\n+  int field_offset = adr_type->isa_aryptr() ? adr_type->isa_aryptr()->field_offset().get() : Type::OffsetBot;\n@@ -2249,1 +2300,1 @@\n-  if (offset == Type::OffsetBot) {\n+  if (offset == Type::OffsetBot && field_offset == Type::OffsetBot) {\n@@ -2261,1 +2312,1 @@\n-      ciField* field = _compile->alias_type(adr_type->isa_instptr())->field();\n+      ciField* field = _compile->alias_type(adr_type->is_ptr())->field();\n@@ -2281,1 +2332,7 @@\n-        bt = elemtype->array_element_basic_type();\n+        if (elemtype->isa_inlinetype() && field_offset != Type::OffsetBot) {\n+          ciInlineKlass* vk = elemtype->inline_klass();\n+          field_offset += vk->first_field_offset();\n+          bt = vk->get_field_by_offset(field_offset, false)->layout_type();\n+        } else {\n+          bt = elemtype->array_element_basic_type();\n+        }\n@@ -2465,3 +2522,1 @@\n-  const TypePtr *t_ptr = adr_type->isa_ptr();\n-  assert(t_ptr != NULL, \"must be a pointer type\");\n-  return t_ptr->offset();\n+  return adr_type->is_ptr()->flattened_offset();\n@@ -2621,1 +2676,8 @@\n-    t = base_t->add_offset(offs)->is_oopptr();\n+    if (base_t->isa_aryptr() != NULL) {\n+      \/\/ In the case of a flattened inline type array, each field has its\n+      \/\/ own slice so we need to extract the field being accessed from\n+      \/\/ the address computation\n+      t = base_t->isa_aryptr()->add_field_offset_and_offset(offs)->is_oopptr();\n+    } else {\n+      t = base_t->add_offset(offs)->is_oopptr();\n+    }\n@@ -2623,1 +2685,1 @@\n-  int inst_id =  base_t->instance_id();\n+  int inst_id = base_t->instance_id();\n@@ -2637,1 +2699,1 @@\n-  \/\/ It could happened when CHA type is different from MDO type on a dead path\n+  \/\/ It could happen when CHA type is different from MDO type on a dead path\n@@ -2647,1 +2709,12 @@\n-  const TypeOopPtr *tinst = base_t->add_offset(t->offset())->is_oopptr();\n+  const TypePtr* tinst = base_t->add_offset(t->offset());\n+  if (tinst->isa_aryptr() && t->isa_aryptr()) {\n+    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ own slice so we need to keep track of the field being accessed.\n+    tinst = tinst->is_aryptr()->with_field_offset(t->is_aryptr()->field_offset().get());\n+    \/\/ Keep array properties (not flat\/null-free)\n+    tinst = tinst->is_aryptr()->update_properties(t->is_aryptr());\n+    if (tinst == NULL) {\n+      return false; \/\/ Skip dead path with inconsistent properties\n+    }\n+  }\n+\n@@ -3329,0 +3402,7 @@\n+          if (tn_t->isa_aryptr()) {\n+            \/\/ Keep array properties (not flat\/null-free)\n+            tinst = tinst->is_aryptr()->update_properties(tn_t->is_aryptr());\n+            if (tinst == NULL) {\n+              continue; \/\/ Skip dead path with inconsistent properties\n+            }\n+          }\n@@ -3354,1 +3434,1 @@\n-      if(use->is_Mem() && use->in(MemNode::Address) == n) {\n+      if (use->is_Mem() && use->in(MemNode::Address) == n) {\n@@ -3390,0 +3470,3 @@\n+      } else if (use->Opcode() == Op_Return) {\n+        \/\/ Allocation is referenced by field of returned inline type\n+        assert(_compile->tf()->returns_inline_type_as_fields(), \"EA: unexpected reference by ReturnNode\");\n@@ -3402,1 +3485,1 @@\n-              op == Op_SubTypeCheck ||\n+              op == Op_SubTypeCheck || op == Op_InlineType || op == Op_InlineTypePtr || op == Op_FlatArrayCheck ||\n@@ -3472,0 +3555,3 @@\n+    } else if (n->is_CallLeaf() && n->as_CallLeaf()->_name != NULL &&\n+               strcmp(n->as_CallLeaf()->_name, \"store_unknown_inline\") == 0) {\n+      n = n->as_CallLeaf()->proj_out(TypeFunc::Memory);\n@@ -3514,1 +3600,1 @@\n-      } else if(use->is_Mem()) {\n+      } else if (use->is_Mem()) {\n@@ -3523,0 +3609,4 @@\n+      } else if (use->is_CallLeaf() && use->as_CallLeaf()->_name != NULL &&\n+                 strcmp(use->as_CallLeaf()->_name, \"store_unknown_inline\") == 0) {\n+        \/\/ store_unknown_inline overwrites destination array\n+        memnode_worklist.append_if_missing(use);\n@@ -3532,1 +3622,1 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {\n+              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar || op == Op_FlatArrayCheck)) {\n@@ -3619,1 +3709,1 @@\n-  \/\/ chains as is done in split_memory_phi() since they  will\n+  \/\/ chains as is done in split_memory_phi() since they will\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":131,"deletions":41,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-      for (int i = node->req()-1; i >= 0; --i) {\n+      for (int i = node->len()-1; i >= 0; --i) {\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -40,0 +42,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -43,0 +46,1 @@\n+#include \"opto\/narrowptrnode.hpp\"\n@@ -56,1 +60,1 @@\n-GraphKit::GraphKit(JVMState* jvms)\n+GraphKit::GraphKit(JVMState* jvms, PhaseGVN* gvn)\n@@ -59,1 +63,1 @@\n-    _gvn(*C->initial_gvn()),\n+    _gvn((gvn != NULL) ? *gvn : *C->initial_gvn()),\n@@ -62,0 +66,1 @@\n+  assert(gvn == NULL || !gvn->is_IterGVN() || gvn->is_IterGVN()->delay_transform(), \"delay transform should be enabled\");\n@@ -65,0 +70,7 @@\n+#ifdef ASSERT\n+  if (_gvn.is_IterGVN() != NULL) {\n+    assert(_gvn.is_IterGVN()->delay_transform(), \"Transformation must be delayed if IterGVN is used\");\n+    \/\/ Save the initial size of _for_igvn worklist for verification (see ~GraphKit)\n+    _worklist_size = _gvn.C->for_igvn()->size();\n+  }\n+#endif\n@@ -837,1 +849,1 @@\n-           (is_anewarray && code == Bytecodes::_multianewarray);\n+           (is_anewarray && (code == Bytecodes::_multianewarray));\n@@ -1097,0 +1109,9 @@\n+  case Bytecodes::_withfield: {\n+    bool ignored_will_link;\n+    ciField* field = method()->get_field_at_bci(bci(), ignored_will_link);\n+    int      size  = field->type()->size();\n+    inputs = size+1;\n+    depth = rsize - inputs;\n+    break;\n+  }\n+\n@@ -1179,1 +1200,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -1228,1 +1249,2 @@\n-                                  bool speculative) {\n+                                  bool speculative,\n+                                  bool is_init_check) {\n@@ -1233,0 +1255,37 @@\n+  if (value->is_InlineType()) {\n+    InlineTypeNode* vt = value->as_InlineType();\n+    null_check_common(vt->get_is_init(), T_INT, assert_null, null_control, speculative, true);\n+    if (stopped()) {\n+      return top();\n+    }\n+    if (assert_null) {\n+      \/\/ TODO 8284443 Scalarize here (this currently leads to compilation bailouts)\n+      \/\/ vt = InlineTypeNode::make_null(_gvn, vt->type()->inline_klass());\n+      \/\/ replace_in_map(value, vt);\n+      \/\/ return vt;\n+      return null();\n+    }\n+    bool do_replace_in_map = (null_control == NULL || (*null_control) == top());\n+    return cast_not_null(value, do_replace_in_map);\n+  } else if (value->is_InlineTypePtr()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    InlineTypePtrNode* vtptr = value->as_InlineTypePtr();\n+    while (vtptr->get_oop()->is_InlineTypePtr()) {\n+      vtptr = vtptr->get_oop()->as_InlineTypePtr();\n+    }\n+    null_check_common(vtptr->get_is_init(), T_INT, assert_null, null_control, speculative, true);\n+    if (stopped()) {\n+      return top();\n+    }\n+    if (assert_null) {\n+      \/\/ TODO 8284443 Scalarize here (this currently leads to compilation bailouts)\n+      \/\/ vtptr = InlineTypePtrNode::make_null(_gvn, vtptr->type()->inline_klass());\n+      \/\/ replace_in_map(value, vtptr);\n+      \/\/ return vtptr;\n+      return null();\n+    }\n+    bool do_replace_in_map = (null_control == NULL || (*null_control) == top());\n+    return cast_not_null(value, do_replace_in_map);\n+  }\n+\n@@ -1238,0 +1297,1 @@\n+    case T_PRIMITIVE_OBJECT : \/\/ fall through\n@@ -1336,1 +1396,1 @@\n-  } else if (type == T_OBJECT) {\n+  } else if (type == T_OBJECT || is_init_check) {\n@@ -1410,1 +1470,0 @@\n-\n@@ -1414,0 +1473,25 @@\n+  if (obj->is_InlineType()) {\n+    InlineTypeNode* vt = obj->clone()->as_InlineType();\n+    vt->set_is_init(_gvn);\n+    vt = _gvn.transform(vt)->as_InlineType();\n+    if (do_replace_in_map) {\n+      replace_in_map(obj, vt);\n+    }\n+    return vt;\n+  } else if (obj->is_InlineTypePtr()) {\n+    \/\/ Cast oop input instead\n+    Node* cast = cast_not_null(obj->as_InlineTypePtr()->get_oop(), do_replace_in_map);\n+    if (cast->is_top()) {\n+      \/\/ Always null\n+      return top();\n+    }\n+    \/\/ Create a new node with the casted oop input and is_init set\n+    InlineTypeBaseNode* vt = obj->clone()->as_InlineTypePtr();\n+    vt->set_oop(cast);\n+    vt->set_is_init(_gvn);\n+    vt = _gvn.transform(vt)->as_InlineTypePtr();\n+    if (do_replace_in_map) {\n+      replace_in_map(obj, vt);\n+    }\n+    return vt;\n+  }\n@@ -1540,1 +1624,2 @@\n-  if (((bt == T_OBJECT) && C->do_escape_analysis()) || C->eliminate_boxing()) {\n+\n+  if (((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && C->do_escape_analysis()) || C->eliminate_boxing()) {\n@@ -1584,1 +1669,2 @@\n-                                DecoratorSet decorators) {\n+                                DecoratorSet decorators,\n+                                bool safe_for_replace) {\n@@ -1597,0 +1683,7 @@\n+  if (val->is_InlineType()) {\n+    \/\/ Store to non-flattened field. Buffer the inline type and make sure\n+    \/\/ the store is re-executed if the allocation triggers deoptimization.\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    val = val->as_InlineType()->buffer(this, safe_for_replace);\n+  }\n@@ -1613,1 +1706,2 @@\n-                               DecoratorSet decorators) {\n+                               DecoratorSet decorators,\n+                               Node* ctl) {\n@@ -1619,1 +1713,1 @@\n-  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, obj, addr);\n+  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, obj, addr, ctl);\n@@ -1725,0 +1819,5 @@\n+  ciKlass* arytype_klass = _gvn.type(ary)->is_aryptr()->klass();\n+  if (arytype_klass != NULL && arytype_klass->is_flat_array_klass()) {\n+    ciFlatArrayKlass* vak = arytype_klass->as_flat_array_klass();\n+    shift = vak->log2_element_size();\n+  }\n@@ -1745,0 +1844,1 @@\n+  assert(elembt != T_PRIMITIVE_OBJECT, \"inline types are not supported by this method\");\n@@ -1756,6 +1856,41 @@\n-void GraphKit::set_arguments_for_java_call(CallJavaNode* call) {\n-  \/\/ Add the call arguments:\n-  uint nargs = call->method()->arg_size();\n-  for (uint i = 0; i < nargs; i++) {\n-    Node* arg = argument(i);\n-    call->init_req(i + TypeFunc::Parms, arg);\n+void GraphKit::set_arguments_for_java_call(CallJavaNode* call, bool is_late_inline) {\n+  PreserveReexecuteState preexecs(this);\n+  if (EnableValhalla) {\n+    \/\/ Make sure the call is \"re-executed\", if buffering of inline type arguments triggers deoptimization.\n+    \/\/ At this point, the call hasn't been executed yet, so we will only ever execute the call once.\n+    jvms()->set_should_reexecute(true);\n+    int arg_size = method()->get_declared_signature_at_bci(bci())->arg_size_for_bc(java_bc());\n+    inc_sp(arg_size);\n+  }\n+  \/\/ Add the call arguments\n+  const TypeTuple* domain = call->tf()->domain_sig();\n+  uint nargs = domain->cnt();\n+  int arg_num = 0;\n+  for (uint i = TypeFunc::Parms, idx = TypeFunc::Parms; i < nargs; i++) {\n+    Node* arg = argument(i-TypeFunc::Parms);\n+    const Type* t = domain->field_at(i);\n+    if (t->is_inlinetypeptr() && call->method()->is_scalarized_arg(arg_num)) {\n+      \/\/ We don't pass inline type arguments by reference but instead pass each field of the inline type\n+      if (!arg->is_InlineTypeBase()) {\n+        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n+        arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass(), t->inline_klass()->is_null_free());\n+      }\n+      InlineTypeBaseNode* vt = arg->as_InlineTypeBase();\n+      vt->pass_fields(this, call, idx, true, !t->maybe_null());\n+      \/\/ If an inline type argument is passed as fields, attach the Method* to the call site\n+      \/\/ to be able to access the extended signature later via attached_method_before_pc().\n+      \/\/ For example, see CompiledMethod::preserve_callee_argument_oops().\n+      call->set_override_symbolic_info(true);\n+      arg_num++;\n+      continue;\n+    } else if (arg->is_InlineType()) {\n+      \/\/ Pass inline type argument via oop to callee\n+      arg = arg->as_InlineType()->buffer(this);\n+      if (!is_late_inline) {\n+        arg = arg->as_InlineTypePtr()->get_oop();\n+      }\n+    }\n+    if (t != Type::HALF) {\n+      arg_num++;\n+    }\n+    call->init_req(idx++, arg);\n@@ -1799,7 +1934,0 @@\n-  \/\/ Capture the return value, if any.\n-  Node* ret;\n-  if (call->method() == NULL ||\n-      call->method()->return_type()->basic_type() == T_VOID)\n-        ret = top();\n-  else  ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-\n@@ -1818,0 +1946,15 @@\n+\n+  \/\/ Capture the return value, if any.\n+  Node* ret;\n+  if (call->method() == NULL || call->method()->return_type()->basic_type() == T_VOID) {\n+    ret = top();\n+  } else if (call->tf()->returns_inline_type_as_fields()) {\n+    \/\/ Return of multiple values (inline type fields): we create a\n+    \/\/ InlineType node, each field is a projection from the call.\n+    ciInlineKlass* vk = call->method()->return_type()->as_inline_klass();\n+    uint base_input = TypeFunc::Parms;\n+    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, call->method()->signature()->returns_null_free_inline_type());\n+  } else {\n+    ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  }\n+\n@@ -1908,2 +2051,1 @@\n-  CallProjections callprojs;\n-  call->extract_projections(&callprojs, true);\n+  CallProjections* callprojs = call->extract_projections(true);\n@@ -1918,2 +2060,2 @@\n-  if (callprojs.fallthrough_catchproj != NULL) {\n-    C->gvn_replace_by(callprojs.fallthrough_catchproj, final_ctl);\n+  if (callprojs->fallthrough_catchproj != NULL) {\n+    C->gvn_replace_by(callprojs->fallthrough_catchproj, final_ctl);\n@@ -1921,1 +2063,1 @@\n-  if (callprojs.fallthrough_memproj != NULL) {\n+  if (callprojs->fallthrough_memproj != NULL) {\n@@ -1926,1 +2068,1 @@\n-    C->gvn_replace_by(callprojs.fallthrough_memproj,   final_mem);\n+    C->gvn_replace_by(callprojs->fallthrough_memproj,   final_mem);\n@@ -1929,2 +2071,2 @@\n-  if (callprojs.fallthrough_ioproj != NULL) {\n-    C->gvn_replace_by(callprojs.fallthrough_ioproj,    final_io);\n+  if (callprojs->fallthrough_ioproj != NULL) {\n+    C->gvn_replace_by(callprojs->fallthrough_ioproj,    final_io);\n@@ -1934,2 +2076,6 @@\n-  if (callprojs.resproj != NULL && result != NULL) {\n-    C->gvn_replace_by(callprojs.resproj, result);\n+  if (callprojs->resproj[0] != NULL && result != NULL) {\n+    \/\/ If the inlined code is dead, the result projections for an inline type returned as\n+    \/\/ fields have not been replaced. They will go away once the call is replaced by TOP below.\n+    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()),\n+           \"unexpected number of results\");\n+    C->gvn_replace_by(callprojs->resproj[0], result);\n@@ -1940,2 +2086,2 @@\n-    if (callprojs.catchall_catchproj != NULL) {\n-      C->gvn_replace_by(callprojs.catchall_catchproj, C->top());\n+    if (callprojs->catchall_catchproj != NULL) {\n+      C->gvn_replace_by(callprojs->catchall_catchproj, C->top());\n@@ -1943,2 +2089,2 @@\n-    if (callprojs.catchall_memproj != NULL) {\n-      C->gvn_replace_by(callprojs.catchall_memproj,   C->top());\n+    if (callprojs->catchall_memproj != NULL) {\n+      C->gvn_replace_by(callprojs->catchall_memproj,   C->top());\n@@ -1946,2 +2092,2 @@\n-    if (callprojs.catchall_ioproj != NULL) {\n-      C->gvn_replace_by(callprojs.catchall_ioproj,    C->top());\n+    if (callprojs->catchall_ioproj != NULL) {\n+      C->gvn_replace_by(callprojs->catchall_ioproj,    C->top());\n@@ -1950,2 +2096,2 @@\n-    if (callprojs.exobj != NULL) {\n-      C->gvn_replace_by(callprojs.exobj, C->top());\n+    if (callprojs->exobj != NULL) {\n+      C->gvn_replace_by(callprojs->exobj, C->top());\n@@ -1962,2 +2108,2 @@\n-    if (callprojs.catchall_catchproj != NULL) {\n-      C->gvn_replace_by(callprojs.catchall_catchproj, ekit.control());\n+    if (callprojs->catchall_catchproj != NULL) {\n+      C->gvn_replace_by(callprojs->catchall_catchproj, ekit.control());\n@@ -1966,1 +2112,1 @@\n-    if (callprojs.catchall_memproj != NULL) {\n+    if (callprojs->catchall_memproj != NULL) {\n@@ -1968,1 +2114,1 @@\n-      C->gvn_replace_by(callprojs.catchall_memproj,   ex_mem);\n+      C->gvn_replace_by(callprojs->catchall_memproj,   ex_mem);\n@@ -1971,2 +2117,2 @@\n-    if (callprojs.catchall_ioproj != NULL) {\n-      C->gvn_replace_by(callprojs.catchall_ioproj,    ekit.i_o());\n+    if (callprojs->catchall_ioproj != NULL) {\n+      C->gvn_replace_by(callprojs->catchall_ioproj,    ekit.i_o());\n@@ -1976,2 +2122,2 @@\n-    if (callprojs.exobj != NULL) {\n-      C->gvn_replace_by(callprojs.exobj, ex_oop);\n+    if (callprojs->exobj != NULL) {\n+      C->gvn_replace_by(callprojs->exobj, ex_oop);\n@@ -1991,1 +2137,1 @@\n-  if (callprojs.fallthrough_catchproj != NULL && !final_ctl->is_top() && do_replaced_nodes) {\n+  if (callprojs->fallthrough_catchproj != NULL && !final_ctl->is_top() && do_replaced_nodes) {\n@@ -2190,1 +2336,1 @@\n-    const TypePtr* ptr = (ptr_kind == ProfileMaybeNull && current_type->speculative_maybe_null()) ? TypePtr::BOTTOM : TypePtr::NOTNULL;\n+    const TypePtr* ptr = (ptr_kind != ProfileNeverNull && current_type->speculative_maybe_null()) ? TypePtr::BOTTOM : TypePtr::NOTNULL;\n@@ -2213,1 +2359,1 @@\n-    const TypeOopPtr* spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::OffsetBot, TypeOopPtr::InstanceBot, speculative);\n+    const TypeOopPtr* spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, speculative);\n@@ -2247,2 +2393,9 @@\n-      if (!data->as_BitData()->null_seen()) {\n-        ptr_kind = ProfileNeverNull;\n+      if (java_bc() == Bytecodes::_aastore) {\n+        ciKlass* array_type = NULL;\n+        ciKlass* element_type = NULL;\n+        ProfilePtrKind element_ptr = ProfileMaybeNull;\n+        bool flat_array = true;\n+        bool null_free_array = true;\n+        method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+        exact_kls = element_type;\n+        ptr_kind = element_ptr;\n@@ -2250,7 +2403,11 @@\n-        assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n-        ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-        uint i = 0;\n-        for (; i < call->row_limit(); i++) {\n-          ciKlass* receiver = call->receiver(i);\n-          if (receiver != NULL) {\n-            break;\n+        if (!data->as_BitData()->null_seen()) {\n+          ptr_kind = ProfileNeverNull;\n+        } else {\n+          assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n+          ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n+          uint i = 0;\n+          for (; i < call->row_limit(); i++) {\n+            ciKlass* receiver = call->receiver(i);\n+            if (receiver != NULL) {\n+              break;\n+            }\n@@ -2258,0 +2415,1 @@\n+          ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2259,1 +2417,0 @@\n-        ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2278,1 +2435,1 @@\n-  int             nargs = tf->domain()->cnt() - TypeFunc::Parms;\n+  int             nargs = tf->domain_sig()->cnt() - TypeFunc::Parms;\n@@ -2281,1 +2438,1 @@\n-    const Type *targ = tf->domain()->field_at(j + TypeFunc::Parms);\n+    const Type *targ = tf->domain_sig()->field_at(j + TypeFunc::Parms);\n@@ -2335,1 +2492,1 @@\n-    int             nargs = tf->domain()->cnt() - TypeFunc::Parms;\n+    int             nargs = tf->domain_sig()->cnt() - TypeFunc::Parms;\n@@ -2337,1 +2494,1 @@\n-      const Type *targ = tf->domain()->field_at(j + TypeFunc::Parms);\n+      const Type *targ = tf->domain_sig()->field_at(j + TypeFunc::Parms);\n@@ -2486,1 +2643,1 @@\n-    uint num_bits = call_type->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    uint num_bits = call_type->range_sig()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n@@ -2566,0 +2723,1 @@\n+\n@@ -2819,0 +2977,4 @@\n+  const Type* sub_t = _gvn.type(obj_or_subklass);\n+  if (sub_t->isa_inlinetype()) {\n+    obj_or_subklass = makecon(TypeKlassPtr::make(sub_t->inline_klass()));\n+  }\n@@ -2825,1 +2987,1 @@\n-    if (!_gvn.type(obj_or_subklass)->isa_klassptr()) {\n+    if (!sub_t->isa_klassptr() && !sub_t->isa_inlinetype()) {\n@@ -2828,1 +2990,0 @@\n-\n@@ -2843,2 +3004,1 @@\n-                                    float prob,\n-                                    Node* *casted_receiver) {\n+                                    float prob, Node* *casted_receiver) {\n@@ -2846,1 +3006,12 @@\n-\n+  Node* fail = top();\n+  const Type* rec_t = _gvn.type(receiver);\n+  if (rec_t->isa_inlinetype()) {\n+    if (klass->equals(rec_t->inline_klass())) {\n+      (*casted_receiver) = receiver; \/\/ Always passes\n+    } else {\n+      (*casted_receiver) = top();    \/\/ Always fails\n+      fail = control();\n+      set_control(top());\n+    }\n+    return fail;\n+  }\n@@ -2849,6 +3020,1 @@\n-  Node* want_klass = makecon(tklass);\n-  Node* cmp = _gvn.transform(new CmpPNode(recv_klass, want_klass));\n-  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n-  IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);\n-  set_control( _gvn.transform(new IfTrueNode (iff)));\n-  Node* fail = _gvn.transform(new IfFalseNode(iff));\n+  fail = type_check(recv_klass, tklass, prob);\n@@ -2858,2 +3024,2 @@\n-    const TypeOopPtr* recvx_type = tklass->as_instance_type();\n-    assert(recvx_type->klass_is_exact(), \"\");\n+    const TypeOopPtr* recv_xtype = tklass->as_instance_type();\n+    assert(recv_xtype->klass_is_exact(), \"\");\n@@ -2861,1 +3027,1 @@\n-    if (!receiver_type->higher_equal(recvx_type)) { \/\/ ignore redundant casts\n+    if (!receiver_type->higher_equal(recv_xtype)) { \/\/ ignore redundant casts\n@@ -2864,2 +3030,7 @@\n-      Node* cast = new CheckCastPPNode(control(), receiver, recvx_type);\n-      (*casted_receiver) = _gvn.transform(cast);\n+      Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);\n+      Node* res = _gvn.transform(cast);\n+      if (recv_xtype->is_inlinetypeptr()) {\n+        assert(!gvn().type(res)->maybe_null(), \"receiver should never be null\");\n+        res = InlineTypeNode::make_from_oop(this, res, recv_xtype->inline_klass())->as_InlineTypeBase()->as_ptr(&gvn());\n+      }\n+      (*casted_receiver) = res;\n@@ -2873,0 +3044,11 @@\n+Node* GraphKit::type_check(Node* recv_klass, const TypeKlassPtr* tklass,\n+                           float prob) {\n+  Node* want_klass = makecon(tklass);\n+  Node* cmp = _gvn.transform(new CmpPNode(recv_klass, want_klass));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);\n+  set_control(_gvn.transform(new IfTrueNode (iff)));\n+  Node* fail = _gvn.transform(new IfFalseNode(iff));\n+  return fail;\n+}\n+\n@@ -2885,1 +3067,1 @@\n-    if (!receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n+    if (receiver_type != NULL && !receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n@@ -2917,0 +3099,3 @@\n+    if (java_bc() == Bytecodes::_aastore) {\n+      return ((ciArrayLoadStoreData*)data->as_ArrayLoadStoreData())->element()->ptr_kind() == ProfileNeverNull;\n+    }\n@@ -2996,1 +3181,14 @@\n-  ciKlass* exact_kls = spec_klass == NULL ? profile_has_unique_klass() : spec_klass;\n+  ciKlass* exact_kls = spec_klass;\n+  if (exact_kls == NULL) {\n+    if (java_bc() == Bytecodes::_aastore) {\n+      ciKlass* array_type = NULL;\n+      ciKlass* element_type = NULL;\n+      ProfilePtrKind element_ptr = ProfileMaybeNull;\n+      bool flat_array = true;\n+      bool null_free_array = true;\n+      method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      exact_kls = element_type;\n+    } else {\n+      exact_kls = profile_has_unique_klass();\n+    }\n+  }\n@@ -3101,0 +3299,1 @@\n+  bool is_value = obj->is_InlineType();\n@@ -3104,0 +3303,5 @@\n+  if (is_value) {\n+    \/\/ TODO 8284443 Enable this\n+    safe_for_replace = false;\n+    never_see_null = false;\n+  }\n@@ -3122,7 +3326,9 @@\n-  bool known_statically = false;\n-  if (_gvn.type(superklass)->singleton()) {\n-    const TypeKlassPtr* superk = _gvn.type(superklass)->is_klassptr();\n-    const TypeKlassPtr* subk = _gvn.type(obj)->is_oopptr()->as_klass_type();\n-    if (subk->is_loaded()) {\n-      int static_res = C->static_subtype_check(superk, subk);\n-      known_statically = (static_res == Compile::SSC_always_true || static_res == Compile::SSC_always_false);\n+  if (!is_value) {\n+    bool known_statically = false;\n+    if (_gvn.type(superklass)->singleton()) {\n+      const TypeKlassPtr* superk = _gvn.type(superklass)->is_klassptr();\n+      const TypeKlassPtr* subk = _gvn.type(obj)->is_oopptr()->as_klass_type();\n+      if (subk != NULL && subk->is_loaded()) {\n+        int static_res = C->static_subtype_check(superk, subk);\n+        known_statically = (static_res == Compile::SSC_always_true || static_res == Compile::SSC_always_false);\n+      }\n@@ -3130,14 +3336,15 @@\n-  }\n-  if (!known_statically) {\n-    const TypeOopPtr* obj_type = _gvn.type(obj)->is_oopptr();\n-    \/\/ We may not have profiling here or it may not help us. If we\n-    \/\/ have a speculative type use it to perform an exact cast.\n-    ciKlass* spec_obj_type = obj_type->speculative_type();\n-    if (spec_obj_type != NULL || (ProfileDynamicTypes && data != NULL)) {\n-      Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);\n-      if (stopped()) {            \/\/ Profile disagrees with this path.\n-        set_control(null_ctl);    \/\/ Null is the only remaining possibility.\n-        return intcon(0);\n-      }\n-      if (cast_obj != NULL) {\n-        not_null_obj = cast_obj;\n+    if (!known_statically) {\n+      const TypeOopPtr* obj_type = _gvn.type(obj)->is_oopptr();\n+      \/\/ We may not have profiling here or it may not help us. If we\n+      \/\/ have a speculative type use it to perform an exact cast.\n+      ciKlass* spec_obj_type = obj_type->speculative_type();\n+      if (spec_obj_type != NULL || (ProfileDynamicTypes && data != NULL)) {\n+        Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);\n+        if (stopped()) {            \/\/ Profile disagrees with this path.\n+          set_control(null_ctl);    \/\/ Null is the only remaining possibility.\n+          return intcon(0);\n+        }\n+        if (cast_obj != NULL) {\n+          not_null_obj = cast_obj;\n+          is_value = not_null_obj->is_InlineType();\n+        }\n@@ -3167,1 +3374,1 @@\n-  if (safe_for_replace) {\n+  if (safe_for_replace && !is_value) {\n@@ -3182,2 +3389,1 @@\n-Node* GraphKit::gen_checkcast(Node *obj, Node* superklass,\n-                              Node* *failure_control) {\n+Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control, bool null_free) {\n@@ -3185,2 +3391,5 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr();\n-  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr* tk = _gvn.type(superklass)->is_klassptr();\n+  const TypeOopPtr* toop = tk->cast_to_exactness(false)->as_instance_type();\n+  bool safe_for_replace = (failure_control == NULL);\n+  bool from_inline = obj->is_InlineType();\n+  assert(!null_free || toop->is_inlinetypeptr(), \"must be an inline type pointer\");\n@@ -3195,3 +3404,10 @@\n-    const TypeOopPtr* objtp = _gvn.type(obj)->isa_oopptr();\n-    if (objtp != NULL) {\n-      switch (C->static_subtype_check(tk, objtp->as_klass_type())) {\n+    const TypeKlassPtr* kptr = NULL;\n+    const Type* t = _gvn.type(obj);\n+    if (t->isa_oop_ptr()) {\n+      kptr = t->is_oopptr()->as_klass_type();\n+    } else if (obj->is_InlineTypeBase()) {\n+      ciInlineKlass* vk = t->inline_klass();\n+      kptr = TypeInstKlassPtr::make(TypePtr::NotNull, vk, Type::Offset(0), vk->flatten_array());\n+    }\n+    if (kptr != NULL) {\n+      switch (C->static_subtype_check(tk, kptr)) {\n@@ -3202,1 +3418,9 @@\n-        return record_profiled_receiver_for_speculation(obj);\n+        if (!from_inline) {\n+          obj = record_profiled_receiver_for_speculation(obj);\n+        }\n+        if (null_free) {\n+          assert(safe_for_replace, \"must be\");\n+          obj = null_check(obj);\n+        }\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineTypeBase(), \"should have been scalarized\");\n+        return obj;\n@@ -3204,0 +3428,4 @@\n+        if (null_free) {\n+          assert(safe_for_replace, \"must be\");\n+          obj = null_check(obj);\n+        }\n@@ -3205,2 +3433,1 @@\n-        \/\/ A non-null value will always produce an exception.\n-        if (!objtp->maybe_null()) {\n+        if (t->isa_oopptr() != NULL && !t->is_oopptr()->maybe_null()) {\n@@ -3223,1 +3450,0 @@\n-  bool safe_for_replace = false;\n@@ -3228,2 +3454,3 @@\n-    data = method()->method_data()->bci_to_data(bci());\n-    safe_for_replace = true;\n+    if (method()->method_data()->is_mature()) {\n+      data = method()->method_data()->bci_to_data(bci());\n+    }\n@@ -3236,0 +3463,3 @@\n+  _gvn.set_type(region, Type::CONTROL);\n+  _gvn.set_type(phi, toop);\n+\n@@ -3245,1 +3475,10 @@\n-  Node* not_null_obj = null_check_oop(obj, &null_ctl, never_see_null, safe_for_replace, speculative_not_null);\n+  Node* not_null_obj = NULL;\n+  if (null_free) {\n+    assert(safe_for_replace, \"must be\");\n+    not_null_obj = null_check(obj);\n+  } else if (from_inline) {\n+    \/\/ TODO 8284443 obj can be null and null should pass\n+    not_null_obj = obj;\n+  } else {\n+    not_null_obj = null_check_oop(obj, &null_ctl, never_see_null, safe_for_replace, speculative_not_null);\n+  }\n@@ -3250,0 +3489,3 @@\n+    if (toop->is_inlinetypeptr()) {\n+      return InlineTypePtrNode::make_null(_gvn, toop->inline_klass());\n+    }\n@@ -3263,1 +3505,1 @@\n-  if (tk->klass_is_exact()) {\n+  if (!from_inline && tk->klass_is_exact()) {\n@@ -3285,1 +3527,1 @@\n-    Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass );\n+    Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);\n@@ -3288,1 +3530,1 @@\n-    cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));\n+    cast_obj = from_inline ? not_null_obj : _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));\n@@ -3294,0 +3536,6 @@\n+        Node* obj_klass = NULL;\n+        if (not_null_obj->is_InlineTypeBase()) {\n+          obj_klass = makecon(TypeKlassPtr::make(_gvn.type(not_null_obj)->inline_klass()));\n+        } else {\n+          obj_klass = load_object_klass(not_null_obj);\n+        }\n@@ -3324,1 +3572,125 @@\n-  return record_profiled_receiver_for_speculation(res);\n+  bool not_inline = !toop->can_be_inline_type();\n+  bool not_flattened = !UseFlatArray || not_inline || (toop->is_inlinetypeptr() && !toop->inline_klass()->flatten_array());\n+  if (EnableValhalla && not_flattened) {\n+    \/\/ Check if obj has been loaded from an array\n+    obj = obj->isa_DecodeN() ? obj->in(1) : obj;\n+    Node* array = NULL;\n+    if (obj->isa_Load()) {\n+      Node* address = obj->in(MemNode::Address);\n+      if (address->isa_AddP()) {\n+        array = address->as_AddP()->in(AddPNode::Base);\n+      }\n+    } else if (obj->is_Phi()) {\n+      Node* region = obj->in(0);\n+      \/\/ TODO make this more robust (see JDK-8231346)\n+      if (region->req() == 3 && region->in(2) != NULL && region->in(2)->in(0) != NULL) {\n+        IfNode* iff = region->in(2)->in(0)->isa_If();\n+        if (iff != NULL) {\n+          iff->is_flat_array_check(&_gvn, &array);\n+        }\n+      }\n+    }\n+    if (array != NULL) {\n+      const TypeAryPtr* ary_t = _gvn.type(array)->isa_aryptr();\n+      if (ary_t != NULL) {\n+        if (!ary_t->is_not_null_free() && not_inline) {\n+          \/\/ Casting array element to a non-inline-type, mark array as not null-free.\n+          Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t->cast_to_not_null_free()));\n+          replace_in_map(array, cast);\n+        } else if (!ary_t->is_not_flat()) {\n+          \/\/ Casting array element to a non-flattened type, mark array as not flat.\n+          Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t->cast_to_not_flat()));\n+          replace_in_map(array, cast);\n+        }\n+      }\n+    }\n+  }\n+\n+  if (!stopped() && !res->is_InlineTypeBase()) {\n+    res = record_profiled_receiver_for_speculation(res);\n+    if (toop->is_inlinetypeptr()) {\n+      Node* vt = InlineTypeNode::make_from_oop(this, res, toop->inline_klass(), !gvn().type(res)->maybe_null());\n+      res = vt;\n+      if (safe_for_replace) {\n+        if (vt->is_InlineType() && C->inlining_incrementally()) {\n+          vt = vt->as_InlineType()->as_ptr(&_gvn);\n+        }\n+        replace_in_map(obj, vt);\n+        replace_in_map(not_null_obj, vt);\n+        replace_in_map(res, vt);\n+      }\n+    }\n+  }\n+  return res;\n+}\n+\n+Node* GraphKit::inline_type_test(Node* obj, bool is_inline) {\n+  Node* mark_adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n+  Node* mark = make_load(NULL, mark_adr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  Node* mask = MakeConX(markWord::inline_type_pattern);\n+  Node* masked = _gvn.transform(new AndXNode(mark, mask));\n+  Node* cmp = _gvn.transform(new CmpXNode(masked, mask));\n+  return _gvn.transform(new BoolNode(cmp, is_inline ? BoolTest::eq : BoolTest::ne));\n+}\n+\n+Node* GraphKit::is_val_mirror(Node* mirror) {\n+  Node* p = basic_plus_adr(mirror, java_lang_Class::secondary_mirror_offset());\n+  Node* secondary_mirror = access_load_at(mirror, p, _gvn.type(p)->is_ptr(), TypeInstPtr::MIRROR->cast_to_ptr_type(TypePtr::BotPTR), T_OBJECT, IN_HEAP);\n+  Node* cmp = _gvn.transform(new CmpPNode(mirror, secondary_mirror));\n+  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+}\n+\n+Node* GraphKit::array_lh_test(Node* klass, jint mask, jint val, bool eq) {\n+  Node* lh_adr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+  \/\/ Make sure to use immutable memory here to enable hoisting the check out of loops\n+  Node* lh_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lh_adr, lh_adr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* masked = _gvn.transform(new AndINode(lh_val, intcon(mask)));\n+  Node* cmp = _gvn.transform(new CmpINode(masked, intcon(val)));\n+  return _gvn.transform(new BoolNode(cmp, eq ? BoolTest::eq : BoolTest::ne));\n+}\n+\n+Node* GraphKit::flat_array_test(Node* array_or_klass, bool flat) {\n+  \/\/ We can't use immutable memory here because the mark word is mutable.\n+  \/\/ PhaseIdealLoop::move_flat_array_check_out_of_loop will make sure the\n+  \/\/ check is moved out of loops (mainly to enable loop unswitching).\n+  Node* mem = UseArrayMarkWordCheck ? memory(Compile::AliasIdxRaw) : immutable_memory();\n+  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, mem, array_or_klass));\n+  record_for_igvn(cmp); \/\/ Give it a chance to be optimized out by IGVN\n+  return _gvn.transform(new BoolNode(cmp, flat ? BoolTest::eq : BoolTest::ne));\n+}\n+\n+Node* GraphKit::null_free_array_test(Node* klass, bool null_free) {\n+  return array_lh_test(klass, Klass::_lh_null_free_array_bit_inplace, 0, !null_free);\n+}\n+\n+\/\/ Deoptimize if 'ary' is a null-free inline type array and 'val' is null\n+Node* GraphKit::inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {\n+  RegionNode* region = new RegionNode(3);\n+  Node* null_ctl = top();\n+  null_check_oop(val, &null_ctl);\n+  if (null_ctl != top()) {\n+    PreserveJVMState pjvms(this);\n+    set_control(null_ctl);\n+    {\n+      \/\/ Deoptimize if null-free array\n+      BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n+      inc_sp(nargs);\n+      uncommon_trap(Deoptimization::Reason_null_check,\n+                    Deoptimization::Action_none);\n+    }\n+    region->init_req(1, control());\n+  }\n+  region->init_req(2, control());\n+  set_control(_gvn.transform(region));\n+  record_for_igvn(region);\n+  if (_gvn.type(val) == TypePtr::NULL_PTR) {\n+    \/\/ Since we were just successfully storing null, the array can't be null free.\n+    const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+    ary_t = ary_t->cast_to_not_null_free();\n+    Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n+    if (safe_for_replace) {\n+      replace_in_map(ary, cast);\n+    }\n+    ary = cast;\n+  }\n+  return ary;\n@@ -3392,0 +3764,1 @@\n+\n@@ -3460,0 +3833,1 @@\n+  assert(!obj->is_InlineTypeBase(), \"should not unlock on inline type\");\n@@ -3499,2 +3873,9 @@\n-    bool    xklass = inst_klass->klass_is_exact();\n-    if (xklass || inst_klass->isa_aryklassptr()) {\n+    bool xklass = inst_klass->klass_is_exact();\n+    bool can_be_flattened = false;\n+    ciKlass* klass = inst_klass->klass();\n+    if (UseFlatArray && !xklass && klass->is_obj_array_klass() && !klass->as_obj_array_klass()->is_elem_null_free()) {\n+      \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue. Don't constant fold.\n+      ciKlass* elem = klass->as_obj_array_klass()->element_klass();\n+      can_be_flattened = elem->can_be_inline_klass() && (!elem->is_inlinetype() || elem->flatten_array());\n+    }\n+    if (!can_be_flattened && (xklass || klass->is_array_klass())) {\n@@ -3502,1 +3883,3 @@\n-      if (inst_klass->isa_aryklassptr()) {\n+      if (klass->is_flat_array_klass()) {\n+        lhelper = klass->layout_helper();\n+      } else if (inst_klass->isa_aryklassptr()) {\n@@ -3532,1 +3915,3 @@\n-  kit.set_memory(init_out_raw, alias_idx);\n+  if (init_out_raw != NULL) {\n+    kit.set_memory(init_out_raw, alias_idx);\n+  }\n@@ -3571,0 +3956,1 @@\n+    _gvn.set_type(minit_in, Type::MEMORY);\n@@ -3578,3 +3964,29 @@\n-      const TypePtr* telemref = oop_type->add_offset(Type::OffsetBot);\n-      int            elemidx  = C->get_alias_index(telemref);\n-      hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      const TypeAryPtr* arytype = oop_type->is_aryptr();\n+      if (arytype->klass()->is_flat_array_klass()) {\n+        \/\/ Initially all flattened array accesses share a single slice\n+        \/\/ but that changes after parsing. Prepare the memory graph so\n+        \/\/ it can optimize flattened array accesses properly once they\n+        \/\/ don't share a single slice.\n+        assert(C->flattened_accesses_share_alias(), \"should be set at parse time\");\n+        C->set_flattened_accesses_share_alias(false);\n+        ciFlatArrayKlass* vak = arytype->klass()->as_flat_array_klass();\n+        ciInlineKlass* vk = vak->element_klass()->as_inline_klass();\n+        for (int i = 0, len = vk->nof_nonstatic_fields(); i < len; i++) {\n+          ciField* field = vk->nonstatic_field_at(i);\n+          if (field->offset() >= TrackedInitializationLimit * HeapWordSize)\n+            continue;  \/\/ do not bother to track really large numbers of fields\n+          int off_in_vt = field->offset() - vk->first_field_offset();\n+          const TypePtr* adr_type = arytype->with_field_offset(off_in_vt)->add_offset(Type::OffsetBot);\n+          int fieldidx = C->get_alias_index(adr_type, true);\n+          \/\/ Pass NULL for init_out. Having per flat array element field memory edges as uses of the Initialize node\n+          \/\/ can result in per flat array field Phis to be created which confuses the logic of\n+          \/\/ Compile::adjust_flattened_array_access_aliases().\n+          hook_memory_on_init(*this, fieldidx, minit_in, NULL);\n+        }\n+        C->set_flattened_accesses_share_alias(true);\n+        hook_memory_on_init(*this, C->get_alias_index(TypeAryPtr::INLINES), minit_in, minit_out);\n+      } else {\n+        const TypePtr* telemref = oop_type->add_offset(Type::OffsetBot);\n+        int            elemidx  = C->get_alias_index(telemref);\n+        hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      }\n@@ -3582,0 +3994,1 @@\n+      set_memory(minit_out, C->get_alias_index(oop_type)); \/\/ mark word\n@@ -3632,1 +4045,2 @@\n-                             bool deoptimize_on_exception) {\n+                             bool deoptimize_on_exception,\n+                             InlineTypeBaseNode* inline_type_node) {\n@@ -3639,1 +4053,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  bool  layout_is_con = (layout_val == NULL);\n@@ -3690,1 +4104,1 @@\n-  \/\/ since GC and deoptimization can happened.\n+  \/\/ since GC and deoptimization can happen.\n@@ -3697,1 +4111,1 @@\n-                                         initial_slow_test);\n+                                         initial_slow_test, inline_type_node);\n@@ -3703,1 +4117,1 @@\n-\/\/ helper for both newarray and anewarray\n+\/\/ helper for newarray and anewarray\n@@ -3713,1 +4127,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  bool  layout_is_con = (layout_val == NULL);\n@@ -3743,1 +4157,1 @@\n-    fast_size_limit <<= (LogBytesPerLong - log2_esize);\n+    fast_size_limit <<= MAX2(LogBytesPerLong - log2_esize, 0);\n@@ -3761,1 +4175,1 @@\n-    BasicType etype  = Klass::layout_helper_element_type(layout_con);\n+    bool is_flat_array = Klass::layout_helper_is_flatArray(layout_con);\n@@ -3764,1 +4178,1 @@\n-    assert((hsize & right_n_bits(eshift)) == 0, \"hsize is pre-rounded\");\n+    assert(is_flat_array || (hsize & right_n_bits(eshift)) == 0, \"hsize is pre-rounded\");\n@@ -3848,1 +4262,1 @@\n-  \/\/ since GC and deoptimization can happened.\n+  \/\/ since GC and deoptimization can happen.\n@@ -3857,1 +4271,2 @@\n-  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n+  const TypeKlassPtr* ary_klass = _gvn.type(klass_node)->isa_klassptr();\n+  const TypeOopPtr* ary_type = ary_klass->as_instance_type();\n@@ -3866,0 +4281,60 @@\n+  const TypeAryPtr* ary_ptr = ary_type->isa_aryptr();\n+\n+  \/\/ Inline type array variants:\n+  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue\")\n+  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue\")\n+  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n+  \/\/ Check if array is a null-free, non-flattened inline type array\n+  \/\/ that needs to be initialized with the default inline type.\n+  Node* default_value = NULL;\n+  Node* raw_default_value = NULL;\n+  if (ary_ptr != NULL && ary_ptr->klass_is_exact()) {\n+    \/\/ Array type is known\n+    if (ary_ptr->klass()->as_array_klass()->is_elem_null_free()) {\n+      ciInlineKlass* vk = ary_ptr->klass()->as_array_klass()->element_klass()->as_inline_klass();\n+      if (!vk->flatten_array()) {\n+        default_value = InlineTypeNode::default_oop(gvn(), vk);\n+      }\n+    }\n+  } else if (ary_klass->klass()->can_be_inline_array_klass()) {\n+    \/\/ Array type is not known, add runtime checks\n+    assert(!ary_klass->klass_is_exact(), \"unexpected exact type\");\n+    Node* r = new RegionNode(3);\n+    default_value = new PhiNode(r, TypeInstPtr::BOTTOM);\n+\n+    Node* bol = array_lh_test(klass_node, Klass::_lh_array_tag_flat_value_bit_inplace | Klass::_lh_null_free_array_bit_inplace, Klass::_lh_null_free_array_bit_inplace);\n+    IfNode* iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+    \/\/ Null-free, non-flattened inline type array, initialize with the default value\n+    set_control(_gvn.transform(new IfTrueNode(iff)));\n+    Node* p = basic_plus_adr(klass_node, in_bytes(ArrayKlass::element_klass_offset()));\n+    Node* eklass = _gvn.transform(LoadKlassNode::make(_gvn, control(), immutable_memory(), p, TypeInstPtr::KLASS));\n+    Node* adr_fixed_block_addr = basic_plus_adr(eklass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    Node* adr_fixed_block = make_load(control(), adr_fixed_block_addr, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+    Node* default_value_offset_addr = basic_plus_adr(adr_fixed_block, in_bytes(InlineKlass::default_value_offset_offset()));\n+    Node* default_value_offset = make_load(control(), default_value_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+    Node* elem_mirror = load_mirror_from_klass(eklass);\n+    Node* default_value_addr = basic_plus_adr(elem_mirror, ConvI2X(default_value_offset));\n+    Node* val = access_load_at(elem_mirror, default_value_addr, TypeInstPtr::MIRROR, TypeInstPtr::NOTNULL, T_OBJECT, IN_HEAP);\n+    r->init_req(1, control());\n+    default_value->init_req(1, val);\n+\n+    \/\/ Otherwise initialize with all zero\n+    r->init_req(2, _gvn.transform(new IfFalseNode(iff)));\n+    default_value->init_req(2, null());\n+\n+    set_control(_gvn.transform(r));\n+    default_value = _gvn.transform(default_value);\n+  }\n+  if (default_value != NULL) {\n+    if (UseCompressedOops) {\n+      \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n+      default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n+      Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n+      Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n+      raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n+    } else {\n+      raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n+    }\n+  }\n+\n@@ -3867,6 +4342,6 @@\n-  AllocateArrayNode* alloc\n-    = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),\n-                            control(), mem, i_o(),\n-                            size, klass_node,\n-                            initial_slow_test,\n-                            length, valid_length_test);\n+  AllocateArrayNode* alloc = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),\n+                                                   control(), mem, i_o(),\n+                                                   size, klass_node,\n+                                                   initial_slow_test,\n+                                                   length, valid_length_test,\n+                                                   default_value, raw_default_value);\n@@ -4027,1 +4502,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, NULL, Type::Offset(0));\n@@ -4030,2 +4505,2 @@\n-                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS),\n-                                                  ciTypeArrayKlass::make(T_BYTE), true, 0);\n+                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, true, true),\n+                                                  ciTypeArrayKlass::make(T_BYTE), true, Type::Offset(0));\n@@ -4044,1 +4519,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, NULL, Type::Offset(0));\n@@ -4056,1 +4531,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, NULL, Type::Offset(0));\n@@ -4066,1 +4541,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, NULL, Type::Offset(0));\n@@ -4179,1 +4654,7 @@\n-    return makecon(con_type);\n+    Node* con = makecon(con_type);\n+    if (field->type()->is_inlinetype()) {\n+      con = InlineTypeNode::make_from_oop(this, con, field->type()->as_inline_klass(), field->is_null_free());\n+    } else if (con_type->is_inlinetypeptr()) {\n+      con = InlineTypeNode::make_from_oop(this, con, con_type->inline_klass(), field->is_null_free());\n+    }\n+    return con;\n@@ -4183,0 +4664,9 @@\n+\n+\/\/---------------------------load_mirror_from_klass----------------------------\n+\/\/ Given a klass oop, load its java mirror (a java.lang.Class oop).\n+Node* GraphKit::load_mirror_from_klass(Node* klass) {\n+  Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));\n+  Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  \/\/ mirror = ((OopHandle)mirror)->resolve();\n+  return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":647,"deletions":157,"binary":false,"changes":804,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -69,0 +70,3 @@\n+#ifdef ASSERT\n+  uint              _worklist_size;\n+#endif\n@@ -81,1 +85,1 @@\n-  GraphKit(JVMState* jvms);     \/\/ the JVM state on which to operate\n+  GraphKit(JVMState* jvms, PhaseGVN* gvn = NULL);     \/\/ the JVM state on which to operate\n@@ -86,0 +90,5 @@\n+    \/\/ During incremental inlining, the Node_Array of the C->for_igvn() worklist and the IGVN\n+    \/\/ worklist are shared but the _in_worklist VectorSet is not. To avoid inconsistencies,\n+    \/\/ we should not add nodes to the _for_igvn worklist when using IGVN for the GraphKit.\n+    assert((_gvn.is_IterGVN() == NULL) || (_gvn.C->for_igvn()->size() == _worklist_size),\n+           \"GraphKit should not modify _for_igvn worklist after parsing\");\n@@ -96,1 +105,1 @@\n-  void record_for_igvn(Node* n) const { C->record_for_igvn(n); }  \/\/ delegate to Compile\n+  void record_for_igvn(Node* n) const { _gvn.record_for_igvn(n); }\n@@ -357,1 +366,2 @@\n-                          bool speculative = false);\n+                          bool speculative = false,\n+                          bool is_init_check = false);\n@@ -362,1 +372,0 @@\n-    assert(argument(0)->bottom_type()->isa_ptr(), \"must be\");\n@@ -597,1 +606,2 @@\n-                        DecoratorSet decorators);\n+                        DecoratorSet decorators,\n+                        bool safe_for_replace = true);\n@@ -604,1 +614,2 @@\n-                       DecoratorSet decorators);\n+                       DecoratorSet decorators,\n+                       Node* ctl = NULL);\n@@ -682,1 +693,1 @@\n-  Node* null_check_receiver_before_call(ciMethod* callee) {\n+  Node* null_check_receiver_before_call(ciMethod* callee, bool replace_value = true) {\n@@ -690,0 +701,2 @@\n+    \/\/ TODO Remove this code once InlineTypeNodes are replaced by InlineTypePtrNodes\n+    set_argument(0, n);\n@@ -691,0 +704,14 @@\n+    \/\/ Scalarize inline type receiver\n+    const Type* recv_type = gvn().type(n);\n+    if (recv_type->is_inlinetypeptr()) {\n+      assert(!recv_type->maybe_null(), \"should never be null\");\n+      Node* vt = InlineTypeNode::make_from_oop(this, n, recv_type->inline_klass());\n+      set_argument(0, vt);\n+      if (replace_value && is_Parse()) {\n+        \/\/ Only replace in map if we are not incrementally inlining because we\n+        \/\/ share a map with the caller which might expect the inline type as oop.\n+        assert(!Compile::current()->inlining_incrementally(), \"sanity\");\n+        replace_in_map(n, vt);\n+      }\n+      n = vt;\n+    }\n@@ -696,1 +723,1 @@\n-  void  set_arguments_for_java_call(CallJavaNode* call);\n+  void  set_arguments_for_java_call(CallJavaNode* call, bool is_late_inline = false);\n@@ -835,2 +862,9 @@\n-  Node* gen_checkcast( Node *subobj, Node* superkls,\n-                       Node* *failure_control = NULL );\n+  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL, bool null_free = false);\n+\n+  \/\/ Inline types\n+  Node* inline_type_test(Node* obj, bool is_inline = true);\n+  Node* is_val_mirror(Node* mirror);\n+  Node* array_lh_test(Node* kls, jint mask, jint val, bool eq = true);\n+  Node* flat_array_test(Node* array_or_klass, bool flat = true);\n+  Node* null_free_array_test(Node* klass, bool null_free = true);\n+  Node* inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace = false);\n@@ -845,0 +879,1 @@\n+  Node* type_check(Node* recv_klass, const TypeKlassPtr* tklass, float prob);\n@@ -858,1 +893,2 @@\n-                     bool deoptimize_on_exception = false);\n+                     bool deoptimize_on_exception = false,\n+                     InlineTypeBaseNode* inline_type_node = NULL);\n@@ -895,0 +931,1 @@\n+  Node* load_mirror_from_klass(Node* klass);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  assert(!_gvn.is_IterGVN(), \"IdealKit can't be used during Optimize phase\");\n@@ -83,1 +82,0 @@\n-\n@@ -87,0 +85,4 @@\n+  if_then(bol, prob, cnt, push_new_state);\n+}\n+\n+void IdealKit::if_then(Node* bol, float prob, float cnt, bool push_new_state) {\n@@ -299,1 +301,1 @@\n-    C->record_for_igvn(n);\n+    gvn().record_for_igvn(n);\n@@ -308,1 +310,1 @@\n-  C->record_for_igvn(n);\n+  gvn().record_for_igvn(n);\n@@ -527,2 +529,2 @@\n-  if (slow_call_type->range()->cnt() > TypeFunc::Parms) {\n-    assert(slow_call_type->range()->cnt() == TypeFunc::Parms+1, \"only one return value\");\n+  if (slow_call_type->range_sig()->cnt() > TypeFunc::Parms) {\n+    assert(slow_call_type->range_sig()->cnt() == TypeFunc::Parms+1, \"only one return value\");\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1234,0 +1234,17 @@\n+\/\/ Returns true if this IfNode belongs to a flat array check\n+\/\/ and returns the corresponding array in the 'array' parameter.\n+bool IfNode::is_flat_array_check(PhaseTransform* phase, Node** array) {\n+  Node* bol = in(1);\n+  if (!bol->is_Bool()) {\n+    return false;\n+  }\n+  Node* cmp = bol->in(1);\n+  if (cmp->isa_FlatArrayCheck()) {\n+    if (array != NULL) {\n+      *array = cmp->in(FlatArrayCheckNode::ArrayOrKlass);\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1181 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"opto\/addnode.hpp\"\n+#include \"opto\/castnode.hpp\"\n+#include \"opto\/graphKit.hpp\"\n+#include \"opto\/inlinetypenode.hpp\"\n+#include \"opto\/rootnode.hpp\"\n+#include \"opto\/phaseX.hpp\"\n+\n+\/\/ Clones the inline type to handle control flow merges involving multiple inline types.\n+\/\/ The inputs are replaced by PhiNodes to represent the merged values for the given region.\n+InlineTypeBaseNode* InlineTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init) {\n+  InlineTypeBaseNode* vt = clone()->as_InlineTypeBase();\n+  if (vt->is_InlineTypePtr()) {\n+    \/\/ Use nullable type\n+    const Type* t = Type::get_const_type(inline_klass());\n+    gvn->set_type(vt, t);\n+    vt->as_InlineTypePtr()->set_type(t);\n+  }\n+\n+  \/\/ Create a PhiNode for merging the oop values\n+  const Type* phi_type = Type::get_const_type(inline_klass());\n+  PhiNode* oop = PhiNode::make(region, vt->get_oop(), phi_type);\n+  gvn->set_type(oop, phi_type);\n+  gvn->record_for_igvn(oop);\n+  vt->set_oop(oop);\n+\n+  \/\/ Create a PhiNode for merging the is_init values\n+  Node* is_init_node;\n+  if (is_init) {\n+    is_init_node = gvn->intcon(1);\n+  } else {\n+    phi_type = Type::get_const_basic_type(T_BOOLEAN);\n+    is_init_node = PhiNode::make(region, vt->get_is_init(), phi_type);\n+    gvn->set_type(is_init_node, phi_type);\n+    gvn->record_for_igvn(is_init_node);\n+  }\n+  vt->set_req(IsInit, is_init_node);\n+\n+  \/\/ Create a PhiNode each for merging the field values\n+  for (uint i = 0; i < vt->field_count(); ++i) {\n+    ciType* type = vt->field_type(i);\n+    Node*  value = vt->field_value(i);\n+    if (value->is_InlineTypeBase()) {\n+      \/\/ Handle inline type fields recursively\n+      value = value->as_InlineTypeBase()->clone_with_phis(gvn, region);\n+    } else {\n+      phi_type = Type::get_const_type(type);\n+      value = PhiNode::make(region, value, phi_type);\n+      gvn->set_type(value, phi_type);\n+      gvn->record_for_igvn(value);\n+    }\n+    vt->set_field_value(i, value);\n+  }\n+  gvn->set_type(vt, vt->bottom_type());\n+  gvn->record_for_igvn(vt);\n+  return vt;\n+}\n+\n+\/\/ Checks if the inputs of the InlineTypeBaseTypeNode were replaced by PhiNodes\n+\/\/ for the given region (see InlineTypeBaseTypeNode::clone_with_phis).\n+bool InlineTypeBaseNode::has_phi_inputs(Node* region) {\n+  \/\/ Check oop input\n+  bool result = get_oop()->is_Phi() && get_oop()->as_Phi()->region() == region;\n+#ifdef ASSERT\n+  if (result) {\n+    \/\/ Check all field value inputs for consistency\n+    for (uint i = Values; i < field_count(); ++i) {\n+      Node* n = in(i);\n+      if (n->is_InlineTypeBase()) {\n+        assert(n->as_InlineTypeBase()->has_phi_inputs(region), \"inconsistent phi inputs\");\n+      } else {\n+        assert(n->is_Phi() && n->as_Phi()->region() == region, \"inconsistent phi inputs\");\n+      }\n+    }\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ Check if all inline type fields have inline type node values\n+bool InlineTypeBaseNode::can_merge() {\n+  for (uint i = 0; i < field_count(); ++i) {\n+    ciType* type = field_type(i);\n+    Node* val = field_value(i);\n+    if (type->is_inlinetype() &&\n+        (!val->is_InlineTypeBase() || !val->as_InlineTypeBase()->can_merge())) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Merges 'this' with 'other' by updating the input PhiNodes added by 'clone_with_phis'\n+InlineTypeBaseNode* InlineTypeBaseNode::merge_with(PhaseGVN* gvn, const InlineTypeBaseNode* other, int pnum, bool transform) {\n+  \/\/ Merge oop inputs\n+  PhiNode* phi = get_oop()->as_Phi();\n+  phi->set_req(pnum, other->get_oop());\n+  if (transform) {\n+    set_oop(gvn->transform(phi));\n+  }\n+\n+  Node* is_init = get_is_init();\n+  if (is_init->is_Phi()) {\n+    phi = is_init->as_Phi();\n+    phi->set_req(pnum, other->get_is_init());\n+    if (transform) {\n+      set_req(IsInit, gvn->transform(phi));\n+    }\n+  } else {\n+    assert(is_init->find_int_con(0) == 1, \"only with a non null inline type\");\n+  }\n+\n+  \/\/ Merge field values\n+  for (uint i = 0; i < field_count(); ++i) {\n+    Node* val1 =        field_value(i);\n+    Node* val2 = other->field_value(i);\n+    if (val1->is_InlineTypeBase()) {\n+      val1->as_InlineTypeBase()->merge_with(gvn, val2->as_InlineTypeBase(), pnum, transform);\n+    } else {\n+      assert(val1->is_Phi(), \"must be a phi node\");\n+      val1->set_req(pnum, val2);\n+    }\n+    if (transform) {\n+      set_field_value(i, gvn->transform(val1));\n+    }\n+  }\n+  return this;\n+}\n+\n+\/\/ Adds a new merge path to an inline type node with phi inputs\n+void InlineTypeBaseNode::add_new_path(Node* region) {\n+  assert(has_phi_inputs(region), \"must have phi inputs\");\n+\n+  PhiNode* phi = get_oop()->as_Phi();\n+  phi->add_req(NULL);\n+  assert(phi->req() == region->req(), \"must be same size as region\");\n+\n+  phi = get_is_init()->as_Phi();\n+  phi->add_req(NULL);\n+  assert(phi->req() == region->req(), \"must be same size as region\");\n+\n+  for (uint i = 0; i < field_count(); ++i) {\n+    Node* val = field_value(i);\n+    if (val->is_InlineTypeBase()) {\n+      val->as_InlineTypeBase()->add_new_path(region);\n+    } else {\n+      val->as_Phi()->add_req(NULL);\n+      assert(val->req() == region->req(), \"must be same size as region\");\n+    }\n+  }\n+}\n+\n+Node* InlineTypeBaseNode::field_value(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return in(Values + index);\n+}\n+\n+\/\/ Get the value of the field at the given offset.\n+\/\/ If 'recursive' is true, flattened inline type fields will be resolved recursively.\n+Node* InlineTypeBaseNode::field_value_by_offset(int offset, bool recursive) const {\n+  \/\/ If the field at 'offset' belongs to a flattened inline type field, 'index' refers to the\n+  \/\/ corresponding InlineTypeNode input and 'sub_offset' is the offset in flattened inline type.\n+  int index = inline_klass()->field_index_by_offset(offset);\n+  int sub_offset = offset - field_offset(index);\n+  Node* value = field_value(index);\n+  assert(value != NULL, \"field value not found\");\n+  if (recursive && value->is_InlineTypeBase()) {\n+    if (field_is_flattened(index)) {\n+      \/\/ Flattened inline type field\n+      InlineTypeBaseNode* vt = value->as_InlineTypeBase();\n+      sub_offset += vt->inline_klass()->first_field_offset(); \/\/ Add header size\n+      return vt->field_value_by_offset(sub_offset, recursive);\n+    } else {\n+      assert(sub_offset == 0, \"should not have a sub offset\");\n+      return value;\n+    }\n+  }\n+  assert(!(recursive && value->is_InlineTypeBase()), \"should not be an inline type\");\n+  assert(sub_offset == 0, \"offset mismatch\");\n+  return value;\n+}\n+\n+void InlineTypeBaseNode::set_field_value(uint index, Node* value) {\n+  assert(index < field_count(), \"index out of bounds\");\n+  set_req(Values + index, value);\n+}\n+\n+void InlineTypeBaseNode::set_field_value_by_offset(int offset, Node* value) {\n+  set_field_value(field_index(offset), value);\n+}\n+\n+int InlineTypeBaseNode::field_offset(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->offset();\n+}\n+\n+uint InlineTypeBaseNode::field_index(int offset) const {\n+  uint i = 0;\n+  for (; i < field_count() && field_offset(i) != offset; i++) { }\n+  assert(i < field_count(), \"field not found\");\n+  return i;\n+}\n+\n+ciType* InlineTypeBaseNode::field_type(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->type();\n+}\n+\n+bool InlineTypeBaseNode::field_is_flattened(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n+  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  return field->is_flattened();\n+}\n+\n+bool InlineTypeBaseNode::field_is_null_free(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n+  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  return field->is_null_free();\n+}\n+\n+void InlineTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt) {\n+  ciInlineKlass* vk = inline_klass();\n+  uint nfields = vk->nof_nonstatic_fields();\n+  JVMState* jvms = sfpt->jvms();\n+  \/\/ Replace safepoint edge by SafePointScalarObjectNode and add field values\n+  assert(jvms != NULL, \"missing JVMS\");\n+  uint first_ind = (sfpt->req() - jvms->scloff());\n+  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(inline_ptr(),\n+#ifdef ASSERT\n+                                                                  NULL,\n+#endif\n+                                                                  first_ind, nfields);\n+  sobj->init_req(0, igvn->C->root());\n+  \/\/ Nullable inline types have an IsInit field that needs\n+  \/\/ to be checked before using the field values.\n+  if (!igvn->type(get_is_init())->is_int()->is_con(1)) {\n+    sfpt->add_req(get_is_init());\n+  } else {\n+    sfpt->add_req(igvn->C->top());\n+  }\n+  \/\/ Iterate over the inline type fields in order of increasing\n+  \/\/ offset and add the field values to the safepoint.\n+  for (uint j = 0; j < nfields; ++j) {\n+    int offset = vk->nonstatic_field_at(j)->offset();\n+    Node* value = field_value_by_offset(offset, true \/* include flattened inline type fields *\/);\n+    if (value->is_InlineTypeBase()) {\n+      \/\/ Add inline type field to the worklist to process later\n+      worklist.push(value);\n+    }\n+    sfpt->add_req(value);\n+  }\n+  jvms->set_endoff(sfpt->req());\n+  sobj = igvn->transform(sobj)->as_SafePointScalarObject();\n+  igvn->rehash_node_delayed(sfpt);\n+  for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n+    Node* debug = sfpt->in(i);\n+    if (debug != NULL && debug->uncast() == this) {\n+      sfpt->set_req(i, sobj);\n+    }\n+  }\n+}\n+\n+void InlineTypeBaseNode::make_scalar_in_safepoints(PhaseIterGVN* igvn, bool allow_oop) {\n+  \/\/ If the inline type has a constant or loaded oop, use the oop instead of scalarization\n+  \/\/ in the safepoint to avoid keeping field loads live just for the debug info.\n+  Node* oop = get_oop();\n+  bool use_oop = allow_oop && (is_InlineTypePtr() || is_allocated(igvn)) &&\n+                 (oop->is_Con() || oop->is_Parm() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+\n+  ResourceMark rm;\n+  Unique_Node_List safepoints;\n+  Unique_Node_List vt_worklist;\n+  Unique_Node_List worklist;\n+  worklist.push(this);\n+  while (worklist.size() > 0) {\n+    Node* n = worklist.pop();\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* use = n->fast_out(i);\n+      if (use->is_SafePoint() && !use->is_CallLeaf() && (!use->is_Call() || use->as_Call()->has_debug_use(n))) {\n+        safepoints.push(use);\n+      } else if (use->is_ConstraintCast()) {\n+        worklist.push(use);\n+      }\n+    }\n+  }\n+\n+  \/\/ Process all safepoint uses and scalarize inline type\n+  while (safepoints.size() > 0) {\n+    SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n+    if (use_oop) {\n+      for (uint i = sfpt->jvms()->debug_start(); i < sfpt->jvms()->debug_end(); i++) {\n+        Node* debug = sfpt->in(i);\n+        if (debug != NULL && debug->uncast() == this) {\n+          sfpt->set_req(i, get_oop());\n+        }\n+      }\n+      igvn->rehash_node_delayed(sfpt);\n+    } else {\n+      make_scalar_in_safepoint(igvn, vt_worklist, sfpt);\n+    }\n+  }\n+  \/\/ Now scalarize non-flattened fields\n+  for (uint i = 0; i < vt_worklist.size(); ++i) {\n+    InlineTypeBaseNode* vt = vt_worklist.at(i)->isa_InlineTypeBase();\n+    vt->make_scalar_in_safepoints(igvn);\n+  }\n+  if (outcnt() == 0) {\n+    igvn->_worklist.push(this);\n+  }\n+}\n+\n+const TypePtr* InlineTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN& gvn) const {\n+  const TypeAryPtr* ary_type = gvn.type(base)->isa_aryptr();\n+  const TypePtr* adr_type = NULL;\n+  bool is_array = ary_type != NULL;\n+  if ((decorators & C2_MISMATCHED) != 0) {\n+    adr_type = TypeRawPtr::BOTTOM;\n+  } else if (is_array) {\n+    \/\/ In the case of a flattened inline type array, each field has its own slice\n+    adr_type = ary_type->with_field_offset(offset)->add_offset(Type::OffsetBot);\n+  } else {\n+    ciField* field = holder->get_field_by_offset(offset, false);\n+    assert(field != NULL, \"field not found\");\n+    adr_type = gvn.C->alias_type(field)->adr_type();\n+  }\n+  return adr_type;\n+}\n+\n+void InlineTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n+  \/\/ Initialize the inline type by loading its field values from\n+  \/\/ memory and adding the values as input edges to the node.\n+  for (uint i = 0; i < field_count(); ++i) {\n+    int offset = holder_offset + field_offset(i);\n+    Node* value = NULL;\n+    ciType* ft = field_type(i);\n+    bool null_free = field_is_null_free(i);\n+    if (null_free && ft->as_inline_klass()->is_empty()) {\n+      \/\/ Loading from a field of an empty inline type. Just return the default instance.\n+      value = InlineTypeNode::make_default(kit->gvn(), ft->as_inline_klass());\n+    } else if (field_is_flattened(i)) {\n+      \/\/ Recursively load the flattened inline type field\n+      value = InlineTypeNode::make_from_flattened(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators);\n+    } else {\n+      const TypeOopPtr* oop_ptr = kit->gvn().type(base)->isa_oopptr();\n+      bool is_array = (oop_ptr->isa_aryptr() != NULL);\n+      bool mismatched = (decorators & C2_MISMATCHED) != 0;\n+      if (base->is_Con() && !is_array && !mismatched) {\n+        \/\/ If the oop to the inline type is constant (static final field), we can\n+        \/\/ also treat the fields as constants because the inline type is immutable.\n+        ciObject* constant_oop = oop_ptr->const_oop();\n+        ciField* field = holder->get_field_by_offset(offset, false);\n+        assert(field != NULL, \"field not found\");\n+        ciConstant constant = constant_oop->as_instance()->field_value(field);\n+        const Type* con_type = Type::make_from_constant(constant, \/*require_const=*\/ true);\n+        assert(con_type != NULL, \"type not found\");\n+        value = kit->gvn().transform(kit->makecon(con_type));\n+        \/\/ Check type of constant which might be more precise than the static field type\n+        if (con_type->is_inlinetypeptr() && !con_type->is_zero_type()) {\n+          ft = con_type->inline_klass();\n+          null_free = true;\n+        }\n+      } else {\n+        \/\/ Load field value from memory\n+        const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n+        Node* adr = kit->basic_plus_adr(base, ptr, offset);\n+        BasicType bt = type2field[ft->basic_type()];\n+        assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n+        const Type* val_type = Type::get_const_type(ft);\n+        if (is_array) {\n+          decorators |= IS_ARRAY;\n+        }\n+        value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);\n+      }\n+      \/\/ Loading a non-flattened inline type from memory\n+      if (ft->is_inlinetype()) {\n+        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass(), null_free);\n+      }\n+    }\n+    set_field_value(i, value);\n+  }\n+}\n+\n+void InlineTypeBaseNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+  if (kit->gvn().type(base)->isa_aryptr()) {\n+    kit->C->set_flattened_accesses();\n+  }\n+  \/\/ The inline type is embedded into the object without an oop header. Subtract the\n+  \/\/ offset of the first field to account for the missing header when storing the values.\n+  if (holder == NULL) {\n+    holder = inline_klass();\n+  }\n+  holder_offset -= inline_klass()->first_field_offset();\n+  store(kit, base, ptr, holder, holder_offset, decorators);\n+}\n+\n+void InlineTypeBaseNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+  \/\/ Write field values to memory\n+  for (uint i = 0; i < field_count(); ++i) {\n+    int offset = holder_offset + field_offset(i);\n+    Node* value = field_value(i);\n+    ciType* ft = field_type(i);\n+    if (field_is_flattened(i)) {\n+      \/\/ Recursively store the flattened inline type field\n+      if (!value->is_InlineTypeBase()) {\n+        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());\n+      }\n+      value->as_InlineTypeBase()->store_flattened(kit, base, ptr, holder, offset, decorators);\n+    } else {\n+      \/\/ Store field value to memory\n+      const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n+      Node* adr = kit->basic_plus_adr(base, ptr, offset);\n+      BasicType bt = type2field[ft->basic_type()];\n+      assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n+      const Type* val_type = Type::get_const_type(ft);\n+      const TypeAryPtr* ary_type = kit->gvn().type(base)->isa_aryptr();\n+      if (ary_type != NULL) {\n+        decorators |= IS_ARRAY;\n+      }\n+      kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);\n+    }\n+  }\n+}\n+\n+InlineTypePtrNode* InlineTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {\n+  assert(is_InlineType(), \"sanity\");\n+\n+  \/\/ Check if inline type is already buffered\n+  Node* not_buffered_ctl = kit->top();\n+  Node* not_null_oop = kit->null_check_oop(get_oop(), &not_buffered_ctl, \/* never_see_null = *\/ false, safe_for_replace);\n+  if (not_buffered_ctl->is_top()) {\n+    \/\/ Already buffered\n+    InlineTypePtrNode* ptr = as_ptr(&kit->gvn(), false);\n+    if (safe_for_replace) {\n+      kit->replace_in_map(this, ptr);\n+    }\n+    return ptr;\n+  }\n+  Node* buffered_ctl = kit->control();\n+  kit->set_control(not_buffered_ctl);\n+\n+  \/\/ Inline type is not buffered, check if it is null.\n+  Node* null_ctl = kit->top();\n+  kit->null_check_common(get_is_init(), T_INT, false, &null_ctl);\n+  bool null_free = null_ctl->is_top();\n+\n+  RegionNode* region = new RegionNode(4);\n+  PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr()->join_speculative(null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM));\n+\n+  \/\/ InlineType is already buffered\n+  region->init_req(1, buffered_ctl);\n+  oop->init_req(1, not_null_oop);\n+\n+  \/\/ InlineType is null\n+  region->init_req(2, null_ctl);\n+  oop->init_req(2, kit->gvn().zerocon(T_OBJECT));\n+\n+  PhiNode* io  = PhiNode::make(region, kit->i_o(), Type::ABIO);\n+  PhiNode* mem = PhiNode::make(region, kit->merged_memory(), Type::MEMORY, TypePtr::BOTTOM);\n+\n+  int bci = kit->bci();\n+  bool reexecute = kit->jvms()->should_reexecute();\n+  if (!kit->stopped()) {\n+    assert(!is_allocated(&kit->gvn()), \"already buffered\");\n+\n+    \/\/ Allocate and initialize buffer\n+    PreserveJVMState pjvms(kit);\n+    \/\/ Propagate re-execution state and bci\n+    kit->set_bci(bci);\n+    kit->jvms()->set_bci(bci);\n+    kit->jvms()->set_should_reexecute(reexecute);\n+\n+    kit->kill_dead_locals();\n+    ciInlineKlass* vk = inline_klass();\n+    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, this);\n+    store(kit, alloc_oop, alloc_oop, vk);\n+\n+    \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+    \/\/ store that would make this buffer accessible by other threads.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit->gvn());\n+    assert(alloc != NULL, \"must have an allocation node\");\n+    kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+\n+    region->init_req(3, kit->control());\n+    oop   ->init_req(3, alloc_oop);\n+    io    ->init_req(3, kit->i_o());\n+    mem   ->init_req(3, kit->merged_memory());\n+  }\n+\n+  \/\/ Update GraphKit\n+  kit->set_control(kit->gvn().transform(region));\n+  kit->set_i_o(kit->gvn().transform(io));\n+  kit->set_all_memory(kit->gvn().transform(mem));\n+  kit->record_for_igvn(region);\n+  kit->record_for_igvn(oop);\n+  kit->record_for_igvn(io);\n+  kit->record_for_igvn(mem);\n+\n+  \/\/ Use cloned InlineTypeNode to propagate oop from now on\n+  Node* res_oop = kit->gvn().transform(oop);\n+  InlineTypeBaseNode* vt = clone()->as_InlineTypeBase();\n+  vt->set_oop(res_oop);\n+  vt = kit->gvn().transform(vt)->as_InlineTypeBase();\n+  if (safe_for_replace) {\n+    kit->replace_in_map(this, vt);\n+  }\n+  \/\/ InlineTypeNode::remove_redundant_allocations piggybacks on split if.\n+  \/\/ Make sure it gets a chance to remove this allocation.\n+  kit->C->set_has_split_ifs(true);\n+  return vt->as_ptr(&kit->gvn(), null_free);\n+}\n+\n+bool InlineTypeBaseNode::is_allocated(PhaseGVN* phase) const {\n+  Node* oop = get_oop();\n+  const Type* oop_type = (phase != NULL) ? phase->type(oop) : oop->bottom_type();\n+  return !oop_type->maybe_null();\n+}\n+\n+InlineTypePtrNode* InlineTypeBaseNode::as_ptr(PhaseGVN* phase, bool null_free) const {\n+  assert(!null_free || is_allocated(phase), \"must be allocated\");\n+  if (is_InlineTypePtr()) {\n+    return as_InlineTypePtr();\n+  }\n+  return phase->transform(new InlineTypePtrNode(this, null_free))->as_InlineTypePtr();\n+}\n+\n+\/\/ When a call returns multiple values, it has several result\n+\/\/ projections, one per field. Replacing the result of the call by an\n+\/\/ inline type node (after late inlining) requires that for each result\n+\/\/ projection, we find the corresponding inline type field.\n+void InlineTypeBaseNode::replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free) {\n+  ciInlineKlass* vk = inline_klass();\n+  for (DUIterator_Fast imax, i = call->fast_outs(imax); i < imax; i++) {\n+    ProjNode* pn = call->fast_out(i)->as_Proj();\n+    uint con = pn->_con;\n+    Node* field = NULL;\n+    if (con == TypeFunc::Parms) {\n+      field = get_oop();\n+    } else if (!null_free && con == (call->tf()->range_cc()->cnt() - 1)) {\n+      field = get_is_init();\n+    } else if (con > TypeFunc::Parms) {\n+      uint field_nb = con - (TypeFunc::Parms+1);\n+      int extra = 0;\n+      for (uint j = 0; j < field_nb - extra; j++) {\n+        ciField* f = vk->nonstatic_field_at(j);\n+        BasicType bt = f->type()->basic_type();\n+        if (bt == T_LONG || bt == T_DOUBLE) {\n+          extra++;\n+        }\n+      }\n+      ciField* f = vk->nonstatic_field_at(field_nb - extra);\n+      field = field_value_by_offset(f->offset(), true);\n+      if (field->is_InlineType()) {\n+        assert(field->as_InlineType()->is_allocated(&kit->gvn()), \"must be allocated\");\n+        field = field->as_InlineType()->get_oop();\n+      }\n+    }\n+    if (field != NULL) {\n+      C->gvn_replace_by(pn, field);\n+      C->initial_gvn()->hash_delete(pn);\n+      pn->set_req(0, C->top());\n+      --i; --imax;\n+    }\n+  }\n+}\n+\n+Node* InlineTypeBaseNode::allocate_fields(GraphKit* kit) {\n+  InlineTypeBaseNode* vt = clone()->as_InlineTypeBase();\n+  for (uint i = 0; i < field_count(); i++) {\n+     Node* value = field_value(i);\n+     if (field_is_flattened(i)) {\n+       \/\/ Flattened inline type field\n+       vt->set_field_value(i, value->as_InlineTypeBase()->allocate_fields(kit));\n+     } else if (value->is_InlineType()) {\n+       \/\/ Non-flattened inline type field\n+       vt->set_field_value(i, value->as_InlineType()->buffer(kit));\n+     }\n+  }\n+  vt = kit->gvn().transform(vt)->as_InlineTypeBase();\n+  kit->replace_in_map(this, vt);\n+  return vt;\n+}\n+\n+Node* InlineTypeBaseNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* is_init = get_is_init();\n+  if (is_init->isa_InlineTypePtr()) {\n+    set_req(IsInit, is_init->as_InlineTypePtr()->get_is_init());\n+    return this;\n+  }\n+  Node* oop = get_oop();\n+  if (oop->isa_InlineTypePtr() && !phase->type(oop)->maybe_null()) {\n+    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n+    set_oop(vtptr->get_oop());\n+    set_is_init(*phase);\n+    for (uint i = Values; i < vtptr->req(); ++i) {\n+      set_req(i, vtptr->in(i));\n+    }\n+    return this;\n+  }\n+  return NULL;\n+}\n+\n+InlineTypeNode* InlineTypeNode::make_uninitialized(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  \/\/ Create a new InlineTypeNode with uninitialized values and NULL oop\n+  Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n+  vt->set_is_init(gvn);\n+  return vt;\n+}\n+\n+Node* InlineTypeBaseNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  \/\/ Returns the constant oop of the default inline type allocation\n+  return gvn.makecon(TypeInstPtr::make(vk->default_instance()));\n+}\n+\n+InlineTypeNode* InlineTypeNode::make_default(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  \/\/ Create a new InlineTypeNode with default values\n+  Node* oop = vk->is_initialized() ? default_oop(gvn, vk) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n+  vt->set_is_init(gvn);\n+  for (uint i = 0; i < vt->field_count(); ++i) {\n+    ciType* field_type = vt->field_type(i);\n+    Node* value = gvn.zerocon(field_type->basic_type());\n+    if (field_type->is_inlinetype()) {\n+      ciInlineKlass* vk = field_type->as_inline_klass();\n+      if (vt->field_is_null_free(i)) {\n+        value = make_default(gvn, vk);\n+      } else {\n+        value = InlineTypePtrNode::make_null(gvn, vk);\n+      }\n+    }\n+    vt->set_field_value(i, value);\n+  }\n+  vt = gvn.transform(vt)->as_InlineType();\n+  assert(vt->is_default(&gvn), \"must be the default inline type\");\n+  return vt;\n+}\n+\n+InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT));\n+  vt->set_req(IsInit, gvn.intcon(0));\n+  for (uint i = 0; i < vt->field_count(); i++) {\n+    ciType* field_type = vt->field_type(i);\n+    Node* value = gvn.zerocon(field_type->basic_type());\n+    if (field_type->is_inlinetype()) {\n+      if (vt->field_is_null_free(i)) {\n+        value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n+      } else {\n+        value = InlineTypePtrNode::make_null(gvn, field_type->as_inline_klass());\n+      }\n+    }\n+    vt->set_field_value(i, value);\n+  }\n+  return gvn.transform(vt)->as_InlineType();\n+}\n+\n+bool InlineTypeBaseNode::is_default(PhaseGVN* gvn) const {\n+  const Type* tinit = gvn->type(in(IsInit));\n+  if (!tinit->isa_int() || !tinit->is_int()->is_con(1)) {\n+    return false; \/\/ May be null\n+  }\n+  for (uint i = 0; i < field_count(); ++i) {\n+    Node* value = field_value(i);\n+    if (value->is_InlineTypePtr()) {\n+      value = value->as_InlineTypePtr()->get_oop();\n+    }\n+    if (!gvn->type(value)->is_zero_type() &&\n+        !(field_is_null_free(i) && value->is_InlineType() && value->as_InlineType()->is_default(gvn))) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+InlineTypeBaseNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n+  PhaseGVN& gvn = kit->gvn();\n+\n+  if (vk->is_empty() && null_free) {\n+    InlineTypeNode* def = make_default(gvn, vk);\n+    kit->record_for_igvn(def);\n+    return def;\n+  }\n+  \/\/ Create and initialize an InlineTypeNode by loading all field\n+  \/\/ values from a heap-allocated version and also save the oop.\n+  InlineTypeBaseNode* vt = NULL;\n+\n+  if (oop->isa_InlineTypePtr()) {\n+    return oop->as_InlineTypePtr();\n+  } else if (gvn.type(oop)->maybe_null()) {\n+    \/\/ Add a null check because the oop may be null\n+    Node* null_ctl = kit->top();\n+    Node* not_null_oop = kit->null_check_oop(oop, &null_ctl);\n+    if (kit->stopped()) {\n+      \/\/ Constant null\n+      kit->set_control(null_ctl);\n+      if (null_free) {\n+        vt = make_default(gvn, vk);\n+      } else {\n+        vt = InlineTypePtrNode::make_null(gvn, vk);\n+      }\n+      kit->record_for_igvn(vt);\n+      return vt;\n+    }\n+    vt = new InlineTypePtrNode(vk, not_null_oop, null_free);\n+    vt->set_is_init(gvn);\n+    vt->load(kit, not_null_oop, not_null_oop, vk, \/* holder_offset *\/ 0);\n+\n+    if (null_ctl != kit->top()) {\n+      InlineTypeBaseNode* null_vt = NULL;\n+      if (null_free) {\n+        null_vt = make_default(gvn, vk)->as_ptr(&gvn);\n+      } else {\n+        null_vt = InlineTypePtrNode::make_null(gvn, vk);\n+      }\n+      Node* region = new RegionNode(3);\n+      region->init_req(1, kit->control());\n+      region->init_req(2, null_ctl);\n+\n+      vt = vt->clone_with_phis(&gvn, region);\n+      vt->merge_with(&gvn, null_vt, 2, true);\n+      if (!null_free) {\n+        vt->set_oop(oop);\n+      }\n+      kit->set_control(gvn.transform(region));\n+    }\n+  } else {\n+    \/\/ Oop can never be null\n+    vt = new InlineTypePtrNode(vk, oop, \/* null_free= *\/ true);\n+    Node* init_ctl = kit->control();\n+    vt->set_is_init(gvn);\n+    vt->load(kit, oop, oop, vk, \/* holder_offset *\/ 0);\n+\/\/ TODO fix with JDK-8278390\n+\/\/    assert(!null_free || vt->as_InlineType()->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineTypePtr ||\n+\/\/           AllocateNode::Ideal_allocation(oop, &gvn) != NULL || vt->as_InlineType()->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n+  }\n+  assert(!null_free || vt->is_allocated(&gvn), \"inline type should be allocated\");\n+  kit->record_for_igvn(vt);\n+  return gvn.transform(vt)->as_InlineTypeBase();\n+}\n+\n+\/\/ GraphKit wrapper for the 'make_from_flattened' method\n+InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n+  if (kit->gvn().type(obj)->isa_aryptr()) {\n+    kit->C->set_flattened_accesses();\n+  }\n+  \/\/ Create and initialize an InlineTypeNode by loading all field values from\n+  \/\/ a flattened inline type field at 'holder_offset' or from an inline type array.\n+  InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk);\n+  \/\/ The inline type is flattened into the object without an oop header. Subtract the\n+  \/\/ offset of the first field to account for the missing header when loading the values.\n+  holder_offset -= vk->first_field_offset();\n+  vt->load(kit, obj, ptr, holder, holder_offset, decorators);\n+  assert(vt->is_loaded(&kit->gvn()) != obj, \"holder oop should not be used as flattened inline type oop\");\n+  return kit->gvn().transform(vt)->as_InlineType();\n+}\n+\n+InlineTypeBaseNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free) {\n+  InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk);\n+  if (!in) {\n+    \/\/ Keep track of the oop. The returned inline type might already be buffered.\n+    Node* oop = kit->gvn().transform(new ProjNode(multi, base_input++));\n+    vt->set_oop(oop);\n+  }\n+  vt->initialize_fields(kit, multi, base_input, in, null_free);\n+  return kit->gvn().transform(vt)->as_InlineTypeBase();\n+}\n+\n+InlineTypeNode* InlineTypeBaseNode::make_larval(GraphKit* kit, bool allocate) const {\n+  ciInlineKlass* vk = inline_klass();\n+  InlineTypeNode* res = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n+  for (uint i = 1; i < req(); ++i) {\n+    res->set_req(i, in(i));\n+  }\n+\n+  if (allocate) {\n+    \/\/ Re-execute if buffering triggers deoptimization\n+    PreserveReexecuteState preexecs(kit);\n+    kit->jvms()->set_should_reexecute(true);\n+    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, true);\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit->gvn());\n+    alloc->_larval = true;\n+\n+    store(kit, alloc_oop, alloc_oop, vk);\n+    res->set_oop(alloc_oop);\n+  }\n+  res->set_type(TypeInlineType::make(vk, true));\n+  res = kit->gvn().transform(res)->as_InlineType();\n+  assert(!allocate || res->is_allocated(&kit->gvn()), \"must be allocated\");\n+  return res;\n+}\n+\n+InlineTypeNode* InlineTypeBaseNode::finish_larval(GraphKit* kit) const {\n+  Node* obj = get_oop();\n+  Node* mark_addr = kit->basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n+  Node* mark = kit->make_load(NULL, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  mark = kit->gvn().transform(new AndXNode(mark, kit->MakeConX(~markWord::larval_bit_in_place)));\n+  kit->store_to_memory(kit->control(), mark_addr, mark, TypeX_X->basic_type(), kit->gvn().type(mark_addr)->is_ptr(), MemNode::unordered);\n+\n+  \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+  \/\/ store that would make this buffer accessible by other threads.\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(obj, &kit->gvn());\n+  assert(alloc != NULL, \"must have an allocation node\");\n+  kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+\n+  ciInlineKlass* vk = inline_klass();\n+  InlineTypeNode* res = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n+  for (uint i = 1; i < req(); ++i) {\n+    res->set_req(i, in(i));\n+  }\n+  res->set_type(TypeInlineType::make(vk, false));\n+  res = kit->gvn().transform(res)->as_InlineType();\n+  return res;\n+}\n+\n+Node* InlineTypeNode::is_loaded(PhaseGVN* phase, ciInlineKlass* vk, Node* base, int holder_offset) {\n+  if (vk == NULL) {\n+    vk = inline_klass();\n+  }\n+  if (field_count() == 0 && vk->is_initialized()) {\n+    const Type* tinit = phase->type(in(IsInit));\n+    if (tinit->isa_int() && tinit->is_int()->is_con(1)) {\n+      assert(is_allocated(phase), \"must be allocated\");\n+      return get_oop();\n+    } else {\n+      \/\/ TODO 8284443\n+      return NULL;\n+    }\n+  }\n+  for (uint i = 0; i < field_count(); ++i) {\n+    int offset = holder_offset + field_offset(i);\n+    Node* value = field_value(i);\n+    if (value->is_InlineTypeBase()) {\n+      InlineTypeBaseNode* vt = value->as_InlineTypeBase();\n+      if (vt->type()->inline_klass()->is_empty()) {\n+        continue;\n+      } else if (field_is_flattened(i) && vt->is_InlineType()) {\n+        \/\/ Check inline type field load recursively\n+        base = vt->as_InlineType()->is_loaded(phase, vk, base, offset - vt->type()->inline_klass()->first_field_offset());\n+        if (base == NULL) {\n+          return NULL;\n+        }\n+        continue;\n+      } else {\n+        value = vt->get_oop();\n+        if (value->Opcode() == Op_CastPP) {\n+          \/\/ Skip CastPP\n+          value = value->in(1);\n+        }\n+      }\n+    }\n+    if (value->isa_DecodeN()) {\n+      \/\/ Skip DecodeN\n+      value = value->in(1);\n+    }\n+    if (value->isa_Load()) {\n+      \/\/ Check if base and offset of field load matches inline type layout\n+      intptr_t loffset = 0;\n+      Node* lbase = AddPNode::Ideal_base_and_offset(value->in(MemNode::Address), phase, loffset);\n+      if (lbase == NULL || (lbase != base && base != NULL) || loffset != offset) {\n+        return NULL;\n+      } else if (base == NULL) {\n+        \/\/ Set base and check if pointer type matches\n+        base = lbase;\n+        const TypeInstPtr* vtptr = phase->type(base)->isa_instptr();\n+        if (vtptr == NULL || !vtptr->instance_klass()->equals(vk)) {\n+          return NULL;\n+        }\n+      }\n+    } else {\n+      return NULL;\n+    }\n+  }\n+  return base;\n+}\n+\n+Node* InlineTypeBaseNode::tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn) {\n+  const TypeKlassPtr* tk = TypeKlassPtr::make(vk);\n+  intptr_t bits = tk->get_con();\n+  set_nth_bit(bits, 0);\n+  return gvn.longcon((jlong)bits);\n+}\n+\n+void InlineTypeBaseNode::pass_fields(GraphKit* kit, Node* n, uint& base_input, bool in, bool null_free) {\n+  if (!null_free && in) {\n+    n->init_req(base_input++, get_is_init());\n+  }\n+  for (uint i = 0; i < field_count(); i++) {\n+    Node* arg = field_value(i);\n+    if (field_is_flattened(i)) {\n+      \/\/ Flattened inline type field\n+      arg->as_InlineTypeBase()->pass_fields(kit, n, base_input, in);\n+    } else {\n+      if (arg->is_InlineType()) {\n+        \/\/ Non-flattened inline type field\n+        InlineTypeNode* vt = arg->as_InlineType();\n+        assert(n->Opcode() != Op_Return || vt->is_allocated(&kit->gvn()), \"inline type field should be allocated on return\");\n+        arg = vt->buffer(kit);\n+      }\n+      \/\/ Initialize call\/return arguments\n+      n->init_req(base_input++, arg);\n+      if (field_type(i)->size() == 2) {\n+        n->init_req(base_input++, kit->top());\n+      }\n+    }\n+  }\n+  \/\/ The last argument is used to pass IsInit information to compiled code and not required here.\n+  if (!null_free && !in) {\n+    n->init_req(base_input++, kit->top());\n+  }\n+}\n+\n+void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region) {\n+  PhaseGVN& gvn = kit->gvn();\n+  Node* is_init = NULL;\n+  if (!null_free) {\n+    \/\/ Nullable inline type\n+    if (in) {\n+      \/\/ Set IsInit field\n+      if (multi->is_Start()) {\n+        is_init = gvn.transform(new ParmNode(multi->as_Start(), base_input));\n+      } else {\n+        is_init = multi->as_Call()->in(base_input);\n+      }\n+      set_req(IsInit, is_init);\n+      base_input++;\n+    }\n+    \/\/ Add a null check to make subsequent loads dependent on\n+    assert(null_check_region == NULL, \"already set\");\n+    if (is_init == NULL) {\n+      \/\/ Will only be initialized below, use dummy node for now\n+      is_init = new Node(1);\n+      gvn.set_type_bottom(is_init);\n+    }\n+    Node* null_ctrl = kit->top();\n+    kit->null_check_common(is_init, T_INT, false, &null_ctrl);\n+    Node* non_null_ctrl = kit->control();\n+    null_check_region = new RegionNode(3);\n+    null_check_region->init_req(1, non_null_ctrl);\n+    null_check_region->init_req(2, null_ctrl);\n+    null_check_region = gvn.transform(null_check_region);\n+    kit->set_control(null_check_region);\n+  }\n+\n+  for (uint i = 0; i < field_count(); ++i) {\n+    ciType* type = field_type(i);\n+    Node* parm = NULL;\n+    if (field_is_flattened(i)) {\n+      \/\/ Flattened inline type field\n+      InlineTypeNode* vt = make_uninitialized(gvn, type->as_inline_klass());\n+      vt->initialize_fields(kit, multi, base_input, in, true, null_check_region);\n+      parm = gvn.transform(vt);\n+    } else {\n+      if (multi->is_Start()) {\n+        assert(in, \"return from start?\");\n+        parm = gvn.transform(new ParmNode(multi->as_Start(), base_input));\n+      } else if (in) {\n+        parm = multi->as_Call()->in(base_input);\n+      } else {\n+        parm = gvn.transform(new ProjNode(multi->as_Call(), base_input));\n+      }\n+      \/\/ Non-flattened inline type field\n+      if (type->is_inlinetype()) {\n+        if (null_check_region != NULL) {\n+          \/\/ Holder is nullable, set field to NULL if holder is NULL to avoid loading from uninitialized memory\n+          parm = PhiNode::make(null_check_region, parm, TypeInstPtr::make(TypePtr::BotPTR, type->as_inline_klass()));\n+          parm->set_req(2, kit->zerocon(T_OBJECT));\n+          parm = gvn.transform(parm);\n+        }\n+        parm = make_from_oop(kit, parm, type->as_inline_klass(), field_is_null_free(i));\n+      }\n+      base_input += type->size();\n+    }\n+    assert(parm != NULL, \"should never be null\");\n+    assert(field_value(i) == NULL, \"already set\");\n+    set_field_value(i, parm);\n+    gvn.record_for_igvn(parm);\n+  }\n+  \/\/ The last argument is used to pass IsInit information to compiled code\n+  if (!null_free && !in) {\n+    Node* cmp = is_init->raw_out(0);\n+    is_init= gvn.transform(new ProjNode(multi->as_Call(), base_input));\n+    set_req(IsInit, is_init);\n+    gvn.hash_delete(cmp);\n+    cmp->set_req(1, is_init);\n+    gvn.hash_find_insert(cmp);\n+    base_input++;\n+  }\n+}\n+\n+\/\/ Replace a buffer allocation by a dominating allocation\n+static void replace_allocation(PhaseIterGVN* igvn, Node* res, Node* dom) {\n+  \/\/ Remove initializing stores and GC barriers\n+  for (DUIterator_Fast imax, i = res->fast_outs(imax); i < imax; i++) {\n+    Node* use = res->fast_out(i);\n+    if (use->is_AddP()) {\n+      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n+        Node* store = use->fast_out(j)->isa_Store();\n+        if (store != NULL) {\n+          igvn->rehash_node_delayed(store);\n+          igvn->replace_in_uses(store, store->in(MemNode::Memory));\n+        }\n+      }\n+    } else if (use->Opcode() == Op_CastP2X) {\n+      if (UseG1GC && use->find_out_with(Op_XorX)->in(1) != use) {\n+        \/\/ The G1 pre-barrier uses a CastP2X both for the pointer of the object\n+        \/\/ we store into, as well as the value we are storing. Skip if this is a\n+        \/\/ barrier for storing 'res' into another object.\n+        continue;\n+      }\n+      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+      bs->eliminate_gc_barrier(igvn, use);\n+      --i; --imax;\n+    }\n+  }\n+  igvn->replace_node(res, dom);\n+}\n+\n+Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* oop = get_oop();\n+  if (is_default(phase) && inline_klass()->is_initialized() &&\n+      (!oop->is_Con() || phase->type(oop)->is_zero_type())) {\n+    \/\/ Use the pre-allocated oop for default inline types\n+    set_oop(default_oop(*phase, inline_klass()));\n+    assert(is_allocated(phase), \"should now be allocated\");\n+    return this;\n+  }\n+\n+  if (!is_allocated(phase)) {\n+    \/\/ Save base oop if fields are loaded from memory and the inline\n+    \/\/ type is not buffered (in this case we should not use the oop).\n+    Node* base = is_loaded(phase);\n+    if (base != NULL && !phase->type(base)->maybe_null()) {\n+      set_oop(base);\n+      assert(is_allocated(phase), \"should now be allocated\");\n+      return this;\n+    }\n+  }\n+\n+  if (can_reshape) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+    if (is_allocated(phase)) {\n+      \/\/ Search for and remove re-allocations of this inline type. Ignore scalar replaceable ones,\n+      \/\/ they will be removed anyway and changing the memory chain will confuse other optimizations.\n+      \/\/ This can happen with late inlining when we first allocate an inline type argument\n+      \/\/ but later decide to inline the call after the callee code also triggered allocation.\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        AllocateNode* alloc = fast_out(i)->isa_Allocate();\n+        if (alloc != NULL && alloc->in(AllocateNode::InlineTypeNode) == this && !alloc->_is_scalar_replaceable) {\n+          \/\/ Found a re-allocation\n+          Node* res = alloc->result_cast();\n+          if (res != NULL && res->is_CheckCastPP()) {\n+            \/\/ Replace allocation by oop and unlink AllocateNode\n+            replace_allocation(igvn, res, oop);\n+            igvn->replace_input_of(alloc, AllocateNode::InlineTypeNode, igvn->C->top());\n+            --i; --imax;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return InlineTypeBaseNode::Ideal(phase, can_reshape);\n+}\n+\n+\/\/ Search for multiple allocations of this inline type and try to replace them by dominating allocations.\n+void InlineTypeNode::remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase) {\n+  \/\/ Search for allocations of this inline type. Ignore scalar replaceable ones, they\n+  \/\/ will be removed anyway and changing the memory chain will confuse other optimizations.\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    AllocateNode* alloc = fast_out(i)->isa_Allocate();\n+    if (alloc != NULL && alloc->in(AllocateNode::InlineTypeNode) == this && !alloc->_is_scalar_replaceable) {\n+      Node* res = alloc->result_cast();\n+      if (res == NULL || !res->is_CheckCastPP()) {\n+        break; \/\/ No unique CheckCastPP\n+      }\n+      assert((!is_default(igvn) || !inline_klass()->is_initialized()) && !is_allocated(igvn), \"re-allocation should be removed by Ideal transformation\");\n+      \/\/ Search for a dominating allocation of the same inline type\n+      Node* res_dom = res;\n+      for (DUIterator_Fast jmax, j = fast_outs(jmax); j < jmax; j++) {\n+        AllocateNode* alloc_other = fast_out(j)->isa_Allocate();\n+        if (alloc_other != NULL && alloc_other->in(AllocateNode::InlineTypeNode) == this && !alloc_other->_is_scalar_replaceable) {\n+          Node* res_other = alloc_other->result_cast();\n+          if (res_other != NULL && res_other->is_CheckCastPP() && res_other != res_dom &&\n+              phase->is_dominator(res_other->in(0), res_dom->in(0))) {\n+            res_dom = res_other;\n+          }\n+        }\n+      }\n+      if (res_dom != res) {\n+        \/\/ Replace allocation by dominating one.\n+        replace_allocation(igvn, res, res_dom);\n+        \/\/ The result of the dominated allocation is now unused and will be removed\n+        \/\/ later in PhaseMacroExpand::eliminate_allocate_node to not confuse loop opts.\n+        igvn->_worklist.push(alloc);\n+      }\n+    }\n+  }\n+\n+  \/\/ Process users\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* out = fast_out(i);\n+    if (out->is_InlineType()) {\n+      \/\/ Recursively process inline type users\n+      igvn->rehash_node_delayed(out);\n+      out->as_InlineType()->remove_redundant_allocations(igvn, phase);\n+    } else if (out->isa_Allocate() != NULL) {\n+      \/\/ Unlink AllocateNode\n+      assert(out->in(AllocateNode::InlineTypeNode) == this, \"should be linked\");\n+      igvn->replace_input_of(out, AllocateNode::InlineTypeNode, igvn->C->top());\n+      --i; --imax;\n+    }\n+  }\n+}\n+\n+InlineTypePtrNode* InlineTypePtrNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  InlineTypePtrNode* ptr = new InlineTypePtrNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false);\n+  ptr->set_req(IsInit, gvn.intcon(0));\n+  for (uint i = 0; i < ptr->field_count(); i++) {\n+    ciType* field_type = ptr->field_type(i);\n+    Node* value = gvn.zerocon(field_type->basic_type());\n+    if (field_type->is_inlinetype()) {\n+      if (ptr->field_is_null_free(i)) {\n+        value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n+      } else {\n+        value = InlineTypePtrNode::make_null(gvn, field_type->as_inline_klass());\n+      }\n+    }\n+    ptr->set_field_value(i, value);\n+  }\n+  return gvn.transform(ptr)->as_InlineTypePtr();\n+}\n+\n+Node* InlineTypePtrNode::Identity(PhaseGVN* phase) {\n+  if (get_oop()->is_InlineTypePtr()) {\n+    return get_oop();\n+  }\n+  return this;\n+}\n+\n+const Type* InlineTypePtrNode::Value(PhaseGVN* phase) const {\n+  const Type* t = phase->type(get_oop())->filter_speculative(_type);\n+  if (t->singleton()) {\n+    \/\/ Don't replace InlineTypePtr by a constant\n+    t = _type;\n+  }\n+  const Type* tinit = phase->type(in(IsInit));\n+  if (tinit->isa_int() && tinit->is_int()->is_con(1)) {\n+    t = t->join_speculative(TypePtr::NOTNULL);\n+  }\n+  return t;\n+}\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1181,"deletions":0,"binary":false,"changes":1181,"status":"added"},{"patch":"@@ -277,1 +277,1 @@\n-        if (offset == Type::OffsetBot || tptr->_offset == Type::OffsetBot)\n+        if (offset == Type::OffsetBot || tptr->offset() == Type::OffsetBot)\n@@ -279,1 +279,1 @@\n-        offset += tptr->_offset; \/\/ correct if base is offsetted\n+        offset += tptr->offset(); \/\/ correct if base is offsetted\n@@ -316,1 +316,5 @@\n-      Block *inb = get_block_for_node(mach->in(j));\n+      Block* inb = get_block_for_node(mach->in(j));\n+      if (mach->in(j)->is_Con() && mach->in(j)->req() == 1 && inb == get_block_for_node(mach)) {\n+        \/\/ Ignore constant loads scheduled in the same block (we can simply hoist them as well)\n+        continue;\n+      }\n@@ -409,0 +413,21 @@\n+\n+  \/\/ Hoist constant load inputs as well.\n+  for (uint i = 1; i < best->req(); ++i) {\n+    Node* n = best->in(i);\n+    if (n->is_Con() && get_block_for_node(n) == get_block_for_node(best)) {\n+      get_block_for_node(n)->find_remove(n);\n+      block->add_inst(n);\n+      map_node_to_block(n, block);\n+      \/\/ Constant loads may kill flags (for example, when XORing a register).\n+      \/\/ Check for flag-killing projections that also need to be hoisted.\n+      for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+        Node* proj = n->fast_out(j);\n+        if (proj->is_MachProj()) {\n+          get_block_for_node(proj)->find_remove(proj);\n+          block->add_inst(proj);\n+          map_node_to_block(proj, block);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -880,1 +905,1 @@\n-  uint r_cnt = mcall->tf()->range()->cnt();\n+  uint r_cnt = mcall->tf()->range_cc()->cnt();\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -320,0 +321,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:        return inline_unsafe_make_private_buffer();\n+  case vmIntrinsics::_finishPrivateBuffer:      return inline_unsafe_finish_private_buffer();\n@@ -329,0 +332,1 @@\n+  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n@@ -339,0 +343,1 @@\n+  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n@@ -512,0 +517,3 @@\n+  case vmIntrinsics::_asPrimaryType:\n+  case vmIntrinsics::_asValueType:              return inline_primitive_Class_conversion(intrinsic_id());\n+\n@@ -2158,0 +2166,1 @@\n+  bool null_free = false;\n@@ -2163,0 +2172,1 @@\n+      null_free = alias_type->field()->is_null_free();\n@@ -2171,0 +2181,1 @@\n+      null_free = adr_type->is_aryptr()->is_null_free();\n@@ -2183,0 +2194,3 @@\n+    if (null_free) {\n+      result = result->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n@@ -2237,2 +2251,2 @@\n-      assert(rtype == type, \"getter must return the expected value\");\n-      assert(sig->count() == 2, \"oop getter has 2 arguments\");\n+      assert(rtype == type || (rtype == T_OBJECT && type == T_PRIMITIVE_OBJECT), \"getter must return the expected value\");\n+      assert(sig->count() == 2 || (type == T_PRIMITIVE_OBJECT && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n@@ -2244,1 +2258,1 @@\n-      assert(sig->count() == 3, \"oop putter has 3 arguments\");\n+      assert(sig->count() == 3 || (type == T_PRIMITIVE_OBJECT && sig->count() == 4), \"oop putter has 3 arguments\");\n@@ -2248,1 +2262,1 @@\n-      assert(vtype == type, \"putter must accept the expected value\");\n+      assert(vtype == type || (type == T_PRIMITIVE_OBJECT && vtype == T_OBJECT), \"putter must accept the expected value\");\n@@ -2270,0 +2284,51 @@\n+\n+  ciInlineKlass* inline_klass = NULL;\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    const TypeInstPtr* cls = _gvn.type(argument(4))->isa_instptr();\n+    if (cls == NULL || cls->const_oop() == NULL) {\n+      return false;\n+    }\n+    ciType* mirror_type = cls->const_oop()->as_instance()->java_mirror_type();\n+    if (!mirror_type->is_inlinetype()) {\n+      return false;\n+    }\n+    inline_klass = mirror_type->as_inline_klass();\n+  }\n+\n+  if (base->is_InlineTypeBase()) {\n+    InlineTypeBaseNode* vt = base->as_InlineTypeBase();\n+    if (is_store) {\n+      if (!vt->is_allocated(&_gvn) || !_gvn.type(vt)->isa_inlinetype() || !_gvn.type(vt)->is_inlinetype()->larval()) {\n+        return false;\n+      }\n+      base = vt->get_oop();\n+    } else {\n+      if (offset->is_Con()) {\n+        long off = find_long_con(offset, 0);\n+        ciInlineKlass* vk = vt->type()->inline_klass();\n+        if ((long)(int)off != off || !vk->contains_field_offset(off)) {\n+          return false;\n+        }\n+\n+        ciField* field = vk->get_non_flattened_field_by_offset(off);\n+        if (field != NULL) {\n+          BasicType bt = field->layout_type();\n+          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flattened())) {\n+            bt = T_OBJECT;\n+          }\n+          if (bt == type && (bt != T_PRIMITIVE_OBJECT || field->type() == inline_klass)) {\n+            set_result(vt->field_value_by_offset(off, false));\n+            return true;\n+          }\n+        }\n+      }\n+      if (vt->is_InlineType()) {\n+        \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        vt = vt->buffer(this);\n+      }\n+      base = vt->get_oop();\n+    }\n+  }\n+\n@@ -2280,1 +2345,1 @@\n-    if (type != T_OBJECT) {\n+    if (type != T_OBJECT && (inline_klass == NULL || !inline_klass->has_object_fields())) {\n@@ -2298,1 +2363,1 @@\n-  Node* val = is_store ? argument(4) : NULL;\n+  Node* val = is_store ? argument(4 + (type == T_PRIMITIVE_OBJECT ? 1 : 0)) : NULL;\n@@ -2319,1 +2384,25 @@\n-  BasicType bt = alias_type->basic_type();\n+  BasicType bt = T_ILLEGAL;\n+  ciField* field = NULL;\n+  if (adr_type->isa_instptr()) {\n+    const TypeInstPtr* instptr = adr_type->is_instptr();\n+    ciInstanceKlass* k = instptr->instance_klass();\n+    int off = instptr->offset();\n+    if (instptr->const_oop() != NULL &&\n+        k == ciEnv::current()->Class_klass() &&\n+        instptr->offset() >= (k->size_helper() * wordSize)) {\n+      k = instptr->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+      field = k->get_field_by_offset(off, true);\n+    } else {\n+      field = k->get_non_flattened_field_by_offset(off);\n+    }\n+    if (field != NULL) {\n+      bt = field->layout_type();\n+    }\n+    assert(bt == alias_type->basic_type() || bt == T_PRIMITIVE_OBJECT, \"should match\");\n+    if (field != NULL && bt == T_PRIMITIVE_OBJECT && !field->is_flattened()) {\n+      bt = T_OBJECT;\n+    }\n+  } else {\n+    bt = alias_type->basic_type();\n+  }\n+\n@@ -2327,1 +2416,1 @@\n-    if (is_reference_type(bt, true)) {\n+    if (bt != T_PRIMITIVE_OBJECT && is_reference_type(bt, true)) {\n@@ -2342,0 +2431,25 @@\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    if (adr_type->isa_instptr()) {\n+      if (field == NULL || field->type() != inline_klass) {\n+        mismatched = true;\n+      }\n+    } else if (adr_type->isa_aryptr()) {\n+      const Type* elem = adr_type->is_aryptr()->elem();\n+      if (!elem->isa_inlinetype()) {\n+        mismatched = true;\n+      } else if (elem->inline_klass() != inline_klass) {\n+        mismatched = true;\n+      }\n+    } else {\n+      mismatched = true;\n+    }\n+    if (is_store) {\n+      const Type* val_t = _gvn.type(val);\n+      if (!(val_t->isa_inlinetype() || val_t->is_inlinetypeptr()) || val_t->inline_klass() != inline_klass) {\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -2343,1 +2457,1 @@\n-  assert(!mismatched || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  assert(!mismatched || type == T_PRIMITIVE_OBJECT || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -2355,4 +2469,8 @@\n-  if (!is_store && type == T_OBJECT) {\n-    const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);\n-    if (tjp != NULL) {\n-      value_type = tjp;\n+  if (!is_store) {\n+    if (type == T_OBJECT) {\n+      const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);\n+      if (tjp != NULL) {\n+        value_type = tjp;\n+      }\n+    } else if (type == T_PRIMITIVE_OBJECT) {\n+      value_type = NULL;\n@@ -2374,2 +2492,2 @@\n-    ciField* field = alias_type->field();\n-    if (heap_base_oop != top() && field != NULL && field->is_constant() && !mismatched) {\n+\n+    if (heap_base_oop != top() && field != NULL && field->is_constant() && !field->is_flattened() && !mismatched) {\n@@ -2381,1 +2499,16 @@\n-      p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n+      if (type == T_PRIMITIVE_OBJECT) {\n+        if (adr_type->isa_instptr() && !mismatched) {\n+          ciInstanceKlass* holder = adr_type->is_instptr()->instance_klass();\n+          int offset = adr_type->is_instptr()->offset();\n+          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, base, holder, offset, decorators);\n+        } else {\n+          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, NULL, 0, decorators);\n+        }\n+      } else {\n+        p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n+        const TypeOopPtr* ptr = value_type->make_oopptr();\n+        if (ptr != NULL && ptr->is_inlinetypeptr()) {\n+          \/\/ Load a non-flattened inline type from memory\n+          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass(), !ptr->maybe_null());\n+        }\n+      }\n@@ -2419,1 +2552,17 @@\n-    access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n+    if (type == T_PRIMITIVE_OBJECT) {\n+      if (adr_type->isa_instptr() && !mismatched) {\n+        ciInstanceKlass* holder = adr_type->is_instptr()->instance_klass();\n+        int offset = adr_type->is_instptr()->offset();\n+        val->as_InlineTypeBase()->store_flattened(this, base, base, holder, offset, decorators);\n+      } else {\n+        val->as_InlineTypeBase()->store_flattened(this, base, adr, NULL, 0, decorators);\n+      }\n+    } else {\n+      access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n+    }\n+  }\n+\n+  if (argument(1)->is_InlineType() && is_store) {\n+    InlineTypeBaseNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(base)->inline_klass());\n+    value = value->make_larval(this, false);\n+    replace_in_map(argument(1), value);\n@@ -2425,0 +2574,36 @@\n+bool LibraryCallKit::inline_unsafe_make_private_buffer() {\n+  Node* receiver = argument(0);\n+  Node* value = argument(1);\n+  if (!value->is_InlineTypeBase()) {\n+    return false;\n+  }\n+\n+  receiver = null_check(receiver);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n+  set_result(value->as_InlineTypeBase()->make_larval(this, true));\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_unsafe_finish_private_buffer() {\n+  Node* receiver = argument(0);\n+  Node* buffer = argument(1);\n+  if (!buffer->is_InlineType()) {\n+    return false;\n+  }\n+  InlineTypeNode* vt = buffer->as_InlineType();\n+  if (!vt->is_allocated(&_gvn) || !_gvn.type(vt)->is_inlinetype()->larval()) {\n+    return false;\n+  }\n+\n+  receiver = null_check(receiver);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n+  set_result(vt->finish_larval(this));\n+  return true;\n+}\n+\n@@ -2630,0 +2815,13 @@\n+    if (oldval != NULL && oldval->is_InlineType()) {\n+      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      oldval = oldval->as_InlineType()->buffer(this)->get_oop();\n+    }\n+    if (newval != NULL && newval->is_InlineType()) {\n+      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      newval = newval->as_InlineType()->buffer(this)->get_oop();\n+    }\n+\n@@ -2791,2 +2989,7 @@\n-\n-  Node* obj = new_instance(kls, test);\n+  Node* obj = NULL;\n+  ciKlass* klass = _gvn.type(kls)->is_klassptr()->klass();\n+  if (klass->is_inlinetype()) {\n+    obj = InlineTypeNode::make_default(_gvn, klass->as_inline_klass())->buffer(this);\n+  } else {\n+    obj = new_instance(kls, test);\n+  }\n@@ -3368,1 +3571,1 @@\n-  const Type* objects_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, objects_klass, xk, 0);\n+  const Type* objects_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, objects_klass, xk, TypeAryPtr::Offset(0));\n@@ -3387,9 +3590,0 @@\n-\/\/---------------------------load_mirror_from_klass----------------------------\n-\/\/ Given a klass oop, load its java mirror (a java.lang.Class oop).\n-Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {\n-  Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));\n-  Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n-  \/\/ mirror = ((OopHandle)mirror)->resolve();\n-  return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);\n-}\n-\n@@ -3438,0 +3632,1 @@\n+\n@@ -3631,0 +3826,29 @@\n+\/\/-------------------------inline_primitive_Class_conversion-------------------\n+\/\/ public Class<T> java.lang.Class.asPrimaryType();\n+\/\/ public Class<T> java.lang.Class.asValueType()\n+bool LibraryCallKit::inline_primitive_Class_conversion(vmIntrinsics::ID id) {\n+  Node* mirror = argument(0); \/\/ Receiver Class\n+  const TypeInstPtr* mirror_con = _gvn.type(mirror)->isa_instptr();\n+  if (mirror_con == NULL) {\n+    return false;\n+  }\n+\n+  bool is_val_mirror = true;\n+  ciType* tm = mirror_con->java_mirror_type(&is_val_mirror);\n+  if (tm != NULL) {\n+    Node* result = mirror;\n+    if (id == vmIntrinsics::_asPrimaryType && is_val_mirror) {\n+      result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->ref_mirror()));\n+    } else if (id == vmIntrinsics::_asValueType) {\n+      if (!tm->is_inlinetype()) {\n+        return false; \/\/ Throw UnsupportedOperationException\n+      } else if (!is_val_mirror) {\n+        result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->val_mirror()));\n+      }\n+    }\n+    set_result(result);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -3646,1 +3870,2 @@\n-  ciType* tm = mirror_con->java_mirror_type();\n+  bool requires_null_check = false;\n+  ciType* tm = mirror_con->java_mirror_type(&requires_null_check);\n@@ -3656,0 +3881,3 @@\n+        if (requires_null_check) {\n+          obj = null_check(obj);\n+        }\n@@ -3676,0 +3904,3 @@\n+  if (requires_null_check) {\n+    obj = null_check(obj);\n+  }\n@@ -3683,1 +3914,1 @@\n-  enum { _bad_type_path = 1, _prim_path = 2, PATH_LIMIT };\n+  enum { _bad_type_path = 1, _prim_path = 2, _npe_path = 3, PATH_LIMIT };\n@@ -3694,0 +3925,21 @@\n+    if (EnableValhalla && !requires_null_check) {\n+      \/\/ Check if we are casting to QMyValue\n+      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), NULL);\n+      if (ctrl_val_mirror != NULL) {\n+        RegionNode* r = new RegionNode(3);\n+        record_for_igvn(r);\n+        r->init_req(1, control());\n+\n+        \/\/ Casting to QMyValue, check for null\n+        set_control(ctrl_val_mirror);\n+        { \/\/ PreserveJVMState because null check replaces obj in map\n+          PreserveJVMState pjvms(this);\n+          Node* null_ctr = top();\n+          null_check_oop(obj, &null_ctr);\n+          region->init_req(_npe_path, null_ctr);\n+          r->init_req(2, control());\n+        }\n+        set_control(_gvn.transform(r));\n+      }\n+    }\n+\n@@ -3700,1 +3952,2 @@\n-      region->in(_bad_type_path) != top()) {\n+      region->in(_bad_type_path) != top() ||\n+      region->in(_npe_path) != top()) {\n@@ -3737,0 +3990,1 @@\n+  RegionNode* prim_region = new RegionNode(2);\n@@ -3739,0 +3993,1 @@\n+  record_for_igvn(prim_region);\n@@ -3763,2 +4018,5 @@\n-    int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);\n-    region->init_req(prim_path, null_ctl);\n+    if (which_arg == 0) {\n+      prim_region->init_req(1, null_ctl);\n+    } else {\n+      region->init_req(_prim_1_path, null_ctl);\n+    }\n@@ -3774,0 +4032,3 @@\n+    \/\/ If superc is an inline mirror, we also need to check if superc == subc because LMyValue\n+    \/\/ is not a subtype of QMyValue but due to subk == superk the subtype check will pass.\n+    generate_fair_guard(is_val_mirror(args[0]), prim_region);\n@@ -3781,1 +4042,2 @@\n-  set_control(region->in(_prim_0_path)); \/\/ go back to first null check\n+  \/\/ This path is also used if superc is a value mirror.\n+  set_control(_gvn.transform(prim_region));\n@@ -3786,1 +4048,1 @@\n-    generate_guard(bol_eq, region, PROB_FAIR);\n+    generate_fair_guard(bol_eq, region);\n@@ -3817,2 +4079,1 @@\n-Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region,\n-                                                  bool obj_array, bool not_array) {\n+Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind) {\n@@ -3824,9 +4085,0 @@\n-  \/\/ If obj_array\/non_array==false\/false:\n-  \/\/ Branch around if the given klass is in fact an array (either obj or prim).\n-  \/\/ If obj_array\/non_array==false\/true:\n-  \/\/ Branch around if the given klass is not an array klass of any kind.\n-  \/\/ If obj_array\/non_array==true\/true:\n-  \/\/ Branch around if the kls is not an oop array (kls is int[], String, etc.)\n-  \/\/ If obj_array\/non_array==true\/false:\n-  \/\/ Branch around if the kls is an oop array (Object[] or subtype)\n-  \/\/\n@@ -3837,4 +4089,11 @@\n-    bool query = (obj_array\n-                  ? Klass::layout_helper_is_objArray(layout_con)\n-                  : Klass::layout_helper_is_array(layout_con));\n-    if (query == not_array) {\n+    bool query = 0;\n+    switch(kind) {\n+      case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;\n+      case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;\n+      case TypeArray:      query = Klass::layout_helper_is_typeArray(layout_con); break;\n+      case AnyArray:       query = Klass::layout_helper_is_array(layout_con); break;\n+      case NonArray:       query = !Klass::layout_helper_is_array(layout_con); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    if (!query) {\n@@ -3850,0 +4109,21 @@\n+  unsigned int value = 0;\n+  BoolTest::mask btest = BoolTest::illegal;\n+  switch(kind) {\n+    case ObjectArray:\n+    case NonObjectArray: {\n+      value = Klass::_lh_array_tag_obj_value;\n+      layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n+      btest = (kind == ObjectArray) ? BoolTest::eq : BoolTest::ne;\n+      break;\n+    }\n+    case TypeArray: {\n+      value = Klass::_lh_array_tag_type_value;\n+      layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n+      btest = BoolTest::eq;\n+      break;\n+    }\n+    case AnyArray:    value = Klass::_lh_neutral_value; btest = BoolTest::lt; break;\n+    case NonArray:    value = Klass::_lh_neutral_value; btest = BoolTest::gt; break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -3851,4 +4131,1 @@\n-  jint  nval = (obj_array\n-                ? (jint)(Klass::_lh_array_tag_type_value\n-                   <<    Klass::_lh_array_tag_shift)\n-                : Klass::_lh_neutral_value);\n+  jint nval = (jint)value;\n@@ -3856,3 +4133,0 @@\n-  BoolTest::mask btest = BoolTest::lt;  \/\/ correct for testing is_[obj]array\n-  \/\/ invert the test if we are looking for a non-array\n-  if (not_array)  btest = BoolTest(btest).negate();\n@@ -3865,1 +4139,1 @@\n-\/\/ private static native Object java.lang.reflect.newArray(Class<?> componentType, int length);\n+\/\/ private static native Object java.lang.reflect.Array.newArray(Class<?> componentType, int length);\n@@ -4010,1 +4284,13 @@\n-    Node* not_objArray = generate_non_objArray_guard(klass_node, bailout);\n+    \/\/ Inline type array may have object field that would require a\n+    \/\/ write barrier. Conservatively, go to slow path.\n+    \/\/ TODO 8251971: Optimize for the case when flat src\/dst are later found\n+    \/\/ to not contain oops (i.e., move this check to the macro expansion phase).\n+    BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+    const TypeAryPtr* orig_t = _gvn.type(original)->isa_aryptr();\n+    ciKlass* klass = _gvn.type(klass_node)->is_klassptr()->klass();\n+    bool exclude_flat = UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, false, false, BarrierSetC2::Parsing) &&\n+                        \/\/ Can src array be flat and contain oops?\n+                        (orig_t == NULL || (!orig_t->is_not_flat() && (!orig_t->is_flat() || orig_t->elem()->inline_klass()->contains_oops()))) &&\n+                        \/\/ Can dest array be flat and contain oops?\n+                        klass->can_be_inline_array_klass() && (!klass->is_flat_array_klass() || klass->as_flat_array_klass()->element_klass()->as_inline_klass()->contains_oops());\n+    Node* not_objArray = exclude_flat ? generate_non_objArray_guard(klass_node, bailout) : generate_typeArray_guard(klass_node, bailout);\n@@ -4014,1 +4300,1 @@\n-      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, 0\/*offset*\/);\n+      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));\n@@ -4035,0 +4321,32 @@\n+    \/\/ Handle inline type arrays\n+    bool can_validate = !too_many_traps(Deoptimization::Reason_class_check);\n+    if (!stopped()) {\n+      orig_t = _gvn.type(original)->isa_aryptr();\n+      if (orig_t != NULL && orig_t->is_flat()) {\n+        \/\/ Src is flat, check that dest is flat as well\n+        if (exclude_flat) {\n+          \/\/ Dest can't be flat, bail out\n+          bailout->add_req(control());\n+          set_control(top());\n+        } else {\n+          generate_fair_guard(flat_array_test(klass_node, \/* flat = *\/ false), bailout);\n+        }\n+      } else if (UseFlatArray && (orig_t == NULL || !orig_t->is_not_flat()) &&\n+                 \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check if validated).\n+                 ((!klass->is_flat_array_klass() && klass->can_be_inline_array_klass()) || !can_validate)) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n+        generate_fair_guard(flat_array_test(load_object_klass(original)), bailout);\n+        if (orig_t != NULL) {\n+          orig_t = orig_t->cast_to_not_flat();\n+          original = _gvn.transform(new CheckCastPPNode(control(), original, orig_t));\n+        }\n+      }\n+      if (!can_validate) {\n+        \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n+        \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat\/null-free.\n+        generate_fair_guard(null_free_array_test(klass_node), bailout);\n+      }\n+    }\n+\n@@ -4077,1 +4395,1 @@\n-      if (!too_many_traps(Deoptimization::Reason_class_check)) {\n+      if (can_validate) {\n@@ -4216,1 +4534,6 @@\n-  Node* obj = NULL;\n+  Node* obj = argument(0);\n+\n+  if (obj->is_InlineType() || gvn().type(obj)->is_inlinetypeptr()) {\n+    return false;\n+  }\n+\n@@ -4226,1 +4549,0 @@\n-    obj = argument(0);\n@@ -4266,1 +4588,2 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+  \/\/ This also serves as guard against inline types\n+  Node *lock_mask      = _gvn.MakeConX(markWord::inline_type_mask_in_place);\n@@ -4332,1 +4655,10 @@\n-  Node* obj = null_check_receiver();\n+  Node* obj = argument(0);\n+  if (obj->is_InlineTypeBase()) {\n+    const Type* t = _gvn.type(obj);\n+    if (t->maybe_null()) {\n+      null_check(obj);\n+    }\n+    set_result(makecon(TypeInstPtr::make(t->inline_klass()->java_mirror())));\n+    return true;\n+  }\n+  obj = null_check_receiver();\n@@ -4689,1 +5021,6 @@\n-    Node* obj = null_check_receiver();\n+    Node* obj = argument(0);\n+    if (obj->is_InlineType()) {\n+      return false;\n+    }\n+\n+    obj = null_check_receiver();\n@@ -4699,1 +5036,2 @@\n-        obj_type->speculative_type()->is_instance_klass()) {\n+        obj_type->speculative_type()->is_instance_klass() &&\n+        !obj_type->speculative_type()->is_inlinetype()) {\n@@ -4729,0 +5067,5 @@\n+    \/\/ We only go to the fast case code if we pass a number of guards.\n+    \/\/ The paths which do not pass are accumulated in the slow_region.\n+    RegionNode* slow_region = new RegionNode(1);\n+    record_for_igvn(slow_region);\n+\n@@ -4734,3 +5077,0 @@\n-      Node* obj_length = load_array_length(obj);\n-      Node* obj_size  = NULL;\n-      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n@@ -4739,20 +5079,7 @@\n-      if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing)) {\n-        \/\/ If it is an oop array, it requires very special treatment,\n-        \/\/ because gc barriers are required when accessing the array.\n-        Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n-        if (is_obja != NULL) {\n-          PreserveJVMState pjvms2(this);\n-          set_control(is_obja);\n-          \/\/ Generate a direct call to the right arraycopy function(s).\n-          \/\/ Clones are always tightly coupled.\n-          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n-          ac->set_clone_oop_array();\n-          Node* n = _gvn.transform(ac);\n-          assert(n == ac, \"cannot disappear\");\n-          ac->connect_outputs(this, \/*deoptimize_on_exception=*\/true);\n-\n-          result_reg->init_req(_objArray_path, control());\n-          result_val->init_req(_objArray_path, alloc_obj);\n-          result_i_o ->set_req(_objArray_path, i_o());\n-          result_mem ->set_req(_objArray_path, reset_memory());\n-        }\n+      const TypeAryPtr* ary_ptr = obj_type->isa_aryptr();\n+      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Expansion) &&\n+          obj_type->klass()->can_be_inline_array_klass() &&\n+          (ary_ptr == NULL || (!ary_ptr->is_not_flat() && (!ary_ptr->is_flat() || ary_ptr->elem()->inline_klass()->contains_oops())))) {\n+        \/\/ Flattened inline type array may have object field that would require a\n+        \/\/ write barrier. Conservatively, go to slow path.\n+        generate_fair_guard(flat_array_test(obj_klass), slow_region);\n@@ -4760,7 +5087,0 @@\n-      \/\/ Otherwise, there are no barriers to worry about.\n-      \/\/ (We can dispense with card marks if we know the allocation\n-      \/\/  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks\n-      \/\/  causes the non-eden paths to take compensating steps to\n-      \/\/  simulate a fresh allocation, so that no further\n-      \/\/  card marks are required in compiled code to initialize\n-      \/\/  the object.)\n@@ -4769,7 +5089,43 @@\n-        copy_to_clone(obj, alloc_obj, obj_size, true);\n-\n-        \/\/ Present the results of the copy.\n-        result_reg->init_req(_array_path, control());\n-        result_val->init_req(_array_path, alloc_obj);\n-        result_i_o ->set_req(_array_path, i_o());\n-        result_mem ->set_req(_array_path, reset_memory());\n+        Node* obj_length = load_array_length(obj);\n+        Node* obj_size  = NULL;\n+        Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+\n+        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+        if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing)) {\n+          \/\/ If it is an oop array, it requires very special treatment,\n+          \/\/ because gc barriers are required when accessing the array.\n+          Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n+          if (is_obja != NULL) {\n+            PreserveJVMState pjvms2(this);\n+            set_control(is_obja);\n+            \/\/ Generate a direct call to the right arraycopy function(s).\n+            \/\/ Clones are always tightly coupled.\n+            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n+            ac->set_clone_oop_array();\n+            Node* n = _gvn.transform(ac);\n+            assert(n == ac, \"cannot disappear\");\n+            ac->connect_outputs(this, \/*deoptimize_on_exception=*\/true);\n+\n+            result_reg->init_req(_objArray_path, control());\n+            result_val->init_req(_objArray_path, alloc_obj);\n+            result_i_o ->set_req(_objArray_path, i_o());\n+            result_mem ->set_req(_objArray_path, reset_memory());\n+          }\n+        }\n+        \/\/ Otherwise, there are no barriers to worry about.\n+        \/\/ (We can dispense with card marks if we know the allocation\n+        \/\/  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks\n+        \/\/  causes the non-eden paths to take compensating steps to\n+        \/\/  simulate a fresh allocation, so that no further\n+        \/\/  card marks are required in compiled code to initialize\n+        \/\/  the object.)\n+\n+        if (!stopped()) {\n+          copy_to_clone(obj, alloc_obj, obj_size, true);\n+\n+          \/\/ Present the results of the copy.\n+          result_reg->init_req(_array_path, control());\n+          result_val->init_req(_array_path, alloc_obj);\n+          result_i_o ->set_req(_array_path, i_o());\n+          result_mem ->set_req(_array_path, reset_memory());\n+        }\n@@ -4779,4 +5135,0 @@\n-    \/\/ We only go to the instance fast case code if we pass a number of guards.\n-    \/\/ The paths which do not pass are accumulated in the slow_region.\n-    RegionNode* slow_region = new RegionNode(1);\n-    record_for_igvn(slow_region);\n@@ -4943,2 +5295,1 @@\n-    CallProjections callprojs;\n-    alloc->extract_projections(&callprojs, true);\n+    CallProjections* callprojs = alloc->extract_projections(true);\n@@ -4947,1 +5298,1 @@\n-    C->gvn_replace_by(callprojs.fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n+    C->gvn_replace_by(callprojs->fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -4989,1 +5340,1 @@\n-    set_i_o(callprojs.fallthrough_ioproj);\n+    set_i_o(callprojs->fallthrough_ioproj);\n@@ -5165,0 +5516,2 @@\n+          src_type = _gvn.type(src);\n+          top_src = src_type->isa_aryptr();\n@@ -5168,0 +5521,2 @@\n+          dest_type = _gvn.type(dest);\n+          top_dest = dest_type->isa_aryptr();\n@@ -5183,2 +5538,1 @@\n-      can_emit_guards &&\n-      !src->is_top() && !dest->is_top()) {\n+      can_emit_guards && !src->is_top() && !dest->is_top()) {\n@@ -5227,0 +5581,2 @@\n+      slow_region->add_req(not_subtype_ctrl);\n+    }\n@@ -5228,6 +5584,31 @@\n-      if (not_subtype_ctrl != top()) {\n-        PreserveJVMState pjvms(this);\n-        set_control(not_subtype_ctrl);\n-        uncommon_trap(Deoptimization::Reason_intrinsic,\n-                      Deoptimization::Action_make_not_entrant);\n-        assert(stopped(), \"Should be stopped\");\n+    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->is_klassptr();\n+    const Type* toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n+    if (toop->isa_aryptr() != NULL) {\n+      toop = toop->is_aryptr()->cast_to_not_flat(false)->cast_to_not_null_free(false);\n+    }\n+    src = _gvn.transform(new CheckCastPPNode(control(), src, toop));\n+    src_type = _gvn.type(src);\n+    top_src  = src_type->isa_aryptr();\n+\n+    \/\/ Handle flat inline type arrays (null-free arrays are handled by the subtype check above)\n+    if (!stopped() && UseFlatArray) {\n+      \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check). Handle flat src here.\n+      assert(top_dest == NULL || !top_dest->is_flat() || top_src->is_flat(), \"src array must be flat\");\n+      if (top_src != NULL && top_src->is_flat()) {\n+        \/\/ Src is flat, check that dest is flat as well\n+        if (top_dest != NULL && !top_dest->is_flat()) {\n+          generate_fair_guard(flat_array_test(dest_klass, \/* flat = *\/ false), slow_region);\n+          \/\/ Since dest is flat and src <: dest, dest must have the same type as src.\n+          top_dest = TypeOopPtr::make_from_klass(top_src->klass())->isa_aryptr();\n+          assert(top_dest->is_flat(), \"dest must be flat\");\n+          dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));\n+        }\n+      } else if (top_src == NULL || !top_src->is_not_flat()) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n+        assert(top_dest == NULL || !top_dest->is_flat(), \"dest array must not be flat\");\n+        generate_fair_guard(flat_array_test(src), slow_region);\n+        if (top_src != NULL) {\n+          top_src = top_src->cast_to_not_flat();\n+          src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));\n+        }\n@@ -5236,0 +5617,1 @@\n+\n@@ -5243,4 +5625,0 @@\n-\n-    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->is_klassptr();\n-    const Type *toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n-    src = _gvn.transform(new CheckCastPPNode(control(), src, toop));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":503,"deletions":125,"binary":false,"changes":628,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -108,3 +109,11 @@\n-    if (!stopped() && result() != NULL) {\n-      BasicType bt = result()->bottom_type()->basic_type();\n-      push_node(bt, result());\n+    Node* res = result();\n+    if (!stopped() && res != NULL) {\n+      BasicType bt = res->bottom_type()->basic_type();\n+      if (C->inlining_incrementally() && res->is_InlineType()) {\n+        \/\/ The caller expects an oop when incrementally inlining an intrinsic that returns an\n+        \/\/ inline type. Make sure the call is re-executed if the allocation triggers a deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        res = res->as_InlineType()->buffer(this);\n+      }\n+      push_node(bt, res);\n@@ -141,1 +150,0 @@\n-  Node* load_mirror_from_klass(Node* klass);\n@@ -163,0 +171,9 @@\n+\n+  enum ArrayKind {\n+    AnyArray,\n+    NonArray,\n+    ObjectArray,\n+    NonObjectArray,\n+    TypeArray\n+  };\n+\n@@ -164,0 +181,1 @@\n+\n@@ -165,1 +183,1 @@\n-    return generate_array_guard_common(kls, region, false, false);\n+    return generate_array_guard_common(kls, region, AnyArray);\n@@ -168,1 +186,1 @@\n-    return generate_array_guard_common(kls, region, false, true);\n+    return generate_array_guard_common(kls, region, NonArray);\n@@ -171,1 +189,1 @@\n-    return generate_array_guard_common(kls, region, true, false);\n+    return generate_array_guard_common(kls, region, ObjectArray);\n@@ -174,1 +192,4 @@\n-    return generate_array_guard_common(kls, region, true, true);\n+    return generate_array_guard_common(kls, region, NonObjectArray);\n+  }\n+  Node* generate_typeArray_guard(Node* kls, RegionNode* region) {\n+    return generate_array_guard_common(kls, region, TypeArray);\n@@ -176,2 +197,1 @@\n-  Node* generate_array_guard_common(Node* kls, RegionNode* region,\n-                                    bool obj_array, bool not_array);\n+  Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);\n@@ -237,0 +257,2 @@\n+  bool inline_unsafe_make_private_buffer();\n+  bool inline_unsafe_finish_private_buffer();\n@@ -253,0 +275,1 @@\n+  bool inline_primitive_Class_conversion(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -152,0 +152,8 @@\n+const Type* FastLockNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(1))->is_inlinetypeptr()) {\n+    \/\/ Locking on inline types always fails\n+    return TypeInt::CC_GT;\n+  }\n+  return TypeInt::CC;\n+}\n+\n@@ -182,0 +190,8 @@\n+  Node* obj = peek();\n+  const Type* obj_type = gvn().type(obj);\n+  if (obj_type->isa_inlinetype() || obj_type->is_inlinetypeptr()) {\n+    uncommon_trap(Deoptimization::Reason_class_check,\n+                  Deoptimization::Action_none);\n+    return;\n+  }\n+\n@@ -185,1 +201,1 @@\n-  Node* obj = null_check(peek());\n+  obj = null_check(obj);\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const { return TypeInt::CC; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,4 @@\n-         LoopNestInnerLoop = 1 << 18,\n-         LoopNestLongOuterLoop = 1 << 19};\n+         LoopNestInnerLoop   = 1<< 18,\n+         LoopNestLongOuterLoop = 1<< 19,\n+         FlattenedArrays     = 1<<20};\n+\n@@ -108,0 +110,1 @@\n+  bool is_flattened_arrays() const { return _loop_flags & FlattenedArrays; }\n@@ -125,0 +128,1 @@\n+  void mark_flattened_arrays() { _loop_flags |= FlattenedArrays; }\n@@ -1431,3 +1435,3 @@\n-                                        Node_List &old_new,\n-                                        IfNode* unswitch_iff,\n-                                        CloneLoopMode mode);\n+                                      Node_List &old_new,\n+                                      Node_List &unswitch_iffs,\n+                                      CloneLoopMode mode);\n@@ -1451,1 +1455,1 @@\n-  IfNode* find_unswitching_candidate(const IdealLoopTree *loop) const;\n+  IfNode* find_unswitching_candidate(const IdealLoopTree *loop, Node_List& unswitch_iffs) const;\n@@ -1574,0 +1578,1 @@\n+  void move_flat_array_check_out_of_loop(Node* n);\n@@ -1575,0 +1580,1 @@\n+  bool flatten_array_element_type_check(Node *n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -64,0 +65,6 @@\n+  \/\/ Inline types should not be split through Phis because they cannot be merged\n+  \/\/ through Phi nodes but each value input needs to be merged individually.\n+  if (n->is_InlineType()) {\n+    return NULL;\n+  }\n+\n@@ -999,0 +1006,49 @@\n+\/\/ If UseArrayMarkWordCheck is enabled, we can't use immutable memory for the flat array check\n+\/\/ because we are loading the mark word which is mutable. Although the bits we are interested in\n+\/\/ are immutable (we check for markWord::unlocked_value), we need to use raw memory to not break\n+\/\/ anti dependency analysis. Below code will attempt to still move flat array checks out of loops,\n+\/\/ mainly to enable loop unswitching.\n+void PhaseIdealLoop::move_flat_array_check_out_of_loop(Node* n) {\n+  \/\/ Skip checks for more than one array\n+  if (n->req() > 3) {\n+    return;\n+  }\n+  Node* mem = n->in(FlatArrayCheckNode::Memory);\n+  Node* array = n->in(FlatArrayCheckNode::ArrayOrKlass)->uncast();\n+  IdealLoopTree* check_loop = get_loop(get_ctrl(n));\n+  IdealLoopTree* ary_loop = get_loop(get_ctrl(array));\n+\n+  \/\/ Check if array is loop invariant\n+  if (!check_loop->is_member(ary_loop)) {\n+    \/\/ Walk up memory graph from the check until we leave the loop\n+    VectorSet wq;\n+    wq.set(mem->_idx);\n+    while (check_loop->is_member(get_loop(ctrl_or_self(mem)))) {\n+      if (mem->is_Phi()) {\n+        mem = mem->in(1);\n+      } else if (mem->is_MergeMem()) {\n+        mem = mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw);\n+      } else if (mem->is_Proj()) {\n+        mem = mem->in(0);\n+      } else if (mem->is_MemBar() || mem->is_SafePoint()) {\n+        mem = mem->in(TypeFunc::Memory);\n+      } else if (mem->is_Store() || mem->is_LoadStore() || mem->is_ClearArray()) {\n+        mem = mem->in(MemNode::Memory);\n+      } else {\n+#ifdef ASSERT\n+        mem->dump();\n+#endif\n+        ShouldNotReachHere();\n+      }\n+      if (wq.test_set(mem->_idx)) {\n+        return;\n+      }\n+    }\n+    \/\/ Replace memory input and re-compute ctrl to move the check out of the loop\n+    _igvn.replace_input_of(n, 1, mem);\n+    set_ctrl_and_loop(n, get_early_ctrl(n));\n+    Node* bol = n->unique_out();\n+    set_ctrl_and_loop(bol, get_early_ctrl(bol));\n+  }\n+}\n+\n@@ -1011,0 +1067,6 @@\n+\n+  if (UseArrayMarkWordCheck && n->isa_FlatArrayCheck()) {\n+    move_flat_array_check_out_of_loop(n);\n+    return n;\n+  }\n+\n@@ -1289,0 +1351,96 @@\n+bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {\n+  \/\/ If the CmpP is a subtype check for a value that has just been\n+  \/\/ loaded from an array, the subtype check guarantees the value\n+  \/\/ can't be stored in a flattened array and the load of the value\n+  \/\/ happens with a flattened array check then: push the type check\n+  \/\/ through the phi of the flattened array check. This needs special\n+  \/\/ logic because the subtype check's input is not a phi but a\n+  \/\/ LoadKlass that must first be cloned through the phi.\n+  if (n->Opcode() != Op_CmpP) {\n+    return false;\n+  }\n+\n+  Node* klassptr = n->in(1);\n+  Node* klasscon = n->in(2);\n+\n+  if (klassptr->is_DecodeNarrowPtr()) {\n+    klassptr = klassptr->in(1);\n+  }\n+\n+  if (klassptr->Opcode() != Op_LoadKlass && klassptr->Opcode() != Op_LoadNKlass) {\n+    return false;\n+  }\n+\n+  if (!klasscon->is_Con()) {\n+    return false;\n+  }\n+\n+  Node* addr = klassptr->in(MemNode::Address);\n+\n+  if (!addr->is_AddP()) {\n+    return false;\n+  }\n+\n+  intptr_t offset;\n+  Node* obj = AddPNode::Ideal_base_and_offset(addr, &_igvn, offset);\n+\n+  if (obj == NULL) {\n+    return false;\n+  }\n+\n+  assert(obj != NULL && addr->in(AddPNode::Base) == addr->in(AddPNode::Address), \"malformed AddP?\");\n+  if (obj->Opcode() == Op_CastPP) {\n+    obj = obj->in(1);\n+  }\n+\n+  if (!obj->is_Phi()) {\n+    return false;\n+  }\n+\n+  Node* region = obj->in(0);\n+\n+  Node* phi = PhiNode::make_blank(region, n->in(1));\n+  for (uint i = 1; i < region->req(); i++) {\n+    Node* in = obj->in(i);\n+    Node* ctrl = region->in(i);\n+    if (addr->in(AddPNode::Base) != obj) {\n+      Node* cast = addr->in(AddPNode::Base);\n+      assert(cast->Opcode() == Op_CastPP && cast->in(0) != NULL, \"inconsistent subgraph\");\n+      Node* cast_clone = cast->clone();\n+      cast_clone->set_req(0, ctrl);\n+      cast_clone->set_req(1, in);\n+      register_new_node(cast_clone, ctrl);\n+      _igvn.set_type(cast_clone, cast_clone->Value(&_igvn));\n+      in = cast_clone;\n+    }\n+    Node* addr_clone = addr->clone();\n+    addr_clone->set_req(AddPNode::Base, in);\n+    addr_clone->set_req(AddPNode::Address, in);\n+    register_new_node(addr_clone, ctrl);\n+    _igvn.set_type(addr_clone, addr_clone->Value(&_igvn));\n+    Node* klassptr_clone = klassptr->clone();\n+    klassptr_clone->set_req(2, addr_clone);\n+    register_new_node(klassptr_clone, ctrl);\n+    _igvn.set_type(klassptr_clone, klassptr_clone->Value(&_igvn));\n+    if (klassptr != n->in(1)) {\n+      Node* decode = n->in(1);\n+      assert(decode->is_DecodeNarrowPtr(), \"inconsistent subgraph\");\n+      Node* decode_clone = decode->clone();\n+      decode_clone->set_req(1, klassptr_clone);\n+      register_new_node(decode_clone, ctrl);\n+      _igvn.set_type(decode_clone, decode_clone->Value(&_igvn));\n+      klassptr_clone = decode_clone;\n+    }\n+    phi->set_req(i, klassptr_clone);\n+  }\n+  register_new_node(phi, region);\n+  Node* orig = n->in(1);\n+  _igvn.replace_input_of(n, 1, phi);\n+  split_if_with_blocks_post(n);\n+  if (n->outcnt() != 0) {\n+    _igvn.replace_input_of(n, 1, orig);\n+    _igvn.remove_dead_node(phi);\n+  }\n+  return true;\n+}\n+\n@@ -1295,0 +1453,4 @@\n+  if (flatten_array_element_type_check(n)) {\n+    return;\n+  }\n+\n@@ -1430,0 +1592,5 @@\n+  \/\/ Remove multiple allocations of the same inline type\n+  if (n->is_InlineType()) {\n+    n->as_InlineType()->remove_redundant_allocations(&_igvn, this);\n+  }\n+\n@@ -1868,1 +2035,9 @@\n-  Node *sample_cmp = sample_bool->in(1);\n+  Node* sample_cmp = sample_bool->in(1);\n+  const Type* t = Type::TOP;\n+  const TypePtr* at = NULL;\n+  if (sample_cmp->is_FlatArrayCheck()) {\n+    \/\/ Left input of a FlatArrayCheckNode is memory, set the (adr) type of the phi accordingly\n+    assert(sample_cmp->in(1)->bottom_type() == Type::MEMORY, \"unexpected input type\");\n+    t = Type::MEMORY;\n+    at = TypeRawPtr::BOTTOM;\n+  }\n@@ -1871,1 +2046,1 @@\n-  PhiNode *phi1 = new PhiNode(phi->in(0), Type::TOP);\n+  PhiNode *phi1 = new PhiNode(phi->in(0), t, at);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":177,"deletions":2,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -386,0 +386,16 @@\n+  if (tp->isa_aryptr()) {\n+    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ own slice so we need to extract the field being accessed from\n+    \/\/ the address computation\n+    if (offset == Type::OffsetBot) {\n+      Node* base;\n+      Node* index;\n+      const MachOper* oper = memory_inputs(base, index);\n+      if (oper != (MachOper*)-1) {\n+        offset = oper->constant_disp();\n+        return tp->is_aryptr()->add_field_offset_and_offset(offset)->add_offset(Type::OffsetBot);\n+      }\n+    }\n+    return tp->is_aryptr()->add_field_offset_and_offset(offset);\n+  }\n+\n@@ -672,2 +688,2 @@\n-const Type *MachCallNode::bottom_type() const { return tf()->range(); }\n-const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()->range(); }\n+const Type *MachCallNode::bottom_type() const { return tf()->range_cc(); }\n+const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()->range_cc(); }\n@@ -684,2 +700,1 @@\n-#ifndef _LP64\n-  if (tf()->range()->cnt() == TypeFunc::Parms) {\n+  if (tf()->range_sig()->cnt() == TypeFunc::Parms) {\n@@ -701,1 +716,0 @@\n-#endif\n@@ -707,1 +721,1 @@\n-  const TypeTuple *r = tf()->range();\n+  const TypeTuple *r = tf()->range_sig();\n@@ -712,0 +726,4 @@\n+bool MachCallNode::returns_scalarized() const {\n+  return tf()->returns_inline_type_as_fields();\n+}\n+\n@@ -716,1 +734,6 @@\n-  if (idx < tf()->domain()->cnt()) {\n+  if (entry_point() == NULL && idx == TypeFunc::Parms) {\n+    \/\/ Null entry point is a special cast where the target of the call\n+    \/\/ is in a register.\n+    return MachNode::in_RegMask(idx);\n+  }\n+  if (idx < tf()->domain_sig()->cnt()) {\n@@ -749,1 +772,1 @@\n-  if (idx < tf()->domain()->cnt()) {\n+  if (idx < tf()->domain_cc()->cnt()) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class MachVEPNode;\n@@ -489,0 +490,30 @@\n+\/\/------------------------------MachVEPNode-----------------------------------\n+\/\/ Machine Inline Type Entry Point Node\n+class MachVEPNode : public MachIdealNode {\n+public:\n+  Label* _verified_entry;\n+\n+  MachVEPNode(Label* verified_entry, bool verified, bool receiver_only) :\n+    _verified_entry(verified_entry),\n+    _verified(verified),\n+    _receiver_only(receiver_only) {\n+    init_class_id(Class_MachVEP);\n+  }\n+  virtual bool cmp(const Node &n) const {\n+    return (_verified_entry == ((MachVEPNode&)n)._verified_entry) &&\n+           (_verified == ((MachVEPNode&)n)._verified) &&\n+           (_receiver_only == ((MachVEPNode&)n)._receiver_only) &&\n+           MachIdealNode::cmp(n);\n+  }\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual void emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const;\n+\n+#ifndef PRODUCT\n+  virtual const char* Name() const { return \"InlineType Entry-Point\"; }\n+  virtual void format(PhaseRegAlloc*, outputStream* st) const;\n+#endif\n+private:\n+  bool   _verified;\n+  bool   _receiver_only;\n+};\n+\n@@ -495,1 +526,0 @@\n-  virtual uint size(PhaseRegAlloc *ra_) const;\n@@ -507,1 +537,9 @@\n-  MachPrologNode( ) {}\n+  Label* _verified_entry;\n+\n+  MachPrologNode(Label* verified_entry) : _verified_entry(verified_entry) {\n+    init_class_id(Class_MachProlog);\n+  }\n+  virtual bool cmp(const Node &n) const {\n+    return (_verified_entry == ((MachPrologNode&)n)._verified_entry) && MachIdealNode::cmp(n);\n+  }\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -509,1 +547,0 @@\n-  virtual uint size(PhaseRegAlloc *ra_) const;\n@@ -524,1 +561,0 @@\n-  virtual uint size(PhaseRegAlloc *ra_) const;\n@@ -912,1 +948,1 @@\n-  NOT_LP64(bool return_value_is_used() const;)\n+  bool return_value_is_used() const;\n@@ -916,0 +952,1 @@\n+  bool returns_scalarized() const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -88,12 +91,0 @@\n-void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {\n-  assert(old != NULL, \"sanity\");\n-  for (DUIterator_Fast imax, i = old->fast_outs(imax); i < imax; i++) {\n-    Node* use = old->fast_out(i);\n-    _igvn.rehash_node_delayed(use);\n-    imax -= replace_input(use, old, target);\n-    \/\/ back up iterator\n-    --i;\n-  }\n-  assert(old->outcnt() == 0, \"all uses must be deleted\");\n-}\n-\n@@ -162,1 +153,1 @@\n-  bs->eliminate_gc_barrier(this, p2x);\n+  bs->eliminate_gc_barrier(&_igvn, p2x);\n@@ -216,1 +207,1 @@\n-        int adr_offset = atype->offset();\n+        int adr_offset = atype->flattened_offset();\n@@ -261,1 +252,1 @@\n-   } else if (mem->Opcode() == Op_StrInflatedCopy) {\n+    } else if (mem->Opcode() == Op_StrInflatedCopy) {\n@@ -306,1 +297,7 @@\n-      const TypePtr* adr_type = NULL;\n+      Node* base = ac->in(ArrayCopyNode::Src);\n+      const TypePtr* adr_type = _igvn.type(base)->is_ptr();\n+      assert(adr_type->isa_aryptr(), \"only arrays here\");\n+      if (adr_type->is_aryptr()->is_flat()) {\n+        ciFlatArrayKlass* vak = adr_type->is_aryptr()->klass()->as_flat_array_klass();\n+        shift = vak->log2_element_size();\n+      }\n@@ -309,2 +306,2 @@\n-        Node* base = ac->in(ArrayCopyNode::Src);\n-        adr_type = _igvn.type(base)->is_ptr()->add_offset(off);\n+        adr_type = _igvn.type(adr)->is_ptr();\n+        assert(adr_type == _igvn.type(base)->is_aryptr()->add_field_offset_and_offset(off), \"incorrect address type\");\n@@ -317,0 +314,5 @@\n+        if (ac->in(ArrayCopyNode::Src) == ac->in(ArrayCopyNode::Dest)) {\n+          \/\/ Non constant offset in the array: we can't statically\n+          \/\/ determine the value\n+          return NULL;\n+        }\n@@ -324,7 +326,5 @@\n-        Node* base = ac->in(ArrayCopyNode::Src);\n-        adr_type = _igvn.type(base)->is_ptr()->add_offset(Type::OffsetBot);\n-        if (ac->in(ArrayCopyNode::Src) == ac->in(ArrayCopyNode::Dest)) {\n-          \/\/ Non constant offset in the array: we can't statically\n-          \/\/ determine the value\n-          return NULL;\n-        }\n+        \/\/ In the case of a flattened inline type array, each field has its\n+        \/\/ own slice so we need to extract the field being accessed from\n+        \/\/ the address computation\n+        adr_type = adr_type->is_aryptr()->add_field_offset_and_offset(offset)->add_offset(Type::OffsetBot);\n+        adr = _igvn.transform(new CastPPNode(adr, adr_type));\n@@ -341,0 +341,1 @@\n+      assert(res->isa_DecodeN(), \"should be narrow oop\");\n@@ -356,1 +357,1 @@\n-  int offset = adr_t->offset();\n+  int offset = adr_t->flattened_offset();\n@@ -395,1 +396,7 @@\n-        values.at_put(j, _igvn.zerocon(ft));\n+        Node* default_value = alloc->in(AllocateNode::DefaultValue);\n+        if (default_value != NULL) {\n+          values.at_put(j, default_value);\n+        } else {\n+          assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+          values.at_put(j, _igvn.zerocon(ft));\n+        }\n@@ -415,1 +422,7 @@\n-        values.at_put(j, _igvn.zerocon(ft));\n+        Node* default_value = alloc->in(AllocateNode::DefaultValue);\n+        if (default_value != NULL) {\n+          values.at_put(j, default_value);\n+        } else {\n+          assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+          values.at_put(j, _igvn.zerocon(ft));\n+        }\n@@ -459,1 +472,1 @@\n-  int offset = adr_t->offset();\n+  int offset = adr_t->flattened_offset();\n@@ -461,1 +474,0 @@\n-  Node *alloc_ctrl = alloc->in(TypeFunc::Control);\n@@ -477,1 +489,1 @@\n-        done = true; \/\/ Something go wrong.\n+        done = true; \/\/ Something went wrong.\n@@ -487,1 +499,1 @@\n-             atype->is_known_instance_field() && atype->offset() == offset &&\n+             atype->is_known_instance_field() && atype->flattened_offset() == offset &&\n@@ -520,0 +532,5 @@\n+      Node* default_value = alloc->in(AllocateNode::DefaultValue);\n+      if (default_value != NULL) {\n+        return default_value;\n+      }\n+      assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n@@ -551,1 +568,1 @@\n-  \/\/ Something go wrong.\n+  \/\/ Something went wrong.\n@@ -555,0 +572,42 @@\n+\/\/ Search the last value stored into the inline type's fields.\n+Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {\n+  \/\/ Subtract the offset of the first field to account for the missing oop header\n+  offset -= vk->first_field_offset();\n+  \/\/ Create a new InlineTypeNode and retrieve the field values from memory\n+  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk)->as_InlineType();\n+  transform_later(vt);\n+  for (int i = 0; i < vk->nof_declared_nonstatic_fields(); ++i) {\n+    ciType* field_type = vt->field_type(i);\n+    int field_offset = offset + vt->field_offset(i);\n+    Node* value = NULL;\n+    if (vt->field_is_flattened(i)) {\n+      value = inline_type_from_mem(mem, ctl, field_type->as_inline_klass(), adr_type, field_offset, alloc);\n+    } else {\n+      const Type* ft = Type::get_const_type(field_type);\n+      BasicType bt = type2field[field_type->basic_type()];\n+      if (UseCompressedOops && !is_java_primitive(bt)) {\n+        ft = ft->make_narrowoop();\n+        bt = T_NARROWOOP;\n+      }\n+      \/\/ Each inline type field has its own memory slice\n+      adr_type = adr_type->with_field_offset(field_offset);\n+      value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);\n+      if (value != NULL && ft->isa_narrowoop()) {\n+        assert(UseCompressedOops, \"unexpected narrow oop\");\n+        if (value->is_EncodeP()) {\n+          value = value->in(1);\n+        } else {\n+          value = transform_later(new DecodeNNode(value, value->get_ptr_type()));\n+        }\n+      }\n+    }\n+    if (value != NULL) {\n+      vt->set_field_value(i, value);\n+    } else {\n+      \/\/ We might have reached the TrackedInitializationLimit\n+      return NULL;\n+    }\n+  }\n+  return vt;\n+}\n+\n@@ -563,0 +622,1 @@\n+  Unique_Node_List worklist;\n@@ -571,0 +631,1 @@\n+    worklist.push(res);\n@@ -584,3 +645,3 @@\n-  if (can_eliminate && res != NULL) {\n-    for (DUIterator_Fast jmax, j = res->fast_outs(jmax);\n-                               j < jmax && can_eliminate; j++) {\n+  while (can_eliminate && worklist.size() > 0) {\n+    res = worklist.pop();\n+    for (DUIterator_Fast jmax, j = res->fast_outs(jmax); j < jmax && can_eliminate; j++) {\n@@ -635,0 +696,8 @@\n+      } else if (use->is_InlineType() && use->isa_InlineType()->get_oop() == res) {\n+        \/\/ ok to eliminate\n+      } else if (use->is_InlineTypePtr() && use->isa_InlineTypePtr()->get_oop() == res) {\n+        \/\/ Process users\n+        worklist.push(use);\n+      } else if (use->Opcode() == Op_StoreX && use->in(MemNode::Address) == res) {\n+        \/\/ Store to mark word of inline type larval buffer\n+        assert(res_type->is_inlinetypeptr(), \"Unexpected store to mark word\");\n@@ -646,1 +715,1 @@\n-          }else {\n+          } else {\n@@ -652,0 +721,3 @@\n+      } else {\n+        assert(use->Opcode() == Op_CastP2X, \"should be\");\n+        assert(!use->has_out_with(Op_OrL), \"should have been removed because oop is never null\");\n@@ -664,1 +736,1 @@\n-    } else if (alloc->_is_scalar_replaceable) {\n+    } else {\n@@ -710,0 +782,3 @@\n+      if (basic_elem_type == T_PRIMITIVE_OBJECT && !res_type->is_aryptr()->is_flat()) {\n+        basic_elem_type = T_OBJECT;\n+      }\n@@ -713,0 +788,4 @@\n+      if (res_type->is_aryptr()->is_flat()) {\n+        \/\/ Flattened inline type array\n+        element_size = res_type->is_aryptr()->klass()->as_flat_array_klass()->element_byte_size();\n+      }\n@@ -718,0 +797,2 @@\n+  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr(), \"Inline type allocations should not have safepoint uses\");\n+  Unique_Node_List value_worklist;\n@@ -744,0 +825,1 @@\n+        assert(!field->is_flattened(), \"flattened inline type fields should not have safepoint uses\");\n@@ -769,3 +851,9 @@\n-      const TypeOopPtr *field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n-\n-      Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n+      Node* field_val = NULL;\n+      const TypeOopPtr* field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n+      if (res_type->isa_aryptr() && res_type->is_aryptr()->is_flat()) {\n+        ciInlineKlass* vk = res_type->is_aryptr()->elem()->inline_klass();\n+        assert(vk->flatten_array(), \"must be flattened\");\n+        field_val = inline_type_from_mem(mem, ctl, vk, field_addr_type->isa_aryptr(), 0, alloc);\n+      } else {\n+        field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n+      }\n@@ -834,1 +922,1 @@\n-        } else {\n+        } else if (!field_val->is_InlineTypeBase()) {\n@@ -838,0 +926,4 @@\n+      if (field_val->is_InlineTypeBase()) {\n+        \/\/ Keep track of inline types to scalarize them later\n+        value_worklist.push(field_val);\n+      }\n@@ -850,0 +942,8 @@\n+  \/\/ Scalarize inline types that were added to the safepoint.\n+  \/\/ Don't allow linking a constant oop (if available) for flat array elements\n+  \/\/ because Deoptimization::reassign_flat_array_elements needs field values.\n+  bool allow_oop = res_type != NULL && (!res_type->isa_aryptr() || !res_type->is_aryptr()->is_flat());\n+  for (uint i = 0; i < value_worklist.size(); ++i) {\n+    InlineTypeBaseNode* vt = value_worklist.at(i)->as_InlineTypeBase();\n+    vt->make_scalar_in_safepoints(&_igvn, allow_oop);\n+  }\n@@ -865,1 +965,2 @@\n-void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {\n+void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc, bool inline_alloc) {\n+  Unique_Node_List worklist;\n@@ -868,0 +969,4 @@\n+    worklist.push(res);\n+  }\n+  while (worklist.size() > 0) {\n+    res = worklist.pop();\n@@ -877,10 +982,7 @@\n-#ifdef ASSERT\n-            \/\/ Verify that there is no dependent MemBarVolatile nodes,\n-            \/\/ they should be removed during IGVN, see MemBarNode::Ideal().\n-            for (DUIterator_Fast pmax, p = n->fast_outs(pmax);\n-                                       p < pmax; p++) {\n-              Node* mb = n->fast_out(p);\n-              assert(mb->is_Initialize() || !mb->is_MemBar() ||\n-                     mb->req() <= MemBarNode::Precedent ||\n-                     mb->in(MemBarNode::Precedent) != n,\n-                     \"MemBarVolatile should be eliminated for non-escaping object\");\n+            for (DUIterator_Fast pmax, p = n->fast_outs(pmax); p < pmax; p++) {\n+              MemBarNode* mb = n->fast_out(p)->isa_MemBar();\n+              if (mb != NULL && mb->req() <= MemBarNode::Precedent && mb->in(MemBarNode::Precedent) == n) {\n+                \/\/ MemBarVolatiles should have been removed by MemBarNode::Ideal() for non-inline allocations\n+                assert(inline_alloc, \"MemBarVolatile should be eliminated for non-escaping object\");\n+                mb->remove(&_igvn);\n+              }\n@@ -888,1 +990,0 @@\n-#endif\n@@ -912,2 +1013,1 @@\n-          CallProjections callprojs;\n-          ac->extract_projections(&callprojs, true);\n+          CallProjections* callprojs = ac->extract_projections(true);\n@@ -915,3 +1015,3 @@\n-          _igvn.replace_node(callprojs.fallthrough_ioproj, ac->in(TypeFunc::I_O));\n-          _igvn.replace_node(callprojs.fallthrough_memproj, ac->in(TypeFunc::Memory));\n-          _igvn.replace_node(callprojs.fallthrough_catchproj, ac->in(TypeFunc::Control));\n+          _igvn.replace_node(callprojs->fallthrough_ioproj, ac->in(TypeFunc::I_O));\n+          _igvn.replace_node(callprojs->fallthrough_memproj, ac->in(TypeFunc::Memory));\n+          _igvn.replace_node(callprojs->fallthrough_catchproj, ac->in(TypeFunc::Control));\n@@ -934,0 +1034,14 @@\n+      } else if (use->is_InlineType()) {\n+        assert(use->isa_InlineType()->get_oop() == res, \"unexpected inline type use\");\n+        _igvn.rehash_node_delayed(use);\n+        use->isa_InlineType()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n+      } else if (use->is_InlineTypePtr()) {\n+        assert(use->isa_InlineTypePtr()->get_oop() == res, \"unexpected inline type ptr use\");\n+        _igvn.rehash_node_delayed(use);\n+        use->isa_InlineTypePtr()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n+        \/\/ Process users\n+        worklist.push(use);\n+      } else if (use->Opcode() == Op_StoreX && use->in(MemNode::Address) == res) {\n+        \/\/ Store to mark word of inline type larval buffer\n+        assert(inline_alloc, \"Unexpected store to mark word\");\n+        _igvn.replace_node(use, use->in(MemNode::Memory));\n@@ -946,1 +1060,1 @@\n-  if (_callprojs.resproj != NULL && _callprojs.resproj->outcnt() != 0) {\n+  if (_callprojs->resproj[0] != NULL && _callprojs->resproj[0]->outcnt() != 0) {\n@@ -950,2 +1064,2 @@\n-    for (DUIterator_Fast jmax, j = _callprojs.resproj->fast_outs(jmax);  j < jmax; j++) {\n-      Node* use = _callprojs.resproj->fast_out(j);\n+    for (DUIterator_Fast jmax, j = _callprojs->resproj[0]->fast_outs(jmax);  j < jmax; j++) {\n+      Node* use = _callprojs->resproj[0]->fast_out(j);\n@@ -958,3 +1072,3 @@\n-    for (DUIterator_Last jmin, j = _callprojs.resproj->last_outs(jmin); j >= jmin; ) {\n-      Node* use = _callprojs.resproj->last_out(j);\n-      uint oc1 = _callprojs.resproj->outcnt();\n+    for (DUIterator_Last jmin, j = _callprojs->resproj[0]->last_outs(jmin); j >= jmin; ) {\n+      Node* use = _callprojs->resproj[0]->last_out(j);\n+      uint oc1 = _callprojs->resproj[0]->outcnt();\n@@ -971,1 +1085,1 @@\n-          assert(tmp == NULL || tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n+          assert(tmp == NULL || tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n@@ -979,1 +1093,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem->in(TypeFunc::Memory) == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -981,1 +1095,1 @@\n-            assert(mem == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -986,0 +1100,4 @@\n+      } else if (use->Opcode() == Op_MemBarStoreStore) {\n+        \/\/ Inline type buffer allocations are followed by a membar\n+        assert(inline_alloc, \"Unexpected MemBarStoreStore\");\n+        use->as_MemBar()->remove(&_igvn);\n@@ -989,1 +1107,1 @@\n-      j -= (oc1 - _callprojs.resproj->outcnt());\n+      j -= (oc1 - _callprojs->resproj[0]->outcnt());\n@@ -992,2 +1110,2 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_catchproj, alloc->in(TypeFunc::Control));\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, alloc->in(TypeFunc::Control));\n@@ -995,2 +1113,2 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, alloc->in(TypeFunc::Memory));\n+  if (_callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_memproj, alloc->in(TypeFunc::Memory));\n@@ -998,2 +1116,2 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n-    _igvn.replace_node(_callprojs.catchall_memproj, C->top());\n+  if (_callprojs->catchall_memproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_memproj, C->top());\n@@ -1001,2 +1119,2 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -1004,2 +1122,2 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n-    _igvn.replace_node(_callprojs.catchall_ioproj, C->top());\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_ioproj, C->top());\n@@ -1007,2 +1125,2 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n-    _igvn.replace_node(_callprojs.catchall_catchproj, C->top());\n+  if (_callprojs->catchall_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_catchproj, C->top());\n@@ -1018,1 +1136,1 @@\n-  if (!EliminateAllocations || !alloc->_is_non_escaping) {\n+  if (!EliminateAllocations) {\n@@ -1023,1 +1141,7 @@\n-  Node* res = alloc->result_cast();\n+\n+  \/\/ Attempt to eliminate inline type buffer allocations\n+  \/\/ regardless of usage and escape\/replaceable status.\n+  bool inline_alloc = tklass->klass()->is_inlinetype();\n+  if (!alloc->_is_non_escaping && !inline_alloc) {\n+    return false;\n+  }\n@@ -1026,1 +1150,2 @@\n-  bool boxing_alloc = C->eliminate_boxing() &&\n+  Node* res = alloc->result_cast();\n+  bool boxing_alloc = (res == NULL) && C->eliminate_boxing() &&\n@@ -1033,1 +1158,1 @@\n-  alloc->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = alloc->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1041,1 +1166,1 @@\n-    assert(res == NULL, \"sanity\");\n+    assert(res == NULL || inline_alloc, \"sanity\");\n@@ -1046,0 +1171,1 @@\n+      assert(!inline_alloc, \"Inline type allocations should not have safepoint uses\");\n@@ -1066,1 +1192,1 @@\n-  process_users_of_allocation(alloc);\n+  process_users_of_allocation(alloc, inline_alloc);\n@@ -1088,1 +1214,1 @@\n-  boxing->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = boxing->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1090,1 +1216,1 @@\n-  const TypeTuple* r = boxing->tf()->range();\n+  const TypeTuple* r = boxing->tf()->range_sig();\n@@ -1274,1 +1400,1 @@\n-    IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n+    IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n@@ -1277,1 +1403,1 @@\n-    Node *toobig_true = new IfTrueNode( toobig_iff );\n+    Node* toobig_true = new IfTrueNode(toobig_iff);\n@@ -1280,1 +1406,1 @@\n-    toobig_false = new IfFalseNode( toobig_iff );\n+    toobig_false = new IfFalseNode(toobig_iff);\n@@ -1319,0 +1445,1 @@\n+\n@@ -1376,0 +1503,3 @@\n+  } else {\n+    \/\/ Let the runtime know if this is a larval allocation\n+    call->init_req(TypeFunc::Parms+1, _igvn.intcon(alloc->_larval));\n@@ -1407,1 +1537,1 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1413,2 +1543,2 @@\n-  if (expand_fast_path && _callprojs.fallthrough_memproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_memproj, result_phi_rawmem);\n+  if (expand_fast_path && _callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_memproj, result_phi_rawmem);\n@@ -1418,4 +1548,4 @@\n-  if (_callprojs.catchall_memproj != NULL ) {\n-    if (_callprojs.fallthrough_memproj == NULL) {\n-      _callprojs.fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n-      transform_later(_callprojs.fallthrough_memproj);\n+  if (_callprojs->catchall_memproj != NULL) {\n+    if (_callprojs->fallthrough_memproj == NULL) {\n+      _callprojs->fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n+      transform_later(_callprojs->fallthrough_memproj);\n@@ -1423,2 +1553,2 @@\n-    migrate_outs(_callprojs.catchall_memproj, _callprojs.fallthrough_memproj);\n-    _igvn.remove_dead_node(_callprojs.catchall_memproj);\n+    _igvn.replace_in_uses(_callprojs->catchall_memproj, _callprojs->fallthrough_memproj);\n+    _igvn.remove_dead_node(_callprojs->catchall_memproj);\n@@ -1432,2 +1562,2 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_ioproj, result_phi_i_o);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_ioproj, result_phi_i_o);\n@@ -1437,4 +1567,4 @@\n-  if (_callprojs.catchall_ioproj != NULL ) {\n-    if (_callprojs.fallthrough_ioproj == NULL) {\n-      _callprojs.fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n-      transform_later(_callprojs.fallthrough_ioproj);\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    if (_callprojs->fallthrough_ioproj == NULL) {\n+      _callprojs->fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n+      transform_later(_callprojs->fallthrough_ioproj);\n@@ -1442,2 +1572,2 @@\n-    migrate_outs(_callprojs.catchall_ioproj, _callprojs.fallthrough_ioproj);\n-    _igvn.remove_dead_node(_callprojs.catchall_ioproj);\n+    _igvn.replace_in_uses(_callprojs->catchall_ioproj, _callprojs->fallthrough_ioproj);\n+    _igvn.remove_dead_node(_callprojs->catchall_ioproj);\n@@ -1462,2 +1592,2 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n-    ctrl = _callprojs.fallthrough_catchproj->clone();\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    ctrl = _callprojs->fallthrough_catchproj->clone();\n@@ -1465,1 +1595,1 @@\n-    _igvn.replace_node(_callprojs.fallthrough_catchproj, result_region);\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, result_region);\n@@ -1470,1 +1600,1 @@\n-  if (_callprojs.resproj == NULL) {\n+  if (_callprojs->resproj[0] == NULL) {\n@@ -1474,1 +1604,1 @@\n-    slow_result = _callprojs.resproj->clone();\n+    slow_result = _callprojs->resproj[0]->clone();\n@@ -1476,1 +1606,1 @@\n-    _igvn.replace_node(_callprojs.resproj, result_phi_rawoop);\n+    _igvn.replace_node(_callprojs->resproj[0], result_phi_rawoop);\n@@ -1486,1 +1616,1 @@\n-  result_phi_rawmem->init_req(slow_result_path, _callprojs.fallthrough_memproj);\n+  result_phi_rawmem->init_req(slow_result_path, _callprojs->fallthrough_memproj);\n@@ -1498,4 +1628,4 @@\n-  alloc->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n-  if (_callprojs.resproj != NULL) {\n-    for (DUIterator_Fast imax, i = _callprojs.resproj->fast_outs(imax); i < imax; i++) {\n-      Node* use = _callprojs.resproj->fast_out(i);\n+  _callprojs = alloc->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  if (_callprojs->resproj[0] != NULL) {\n+    for (DUIterator_Fast imax, i = _callprojs->resproj[0]->fast_outs(imax); i < imax; i++) {\n+      Node* use = _callprojs->resproj[0]->fast_out(i);\n@@ -1506,2 +1636,2 @@\n-    assert(_callprojs.resproj->outcnt() == 0, \"all uses must be deleted\");\n-    _igvn.remove_dead_node(_callprojs.resproj);\n+    assert(_callprojs->resproj[0]->outcnt() == 0, \"all uses must be deleted\");\n+    _igvn.remove_dead_node(_callprojs->resproj[0]);\n@@ -1509,3 +1639,3 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_catchproj, ctrl);\n-    _igvn.remove_dead_node(_callprojs.fallthrough_catchproj);\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_catchproj, ctrl);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_catchproj);\n@@ -1513,3 +1643,3 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n-    _igvn.rehash_node_delayed(_callprojs.catchall_catchproj);\n-    _callprojs.catchall_catchproj->set_req(0, top());\n+  if (_callprojs->catchall_catchproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_catchproj);\n+    _callprojs->catchall_catchproj->set_req(0, top());\n@@ -1517,2 +1647,2 @@\n-  if (_callprojs.fallthrough_proj != NULL) {\n-    Node* catchnode = _callprojs.fallthrough_proj->unique_ctrl_out();\n+  if (_callprojs->fallthrough_proj != NULL) {\n+    Node* catchnode = _callprojs->fallthrough_proj->unique_ctrl_out();\n@@ -1520,1 +1650,1 @@\n-    _igvn.remove_dead_node(_callprojs.fallthrough_proj);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_proj);\n@@ -1522,3 +1652,3 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_memproj, mem);\n-    _igvn.remove_dead_node(_callprojs.fallthrough_memproj);\n+  if (_callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_memproj, mem);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_memproj);\n@@ -1526,3 +1656,3 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_ioproj, i_o);\n-    _igvn.remove_dead_node(_callprojs.fallthrough_ioproj);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_ioproj, i_o);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_ioproj);\n@@ -1530,3 +1660,3 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n-    _igvn.rehash_node_delayed(_callprojs.catchall_memproj);\n-    _callprojs.catchall_memproj->set_req(0, top());\n+  if (_callprojs->catchall_memproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_memproj);\n+    _callprojs->catchall_memproj->set_req(0, top());\n@@ -1534,3 +1664,3 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n-    _igvn.rehash_node_delayed(_callprojs.catchall_ioproj);\n-    _callprojs.catchall_ioproj->set_req(0, top());\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_ioproj);\n+    _callprojs->catchall_ioproj->set_req(0, top());\n@@ -1654,5 +1784,4 @@\n-Node*\n-PhaseMacroExpand::initialize_object(AllocateNode* alloc,\n-                                    Node* control, Node* rawmem, Node* object,\n-                                    Node* klass_node, Node* length,\n-                                    Node* size_in_bytes) {\n+Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,\n+                                          Node* control, Node* rawmem, Node* object,\n+                                          Node* klass_node, Node* length,\n+                                          Node* size_in_bytes) {\n@@ -1661,1 +1790,1 @@\n-  Node* mark_node = alloc->make_ideal_mark(&_igvn, object, control, rawmem);\n+  Node* mark_node = alloc->make_ideal_mark(&_igvn, control, rawmem);\n@@ -1697,0 +1826,2 @@\n+                                            alloc->in(AllocateNode::DefaultValue),\n+                                            alloc->in(AllocateNode::RawDefaultValue),\n@@ -2066,0 +2197,43 @@\n+void PhaseMacroExpand::inline_type_guard(Node** ctrl, LockNode* lock) {\n+  Node* obj = lock->obj_node();\n+  const TypePtr* obj_type = _igvn.type(obj)->make_ptr();\n+  if (!obj_type->can_be_inline_type()) {\n+    return;\n+  }\n+  Node* mark = make_load(*ctrl, lock->memory(), obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n+  Node* value_mask = _igvn.MakeConX(markWord::inline_type_pattern);\n+  Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));\n+  Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));\n+  Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  Node* unc_ctrl = generate_slow_guard(ctrl, bol, NULL);\n+\n+  int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+  address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+  const TypePtr* no_memory_effects = NULL;\n+  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\",\n+                                         no_memory_effects);\n+  unc->init_req(TypeFunc::Control, unc_ctrl);\n+  unc->init_req(TypeFunc::I_O, lock->i_o());\n+  unc->init_req(TypeFunc::Memory, lock->memory());\n+  unc->init_req(TypeFunc::FramePtr,  lock->in(TypeFunc::FramePtr));\n+  unc->init_req(TypeFunc::ReturnAdr, lock->in(TypeFunc::ReturnAdr));\n+  unc->init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));\n+  unc->set_cnt(PROB_UNLIKELY_MAG(4));\n+  unc->copy_call_debug_info(&_igvn, lock);\n+\n+  assert(unc->peek_monitor_box() == lock->box_node(), \"wrong monitor\");\n+  assert((obj_type->is_inlinetypeptr() && unc->peek_monitor_obj()->is_SafePointScalarObject()) ||\n+         (obj->is_InlineTypePtr() && obj->in(1) == unc->peek_monitor_obj()) ||\n+         (obj == unc->peek_monitor_obj()), \"wrong monitor\");\n+\n+  \/\/ pop monitor and push obj back on stack: we trap before the monitorenter\n+  unc->pop_monitor();\n+  unc->grow_stack(unc->jvms(), 1);\n+  unc->set_stack(unc->jvms(), unc->jvms()->stk_size()-1, obj);\n+  _igvn.register_new_node_with_optimizer(unc);\n+\n+  unc_ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));\n+  Node* halt = _igvn.transform(new HaltNode(unc_ctrl, lock->in(TypeFunc::FramePtr), \"monitor enter on inline type\"));\n+  C->root()->add_req(halt);\n+}\n+\n@@ -2097,1 +2271,1 @@\n-  alock->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = alock->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2101,2 +2275,2 @@\n-         _callprojs.fallthrough_proj != NULL &&\n-         _callprojs.fallthrough_memproj != NULL,\n+         _callprojs->fallthrough_proj != NULL &&\n+         _callprojs->fallthrough_memproj != NULL,\n@@ -2105,2 +2279,2 @@\n-  Node* fallthroughproj = _callprojs.fallthrough_proj;\n-  Node* memproj_fallthrough = _callprojs.fallthrough_memproj;\n+  Node* fallthroughproj = _callprojs->fallthrough_proj;\n+  Node* memproj_fallthrough = _callprojs->fallthrough_memproj;\n@@ -2112,0 +2286,3 @@\n+    \/\/ Deoptimize and re-execute if object is an inline type\n+    inline_type_guard(&ctrl, alock->as_Lock());\n+\n@@ -2172,0 +2349,3 @@\n+  \/\/ Deoptimize and re-execute if object is an inline type\n+  inline_type_guard(&slow_path, lock);\n+\n@@ -2177,1 +2357,1 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2183,2 +2363,2 @@\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n+         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2189,1 +2369,1 @@\n-  Node *slow_ctrl = _callprojs.fallthrough_proj->clone();\n+  Node *slow_ctrl = _callprojs->fallthrough_proj->clone();\n@@ -2191,2 +2371,2 @@\n-  _igvn.hash_delete(_callprojs.fallthrough_proj);\n-  _callprojs.fallthrough_proj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs->fallthrough_proj);\n+  _callprojs->fallthrough_proj->disconnect_inputs(C);\n@@ -2196,1 +2376,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_proj, region);\n+  _igvn.replace_node(_callprojs->fallthrough_proj, region);\n@@ -2204,1 +2384,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, mem_phi);\n@@ -2237,3 +2417,3 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n+         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2245,1 +2425,1 @@\n-  Node *slow_ctrl = _callprojs.fallthrough_proj->clone();\n+  Node *slow_ctrl = _callprojs->fallthrough_proj->clone();\n@@ -2247,2 +2427,2 @@\n-  _igvn.hash_delete(_callprojs.fallthrough_proj);\n-  _callprojs.fallthrough_proj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs->fallthrough_proj);\n+  _callprojs->fallthrough_proj->disconnect_inputs(C);\n@@ -2252,1 +2432,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_proj, region);\n+  _igvn.replace_node(_callprojs->fallthrough_proj, region);\n@@ -2259,1 +2439,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, mem_phi);\n@@ -2262,0 +2442,200 @@\n+\/\/ An inline type might be returned from the call but we don't know its\n+\/\/ type. Either we get a buffered inline type (and nothing needs to be done)\n+\/\/ or one of the inlines being returned is the klass of the inline type\n+\/\/ and we need to allocate an inline type instance of that type and\n+\/\/ initialize it with other values being returned. In that case, we\n+\/\/ first try a fast path allocation and initialize the value with the\n+\/\/ inline klass's pack handler or we fall back to a runtime call.\n+void PhaseMacroExpand::expand_mh_intrinsic_return(CallStaticJavaNode* call) {\n+  assert(call->method()->is_method_handle_intrinsic(), \"must be a method handle intrinsic call\");\n+  Node* ret = call->proj_out_or_null(TypeFunc::Parms);\n+  if (ret == NULL) {\n+    return;\n+  }\n+  const TypeFunc* tf = call->_tf;\n+  const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n+  const TypeFunc* new_tf = TypeFunc::make(tf->domain_sig(), tf->domain_cc(), tf->range_sig(), domain);\n+  call->_tf = new_tf;\n+  \/\/ Make sure the change of type is applied before projections are processed by igvn\n+  _igvn.set_type(call, call->Value(&_igvn));\n+  _igvn.set_type(ret, ret->Value(&_igvn));\n+\n+  \/\/ Before any new projection is added:\n+  CallProjections* projs = call->extract_projections(true, true);\n+\n+  \/\/ Create temporary hook nodes that will be replaced below.\n+  \/\/ Add an input to prevent hook nodes from being dead.\n+  Node* ctl = new Node(call);\n+  Node* mem = new Node(ctl);\n+  Node* io = new Node(ctl);\n+  Node* ex_ctl = new Node(ctl);\n+  Node* ex_mem = new Node(ctl);\n+  Node* ex_io = new Node(ctl);\n+  Node* res = new Node(ctl);\n+\n+  \/\/ Allocate a new buffered inline type only if a new one is not returned\n+  Node* cast = transform_later(new CastP2XNode(ctl, res));\n+  Node* mask = MakeConX(0x1);\n+  Node* masked = transform_later(new AndXNode(cast, mask));\n+  Node* cmp = transform_later(new CmpXNode(masked, mask));\n+  Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n+  IfNode* allocation_iff = new IfNode(ctl, bol, PROB_MAX, COUNT_UNKNOWN);\n+  transform_later(allocation_iff);\n+  Node* allocation_ctl = transform_later(new IfTrueNode(allocation_iff));\n+  Node* no_allocation_ctl = transform_later(new IfFalseNode(allocation_iff));\n+  Node* no_allocation_res = transform_later(new CheckCastPPNode(no_allocation_ctl, res, TypeInstPtr::BOTTOM));\n+\n+  \/\/ Try to allocate a new buffered inline instance either from TLAB or eden space\n+  Node* needgc_ctrl = NULL; \/\/ needgc means slowcase, i.e. allocation failed\n+  CallLeafNoFPNode* handler_call;\n+  const bool alloc_in_place = UseTLAB;\n+  if (alloc_in_place) {\n+    Node* fast_oop_ctrl = NULL;\n+    Node* fast_oop_rawmem = NULL;\n+    Node* mask2 = MakeConX(-2);\n+    Node* masked2 = transform_later(new AndXNode(cast, mask2));\n+    Node* rawklassptr = transform_later(new CastX2PNode(masked2));\n+    Node* klass_node = transform_later(new CheckCastPPNode(allocation_ctl, rawklassptr, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    Node* layout_val = make_load(NULL, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);\n+    Node* size_in_bytes = ConvI2X(layout_val);\n+    BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+    Node* fast_oop = bs->obj_allocate(this, mem, allocation_ctl, size_in_bytes, io, needgc_ctrl,\n+                                      fast_oop_ctrl, fast_oop_rawmem,\n+                                      AllocateInstancePrefetchLines);\n+    \/\/ Allocation succeed, initialize buffered inline instance header firstly,\n+    \/\/ and then initialize its fields with an inline class specific handler\n+    Node* mark_node = makecon(TypeRawPtr::make((address)markWord::inline_type_prototype().value()));\n+    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::mark_offset_in_bytes(), mark_node, T_ADDRESS);\n+    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+    if (UseCompressedClassPointers) {\n+      fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);\n+    }\n+    Node* fixed_block  = make_load(fast_oop_ctrl, fast_oop_rawmem, klass_node, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);\n+    Node* pack_handler = make_load(fast_oop_ctrl, fast_oop_rawmem, fixed_block, in_bytes(InlineKlass::pack_handler_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);\n+    handler_call = new CallLeafNoFPNode(OptoRuntime::pack_inline_type_Type(),\n+                                        NULL,\n+                                        \"pack handler\",\n+                                        TypeRawPtr::BOTTOM);\n+    handler_call->init_req(TypeFunc::Control, fast_oop_ctrl);\n+    handler_call->init_req(TypeFunc::Memory, fast_oop_rawmem);\n+    handler_call->init_req(TypeFunc::I_O, top());\n+    handler_call->init_req(TypeFunc::FramePtr, call->in(TypeFunc::FramePtr));\n+    handler_call->init_req(TypeFunc::ReturnAdr, top());\n+    handler_call->init_req(TypeFunc::Parms, pack_handler);\n+    handler_call->init_req(TypeFunc::Parms+1, fast_oop);\n+  } else {\n+    needgc_ctrl = allocation_ctl;\n+  }\n+\n+  \/\/ Allocation failed, fall back to a runtime call\n+  CallStaticJavaNode* slow_call = new CallStaticJavaNode(OptoRuntime::store_inline_type_fields_Type(),\n+                                                         StubRoutines::store_inline_type_fields_to_buf(),\n+                                                         \"store_inline_type_fields\",\n+                                                         TypePtr::BOTTOM);\n+  slow_call->init_req(TypeFunc::Control, needgc_ctrl);\n+  slow_call->init_req(TypeFunc::Memory, mem);\n+  slow_call->init_req(TypeFunc::I_O, io);\n+  slow_call->init_req(TypeFunc::FramePtr, call->in(TypeFunc::FramePtr));\n+  slow_call->init_req(TypeFunc::ReturnAdr, call->in(TypeFunc::ReturnAdr));\n+  slow_call->init_req(TypeFunc::Parms, res);\n+\n+  Node* slow_ctl = transform_later(new ProjNode(slow_call, TypeFunc::Control));\n+  Node* slow_mem = transform_later(new ProjNode(slow_call, TypeFunc::Memory));\n+  Node* slow_io = transform_later(new ProjNode(slow_call, TypeFunc::I_O));\n+  Node* slow_res = transform_later(new ProjNode(slow_call, TypeFunc::Parms));\n+  Node* slow_catc = transform_later(new CatchNode(slow_ctl, slow_io, 2));\n+  Node* slow_norm = transform_later(new CatchProjNode(slow_catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci));\n+  Node* slow_excp = transform_later(new CatchProjNode(slow_catc, CatchProjNode::catch_all_index,    CatchProjNode::no_handler_bci));\n+\n+  Node* ex_r = new RegionNode(3);\n+  Node* ex_mem_phi = new PhiNode(ex_r, Type::MEMORY, TypePtr::BOTTOM);\n+  Node* ex_io_phi = new PhiNode(ex_r, Type::ABIO);\n+  ex_r->init_req(1, slow_excp);\n+  ex_mem_phi->init_req(1, slow_mem);\n+  ex_io_phi->init_req(1, slow_io);\n+  ex_r->init_req(2, ex_ctl);\n+  ex_mem_phi->init_req(2, ex_mem);\n+  ex_io_phi->init_req(2, ex_io);\n+  transform_later(ex_r);\n+  transform_later(ex_mem_phi);\n+  transform_later(ex_io_phi);\n+\n+  \/\/ We don't know how many values are returned. This assumes the\n+  \/\/ worst case, that all available registers are used.\n+  for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+    if (domain->field_at(i) == Type::HALF) {\n+      slow_call->init_req(i, top());\n+      if (alloc_in_place) {\n+        handler_call->init_req(i+1, top());\n+      }\n+      continue;\n+    }\n+    Node* proj = transform_later(new ProjNode(call, i));\n+    slow_call->init_req(i, proj);\n+    if (alloc_in_place) {\n+      handler_call->init_req(i+1, proj);\n+    }\n+  }\n+  \/\/ We can safepoint at that new call\n+  slow_call->copy_call_debug_info(&_igvn, call);\n+  transform_later(slow_call);\n+  if (alloc_in_place) {\n+    transform_later(handler_call);\n+  }\n+\n+  Node* fast_ctl = NULL;\n+  Node* fast_res = NULL;\n+  MergeMemNode* fast_mem = NULL;\n+  if (alloc_in_place) {\n+    fast_ctl = transform_later(new ProjNode(handler_call, TypeFunc::Control));\n+    Node* rawmem = transform_later(new ProjNode(handler_call, TypeFunc::Memory));\n+    fast_res = transform_later(new ProjNode(handler_call, TypeFunc::Parms));\n+    fast_mem = MergeMemNode::make(mem);\n+    fast_mem->set_memory_at(Compile::AliasIdxRaw, rawmem);\n+    transform_later(fast_mem);\n+  }\n+\n+  Node* r = new RegionNode(alloc_in_place ? 4 : 3);\n+  Node* mem_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);\n+  Node* io_phi = new PhiNode(r, Type::ABIO);\n+  Node* res_phi = new PhiNode(r, TypeInstPtr::BOTTOM);\n+  r->init_req(1, no_allocation_ctl);\n+  mem_phi->init_req(1, mem);\n+  io_phi->init_req(1, io);\n+  res_phi->init_req(1, no_allocation_res);\n+  r->init_req(2, slow_norm);\n+  mem_phi->init_req(2, slow_mem);\n+  io_phi->init_req(2, slow_io);\n+  res_phi->init_req(2, slow_res);\n+  if (alloc_in_place) {\n+    r->init_req(3, fast_ctl);\n+    mem_phi->init_req(3, fast_mem);\n+    io_phi->init_req(3, io);\n+    res_phi->init_req(3, fast_res);\n+  }\n+  transform_later(r);\n+  transform_later(mem_phi);\n+  transform_later(io_phi);\n+  transform_later(res_phi);\n+\n+  assert(projs->nb_resproj == 1, \"unexpected number of results\");\n+  _igvn.replace_in_uses(projs->fallthrough_catchproj, r);\n+  _igvn.replace_in_uses(projs->fallthrough_memproj, mem_phi);\n+  _igvn.replace_in_uses(projs->fallthrough_ioproj, io_phi);\n+  _igvn.replace_in_uses(projs->resproj[0], res_phi);\n+  _igvn.replace_in_uses(projs->catchall_catchproj, ex_r);\n+  _igvn.replace_in_uses(projs->catchall_memproj, ex_mem_phi);\n+  _igvn.replace_in_uses(projs->catchall_ioproj, ex_io_phi);\n+  \/\/ The CatchNode should not use the ex_io_phi. Re-connect it to the catchall_ioproj.\n+  Node* cn = projs->fallthrough_catchproj->in(0);\n+  _igvn.replace_input_of(cn, 1, projs->catchall_ioproj);\n+\n+  _igvn.replace_node(ctl, projs->fallthrough_catchproj);\n+  _igvn.replace_node(mem, projs->fallthrough_memproj);\n+  _igvn.replace_node(io, projs->fallthrough_ioproj);\n+  _igvn.replace_node(res, projs->resproj[0]);\n+  _igvn.replace_node(ex_ctl, projs->catchall_catchproj);\n+  _igvn.replace_node(ex_mem, projs->catchall_memproj);\n+  _igvn.replace_node(ex_io, projs->catchall_ioproj);\n+ }\n+\n@@ -2287,1 +2667,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2299,0 +2679,101 @@\n+\/\/ FlatArrayCheckNode (array1 array2 ...) is expanded into:\n+\/\/\n+\/\/ long mark = array1.mark | array2.mark | ...;\n+\/\/ long locked_bit = markWord::unlocked_value & array1.mark & array2.mark & ...;\n+\/\/ if (locked_bit == 0) {\n+\/\/   \/\/ One array is locked, load prototype header from the klass\n+\/\/   mark = array1.klass.proto | array2.klass.proto | ...\n+\/\/ }\n+\/\/ if ((mark & markWord::flat_array_bit_in_place) == 0) {\n+\/\/    ...\n+\/\/ }\n+void PhaseMacroExpand::expand_flatarraycheck_node(FlatArrayCheckNode* check) {\n+  bool array_inputs = _igvn.type(check->in(FlatArrayCheckNode::ArrayOrKlass))->isa_oopptr() != NULL;\n+  if (UseArrayMarkWordCheck && array_inputs) {\n+    Node* mark = MakeConX(0);\n+    Node* locked_bit = MakeConX(markWord::unlocked_value);\n+    Node* mem = check->in(FlatArrayCheckNode::Memory);\n+    for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+      Node* ary = check->in(i);\n+      const TypeOopPtr* t = _igvn.type(ary)->isa_oopptr();\n+      assert(t != NULL, \"Mixing array and klass inputs\");\n+      assert(!t->is_flat() && !t->is_not_flat(), \"Should have been optimized out\");\n+      Node* mark_adr = basic_plus_adr(ary, oopDesc::mark_offset_in_bytes());\n+      Node* mark_load = _igvn.transform(LoadNode::make(_igvn, NULL, mem, mark_adr, mark_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+      mark = _igvn.transform(new OrXNode(mark, mark_load));\n+      locked_bit = _igvn.transform(new AndXNode(locked_bit, mark_load));\n+    }\n+    assert(!mark->is_Con(), \"Should have been optimized out\");\n+    Node* cmp = _igvn.transform(new CmpXNode(locked_bit, MakeConX(0)));\n+    Node* is_unlocked = _igvn.transform(new BoolNode(cmp, BoolTest::ne));\n+\n+    \/\/ BoolNode might be shared, replace each if user\n+    Node* old_bol = check->unique_out();\n+    assert(old_bol->is_Bool() && old_bol->as_Bool()->_test._test == BoolTest::ne, \"unexpected condition\");\n+    for (DUIterator_Last imin, i = old_bol->last_outs(imin); i >= imin; --i) {\n+      IfNode* old_iff = old_bol->last_out(i)->as_If();\n+      Node* ctrl = old_iff->in(0);\n+      RegionNode* region = new RegionNode(3);\n+      Node* mark_phi = new PhiNode(region, TypeX_X);\n+\n+      \/\/ Check if array is unlocked\n+      IfNode* iff = _igvn.transform(new IfNode(ctrl, is_unlocked, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+\n+      \/\/ Unlocked: Use bits from mark word\n+      region->init_req(1, _igvn.transform(new IfTrueNode(iff)));\n+      mark_phi->init_req(1, mark);\n+\n+      \/\/ Locked: Load prototype header from klass\n+      ctrl = _igvn.transform(new IfFalseNode(iff));\n+      Node* proto = MakeConX(0);\n+      for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+        Node* ary = check->in(i);\n+        \/\/ Make loads control dependent to make sure they are only executed if array is locked\n+        Node* klass_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());\n+        Node* klass = _igvn.transform(LoadKlassNode::make(_igvn, ctrl, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* proto_adr = basic_plus_adr(klass, in_bytes(Klass::prototype_header_offset()));\n+        Node* proto_load = _igvn.transform(LoadNode::make(_igvn, ctrl, C->immutable_memory(), proto_adr, proto_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+        proto = _igvn.transform(new OrXNode(proto, proto_load));\n+      }\n+      region->init_req(2, ctrl);\n+      mark_phi->init_req(2, proto);\n+\n+      \/\/ Check if flat array bits are set\n+      Node* mask = MakeConX(markWord::flat_array_bit_in_place);\n+      Node* masked = _igvn.transform(new AndXNode(_igvn.transform(mark_phi), mask));\n+      cmp = _igvn.transform(new CmpXNode(masked, MakeConX(0)));\n+      Node* is_not_flat = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n+\n+      ctrl = _igvn.transform(region);\n+      iff = _igvn.transform(new IfNode(ctrl, is_not_flat, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+      _igvn.replace_node(old_iff, iff);\n+    }\n+    _igvn.replace_node(check, C->top());\n+  } else {\n+    \/\/ Fall back to layout helper check\n+    Node* lhs = intcon(0);\n+    for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+      Node* array_or_klass = check->in(i);\n+      Node* klass = NULL;\n+      const TypePtr* t = _igvn.type(array_or_klass)->is_ptr();\n+      assert(!t->is_flat() && !t->is_not_flat(), \"Should have been optimized out\");\n+      if (t->isa_oopptr() != NULL) {\n+        Node* klass_adr = basic_plus_adr(array_or_klass, oopDesc::klass_offset_in_bytes());\n+        klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+      } else {\n+        assert(t->isa_aryklassptr(), \"Unexpected input type\");\n+        klass = array_or_klass;\n+      }\n+      Node* lh_addr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+      Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+      lhs = _igvn.transform(new OrINode(lhs, lh_val));\n+    }\n+    Node* masked = transform_later(new AndINode(lhs, intcon(Klass::_lh_array_tag_flat_value_bit_inplace)));\n+    Node* cmp = transform_later(new CmpINode(masked, intcon(0)));\n+    Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n+    Node* old_bol = check->unique_out();\n+    _igvn.replace_node(old_bol, bol);\n+    _igvn.replace_node(check, C->top());\n+  }\n+}\n+\n@@ -2359,2 +2840,5 @@\n-      case Node::Class_CallStaticJava:\n-        success = eliminate_boxing_node(n->as_CallStaticJava());\n+      case Node::Class_CallStaticJava: {\n+        CallStaticJavaNode* call = n->as_CallStaticJava();\n+        if (!call->method()->is_method_handle_intrinsic()) {\n+          success = eliminate_boxing_node(n->as_CallStaticJava());\n+        }\n@@ -2362,0 +2846,1 @@\n+      }\n@@ -2375,0 +2860,2 @@\n+      case Node::Class_FlatArrayCheck:\n+        break;\n@@ -2416,4 +2903,7 @@\n-        \/\/ Remove it from macro list and put on IGVN worklist to optimize.\n-        C->remove_macro_node(n);\n-        _igvn._worklist.push(n);\n-        success = true;\n+        CallStaticJavaNode* call = n->as_CallStaticJava();\n+        if (!call->method()->is_method_handle_intrinsic()) {\n+          \/\/ Remove it from macro list and put on IGVN worklist to optimize.\n+          C->remove_macro_node(n);\n+          _igvn._worklist.push(n);\n+          success = true;\n+        }\n@@ -2522,0 +3012,7 @@\n+    case Node::Class_CallStaticJava:\n+      expand_mh_intrinsic_return(n->as_CallStaticJava());\n+      C->remove_macro_node(n);\n+      break;\n+    case Node::Class_FlatArrayCheck:\n+      expand_flatarraycheck_node(n->as_FlatArrayCheck());\n+      break;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":674,"deletions":177,"binary":false,"changes":851,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  CallProjections _callprojs;\n+  CallProjections* _callprojs;\n@@ -99,0 +99,1 @@\n+  Node* inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc);\n@@ -104,1 +105,1 @@\n-  void process_users_of_allocation(CallNode *alloc);\n+  void process_users_of_allocation(CallNode *alloc, bool inline_alloc = false);\n@@ -111,0 +112,1 @@\n+  void inline_type_guard(Node** ctrl, LockNode* lock);\n@@ -112,0 +114,1 @@\n+  void expand_mh_intrinsic_return(CallStaticJavaNode* call);\n@@ -121,0 +124,1 @@\n+  Node* generate_fair_guard(Node** ctrl, Node* test, RegionNode* region);\n@@ -131,0 +135,4 @@\n+  Node* array_lh_test(Node* array, jint mask);\n+  Node* generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region);\n+  Node* generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region);\n+\n@@ -140,0 +148,1 @@\n+                           Node* dest_length,\n@@ -146,0 +155,2 @@\n+                            Node* val,\n+                            Node* raw_val,\n@@ -181,1 +192,3 @@\n-\n+  const TypePtr* adjust_for_flat_array(const TypeAryPtr* top_dest, Node*& src_offset,\n+                                       Node*& dest_offset, Node*& length, BasicType& dest_elem,\n+                                       Node*& dest_length);\n@@ -186,0 +199,2 @@\n+  void expand_flatarraycheck_node(FlatArrayCheckNode* check);\n+\n@@ -201,0 +216,2 @@\n+  bool can_try_zeroing_elimination(AllocateArrayNode* alloc, Node* src, Node* dest) const;\n+\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -142,1 +143,1 @@\n-inline Node* PhaseMacroExpand::generate_slow_guard(Node** ctrl, Node* test, RegionNode* region) {\n+Node* PhaseMacroExpand::generate_slow_guard(Node** ctrl, Node* test, RegionNode* region) {\n@@ -146,0 +147,4 @@\n+inline Node* PhaseMacroExpand::generate_fair_guard(Node** ctrl, Node* test, RegionNode* region) {\n+  return generate_guard(ctrl, test, region, PROB_FAIR);\n+}\n+\n@@ -286,0 +291,20 @@\n+Node* PhaseMacroExpand::array_lh_test(Node* array, jint mask) {\n+  Node* klass_adr = basic_plus_adr(array, oopDesc::klass_offset_in_bytes());\n+  Node* klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  Node* lh_addr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+  Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* masked = transform_later(new AndINode(lh_val, intcon(mask)));\n+  Node* cmp = transform_later(new CmpINode(masked, intcon(0)));\n+  return transform_later(new BoolNode(cmp, BoolTest::ne));\n+}\n+\n+Node* PhaseMacroExpand::generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region) {\n+  assert(UseFlatArray, \"can never be flattened\");\n+  return generate_fair_guard(ctrl, array_lh_test(array, Klass::_lh_array_tag_flat_value_bit_inplace), region);\n+}\n+\n+Node* PhaseMacroExpand::generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region) {\n+  assert(EnableValhalla, \"can never be null free\");\n+  return generate_fair_guard(ctrl, array_lh_test(array, Klass::_lh_null_free_array_bit_inplace), region);\n+}\n+\n@@ -338,0 +363,19 @@\n+bool PhaseMacroExpand::can_try_zeroing_elimination(AllocateArrayNode* alloc,\n+                                                   Node* src,\n+                                                   Node* dest) const {\n+  const TypeAryPtr* top_dest = _igvn.type(dest)->isa_aryptr();\n+\n+  if (top_dest != NULL) {\n+    if (top_dest->klass() == NULL) {\n+      return false;\n+    }\n+  }\n+\n+  return ReduceBulkZeroing\n+    && !(UseTLAB && ZeroTLAB) \/\/ pointless if already zeroed\n+    && !src->eqv_uncast(dest)\n+    && alloc != NULL\n+    && _igvn.find_int_con(alloc->in(AllocateNode::ALength), 1) > 0\n+    && alloc->maybe_set_complete(&_igvn);\n+}\n+\n@@ -380,0 +424,1 @@\n+                                           Node* dest_length,\n@@ -391,0 +436,2 @@\n+  Node* default_value = NULL;\n+  Node* raw_default_value = NULL;\n@@ -421,0 +468,2 @@\n+      default_value = alloc->in(AllocateNode::DefaultValue);\n+      raw_default_value = alloc->in(AllocateNode::RawDefaultValue);\n@@ -490,1 +539,0 @@\n-      Node* dest_length = alloc->in(AllocateNode::ALength);\n@@ -497,1 +545,3 @@\n-                             adr_type, dest, basic_elem_type,\n+                             adr_type, dest,\n+                             default_value, raw_default_value,\n+                             basic_elem_type,\n@@ -528,1 +578,0 @@\n-    Node* dest_length = alloc->in(AllocateNode::ALength);\n@@ -534,1 +583,3 @@\n-                           adr_type, dest, basic_elem_type,\n+                           adr_type, dest,\n+                           default_value, raw_default_value,\n+                           basic_elem_type,\n@@ -583,1 +634,3 @@\n-                             adr_type, dest, basic_elem_type,\n+                             adr_type, dest,\n+                             default_value, raw_default_value,\n+                             basic_elem_type,\n@@ -593,1 +646,3 @@\n-                             adr_type, dest, basic_elem_type,\n+                             adr_type, dest,\n+                             default_value, raw_default_value,\n+                             basic_elem_type,\n@@ -771,1 +826,3 @@\n-                           adr_type, dest, basic_elem_type,\n+                           adr_type, dest,\n+                           default_value, raw_default_value,\n+                           basic_elem_type,\n@@ -833,3 +890,3 @@\n-  _igvn.replace_node(_callprojs.fallthrough_memproj, out_mem);\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_ioproj, *io);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, out_mem);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_ioproj, *io);\n@@ -837,1 +894,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_catchproj, *ctrl);\n+  _igvn.replace_node(_callprojs->fallthrough_catchproj, *ctrl);\n@@ -877,0 +934,2 @@\n+                                            Node* val,\n+                                            Node* raw_val,\n@@ -892,0 +951,1 @@\n+  assert(basic_elem_type != T_PRIMITIVE_OBJECT, \"should have been converted to a basic type copy\");\n@@ -915,1 +975,1 @@\n-    mem = ClearArrayNode::clear_memory(ctrl, mem, dest,\n+    mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,\n@@ -920,1 +980,1 @@\n-    mem = ClearArrayNode::clear_memory(ctrl, mem, dest,\n+    mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,\n@@ -933,1 +993,1 @@\n-    mem = ClearArrayNode::clear_memory(ctrl, mem, dest,\n+    mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,\n@@ -962,1 +1022,7 @@\n-        mem = StoreNode::make(_igvn, ctrl, mem, p1, adr_type, intcon(0), T_INT, MemNode::unordered);\n+        if (val == NULL) {\n+          assert(raw_val == NULL, \"val may not be null\");\n+          mem = StoreNode::make(_igvn, ctrl, mem, p1, adr_type, intcon(0), T_INT, MemNode::unordered);\n+        } else {\n+          assert(_igvn.type(val)->isa_narrowoop(), \"should be narrow oop\");\n+          mem = new StoreNNode(ctrl, mem, p1, adr_type, val, MemNode::unordered);\n+        }\n@@ -967,1 +1033,1 @@\n-    mem = ClearArrayNode::clear_memory(ctrl, mem, dest,\n+    mem = ClearArrayNode::clear_memory(ctrl, mem, dest, raw_val,\n@@ -1083,2 +1149,2 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n-  *ctrl = _callprojs.fallthrough_catchproj->clone();\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  *ctrl = _callprojs->fallthrough_catchproj->clone();\n@@ -1087,1 +1153,1 @@\n-  Node* m = _callprojs.fallthrough_memproj->clone();\n+  Node* m = _callprojs->fallthrough_memproj->clone();\n@@ -1102,2 +1168,2 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    *io = _callprojs.fallthrough_ioproj->clone();\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    *io = _callprojs->fallthrough_ioproj->clone();\n@@ -1235,0 +1301,36 @@\n+const TypePtr* PhaseMacroExpand::adjust_for_flat_array(const TypeAryPtr* top_dest, Node*& src_offset,\n+                                                       Node*& dest_offset, Node*& length, BasicType& dest_elem,\n+                                                       Node*& dest_length) {\n+#ifdef ASSERT\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bool needs_barriers = top_dest->elem()->inline_klass()->contains_oops() &&\n+    bs->array_copy_requires_gc_barriers(dest_length != NULL, T_OBJECT, false, false, BarrierSetC2::Optimization);\n+  assert(!needs_barriers || StressReflectiveCode, \"Flat arracopy would require GC barriers\");\n+#endif\n+  int elem_size = top_dest->klass()->as_flat_array_klass()->element_byte_size();\n+  if (elem_size >= 8) {\n+    if (elem_size > 8) {\n+      \/\/ treat as array of long but scale length, src offset and dest offset\n+      assert((elem_size % 8) == 0, \"not a power of 2?\");\n+      int factor = elem_size \/ 8;\n+      length = transform_later(new MulINode(length, intcon(factor)));\n+      src_offset = transform_later(new MulINode(src_offset, intcon(factor)));\n+      dest_offset = transform_later(new MulINode(dest_offset, intcon(factor)));\n+      if (dest_length != NULL) {\n+        dest_length = transform_later(new MulINode(dest_length, intcon(factor)));\n+      }\n+      elem_size = 8;\n+    }\n+    dest_elem = T_LONG;\n+  } else if (elem_size == 4) {\n+    dest_elem = T_INT;\n+  } else if (elem_size == 2) {\n+    dest_elem = T_CHAR;\n+  } else if (elem_size == 1) {\n+    dest_elem = T_BYTE;\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+  return TypeRawPtr::BOTTOM;\n+}\n+\n@@ -1252,3 +1354,16 @@\n-    Node* mem = ac->in(TypeFunc::Memory);\n-    merge_mem = MergeMemNode::make(mem);\n-    transform_later(merge_mem);\n+    const Type* src_type = _igvn.type(src);\n+    const Type* dest_type = _igvn.type(dest);\n+    const TypeAryPtr* top_src = src_type->isa_aryptr();\n+    const TypeAryPtr* top_dest = dest_type->isa_aryptr();\n+    BasicType dest_elem = T_OBJECT;\n+    if (top_dest != NULL && top_dest->klass() != NULL) {\n+      dest_elem = top_dest->klass()->as_array_klass()->element_type()->basic_type();\n+    }\n+    if (dest_elem == T_ARRAY || (dest_elem == T_PRIMITIVE_OBJECT && top_dest->klass()->is_obj_array_klass())) {\n+      dest_elem = T_OBJECT;\n+    }\n+    if (top_src != NULL && top_src->is_flat()) {\n+      \/\/ If src is flat, dest is guaranteed to be flat as well\n+      dest_elem = T_PRIMITIVE_OBJECT;\n+      top_dest = top_src;\n+    }\n@@ -1257,0 +1372,1 @@\n+    Node* dest_length = NULL;\n@@ -1260,0 +1376,1 @@\n+      dest_length = alloc->in(AllocateNode::ALength);\n@@ -1262,3 +1379,16 @@\n-    const TypePtr* adr_type = _igvn.type(dest)->is_oopptr()->add_offset(Type::OffsetBot);\n-    if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n-      adr_type = ac->_dest_type->add_offset(Type::OffsetBot)->is_ptr();\n+    Node* mem = ac->in(TypeFunc::Memory);\n+    const TypePtr* adr_type = NULL;\n+    if (dest_elem == T_PRIMITIVE_OBJECT) {\n+      assert(dest_length != NULL || StressReflectiveCode, \"must be tightly coupled\");\n+      \/\/ Copy to a flat array modifies multiple memory slices. Conservatively insert a barrier\n+      \/\/ on all slices to prevent writes into the source from floating below the arraycopy.\n+      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n+      adr_type = adjust_for_flat_array(top_dest, src_offset, dest_offset, length, dest_elem, dest_length);\n+    } else {\n+      adr_type = dest_type->is_oopptr()->add_offset(Type::OffsetBot);\n+      if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n+        adr_type = ac->_dest_type->add_offset(Type::OffsetBot)->is_ptr();\n+      }\n+      if (ac->_src_type != ac->_dest_type) {\n+        adr_type = TypeRawPtr::BOTTOM;\n+      }\n@@ -1266,0 +1396,3 @@\n+    merge_mem = MergeMemNode::make(mem);\n+    transform_later(merge_mem);\n+\n@@ -1267,1 +1400,1 @@\n-                       adr_type, T_OBJECT,\n+                       adr_type, dest_elem,\n@@ -1269,0 +1402,1 @@\n+                       dest_length,\n@@ -1270,1 +1404,0 @@\n-\n@@ -1301,2 +1434,6 @@\n-  if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n-  if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n+  if (src_elem == T_ARRAY || src_elem == T_NARROWOOP || (src_elem == T_PRIMITIVE_OBJECT && top_src->klass()->is_obj_array_klass())) {\n+    src_elem = T_OBJECT;\n+  }\n+  if (dest_elem == T_ARRAY || dest_elem == T_NARROWOOP || (dest_elem == T_PRIMITIVE_OBJECT && top_dest->klass()->is_obj_array_klass())) {\n+    dest_elem = T_OBJECT;\n+  }\n@@ -1304,3 +1441,1 @@\n-  if (ac->is_arraycopy_validated() &&\n-      dest_elem != T_CONFLICT &&\n-      src_elem == T_CONFLICT) {\n+  if (ac->is_arraycopy_validated() && dest_elem != T_CONFLICT && src_elem == T_CONFLICT) {\n@@ -1325,0 +1460,1 @@\n+                                   NULL,\n@@ -1331,1 +1467,2 @@\n-  assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID), \"validated but different basic types\");\n+  assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID) ||\n+         (src_elem == T_PRIMITIVE_OBJECT && StressReflectiveCode), \"validated but different basic types\");\n@@ -1335,1 +1472,8 @@\n-  if (src_elem != dest_elem || dest_elem == T_VOID) {\n+  \/\/\n+  \/\/ We have no stub to copy flattened inline type arrays with oop\n+  \/\/ fields if we need to emit write barriers.\n+  \/\/\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  if (src_elem != dest_elem || dest_elem == T_VOID ||\n+      (dest_elem == T_PRIMITIVE_OBJECT && top_dest->elem()->inline_klass()->contains_oops() &&\n+       bs->array_copy_requires_gc_barriers(alloc != NULL, T_OBJECT, false, false, BarrierSetC2::Optimization))) {\n@@ -1343,3 +1487,3 @@\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, merge_mem);\n-    if (_callprojs.fallthrough_ioproj != NULL) {\n-      _igvn.replace_node(_callprojs.fallthrough_ioproj, io);\n+    _igvn.replace_node(_callprojs->fallthrough_memproj, merge_mem);\n+    if (_callprojs->fallthrough_ioproj != NULL) {\n+      _igvn.replace_node(_callprojs->fallthrough_ioproj, io);\n@@ -1347,1 +1491,1 @@\n-    _igvn.replace_node(_callprojs.fallthrough_catchproj, ctrl);\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, ctrl);\n@@ -1364,4 +1508,5 @@\n-  {\n-    Node* mem = ac->in(TypeFunc::Memory);\n-    merge_mem = MergeMemNode::make(mem);\n-    transform_later(merge_mem);\n+  Node* mem = ac->in(TypeFunc::Memory);\n+  if (dest_elem == T_PRIMITIVE_OBJECT) {\n+    \/\/ Copy to a flat array modifies multiple memory slices. Conservatively insert a barrier\n+    \/\/ on all slices to prevent writes into the source from floating below the arraycopy.\n+    insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n@@ -1369,0 +1514,2 @@\n+  merge_mem = MergeMemNode::make(mem);\n+  transform_later(merge_mem);\n@@ -1409,0 +1556,15 @@\n+\n+    \/\/ Handle inline type arrays\n+    if (!top_src->is_flat()) {\n+      if (UseFlatArray && !top_src->is_not_flat()) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        generate_flat_array_guard(&ctrl, src, slow_region);\n+      }\n+      if (EnableValhalla) {\n+        \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n+        \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n+        generate_null_free_array_guard(&ctrl, dest, slow_region);\n+      }\n+    } else {\n+      assert(top_dest->is_flat(), \"dest array must be flat\");\n+    }\n@@ -1410,0 +1572,1 @@\n+\n@@ -1412,1 +1575,5 @@\n-  if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n+  Node* dest_length = (alloc != NULL) ? alloc->in(AllocateNode::ALength) : NULL;\n+\n+  if (dest_elem == T_PRIMITIVE_OBJECT) {\n+    adr_type = adjust_for_flat_array(top_dest, src_offset, dest_offset, length, dest_elem, dest_length);\n+  } else if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n@@ -1421,0 +1588,1 @@\n+                     dest_length,\n@@ -1423,1 +1591,2 @@\n-                     false, ac->has_negative_length_guard(), slow_region);\n+                     false, ac->has_negative_length_guard(),\n+                     slow_region);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":216,"deletions":47,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -186,0 +186,44 @@\n+\/\/ Array of RegMask, one per returned values (inline type instances can\n+\/\/ be returned as multiple return values, one per field)\n+RegMask* Matcher::return_values_mask(const TypeFunc* tf) {\n+  const TypeTuple* range = tf->range_cc();\n+  uint cnt = range->cnt() - TypeFunc::Parms;\n+  if (cnt == 0) {\n+    return NULL;\n+  }\n+  RegMask* mask = NEW_RESOURCE_ARRAY(RegMask, cnt);\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, cnt);\n+  VMRegPair* vm_parm_regs = NEW_RESOURCE_ARRAY(VMRegPair, cnt);\n+  for (uint i = 0; i < cnt; i++) {\n+    sig_bt[i] = range->field_at(i+TypeFunc::Parms)->basic_type();\n+  }\n+\n+  int regs = SharedRuntime::java_return_convention(sig_bt, vm_parm_regs, cnt);\n+  if (regs <= 0) {\n+    \/\/ We ran out of registers to store the IsInit information for a nullable inline type return.\n+    \/\/ Since it is only set in the 'call_epilog', we can simply put it on the stack.\n+    assert(tf->returns_inline_type_as_fields(), \"should have been tested during graph construction\");\n+    \/\/ TODO 8284443 Can we teach the register allocator to reserve a stack slot instead?\n+    \/\/ mask[--cnt] = STACK_ONLY_mask does not work (test with -XX:+StressGCM)\n+    int slot = C->fixed_slots() - 2;\n+    if (C->needs_stack_repair()) {\n+      slot -= 2; \/\/ Account for stack increment value\n+    }\n+    mask[--cnt].Clear();\n+    mask[cnt].Insert(OptoReg::stack2reg(slot));\n+  }\n+  for (uint i = 0; i < cnt; i++) {\n+    mask[i].Clear();\n+\n+    OptoReg::Name reg1 = OptoReg::as_OptoReg(vm_parm_regs[i].first());\n+    if (OptoReg::is_valid(reg1)) {\n+      mask[i].Insert(reg1);\n+    }\n+    OptoReg::Name reg2 = OptoReg::as_OptoReg(vm_parm_regs[i].second());\n+    if (OptoReg::is_valid(reg2)) {\n+      mask[i].Insert(reg2);\n+    }\n+  }\n+\n+  return mask;\n+}\n@@ -201,15 +245,3 @@\n-  \/\/ Map a Java-signature return type into return register-value\n-  \/\/ machine registers for 0, 1 and 2 returned values.\n-  const TypeTuple *range = C->tf()->range();\n-  if( range->cnt() > TypeFunc::Parms ) { \/\/ If not a void function\n-    \/\/ Get ideal-register return type\n-    uint ireg = range->field_at(TypeFunc::Parms)->ideal_reg();\n-    \/\/ Get machine return register\n-    uint sop = C->start()->Opcode();\n-    OptoRegPair regs = return_value(ireg);\n-\n-    \/\/ And mask for same\n-    _return_value_mask = RegMask(regs.first());\n-    if( OptoReg::is_valid(regs.second()) )\n-      _return_value_mask.Insert(regs.second());\n-  }\n+  \/\/ Map Java-signature return types into return register-value\n+  \/\/ machine registers.\n+  _return_values_mask = return_values_mask(C->tf());\n@@ -223,1 +255,1 @@\n-  const TypeTuple *domain = C->tf()->domain();\n+  const TypeTuple *domain = C->tf()->domain_cc();\n@@ -526,0 +558,1 @@\n+\n@@ -784,1 +817,1 @@\n-  uint ret_edge_cnt = TypeFunc::Parms + ((C->tf()->range()->cnt() == TypeFunc::Parms) ? 0 : 1);\n+  uint ret_edge_cnt = C->tf()->range_cc()->cnt();\n@@ -786,4 +819,3 @@\n-  \/\/ Returns have 0 or 1 returned values depending on call signature.\n-  \/\/ Return register is specified by return_value in the AD file.\n-  if (ret_edge_cnt > TypeFunc::Parms)\n-    ret_rms[TypeFunc::Parms+0] = _return_value_mask;\n+  for (i = TypeFunc::Parms; i < ret_edge_cnt; i++) {\n+    ret_rms[i] = _return_values_mask[i-TypeFunc::Parms];\n+  }\n@@ -856,1 +888,1 @@\n-  int proj_cnt = C->tf()->domain()->cnt();\n+  int proj_cnt = C->tf()->domain_cc()->cnt();\n@@ -1128,1 +1160,5 @@\n-              m = n->in(0)->as_Multi()->match( n->as_Proj(), this );\n+              RegMask* mask = NULL;\n+              if (n->in(0)->is_Call() && n->in(0)->as_Call()->tf()->returns_inline_type_as_fields()) {\n+                mask = return_values_mask(n->in(0)->as_Call()->tf());\n+              }\n+              m = n->in(0)->as_Multi()->match(n->as_Proj(), this, mask);\n@@ -1267,1 +1303,1 @@\n-    domain = call->tf()->domain();\n+    domain = call->tf()->domain_cc();\n@@ -1346,1 +1382,4 @@\n-  int argcnt = cnt - TypeFunc::Parms;\n+  \/\/ Null entry point is a special cast where the target of the call\n+  \/\/ is in a register.\n+  int adj = (call != NULL && call->entry_point() == NULL) ? 1 : 0;\n+  int argcnt = cnt - TypeFunc::Parms - adj;\n@@ -1352,1 +1391,1 @@\n-      sig_bt[i] = domain->field_at(i+TypeFunc::Parms)->basic_type();\n+      sig_bt[i] = domain->field_at(i+TypeFunc::Parms+adj)->basic_type();\n@@ -1393,1 +1432,1 @@\n-      RegMask *rm = &mcall->_in_rms[i+TypeFunc::Parms];\n+      RegMask *rm = &mcall->_in_rms[i+TypeFunc::Parms+adj];\n@@ -1411,1 +1450,1 @@\n-      if (OptoReg::is_valid(reg1))\n+      if (OptoReg::is_valid(reg1)) {\n@@ -1413,0 +1452,1 @@\n+      }\n@@ -1415,1 +1455,1 @@\n-      if (OptoReg::is_valid(reg2))\n+      if (OptoReg::is_valid(reg2)) {\n@@ -1417,0 +1457,1 @@\n+      }\n@@ -1432,1 +1473,1 @@\n-    uint r_cnt = mcall->tf()->range()->cnt();\n+    uint r_cnt = mcall->tf()->range_sig()->cnt();\n@@ -1453,1 +1494,1 @@\n-         (mcall->jvms()->debug_start() + mcall->_jvmadj == mcall->tf()->domain()->cnt()), \"\");\n+         (mcall->jvms()->debug_start() + mcall->_jvmadj == mcall->tf()->domain_cc()->cnt()), \"\");\n@@ -2136,1 +2177,1 @@\n-      for (int i = n->req() - 1; i >= 0; --i) { \/\/ For my children\n+      for (int i = n->len() - 1; i >= 0; --i) { \/\/ For my children\n@@ -2451,0 +2492,7 @@\n+    case Op_ClearArray: {\n+      Node* pair = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair);\n+      n->set_req(3, n->in(4));\n+      n->del_req(4);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":80,"deletions":32,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -274,0 +274,2 @@\n+  RegMask* return_values_mask(const TypeFunc* tf);\n+\n@@ -398,1 +400,1 @@\n-  RegMask                     _return_value_mask;\n+  RegMask*            _return_values_mask;\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -243,1 +246,1 @@\n-               tp->isa_aryptr() &&        tp->offset() == Type::OffsetBot &&\n+        tp->isa_aryptr() &&        tp->offset() == Type::OffsetBot &&\n@@ -904,0 +907,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -1000,0 +1004,4 @@\n+      if (ary_t->klass()->is_flat_array_klass()) {\n+        ciFlatArrayKlass* vak = ary_t->klass()->as_flat_array_klass();\n+        shift = vak->log2_element_size();\n+      }\n@@ -1120,1 +1128,1 @@\n-        const TypeVect* out_vt = as_LoadVector()->vect_type();\n+        const TypeVect* out_vt = is_Load() ? as_LoadVector()->vect_type() : as_StoreVector()->vect_type();\n@@ -1138,0 +1146,6 @@\n+      assert(memory_type() != T_PRIMITIVE_OBJECT, \"should not be used for inline types\");\n+      Node* default_value = ld_alloc->in(AllocateNode::DefaultValue);\n+      if (default_value != NULL) {\n+        return default_value;\n+      }\n+      assert(ld_alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n@@ -1205,0 +1219,27 @@\n+  \/\/ Loading from an InlineTypePtr? The InlineTypePtr has the values of\n+  \/\/ all fields as input. Look for the field with matching offset.\n+  Node* addr = in(Address);\n+  intptr_t offset;\n+  Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);\n+  if (base != NULL && base->is_InlineTypePtr() && offset > oopDesc::klass_offset_in_bytes()) {\n+    Node* value = base->as_InlineTypePtr()->field_value_by_offset((int)offset, true);\n+    if (value->is_InlineType()) {\n+      \/\/ Non-flattened inline type field\n+      InlineTypeNode* vt = value->as_InlineType();\n+      if (vt->is_allocated(phase)) {\n+        value = vt->get_oop();\n+      } else {\n+        \/\/ Not yet allocated, bail out\n+        value = NULL;\n+      }\n+    }\n+    if (value != NULL) {\n+      if (Opcode() == Op_LoadN) {\n+        \/\/ Encode oop value if we are loading a narrow oop\n+        assert(!phase->type(value)->isa_narrowoop(), \"should already be decoded\");\n+        value = phase->transform(new EncodePNode(value, bottom_type()));\n+      }\n+      return value;\n+    }\n+  }\n+\n@@ -1914,0 +1955,1 @@\n+        && t->isa_inlinetype() == NULL\n@@ -1949,0 +1991,2 @@\n+            \/\/ Default value load\n+            tp->is_instptr()->instance_klass() == ciEnv::current()->Class_klass() ||\n@@ -1954,1 +1998,3 @@\n-    \/\/ Optimize loads from constant fields.\n+    BasicType bt = memory_type();\n+\n+    \/\/ Optimize loads from constant fields.\n@@ -1958,1 +2004,19 @@\n-      const Type* con_type = Type::make_constant_from_field(const_oop->as_instance(), off, is_unsigned(), memory_type());\n+      ciType* mirror_type = const_oop->as_instance()->java_mirror_type();\n+      if (mirror_type != NULL) {\n+        const Type* const_oop = NULL;\n+        ciInlineKlass* vk = mirror_type->is_inlinetype() ? mirror_type->as_inline_klass() : NULL;\n+        \/\/ Fold default value loads\n+        if (vk != NULL && off == vk->default_value_offset()) {\n+          const_oop = TypeInstPtr::make(vk->default_instance());\n+        }\n+        \/\/ Fold class mirror loads\n+        if (off == java_lang_Class::primary_mirror_offset()) {\n+          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n+        } else if (off == java_lang_Class::secondary_mirror_offset()) {\n+          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n+        }\n+        if (const_oop != NULL) {\n+          return (bt == T_NARROWOOP) ? const_oop->make_narrowoop() : const_oop;\n+        }\n+      }\n+      const Type* con_type = Type::make_constant_from_field(const_oop->as_instance(), off, is_unsigned(), bt);\n@@ -1973,15 +2037,31 @@\n-  } else if (tp->base() == Type::RawPtr && adr->is_Load() && off == 0) {\n-    \/* With mirrors being an indirect in the Klass*\n-     * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))\n-     * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).\n-     *\n-     * So check the type and klass of the node before the LoadP.\n-     *\/\n-    Node* adr2 = adr->in(MemNode::Address);\n-    const TypeKlassPtr* tkls = phase->type(adr2)->isa_klassptr();\n-    if (tkls != NULL && !StressReflectiveCode) {\n-      if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n-        ciKlass* klass = tkls->exact_klass();\n-        assert(adr->Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n-        assert(Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n-        return TypeInstPtr::make(klass->java_mirror());\n+  } else if (tp->base() == Type::RawPtr && !StressReflectiveCode) {\n+    if (adr->is_Load() && off == 0) {\n+      \/* With mirrors being an indirect in the Klass*\n+       * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))\n+       * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).\n+       *\n+       * So check the type and klass of the node before the LoadP.\n+       *\/\n+      Node* adr2 = adr->in(MemNode::Address);\n+      const TypeKlassPtr* tkls = phase->type(adr2)->isa_klassptr();\n+      if (tkls != NULL) {\n+        if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n+          ciKlass* klass = tkls->exact_klass();\n+          assert(adr->Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n+          assert(Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n+          return TypeInstPtr::make(klass->java_mirror());\n+        }\n+      }\n+    } else {\n+      \/\/ Check for a load of the default value offset from the InlineKlassFixedBlock:\n+      \/\/ LoadI(LoadP(inline_klass, adr_inlineklass_fixed_block_offset), default_value_offset_offset)\n+      intptr_t offset = 0;\n+      Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);\n+      if (base != NULL && base->is_Load() && offset == in_bytes(InlineKlass::default_value_offset_offset())) {\n+        const TypeKlassPtr* tkls = phase->type(base->in(MemNode::Address))->isa_klassptr();\n+        if (tkls != NULL && tkls->is_loaded() && tkls->klass_is_exact() && tkls->isa_inlinetype() &&\n+            tkls->offset() == in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())) {\n+          assert(base->Opcode() == Op_LoadP, \"must load an oop from klass\");\n+          assert(Opcode() == Op_LoadI, \"must load an int from fixed block\");\n+          return TypeInt::make(tkls->klass()->as_inline_klass()->default_value_offset());\n+        }\n@@ -2093,1 +2173,0 @@\n-\n@@ -2096,1 +2175,11 @@\n-    return TypeX::make(markWord::prototype().value());\n+    if (EnableValhalla) {\n+      \/\/ The mark word may contain property bits (inline, flat, null-free)\n+      Node* klass_node = alloc->in(AllocateNode::KlassNode);\n+      const TypeKlassPtr* tkls = phase->type(klass_node)->is_klassptr();\n+      ciKlass* klass = tkls->klass();\n+      if (klass != NULL && klass->is_loaded() && tkls->klass_is_exact()) {\n+        return TypeX::make(klass->prototype_header().value());\n+      }\n+    } else {\n+      return TypeX::make(markWord::prototype().value());\n+    }\n@@ -2247,1 +2336,2 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,\n+                          const TypeKlassPtr* tk) {\n@@ -2294,1 +2384,2 @@\n-      ciType* t = tinst->java_mirror_type();\n+      bool null_free = false;\n+      ciType* t = tinst->java_mirror_type(&null_free);\n@@ -2304,1 +2395,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          return TypeKlassPtr::make(ciArrayKlass::make(t, null_free));\n@@ -2323,1 +2414,1 @@\n-  const TypeAryPtr *tary = tp->isa_aryptr();\n+  const TypeAryPtr* tary = tp->isa_aryptr();\n@@ -2549,0 +2640,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -2599,1 +2691,1 @@\n-  {\n+  if (phase->C->get_adr_type(phase->C->get_alias_index(adr_type())) != TypeAryPtr::INLINES) {\n@@ -2619,0 +2711,1 @@\n+             (Opcode() == Op_StoreL && st->Opcode() == Op_StoreN) ||\n@@ -2715,2 +2808,1 @@\n-  if (result == this &&\n-      ReduceFieldZeroing && phase->type(val)->is_zero_type()) {\n+  if (result == this && ReduceFieldZeroing) {\n@@ -2718,1 +2810,3 @@\n-    if (mem->is_Proj() && mem->in(0)->is_Allocate()) {\n+    if (mem->is_Proj() && mem->in(0)->is_Allocate() &&\n+        (phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::DefaultValue) == val)) {\n+      assert(!phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::DefaultValue) == NULL, \"storing null to inline type array is forbidden\");\n@@ -2722,1 +2816,1 @@\n-    if (result == this) {\n+    if (result == this && phase->type(val)->is_zero_type()) {\n@@ -2907,3 +3001,7 @@\n-    Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-    set_req_X(MemNode::OopStore, mem, phase);\n-    return this;\n+    if (oop_alias_idx() != phase->C->get_alias_index(TypeAryPtr::INLINES) ||\n+        phase->C->flattened_accesses_share_alias()) {\n+      \/\/ The alias that was recorded is no longer accurate enough.\n+      Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n+      set_req_X(MemNode::OopStore, mem, phase);\n+      return this;\n+    }\n@@ -3068,1 +3166,1 @@\n-    return new ClearArrayNode(in(0), in(1), in(2), in(3), true);\n+    return new ClearArrayNode(in(0), in(1), in(2), in(3), in(4), true);\n@@ -3086,1 +3184,1 @@\n-  Node *zero = phase->makecon(TypeLong::ZERO);\n+  Node *val = in(4);\n@@ -3088,1 +3186,1 @@\n-  mem = new StoreLNode(in(0),mem,adr,atp,zero,MemNode::unordered,false);\n+  mem = new StoreLNode(in(0), mem, adr, atp, val, MemNode::unordered, false);\n@@ -3093,1 +3191,1 @@\n-    mem = new StoreLNode(in(0),mem,adr,atp,zero,MemNode::unordered,false);\n+    mem = new StoreLNode(in(0), mem, adr, atp, val, MemNode::unordered, false);\n@@ -3127,0 +3225,2 @@\n+                                   Node* val,\n+                                   Node* raw_val,\n@@ -3137,1 +3237,7 @@\n-    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    if (val != NULL) {\n+      assert(phase->type(val)->isa_narrowoop(), \"should be narrow oop\");\n+      mem = new StoreNNode(ctl, mem, adr, atp, val, MemNode::unordered);\n+    } else {\n+      assert(raw_val == NULL, \"val may not be null\");\n+      mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    }\n@@ -3144,1 +3250,1 @@\n-  return clear_memory(ctl, mem, dest, phase->MakeConX(offset), end_offset, phase);\n+  return clear_memory(ctl, mem, dest, raw_val, phase->MakeConX(offset), end_offset, phase);\n@@ -3148,0 +3254,1 @@\n+                                   Node* raw_val,\n@@ -3170,1 +3277,4 @@\n-  mem = new ClearArrayNode(ctl, mem, zsize, adr, false);\n+  if (raw_val == NULL) {\n+    raw_val = phase->MakeConX(0);\n+  }\n+  mem = new ClearArrayNode(ctl, mem, zsize, adr, raw_val, false);\n@@ -3175,0 +3285,2 @@\n+                                   Node* val,\n+                                   Node* raw_val,\n@@ -3189,1 +3301,1 @@\n-    mem = clear_memory(ctl, mem, dest,\n+    mem = clear_memory(ctl, mem, dest, val, raw_val,\n@@ -3196,1 +3308,7 @@\n-    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    if (val != NULL) {\n+      assert(phase->type(val)->isa_narrowoop(), \"should be narrow oop\");\n+      mem = new StoreNNode(ctl, mem, adr, atp, val, MemNode::unordered);\n+    } else {\n+      assert(raw_val == NULL, \"val may not be null\");\n+      mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    }\n@@ -3342,1 +3460,1 @@\n-Node *MemBarNode::match( const ProjNode *proj, const Matcher *m ) {\n+Node *MemBarNode::match(const ProjNode *proj, const Matcher *m, const RegMask* mask) {\n@@ -3649,1 +3767,3 @@\n-  if (init == NULL || init->is_complete())  return false;\n+  if (init == NULL || init->is_complete()) {\n+    return false;\n+  }\n@@ -3827,0 +3947,6 @@\n+                if (base->is_Phi()) {\n+                  \/\/ In rare case, base may be a PhiNode and it may read\n+                  \/\/ the same memory slice between InitializeNode and store.\n+                  failed = true;\n+                  break;\n+                }\n@@ -4411,0 +4537,2 @@\n+                                              allocation()->in(AllocateNode::DefaultValue),\n+                                              allocation()->in(AllocateNode::RawDefaultValue),\n@@ -4470,0 +4598,2 @@\n+                                            allocation()->in(AllocateNode::DefaultValue),\n+                                            allocation()->in(AllocateNode::RawDefaultValue),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":174,"deletions":44,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -129,0 +129,4 @@\n+#ifdef ASSERT\n+  void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }\n+#endif\n+\n@@ -548,1 +552,0 @@\n-\n@@ -1133,0 +1136,1 @@\n+  bool _word_copy_only;\n@@ -1134,2 +1138,3 @@\n-  ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, bool is_large)\n-    : Node(ctrl,arymem,word_cnt,base), _is_large(is_large) {\n+  ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, Node* val, bool is_large)\n+    : Node(ctrl, arymem, word_cnt, base, val), _is_large(is_large),\n+      _word_copy_only(val->bottom_type()->isa_long() && (!val->bottom_type()->is_long()->is_con() || val->bottom_type()->is_long()->get_con() != 0)) {\n@@ -1147,0 +1152,1 @@\n+  bool word_copy_only() const { return _word_copy_only; }\n@@ -1153,0 +1159,2 @@\n+                            Node* val,\n+                            Node* raw_val,\n@@ -1157,0 +1165,2 @@\n+                            Node* val,\n+                            Node* raw_val,\n@@ -1161,0 +1171,1 @@\n+                            Node* raw_val,\n@@ -1212,1 +1223,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);\n@@ -1351,1 +1362,3 @@\n-    : MemBarNode(C, alias_idx, precedent) {}\n+    : MemBarNode(C, alias_idx, precedent) {\n+    init_class_id(Class_Blackhole);\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -210,0 +210,12 @@\n+  \/\/ Code pattern on return from a call that returns an __Value.  Can\n+  \/\/ be optimized away if the return value turns out to be an oop.\n+  if (op == Op_AndX &&\n+      in(1) != NULL &&\n+      in(1)->Opcode() == Op_CastP2X &&\n+      in(1)->in(1) != NULL &&\n+      phase->type(in(1)->in(1))->isa_oopptr() &&\n+      t2->isa_intptr_t()->_lo >= 0 &&\n+      t2->isa_intptr_t()->_hi <= MinObjAlignmentInBytesMask) {\n+    return add_id();\n+  }\n+\n@@ -706,0 +718,8 @@\n+\n+    \/\/ Check if this is part of an inline type test\n+    if (con == markWord::inline_type_pattern && in(1)->is_Load() &&\n+        phase->type(in(1)->in(MemNode::Address))->is_inlinetypeptr() &&\n+        phase->type(in(1)->in(MemNode::Address))->is_ptr()->offset() == oopDesc::mark_offset_in_bytes()) {\n+      assert(EnableValhalla, \"should only be used for inline types\");\n+      return in(2); \/\/ Obj is known to be an inline type\n+    }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -583,0 +583,3 @@\n+  if (n->is_InlineTypeBase()) {\n+    C->add_inline_type(n);\n+  }\n@@ -665,0 +668,3 @@\n+  if (is_InlineTypeBase()) {\n+    compile->remove_inline_type(this);\n+  }\n@@ -2980,1 +2986,3 @@\n-      assert(i >= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() || (is_Unlock() && i == req()-1)\n+      assert(i >= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() ||\n+             (is_Allocate() && i >= AllocateNode::InlineTypeNode) ||\n+             (is_Unlock() && i == req()-1)\n@@ -2982,1 +2990,1 @@\n-              \"only region, phi, arraycopy, unlock or membar nodes have null data edges\");\n+             \"only region, phi, arraycopy, allocate or unlock nodes have null data edges\");\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+class FlatArrayCheckNode;\n@@ -116,0 +117,1 @@\n+class MachPrologNode;\n@@ -122,0 +124,1 @@\n+class MachVEPNode;\n@@ -166,0 +169,3 @@\n+class InlineTypeBaseNode;\n+class InlineTypeNode;\n+class InlineTypePtrNode;\n@@ -666,0 +672,1 @@\n+        DEFINE_CLASS_ID(Blackhole,        MemBar, 2)\n@@ -687,0 +694,2 @@\n+      DEFINE_CLASS_ID(MachProlog,       Mach, 8)\n+      DEFINE_CLASS_ID(MachVEP,          Mach, 9)\n@@ -713,0 +722,3 @@\n+      DEFINE_CLASS_ID(InlineTypeBase, Type, 8)\n+        DEFINE_CLASS_ID(InlineType, InlineTypeBase, 0)\n+        DEFINE_CLASS_ID(InlineTypePtr, InlineTypeBase, 1)\n@@ -749,3 +761,4 @@\n-        DEFINE_CLASS_ID(FastLock,   Cmp, 0)\n-        DEFINE_CLASS_ID(FastUnlock, Cmp, 1)\n-        DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)\n+        DEFINE_CLASS_ID(FastLock,       Cmp, 0)\n+        DEFINE_CLASS_ID(FastUnlock,     Cmp, 1)\n+        DEFINE_CLASS_ID(SubTypeCheck,   Cmp, 2)\n+        DEFINE_CLASS_ID(FlatArrayCheck, Cmp, 3)\n@@ -850,0 +863,1 @@\n+  DEFINE_CLASS_QUERY(Blackhole)\n@@ -878,0 +892,1 @@\n+  DEFINE_CLASS_QUERY(FlatArrayCheck)\n@@ -910,0 +925,1 @@\n+  DEFINE_CLASS_QUERY(MachProlog)\n@@ -916,0 +932,1 @@\n+  DEFINE_CLASS_QUERY(MachVEP)\n@@ -940,0 +957,3 @@\n+  DEFINE_CLASS_QUERY(InlineType)\n+  DEFINE_CLASS_QUERY(InlineTypeBase)\n+  DEFINE_CLASS_QUERY(InlineTypePtr)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -349,1 +350,9 @@\n-    _orig_pc_slot = C->fixed_slots() - (sizeof(address) \/ VMRegImpl::stack_slot_size);\n+    int fixed_slots = C->fixed_slots();\n+    if (C->needs_stack_repair()) {\n+      fixed_slots -= 2;\n+    }\n+    \/\/ TODO 8284443 Only reserve extra slot if needed\n+    if (InlineTypeReturnedAsFields) {\n+      fixed_slots -= 2;\n+    }\n+    _orig_pc_slot = fixed_slots - (sizeof(address) \/ VMRegImpl::stack_slot_size);\n@@ -390,1 +399,2 @@\n-  MachPrologNode *prolog = new MachPrologNode();\n+  Label verified_entry;\n+  MachPrologNode* prolog = new MachPrologNode(&verified_entry);\n@@ -396,3 +406,2 @@\n-\n-  if( C->is_osr_compilation() ) {\n-    if( PoisonOSREntry ) {\n+  if (C->is_osr_compilation()) {\n+    if (PoisonOSREntry) {\n@@ -403,3 +412,14 @@\n-    if( C->method() && !C->method()->flags().is_static() ) {\n-      \/\/ Insert unvalidated entry point\n-      C->cfg()->insert( broot, 0, new MachUEPNode() );\n+    if (C->method()) {\n+      if (C->method()->has_scalarized_args()) {\n+        \/\/ Add entry point to unpack all inline type arguments\n+        C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ true, \/* receiver_only *\/ false));\n+        if (!C->method()->is_static()) {\n+          \/\/ Add verified\/unverified entry points to only unpack inline type receiver at interface calls\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ false, \/* receiver_only *\/ false));\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ true,  \/* receiver_only *\/ true));\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ false, \/* receiver_only *\/ true));\n+        }\n+      } else if (!C->method()->is_static()) {\n+        \/\/ Insert unvalidated entry point\n+        C->cfg()->insert(broot, 0, new MachUEPNode());\n+      }\n@@ -407,1 +427,0 @@\n-\n@@ -447,0 +466,25 @@\n+  if (!C->is_osr_compilation() && C->has_scalarized_args()) {\n+    \/\/ Compute the offsets of the entry points required by the inline type calling convention\n+    if (!C->method()->is_static()) {\n+      \/\/ We have entries at the beginning of the method, implemented by the first 4 nodes.\n+      \/\/ Entry                     (unverified) @ offset 0\n+      \/\/ Verified_Inline_Entry_RO\n+      \/\/ Inline_Entry              (unverified)\n+      \/\/ Verified_Inline_Entry\n+      uint offset = 0;\n+      _code_offsets.set_value(CodeOffsets::Entry, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(0))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(1))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Inline_Entry, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(2))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, offset);\n+    } else {\n+      _code_offsets.set_value(CodeOffsets::Entry, -1); \/\/ will be patched later\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, 0);\n+    }\n+  }\n+\n@@ -607,1 +651,3 @@\n-          mcall->method_set((intptr_t)mcall->entry_point());\n+          if (mcall->entry_point() != NULL) {\n+            mcall->method_set((intptr_t)mcall->entry_point());\n+          }\n@@ -862,0 +908,17 @@\n+      uint first_ind = spobj->first_index(sfpt->jvms());\n+      \/\/ Nullable, scalarized inline types have an is_init input\n+      \/\/ that needs to be checked before using the field values.\n+      ScopeValue* is_init = NULL;\n+      if (cik->is_inlinetype()) {\n+        Node* init_node = sfpt->in(first_ind++);\n+        assert(init_node != NULL, \"is_init node not found\");\n+        if (!init_node->is_top()) {\n+          const TypeInt* init_type = init_node->bottom_type()->is_int();\n+          if (init_node->is_Con()) {\n+            is_init = new ConstantIntValue(init_type->get_con());\n+          } else {\n+            OptoReg::Name init_reg = C->regalloc()->get_reg_first(init_node);\n+            is_init = new_loc_value(C->regalloc(), init_reg, Location::normal);\n+          }\n+        }\n+      }\n@@ -863,1 +926,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init);\n@@ -866,1 +929,0 @@\n-      uint first_ind = spobj->first_index(sfpt->jvms());\n@@ -1039,0 +1101,1 @@\n+  bool return_scalarized = false;\n@@ -1060,1 +1123,1 @@\n-    if (mcall->returns_pointer()) {\n+    if (mcall->returns_pointer() || mcall->returns_scalarized()) {\n@@ -1063,0 +1126,3 @@\n+    if (mcall->returns_scalarized()) {\n+      return_scalarized = true;\n+    }\n@@ -1185,0 +1251,1 @@\n+      return_scalarized,\n@@ -1563,2 +1630,4 @@\n-          \/\/ This destination address is NOT PC-relative\n-          mcall->method_set((intptr_t)mcall->entry_point());\n+          if (mcall->entry_point() != NULL) {\n+            \/\/ This destination address is NOT PC-relative\n+            mcall->method_set((intptr_t)mcall->entry_point());\n+          }\n@@ -1728,1 +1797,0 @@\n-\n@@ -3118,0 +3186,13 @@\n+\n+      \/\/ Do not allow a CheckCastPP node whose input is a raw pointer to\n+      \/\/ float past a safepoint.  This can occur when a buffered inline\n+      \/\/ type is allocated in a loop and the CheckCastPP from that\n+      \/\/ allocation is reused outside the loop.  If the use inside the\n+      \/\/ loop is scalarized the CheckCastPP will no longer be connected\n+      \/\/ to the loop safepoint.  See JDK-8264340.\n+      if (m->is_Mach() && m->as_Mach()->ideal_Opcode() == Op_CheckCastPP) {\n+        Node *def = m->in(1);\n+        if (def != NULL && def->bottom_type()->base() == Type::RawPtr) {\n+          last_safept_node->add_prec(m);\n+        }\n+      }\n@@ -3276,0 +3357,19 @@\n+    if (C->has_scalarized_args()) {\n+      \/\/ Inline type entry points (MachVEPNodes) require lots of space for GC barriers and oop verification\n+      \/\/ when loading object fields from the buffered argument. Increase scratch buffer size accordingly.\n+      ciMethod* method = C->method();\n+      int barrier_size = UseZGC ? 200 : (7 DEBUG_ONLY(+ 37));\n+      int arg_num = 0;\n+      if (!method->is_static()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += method->holder()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+      for (ciSignatureStream str(method->signature()); !str.at_return_type(); str.next()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += str.type()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+    }\n@@ -3340,0 +3440,6 @@\n+  } else if (n->is_MachProlog()) {\n+    saveL = ((MachPrologNode*)n)->_verified_entry;\n+    ((MachPrologNode*)n)->_verified_entry = &fakeL;\n+  } else if (n->is_MachVEP()) {\n+    saveL = ((MachVEPNode*)n)->_verified_entry;\n+    ((MachVEPNode*)n)->_verified_entry = &fakeL;\n@@ -3346,1 +3452,2 @@\n-  if (is_branch) \/\/ Restore label.\n+  \/\/ Restore label.\n+  if (is_branch) {\n@@ -3348,0 +3455,5 @@\n+  } else if (n->is_MachProlog()) {\n+    ((MachPrologNode*)n)->_verified_entry = saveL;\n+  } else if (n->is_MachVEP()) {\n+    ((MachVEPNode*)n)->_verified_entry = saveL;\n+  }\n@@ -3391,0 +3503,9 @@\n+      if (_code_offsets.value(CodeOffsets::Verified_Inline_Entry) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, _first_block_size);\n+      }\n+      if (_code_offsets.value(CodeOffsets::Verified_Inline_Entry_RO) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, _first_block_size);\n+      }\n+      if (_code_offsets.value(CodeOffsets::Entry) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);\n+      }\n@@ -3395,14 +3516,14 @@\n-                                     entry_bci,\n-                                     &_code_offsets,\n-                                     _orig_pc_slot_offset_in_bytes,\n-                                     code_buffer(),\n-                                     frame_size_in_words(),\n-                                     oop_map_set(),\n-                                     &_handler_table,\n-                                     inc_table(),\n-                                     compiler,\n-                                     has_unsafe_access,\n-                                     SharedRuntime::is_wide_vector(C->max_vector_size()),\n-                                     C->has_monitors(),\n-                                     0,\n-                                     C->rtm_state());\n+                              entry_bci,\n+                              &_code_offsets,\n+                              _orig_pc_slot_offset_in_bytes,\n+                              code_buffer(),\n+                              frame_size_in_words(),\n+                              _oop_map_set,\n+                              &_handler_table,\n+                              inc_table(),\n+                              compiler,\n+                              has_unsafe_access,\n+                              SharedRuntime::is_wide_vector(C->max_vector_size()),\n+                              C->has_monitors(),\n+                              0,\n+                              C->rtm_state());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":152,"deletions":31,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-  Node *fetch_interpreter_state(int index, BasicType bt, Node *local_addrs, Node *local_addrs_base);\n+  Node* fetch_interpreter_state(int index, const Type* type, Node* local_addrs, Node* local_addrs_base);\n@@ -468,1 +468,1 @@\n-  void array_store_check();\n+  Node* array_store_check(Node*& adr, const Type*& elemtype);\n@@ -475,0 +475,1 @@\n+  Node* record_profile_for_speculation_at_array_load(Node* ld);\n@@ -523,1 +524,1 @@\n-  void do_get_xxx(Node* obj, ciField* field, bool is_field);\n+  void do_get_xxx(Node* obj, ciField* field);\n@@ -528,0 +529,2 @@\n+  void do_aconst_init();\n+  void do_withfield();\n@@ -529,1 +532,1 @@\n-  void do_anewarray();\n+  void do_newarray();\n@@ -544,1 +547,6 @@\n-  void    do_if(BoolTest::mask btest, Node* c);\n+  void    do_if(BoolTest::mask btest, Node* c, bool new_path = false, Node** ctrl_taken = NULL);\n+  void    do_acmp(BoolTest::mask btest, Node* left, Node* right);\n+  void    acmp_always_null_input(Node* input, const TypeOopPtr* tinput, BoolTest::mask btest, Node* eq_region);\n+  void    acmp_known_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, ciKlass* input_type, BoolTest::mask btest, Node* eq_region);\n+  Node*   acmp_null_check(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, Node*& null_ctl);\n+  void    acmp_unknown_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, BoolTest::mask btest, Node* eq_region);\n@@ -546,2 +554,1 @@\n-  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                              Block* path, Block* other_path);\n+  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/convertnode.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -105,4 +107,10 @@\n-Node *Parse::fetch_interpreter_state(int index,\n-                                     BasicType bt,\n-                                     Node *local_addrs,\n-                                     Node *local_addrs_base) {\n+Node* Parse::fetch_interpreter_state(int index,\n+                                     const Type* type,\n+                                     Node* local_addrs,\n+                                     Node* local_addrs_base) {\n+  BasicType bt = type->basic_type();\n+  if (type == TypePtr::NULL_PTR) {\n+    \/\/ Ptr types are mixed together with T_ADDRESS but NULL is\n+    \/\/ really for T_OBJECT types so correct it.\n+    bt = T_OBJECT;\n+  }\n@@ -120,0 +128,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -150,1 +159,5 @@\n-\n+  if (type->isa_inlinetype() != NULL) {\n+    \/\/ The interpreter passes inline types as oops\n+    type = TypeOopPtr::make_from_klass(type->inline_klass());\n+    type = type->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+  }\n@@ -174,0 +187,6 @@\n+    if (tp->is_inlinetypeptr() && !tp->maybe_null()) {\n+      \/\/ Check inline types for null here to prevent checkcast from adding an\n+      \/\/ exception state before the bytecode entry (use 'bad_type_ctrl' instead).\n+      l = null_check_oop(l, &bad_type_ctrl);\n+      bad_type_exit->control()->add_req(bad_type_ctrl);\n+    }\n@@ -177,3 +196,0 @@\n-\n-  BasicType bt_l = _gvn.type(l)->basic_type();\n-  BasicType bt_t = type->basic_type();\n@@ -192,1 +208,0 @@\n-\n@@ -230,1 +245,0 @@\n-\n@@ -234,1 +248,1 @@\n-    Node *lock_object = fetch_interpreter_state(index*2, T_OBJECT, monitors_addr, osr_buf);\n+    Node* lock_object = fetch_interpreter_state(index*2, Type::get_const_basic_type(T_OBJECT), monitors_addr, osr_buf);\n@@ -236,2 +250,1 @@\n-    Node *displaced_hdr = fetch_interpreter_state((index*2) + 1, T_ADDRESS, monitors_addr, osr_buf);\n-\n+    Node* displaced_hdr = fetch_interpreter_state((index*2) + 1, Type::get_const_basic_type(T_ADDRESS), monitors_addr, osr_buf);\n@@ -304,7 +317,1 @@\n-    BasicType bt = type->basic_type();\n-    if (type == TypePtr::NULL_PTR) {\n-      \/\/ Ptr types are mixed together with T_ADDRESS but NULL is\n-      \/\/ really for T_OBJECT types so correct it.\n-      bt = T_OBJECT;\n-    }\n-    Node *value = fetch_interpreter_state(index, bt, locals_addr, osr_buf);\n+    Node* value = fetch_interpreter_state(index, type, locals_addr, osr_buf);\n@@ -602,0 +609,21 @@\n+  \/\/ Handle inline type arguments\n+  int arg_size = method()->arg_size();\n+  for (int i = 0; i < arg_size; i++) {\n+    Node* parm = local(i);\n+    const Type* t = _gvn.type(parm);\n+    if (t->is_inlinetypeptr()) {\n+      \/\/ Create InlineTypeNode from the oop and replace the parameter\n+      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n+      set_local(i, vt);\n+    } else if (UseTypeSpeculation && (i == (arg_size - 1)) && !is_osr_parse() &&\n+               method()->has_vararg() && t->isa_aryptr() != NULL && !t->is_aryptr()->is_not_null_free()) {\n+      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flattened)\n+      const TypePtr* spec_type = t->speculative();\n+      spec_type = (spec_type != NULL && spec_type->isa_aryptr() != NULL) ? spec_type : t->is_aryptr();\n+      spec_type = spec_type->remove_speculative()->is_aryptr()->cast_to_not_null_free();\n+      spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, spec_type);\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), parm, t->join_speculative(spec_type)));\n+      set_local(i, cast);\n+    }\n+  }\n+\n@@ -784,2 +812,2 @@\n-  if (tf()->range()->cnt() > TypeFunc::Parms) {\n-    const Type* ret_type = tf()->range()->field_at(TypeFunc::Parms);\n+  if (tf()->range_sig()->cnt() > TypeFunc::Parms) {\n+    const Type* ret_type = tf()->range_sig()->field_at(TypeFunc::Parms);\n@@ -803,0 +831,5 @@\n+    \/\/ Scalarize inline type when returning as fields or inlining non-incrementally\n+    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n+        ret_type->is_inlinetypeptr()) {\n+      ret_type = TypeInlineType::make(ret_type->inline_klass());\n+    }\n@@ -807,1 +840,1 @@\n-    assert((int)(tf()->range()->cnt() - TypeFunc::Parms) == ret_size, \"good tf range\");\n+    assert((int)(tf()->range_sig()->cnt() - TypeFunc::Parms) == ret_size, \"good tf range\");\n@@ -814,1 +847,0 @@\n-\n@@ -819,2 +851,2 @@\n-  int        arg_size = tf->domain()->cnt();\n-  int        max_size = MAX2(arg_size, (int)tf->range()->cnt());\n+  int        arg_size = tf->domain_sig()->cnt();\n+  int        max_size = MAX2(arg_size, (int)tf->range_cc()->cnt());\n@@ -823,0 +855,1 @@\n+  jvms->set_map(map);\n@@ -834,3 +867,20 @@\n-  uint i;\n-  for (i = 0; i < (uint)arg_size; i++) {\n-    Node* parm = initial_gvn()->transform(new ParmNode(start, i));\n+  PhaseGVN& gvn = *initial_gvn();\n+  uint i = 0;\n+  int arg_num = 0;\n+  for (uint j = 0; i < (uint)arg_size; i++) {\n+    const Type* t = tf->domain_sig()->field_at(i);\n+    Node* parm = NULL;\n+    if (t->is_inlinetypeptr() && method()->is_scalarized_arg(arg_num)) {\n+      \/\/ Inline type arguments are not passed by reference: we get an argument per\n+      \/\/ field of the inline type. Build InlineTypeNodes from the inline type arguments.\n+      GraphKit kit(jvms, &gvn);\n+      kit.set_control(map->control());\n+      Node* old_mem = map->memory();\n+      \/\/ Use immutable memory for inline type loads and restore it below\n+      kit.set_all_memory(C->immutable_memory());\n+      parm = InlineTypeNode::make_from_multi(&kit, start, t->inline_klass(), j, \/* in= *\/ true, \/* null_free= *\/ !t->maybe_null());\n+      map->set_control(kit.control());\n+      map->set_memory(old_mem);\n+    } else {\n+      parm = gvn.transform(new ParmNode(start, j++));\n+    }\n@@ -840,0 +890,3 @@\n+    if (i >= TypeFunc::Parms && t != Type::HALF) {\n+      arg_num++;\n+    }\n@@ -846,1 +899,0 @@\n-  jvms->set_map(map);\n@@ -873,1 +925,1 @@\n-  int ret_size = tf()->range()->cnt() - TypeFunc::Parms;\n+  int ret_size = tf()->range_sig()->cnt() - TypeFunc::Parms;\n@@ -877,2 +929,30 @@\n-    ret->add_req(kit.argument(0));\n-    \/\/ Note:  The second dummy edge is not needed by a ReturnNode.\n+    Node* res = kit.argument(0);\n+    if (tf()->returns_inline_type_as_fields()) {\n+      \/\/ Multiple return values (inline type fields): add as many edges\n+      \/\/ to the Return node as returned values.\n+      InlineTypeBaseNode* vt = res->as_InlineTypeBase();\n+      ret->add_req_batch(NULL, tf()->range_cc()->cnt() - TypeFunc::Parms);\n+      if (vt->is_allocated(&kit.gvn()) && !StressInlineTypeReturnedAsFields) {\n+        ret->init_req(TypeFunc::Parms, vt->get_oop());\n+      } else {\n+        \/\/ Return the tagged klass pointer to signal scalarization to the caller\n+        Node* tagged_klass = vt->tagged_klass(kit.gvn());\n+        if (!method()->signature()->returns_null_free_inline_type()) {\n+          \/\/ Return null if the inline type is null (IsInit field is not set)\n+          Node* conv   = kit.gvn().transform(new ConvI2LNode(vt->get_is_init()));\n+          Node* shl    = kit.gvn().transform(new LShiftLNode(conv, kit.intcon(63)));\n+          Node* shr    = kit.gvn().transform(new RShiftLNode(shl, kit.intcon(63)));\n+          tagged_klass = kit.gvn().transform(new AndLNode(tagged_klass, shr));\n+        }\n+        ret->init_req(TypeFunc::Parms, tagged_klass);\n+      }\n+      uint idx = TypeFunc::Parms + 1;\n+      vt->pass_fields(&kit, ret, idx, false, method()->signature()->returns_null_free_inline_type());\n+    } else {\n+      if (res->is_InlineType()) {\n+        assert(res->as_InlineType()->is_allocated(&kit.gvn()), \"must be allocated\");\n+        res = res->as_InlineType()->get_oop();\n+      }\n+      ret->add_req(res);\n+      \/\/ Note:  The second dummy edge is not needed by a ReturnNode.\n+    }\n@@ -1002,1 +1082,1 @@\n-  if (method()->is_initializer() &&\n+  if (method()->is_object_constructor_or_class_initializer() &&\n@@ -1040,2 +1120,2 @@\n-  if (tf()->range()->cnt() > TypeFunc::Parms) {\n-    const Type* ret_type = tf()->range()->field_at(TypeFunc::Parms);\n+  if (tf()->range_sig()->cnt() > TypeFunc::Parms) {\n+    const Type* ret_type = tf()->range_sig()->field_at(TypeFunc::Parms);\n@@ -1134,1 +1214,1 @@\n-    kit.null_check_receiver_before_call(method());\n+    kit.null_check_receiver_before_call(method(), false);\n@@ -1172,1 +1252,1 @@\n-  uint arg_size = tf()->domain()->cnt();\n+  uint arg_size = tf()->domain_sig()->cnt();\n@@ -1246,0 +1326,1 @@\n+      assert(!_gvn.type(lock_obj)->make_oopptr()->can_be_inline_type(), \"can't be an inline type\");\n@@ -1657,0 +1738,38 @@\n+  \/\/ Check for merge conflicts involving inline types\n+  JVMState* old_jvms = map()->jvms();\n+  int old_bci = bci();\n+  JVMState* tmp_jvms = old_jvms->clone_shallow(C);\n+  tmp_jvms->set_should_reexecute(true);\n+  tmp_jvms->bind_map(map());\n+  \/\/ Execution needs to restart a the next bytecode (entry of next\n+  \/\/ block)\n+  if (target->is_merged() ||\n+      pnum > PhiNode::Input ||\n+      target->is_handler() ||\n+      target->is_loop_head()) {\n+    set_parse_bci(target->start());\n+    for (uint j = TypeFunc::Parms; j < map()->req(); j++) {\n+      Node* n = map()->in(j);                 \/\/ Incoming change to target state.\n+      const Type* t = NULL;\n+      if (tmp_jvms->is_loc(j)) {\n+        t = target->local_type_at(j - tmp_jvms->locoff());\n+      } else if (tmp_jvms->is_stk(j) && j < (uint)sp() + tmp_jvms->stkoff()) {\n+        t = target->stack_type_at(j - tmp_jvms->stkoff());\n+      }\n+      if (t != NULL && t != Type::BOTTOM) {\n+        if (n->is_InlineType() && (!t->isa_inlinetype() && !t->is_inlinetypeptr())) {\n+          \/\/ TODO Currently, the implementation relies on the assumption that InlineTypePtrNodes\n+          \/\/ are always buffered. We therefore need to allocate here.\n+          \/\/ Allocate inline type in src block to be able to merge it with oop in target block\n+          map()->set_req(j, n->as_InlineType()->buffer(this));\n+        } else if (!n->is_InlineTypeBase() && t->is_inlinetypeptr()) {\n+          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+          map()->set_req(j, InlineTypePtrNode::make_null(gvn(), t->inline_klass()));\n+        }\n+      }\n+    }\n+  }\n+  old_jvms->bind_map(map());\n+  set_parse_bci(old_bci);\n+\n@@ -1710,0 +1829,1 @@\n+\n@@ -1745,0 +1865,1 @@\n+    bool last_merge = (pnum == PhiNode::Input);\n@@ -1749,1 +1870,1 @@\n-      if (m->is_Phi() && m->as_Phi()->region() == r)\n+      if (m->is_Phi() && m->as_Phi()->region() == r) {\n@@ -1751,1 +1872,3 @@\n-      else\n+      } else if (m->is_InlineTypeBase() && m->as_InlineTypeBase()->has_phi_inputs(r)) {\n+        phi = m->as_InlineTypeBase()->get_oop()->as_Phi();\n+      } else {\n@@ -1753,0 +1876,1 @@\n+      }\n@@ -1786,1 +1910,34 @@\n-      if (phi != NULL) {\n+      \/\/ Merging two inline types?\n+      if (phi != NULL && phi->bottom_type()->is_inlinetypeptr()) {\n+        \/\/ Reload current state because it may have been updated by ensure_phi\n+        m = map()->in(j);\n+        InlineTypeBaseNode* vtm = m->as_InlineTypeBase(); \/\/ Current inline type\n+        InlineTypeBaseNode* vtn = n->as_InlineTypeBase(); \/\/ Incoming inline type\n+        assert(vtm->get_oop() == phi, \"Inline type should have Phi input\");\n+        if (TraceOptoParse) {\n+#ifdef ASSERT\n+          tty->print_cr(\"\\nMerging inline types\");\n+          tty->print_cr(\"Current:\");\n+          vtm->dump(2);\n+          tty->print_cr(\"Incoming:\");\n+          vtn->dump(2);\n+          tty->cr();\n+#endif\n+        }\n+        \/\/ Do the merge\n+        vtm->merge_with(&_gvn, vtn, pnum, last_merge);\n+        if (vtm->is_InlineTypePtr() && vtn->is_InlineType()) {\n+          \/\/ TODO 8284443 Remove this\n+          Node* newVal = InlineTypeNode::make_uninitialized(gvn(), vtm->bottom_type()->inline_klass());\n+          for (uint i = 1; i < vtm->req(); ++i) {\n+            newVal->set_req(i, vtm->in(i));\n+          }\n+          _gvn.set_type(newVal, vtm->bottom_type());\n+          vtm->replace_by(newVal);\n+          vtm = newVal->as_InlineTypeBase();\n+        }\n+        if (last_merge) {\n+          map()->set_req(j, _gvn.transform_no_reclaim(vtm));\n+          record_for_igvn(vtm);\n+        }\n+      } else if (phi != NULL) {\n@@ -1790,1 +1947,1 @@\n-        if (pnum == PhiNode::Input) {\n+        if (last_merge) {\n@@ -1806,2 +1963,1 @@\n-    if (pnum == PhiNode::Input &&\n-        !r->in(0)) {         \/\/ The occasional useless Region\n+    if (last_merge && !r->in(0)) {         \/\/ The occasional useless Region\n@@ -1959,0 +2115,2 @@\n+      } else if (n->is_InlineTypeBase() && n->as_InlineTypeBase()->has_phi_inputs(r)) {\n+        n->as_InlineTypeBase()->add_new_path(r);\n@@ -1981,0 +2139,4 @@\n+  InlineTypeBaseNode* vt = o->isa_InlineTypeBase();\n+  if (vt != NULL && vt->has_phi_inputs(region)) {\n+    return vt->get_oop()->as_Phi();\n+  }\n@@ -2000,2 +2162,2 @@\n-  \/\/ is mixing ints and oops or some such.  Forcing it to top\n-  \/\/ makes it go dead.\n+  \/\/ is already dead or is mixing ints and oops or some such.\n+  \/\/ Forcing it to top makes it go dead.\n@@ -2014,5 +2176,14 @@\n-  PhiNode* phi = PhiNode::make(region, o, t);\n-  gvn().set_type(phi, t);\n-  if (C->do_escape_analysis()) record_for_igvn(phi);\n-  map->set_req(idx, phi);\n-  return phi;\n+  if (vt != NULL && (t->is_inlinetypeptr() || t->isa_inlinetype())) {\n+    \/\/ Inline types are merged by merging their field values.\n+    \/\/ Create a cloned InlineTypeNode with phi inputs that\n+    \/\/ represents the merged inline type and update the map.\n+    vt = vt->clone_with_phis(&_gvn, region);\n+    map->set_req(idx, vt);\n+    return vt->get_oop()->as_Phi();\n+  } else {\n+    PhiNode* phi = PhiNode::make(region, o, t);\n+    gvn().set_type(phi, t);\n+    if (C->do_escape_analysis()) record_for_igvn(phi);\n+    map->set_req(idx, phi);\n+    return phi;\n+  }\n@@ -2211,1 +2382,4 @@\n-  set_bci(InvocationEntryBci);\n+  \/\/ vreturn can trigger an allocation so vreturn can throw. Setting\n+  \/\/ the bci here breaks exception handling. Commenting this out\n+  \/\/ doesn't seem to break anything.\n+  \/\/  set_bci(InvocationEntryBci);\n@@ -2218,17 +2392,0 @@\n-  SafePointNode* exit_return = _exits.map();\n-  exit_return->in( TypeFunc::Control  )->add_req( control() );\n-  exit_return->in( TypeFunc::I_O      )->add_req( i_o    () );\n-  Node *mem = exit_return->in( TypeFunc::Memory   );\n-  for (MergeMemStream mms(mem->as_MergeMem(), merged_memory()); mms.next_non_empty2(); ) {\n-    if (mms.is_empty()) {\n-      \/\/ get a copy of the base memory, and patch just this one input\n-      const TypePtr* adr_type = mms.adr_type(C);\n-      Node* phi = mms.force_memory()->as_Phi()->slice_memory(adr_type);\n-      assert(phi->as_Phi()->region() == mms.base_memory()->in(0), \"\");\n-      gvn().set_type_bottom(phi);\n-      phi->del_req(phi->req()-1);  \/\/ prepare to re-patch\n-      mms.set_memory(phi);\n-    }\n-    mms.memory()->add_req(mms.memory2());\n-  }\n-\n@@ -2237,9 +2394,29 @@\n-    \/\/ If returning oops to an interface-return, there is a silent free\n-    \/\/ cast from oop to interface allowed by the Verifier.  Make it explicit\n-    \/\/ here.\n-    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n-    if (tr && tr->is_loaded() &&\n-        tr->is_interface()) {\n-      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() &&\n-          !tp->is_interface()) {\n+    const Type* return_type = phi->bottom_type();\n+    const TypeInstPtr* tr = return_type->isa_instptr();\n+    \/\/ The return_type is set in Parse::build_exits().\n+    if (return_type->isa_inlinetype()) {\n+      \/\/ Inline type is returned as fields, make sure it is scalarized\n+      if (!value->is_InlineType()) {\n+        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), method()->signature()->returns_null_free_inline_type());\n+      }\n+      if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n+        \/\/ Returning from root or an incrementally inlined method. Make sure all non-flattened\n+        \/\/ fields are buffered and re-execute if allocation triggers deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        assert(tf()->returns_inline_type_as_fields(), \"must be returned as fields\");\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(1);\n+        value = value->as_InlineTypeBase()->allocate_fields(this);\n+      }\n+    } else if (value->is_InlineType()) {\n+      \/\/ Inline type is returned as oop, make sure it is buffered and re-execute\n+      \/\/ if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      inc_sp(1);\n+      value = value->as_InlineType()->buffer(this);\n+    } else if (tr && tr->isa_instptr() && tr->is_loaded() && tr->is_interface()) {\n+      \/\/ If returning oops to an interface-return, there is a silent free\n+      \/\/ cast from oop to interface allowed by the Verifier. Make it explicit here.\n+      const TypeInstPtr* tp = value->bottom_type()->isa_instptr();\n+      if (tp && tp->is_loaded() && !tp->is_interface()) {\n@@ -2248,1 +2425,1 @@\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n+        if (tp->higher_equal(TypeInstPtr::NOTNULL)) {\n@@ -2250,0 +2427,1 @@\n+        }\n@@ -2253,1 +2431,1 @@\n-      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n+      \/\/ Handle returns of oop-arrays to an arrays-of-interface return\n@@ -2256,1 +2434,1 @@\n-      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n+      Type::get_arrays_base_elements(return_type, value->bottom_type(), &phi_tip, &val_tip);\n@@ -2259,1 +2437,1 @@\n-        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n+        value = _gvn.transform(new CheckCastPPNode(0, value, return_type));\n@@ -2265,0 +2443,17 @@\n+  SafePointNode* exit_return = _exits.map();\n+  exit_return->in( TypeFunc::Control  )->add_req( control() );\n+  exit_return->in( TypeFunc::I_O      )->add_req( i_o    () );\n+  Node *mem = exit_return->in( TypeFunc::Memory   );\n+  for (MergeMemStream mms(mem->as_MergeMem(), merged_memory()); mms.next_non_empty2(); ) {\n+    if (mms.is_empty()) {\n+      \/\/ get a copy of the base memory, and patch just this one input\n+      const TypePtr* adr_type = mms.adr_type(C);\n+      Node* phi = mms.force_memory()->as_Phi()->slice_memory(adr_type);\n+      assert(phi->as_Phi()->region() == mms.base_memory()->in(0), \"\");\n+      gvn().set_type_bottom(phi);\n+      phi->del_req(phi->req()-1);  \/\/ prepare to re-patch\n+      mms.set_memory(phi);\n+    }\n+    mms.memory()->add_req(mms.memory2());\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":277,"deletions":82,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -39,0 +40,2 @@\n+#include \"opto\/idealKit.hpp\"\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -53,0 +56,17 @@\n+Node* Parse::record_profile_for_speculation_at_array_load(Node* ld) {\n+  \/\/ Feed unused profile data to type speculation\n+  if (UseTypeSpeculation && UseArrayLoadStoreProfile) {\n+    ciKlass* array_type = NULL;\n+    ciKlass* element_type = NULL;\n+    ProfilePtrKind element_ptr = ProfileMaybeNull;\n+    bool flat_array = true;\n+    bool null_free_array = true;\n+    method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+    if (element_type != NULL || element_ptr != ProfileMaybeNull) {\n+      ld = record_profile_for_speculation(ld, element_type, element_ptr);\n+    }\n+  }\n+  return ld;\n+}\n+\n+\n@@ -56,1 +76,0 @@\n-  bool big_val = bt == T_DOUBLE || bt == T_LONG;\n@@ -60,2 +79,92 @@\n-  pop();                      \/\/ index (already used)\n-  Node* array = pop();        \/\/ the array itself\n+  Node* idx = pop();\n+  Node* ary = pop();\n+\n+  \/\/ Handle inline type arrays\n+  const TypeOopPtr* elemptr = elemtype->make_oopptr();\n+  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+  if (ary_t->is_flat()) {\n+    \/\/ Load from flattened inline type array\n+    Node* vt = InlineTypeNode::make_from_flattened(this, elemtype->inline_klass(), ary, adr);\n+    push(vt);\n+    return;\n+  } else if (ary_t->is_null_free()) {\n+    \/\/ Load from non-flattened inline type array (elements can never be null)\n+    bt = T_PRIMITIVE_OBJECT;\n+  } else if (!ary_t->is_not_flat()) {\n+    \/\/ Cannot statically determine if array is flattened, emit runtime check\n+    assert(UseFlatArray && is_reference_type(bt) && elemptr->can_be_inline_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&\n+           (!elemptr->is_inlinetypeptr() || elemptr->inline_klass()->flatten_array()), \"array can't be flattened\");\n+    IdealKit ideal(this);\n+    IdealVariable res(ideal);\n+    ideal.declarations_done();\n+    ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n+      \/\/ non-flattened\n+      assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n+      sync_kit(ideal);\n+      const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n+      Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,\n+                                IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);\n+      if (elemptr->is_inlinetypeptr()) {\n+        assert(elemptr->maybe_null(), \"null free array should be handled above\");\n+        ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), false);\n+      }\n+      ideal.sync_kit(this);\n+      ideal.set(res, ld);\n+    } ideal.else_(); {\n+      \/\/ flattened\n+      sync_kit(ideal);\n+      if (elemptr->is_inlinetypeptr()) {\n+        \/\/ Element type is known, cast and load from flattened representation\n+        ciInlineKlass* vk = elemptr->inline_klass();\n+        assert(vk->flatten_array() && elemptr->maybe_null(), \"never\/always flat - should be optimized\");\n+        ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n+        const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));\n+        Node* casted_adr = array_element_address(cast, idx, T_PRIMITIVE_OBJECT, ary_t->size(), control());\n+        \/\/ Re-execute flattened array load if buffering triggers deoptimization\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(2);\n+        Node* vt = InlineTypeNode::make_from_flattened(this, vk, cast, casted_adr)->buffer(this, false);\n+        ideal.set(res, vt);\n+        ideal.sync_kit(this);\n+      } else {\n+        \/\/ Element type is unknown, emit runtime call\n+\n+        \/\/ Below membars keep this access to an unknown flattened array correctly\n+        \/\/ ordered with other unknown and known flattened array accesses.\n+        insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+        Node* call = NULL;\n+        {\n+          \/\/ Re-execute flattened array load if runtime call triggers deoptimization\n+          PreserveReexecuteState preexecs(this);\n+          jvms()->set_bci(_bci);\n+          jvms()->set_should_reexecute(true);\n+          inc_sp(2);\n+          kill_dead_locals();\n+          call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                                   OptoRuntime::load_unknown_inline_type(),\n+                                   OptoRuntime::load_unknown_inline_Java(),\n+                                   NULL, TypeRawPtr::BOTTOM,\n+                                   ary, idx);\n+        }\n+        make_slow_call_ex(call, env()->Throwable_klass(), false);\n+        Node* buffer = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+\n+        insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+        \/\/ Keep track of the information that the inline type is flattened in arrays\n+        const Type* unknown_value = elemptr->is_instptr()->cast_to_flatten_array();\n+        buffer = _gvn.transform(new CheckCastPPNode(control(), buffer, unknown_value));\n+\n+        ideal.sync_kit(this);\n+        ideal.set(res, buffer);\n+      }\n+    } ideal.end_if();\n+    sync_kit(ideal);\n+    Node* ld = _gvn.transform(ideal.value(res));\n+    ld = record_profile_for_speculation_at_array_load(ld);\n+    push_node(bt, ld);\n+    return;\n+  }\n@@ -67,2 +176,1 @@\n-\n-  Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,\n+  Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,\n@@ -70,4 +178,5 @@\n-  if (big_val) {\n-    push_pair(ld);\n-  } else {\n-    push(ld);\n+  ld = record_profile_for_speculation_at_array_load(ld);\n+  \/\/ Loading a non-flattened inline type\n+  if (elemptr != NULL && elemptr->is_inlinetypeptr()) {\n+    assert(!ary_t->is_null_free() || !elemptr->maybe_null(), \"inline type array elements should never be null\");\n+    ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), !elemptr->maybe_null());\n@@ -75,0 +184,1 @@\n+  push_node(bt, ld);\n@@ -81,2 +191,1 @@\n-  bool big_val = bt == T_DOUBLE || bt == T_LONG;\n-  Node* adr = array_addressing(bt, big_val ? 2 : 1, elemtype);\n+  Node* adr = array_addressing(bt, type2size[bt], elemtype);\n@@ -84,0 +193,1 @@\n+  Node* cast_val = NULL;\n@@ -85,4 +195,2 @@\n-    array_store_check();\n-    if (stopped()) {\n-      return;\n-    }\n+    cast_val = array_store_check(adr, elemtype);\n+    if (stopped()) return;\n@@ -90,8 +198,7 @@\n-  Node* val;                  \/\/ Oop to store\n-  if (big_val) {\n-    val = pop_pair();\n-  } else {\n-    val = pop();\n-  }\n-  pop();                      \/\/ index (already used)\n-  Node* array = pop();        \/\/ the array itself\n+  Node* val = pop_node(bt); \/\/ Value to store\n+  Node* idx = pop();        \/\/ Index in the array\n+  Node* ary = pop();        \/\/ The array itself\n+\n+  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+  const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n+  assert(adr->as_AddP()->in(AddPNode::Base) == ary, \"inconsistent address base\");\n@@ -101,0 +208,121 @@\n+  } else if (bt == T_OBJECT) {\n+    elemtype = elemtype->make_oopptr();\n+    const Type* tval = _gvn.type(cast_val);\n+    \/\/ We may have lost type information for 'val' here due to the casts\n+    \/\/ emitted by the array_store_check code (see JDK-6312651)\n+    \/\/ TODO Remove this code once JDK-6312651 is in.\n+    const Type* tval_init = _gvn.type(val);\n+    \/\/ Based on the value to be stored, try to determine if the array is not null-free and\/or not flat.\n+    \/\/ This is only legal for non-null stores because the array_store_check always passes for null, even\n+    \/\/ if the array is null-free. Null stores are handled in GraphKit::gen_inline_array_null_guard().\n+    bool not_inline = !tval->isa_inlinetype() &&\n+                      ((!tval_init->maybe_null() && !tval_init->is_oopptr()->can_be_inline_type()) ||\n+                       (!tval->maybe_null() && !tval->is_oopptr()->can_be_inline_type()));\n+    bool not_flattened = not_inline || ((tval_init->is_inlinetypeptr() || tval_init->isa_inlinetype()) && !tval_init->inline_klass()->flatten_array());\n+    if (!ary_t->is_not_null_free() && not_inline) {\n+      \/\/ Storing a non-inline type, mark array as not null-free (-> not flat).\n+      ary_t = ary_t->cast_to_not_null_free();\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n+      replace_in_map(ary, cast);\n+      ary = cast;\n+    } else if (!ary_t->is_not_flat() && not_flattened) {\n+      \/\/ Storing a non-flattened value, mark array as not flat.\n+      ary_t = ary_t->cast_to_not_flat();\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n+      replace_in_map(ary, cast);\n+      ary = cast;\n+    }\n+\n+    if (ary_t->is_flat()) {\n+      \/\/ Store to flattened inline type array\n+      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n+      \/\/ Re-execute flattened array store if buffering triggers deoptimization\n+      PreserveReexecuteState preexecs(this);\n+      inc_sp(3);\n+      jvms()->set_should_reexecute(true);\n+      cast_val->as_InlineTypeBase()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      return;\n+    } else if (ary_t->is_null_free()) {\n+      \/\/ Store to non-flattened inline type array (elements can never be null)\n+      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n+      if (elemtype->inline_klass()->is_empty()) {\n+        \/\/ Ignore empty inline stores, array is already initialized.\n+        return;\n+      }\n+    } else if (!ary_t->is_not_flat() && (tval != TypePtr::NULL_PTR || StressReflectiveCode)) {\n+      \/\/ Array might be flattened, emit runtime checks (for NULL, a simple inline_array_null_guard is sufficient).\n+      assert(UseFlatArray && !not_flattened && elemtype->is_oopptr()->can_be_inline_type() &&\n+             !ary_t->klass_is_exact() && !ary_t->is_not_null_free(), \"array can't be flattened\");\n+      IdealKit ideal(this);\n+      ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n+        \/\/ non-flattened\n+        assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n+        sync_kit(ideal);\n+        Node* cast_ary = inline_array_null_guard(ary, cast_val, 3);\n+        inc_sp(3);\n+        access_store_at(cast_ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n+        dec_sp(3);\n+        ideal.sync_kit(this);\n+      } ideal.else_(); {\n+        sync_kit(ideal);\n+        \/\/ flattened\n+        Node* null_ctl = top();\n+        Node* val = null_check_oop(cast_val, &null_ctl);\n+        if (null_ctl != top()) {\n+          PreserveJVMState pjvms(this);\n+          inc_sp(3);\n+          set_control(null_ctl);\n+          uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);\n+          dec_sp(3);\n+        }\n+        \/\/ Try to determine the inline klass\n+        ciInlineKlass* vk = NULL;\n+        if (tval->isa_inlinetype() || tval->is_inlinetypeptr()) {\n+          vk = tval->inline_klass();\n+        } else if (tval_init->isa_inlinetype() || tval_init->is_inlinetypeptr()) {\n+          vk = tval_init->inline_klass();\n+        } else if (elemtype->is_inlinetypeptr()) {\n+          vk = elemtype->inline_klass();\n+        }\n+        Node* casted_ary = ary;\n+        if (vk != NULL && !stopped()) {\n+          \/\/ Element type is known, cast and store to flattened representation\n+          assert(vk->flatten_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n+          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n+          const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+          casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));\n+          Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype->size(), control());\n+          if (!val->is_InlineType()) {\n+            assert(!gvn().type(val)->maybe_null(), \"inline type array elements should never be null\");\n+            val = InlineTypeNode::make_from_oop(this, val, vk);\n+          }\n+          \/\/ Re-execute flattened array store if buffering triggers deoptimization\n+          PreserveReexecuteState preexecs(this);\n+          inc_sp(3);\n+          jvms()->set_should_reexecute(true);\n+          val->as_InlineTypeBase()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+        } else if (!stopped()) {\n+          \/\/ Element type is unknown, emit runtime call\n+\n+          \/\/ Below membars keep this access to an unknown flattened array correctly\n+          \/\/ ordered with other unknown and known flattened array accesses.\n+          insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+          make_runtime_call(RC_LEAF,\n+                            OptoRuntime::store_unknown_inline_type(),\n+                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),\n+                            \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n+                            val, casted_ary, idx);\n+\n+          insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+        }\n+        ideal.sync_kit(this);\n+      }\n+      ideal.end_if();\n+      sync_kit(ideal);\n+      return;\n+    } else if (!ary_t->is_not_null_free()) {\n+      \/\/ Array is not flattened but may be null free\n+      assert(elemtype->is_oopptr()->can_be_inline_type() && !ary_t->klass_is_exact(), \"array can't be null-free\");\n+      ary = inline_array_null_guard(ary, cast_val, 3, true);\n+    }\n@@ -102,3 +330,3 @@\n-  const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n-\n-  access_store_at(array, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+  inc_sp(3);\n+  access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+  dec_sp(3);\n@@ -205,0 +433,116 @@\n+  \/\/ This could be an access to an inline type array. We can't tell if it's\n+  \/\/ flat or not. Knowing the exact type avoids runtime checks and leads to\n+  \/\/ a much simpler graph shape. Check profile information.\n+  if (!arytype->is_flat() && !arytype->is_not_flat()) {\n+    \/\/ First check the speculative type\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;\n+    ciKlass* array_type = arytype->speculative_type();\n+    if (too_many_traps_or_recompiles(reason) || array_type == NULL) {\n+      \/\/ No speculative type, check profile data at this bci\n+      array_type = NULL;\n+      reason = Deoptimization::Reason_class_check;\n+      if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(reason)) {\n+        ciKlass* element_type = NULL;\n+        ProfilePtrKind element_ptr = ProfileMaybeNull;\n+        bool flat_array = true;\n+        bool null_free_array = true;\n+        method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      }\n+    }\n+    if (array_type != NULL) {\n+      \/\/ Speculate that this array has the exact type reported by profile data\n+      Node* better_ary = NULL;\n+      DEBUG_ONLY(Node* old_control = control();)\n+      Node* slow_ctl = type_check_receiver(ary, array_type, 1.0, &better_ary);\n+      if (stopped()) {\n+        \/\/ The check always fails and therefore profile information is incorrect. Don't use it.\n+        assert(old_control == slow_ctl, \"type check should have been removed\");\n+        set_control(slow_ctl);\n+      } else if (!slow_ctl->is_top()) {\n+        { PreserveJVMState pjvms(this);\n+          set_control(slow_ctl);\n+          uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+        }\n+        replace_in_map(ary, better_ary);\n+        ary = better_ary;\n+        arytype  = _gvn.type(ary)->is_aryptr();\n+        elemtype = arytype->elem();\n+      }\n+    }\n+  } else if (UseTypeSpeculation && UseArrayLoadStoreProfile) {\n+    \/\/ No need to speculate: feed profile data at this bci for the\n+    \/\/ array to type speculation\n+    ciKlass* array_type = NULL;\n+    ciKlass* element_type = NULL;\n+    ProfilePtrKind element_ptr = ProfileMaybeNull;\n+    bool flat_array = true;\n+    bool null_free_array = true;\n+    method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+    if (array_type != NULL) {\n+      ary = record_profile_for_speculation(ary, array_type, ProfileMaybeNull);\n+    }\n+  }\n+\n+  \/\/ We have no exact array type from profile data. Check profile data\n+  \/\/ for a non null-free or non flat array. Non null-free implies non\n+  \/\/ flat so check this one first. Speculating on a non null-free\n+  \/\/ array doesn't help aaload but could be profitable for a\n+  \/\/ subsequent aastore.\n+  if (!arytype->is_null_free() && !arytype->is_not_null_free()) {\n+    bool null_free_array = true;\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_none;\n+    if (arytype->speculative() != NULL &&\n+        arytype->speculative()->is_aryptr()->is_not_null_free() &&\n+        !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      null_free_array = false;\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n+      ciKlass* array_type = NULL;\n+      ciKlass* element_type = NULL;\n+      ProfilePtrKind element_ptr = ProfileMaybeNull;\n+      bool flat_array = true;\n+      method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    if (!null_free_array) {\n+      { \/\/ Deoptimize if null-free array\n+        BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n+        uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+      }\n+      assert(!stopped(), \"null-free array should have been caught earlier\");\n+      Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype->cast_to_not_null_free()));\n+      replace_in_map(ary, better_ary);\n+      ary = better_ary;\n+      arytype = _gvn.type(ary)->is_aryptr();\n+    }\n+  }\n+\n+  if (!arytype->is_flat() && !arytype->is_not_flat()) {\n+    bool flat_array = true;\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_none;\n+    if (arytype->speculative() != NULL &&\n+        arytype->speculative()->is_aryptr()->is_not_flat() &&\n+        !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      flat_array = false;\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(reason)) {\n+      ciKlass* array_type = NULL;\n+      ciKlass* element_type = NULL;\n+      ProfilePtrKind element_ptr = ProfileMaybeNull;\n+      bool null_free_array = true;\n+      method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    if (!flat_array) {\n+      { \/\/ Deoptimize if flat array\n+        BuildCutout unless(this, flat_array_test(ary, \/* flat = *\/ false), PROB_MAX);\n+        uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+      }\n+      assert(!stopped(), \"flat array should have been caught earlier\");\n+      Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype->cast_to_not_flat()));\n+      replace_in_map(ary, better_ary);\n+      ary = better_ary;\n+      arytype = _gvn.type(ary)->is_aryptr();\n+    }\n+  }\n+\n@@ -1413,1 +1757,1 @@\n-      adjust_map_after_if(btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(btest, c, prob, branch_block);\n@@ -1431,2 +1775,1 @@\n-    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);\n@@ -1437,1 +1780,1 @@\n-void Parse::do_if(BoolTest::mask btest, Node* c) {\n+void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {\n@@ -1521,2 +1864,2 @@\n-      if (C->eliminate_boxing()) {\n-        \/\/ Mark the successor block as parsed\n+      if (C->eliminate_boxing() && !new_path) {\n+        \/\/ Mark the successor block as parsed (if we haven't created a new path)\n@@ -1526,1 +1869,1 @@\n-      adjust_map_after_if(taken_btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(taken_btest, c, prob, branch_block);\n@@ -1528,1 +1871,9 @@\n-        merge(target_bci);\n+        if (new_path) {\n+          \/\/ Merge by using a new path\n+          merge_new_path(target_bci);\n+        } else if (ctrl_taken != NULL) {\n+          \/\/ Don't merge but save taken branch to be wired by caller\n+          *ctrl_taken = control();\n+        } else {\n+          merge(target_bci);\n+        }\n@@ -1537,1 +1888,1 @@\n-  if (stopped()) {\n+  if (stopped() && ctrl_taken == NULL) {\n@@ -1539,1 +1890,1 @@\n-      \/\/ Mark the successor block as parsed\n+      \/\/ Mark the successor block as parsed (if caller does not re-wire control flow)\n@@ -1543,2 +1894,396 @@\n-    adjust_map_after_if(untaken_btest, c, untaken_prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);\n+  }\n+}\n+\n+\n+static ProfilePtrKind speculative_ptr_kind(const TypeOopPtr* t) {\n+  if (t->speculative() == NULL) {\n+    return ProfileUnknownNull;\n+  }\n+  if (t->speculative_always_null()) {\n+    return ProfileAlwaysNull;\n+  }\n+  if (t->speculative_maybe_null()) {\n+    return ProfileMaybeNull;\n+  }\n+  return ProfileNeverNull;\n+}\n+\n+void Parse::acmp_always_null_input(Node* input, const TypeOopPtr* tinput, BoolTest::mask btest, Node* eq_region) {\n+  inc_sp(2);\n+  Node* cast = null_check_common(input, T_OBJECT, true, NULL,\n+                                 !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check) &&\n+                                 speculative_ptr_kind(tinput) == ProfileAlwaysNull);\n+  dec_sp(2);\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      replace_in_map(input, cast);\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    replace_in_map(input, cast);\n+  }\n+}\n+\n+Node* Parse::acmp_null_check(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, Node*& null_ctl) {\n+  inc_sp(2);\n+  null_ctl = top();\n+  Node* cast = null_check_oop(input, &null_ctl,\n+                              input_ptr == ProfileNeverNull || (input_ptr == ProfileUnknownNull && !too_many_traps_or_recompiles(Deoptimization::Reason_null_check)),\n+                              false,\n+                              speculative_ptr_kind(tinput) == ProfileNeverNull &&\n+                              !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check));\n+  dec_sp(2);\n+  assert(!stopped(), \"null input should have been caught earlier\");\n+  if (cast->is_InlineType()) {\n+    cast = cast->as_InlineType()->get_oop();\n+  }\n+  return cast;\n+}\n+\n+void Parse::acmp_known_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, ciKlass* input_type, BoolTest::mask btest, Node* eq_region) {\n+  Node* ne_region = new RegionNode(1);\n+  Node* null_ctl;\n+  Node* cast = acmp_null_check(input, tinput, input_ptr, null_ctl);\n+  ne_region->add_req(null_ctl);\n+\n+  Node* slow_ctl = type_check_receiver(cast, input_type, 1.0, &cast);\n+  {\n+    PreserveJVMState pjvms(this);\n+    inc_sp(2);\n+    set_control(slow_ctl);\n+    Deoptimization::DeoptReason reason;\n+    if (tinput->speculative_type() != NULL && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else {\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+  }\n+  ne_region->add_req(control());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      if (null_ctl == top()) {\n+        replace_in_map(input, cast);\n+      }\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    if (null_ctl == top()) {\n+      replace_in_map(input, cast);\n+    }\n+    set_control(_gvn.transform(ne_region));\n+  }\n+}\n+\n+void Parse::acmp_unknown_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, BoolTest::mask btest, Node* eq_region) {\n+  Node* ne_region = new RegionNode(1);\n+  Node* null_ctl;\n+  Node* cast = acmp_null_check(input, tinput, input_ptr, null_ctl);\n+  ne_region->add_req(null_ctl);\n+\n+  {\n+    BuildCutout unless(this, inline_type_test(cast, \/* is_inline = *\/ false), PROB_MAX);\n+    inc_sp(2);\n+    uncommon_trap_exact(Deoptimization::Reason_class_check, Deoptimization::Action_maybe_recompile);\n+  }\n+\n+  ne_region->add_req(control());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      if (null_ctl == top()) {\n+        replace_in_map(input, cast);\n+      }\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    if (null_ctl == top()) {\n+      replace_in_map(input, cast);\n+    }\n+    set_control(_gvn.transform(ne_region));\n+  }\n+}\n+\n+void Parse::do_acmp(BoolTest::mask btest, Node* left, Node* right) {\n+  ciKlass* left_type = NULL;\n+  ciKlass* right_type = NULL;\n+  ProfilePtrKind left_ptr = ProfileUnknownNull;\n+  ProfilePtrKind right_ptr = ProfileUnknownNull;\n+  bool left_inline_type = true;\n+  bool right_inline_type = true;\n+\n+  \/\/ Leverage profiling at acmp\n+  if (UseACmpProfile) {\n+    method()->acmp_profiled_type(bci(), left_type, right_type, left_ptr, right_ptr, left_inline_type, right_inline_type);\n+    if (too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n+      left_type = NULL;\n+      right_type = NULL;\n+      left_inline_type = true;\n+      right_inline_type = true;\n+    }\n+    if (too_many_traps_or_recompiles(Deoptimization::Reason_null_check)) {\n+      left_ptr = ProfileUnknownNull;\n+      right_ptr = ProfileUnknownNull;\n+    }\n+  }\n+\n+  if (UseTypeSpeculation) {\n+    record_profile_for_speculation(left, left_type, left_ptr);\n+    record_profile_for_speculation(right, right_type, right_ptr);\n+  }\n+\n+  if (!EnableValhalla) {\n+    Node* cmp = CmpP(left, right);\n+    cmp = optimize_cmp_with_klass(cmp);\n+    do_if(btest, cmp);\n+    return;\n+  }\n+\n+  \/\/ Check for equality before potentially allocating\n+  if (left == right) {\n+    do_if(btest, makecon(TypeInt::CC_EQ));\n+    return;\n+  }\n+\n+  \/\/ Allocate inline type operands and re-execute on deoptimization\n+  if (left->is_InlineTypeBase()) {\n+    if (_gvn.type(right)->is_zero_type() ||\n+        (right->is_InlineTypeBase() && _gvn.type(right->as_InlineTypeBase()->get_is_init())->is_zero_type())) {\n+      \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+      \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+      Node* cmp = CmpI(left->as_InlineTypeBase()->get_is_init(), intcon(0));\n+      do_if(btest, cmp);\n+      return;\n+    } else if (left->is_InlineType()){\n+      PreserveReexecuteState preexecs(this);\n+      inc_sp(2);\n+      jvms()->set_should_reexecute(true);\n+      left = left->as_InlineType()->buffer(this)->get_oop();\n+    }\n+  }\n+  if (right->is_InlineType()) {\n+    PreserveReexecuteState preexecs(this);\n+    inc_sp(2);\n+    jvms()->set_should_reexecute(true);\n+    right = right->as_InlineType()->buffer(this)->get_oop();\n+  }\n+\n+  \/\/ First, do a normal pointer comparison\n+  const TypeOopPtr* tleft = _gvn.type(left)->isa_oopptr();\n+  const TypeOopPtr* tright = _gvn.type(right)->isa_oopptr();\n+  Node* cmp = CmpP(left, right);\n+  cmp = optimize_cmp_with_klass(cmp);\n+  if (tleft == NULL || !tleft->can_be_inline_type() ||\n+      tright == NULL || !tright->can_be_inline_type()) {\n+    \/\/ This is sufficient, if one of the operands can't be an inline type\n+    do_if(btest, cmp);\n+    return;\n+  }\n+  Node* eq_region = NULL;\n+  if (btest == BoolTest::eq) {\n+    do_if(btest, cmp, true);\n+    if (stopped()) {\n+      return;\n+    }\n+  } else {\n+    assert(btest == BoolTest::ne, \"only eq or ne\");\n+    Node* is_not_equal = NULL;\n+    eq_region = new RegionNode(3);\n+    {\n+      PreserveJVMState pjvms(this);\n+      do_if(btest, cmp, false, &is_not_equal);\n+      if (!stopped()) {\n+        eq_region->init_req(1, control());\n+      }\n+    }\n+    if (is_not_equal == NULL || is_not_equal->is_top()) {\n+      record_for_igvn(eq_region);\n+      set_control(_gvn.transform(eq_region));\n+      return;\n+    }\n+    set_control(is_not_equal);\n+  }\n+\n+  \/\/ Prefer speculative types if available\n+  if (!too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+    if (tleft->speculative_type() != NULL) {\n+      left_type = tleft->speculative_type();\n+    }\n+    if (tright->speculative_type() != NULL) {\n+      right_type = tright->speculative_type();\n+    }\n+  }\n+\n+  if (speculative_ptr_kind(tleft) != ProfileMaybeNull && speculative_ptr_kind(tleft) != ProfileUnknownNull) {\n+    ProfilePtrKind speculative_left_ptr = speculative_ptr_kind(tleft);\n+    if (speculative_left_ptr == ProfileAlwaysNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_assert)) {\n+      left_ptr = speculative_left_ptr;\n+    } else if (speculative_left_ptr == ProfileNeverNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check)) {\n+      left_ptr = speculative_left_ptr;\n+    }\n+  }\n+  if (speculative_ptr_kind(tright) != ProfileMaybeNull && speculative_ptr_kind(tright) != ProfileUnknownNull) {\n+    ProfilePtrKind speculative_right_ptr = speculative_ptr_kind(tright);\n+    if (speculative_right_ptr == ProfileAlwaysNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_assert)) {\n+      right_ptr = speculative_right_ptr;\n+    } else if (speculative_right_ptr == ProfileNeverNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check)) {\n+      right_ptr = speculative_right_ptr;\n+    }\n+  }\n+\n+  if (left_ptr == ProfileAlwaysNull) {\n+    \/\/ Comparison with null. Assert the input is indeed null and we're done.\n+    acmp_always_null_input(left, tleft, btest, eq_region);\n+    return;\n+  }\n+  if (right_ptr == ProfileAlwaysNull) {\n+    \/\/ Comparison with null. Assert the input is indeed null and we're done.\n+    acmp_always_null_input(right, tright, btest, eq_region);\n+    return;\n+  }\n+  if (left_type != NULL && !left_type->is_inlinetype()) {\n+    \/\/ Comparison with an object of known type\n+    acmp_known_non_inline_type_input(left, tleft, left_ptr, left_type, btest, eq_region);\n+    return;\n+  }\n+  if (right_type != NULL && !right_type->is_inlinetype()) {\n+    \/\/ Comparison with an object of known type\n+    acmp_known_non_inline_type_input(right, tright, right_ptr, right_type, btest, eq_region);\n+    return;\n+  }\n+  if (!left_inline_type) {\n+    \/\/ Comparison with an object known not to be an inline type\n+    acmp_unknown_non_inline_type_input(left, tleft, left_ptr, btest, eq_region);\n+    return;\n+  }\n+  if (!right_inline_type) {\n+    \/\/ Comparison with an object known not to be an inline type\n+    acmp_unknown_non_inline_type_input(right, tright, right_ptr, btest, eq_region);\n+    return;\n+  }\n+\n+  \/\/ Pointers are not equal, check if first operand is non-null\n+  Node* ne_region = new RegionNode(6);\n+  Node* null_ctl;\n+  Node* not_null_right = acmp_null_check(right, tright, right_ptr, null_ctl);\n+  ne_region->init_req(1, null_ctl);\n+\n+  \/\/ First operand is non-null, check if it is an inline type\n+  Node* is_value = inline_type_test(not_null_right);\n+  IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);\n+  Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));\n+  ne_region->init_req(2, not_value);\n+  set_control(_gvn.transform(new IfTrueNode(is_value_iff)));\n+\n+  \/\/ The first operand is an inline type, check if the second operand is non-null\n+  Node* not_null_left = acmp_null_check(left, tleft, left_ptr, null_ctl);\n+  ne_region->init_req(3, null_ctl);\n+\n+  \/\/ Check if both operands are of the same class.\n+  Node* kls_left = load_object_klass(not_null_left);\n+  Node* kls_right = load_object_klass(not_null_right);\n+  Node* kls_cmp = CmpP(kls_left, kls_right);\n+  Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));\n+  IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);\n+  Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));\n+  set_control(_gvn.transform(new IfFalseNode(kls_iff)));\n+  ne_region->init_req(4, kls_ne);\n+\n+  if (stopped()) {\n+    record_for_igvn(ne_region);\n+    set_control(_gvn.transform(ne_region));\n+    if (btest == BoolTest::ne) {\n+      {\n+        PreserveJVMState pjvms(this);\n+        int target_bci = iter().get_dest();\n+        merge(target_bci);\n+      }\n+      record_for_igvn(eq_region);\n+      set_control(_gvn.transform(eq_region));\n+    }\n+    return;\n+  }\n+\n+  \/\/ Both operands are values types of the same class, we need to perform a\n+  \/\/ substitutability test. Delegate to PrimitiveObjectMethods::isSubstitutable().\n+  Node* ne_io_phi = PhiNode::make(ne_region, i_o());\n+  Node* mem = reset_memory();\n+  Node* ne_mem_phi = PhiNode::make(ne_region, mem);\n+\n+  Node* eq_io_phi = NULL;\n+  Node* eq_mem_phi = NULL;\n+  if (eq_region != NULL) {\n+    eq_io_phi = PhiNode::make(eq_region, i_o());\n+    eq_mem_phi = PhiNode::make(eq_region, mem);\n+  }\n+\n+  set_all_memory(mem);\n+\n+  kill_dead_locals();\n+  ciMethod* subst_method = ciEnv::current()->PrimitiveObjectMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n+  CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method);\n+  call->set_override_symbolic_info(true);\n+  call->init_req(TypeFunc::Parms, not_null_left);\n+  call->init_req(TypeFunc::Parms+1, not_null_right);\n+  inc_sp(2);\n+  set_edges_for_java_call(call, false, false);\n+  Node* ret = set_results_for_java_call(call, false, true);\n+  dec_sp(2);\n+\n+  \/\/ Test the return value of PrimitiveObjectMethods::isSubstitutable()\n+  Node* subst_cmp = _gvn.transform(new CmpINode(ret, intcon(1)));\n+  Node* ctl = C->top();\n+  if (btest == BoolTest::eq) {\n+    PreserveJVMState pjvms(this);\n+    do_if(btest, subst_cmp);\n+    if (!stopped()) {\n+      ctl = control();\n+    }\n+  } else {\n+    assert(btest == BoolTest::ne, \"only eq or ne\");\n+    PreserveJVMState pjvms(this);\n+    do_if(btest, subst_cmp, false, &ctl);\n+    if (!stopped()) {\n+      eq_region->init_req(2, control());\n+      eq_io_phi->init_req(2, i_o());\n+      eq_mem_phi->init_req(2, reset_memory());\n+    }\n+  }\n+  ne_region->init_req(5, ctl);\n+  ne_io_phi->init_req(5, i_o());\n+  ne_mem_phi->init_req(5, reset_memory());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  set_i_o(_gvn.transform(ne_io_phi));\n+  set_all_memory(_gvn.transform(ne_mem_phi));\n+\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+    set_i_o(_gvn.transform(eq_io_phi));\n+    set_all_memory(_gvn.transform(eq_mem_phi));\n@@ -1574,2 +2319,1 @@\n-void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                                Block* path, Block* other_path) {\n+void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {\n@@ -1789,0 +2533,4 @@\n+        if (obj->is_InlineType()) {\n+          assert(obj->as_InlineType()->is_allocated(&_gvn), \"must be allocated\");\n+          obj = obj->as_InlineType()->get_oop();\n+        }\n@@ -2634,14 +3382,20 @@\n-    if (!_gvn.type(b)->speculative_maybe_null() &&\n-        !too_many_traps(Deoptimization::Reason_speculate_null_check)) {\n-      inc_sp(1);\n-      Node* null_ctl = top();\n-      b = null_check_oop(b, &null_ctl, true, true, true);\n-      assert(null_ctl->is_top(), \"no null control here\");\n-      dec_sp(1);\n-    } else if (_gvn.type(b)->speculative_always_null() &&\n-               !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {\n-      inc_sp(1);\n-      b = null_assert(b);\n-      dec_sp(1);\n-    }\n-    c = _gvn.transform( new CmpPNode(b, a) );\n+    if (b->is_InlineType()) {\n+      \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+      \/\/ input instead of the oop input to avoid keeping buffer allocations alive\n+      c = _gvn.transform(new CmpINode(b->as_InlineType()->get_is_init(), zerocon(T_INT)));\n+    } else {\n+      if (!_gvn.type(b)->speculative_maybe_null() &&\n+          !too_many_traps(Deoptimization::Reason_speculate_null_check)) {\n+        inc_sp(1);\n+        Node* null_ctl = top();\n+        b = null_check_oop(b, &null_ctl, true, true, true);\n+        assert(null_ctl->is_top(), \"no null control here\");\n+        dec_sp(1);\n+      } else if (_gvn.type(b)->speculative_always_null() &&\n+                 !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {\n+        inc_sp(1);\n+        b = null_assert(b);\n+        dec_sp(1);\n+      }\n+      c = _gvn.transform( new CmpPNode(b, a) );\n+    }\n@@ -2658,3 +3412,1 @@\n-    c = _gvn.transform( new CmpPNode(b, a) );\n-    c = optimize_cmp_with_klass(c);\n-    do_if(btest, c);\n+    do_acmp(btest, b, a);\n@@ -2715,1 +3467,1 @@\n-    do_anewarray();\n+    do_newarray();\n@@ -2726,0 +3478,6 @@\n+  case Bytecodes::_aconst_init:\n+    do_aconst_init();\n+    break;\n+  case Bytecodes::_withfield:\n+    do_withfield();\n+    break;\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":816,"deletions":58,"binary":false,"changes":874,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -30,0 +32,2 @@\n+#include \"opto\/castnode.hpp\"\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -68,1 +72,1 @@\n-\n+  bool null_free = iter().has_Q_signature();\n@@ -76,0 +80,1 @@\n+    assert(!null_free, \"Inline type should be loaded\");\n@@ -93,1 +98,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)), NULL, null_free);\n@@ -141,2 +146,1 @@\n-void Parse::array_store_check() {\n-\n+Node* Parse::array_store_check(Node*& adr, const Type*& elemtype) {\n@@ -153,1 +157,4 @@\n-    return;\n+    if (_gvn.type(ary)->is_aryptr()->is_null_free()) {\n+      null_check(obj);\n+    }\n+    return obj;\n@@ -157,4 +164,1 @@\n-  int klass_offset = oopDesc::klass_offset_in_bytes();\n-  Node* p = basic_plus_adr( ary, ary, klass_offset );\n-  \/\/ p's type is array-of-OOPS plus klass_offset\n-  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS));\n+  Node* array_klass = load_object_klass(ary);\n@@ -162,1 +166,1 @@\n-  const TypeKlassPtr *tak = _gvn.type(array_klass)->is_klassptr();\n+  const TypeKlassPtr* tak = _gvn.type(array_klass)->is_klassptr();\n@@ -169,6 +173,26 @@\n-  if (MonomorphicArrayCheck\n-      && !too_many_traps(Deoptimization::Reason_array_check)\n-      && !tak->klass_is_exact()\n-      && tak != TypeInstKlassPtr::OBJECT) {\n-      \/\/ Regarding the fourth condition in the if-statement from above:\n-      \/\/\n+  if (MonomorphicArrayCheck && !tak->klass_is_exact()) {\n+    \/\/ Make a constant out of the inexact array klass\n+    const TypeKlassPtr* extak = NULL;\n+    const TypeOopPtr* ary_t = _gvn.type(ary)->is_oopptr();\n+    ciKlass* ary_spec = ary_t->speculative_type();\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_none;\n+    \/\/ Try to cast the array to an exact type from profile data. First\n+    \/\/ check the speculative type.\n+    if (ary_spec != NULL && !too_many_traps(Deoptimization::Reason_speculate_class_check)) {\n+      extak = TypeKlassPtr::make(ary_spec);\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else if (UseArrayLoadStoreProfile) {\n+      \/\/ No speculative type: check profile data at this bci.\n+      reason = Deoptimization::Reason_class_check;\n+      if (!too_many_traps(reason)) {\n+        ciKlass* array_type = NULL;\n+        ciKlass* element_type = NULL;\n+        ProfilePtrKind element_ptr = ProfileMaybeNull;\n+        bool flat_array = true;\n+        bool null_free_array = true;\n+        method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+        if (array_type != NULL) {\n+          extak = TypeKlassPtr::make(array_type);\n+        }\n+      }\n+    } else if (!too_many_traps(Deoptimization::Reason_array_check) && tak != TypeInstKlassPtr::OBJECT) {\n@@ -193,8 +217,4 @@\n-\n-    always_see_exact_class = true;\n-    \/\/ (If no MDO at all, hope for the best, until a trap actually occurs.)\n-\n-    \/\/ Make a constant out of the inexact array klass\n-    const TypeKlassPtr *extak = tak->cast_to_exactness(true);\n-\n-    if (extak->exact_klass(true) != NULL) {\n+      extak = tak->cast_to_exactness(true);\n+      reason = Deoptimization::Reason_array_check;\n+    }\n+    if (extak != NULL && extak->exact_klass(true) != NULL) {\n@@ -202,13 +222,22 @@\n-      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n-      Node* ctrl= control();\n-      { BuildCutout unless(this, bol, PROB_MAX);\n-        uncommon_trap(Deoptimization::Reason_array_check,\n-                      Deoptimization::Action_maybe_recompile,\n-                      extak->exact_klass());\n-      }\n-      if (stopped()) {          \/\/ MUST uncommon-trap?\n-        set_control(ctrl);      \/\/ Then Don't Do It, just fall into the normal checking\n-      } else {                  \/\/ Cast array klass to exactness:\n-        \/\/ Use the exact constant value we know it is.\n-        replace_in_map(array_klass,con);\n+      Node* cmp = _gvn.transform(new CmpPNode(array_klass, con));\n+      Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+      \/\/ Only do it if the check does not always pass\/fail\n+      if (!bol->is_Con()) {\n+        always_see_exact_class = true;\n+        { BuildCutout unless(this, bol, PROB_MAX);\n+          uncommon_trap(reason,\n+                        Deoptimization::Action_maybe_recompile,\n+                        extak->exact_klass());\n+        }\n+        \/\/ Cast array klass to exactness\n+        replace_in_map(array_klass, con);\n+        array_klass = con;\n+        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, extak->as_instance_type()));\n+        replace_in_map(ary, cast);\n+        ary = cast;\n+\n+        \/\/ Recompute element type and address\n+        const TypeAryPtr* arytype = _gvn.type(ary)->is_aryptr();\n+        elemtype = arytype->elem();\n+        adr = array_element_address(ary, idx, T_OBJECT, arytype->size(), control());\n+\n@@ -220,1 +249,0 @@\n-        array_klass = con;      \/\/ Use cast value moving forward\n@@ -228,1 +256,2 @@\n-  int element_klass_offset = in_bytes(ObjArrayKlass::element_klass_offset());\n+  int element_klass_offset = in_bytes(ArrayKlass::element_klass_offset());\n+\n@@ -236,0 +265,11 @@\n+  \/\/ If we statically know that this is an inline type array, use precise element klass for checkcast\n+  if (!elemtype->isa_inlinetype()) {\n+    elemtype = elemtype->make_oopptr();\n+  }\n+  bool null_free = false;\n+  if (elemtype->isa_inlinetype() != NULL || elemtype->is_inlinetypeptr()) {\n+    \/\/ We statically know that this is an inline type array, use precise klass ptr\n+    null_free = elemtype->isa_inlinetype() || !elemtype->maybe_null();\n+    a_e_klass = makecon(TypeKlassPtr::make(elemtype->inline_klass()));\n+  }\n+\n@@ -237,2 +277,1 @@\n-  \/\/ Result is ignored, we just need the CFG effects.\n-  gen_checkcast(obj, a_e_klass);\n+  return gen_checkcast(obj, a_e_klass, NULL, null_free);\n@@ -249,0 +288,1 @@\n+  assert(!klass->is_inlinetype(), \"unexpected inline type\");\n@@ -285,0 +325,59 @@\n+\/\/------------------------------do_aconst_init---------------------------------\n+void Parse::do_aconst_init() {\n+  bool will_link;\n+  ciInlineKlass* vk = iter().get_klass(will_link)->as_inline_klass();\n+  assert(will_link && !iter().is_unresolved_klass(), \"aconst_init: typeflow responsibility\");\n+\n+  if (C->needs_clinit_barrier(vk, method())) {\n+    clinit_barrier(vk, method());\n+    if (stopped())  return;\n+  }\n+\n+  InlineTypeNode* vt = InlineTypeNode::make_default(_gvn, vk);\n+  push(vt);\n+}\n+\n+\/\/------------------------------do_withfield------------------------------------\n+void Parse::do_withfield() {\n+  bool will_link;\n+  ciField* field = iter().get_field(will_link);\n+  assert(will_link, \"withfield: typeflow responsibility\");\n+  int holder_depth = field->type()->size();\n+  null_check(peek(holder_depth));\n+  if (stopped()) {\n+    return;\n+  }\n+  Node* val = pop_node(field->layout_type());\n+  Node* holder = pop();\n+\n+  if (!val->is_InlineTypeBase() && field->type()->is_inlinetype()) {\n+    \/\/ Scalarize inline type field value\n+    assert(!field->is_null_free() || !gvn().type(val)->maybe_null(), \"Null store to null-free field\");\n+    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n+  } else if (val->is_InlineType() && !field->is_null_free()) {\n+    \/\/ Field value needs to be allocated because it can be merged with an oop.\n+    \/\/ Re-execute withfield if buffering triggers deoptimization.\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    int nargs = 1 + field->type()->size();\n+    inc_sp(nargs);\n+    val = val->as_InlineType()->buffer(this);\n+  }\n+  if (val->is_InlineTypePtr() && field->is_null_free()) {\n+    \/\/ TODO 8284443 Remove this\n+    Node* newVal = InlineTypeNode::make_uninitialized(gvn(), field->type()->as_inline_klass());\n+    for (uint i = 1; i < val->req(); ++i) {\n+      newVal->set_req(i, val->in(i));\n+    }\n+    val = gvn().transform(newVal);\n+  }\n+\n+  \/\/ Clone the inline type node and set the new field value\n+  InlineTypeNode* new_vt = InlineTypeNode::make_uninitialized(gvn(), gvn().type(holder)->inline_klass());\n+  for (uint i = 2; i < holder->req(); ++i) {\n+    new_vt->set_req(i, holder->in(i));\n+  }\n+  new_vt->set_field_value_by_offset(field->offset(), val);\n+  push(_gvn.transform(new_vt));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":140,"deletions":41,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  C->remove_useless_nodes(_useful);\n+  C->disconnect_useless_nodes(_useful, worklist);\n@@ -1228,6 +1228,0 @@\n-  if (_delay_transform) {\n-    \/\/ Register the node but don't optimize for now\n-    register_new_node_with_optimizer(n);\n-    return n;\n-  }\n-\n@@ -1240,0 +1234,6 @@\n+  if (_delay_transform) {\n+    \/\/ Add the node to the worklist but don't optimize for now\n+    _worklist.push(n);\n+    return n;\n+  }\n+\n@@ -1502,0 +1502,13 @@\n+void PhaseIterGVN::replace_in_uses(Node* n, Node* m) {\n+  assert(n != NULL, \"sanity\");\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    if (u != n) {\n+      rehash_node_delayed(u);\n+      int nb = u->replace_edge(n, m);\n+      --i, imax -= nb;\n+    }\n+  }\n+  assert(n->outcnt() == 0, \"all uses must be deleted\");\n+}\n+\n@@ -1602,0 +1615,9 @@\n+    \/\/ Inline type nodes can have other inline types as users. If an input gets\n+    \/\/ updated, make sure that inline type users get a chance for optimization.\n+    if (use->is_InlineTypeBase()) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->is_InlineTypeBase())\n+          _worklist.push(u);\n+      }\n+    }\n@@ -1647,0 +1669,8 @@\n+    if (use_op == Op_CastP2X) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->Opcode() == Op_AndX) {\n+          _worklist.push(u);\n+        }\n+      }\n+    }\n@@ -1671,0 +1701,11 @@\n+\n+    \/\/ Give CallStaticJavaNode::remove_useless_allocation a chance to run\n+    if (use->is_Region()) {\n+      Node* c = use;\n+      do {\n+        c = c->unique_ctrl_out_or_null();\n+      } while (c != NULL && c->is_Region());\n+      if (c != NULL && c->is_CallStaticJava() && c->as_CallStaticJava()->uncommon_trap_request() != 0) {\n+        _worklist.push(c);\n+      }\n+    }\n@@ -1722,1 +1763,1 @@\n-PhaseCCP::PhaseCCP( PhaseIterGVN *igvn ) : PhaseIterGVN(igvn) {\n+PhaseCCP::PhaseCCP(PhaseIterGVN* igvn) : PhaseIterGVN(igvn), _trstack(C->live_nodes() >> 1) {\n@@ -1776,0 +1817,5 @@\n+    if (n->is_SafePoint()) {\n+      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n+      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n+      _trstack.push(n);\n+    }\n@@ -1841,0 +1887,8 @@\n+        if (m_op == Op_CastP2X) {\n+          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n+            Node* u = m->fast_out(i2);\n+            if (u->Opcode() == Op_AndX) {\n+              worklist.push(u);\n+            }\n+          }\n+        }\n@@ -1905,0 +1959,1 @@\n+  _useful.push(new_node); \/\/ Keep track of nodes that are reachable from the bottom\n@@ -1906,6 +1961,3 @@\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n-  GrowableArray <Node *> trstack(C->live_nodes() >> 1);\n-\n-  trstack.push(new_node);           \/\/ Process children of cloned node\n-  while ( trstack.is_nonempty() ) {\n-    Node *clone = trstack.pop();\n+  _trstack.push(new_node);           \/\/ Process children of cloned node\n+  while (_trstack.is_nonempty()) {\n+    Node* clone = _trstack.pop();\n@@ -1920,1 +1972,2 @@\n-          trstack.push(new_input);\n+          _useful.push(new_input);\n+          _trstack.push(new_input);\n@@ -1926,0 +1979,17 @@\n+\n+  \/\/ The above transformation might lead to subgraphs becoming unreachable from the\n+  \/\/ bottom while still being reachable from the top. As a result, nodes in that\n+  \/\/ subgraph are not transformed and their bottom types are not updated, leading to\n+  \/\/ an inconsistency between bottom_type() and type(). In rare cases, LoadNodes in\n+  \/\/ such a subgraph, kept alive by InlineTypePtrNodes, might be re-enqueued for IGVN\n+  \/\/ indefinitely by MemNode::Ideal_common because their address type is inconsistent.\n+  \/\/ Therefore, we aggressively remove all useless nodes here even before\n+  \/\/ PhaseIdealLoop::build_loop_late gets a chance to remove them anyway.\n+  if (C->cached_top_node()) {\n+    _useful.push(C->cached_top_node());\n+  }\n+  C->update_dead_node_list(_useful);\n+  remove_useless_nodes(_useful.member_set());\n+  _worklist.remove_useless_nodes(_useful.member_set());\n+  C->disconnect_useless_nodes(_useful, &_worklist);\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":85,"deletions":15,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  virtual void record_for_igvn(Node *n) { }\n+  virtual void record_for_igvn(Node *n) { _worklist.push(n); }\n@@ -520,0 +520,2 @@\n+  void replace_in_uses(Node* n, Node* m);\n+\n@@ -568,0 +570,3 @@\n+  GrowableArray<Node*> _trstack; \/\/ Stack for transform operation\n+  Unique_Node_List _useful;      \/\/ Nodes reachable from the bottom\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+  flags(SPLIT_INLINES_ARRAY,          \"Split inlines array\") \\\n+  flags(SPLIT_INLINES_ARRAY_IGVN,     \"IGVN after split inlines array\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+      DEBUG_ONLY(uint loop_count = 0);\n@@ -177,0 +178,1 @@\n+        assert(loop_count++ < K, \"infinite loop in ReplacedNodes::apply\");\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -111,0 +113,1 @@\n+address OptoRuntime::_load_unknown_inline                         = NULL;\n@@ -154,1 +157,0 @@\n-\n@@ -157,0 +159,1 @@\n+  gen(env, _load_unknown_inline            , load_unknown_inline_type     , load_unknown_inline             ,    0 , true,  false);\n@@ -202,1 +205,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* current))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, bool is_larval, JavaThread* current))\n@@ -222,1 +225,5 @@\n-    oop result = InstanceKlass::cast(klass)->allocate_instance(THREAD);\n+    instanceOop result = InstanceKlass::cast(klass)->allocate_instance(THREAD);\n+    if (is_larval) {\n+      \/\/ Check if this is a larval buffer allocation\n+      result->set_mark(result->mark().enter_larval_state());\n+    }\n@@ -250,1 +257,4 @@\n-  if (array_type->is_typeArray_klass()) {\n+  if (array_type->is_flatArray_klass()) {\n+    Klass* elem_type = FlatArrayKlass::cast(array_type)->element_klass();\n+    result = oopFactory::new_valueArray(elem_type, len, THREAD);\n+  } else if (array_type->is_typeArray_klass()) {\n@@ -256,5 +266,1 @@\n-    \/\/ Although the oopFactory likes to work with the elem_type,\n-    \/\/ the compiler prefers the array_type, since it must already have\n-    \/\/ that latter value in hand for the fast path.\n-    Klass* elem_type = ObjArrayKlass::cast(array_type)->element_klass();\n-    result = oopFactory::new_objArray(elem_type, len, THREAD);\n+    result = ObjArrayKlass::cast(array_type)->allocate(len, THREAD);\n@@ -455,1 +461,1 @@\n-  const Type **fields = TypeTuple::fields(1);\n+  const Type **fields = TypeTuple::fields(2);\n@@ -457,1 +463,2 @@\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms+1] = TypeInt::BOOL;        \/\/ is_larval\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n@@ -575,1 +582,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1618,1 +1625,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1651,1 +1658,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1667,1 +1674,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1791,0 +1798,104 @@\n+\n+const TypeFunc *OptoRuntime::store_inline_type_fields_Type() {\n+  \/\/ create input type (domain)\n+  uint total = SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;\n+  const Type **fields = TypeTuple::fields(total);\n+  \/\/ We don't know the number of returned values and their\n+  \/\/ types. Assume all registers available to the return convention\n+  \/\/ are used.\n+  fields[TypeFunc::Parms] = TypePtr::BOTTOM;\n+  uint i = 1;\n+  for (; i < SharedRuntime::java_return_convention_max_int; i++) {\n+    fields[TypeFunc::Parms+i] = TypeInt::INT;\n+  }\n+  for (; i < total; i+=2) {\n+    fields[TypeFunc::Parms+i] = Type::DOUBLE;\n+    fields[TypeFunc::Parms+i+1] = Type::HALF;\n+  }\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+const TypeFunc *OptoRuntime::pack_inline_type_Type() {\n+  \/\/ create input type (domain)\n+  uint total = 1 + SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;\n+  const Type **fields = TypeTuple::fields(total);\n+  \/\/ We don't know the number of returned values and their\n+  \/\/ types. Assume all registers available to the return convention\n+  \/\/ are used.\n+  fields[TypeFunc::Parms] = TypeRawPtr::BOTTOM;\n+  fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;\n+  uint i = 2;\n+  for (; i < SharedRuntime::java_return_convention_max_int+1; i++) {\n+    fields[TypeFunc::Parms+i] = TypeInt::INT;\n+  }\n+  for (; i < total; i+=2) {\n+    fields[TypeFunc::Parms+i] = Type::DOUBLE;\n+    fields[TypeFunc::Parms+i+1] = Type::HALF;\n+  }\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+JRT_BLOCK_ENTRY(void, OptoRuntime::load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current))\n+  JRT_BLOCK;\n+  flatArrayHandle vah(current, array);\n+  oop buffer = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, THREAD);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(buffer);\n+  JRT_BLOCK_END;\n+JRT_END\n+\n+const TypeFunc* OptoRuntime::load_unknown_inline_type() {\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms] = TypeOopPtr::NOTNULL;\n+  fields[TypeFunc::Parms+1] = TypeInt::POS;\n+\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+JRT_LEAF(void, OptoRuntime::store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index))\n+{\n+  assert(buffer != NULL, \"can't store null into flat array\");\n+  array->value_copy_to_index(buffer, index);\n+}\n+JRT_END\n+\n+const TypeFunc* OptoRuntime::store_unknown_inline_type() {\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(3);\n+  fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;\n+  fields[TypeFunc::Parms+1] = TypeOopPtr::NOTNULL;\n+  fields[TypeFunc::Parms+2] = TypeInt::POS;\n+\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":126,"deletions":15,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  static address _load_unknown_inline;\n@@ -144,1 +145,1 @@\n-  static void new_instance_C(Klass* instance_klass, JavaThread* current);\n+  static void new_instance_C(Klass* instance_klass, bool is_larval, JavaThread* current);\n@@ -211,0 +212,1 @@\n+  static address load_unknown_inline_Java()              { return _load_unknown_inline; }\n@@ -302,0 +304,8 @@\n+  static const TypeFunc* store_inline_type_fields_Type();\n+  static const TypeFunc* pack_inline_type_Type();\n+\n+  static void load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current);\n+  static const TypeFunc* load_unknown_inline_type();\n+  static void store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index);\n+  static const TypeFunc* store_unknown_inline_type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -316,4 +316,3 @@\n-  CallProjections projs;\n-  call->extract_projections(&projs, false);\n-  if (projs.fallthrough_catchproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_catchproj, call->in(TypeFunc::Control));\n+  CallProjections* projs = call->extract_projections(false);\n+  if (projs->fallthrough_catchproj != NULL) {\n+    C->gvn_replace_by(projs->fallthrough_catchproj, call->in(TypeFunc::Control));\n@@ -321,2 +320,2 @@\n-  if (projs.fallthrough_memproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_memproj, call->in(TypeFunc::Memory));\n+  if (projs->fallthrough_memproj != NULL) {\n+    C->gvn_replace_by(projs->fallthrough_memproj, call->in(TypeFunc::Memory));\n@@ -324,2 +323,2 @@\n-  if (projs.catchall_memproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+  if (projs->catchall_memproj != NULL) {\n+    C->gvn_replace_by(projs->catchall_memproj, C->top());\n@@ -327,2 +326,2 @@\n-  if (projs.fallthrough_ioproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_ioproj, call->in(TypeFunc::I_O));\n+  if (projs->fallthrough_ioproj != NULL) {\n+    C->gvn_replace_by(projs->fallthrough_ioproj, call->in(TypeFunc::I_O));\n@@ -330,2 +329,2 @@\n-  if (projs.catchall_ioproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_ioproj, C->top());\n+  if (projs->catchall_ioproj != NULL) {\n+    C->gvn_replace_by(projs->catchall_ioproj, C->top());\n@@ -333,1 +332,1 @@\n-  if (projs.catchall_catchproj != NULL) {\n+  if (projs->catchall_catchproj != NULL) {\n@@ -336,1 +335,1 @@\n-    for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {\n+    for (SimpleDUIterator i(projs->catchall_catchproj); i.has_next(); i.next()) {\n@@ -343,1 +342,1 @@\n-    C->gvn_replace_by(projs.catchall_catchproj, C->top());\n+    C->gvn_replace_by(projs->catchall_catchproj, C->top());\n@@ -345,2 +344,3 @@\n-  if (projs.resproj != NULL) {\n-    C->gvn_replace_by(projs.resproj, C->top());\n+  if (projs->resproj[0] != NULL) {\n+    assert(projs->nb_resproj == 1, \"unexpected number of results\");\n+    C->gvn_replace_by(projs->resproj[0], C->top());\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -870,1 +871,8 @@\n-Node *CmpLNode::Ideal( PhaseGVN *phase, bool can_reshape ) {\n+\/\/------------------------------Ideal------------------------------------------\n+Node* CmpLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* a = NULL;\n+  Node* b = NULL;\n+  if (is_double_null_check(phase, a, b) && (phase->type(a)->is_zero_type() || phase->type(b)->is_zero_type())) {\n+    \/\/ Degraded to a simple null check, use old acmp\n+    return new CmpPNode(a, b);\n+  }\n@@ -881,0 +889,25 @@\n+\/\/ Match double null check emitted by Compile::optimize_acmp()\n+bool CmpLNode::is_double_null_check(PhaseGVN* phase, Node*& a, Node*& b) const {\n+  if (in(1)->Opcode() == Op_OrL &&\n+      in(1)->in(1)->Opcode() == Op_CastP2X &&\n+      in(1)->in(2)->Opcode() == Op_CastP2X &&\n+      in(2)->bottom_type()->is_zero_type()) {\n+    assert(EnableValhalla, \"unexpected double null check\");\n+    a = in(1)->in(1)->in(1);\n+    b = in(1)->in(2)->in(1);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/------------------------------Value------------------------------------------\n+const Type* CmpLNode::Value(PhaseGVN* phase) const {\n+  Node* a = NULL;\n+  Node* b = NULL;\n+  if (is_double_null_check(phase, a, b) && (!phase->type(a)->maybe_null() || !phase->type(b)->maybe_null())) {\n+    \/\/ One operand is never NULL, emit constant false\n+    return TypeInt::CC_GT;\n+  }\n+  return SubNode::Value(phase);\n+}\n+\n@@ -1006,1 +1039,16 @@\n-\n+    if (!unrelated_classes) {\n+      \/\/ Handle inline type arrays\n+      if ((r0->flatten_array() && r1->not_flatten_array()) ||\n+          (r1->flatten_array() && r0->not_flatten_array())) {\n+        \/\/ One type is flattened in arrays but the other type is not. Must be unrelated.\n+        unrelated_classes = true;\n+      } else if ((r0->is_not_flat() && r1->is_flat()) ||\n+                 (r1->is_not_flat() && r0->is_flat())) {\n+        \/\/ One type is a non-flattened array and the other type is a flattened array. Must be unrelated.\n+        unrelated_classes = true;\n+      } else if ((r0->is_not_null_free() && r1->is_null_free()) ||\n+                 (r1->is_not_null_free() && r0->is_null_free())) {\n+        \/\/ One type is a nullable array and the other type is a null-free array. Must be unrelated.\n+        unrelated_classes = true;\n+      }\n+    }\n@@ -1091,1 +1139,8 @@\n-Node *CmpPNode::Ideal( PhaseGVN *phase, bool can_reshape ) {\n+Node* CmpPNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ TODO 8284443 in(1) could be cast?\n+  if (in(1)->is_InlineTypePtr() && phase->type(in(2))->is_zero_type()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    return new CmpINode(in(1)->as_InlineTypePtr()->get_is_init(), phase->intcon(0));\n+  }\n+\n@@ -1163,0 +1218,8 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Do not bypass the klass load from the primary supertype array.\n+  if (superklass->is_obj_array_klass() && !superklass->as_array_klass()->is_elem_null_free() &&\n+      superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return NULL;\n+  }\n+\n@@ -1306,0 +1369,37 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* FlatArrayCheckNode::Value(PhaseGVN* phase) const {\n+  bool all_not_flat = true;\n+  for (uint i = ArrayOrKlass; i < req(); ++i) {\n+    const Type* t = phase->type(in(i));\n+    if (t == Type::TOP) {\n+      return Type::TOP;\n+    }\n+    if (t->is_ptr()->is_flat()) {\n+      \/\/ One of the input arrays is flat, check always passes\n+      return TypeInt::CC_EQ;\n+    } else if (!t->is_ptr()->is_not_flat()) {\n+      \/\/ One of the input arrays might be flat\n+      all_not_flat = false;\n+    }\n+  }\n+  if (all_not_flat) {\n+    \/\/ None of the input arrays can be flat, check always fails\n+    return TypeInt::CC_GT;\n+  }\n+  return TypeInt::CC;\n+}\n+\n+\/\/------------------------------Ideal------------------------------------------\n+Node* FlatArrayCheckNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool changed = false;\n+  \/\/ Remove inputs that are known to be non-flat\n+  for (uint i = ArrayOrKlass; i < req(); ++i) {\n+    const Type* t = phase->type(in(i));\n+    if (t->isa_ptr() && t->is_ptr()->is_not_flat()) {\n+      del_req(i--);\n+      changed = true;\n+    }\n+  }\n+  return changed ? this : NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":103,"deletions":3,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -214,1 +214,2 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -216,0 +217,1 @@\n+  bool is_double_null_check(PhaseGVN* phase, Node*& a, Node*& b) const;\n@@ -306,0 +308,20 @@\n+\/\/--------------------------FlatArrayCheckNode---------------------------------\n+\/\/ Returns true if one of the input array objects or array klass ptrs (there\n+\/\/ can be multiple) is flat.\n+class FlatArrayCheckNode : public CmpNode {\n+public:\n+  enum {\n+    Control,\n+    Memory,\n+    ArrayOrKlass\n+  };\n+  FlatArrayCheckNode(Compile* C, Node* mem, Node* array_or_klass) : CmpNode(mem, array_or_klass) {\n+    init_class_id(Class_FlatArrayCheck);\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n+  virtual int Opcode() const;\n+  virtual const Type* sub(const Type*, const Type*) const { ShouldNotReachHere(); return NULL; }\n+  const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,0 +49,20 @@\n+  \/\/ Similar to logic in CmpPNode::sub()\n+  bool unrelated_classes = false;\n+  \/\/ Handle inline type arrays\n+  if (subk->flatten_array() && superk->not_flatten_array()) {\n+    \/\/ The subtype is flattened in arrays and the supertype is not flattened in arrays. Must be unrelated.\n+    unrelated_classes = true;\n+  } else if (subk->is_not_flat() && superk->is_flat()) {\n+    \/\/ The subtype is a non-flattened array and the supertype is a flattened array. Must be unrelated.\n+    unrelated_classes = true;\n+  } else if (subk->is_not_null_free() && superk->is_null_free()) {\n+    \/\/ The subtype is a nullable array and the supertype is null-free array. Must be unrelated.\n+    unrelated_classes = true;\n+  }\n+  if (unrelated_classes) {\n+    TypePtr::PTR jp = sub_t->is_ptr()->join_ptr(super_t->is_ptr()->_ptr);\n+    if (jp != TypePtr::Null && jp != TypePtr::BotPTR) {\n+      return TypeInt::CC_GT;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciField.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -51,0 +54,46 @@\n+const Type::Offset Type::Offset::top(Type::OffsetTop);\n+const Type::Offset Type::Offset::bottom(Type::OffsetBot);\n+\n+const Type::Offset Type::Offset::meet(const Type::Offset other) const {\n+  \/\/ Either is 'TOP' offset?  Return the other offset!\n+  int offset = other._offset;\n+  if (_offset == OffsetTop) return Offset(offset);\n+  if (offset == OffsetTop) return Offset(_offset);\n+  \/\/ If either is different, return 'BOTTOM' offset\n+  if (_offset != offset) return bottom;\n+  return Offset(_offset);\n+}\n+\n+const Type::Offset Type::Offset::dual() const {\n+  if (_offset == OffsetTop) return bottom;\/\/ Map 'TOP' into 'BOTTOM'\n+  if (_offset == OffsetBot) return top;\/\/ Map 'BOTTOM' into 'TOP'\n+  return Offset(_offset);               \/\/ Map everything else into self\n+}\n+\n+const Type::Offset Type::Offset::add(intptr_t offset) const {\n+  \/\/ Adding to 'TOP' offset?  Return 'TOP'!\n+  if (_offset == OffsetTop || offset == OffsetTop) return top;\n+  \/\/ Adding to 'BOTTOM' offset?  Return 'BOTTOM'!\n+  if (_offset == OffsetBot || offset == OffsetBot) return bottom;\n+  \/\/ Addition overflows or \"accidentally\" equals to OffsetTop? Return 'BOTTOM'!\n+  offset += (intptr_t)_offset;\n+  if (offset != (int)offset || offset == OffsetTop) return bottom;\n+\n+  \/\/ assert( _offset >= 0 && _offset+offset >= 0, \"\" );\n+  \/\/ It is possible to construct a negative offset during PhaseCCP\n+\n+  return Offset((int)offset);        \/\/ Sum valid offsets\n+}\n+\n+void Type::Offset::dump2(outputStream *st) const {\n+  if (_offset == 0) {\n+    return;\n+  } else if (_offset == OffsetTop) {\n+    st->print(\"+top\");\n+  }\n+  else if (_offset == OffsetBot) {\n+    st->print(\"+bot\");\n+  } else if (_offset) {\n+    st->print(\"+%d\", _offset);\n+  }\n+}\n@@ -90,0 +139,1 @@\n+  { Bad,             T_PRIMITIVE_OBJECT, \"inline:\",      false, Node::NotAMachineReg, relocInfo::none          },  \/\/ InlineType\n@@ -222,0 +272,10 @@\n+  case T_PRIMITIVE_OBJECT: {\n+    bool is_null_free = type->is_null_free();\n+    ciInlineKlass* vk = type->unwrap()->as_inline_klass();\n+    if (is_null_free) {\n+      return TypeInlineType::make(vk);\n+    } else {\n+      return TypeOopPtr::make_from_klass(vk)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+    }\n+  }\n+\n@@ -250,0 +310,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -287,0 +348,1 @@\n+    case T_PRIMITIVE_OBJECT: conbt = T_OBJECT; break;\n@@ -293,0 +355,1 @@\n+    case T_PRIMITIVE_OBJECT: loadbt = T_OBJECT; break;\n@@ -528,3 +591,3 @@\n-  TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);\n-  TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);\n-  TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);\n+  TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));\n+  TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);\n+  TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);\n@@ -547,1 +610,1 @@\n-                                           false, 0, oopDesc::mark_offset_in_bytes());\n+                                           false, 0, Offset(oopDesc::mark_offset_in_bytes()));\n@@ -549,2 +612,4 @@\n-                                           false, 0, oopDesc::klass_offset_in_bytes());\n-  TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);\n+                                           false, 0, Offset(oopDesc::klass_offset_in_bytes()));\n+  TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);\n+\n+  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);\n@@ -552,1 +617,1 @@\n-  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);\n+  TypeInlineType::BOTTOM = TypeInlineType::make(NULL);\n@@ -569,1 +634,1 @@\n-  TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL \/* current->env()->Object_klass() *\/, false, arrayOopDesc::length_offset_in_bytes());\n+  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n@@ -571,1 +636,1 @@\n-  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n+  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -581,1 +646,1 @@\n-    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n+    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -583,7 +648,8 @@\n-  TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);\n-  TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);\n-  TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);\n-  TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);\n-  TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);\n-  TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);\n-  TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);\n+  TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);\n+  TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);\n+  TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);\n+  TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);\n+  TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);\n+  TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);\n+  TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);\n+  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);\n@@ -594,0 +660,1 @@\n+  TypeAryPtr::_array_body_type[T_PRIMITIVE_OBJECT] = TypeAryPtr::OOPS;\n@@ -604,2 +671,2 @@\n-  TypeInstKlassPtr::OBJECT = TypeInstKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), 0);\n-  TypeInstKlassPtr::OBJECT_OR_NULL = TypeInstKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), 0);\n+  TypeInstKlassPtr::OBJECT = TypeInstKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), Offset(0), false);\n+  TypeInstKlassPtr::OBJECT_OR_NULL = TypeInstKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), Offset(0), false);\n@@ -644,0 +711,1 @@\n+  _const_basic_type[T_PRIMITIVE_OBJECT] = TypeInstPtr::BOTTOM;\n@@ -660,0 +728,1 @@\n+  _zero_type[T_PRIMITIVE_OBJECT] = TypePtr::NULL_PTR;\n@@ -951,0 +1020,3 @@\n+  case InlineType:\n+    return t->xmeet(this);\n+\n@@ -1120,0 +1192,1 @@\n+    case Type::InlineType:\n@@ -1519,0 +1592,1 @@\n+  case InlineType:\n@@ -2006,0 +2080,12 @@\n+static void collect_inline_fields(ciInlineKlass* vk, const Type** field_array, uint& pos) {\n+  for (int j = 0; j < vk->nof_nonstatic_fields(); j++) {\n+    ciField* field = vk->nonstatic_field_at(j);\n+    BasicType bt = field->type()->basic_type();\n+    const Type* ft = Type::get_const_type(field->type());\n+    field_array[pos++] = ft;\n+    if (type2size[bt] == 2) {\n+      field_array[pos++] = Type::HALF;\n+    }\n+  }\n+}\n+\n@@ -2008,1 +2094,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {\n@@ -2011,0 +2097,8 @@\n+  if (ret_vt_fields) {\n+    arg_cnt = return_type->as_inline_klass()->inline_arg_slots() + 1;\n+    if (!sig->returns_null_free_inline_type()) {\n+      \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+      arg_cnt++;\n+    }\n+  }\n+\n@@ -2031,0 +2125,13 @@\n+  case T_PRIMITIVE_OBJECT:\n+    if (ret_vt_fields) {\n+      uint pos = TypeFunc::Parms;\n+      field_array[pos++] = get_const_type(return_type); \/\/ Oop might be null when returning as fields\n+      collect_inline_fields(return_type->as_inline_klass(), field_array, pos);\n+      if (!sig->returns_null_free_inline_type()) {\n+        \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+        field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n+      }\n+    } else {\n+      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+    }\n+    break;\n@@ -2040,2 +2147,10 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n-  uint arg_cnt = sig->size();\n+const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {\n+  ciSignature* sig = method->signature();\n+  uint arg_cnt = sig->size() + (method->is_static() ? 0 : 1);\n+  if (vt_fields_as_args) {\n+    arg_cnt = 0;\n+    assert(method->get_sig_cc() != NULL, \"Should have scalarized signature\");\n+    for (ExtendedSignature sig_cc = ExtendedSignature(method->get_sig_cc(), SigEntryFilter()); !sig_cc.at_end(); ++sig_cc) {\n+      arg_cnt += type2size[(*sig_cc)._bt];\n+    }\n+  }\n@@ -2044,8 +2159,8 @@\n-  const Type **field_array;\n-  if (recv != NULL) {\n-    arg_cnt++;\n-    field_array = fields(arg_cnt);\n-    \/\/ Use get_const_type here because it respects UseUniqueSubclasses:\n-    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n-  } else {\n-    field_array = fields(arg_cnt);\n+  const Type** field_array = fields(arg_cnt);\n+  if (!method->is_static()) {\n+    ciInstanceKlass* recv = method->holder();\n+    if (vt_fields_as_args && recv->is_inlinetype() && recv->as_inline_klass()->can_be_passed_as_fields()) {\n+      collect_inline_fields(recv->as_inline_klass(), field_array, pos);\n+    } else {\n+      field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n+    }\n@@ -2057,0 +2172,1 @@\n+    BasicType bt = type->basic_type();\n@@ -2058,1 +2174,1 @@\n-    switch (type->basic_type()) {\n+    switch (bt) {\n@@ -2079,0 +2195,12 @@\n+    case T_PRIMITIVE_OBJECT: {\n+      if (vt_fields_as_args && method->is_scalarized_arg(i + (method->is_static() ? 0 : 1))) {\n+        if (!sig->is_null_free_at(i)) {\n+          \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+          field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n+        }\n+        collect_inline_fields(type->as_inline_klass(), field_array, pos);\n+      } else {\n+        field_array[pos++] = get_const_type(type)->join_speculative(sig->is_null_free_at(i) ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+      }\n+      break;\n+    }\n@@ -2084,0 +2212,1 @@\n+  assert(pos == TypeFunc::Parms + arg_cnt, \"wrong number of arguments\");\n@@ -2218,1 +2347,2 @@\n-const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {\n+const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,\n+                             bool not_flat, bool not_null_free) {\n@@ -2223,1 +2353,1 @@\n-  return (TypeAry*)(new TypeAry(elem,size,stable))->hashcons();\n+  return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))->hashcons();\n@@ -2245,1 +2375,3 @@\n-                         _stable && a->_stable);\n+                         _stable && a->_stable,\n+                         _not_flat && a->_not_flat,\n+                         _not_null_free && a->_not_null_free);\n@@ -2258,1 +2390,1 @@\n-  return new TypeAry(_elem->dual(), size_dual, !_stable);\n+  return new TypeAry(_elem->dual(), size_dual, !_stable, !_not_flat, !_not_null_free);\n@@ -2267,1 +2399,4 @@\n-    _size == a->_size;\n+    _size == a->_size &&\n+    _not_flat == a->_not_flat &&\n+    _not_null_free == a->_not_null_free;\n+\n@@ -2280,1 +2415,1 @@\n-  return make(_elem->remove_speculative(), _size, _stable);\n+  return make(_elem->remove_speculative(), _size, _stable, _not_flat, _not_null_free);\n@@ -2287,1 +2422,1 @@\n-  return make(_elem->cleanup_speculative(), _size, _stable);\n+  return make(_elem->cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);\n@@ -2321,0 +2456,4 @@\n+  if (Verbose) {\n+    if (_not_flat) st->print(\"not flat:\");\n+    if (_not_null_free) st->print(\"not null free:\");\n+  }\n@@ -2362,2 +2501,10 @@\n-  if (tinst)\n-    return tklass->as_instance_klass()->is_final();\n+  if (tinst) {\n+    if (tklass->as_instance_klass()->is_final()) {\n+      \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+      if (tinst->is_inlinetypeptr() && (tinst->ptr() == TypePtr::BotPTR || tinst->ptr() == TypePtr::TopPTR)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -2374,0 +2521,127 @@\n+\/\/==============================TypeInlineType=======================================\n+\n+const TypeInlineType* TypeInlineType::BOTTOM;\n+\n+\/\/------------------------------make-------------------------------------------\n+const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {\n+  return (TypeInlineType*)(new TypeInlineType(vk, larval))->hashcons();\n+}\n+\n+\/\/------------------------------meet-------------------------------------------\n+\/\/ Compute the MEET of two types.  It returns a new Type object.\n+const Type* TypeInlineType::xmeet(const Type* t) const {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if(this == t) return this;  \/\/ Meeting same type-rep?\n+\n+  \/\/ Current \"this->_base\" is InlineType\n+  switch (t->base()) {          \/\/ switch on original type\n+\n+  case Int:\n+  case Long:\n+  case FloatTop:\n+  case FloatCon:\n+  case FloatBot:\n+  case DoubleTop:\n+  case DoubleCon:\n+  case DoubleBot:\n+  case NarrowKlass:\n+  case Bottom:\n+    return Type::BOTTOM;\n+\n+  case OopPtr:\n+  case MetadataPtr:\n+  case KlassPtr:\n+  case RawPtr:\n+  case AnyPtr:\n+    return TypePtr::BOTTOM;\n+\n+  case Top:\n+    return this;\n+\n+  case NarrowOop: {\n+    const Type* res = t->make_ptr()->xmeet(this);\n+    if (res->isa_ptr()) {\n+      return res->make_narrowoop();\n+    }\n+    return res;\n+  }\n+\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n+  case AryPtr:\n+  case InstPtr: {\n+    return t->xmeet(this);\n+  }\n+\n+  case InlineType: {\n+    \/\/ All inline types inherit from Object\n+    const TypeInlineType* other = t->is_inlinetype();\n+    if (_vk == NULL) {\n+      return this;\n+    } else if (other->_vk == NULL) {\n+      return other;\n+    } else if (_vk == other->_vk) {\n+      if (_larval == other->_larval ||\n+          !_larval) {\n+        return this;\n+      } else {\n+        return t;\n+      }\n+    }\n+    return TypeInstPtr::NOTNULL;\n+  }\n+\n+  default:                      \/\/ All else is a mistake\n+    typerr(t);\n+\n+  }\n+  return this;\n+}\n+\n+\/\/------------------------------xdual------------------------------------------\n+const Type* TypeInlineType::xdual() const {\n+  return this;\n+}\n+\n+\/\/------------------------------eq---------------------------------------------\n+\/\/ Structural equality check for Type representations\n+bool TypeInlineType::eq(const Type* t) const {\n+  const TypeInlineType* vt = t->is_inlinetype();\n+  return (_vk == vt->inline_klass() && _larval == vt->larval());\n+}\n+\n+\/\/------------------------------hash-------------------------------------------\n+\/\/ Type-specific hashing function.\n+int TypeInlineType::hash(void) const {\n+  return (intptr_t)_vk;\n+}\n+\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.\n+bool TypeInlineType::singleton(void) const {\n+  return false;\n+}\n+\n+\/\/------------------------------empty------------------------------------------\n+\/\/ TRUE if Type is a type with no values, FALSE otherwise.\n+bool TypeInlineType::empty(void) const {\n+  return false;\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+#ifndef PRODUCT\n+void TypeInlineType::dump2(Dict &d, uint depth, outputStream* st) const {\n+  if (_vk == NULL) {\n+    st->print(\"BOTTOM inlinetype\");\n+    return;\n+  }\n+  int count = _vk->nof_declared_nonstatic_fields();\n+  st->print(\"inlinetype[%d]:{\", count);\n+  st->print(\"%s\", count != 0 ? _vk->declared_nonstatic_field_at(0)->type()->name() : \"empty\");\n+  for (int i = 1; i < count; ++i) {\n+    st->print(\", %s\", _vk->declared_nonstatic_field_at(i)->type()->name());\n+  }\n+  st->print(\"}%s\", _larval?\" : larval\":\"\");\n+}\n+#endif\n+\n@@ -2559,1 +2833,1 @@\n-const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {\n+const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {\n@@ -2573,1 +2847,1 @@\n-  return _offset;\n+  return offset();\n@@ -2635,0 +2909,1 @@\n+  case InlineType:\n@@ -2644,7 +2919,2 @@\n-int TypePtr::meet_offset( int offset ) const {\n-  \/\/ Either is 'TOP' offset?  Return the other offset!\n-  if( _offset == OffsetTop ) return offset;\n-  if( offset == OffsetTop ) return _offset;\n-  \/\/ If either is different, return 'BOTTOM' offset\n-  if( _offset != offset ) return OffsetBot;\n-  return _offset;\n+Type::Offset TypePtr::meet_offset(int offset) const {\n+  return _offset.meet(Offset(offset));\n@@ -2654,4 +2924,2 @@\n-int TypePtr::dual_offset( ) const {\n-  if( _offset == OffsetTop ) return OffsetBot;\/\/ Map 'TOP' into 'BOTTOM'\n-  if( _offset == OffsetBot ) return OffsetTop;\/\/ Map 'BOTTOM' into 'TOP'\n-  return _offset;               \/\/ Map everything else into self\n+Type::Offset TypePtr::dual_offset() const {\n+  return _offset.dual();\n@@ -2670,13 +2938,2 @@\n-int TypePtr::xadd_offset( intptr_t offset ) const {\n-  \/\/ Adding to 'TOP' offset?  Return 'TOP'!\n-  if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;\n-  \/\/ Adding to 'BOTTOM' offset?  Return 'BOTTOM'!\n-  if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;\n-  \/\/ Addition overflows or \"accidentally\" equals to OffsetTop? Return 'BOTTOM'!\n-  offset += (intptr_t)_offset;\n-  if (offset != (int)offset || offset == OffsetTop) return OffsetBot;\n-\n-  \/\/ assert( _offset >= 0 && _offset+offset >= 0, \"\" );\n-  \/\/ It is possible to construct a negative offset during PhaseCCP\n-\n-  return (int)offset;        \/\/ Sum valid offsets\n+Type::Offset TypePtr::xadd_offset(intptr_t offset) const {\n+  return _offset.add(offset);\n@@ -2691,1 +2948,1 @@\n-  return make(AnyPtr, _ptr, offset, _speculative, _inline_depth);\n+  return make(AnyPtr, _ptr, Offset(offset), _speculative, _inline_depth);\n@@ -2698,1 +2955,1 @@\n-  return _ptr == a->ptr() && _offset == a->offset() && eq_speculative(a) && _inline_depth == a->_inline_depth;\n+  return _ptr == a->ptr() && _offset == a->_offset && eq_speculative(a) && _inline_depth == a->_inline_depth;\n@@ -2704,1 +2961,1 @@\n-  return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));\n+  return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));\n@@ -2971,3 +3228,1 @@\n-  if( _offset == OffsetTop ) st->print(\"+top\");\n-  else if( _offset == OffsetBot ) st->print(\"+bot\");\n-  else if( _offset ) st->print(\"+%d\", _offset);\n+  _offset.dump2(st);\n@@ -3008,1 +3263,1 @@\n-  return (_offset != OffsetBot) && !below_centerline(_ptr);\n+  return (_offset != Offset::bottom) && !below_centerline(_ptr);\n@@ -3012,1 +3267,1 @@\n-  return (_offset == OffsetTop) || above_centerline(_ptr);\n+  return (_offset == Offset::top) || above_centerline(_ptr);\n@@ -3156,1 +3411,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,\n@@ -3166,2 +3421,2 @@\n-      (offset > 0) && xk && (k != 0) && k->is_instance_klass()) {\n-    _is_ptr_to_boxed_value = k->as_instance_klass()->is_boxed_value_offset(offset);\n+      (offset.get() > 0) && xk && (k != 0) && k->is_instance_klass()) {\n+    _is_ptr_to_boxed_value = k->as_instance_klass()->is_boxed_value_offset(offset.get());\n@@ -3170,2 +3425,2 @@\n-  if (_offset > 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {\n-    if (_offset == oopDesc::klass_offset_in_bytes()) {\n+  if (this->offset() > 0 || this->offset() == Type::OffsetTop || this->offset() == Type::OffsetBot) {\n+    if (this->offset() == oopDesc::klass_offset_in_bytes()) {\n@@ -3177,3 +3432,12 @@\n-    } else if (this->isa_aryptr()) {\n-      _is_ptr_to_narrowoop = (UseCompressedOops && klass()->is_obj_array_klass() &&\n-                             _offset != arrayOopDesc::length_offset_in_bytes());\n+    } else if (UseCompressedOops && this->isa_aryptr() && this->offset() != arrayOopDesc::length_offset_in_bytes()) {\n+      if (klass()->is_obj_array_klass()) {\n+        _is_ptr_to_narrowoop = true;\n+      } else if (klass()->is_flat_array_klass() && field_offset != Offset::top && field_offset != Offset::bottom) {\n+        \/\/ Check if the field of the inline type array element contains oops\n+        ciInlineKlass* vk = klass()->as_flat_array_klass()->element_klass()->as_inline_klass();\n+        int foffset = field_offset.get() + vk->first_field_offset();\n+        ciField* field = vk->get_field_by_offset(foffset, false);\n+        assert(field != NULL, \"missing field\");\n+        BasicType bt = field->layout_type();\n+        _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(bt);\n+      }\n@@ -3181,2 +3445,0 @@\n-      ciInstanceKlass* ik = klass()->as_instance_klass();\n-      ciField* field = NULL;\n@@ -3185,1 +3447,1 @@\n-      } else if (_offset == OffsetBot || _offset == OffsetTop) {\n+      } else if (_offset == Offset::bottom || _offset == Offset::top) {\n@@ -3190,3 +3452,2 @@\n-\n-            (_offset == java_lang_Class::klass_offset() ||\n-             _offset == java_lang_Class::array_klass_offset())) {\n+            (this->offset() == java_lang_Class::klass_offset() ||\n+             this->offset() == java_lang_Class::array_klass_offset())) {\n@@ -3198,1 +3459,1 @@\n-                   _offset >= InstanceMirrorKlass::offset_of_static_fields()) {\n+                   this->offset() >= InstanceMirrorKlass::offset_of_static_fields()) {\n@@ -3203,8 +3464,14 @@\n-            field = k->get_field_by_offset(_offset, true);\n-          }\n-          if (field != NULL) {\n-            BasicType basic_elem_type = field->layout_type();\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n-          } else {\n-            \/\/ unsafe access\n-            _is_ptr_to_narrowoop = UseCompressedOops;\n+            if (k->is_inlinetype() && this->offset() == k->as_inline_klass()->default_value_offset()) {\n+              \/\/ Special hidden field that contains the oop of the default inline type\n+              \/\/ basic_elem_type = T_PRIMITIVE_OBJECT;\n+             _is_ptr_to_narrowoop = UseCompressedOops;\n+            } else {\n+              field = k->get_field_by_offset(this->offset(), true);\n+              if (field != NULL) {\n+                BasicType basic_elem_type = field->layout_type();\n+                _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+              } else {\n+                \/\/ unsafe access\n+                _is_ptr_to_narrowoop = UseCompressedOops;\n+              }\n+            }\n@@ -3214,1 +3481,2 @@\n-          field = ik->get_field_by_offset(_offset, false);\n+          ciInstanceKlass* ik = klass()->as_instance_klass();\n+          ciField* field = ik->get_field_by_offset(this->offset(), false);\n@@ -3234,2 +3502,2 @@\n-const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,\n-                                     const TypePtr* speculative, int inline_depth) {\n+const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,\n+                                   const TypePtr* speculative, int inline_depth) {\n@@ -3240,1 +3508,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))->hashcons();\n@@ -3265,1 +3533,0 @@\n-\n@@ -3311,1 +3578,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -3353,1 +3620,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3359,1 +3626,1 @@\n-  if (klass->is_instance_klass()) {\n+  if (klass->is_instance_klass() || klass->is_inlinetype()) {\n@@ -3385,1 +3652,1 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0));\n@@ -3387,4 +3654,18 @@\n-    \/\/ Element is an object array. Recursively call ourself.\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n-    bool xk = etype->klass_is_exact();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);\n+    \/\/ Element is an object or inline type array. Recursively call ourself.\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ false, try_for_exact);\n+    bool null_free = klass->as_array_klass()->is_elem_null_free();\n+    if (null_free) {\n+      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n+    \/\/ Determine null-free\/flattened properties\n+    const TypeOopPtr* exact_etype = etype;\n+    if (etype->can_be_inline_type()) {\n+      \/\/ Use exact type if element can be an inline type\n+      exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ true, \/* try_for_exact= *\/ true);\n+    }\n+    bool not_null_free = !exact_etype->can_be_inline_type();\n+    bool not_flat = !UseFlatArray || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flatten_array());\n+\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    bool xk = etype->klass_is_exact() && (!etype->is_inlinetypeptr() || null_free);\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);\n@@ -3394,1 +3675,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));\n@@ -3399,1 +3680,2 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,\n+                                        \/* stable= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n@@ -3402,1 +3684,6 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));\n+    return arr;\n+  } else if (klass->is_flat_array_klass()) {\n+    ciInlineKlass* vk = klass->as_array_klass()->element_klass()->as_inline_klass();\n+    const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));\n@@ -3418,2 +3705,2 @@\n-  if (klass->is_instance_klass()) {\n-    \/\/ Element is an instance\n+  if (klass->is_instance_klass() || klass->is_inlinetype()) {\n+    \/\/ Element is an instance or inline type\n@@ -3423,1 +3710,1 @@\n-      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);\n+      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0));\n@@ -3427,3 +3714,8 @@\n-    const TypeOopPtr *etype =\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()));\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass());\n+    bool null_free = false;\n+    if (klass->as_array_klass()->is_elem_null_free()) {\n+      null_free = true;\n+      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()),\n+                                        \/* stable= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ !null_free);\n@@ -3434,1 +3726,1 @@\n-      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);\n+      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));\n@@ -3436,1 +3728,1 @@\n-      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);\n+      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));\n@@ -3440,3 +3732,3 @@\n-    const Type* etype =\n-      (Type*)get_const_basic_type(klass->as_type_array_klass()->element_type());\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()));\n+    const Type* etype = (Type*)get_const_basic_type(klass->as_type_array_klass()->element_type());\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()),\n+                                        \/* stable= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n@@ -3446,1 +3738,1 @@\n-      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);\n+      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));\n@@ -3448,1 +3740,12 @@\n-      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);\n+      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));\n+    }\n+  } else if (klass->is_flat_array_klass()) {\n+    ciInlineKlass* vk = klass->as_array_klass()->element_klass()->as_inline_klass();\n+    const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o->as_array()->length()));\n+    \/\/ We used to pass NotNull in here, asserting that the sub-arrays\n+    \/\/ are all not-null.  This is not true in generally, as code can\n+    \/\/ slam NULLs down in the subarrays.\n+    if (make_constant) {\n+      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));\n+    } else {\n+      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));\n@@ -3459,1 +3762,1 @@\n-  assert( _offset >= 0, \"\" );\n+  assert(offset() >= 0, \"\");\n@@ -3461,1 +3764,1 @@\n-  if (_offset != 0) {\n+  if (offset() != 0) {\n@@ -3554,6 +3857,1 @@\n-  switch( _offset ) {\n-  case OffsetTop: st->print(\"+top\"); break;\n-  case OffsetBot: st->print(\"+any\"); break;\n-  case         0: break;\n-  default:        st->print(\"+%d\",_offset); break;\n-  }\n+  _offset.dump2(st);\n@@ -3576,1 +3874,1 @@\n-  return (_offset == 0) && !below_centerline(_ptr);\n+  return (offset() == 0) && !below_centerline(_ptr);\n@@ -3585,1 +3883,1 @@\n-  return make(_ptr, offset, _instance_id, with_offset_speculative(offset), _inline_depth);\n+  return make(_ptr, Offset(offset), _instance_id, with_offset_speculative(offset), _inline_depth);\n@@ -3676,3 +3974,4 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n-                         int instance_id, const TypePtr* speculative, int inline_depth)\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,\n+                         bool flatten_array, int instance_id, const TypePtr* speculative, int inline_depth)\n+  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),\n+    _flatten_array(flatten_array) {\n@@ -3682,0 +3981,2 @@\n+   assert(!klass()->flatten_array() || flatten_array, \"Should be flat in array\");\n+   assert(!flatten_array || can_be_inline_type(), \"Only inline types can be flat in array\");\n@@ -3689,1 +3990,2 @@\n-                                     int offset,\n+                                     Offset offset,\n+                                     bool flatten_array,\n@@ -3710,0 +4012,3 @@\n+  \/\/ Check if this type is known to be flat in arrays\n+  flatten_array = flatten_array || k->flatten_array();\n+\n@@ -3712,1 +4017,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))->hashcons();\n@@ -3745,1 +4050,1 @@\n-  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n@@ -3756,1 +4061,1 @@\n-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n@@ -3762,1 +4067,1 @@\n-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);\n@@ -3769,1 +4074,1 @@\n-    int off = meet_offset(tinst->offset());\n+    Offset off = meet_offset(tinst->offset());\n@@ -3794,1 +4099,1 @@\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n+      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, false, instance_id, speculative, depth); }\n@@ -3855,1 +4160,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -3864,1 +4169,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);\n@@ -3880,1 +4185,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -3892,1 +4197,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);\n@@ -3920,1 +4225,1 @@\n-    int off = meet_offset(tinst->offset());\n+    Offset off = meet_offset(tinst->offset());\n@@ -3928,1 +4233,3 @@\n-    bool this_xk  = klass_is_exact();\n+    bool this_xk  = this->klass_is_exact();\n+    bool tinst_flatten_array = tinst->flatten_array();\n+    bool this_flatten_array  = this->flatten_array();\n@@ -3932,0 +4239,1 @@\n+    bool res_flatten_array = false;\n@@ -3933,1 +4241,3 @@\n-    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr,\n+                                   this_flatten_array, tinst_flatten_array,\n+                                   res_klass, res_xk, res_flatten_array);\n@@ -3973,1 +4283,1 @@\n-      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, res_xk, o, off, res_flatten_array, instance_id, speculative, depth);\n@@ -3980,0 +4290,21 @@\n+  case InlineType: {\n+    const TypeInlineType* tv = t->is_inlinetype();\n+    if (above_centerline(ptr())) {\n+      if (tv->inline_klass()->is_subtype_of(_klass)) {\n+        return t;\n+      } else {\n+        return TypeInstPtr::NOTNULL;\n+      }\n+    } else {\n+      PTR ptr = this->_ptr;\n+      if (ptr == Constant) {\n+        ptr = NotNull;\n+      }\n+      if (tv->inline_klass()->is_subtype_of(_klass)) {\n+        return make(ptr, _klass, false, NULL, Offset(0), _flatten_array, InstanceBot, _speculative);\n+      } else {\n+        return make(ptr, ciEnv::current()->Object_klass());\n+      }\n+    }\n+  }\n+\n@@ -3985,2 +4316,5 @@\n-                                          PTR this_ptr,\n-                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n+                                          PTR this_ptr, PTR tinst_ptr, bool this_flatten_array, bool tinst_flatten_array,\n+                                          ciKlass*&res_klass, bool &res_xk, bool& res_flatten_array) {\n+\n+  bool this_flatten_array_orig = this_flatten_array;\n+  bool tinst_flatten_array_orig = tinst_flatten_array;\n@@ -3992,1 +4326,1 @@\n-  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk && this_flatten_array == tinst_flatten_array) {\n@@ -3995,0 +4329,1 @@\n+    res_flatten_array = this_flatten_array;\n@@ -4012,0 +4347,3 @@\n+    tmp2 = tinst_flatten_array;\n+    tinst_flatten_array = this_flatten_array;\n+    this_flatten_array = tmp2;\n@@ -4029,0 +4367,1 @@\n+      res_flatten_array = below_centerline(ptr) ? tinst_flatten_array    : this_flatten_array;\n@@ -4036,0 +4375,1 @@\n+      res_flatten_array = above_centerline(ptr) ? tinst_flatten_array : false;\n@@ -4071,0 +4411,1 @@\n+  bool flat_array = false;\n@@ -4074,1 +4415,2 @@\n-  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n+    flat_array = below_centerline(ptr) ? (this_flatten_array && tinst_flatten_array) : (this_flatten_array || tinst_flatten_array);\n+  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass) && (!tinst_flatten_array || this_flatten_array)) {\n@@ -4077,1 +4419,2 @@\n-  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n+    flat_array = this_flatten_array;\n+  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass) && (!this_flatten_array || tinst_flatten_array)) {\n@@ -4080,0 +4423,1 @@\n+    flat_array = tinst_flatten_array;\n@@ -4086,0 +4430,1 @@\n+      this_flatten_array = tinst_flatten_array = flat_array;\n@@ -4089,0 +4434,1 @@\n+      this_flatten_array = tinst_flatten_array;\n@@ -4092,0 +4438,1 @@\n+      tinst_flatten_array = this_flatten_array;\n@@ -4094,0 +4441,1 @@\n+      this_flatten_array = flat_array;\n@@ -4104,0 +4452,1 @@\n+    res_flatten_array = this_flatten_array;\n@@ -4118,0 +4467,1 @@\n+  res_flatten_array = this_flatten_array_orig && tinst_flatten_array_orig;\n@@ -4124,1 +4474,1 @@\n-ciType* TypeInstPtr::java_mirror_type() const {\n+ciType* TypeInstPtr::java_mirror_type(bool* is_val_mirror) const {\n@@ -4130,2 +4480,1 @@\n-\n-  return const_oop()->as_instance()->java_mirror_type();\n+  return const_oop()->as_instance()->java_mirror_type(is_val_mirror);\n@@ -4139,1 +4488,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4148,0 +4497,1 @@\n+    flatten_array() == p->flatten_array() &&\n@@ -4154,1 +4504,1 @@\n-  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n+  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), (jint)flatten_array());\n@@ -4258,5 +4608,1 @@\n-  if( _offset ) {               \/\/ Dump offset, if any\n-    if( _offset == OffsetBot )      st->print(\"+any\");\n-    else if( _offset == OffsetTop ) st->print(\"+unknown\");\n-    else st->print(\"+%d\", _offset);\n-  }\n+  _offset.dump2(st);\n@@ -4265,0 +4611,5 @@\n+\n+  if (flatten_array() && !klass()->is_inlinetype()) {\n+    st->print(\" (flatten array)\");\n+  }\n+\n@@ -4277,1 +4628,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),\n@@ -4282,1 +4633,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), Offset(offset), flatten_array(),\n@@ -4291,1 +4642,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(),\n@@ -4299,1 +4650,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);\n@@ -4304,1 +4655,5 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);\n+}\n+\n+const TypeInstPtr *TypeInstPtr::cast_to_flatten_array() const {\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);\n@@ -4316,1 +4671,1 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), Offset(0), flatten_array());\n@@ -4331,0 +4686,1 @@\n+const TypeAryPtr *TypeAryPtr::INLINES;\n@@ -4333,1 +4689,1 @@\n-const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,\n+const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,\n@@ -4339,1 +4695,1 @@\n-  return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))->hashcons();\n+  return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))->hashcons();\n@@ -4343,1 +4699,1 @@\n-const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,\n+const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,\n@@ -4351,1 +4707,1 @@\n-  return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))->hashcons();\n+  return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))->hashcons();\n@@ -4357,1 +4713,1 @@\n-  return make(ptr, ptr == Constant ? const_oop() : NULL, _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, ptr == Constant ? const_oop() : NULL, _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -4365,1 +4721,7 @@\n-  return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);\n+\n+  const TypeAry* new_ary = _ary;\n+  if (klass() != NULL && klass()->is_obj_array_klass() && klass_is_exact) {\n+    \/\/ An object array can't be flat or null-free if the klass is exact\n+    new_ary = TypeAry::make(elem(), size(), is_stable(), \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+  }\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -4371,1 +4733,1 @@\n-  return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -4427,2 +4789,36 @@\n-  const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());\n-  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);\n+  const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+}\n+\n+\/\/-------------------------------cast_to_not_flat------------------------------\n+const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {\n+  if (not_flat == is_not_flat()) {\n+    return this;\n+  }\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+}\n+\n+\/\/-------------------------------cast_to_not_null_free-------------------------\n+const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {\n+  if (not_null_free == is_not_null_free()) {\n+    return this;\n+  }\n+  \/\/ Not null free implies not flat\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+}\n+\n+\/\/---------------------------------update_properties---------------------------\n+const TypeAryPtr* TypeAryPtr::update_properties(const TypeAryPtr* from) const {\n+  if ((from->is_flat()          && is_not_flat()) ||\n+      (from->is_not_flat()      && is_flat()) ||\n+      (from->is_null_free()     && is_not_null_free()) ||\n+      (from->is_not_null_free() && is_null_free())) {\n+    return NULL; \/\/ Inconsistent properties\n+  } else if (from->is_not_null_free()) {\n+    return cast_to_not_null_free(); \/\/ Implies not flat\n+  } else if (from->is_not_flat()) {\n+    return cast_to_not_flat();\n+  }\n+  return this;\n@@ -4444,1 +4840,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem, size(), stable);\n+  const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());\n@@ -4446,1 +4842,1 @@\n-  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -4464,4 +4860,8 @@\n-  \/\/ The pointers in the autobox arrays are always non-null.\n-  etype = etype->cast_to_ptr_type(TypePtr::NotNull)->is_oopptr();\n-  const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());\n-  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, \/*is_autobox_cache=*\/true);\n+  \/\/ TODO fix with JDK-8284164\n+  \/\/ Ignore inline types to not confuse logic in TypeAryPtr::compute_klass\n+  if (!etype->is_inlinetypeptr()) {\n+    \/\/ The pointers in the autobox arrays are always non-null.\n+    etype = etype->cast_to_ptr_type(TypePtr::NotNull)->is_oopptr();\n+  }\n+  const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, \/*is_autobox_cache=*\/true);\n@@ -4476,1 +4876,2 @@\n-    TypeOopPtr::eq(p);  \/\/ Check sub-parts\n+    TypeOopPtr::eq(p) &&\/\/ Check sub-parts\n+    _field_offset == p->_field_offset;\n@@ -4482,1 +4883,1 @@\n-  return (intptr_t)_ary + TypeOopPtr::hash();\n+  return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();\n@@ -4582,1 +4983,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -4591,1 +4992,1 @@\n-                  _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+                  _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n@@ -4605,1 +5006,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -4621,1 +5022,1 @@\n-                  _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+                  _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n@@ -4635,1 +5036,2 @@\n-    int off = meet_offset(tap->offset());\n+    Offset off = meet_offset(tap->offset());\n+    Offset field_off = meet_field_offset(tap->field_offset());\n@@ -4644,2 +5046,8 @@\n-    const Type* elem = tary->_elem;\n-    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+    bool res_not_flat = false;\n+    bool res_not_null_free = false;\n+    const Type* res_elem = NULL;\n+    if (meet_aryptr(ptr, _ary->_elem, tap->_ary->_elem, this->klass(), tap->klass(),\n+                    this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(),\n+                    this->is_not_flat(), tap->is_not_flat(),\n+                    this->is_not_null_free(), tap->is_not_null_free(),\n+                    res_elem, res_klass, res_xk, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n@@ -4647,0 +5055,11 @@\n+    } else if (klass() != NULL && tap->klass() != NULL && klass()->is_flat_array_klass() != tap->klass()->is_flat_array_klass()) {\n+      \/\/ Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.\n+      if (tary->_elem->isa_inlinetype()) {\n+        \/\/ Result is flattened\n+        off = Offset(is_flat() ? offset() : tap->offset());\n+        field_off = is_flat() ? field_offset() : tap->field_offset();\n+      } else if (tary->_elem->make_oopptr() != NULL && tary->_elem->make_oopptr()->isa_instptr() && below_centerline(ptr)) {\n+        \/\/ Result is non-flattened\n+        off = Offset(flattened_offset()).meet(Offset(tap->flattened_offset()));\n+        field_off = Offset::bottom;\n+      }\n@@ -4664,1 +5083,1 @@\n-    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable), res_klass, res_xk, off, instance_id, speculative, depth);\n+    return make(ptr, o, TypeAry::make(res_elem, tary->_size, tary->_stable, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n@@ -4670,1 +5089,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -4681,2 +5100,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n-        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flatten_array()) {\n+        return make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n@@ -4687,1 +5106,1 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);\n@@ -4699,1 +5118,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flatten_array()) {\n@@ -4702,1 +5121,1 @@\n-                      _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+                      _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n@@ -4713,1 +5132,1 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);\n@@ -4717,0 +5136,13 @@\n+\n+  case InlineType: {\n+    const TypeInlineType* tv = t->is_inlinetype();\n+    if (above_centerline(ptr())) {\n+      return TypeInstPtr::NOTNULL;\n+    } else {\n+      PTR ptr = this->_ptr;\n+      if (ptr == Constant) {\n+        ptr = NotNull;\n+      }\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass());\n+    }\n+  }\n@@ -4722,1 +5154,7 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type* this_elem, const Type* tap_elem,\n+                                         ciKlass* this_klass, ciKlass* tap_klass,\n+                                         bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr,\n+                                         bool this_not_flat, bool tap_not_flat,\n+                                         bool this_not_null_free, bool tap_not_null_free,\n+                                         const Type*& res_elem, ciKlass*& res_klass,\n+                                         bool& res_xk, bool& res_not_flat, bool& res_not_null_free) {\n@@ -4725,1 +5163,5 @@\n-  if (elem->isa_int()) {\n+  res_elem = this_elem->meet(tap_elem);\n+  res_not_flat = this_not_flat && tap_not_flat;\n+  res_not_null_free = this_not_null_free && tap_not_null_free;\n+\n+  if (res_elem->isa_int()) {\n@@ -4728,1 +5170,1 @@\n-    if (this_klass == NULL)\n+    if (this_klass == NULL) {\n@@ -4730,1 +5172,1 @@\n-    else if (tap_klass == NULL || tap_klass == this_klass) {\n+    } else if (tap_klass == NULL || tap_klass == this_klass) {\n@@ -4736,1 +5178,1 @@\n-      elem = Type::BOTTOM;\n+      res_elem = Type::BOTTOM;\n@@ -4751,2 +5193,3 @@\n-      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr))) {\n-        elem = Type::BOTTOM;\n+      if (above_centerline(ptr) || (res_elem->make_ptr() && above_centerline(res_elem->make_ptr()->_ptr)) ||\n+          res_elem->isa_inlinetype()) {\n+        res_elem = Type::BOTTOM;\n@@ -4766,0 +5209,3 @@\n+        if (this_elem->isa_inlinetype()) {\n+          res_elem = this_elem;\n+        }\n@@ -4769,1 +5215,1 @@\n-      return result;\n+      break;\n@@ -4772,1 +5218,1 @@\n-          res_xk = true;\n+        res_xk = true;\n@@ -4779,1 +5225,1 @@\n-      return result;\n+      break;\n@@ -4786,0 +5232,3 @@\n+        if (tap_elem->isa_inlinetype()) {\n+          res_elem = tap_elem;\n+        }\n@@ -4790,1 +5239,1 @@\n-      return result;\n+      break;\n@@ -4796,0 +5245,1 @@\n+\n@@ -4803,1 +5253,10 @@\n-  return new TypeAryPtr(dual_ptr(), _const_oop, _ary->dual()->is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());\n+  return new TypeAryPtr(dual_ptr(), _const_oop, _ary->dual()->is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());\n+}\n+\n+Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {\n+  return _field_offset.meet(offset);\n+}\n+\n+\/\/------------------------------dual_offset------------------------------------\n+Type::Offset TypeAryPtr::dual_field_offset() const {\n+  return _field_offset.dual();\n@@ -4840,1 +5299,6 @@\n-  if( _offset != 0 ) {\n+  if (is_flat()) {\n+    st->print(\"(\");\n+    _field_offset.dump2(st);\n+    st->print(\")\");\n+  }\n+  if (offset() != 0) {\n@@ -4842,3 +5306,3 @@\n-    if( _offset == OffsetTop )       st->print(\"+undefined\");\n-    else if( _offset == OffsetBot )  st->print(\"+any\");\n-    else if( _offset < header_size ) st->print(\"+%d\", _offset);\n+    if( _offset == Offset::top )       st->print(\"+undefined\");\n+    else if( _offset == Offset::bottom )  st->print(\"+any\");\n+    else if( offset() < header_size ) st->print(\"+%d\", offset());\n@@ -4852,1 +5316,1 @@\n-        st->print(\"[%d]\", (_offset - array_base)\/elem_size);\n+        st->print(\"[%d]\", (offset() - array_base)\/elem_size);\n@@ -4874,1 +5338,1 @@\n-  return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);\n+  return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);\n@@ -4878,1 +5342,1 @@\n-  return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, offset, _instance_id, with_offset_speculative(offset), _inline_depth);\n+  return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, Offset(offset), _field_offset, _instance_id, with_offset_speculative(offset), _inline_depth, _is_autobox_cache);\n@@ -4882,1 +5346,1 @@\n-  return make(_ptr, _const_oop, ary, _klass, _klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(_ptr, _const_oop, ary, _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -4890,1 +5354,13 @@\n-  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);\n+}\n+\n+const Type* TypeAryPtr::cleanup_speculative() const {\n+  if (speculative() == NULL) {\n+    return this;\n+  }\n+  \/\/ Keep speculative part if it contains information about flat-\/nullability\n+  const TypeAryPtr* spec_aryptr = speculative()->isa_aryptr();\n+  if (spec_aryptr != NULL && (spec_aryptr->is_not_flat() || spec_aryptr->is_not_null_free())) {\n+    return this;\n+  }\n+  return TypeOopPtr::cleanup_speculative();\n@@ -4897,1 +5373,49 @@\n-  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);\n+}\n+\n+const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+}\n+\n+const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {\n+  int adj = 0;\n+  if (offset != Type::OffsetBot && offset != Type::OffsetTop) {\n+    const Type* elemtype = elem();\n+    if (elemtype->isa_inlinetype()) {\n+      if (_offset.get() != OffsetBot && _offset.get() != OffsetTop) {\n+        adj = _offset.get();\n+        offset += _offset.get();\n+      }\n+      uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+      if (_field_offset.get() != OffsetBot && _field_offset.get() != OffsetTop) {\n+        offset += _field_offset.get();\n+        if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {\n+          offset += header;\n+        }\n+      }\n+      if (offset >= (intptr_t)header || offset < 0) {\n+        \/\/ Try to get the field of the inline type array element we are pointing to\n+        ciKlass* arytype_klass = klass();\n+        ciFlatArrayKlass* vak = arytype_klass->as_flat_array_klass();\n+        ciInlineKlass* vk = vak->element_klass()->as_inline_klass();\n+        int shift = vak->log2_element_size();\n+        int mask = (1 << shift) - 1;\n+        intptr_t field_offset = ((offset - header) & mask);\n+        ciField* field = vk->get_field_by_offset(field_offset + vk->first_field_offset(), false);\n+        if (field != NULL) {\n+          return with_field_offset(field_offset)->add_offset(offset - field_offset - adj);\n+        }\n+      }\n+    }\n+  }\n+  return add_offset(offset - adj);\n+}\n+\n+\/\/ Return offset incremented by field_offset for flattened inline type arrays\n+const int TypeAryPtr::flattened_offset() const {\n+  int offset = _offset.get();\n+  if (offset != Type::OffsetBot && offset != Type::OffsetTop &&\n+      _field_offset != Offset::bottom && _field_offset != Offset::top) {\n+    offset += _field_offset.get();\n+  }\n+  return offset;\n@@ -4902,1 +5426,1 @@\n-  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);\n@@ -4907,0 +5431,1 @@\n+\n@@ -4997,1 +5522,0 @@\n-\n@@ -5003,0 +5527,3 @@\n+  case InlineType:\n+    return t->xmeet(this);\n+\n@@ -5081,1 +5608,1 @@\n-  return (_offset == 0) && !below_centerline(_ptr);\n+  return (offset() == 0) && !below_centerline(_ptr);\n@@ -5101,1 +5628,1 @@\n-  assert( _offset >= 0, \"\" );\n+  assert(offset() >= 0, \"\");\n@@ -5103,1 +5630,1 @@\n-  if (_offset != 0) {\n+  if (offset() != 0) {\n@@ -5154,1 +5681,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -5182,1 +5709,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -5215,1 +5742,1 @@\n-  switch( _offset ) {\n+  switch (offset()) {\n@@ -5219,1 +5746,1 @@\n-  default:        st->print(\"+%d\",_offset); break;\n+  default:        st->print(\"+%d\",offset()); break;\n@@ -5229,1 +5756,1 @@\n-TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):\n+TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):\n@@ -5234,1 +5761,1 @@\n-  return make(Constant, m, 0);\n+  return make(Constant, m, Offset(0));\n@@ -5237,1 +5764,1 @@\n-  return make(Constant, m, 0);\n+  return make(Constant, m, Offset(0));\n@@ -5242,1 +5769,1 @@\n-const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {\n+const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {\n@@ -5253,1 +5780,3 @@\n-    if (elem->is_klassptr()->klass_is_exact()) {\n+    if (elem->is_klassptr()->klass_is_exact() &&\n+        \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+        (is_null_free() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n@@ -5256,0 +5785,2 @@\n+  } else if (elem->isa_inlinetype() != NULL) {\n+    elem = TypeKlassPtr::make(elem->inline_klass());\n@@ -5257,1 +5788,1 @@\n-  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), 0);\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_null_free());\n@@ -5260,1 +5791,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass* klass) {\n@@ -5267,1 +5798,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset) {\n@@ -5274,2 +5805,1 @@\n-\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, Offset offset)\n@@ -5304,1 +5834,1 @@\n-  return (_offset == 0) && !below_centerline(_ptr);\n+  return (offset() == 0) && !below_centerline(_ptr);\n@@ -5316,1 +5846,1 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n+    if (!empty() && ktkp != NULL && ktkp->is_loaded() && ktkp->klass()->is_interface())\n@@ -5337,1 +5867,1 @@\n-  assert( _offset >= 0, \"\" );\n+  assert( offset() >= 0, \"\" );\n@@ -5339,1 +5869,1 @@\n-  if (_offset != 0) {\n+  if (offset() != 0) {\n@@ -5359,1 +5889,1 @@\n-void TypeKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n+void TypeInstKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n@@ -5382,5 +5912,2 @@\n-\n-  if (_offset) {               \/\/ Dump offset, if any\n-    if (_offset == OffsetBot)      { st->print(\"+any\"); }\n-    else if (_offset == OffsetTop) { st->print(\"+unknown\"); }\n-    else                            { st->print(\"+%d\", _offset); }\n+  if (Verbose) {\n+    if (_flatten_array) st->print(\":flatten array\");\n@@ -5388,1 +5915,1 @@\n-\n+  _offset.dump2(st);\n@@ -5404,0 +5931,1 @@\n+    flatten_array() == p->flatten_array() &&\n@@ -5408,1 +5936,1 @@\n-  return java_add((jint)klass()->hash(), TypeKlassPtr::hash());\n+  return java_add(java_add((jint)klass()->hash(), TypeKlassPtr::hash()), (jint)flatten_array());\n@@ -5411,1 +5939,3 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {\n+  flatten_array = flatten_array || k->flatten_array();\n+\n@@ -5413,1 +5943,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset, flatten_array))->hashcons();\n@@ -5421,1 +5951,1 @@\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+  return make(_ptr, klass(), xadd_offset(offset), flatten_array());\n@@ -5425,1 +5955,1 @@\n-  return make(_ptr, klass(), offset);\n+  return make(_ptr, klass(), Offset(offset), flatten_array());\n@@ -5432,1 +5962,1 @@\n-  return make(ptr, _klass, _offset);\n+  return make(ptr, _klass, _offset, flatten_array());\n@@ -5448,1 +5978,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _offset, flatten_array());\n@@ -5477,1 +6007,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, Offset(0), flatten_array() && !klass()->is_inlinetype());\n@@ -5510,1 +6040,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -5518,1 +6048,1 @@\n-      return make( ptr, klass(), offset );\n+      return make(ptr, klass(), offset, flatten_array());\n@@ -5531,1 +6061,1 @@\n-    return TypePtr::BOTTOM;\n+      return TypePtr::BOTTOM;\n@@ -5551,1 +6081,1 @@\n-    int  off     = meet_offset(tkls->offset());\n+    Offset  off     = meet_offset(tkls->offset());\n@@ -5557,0 +6087,2 @@\n+    bool tkls_flatten_array = tkls->flatten_array();\n+    bool this_flatten_array  = this->flatten_array();\n@@ -5560,1 +6092,3 @@\n-    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+    bool res_flatten_array = false;\n+    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr,\n+                        this_flatten_array, tkls_flatten_array, res_klass, res_xk, res_flatten_array)) {\n@@ -5568,1 +6102,1 @@\n-        const Type* res1 = make(ptr, res_klass, off);\n+        const Type* res1 = make(ptr, res_klass, off, res_flatten_array);\n@@ -5577,1 +6111,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -5587,1 +6121,1 @@\n-        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset);\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n@@ -5591,1 +6125,1 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+        return make(ptr, ciEnv::current()->Object_klass(), offset, false);\n@@ -5606,1 +6140,1 @@\n-                                       tp->elem(), tp->klass(), offset);\n+                                       tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n@@ -5613,1 +6147,1 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      return make(ptr, ciEnv::current()->Object_klass(), offset, false);\n@@ -5617,0 +6151,20 @@\n+  case InlineType: {\n+    const TypeInlineType* tv = t->is_inlinetype();\n+    if (above_centerline(ptr())) {\n+      if (tv->inline_klass()->is_subtype_of(_klass)) {\n+        return t;\n+      } else {\n+        return TypeInstPtr::NOTNULL;\n+      }\n+    } else {\n+      PTR ptr = this->_ptr;\n+      if (ptr == Constant) {\n+        ptr = NotNull;\n+      }\n+      if (tv->inline_klass()->is_subtype_of(_klass)) {\n+        return make(ptr, _klass, Offset(0), _flatten_array);\n+      } else {\n+        return make(ptr, ciEnv::current()->Object_klass(), Offset(0));\n+      }\n+    }\n+  }\n@@ -5625,1 +6179,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());\n@@ -5691,2 +6245,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n-  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset))->hashcons();\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n+  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, null_free))->hashcons();\n@@ -5695,1 +6249,1 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n@@ -5699,2 +6253,10 @@\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n-    return TypeAryKlassPtr::make(ptr, etype, NULL, offset);\n+    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    if (etype->klass_is_exact() && etype->isa_instklassptr() && etype->is_instklassptr()->klass()->is_inlinetype() && !null_free) {\n+      etype = TypeInstKlassPtr::make(NotNull, etype->is_instklassptr()->klass(), Offset(etype->is_instklassptr()->offset()), etype->is_instklassptr()->flatten_array());\n+    }\n+\n+    const TypeAryKlassPtr* res = TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free);\n+    assert(res->klass() == klass, \"\");\n+    return res;\n@@ -5704,1 +6266,5 @@\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+    return TypeAryKlassPtr::make(ptr, etype, klass, offset, not_flat, not_null_free, null_free);\n+  } else if (klass->is_flat_array_klass()) {\n+    ciKlass* eklass = klass->as_flat_array_klass()->element_klass();\n+    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass);\n+    return TypeAryKlassPtr::make(ptr, etype, klass, offset, not_flat, not_null_free, null_free);\n@@ -5711,0 +6277,11 @@\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset) {\n+  bool null_free = k->as_array_klass()->is_elem_null_free();\n+  bool not_null_free = (ptr == Constant) ? !null_free : !k->is_flat_array_klass() && (k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false));\n+\n+  bool not_flat = !UseFlatArray || not_null_free || (k->as_array_klass()->element_klass() != NULL &&\n+                                                     k->as_array_klass()->element_klass()->is_inlinetype() &&\n+                                                     !k->as_array_klass()->element_klass()->flatten_array());\n+\n+  return TypeAryKlassPtr::make(ptr, k, offset, not_flat, not_null_free, null_free);\n+}\n+\n@@ -5712,1 +6289,1 @@\n-  return TypeAryKlassPtr::make(Constant, klass, 0);\n+  return TypeAryKlassPtr::make(Constant, klass, Offset(0));\n@@ -5721,0 +6298,3 @@\n+    _not_flat == p->_not_flat &&\n+    _not_null_free == p->_not_null_free &&\n+    _null_free == p->_null_free &&\n@@ -5735,1 +6315,0 @@\n-  const TypeInstPtr *tinst;\n@@ -5743,3 +6322,9 @@\n-  if ((tinst = el->isa_instptr()) != NULL) {\n-    \/\/ Compute array klass from element klass\n-    k_ary = ciObjArrayKlass::make(tinst->klass());\n+  if (el->isa_instptr()) {\n+    \/\/ Compute object array klass from element klass\n+    bool null_free = el->is_inlinetypeptr() && el->isa_instptr()->ptr() != TypePtr::TopPTR && !el->isa_instptr()->maybe_null();\n+    k_ary = ciArrayKlass::make(el->is_oopptr()->klass(), null_free);\n+  } else if (el->isa_inlinetype()) {\n+    \/\/ If element type is TypeInlineType::BOTTOM, inline_klass() will be null.\n+    if (el->inline_klass() != NULL) {\n+      k_ary = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n+    }\n@@ -5810,2 +6395,2 @@\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+        offset() != 0 && offset() != arrayOopDesc::length_offset_in_bytes() &&\n+        offset() != arrayOopDesc::klass_offset_in_bytes()) {\n@@ -5824,1 +6409,1 @@\n-    k = ciObjArrayKlass::make(k);\n+    k = ciArrayKlass::make(k, is_null_free());\n@@ -5844,1 +6429,1 @@\n-  return make(_ptr, elem(), klass(), xadd_offset(offset));\n+  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _null_free);\n@@ -5848,1 +6433,1 @@\n-  return make(_ptr, elem(), klass(), offset);\n+  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _null_free);\n@@ -5855,1 +6440,1 @@\n-  return make(ptr, elem(), _klass, _offset);\n+  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _null_free);\n@@ -5869,1 +6454,1 @@\n-  if (must_be_exact()) return this;  \/\/ cannot clear xk\n+  if (must_be_exact() && !klass_is_exact) return this;  \/\/ cannot clear xk\n@@ -5875,1 +6460,16 @@\n-  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset);\n+  bool not_flat = is_not_flat();\n+  bool not_null_free = is_not_null_free();\n+  if (k != NULL && k->is_obj_array_klass()) {\n+    if (klass_is_exact) {\n+      \/\/ An object array can't be flat or null-free if the klass is exact\n+      not_flat = true;\n+      not_null_free = true;\n+    } else {\n+      \/\/ Klass is not exact (anymore), re-compute null-free\/flat properties\n+      not_null_free = !k->as_array_klass()->element_klass()->can_be_inline_klass(false);\n+      not_flat = !UseFlatArray || not_null_free || (k->as_array_klass()->element_klass() != NULL &&\n+                                                    k->as_array_klass()->element_klass()->is_inlinetype() &&\n+                                                    !k->as_array_klass()->element_klass()->flatten_array());\n+    }\n+  }\n+  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _null_free);\n@@ -5884,0 +6484,1 @@\n+  assert(k != NULL, \"klass should not be NULL\");\n@@ -5892,1 +6493,10 @@\n-  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS), k, xk, 0);\n+  bool null_free = _null_free;\n+  if (null_free && el->isa_ptr()) {\n+    el = el->is_ptr()->join_speculative(TypePtr::NOTNULL);\n+  }\n+  bool not_flat = is_not_flat();\n+  bool not_null_free = is_not_null_free();\n+  if (is_flat()) {\n+    el = TypeInlineType::make(el->inline_klass());\n+  }\n+  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS, false, not_flat, not_null_free), k, xk, Offset(0));\n@@ -5926,1 +6536,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -5934,1 +6544,1 @@\n-      return make( ptr, _elem, klass(), offset );\n+      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), _null_free);\n@@ -5967,3 +6577,2 @@\n-    int off = meet_offset(tap->offset());\n-    const Type* elem = _elem->meet(tap->_elem);\n-\n+    Offset off = meet_offset(tap->offset());\n+    const Type* res_elem = NULL;\n@@ -5973,1 +6582,7 @@\n-    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    bool res_not_flat = false;\n+    bool res_not_null_free = false;\n+    MeetResult res = meet_aryptr(ptr, _elem, tap->_elem, this->klass(), tap->klass(),\n+                                 this->klass_is_exact(), tap->klass_is_exact(),\n+                                 this->ptr(), tap->ptr(), this->is_not_flat(), tap->is_not_flat(),\n+                                 this->is_not_null_free(), tap->is_not_null_free(),\n+                                 res_elem, res_klass, res_xk, res_not_flat, res_not_null_free);\n@@ -5975,1 +6590,11 @@\n-    return make(ptr, elem, res_klass, off);\n+    bool null_free = meet_null_free(tap->_null_free);\n+    if (res == NOT_SUBTYPE) {\n+      null_free = false;\n+    } else if (res == SUBTYPE) {\n+      if (above_centerline(tap->ptr()) && !above_centerline(this->ptr())) {\n+        null_free = _null_free;\n+      } else if (above_centerline(this->ptr()) && !above_centerline(tap->ptr())) {\n+        null_free = tap->_null_free;\n+      }\n+    }\n+    return make(ptr, res_elem, res_klass, off, res_not_flat, res_not_null_free, null_free);\n@@ -5979,1 +6604,1 @@\n-    int offset = meet_offset(tp->offset());\n+    Offset offset = meet_offset(tp->offset());\n@@ -5989,1 +6614,1 @@\n-        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset);\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), _null_free);\n@@ -5993,1 +6618,1 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset, false);\n@@ -6007,1 +6632,1 @@\n-          return make(ptr, _elem, _klass, offset);\n+          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), _null_free);\n@@ -6014,1 +6639,1 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset, false);\n@@ -6018,0 +6643,12 @@\n+  case InlineType: {\n+    const TypeInlineType* tv = t->is_inlinetype();\n+    if (above_centerline(ptr())) {\n+      return TypeInstKlassPtr::BOTTOM;\n+    } else {\n+      PTR ptr = this->_ptr;\n+      if (ptr == Constant) {\n+        ptr = NotNull;\n+      }\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), Offset(0));\n+    }\n+  }\n@@ -6040,0 +6677,3 @@\n+    if (other->is_null_free() && !is_null_free()) {\n+      return false; \/\/ [LMyValue is not a subtype of [QMyValue\n+    }\n@@ -6092,1 +6732,1 @@\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset());\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_null_free());\n@@ -6102,1 +6742,1 @@\n-    k = ciObjArrayKlass::make(k);\n+    k = ciArrayKlass::make(k, _null_free);\n@@ -6114,4 +6754,18 @@\n-  if (elem()->isa_klassptr()) {\n-    k = elem()->is_klassptr()->klass();\n-    if (k != NULL) {\n-      k = ciObjArrayKlass::make(k);\n+  const Type* el = elem();\n+  if (el->isa_instklassptr()) {\n+    \/\/ Compute object array klass from element klass\n+    bool null_free = el->is_instklassptr()->klass()->is_inlinetype() && el->isa_instklassptr()->ptr() != TypePtr::TopPTR && (_null_free != 0);\n+    k = ciArrayKlass::make(el->is_klassptr()->klass(), null_free);\n+    ((TypeAryKlassPtr*)this)->_klass = k;\n+  } else if (el->isa_inlinetype()) {\n+    \/\/ If element type is TypeInlineType::BOTTOM, inline_klass() will be null.\n+    if (el->inline_klass() != NULL) {\n+      k = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n+      ((TypeAryKlassPtr*)this)->_klass = k;\n+    }\n+  } else if (el->isa_aryklassptr() != NULL) {\n+    \/\/ Compute array klass from element klass\n+    ciKlass* k_elem = el->is_aryklassptr()->klass();\n+    \/\/ If element type is something like bottom[], k_elem will be null.\n+    if (k_elem != NULL) {\n+      k = ciObjArrayKlass::make(k_elem);\n@@ -6138,0 +6792,4 @@\n+      if (_elem->isa_inlinetype()) {\n+        const char *name = _elem->is_inlinetype()->inline_klass()->name()->as_utf8();\n+        st->print(\"precise %s: \" INTPTR_FORMAT \" \", name, p2i(klass()));\n+      }\n@@ -6151,5 +6809,5 @@\n-\n-  if( _offset ) {               \/\/ Dump offset, if any\n-    if( _offset == OffsetBot )      { st->print(\"+any\"); }\n-    else if( _offset == OffsetTop ) { st->print(\"+unknown\"); }\n-    else                            { st->print(\"+%d\", _offset); }\n+  if (Verbose) {\n+    if (is_flat()) st->print(\":flat\");\n+    if (_not_flat) st->print(\":not flat\");\n+    if (_not_null_free) st->print(\":not null free\");\n+    if (_null_free) st->print(\":null free\");\n@@ -6158,0 +6816,2 @@\n+  _offset.dump2(st);\n+\n@@ -6176,2 +6836,14 @@\n-const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {\n-  return (TypeFunc*)(new TypeFunc(domain,range))->hashcons();\n+const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,\n+                               const TypeTuple *range_sig, const TypeTuple *range_cc) {\n+  return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))->hashcons();\n+}\n+\n+const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {\n+  return make(domain, domain, range, range);\n+}\n+\n+\/\/------------------------------osr_domain-----------------------------\n+const TypeTuple* osr_domain() {\n+  const Type **fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  \/\/ address of osr buffer\n+  return TypeTuple::make(TypeFunc::Parms+1, fields);\n@@ -6181,1 +6853,1 @@\n-const TypeFunc *TypeFunc::make(ciMethod* method) {\n+const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {\n@@ -6183,7 +6855,20 @@\n-  const TypeFunc* tf = C->last_tf(method); \/\/ check cache\n-  if (tf != NULL)  return tf;  \/\/ The hit rate here is almost 50%.\n-  const TypeTuple *domain;\n-  if (method->is_static()) {\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n-  } else {\n-    domain = TypeTuple::make_domain(method->holder(), method->signature());\n+  const TypeFunc* tf = NULL;\n+  if (!is_osr_compilation) {\n+    tf = C->last_tf(method); \/\/ check cache\n+    if (tf != NULL)  return tf;  \/\/ The hit rate here is almost 50%.\n+  }\n+  \/\/ Inline types are not passed\/returned by reference, instead each field of\n+  \/\/ the inline type is passed\/returned as an argument. We maintain two views of\n+  \/\/ the argument\/return list here: one based on the signature (with an inline\n+  \/\/ type argument\/return as a single slot), one based on the actual calling\n+  \/\/ convention (with an inline type argument\/return as a list of its fields).\n+  bool has_scalar_args = method->has_scalarized_args() && !is_osr_compilation;\n+  const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);\n+  const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;\n+  ciSignature* sig = method->signature();\n+  bool has_scalar_ret = sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  const TypeTuple* range_sig = TypeTuple::make_range(sig, false);\n+  const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;\n+  tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);\n+  if (!is_osr_compilation) {\n+    C->set_last_tf(method, tf);  \/\/ fill cache\n@@ -6191,3 +6876,0 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n-  tf = TypeFunc::make(domain, range);\n-  C->set_last_tf(method, tf);  \/\/ fill cache\n@@ -6228,2 +6910,4 @@\n-  return _domain == a->_domain &&\n-    _range == a->_range;\n+  return _domain_sig == a->_domain_sig &&\n+    _domain_cc == a->_domain_cc &&\n+    _range_sig == a->_range_sig &&\n+    _range_cc == a->_range_cc;\n@@ -6235,1 +6919,1 @@\n-  return (intptr_t)_domain + (intptr_t)_range;\n+  return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;\n@@ -6242,1 +6926,1 @@\n-  if( _range->cnt() <= Parms )\n+  if( _range_sig->cnt() <= Parms )\n@@ -6246,2 +6930,2 @@\n-    for (i = Parms; i < _range->cnt()-1; i++) {\n-      _range->field_at(i)->dump2(d,depth,st);\n+    for (i = Parms; i < _range_sig->cnt()-1; i++) {\n+      _range_sig->field_at(i)->dump2(d,depth,st);\n@@ -6250,1 +6934,1 @@\n-    _range->field_at(i)->dump2(d,depth,st);\n+    _range_sig->field_at(i)->dump2(d,depth,st);\n@@ -6259,3 +6943,3 @@\n-  if (Parms < _domain->cnt())\n-    _domain->field_at(Parms)->dump2(d,depth-1,st);\n-  for (uint i = Parms+1; i < _domain->cnt(); i++) {\n+  if (Parms < _domain_sig->cnt())\n+    _domain_sig->field_at(Parms)->dump2(d,depth-1,st);\n+  for (uint i = Parms+1; i < _domain_sig->cnt(); i++) {\n@@ -6263,1 +6947,1 @@\n-    _domain->field_at(i)->dump2(d,depth-1,st);\n+    _domain_sig->field_at(i)->dump2(d,depth-1,st);\n@@ -6283,1 +6967,1 @@\n-  if (range()->cnt() == TypeFunc::Parms) {\n+  if (range_sig()->cnt() == TypeFunc::Parms) {\n@@ -6286,1 +6970,1 @@\n-  return range()->field_at(TypeFunc::Parms)->basic_type();\n+  return range_sig()->field_at(TypeFunc::Parms)->basic_type();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1032,"deletions":348,"binary":false,"changes":1380,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -56,0 +58,1 @@\n+class   TypeInlineType;\n@@ -103,0 +106,1 @@\n+    InlineType,                 \/\/ Inline type\n@@ -136,0 +140,24 @@\n+  class Offset {\n+  private:\n+    int _offset;\n+\n+  public:\n+    explicit Offset(int offset) : _offset(offset) {}\n+\n+    const Offset meet(const Offset other) const;\n+    const Offset dual() const;\n+    const Offset add(intptr_t offset) const;\n+    bool operator==(const Offset& other) const {\n+      return _offset == other._offset;\n+    }\n+    bool operator!=(const Offset& other) const {\n+      return _offset != other._offset;\n+    }\n+    int get() const { return _offset; }\n+\n+    void dump2(outputStream *st) const;\n+\n+    static const Offset top;\n+    static const Offset bottom;\n+  };\n+\n@@ -283,3 +311,0 @@\n-  bool is_ptr_to_boxing_obj() const;\n-\n-\n@@ -323,0 +348,2 @@\n+  const TypeInlineType* isa_inlinetype() const;  \/\/ Returns NULL if not Inline Type\n+  const TypeInlineType* is_inlinetype() const;   \/\/ Inline Type\n@@ -336,0 +363,3 @@\n+  bool is_inlinetypeptr() const;\n+  virtual ciInlineKlass* inline_klass() const;\n+\n@@ -728,2 +758,2 @@\n-  static const TypeTuple *make_range(ciSignature *sig);\n-  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);\n+  static const TypeTuple *make_range(ciSignature* sig, bool ret_vt_fields = false);\n+  static const TypeTuple *make_domain(ciMethod* method, bool vt_fields_as_args = false);\n@@ -758,2 +788,2 @@\n-  TypeAry(const Type* elem, const TypeInt* size, bool stable) : Type(Array),\n-      _elem(elem), _size(size), _stable(stable) {}\n+  TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),\n+      _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}\n@@ -770,0 +800,5 @@\n+\n+  \/\/ Inline type array properties\n+  const bool _not_flat;         \/\/ Array is never flattened\n+  const bool _not_null_free;    \/\/ Array is never null-free\n+\n@@ -773,1 +808,2 @@\n-  static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false);\n+  static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,\n+                             bool not_flat = false, bool not_null_free = false);\n@@ -780,0 +816,1 @@\n+\n@@ -789,0 +826,39 @@\n+\n+\/\/------------------------------TypeValue---------------------------------------\n+\/\/ Class of Inline Type Types\n+class TypeInlineType : public Type {\n+private:\n+  ciInlineKlass* _vk;\n+  bool _larval;\n+\n+protected:\n+  TypeInlineType(ciInlineKlass* vk, bool larval)\n+    : Type(InlineType),\n+      _vk(vk), _larval(larval) {\n+  }\n+\n+public:\n+  static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);\n+  virtual ciInlineKlass* inline_klass() const { return _vk; }\n+  bool larval() const { return _larval; }\n+\n+  virtual bool eq(const Type* t) const;\n+  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n+  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n+\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n+\n+  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }\n+  virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }\n+\n+  virtual bool maybe_null() const { return false; }\n+\n+  static const TypeInlineType* BOTTOM;\n+\n+#ifndef PRODUCT\n+  virtual void dump2(Dict &d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n+#endif\n+};\n+\n@@ -892,1 +968,1 @@\n-  TypePtr(TYPES t, PTR ptr, int offset,\n+  TypePtr(TYPES t, PTR ptr, Offset offset,\n@@ -949,3 +1025,7 @@\n-               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n-  static MeetResult\n-  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n+               PTR tinst_ptr, bool this_flatten_array, bool tinst_flatten_array, ciKlass*&res_klass, bool &res_xk,\n+               bool& res_flatten_array);\n+\n+  static MeetResult meet_aryptr(PTR &ptr, const Type* this_elem, const Type* tap_elem, ciKlass* this_klass, ciKlass* tap_klass,\n+                                bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, bool this_not_flat, bool tap_not_flat,\n+                                bool this_not_null_free, bool tap_not_null_free, const Type*& res_elem, ciKlass*&res_klass,\n+                                bool &res_xk, bool &res_not_flat, bool &res_not_null_free);\n@@ -954,1 +1034,1 @@\n-  const int _offset;            \/\/ Offset into oop, with TOP & BOT\n+  const Offset _offset;         \/\/ Offset into oop, with TOP & BOT\n@@ -957,1 +1037,1 @@\n-  const int offset() const { return _offset; }\n+  const int offset() const { return _offset.get(); }\n@@ -960,1 +1040,1 @@\n-  static const TypePtr *make(TYPES t, PTR ptr, int offset,\n+  static const TypePtr* make(TYPES t, PTR ptr, Offset offset,\n@@ -969,1 +1049,1 @@\n-  int xadd_offset( intptr_t offset ) const;\n+  Type::Offset xadd_offset(intptr_t offset) const;\n@@ -972,0 +1052,1 @@\n+  virtual const int flattened_offset() const { return offset(); }\n@@ -979,2 +1060,2 @@\n-  int meet_offset( int offset ) const;\n-  int dual_offset( ) const;\n+  Offset meet_offset(int offset) const;\n+  Offset dual_offset() const;\n@@ -1008,0 +1089,8 @@\n+  virtual bool can_be_inline_type() const { return false; }\n+  virtual bool flatten_array()      const { return false; }\n+  virtual bool not_flatten_array()  const { return false; }\n+  virtual bool is_flat()            const { return false; }\n+  virtual bool is_not_flat()        const { return false; }\n+  virtual bool is_null_free()       const { return false; }\n+  virtual bool is_not_null_free()   const { return false; }\n+\n@@ -1025,1 +1114,1 @@\n-  TypeRawPtr( PTR ptr, address bits ) : TypePtr(RawPtr,ptr,0), _bits(bits){}\n+  TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}\n@@ -1061,2 +1150,2 @@\n-  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n-             const TypePtr* speculative, int inline_depth);\n+  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,\n+             int instance_id, const TypePtr* speculative, int inline_depth);\n@@ -1097,1 +1186,0 @@\n-  virtual ciKlass* klass() const { return _klass;     }\n@@ -1100,0 +1188,2 @@\n+  \/\/ TODO Tobias\n+  virtual ciKlass* klass() const { return _klass; }\n@@ -1136,1 +1226,1 @@\n-  static const TypeOopPtr* make(PTR ptr, int offset, int instance_id,\n+  static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,\n@@ -1155,1 +1245,3 @@\n-  bool is_known_instance_field() const { return is_known_instance() && _offset >= 0; }\n+  bool is_known_instance_field() const { return is_known_instance() && _offset.get() >= 0; }\n+\n+  virtual bool can_be_inline_type() const { return (_klass == NULL || _klass->can_be_inline_klass(_klass_is_exact)); }\n@@ -1194,2 +1286,3 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n-              const TypePtr* speculative, int inline_depth);\n+  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,\n+              bool flatten_array, int instance_id, const TypePtr* speculative,\n+              int inline_depth);\n@@ -1199,0 +1292,1 @@\n+  bool _flatten_array;     \/\/ Type is flat in arrays\n@@ -1217,1 +1311,1 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, 0, InstanceBot);\n+    return make(TypePtr::Constant, o->klass(), true, o, Offset(0));\n@@ -1220,2 +1314,2 @@\n-  static const TypeInstPtr *make(ciObject* o, int offset) {\n-    return make(TypePtr::Constant, o->klass(), true, o, offset, InstanceBot);\n+  static const TypeInstPtr* make(ciObject* o, Offset offset) {\n+    return make(TypePtr::Constant, o->klass(), true, o, offset);\n@@ -1226,1 +1320,1 @@\n-    return make(ptr, klass, false, NULL, 0, InstanceBot);\n+    return make(ptr, klass, false, NULL, Offset(0));\n@@ -1231,1 +1325,1 @@\n-    return make(ptr, klass, true, NULL, 0, InstanceBot);\n+    return make(ptr, klass, true, NULL, Offset(0));\n@@ -1235,2 +1329,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, int offset) {\n-    return make(ptr, klass, false, NULL, offset, InstanceBot);\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {\n+    return make(ptr, klass, false, NULL, offset);\n@@ -1240,1 +1334,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+  static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,\n+                                 bool flatten_array = false,\n@@ -1251,1 +1346,1 @@\n-  ciType* java_mirror_type() const;\n+  ciType* java_mirror_type(bool* is_val_mirror = NULL) const;\n@@ -1267,0 +1362,4 @@\n+  virtual const TypeInstPtr* cast_to_flatten_array() const;\n+  virtual bool flatten_array() const { return _flatten_array; }\n+  virtual bool not_flatten_array() const { return !can_be_inline_type() || (_klass->is_inlinetype() && !flatten_array()); }\n+\n@@ -1290,4 +1389,4 @@\n-  TypeAryPtr( PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,\n-              int offset, int instance_id, bool is_autobox_cache,\n-              const TypePtr* speculative, int inline_depth)\n-    : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),\n+  TypeAryPtr(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,\n+             Offset offset, Offset field_offset, int instance_id, bool is_autobox_cache,\n+             const TypePtr* speculative, int inline_depth)\n+    : TypeOopPtr(AryPtr, ptr, k, xk, o, offset, field_offset, instance_id, speculative, inline_depth),\n@@ -1295,1 +1394,2 @@\n-    _is_autobox_cache(is_autobox_cache)\n+    _is_autobox_cache(is_autobox_cache),\n+    _field_offset(field_offset)\n@@ -1318,0 +1418,6 @@\n+  \/\/ For flattened inline type arrays, each field of the inline type in\n+  \/\/ the array has its own memory slice so we need to keep track of\n+  \/\/ which field is accessed\n+  const Offset _field_offset;\n+  Offset meet_field_offset(const Type::Offset offset) const;\n+  Offset dual_field_offset() const;\n@@ -1322,0 +1428,2 @@\n+public:\n+  \/\/ TODO Tobias\n@@ -1324,1 +1432,0 @@\n-public:\n@@ -1341,0 +1448,6 @@\n+  \/\/ Inline type array properties\n+  bool is_flat()          const { return _ary->_elem->isa_inlinetype() != NULL; }\n+  bool is_not_flat()      const { return _ary->_not_flat; }\n+  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr() && !_ary->_elem->make_ptr()->maybe_null()); }\n+  bool is_not_null_free() const { return _ary->_not_null_free; }\n+\n@@ -1343,1 +1456,2 @@\n-  static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,\n+  static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,\n+                                Offset field_offset = Offset::bottom,\n@@ -1348,1 +1462,2 @@\n-  static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,\n+  static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,\n+                                Offset field_offset = Offset::bottom,\n@@ -1351,1 +1466,2 @@\n-                                int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);\n+                                int inline_depth = InlineDepthBottom,\n+                                bool is_autobox_cache = false);\n@@ -1370,0 +1486,1 @@\n+  virtual const Type* cleanup_speculative() const;\n@@ -1377,0 +1494,5 @@\n+  \/\/ Inline type array properties\n+  const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;\n+  const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;\n+  const TypeAryPtr* update_properties(const TypeAryPtr* new_type) const;\n+\n@@ -1382,1 +1504,8 @@\n-  static jint max_array_length(BasicType etype) ;\n+  static jint max_array_length(BasicType etype);\n+\n+  const int flattened_offset() const;\n+  const Offset field_offset() const { return _field_offset; }\n+  const TypeAryPtr* with_field_offset(int offset) const;\n+  const TypePtr* add_field_offset_and_offset(intptr_t offset) const;\n+\n+  virtual bool can_be_inline_type() const { return false; }\n@@ -1396,0 +1525,1 @@\n+  static const TypeAryPtr *INLINES;\n@@ -1416,1 +1546,1 @@\n-  TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset);\n+  TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset);\n@@ -1428,1 +1558,1 @@\n-  static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, int offset);\n+  static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, Offset offset);\n@@ -1458,1 +1588,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, Offset offset);\n@@ -1473,0 +1603,2 @@\n+public:\n+  \/\/ TODO Tobias\n@@ -1475,1 +1607,0 @@\n-public:\n@@ -1493,1 +1624,1 @@\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n+  static const TypeKlassPtr* make(PTR ptr, ciKlass* klass, Offset offset);\n@@ -1511,4 +1642,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n-#endif\n@@ -1520,2 +1647,2 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset), _flatten_array(flatten_array) {\n@@ -1526,0 +1653,2 @@\n+  const bool _flatten_array; \/\/ Type is flat in arrays\n+\n@@ -1539,0 +1668,2 @@\n+  virtual bool can_be_inline_type() const { return (_klass == NULL || _klass->can_be_inline_klass(klass_is_exact())); }\n+\n@@ -1540,1 +1671,1 @@\n-    return make(TypePtr::Constant, k, 0);\n+    return make(TypePtr::Constant, k, Offset(0), false);\n@@ -1542,1 +1673,1 @@\n-  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array = false);\n@@ -1560,0 +1691,3 @@\n+  virtual bool flatten_array() const { return _flatten_array; }\n+  virtual bool not_flatten_array() const { return !_klass->can_be_inline_klass() || (_klass->is_inlinetype() && !flatten_array()); }\n+\n@@ -1563,0 +1697,4 @@\n+\n+#ifndef PRODUCT\n+  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n+#endif\n@@ -1569,0 +1707,3 @@\n+  const bool _not_flat;      \/\/ Array is never flattened\n+  const bool _not_null_free; \/\/ Array is never null-free\n+  const bool _null_free;\n@@ -1570,2 +1711,2 @@\n-  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, int offset)\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n+  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool null_free)\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _null_free(null_free) {\n@@ -1579,0 +1720,8 @@\n+  bool dual_null_free() const {\n+    return _null_free;\n+  }\n+\n+  bool meet_null_free(bool other) const {\n+    return _null_free && other;\n+  }\n+\n@@ -1584,1 +1733,1 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n@@ -1592,1 +1741,2 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset);\n@@ -1617,0 +1767,5 @@\n+  bool is_flat()          const { return klass() != NULL && klass()->is_flat_array_klass(); }\n+  bool is_not_flat()      const { return _not_flat; }\n+  bool is_null_free()     const { return _null_free; }\n+  bool is_not_null_free() const { return _not_null_free; }\n+\n@@ -1750,1 +1905,2 @@\n-  TypeFunc( const TypeTuple *domain, const TypeTuple *range ) : Type(Function),  _domain(domain), _range(range) {}\n+  TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)\n+    : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}\n@@ -1756,2 +1912,13 @@\n-  const TypeTuple* const _domain;     \/\/ Domain of inputs\n-  const TypeTuple* const _range;      \/\/ Range of results\n+  \/\/ Domains of inputs: inline type arguments are not passed by\n+  \/\/ reference, instead each field of the inline type is passed as an\n+  \/\/ argument. We maintain 2 views of the argument list here: one\n+  \/\/ based on the signature (with an inline type argument as a single\n+  \/\/ slot), one based on the actual calling convention (with a value\n+  \/\/ type argument as a list of its fields).\n+  const TypeTuple* const _domain_sig;\n+  const TypeTuple* const _domain_cc;\n+  \/\/ Range of results. Similar to domains: an inline type result can be\n+  \/\/ returned in registers in which case range_cc lists all fields and\n+  \/\/ is the actual calling convention.\n+  const TypeTuple* const _range_sig;\n+  const TypeTuple* const _range_cc;\n@@ -1771,5 +1938,8 @@\n-  const TypeTuple* domain() const { return _domain; }\n-  const TypeTuple* range()  const { return _range; }\n-\n-  static const TypeFunc *make(ciMethod* method);\n-  static const TypeFunc *make(ciSignature signature, const Type* extra);\n+  const TypeTuple* domain_sig() const { return _domain_sig; }\n+  const TypeTuple* domain_cc()  const { return _domain_cc; }\n+  const TypeTuple* range_sig()  const { return _range_sig; }\n+  const TypeTuple* range_cc()   const { return _range_cc; }\n+\n+  static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);\n+  static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,\n+                              const TypeTuple* range_sig, const TypeTuple* range_cc);\n@@ -1783,0 +1953,2 @@\n+  bool returns_inline_type_as_fields() const { return range_sig() != range_cc(); }\n+\n@@ -1954,0 +2126,9 @@\n+inline const TypeInlineType* Type::isa_inlinetype() const {\n+  return (_base == InlineType) ? (TypeInlineType*)this : NULL;\n+}\n+\n+inline const TypeInlineType* Type::is_inlinetype() const {\n+  assert(_base == InlineType, \"Not an inline type\");\n+  return (TypeInlineType*)this;\n+}\n+\n@@ -2038,4 +2219,7 @@\n-inline bool Type::is_ptr_to_boxing_obj() const {\n-  const TypeInstPtr* tp = isa_instptr();\n-  return (tp != NULL) && (tp->offset() == 0) &&\n-         tp->instance_klass()->is_box_klass();\n+inline bool Type::is_inlinetypeptr() const {\n+  return isa_instptr() != NULL && is_instptr()->instance_klass()->is_inlinetype();\n+}\n+\n+inline ciInlineKlass* Type::inline_klass() const {\n+  assert(is_inlinetypeptr(), \"must be an inline type ptr\");\n+  return is_instptr()->instance_klass()->as_inline_klass();\n@@ -2070,0 +2254,1 @@\n+#define CmpUXNode    CmpULNode\n@@ -2088,0 +2273,1 @@\n+#define Op_StoreX    Op_StoreL\n@@ -2116,0 +2302,1 @@\n+#define CmpUXNode    CmpUNode\n@@ -2134,0 +2321,1 @@\n+#define Op_StoreX    Op_StoreI\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":262,"deletions":74,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-      for (uint i = TypeFunc::Parms; i < call->tf()->domain()->cnt(); i++) {\n+      for (uint i = TypeFunc::Parms; i < call->tf()->domain_sig()->cnt(); i++) {\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#ifdef JDK_8254007_IS_FIXED\n@@ -78,0 +79,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jni.h\"\n@@ -59,0 +60,2 @@\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -427,0 +430,1 @@\n+  bool is_inlined = InstanceKlass::cast(k1)->field_is_inlined(slot);\n@@ -428,1 +432,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_inlined);\n@@ -445,1 +449,1 @@\n-  if (m->is_initializer()) {\n+  if (m->is_object_constructor() || m->is_static_init_factory()) {\n@@ -501,3 +505,12 @@\n-  jboolean ret = sub_klass->is_subtype_of(super_klass) ?\n-                   JNI_TRUE : JNI_FALSE;\n-\n+  jboolean ret;\n+  if (sub_klass == super_klass && sub_klass->is_inline_klass()) {\n+    \/\/ val type is a subtype of ref type\n+    InlineKlass* ik = InlineKlass::cast(sub_klass);\n+    if (sub_mirror == super_mirror || (ik->val_mirror() == sub_mirror && ik->ref_mirror() == super_mirror)) {\n+      ret = JNI_TRUE;\n+    } else {\n+      ret = JNI_FALSE;\n+    }\n+  } else {\n+    ret = sub_klass->is_subtype_of(super_klass) ? JNI_TRUE : JNI_FALSE;\n+  }\n@@ -807,1 +820,2 @@\n-    case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT: push_object(va_arg(_ap, jobject)); break;\n@@ -847,1 +861,2 @@\n-    case T_OBJECT:      push_object((_ap++)->l); break;\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT: push_object((_ap++)->l); break;\n@@ -983,5 +998,19 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n-  obj = JNIHandles::make_local(THREAD, i);\n-  JavaValue jvalue(T_VOID);\n-  JNI_ArgumentPusherArray ap(methodID, args);\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == NULL) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+  }\n+\n+  if (!k->is_inline_klass()) {\n+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+    obj = JNIHandles::make_local(THREAD, i);\n+    JavaValue jvalue(T_VOID);\n+    JNI_ArgumentPusherArray ap(methodID, args);\n+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  } else {\n+    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n+    JNI_ArgumentPusherArray ap(methodID, args);\n+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    obj = jvalue.get_jobject();\n+  }\n@@ -989,1 +1018,1 @@\n-JNI_END\n+  JNI_END\n@@ -1001,5 +1030,19 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n-  obj = JNIHandles::make_local(THREAD, i);\n-  JavaValue jvalue(T_VOID);\n-  JNI_ArgumentPusherVaArg ap(methodID, args);\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == NULL) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+  }\n+\n+  if (!k->is_inline_klass()) {\n+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+    obj = JNIHandles::make_local(THREAD, i);\n+    JavaValue jvalue(T_VOID);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  } else {\n+    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    obj = jvalue.get_jobject();\n+  }\n@@ -1019,8 +1062,25 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n-  obj = JNIHandles::make_local(THREAD, i);\n-  va_list args;\n-  va_start(args, methodID);\n-  JavaValue jvalue(T_VOID);\n-  JNI_ArgumentPusherVaArg ap(methodID, args);\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n-  va_end(args);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == NULL) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+  }\n+\n+  if (!k->is_inline_klass()) {\n+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+    obj = JNIHandles::make_local(THREAD, i);\n+    va_list args;\n+    va_start(args, methodID);\n+    JavaValue jvalue(T_VOID);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+    va_end(args);\n+  } else {\n+    va_list args;\n+    va_start(args, methodID);\n+    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    va_end(args);\n+    obj = jvalue.get_jobject();\n+  }\n@@ -1777,1 +1837,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_inlined());\n@@ -1787,0 +1847,1 @@\n+  oop res = NULL;\n@@ -1792,2 +1853,12 @@\n-  oop loaded_obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);\n-  jobject ret = JNIHandles::make_local(THREAD, loaded_obj);\n+  if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {\n+    res = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);\n+  } else {\n+    assert(k->is_instance_klass(), \"Only instance can have inlined fields\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    fieldDescriptor fd;\n+    ik->find_field_from_offset(offset, false, &fd);  \/\/ performance bottleneck\n+    InstanceKlass* holder = fd.field_holder();\n+    InlineKlass* field_vklass = InlineKlass::cast(holder->get_inline_type_field_klass(fd.index()));\n+    res = field_vklass->read_inlined_field(o, ik->field_offset(fd.index()), CHECK_NULL);\n+  }\n+  jobject ret = JNIHandles::make_local(THREAD, res);\n@@ -1885,1 +1956,12 @@\n-  HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));\n+  if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {\n+    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));\n+  } else {\n+    assert(k->is_instance_klass(), \"Only instances can have inlined fields\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    fieldDescriptor fd;\n+    ik->find_field_from_offset(offset, false, &fd);\n+    InstanceKlass* holder = fd.field_holder();\n+    InlineKlass* vklass = InlineKlass::cast(holder->get_inline_type_field_klass(fd.index()));\n+    oop v = JNIHandles::resolve_non_null(value);\n+    vklass->write_inlined_field(o, offset, v, CHECK);\n+  }\n@@ -2302,4 +2384,13 @@\n-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-  if (a->is_within_bounds(index)) {\n-    ret = JNIHandles::make_local(THREAD, a->obj_at(index));\n-    return ret;\n+  oop res = NULL;\n+  arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));\n+  if (arr->is_within_bounds(index)) {\n+    if (arr->is_flatArray()) {\n+      flatArrayOop a = flatArrayOop(JNIHandles::resolve_non_null(array));\n+      flatArrayHandle vah(thread, a);\n+      res = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);\n+      assert(res != NULL, \"Must be set in one of two paths above\");\n+    } else {\n+      assert(arr->is_objArray(), \"If not a valueArray. must be an objArray\");\n+      objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+      res = a->obj_at(index);\n+    }\n@@ -2309,1 +2400,1 @@\n-    ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n+    ss.print(\"Index %d out of bounds for length %d\", index,arr->length());\n@@ -2312,0 +2403,2 @@\n+  ret = JNIHandles::make_local(THREAD, res);\n+  return ret;\n@@ -2321,24 +2414,51 @@\n-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-  oop v = JNIHandles::resolve(value);\n-  if (a->is_within_bounds(index)) {\n-    if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n-      a->obj_at_put(index, v);\n-    } else {\n-      ResourceMark rm(THREAD);\n-      stringStream ss;\n-      Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();\n-      ss.print(\"type mismatch: can not store %s to %s[%d]\",\n-               v->klass()->external_name(),\n-               bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),\n-               index);\n-      for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n-        ss.print(\"[]\");\n-      }\n-      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n-    }\n-  } else {\n-    ResourceMark rm(THREAD);\n-    stringStream ss;\n-    ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n-    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n-  }\n+   bool oob = false;\n+   int length = -1;\n+   oop res = NULL;\n+   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));\n+   if (arr->is_within_bounds(index)) {\n+     if (arr->is_flatArray()) {\n+       flatArrayOop a = flatArrayOop(JNIHandles::resolve_non_null(array));\n+       oop v = JNIHandles::resolve(value);\n+       FlatArrayKlass* vaklass = FlatArrayKlass::cast(a->klass());\n+       InlineKlass* element_vklass = vaklass->element_klass();\n+       if (v != NULL && v->is_a(element_vklass)) {\n+         a->value_copy_to_index(v, index);\n+       } else {\n+         ResourceMark rm(THREAD);\n+         stringStream ss;\n+         Klass *kl = FlatArrayKlass::cast(a->klass());\n+         ss.print(\"type mismatch: can not store %s to %s[%d]\",\n+             v->klass()->external_name(),\n+             kl->external_name(),\n+             index);\n+         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n+           ss.print(\"[]\");\n+         }\n+         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+       }\n+     } else {\n+       assert(arr->is_objArray(), \"If not a valueArray. must be an objArray\");\n+       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+       oop v = JNIHandles::resolve(value);\n+       if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n+         a->obj_at_put(index, v);\n+       } else {\n+         ResourceMark rm(THREAD);\n+         stringStream ss;\n+         Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();\n+         ss.print(\"type mismatch: can not store %s to %s[%d]\",\n+             v->klass()->external_name(),\n+             bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),\n+                 index);\n+         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n+           ss.print(\"[]\");\n+         }\n+         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+       }\n+     }\n+   } else {\n+     ResourceMark rm(THREAD);\n+     stringStream ss;\n+     ss.print(\"Index %d out of bounds for length %d\", index, arr->length());\n+     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n+   }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":179,"deletions":59,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -284,1 +284,2 @@\n-      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT)) {\n+      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT) &&\n+      !(fd.field_type() == T_PRIMITIVE_OBJECT && ftype == T_OBJECT)) {\n@@ -321,1 +322,2 @@\n-      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT)) {\n+      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT) &&\n+      !(fd.field_type() == T_PRIMITIVE_OBJECT && ftype == T_OBJECT)) {\n@@ -372,1 +374,1 @@\n-check_is_obj_array(JavaThread* thr, jarray jArray) {\n+check_is_obj_or_inline_array(JavaThread* thr, jarray jArray) {\n@@ -374,1 +376,1 @@\n-  if (!aOop->is_objArray()) {\n+  if (!aOop->is_objArray() && !aOop->is_flatArray()) {\n@@ -494,1 +496,1 @@\n-      name[0] == JVM_SIGNATURE_CLASS &&            \/\/ 'L'\n+      (name[0] == JVM_SIGNATURE_CLASS || name[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) && \/\/ 'L' or 'Q'\n@@ -1643,1 +1645,1 @@\n-      check_is_obj_array(thr, array);\n+      check_is_obj_or_inline_array(thr, array);\n@@ -1657,1 +1659,1 @@\n-      check_is_obj_array(thr, array);\n+      check_is_obj_or_inline_array(thr, array);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -616,1 +617,22 @@\n-  return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;\n+  if (handle == NULL) {\n+    return 0;\n+  }\n+  oop obj = JNIHandles::resolve_non_null(handle);\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+      JavaValue result(T_INT);\n+      JavaCallArguments args;\n+      Handle ho(THREAD, obj);\n+      args.push_oop(ho);\n+      methodHandle method(THREAD, Universe::primitive_type_hash_code_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in hashCode\", e, false);\n+        }\n+      }\n+      return result.get_jint();\n+  } else {\n+    return ObjectSynchronizer::FastHashCode(THREAD, obj);\n+  }\n@@ -668,0 +690,1 @@\n+       klass->is_inline_klass() ||\n@@ -1181,1 +1204,2 @@\n-    size = InstanceKlass::cast(klass)->local_interfaces()->length();\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    size = ik->local_interfaces()->length();\n@@ -1183,1 +1207,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n@@ -1194,1 +1218,2 @@\n-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n+      InstanceKlass* ik = InstanceKlass::cast(klass);\n+      Klass* k = ik->local_interfaces()->at(index);\n@@ -1796,0 +1821,2 @@\n+  bool is_ctor = (method->is_object_constructor() ||\n+                  method->is_static_init_factory());\n@@ -1797,1 +1824,1 @@\n-    return (method->is_initializer() && !method->is_static());\n+    return is_ctor;\n@@ -1799,1 +1826,3 @@\n-    return  (!method->is_initializer() && !method->is_overpass());\n+    return (!is_ctor &&\n+            !method->is_class_initializer() &&\n+            !method->is_overpass());\n@@ -1862,0 +1891,2 @@\n+        assert(method->is_object_constructor() ||\n+               method->is_static_init_factory(), \"must be\");\n@@ -2144,3 +2175,1 @@\n-  if (!m->is_initializer() || m->is_static()) {\n-    method = Reflection::new_method(m, true, CHECK_NULL);\n-  } else {\n+  if (m->is_object_constructor() || m->is_static_init_factory()) {\n@@ -2148,0 +2177,2 @@\n+  } else {\n+    method = Reflection::new_method(m, true, CHECK_NULL);\n@@ -2418,0 +2449,37 @@\n+\/\/ Arrays support \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == NULL) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  return ArrayKlass::cast(k)->element_access_is_atomic();\n+JVM_END\n+\n+JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == NULL) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vk = FlatArrayKlass::cast(k);\n+    if (!vk->element_access_is_atomic()) {\n+      \/**\n+       * Need to decide how to implement:\n+       *\n+       * 1) Change to objArrayOop layout, therefore oop->klass() differs so\n+       * then \"<atomic>[Qfoo;\" klass needs to subclass \"[Qfoo;\" to pass through\n+       * \"checkcast\" & \"instanceof\"\n+       *\n+       * 2) Use extra header in the flatArrayOop to flag atomicity required and\n+       * possibly per instance lock structure. Said info, could be placed in\n+       * \"trailer\" rather than disturb the current arrayOop\n+       *\/\n+      Unimplemented();\n+    }\n+  }\n+  return array;\n+JVM_END\n+\n@@ -2580,1 +2648,1 @@\n-  return method->name() == vmSymbols::object_initializer_name();\n+  return method->is_object_constructor();\n@@ -3571,1 +3639,1 @@\n-    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n+    objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3591,0 +3659,1 @@\n+  objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3592,1 +3661,0 @@\n-  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":80,"deletions":12,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -916,2 +917,1 @@\n-  write_u2(ik()->access_flags().get_flags() & JVM_RECOGNIZED_CLASS_MODIFIERS);\n-\n+  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY));\n@@ -930,0 +930,1 @@\n+\n@@ -1028,0 +1029,1 @@\n+      case Bytecodes::_withfield       :  \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2882,3 +2882,3 @@\n-    if (k->is_super()) {\n-      result |= JVM_ACC_SUPER;\n-    }\n+    \/\/ if (k->is_super()) {\n+    \/\/   result |= JVM_ACC_SUPER;\n+    \/\/ }\n@@ -3022,1 +3022,2 @@\n-                                            src_st.access_flags().is_static());\n+                                            src_st.access_flags().is_static(),\n+                                            src_st.field_descriptor().is_inlined());\n@@ -3059,2 +3060,3 @@\n-    Array<InstanceKlass*>* interface_list = InstanceKlass::cast(k)->local_interfaces();\n-    const int result_length = (interface_list == NULL ? 0 : interface_list->length());\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    Array<InstanceKlass*>* interface_list = ik->local_interfaces();\n+    int result_length = (interface_list == NULL ? 0 : interface_list->length());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2295,1 +2295,1 @@\n-  if (sig_type == JVM_SIGNATURE_CLASS) {\n+  if (sig_type == JVM_SIGNATURE_CLASS || sig_type == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include <oops\/inlineKlass.hpp>\n@@ -81,0 +82,1 @@\n+      \/\/ CMH flat arrays (InlineKlass)\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,2 @@\n-  if (ty_sign[0] == JVM_SIGNATURE_CLASS &&\n+  if ((ty_sign[0] == JVM_SIGNATURE_CLASS ||\n+       ty_sign[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) &&\n@@ -536,0 +537,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -683,1 +685,1 @@\n-      if (_type == T_OBJECT) {\n+      if (_type == T_OBJECT || _type == T_PRIMITIVE_OBJECT) {\n@@ -701,1 +703,2 @@\n-      case T_OBJECT: {\n+      case T_OBJECT:\n+      case T_PRIMITIVE_OBJECT: {\n@@ -722,1 +725,2 @@\n-        case T_OBJECT: {\n+        case T_OBJECT:\n+        case T_PRIMITIVE_OBJECT: {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -607,2 +607,1 @@\n-    \/\/ At this stage JVM_CONSTANT_UnresolvedClassInError should not be\n-    \/\/ here\n+    \/\/ At this stage JVM_CONSTANT_UnresolvedClassInError should not be here\n@@ -918,0 +917,12 @@\n+static jvmtiError check_preload_attribute(InstanceKlass* the_class,\n+                                          InstanceKlass* scratch_class) {\n+  Thread* thread = Thread::current();\n+  ResourceMark rm(thread);\n+\n+  \/\/ Check whether the class Preload attribute has been changed.\n+  return check_attribute_arrays(\"Preload\",\n+                                the_class, scratch_class,\n+                                the_class->preload_classes(),\n+                                scratch_class->preload_classes());\n+}\n+\n@@ -997,0 +1008,6 @@\n+  \/\/ Check whether the Preload attribute has been changed.\n+  err = check_preload_attribute(the_class, scratch_class);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n@@ -1966,0 +1983,6 @@\n+  \/\/ rewrite constant pool references in the Preload attribute:\n+  if (!rewrite_cp_refs_in_preload_attribute(scratch_class)) {\n+    \/\/ propagate failure back to caller\n+    return false;\n+  }\n+\n@@ -2114,0 +2137,13 @@\n+\/\/ Rewrite constant pool references in the Preload attribute.\n+bool VM_RedefineClasses::rewrite_cp_refs_in_preload_attribute(\n+       InstanceKlass* scratch_class) {\n+\n+  Array<u2>* preload_classes = scratch_class->preload_classes();\n+  assert(preload_classes != NULL, \"unexpected null preload_classes\");\n+  for (int i = 0; i < preload_classes->length(); i++) {\n+    u2 cp_index = preload_classes->at(i);\n+    preload_classes->at_put(i, find_new_index(cp_index));\n+  }\n+  return true;\n+}\n+\n@@ -2246,0 +2282,2 @@\n+      case Bytecodes::_aconst_init   : \/\/ fall through\n+      case Bytecodes::_withfield      : \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -476,0 +476,1 @@\n+  bool rewrite_cp_refs_in_preload_attribute(InstanceKlass* scratch_class);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -39,0 +41,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -46,0 +51,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -152,1 +158,0 @@\n-\n@@ -228,0 +233,1 @@\n+    assert(_obj == NULL || !_obj->is_inline_type() || _obj->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n@@ -231,1 +237,0 @@\n-\n@@ -244,0 +249,62 @@\n+#ifdef ASSERT\n+\/*\n+ * Get the field descriptor of the field of the given object at the given offset.\n+ *\/\n+static bool get_field_descriptor(oop p, jlong offset, fieldDescriptor* fd) {\n+  bool found = false;\n+  Klass* k = p->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    found = ik->find_field_from_offset((int)offset, false, fd);\n+    if (!found && ik->is_mirror_instance_klass()) {\n+      Klass* k2 = java_lang_Class::as_Klass(p);\n+      if (k2->is_instance_klass()) {\n+        ik = InstanceKlass::cast(k2);\n+        found = ik->find_field_from_offset((int)offset, true, fd);\n+      }\n+    }\n+  }\n+  return found;\n+}\n+#endif \/\/ ASSERT\n+\n+static void assert_and_log_unsafe_value_access(oop p, jlong offset, InlineKlass* vk) {\n+  Klass* k = p->klass();\n+#ifdef ASSERT\n+  if (k->is_instance_klass()) {\n+    assert_field_offset_sane(p, offset);\n+    fieldDescriptor fd;\n+    bool found = get_field_descriptor(p, offset, &fd);\n+    if (found) {\n+      assert(found, \"value field not found\");\n+      assert(fd.is_inlined(), \"field not flat\");\n+    } else {\n+      if (log_is_enabled(Trace, valuetypes)) {\n+        log_trace(valuetypes)(\"not a field in %s at offset \" UINT64_FORMAT_X,\n+                              p->klass()->external_name(), (uint64_t)offset);\n+      }\n+    }\n+  } else if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+    int index = (offset - vak->array_header_in_bytes()) \/ vak->element_byte_size();\n+    address dest = (address)((flatArrayOop)p)->value_at_addr(index, vak->layout_helper());\n+    assert(dest == (cast_from_oop<address>(p) + offset), \"invalid offset\");\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+#endif \/\/ ASSERT\n+  if (log_is_enabled(Trace, valuetypes)) {\n+    if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      int index = (offset - vak->array_header_in_bytes()) \/ vak->element_byte_size();\n+      address dest = (address)((flatArrayOop)p)->value_at_addr(index, vak->layout_helper());\n+      log_trace(valuetypes)(\"%s array type %s index %d element size %d offset \" UINT64_FORMAT_X \" at \" INTPTR_FORMAT,\n+                            p->klass()->external_name(), vak->external_name(),\n+                            index, vak->element_byte_size(), (uint64_t)offset, p2i(dest));\n+    } else {\n+      log_trace(valuetypes)(\"%s field type %s at offset \" UINT64_FORMAT_X,\n+                            p->klass()->external_name(), vk->external_name(), (uint64_t)offset);\n+    }\n+  }\n+}\n+\n@@ -258,0 +325,1 @@\n+  assert(!p->is_inline_type() || p->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n@@ -261,0 +329,65 @@\n+UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  return vk->first_field_offset();\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedField(JNIEnv *env, jobject unsafe, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->field_is_inlined(slot);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n+  return k->is_flatArray_klass();\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  oop v = vk->default_value();\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {\n+  oop base = JNIHandles::resolve(obj);\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  Handle base_h(THREAD, base);\n+  oop v = vk->read_inlined_field(base_h(), offset, CHECK_NULL);\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {\n+  oop base = JNIHandles::resolve(obj);\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  oop v = JNIHandles::resolve(value);\n+  vk->write_inlined_field(base, offset, v, CHECK);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n+  oop v = JNIHandles::resolve_non_null(value);\n+  assert(v->is_inline_type(), \"must be an inline type instance\");\n+  Handle vh(THREAD, v);\n+  InlineKlass* vk = InlineKlass::cast(v->klass());\n+  instanceOop new_value = vk->allocate_instance_buffer(CHECK_NULL);\n+  vk->inline_copy_oop_to_new_oop(vh(),  new_value);\n+  markWord mark = new_value->mark();\n+  new_value->set_mark(mark.enter_larval_state());\n+  return JNIHandles::make_local(THREAD, new_value);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n+  oop v = JNIHandles::resolve(value);\n+  assert(v->mark().is_larval_state(), \"must be a larval value\");\n+  markWord mark = v->mark();\n+  v->set_mark(mark.exit_larval_state());\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n@@ -593,0 +726,5 @@\n+  } else if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+    InlineKlass* vklass = vak->element_klass();\n+    base = vak->array_header_in_bytes();\n+    scale = vak->element_byte_size();\n@@ -628,0 +766,6 @@\n+UNSAFE_ENTRY(jlong, Unsafe_GetObjectSize0(JNIEnv* env, jobject o, jobject obj))\n+  oop p = JNIHandles::resolve(obj);\n+  return p->size() * HeapWordSize;\n+UNSAFE_END\n+\n+\n@@ -847,4 +991,4 @@\n-    {CC \"get\" #Type,      CC \"(\" OBJ \"J)\" #Desc,       FN_PTR(Unsafe_Get##Type)}, \\\n-    {CC \"put\" #Type,      CC \"(\" OBJ \"J\" #Desc \")V\",   FN_PTR(Unsafe_Put##Type)}, \\\n-    {CC \"get\" #Type \"Volatile\",      CC \"(\" OBJ \"J)\" #Desc,       FN_PTR(Unsafe_Get##Type##Volatile)}, \\\n-    {CC \"put\" #Type \"Volatile\",      CC \"(\" OBJ \"J\" #Desc \")V\",   FN_PTR(Unsafe_Put##Type##Volatile)}\n+    {CC \"get\"  #Type,      CC \"(\" OBJ \"J)\" #Desc,                 FN_PTR(Unsafe_Get##Type)}, \\\n+    {CC \"put\"  #Type,      CC \"(\" OBJ \"J\" #Desc \")V\",             FN_PTR(Unsafe_Put##Type)}, \\\n+    {CC \"get\"  #Type \"Volatile\",      CC \"(\" OBJ \"J)\" #Desc,      FN_PTR(Unsafe_Get##Type##Volatile)}, \\\n+    {CC \"put\"  #Type \"Volatile\",      CC \"(\" OBJ \"J\" #Desc \")V\",  FN_PTR(Unsafe_Put##Type##Volatile)}\n@@ -859,0 +1003,9 @@\n+    {CC \"isFlattenedArray\", CC \"(\" CLS \")Z\",                     FN_PTR(Unsafe_IsFlattenedArray)},\n+    {CC \"isFlattenedField0\", CC \"(\" OBJ \")Z\",                    FN_PTR(Unsafe_IsFlattenedField)},\n+    {CC \"getValue\",         CC \"(\" OBJ \"J\" CLS \")\" OBJ,          FN_PTR(Unsafe_GetValue)},\n+    {CC \"putValue\",         CC \"(\" OBJ \"J\" CLS OBJ \")V\",         FN_PTR(Unsafe_PutValue)},\n+    {CC \"uninitializedDefaultValue\", CC \"(\" CLS \")\" OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},\n+    {CC \"makePrivateBuffer\",     CC \"(\" OBJ \")\" OBJ,             FN_PTR(Unsafe_MakePrivateBuffer)},\n+    {CC \"finishPrivateBuffer\",   CC \"(\" OBJ \")\" OBJ,             FN_PTR(Unsafe_FinishPrivateBuffer)},\n+    {CC \"valueHeaderSize\",       CC \"(\" CLS \")J\",                FN_PTR(Unsafe_ValueHeaderSize)},\n+\n@@ -881,0 +1034,1 @@\n+    {CC \"getObjectSize0\",     CC \"(Ljava\/lang\/Object;)J\", FN_PTR(Unsafe_GetObjectSize0)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":160,"deletions":6,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -66,0 +68,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -1870,0 +1873,87 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return NULL;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return NULL;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+class CollectOops : public BasicOopIterateClosure {\n+ public:\n+  GrowableArray<Handle>* array;\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < array->length(); i++) {\n+      result_array->obj_at_put(i, array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    \/\/ Value might be oop, but JLS can't see as Object, just iterate through it...\n+    if (oh != NULL && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      array->append(oh);\n+    }\n+  }\n+\n+  void do_oop(oop* o) { add_oop(HeapAccess<>::oop_load(o)); }\n+  void do_oop(narrowOop* v) { add_oop(HeapAccess<>::oop_load(v)); }\n+};\n+\n+\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  GrowableArray<Handle>* array = new GrowableArray<Handle>(128);\n+  CollectOops collectOops;\n+  collectOops.array = array;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* array = new GrowableArray<Handle>(128);\n+  CollectOops collectOops;\n+  collectOops.array = array;\n+  StackFrameStream sfs(thread, false \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, NULL, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\n@@ -2697,0 +2787,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2066,0 +2066,10 @@\n+  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {\n+    FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);\n+    warning(\"InlineTypePassFieldsAsArgs is not supported on this platform\");\n+  }\n+\n+  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {\n+    FLAG_SET_CMDLINE(InlineTypeReturnedAsFields, false);\n+    warning(\"InlineTypeReturnedAsFields is not supported on this platform\");\n+  }\n+\n@@ -3023,0 +3033,18 @@\n+  if (EnableValhalla) {\n+    \/\/ create_property(\"valhalla.enableValhalla\", \"true\", InternalProperty)\n+    const char* prop_name = \"valhalla.enableValhalla\";\n+    const char* prop_value = \"true\";\n+    const size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;\n+    char* property = AllocateHeap(prop_len, mtArguments);\n+    int ret = jio_snprintf(property, prop_len, \"%s=%s\", prop_name, prop_value);\n+    if (ret < 0 || ret >= (int)prop_len) {\n+      FreeHeap(property);\n+      return JNI_ENOMEM;\n+    }\n+    bool added = add_property(property, UnwriteableProperty, InternalProperty);\n+    FreeHeap(property);\n+    if (!added) {\n+      return JNI_ENOMEM;\n+    }\n+  }\n+\n@@ -4167,0 +4195,7 @@\n+  if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive() && !UseSharedSpaces)) {\n+    \/\/ Disable calling convention optimizations if inline types are not supported.\n+    \/\/ Also these aren't useful in -Xint. However, don't disable them when dumping or using\n+    \/\/ the CDS archive, as the values must match between dumptime and runtime.\n+    InlineTypePassFieldsAsArgs = false;\n+    InlineTypeReturnedAsFields = false;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n@@ -55,0 +57,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -204,1 +207,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || k->is_inline_klass() || realloc_failures, \"reallocation was missed\");\n@@ -206,1 +209,5 @@\n-      st.print(\" allocation failed\");\n+      if (k->is_inline_klass()) {\n+        st.print(\" is null\");\n+      } else {\n+        st.print(\" allocation failed\");\n+      }\n@@ -240,2 +247,13 @@\n-  bool save_oop_result = chunk->at(0)->scope()->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n-  Handle return_value;\n+  ScopeDesc* scope = chunk->at(0)->scope();\n+  bool save_oop_result = scope->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n+  \/\/ In case of the return of multiple values, we must take care\n+  \/\/ of all oop return values.\n+  GrowableArray<Handle> return_oops;\n+  InlineKlass* vk = NULL;\n+  if (save_oop_result && scope->return_scalarized()) {\n+    vk = InlineKlass::returned_inline_klass(map);\n+    if (vk != NULL) {\n+      vk->save_oop_fields(map, return_oops);\n+      save_oop_result = false;\n+    }\n+  }\n@@ -247,1 +265,1 @@\n-    return_value = Handle(thread, result);\n+    return_oops.push(Handle(thread, result));\n@@ -254,1 +272,1 @@\n-  if (objects != NULL) {\n+  if (objects != NULL || vk != NULL) {\n@@ -259,1 +277,8 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+      if (vk != NULL) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, CHECK_AND_CLEAR_(true));\n+      }\n+      if (objects != NULL) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+        bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, CHECK_AND_CLEAR_(true));\n+      }\n@@ -264,1 +289,8 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+      if (vk != NULL) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, THREAD);\n+      }\n+      if (objects != NULL) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+        bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, THREAD);\n+      }\n@@ -267,2 +299,0 @@\n-    bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal);\n@@ -273,1 +303,1 @@\n-  if (save_oop_result) {\n+  if (save_oop_result || vk != NULL) {\n@@ -275,1 +305,2 @@\n-    deoptee.set_saved_oop_result(&map, return_value());\n+    assert(return_oops.length() == 1, \"no inline type\");\n+    deoptee.set_saved_oop_result(&map, return_oops.pop()());\n@@ -613,1 +644,1 @@\n-  \/\/ If the sender is deoptimized the we must retrieve the address of the handler\n+  \/\/ If the sender is deoptimized we must retrieve the address of the handler\n@@ -1098,2 +1129,12 @@\n-\n-    oop obj = NULL;\n+    \/\/ Check if the object may be null and has an additional is_init input that needs\n+    \/\/ to be checked before using the field values. Skip re-allocation if it is null.\n+    if (sv->maybe_null()) {\n+      assert(k->is_inline_klass(), \"must be an inline klass\");\n+      intptr_t init_value = StackValue::create_stack_value(fr, reg_map, sv->is_init())->get_int();\n+      jint is_init = (jint)*((jint*)&init_value);\n+      if (is_init == 0) {\n+        continue;\n+      }\n+    }\n+\n+    oop obj = NULL;\n@@ -1127,0 +1168,4 @@\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* ak = FlatArrayKlass::cast(k);\n+      \/\/ Inline type array must be zeroed because not all memory is reassigned\n+      obj = ak->allocate(sv->field_size(), THREAD);\n@@ -1156,0 +1201,15 @@\n+\/\/ We're deoptimizing at the return of a call, inline type fields are\n+\/\/ in registers. When we go back to the interpreter, it will expect a\n+\/\/ reference to an inline type instance. Allocate and initialize it from\n+\/\/ the register values here.\n+bool Deoptimization::realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS) {\n+  oop new_vt = vk->realloc_result(map, return_oops, THREAD);\n+  if (new_vt == NULL) {\n+    CLEAR_PENDING_EXCEPTION;\n+    THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);\n+  }\n+  return_oops.clear();\n+  return_oops.push(Handle(THREAD, new_vt));\n+  return false;\n+}\n+\n@@ -1328,0 +1388,1 @@\n+  InstanceKlass* _klass;\n@@ -1332,0 +1393,1 @@\n+    _klass = NULL;\n@@ -1341,1 +1403,1 @@\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {\n@@ -1350,0 +1412,8 @@\n+        if (fs.signature()->is_Q_signature()) {\n+          if (fs.is_inlined()) {\n+            \/\/ Resolve klass of flattened inline type field\n+            field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n+          } else {\n+            field._type = T_OBJECT;\n+          }\n+        }\n@@ -1357,0 +1427,11 @@\n+    BasicType type = fields->at(i)._type;\n+    int offset = base_offset + fields->at(i)._offset;\n+    \/\/ Check for flattened inline type field before accessing the ScopeValue because it might not have any fields\n+    if (type == T_PRIMITIVE_OBJECT) {\n+      \/\/ Recursively re-assign flattened inline type fields\n+      InstanceKlass* vk = fields->at(i)._klass;\n+      assert(vk != NULL, \"must be resolved\");\n+      offset -= InlineKlass::cast(vk)->first_field_offset(); \/\/ Adjust offset to omit oop header\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);\n+      continue; \/\/ Continue because we don't need to increment svIndex\n+    }\n@@ -1360,3 +1441,2 @@\n-    int offset = fields->at(i)._offset;\n-    BasicType type = fields->at(i)._type;\n-      case T_OBJECT: case T_ARRAY:\n+      case T_OBJECT:\n+      case T_ARRAY:\n@@ -1443,0 +1523,14 @@\n+\/\/ restore fields of an eliminated inline type array\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS) {\n+  InlineKlass* vk = vak->element_klass();\n+  assert(vk->flatten_array(), \"should only be used for flattened inline type arrays\");\n+  \/\/ Adjust offset to omit oop header\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT) - InlineKlass::cast(vk)->first_field_offset();\n+  \/\/ Initialize all elements of the flattened inline type array\n+  for (int i = 0; i < sv->field_size(); i++) {\n+    ScopeValue* val = sv->field_at(i);\n+    int offset = base_offset + (i << Klass::layout_helper_log2_element_size(vak->layout_helper()));\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, skip_internal, offset, CHECK);\n+  }\n+}\n+\n@@ -1444,1 +1538,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS) {\n@@ -1449,1 +1543,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->maybe_null(), \"reallocation was missed\");\n@@ -1489,1 +1583,4 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, CHECK);\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, skip_internal, CHECK);\n@@ -1649,1 +1746,1 @@\n-  \/\/ Deoptimize only if the frame comes from compile code.\n+  \/\/ Deoptimize only if the frame comes from compiled code.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":120,"deletions":23,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  static bool realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS);\n@@ -182,1 +183,2 @@\n-  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal);\n+  static void reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS);\n+  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -62,0 +63,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -365,0 +369,19 @@\n+\n+#ifdef COMPILER1\n+  if (cm->is_compiled_by_c1() && cm->method()->has_scalarized_args() &&\n+      pc() < cm->verified_inline_entry_point()) {\n+    \/\/ The VEP and VIEP(RO) of C1-compiled methods call into the runtime to buffer scalarized value\n+    \/\/ type args. We can't deoptimize at that point because the buffers have not yet been initialized.\n+    \/\/ Also, if the method is synchronized, we first need to acquire the lock.\n+    \/\/ Don't patch the return pc to delay deoptimization until we enter the method body (the check\n+    \/\/ addedin LIRGenerator::do_Base will detect the pending deoptimization by checking the original_pc).\n+#if defined ASSERT && !defined AARCH64   \/\/ Stub call site does not look like NativeCall on AArch64\n+    NativeCall* call = nativeCall_before(this->pc());\n+    address dest = call->destination();\n+    assert(dest == Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id) ||\n+           dest == Runtime1::entry_for(Runtime1::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n+#endif\n+    return;\n+  }\n+#endif\n+\n@@ -763,1 +786,1 @@\n-                          OopClosure* f) {\n+                          OopClosure* f, BufferedValueClosure* bvt_f) {\n@@ -775,1 +798,3 @@\n-      _f->do_oop(addr);\n+      if (_f != NULL) {\n+        _f->do_oop(addr);\n+      }\n@@ -787,1 +812,3 @@\n-        _f->do_oop(addr);\n+        if (_f != NULL) {\n+          _f->do_oop(addr);\n+        }\n@@ -964,1 +991,1 @@\n-  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f);\n+  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f, NULL);\n@@ -976,0 +1003,17 @@\n+void frame::buffered_values_interpreted_do(BufferedValueClosure* f) {\n+  assert(is_interpreted_frame(), \"Not an interpreted frame\");\n+  Thread *thread = Thread::current();\n+  methodHandle m (thread, interpreter_frame_method());\n+  jint      bci = interpreter_frame_bci();\n+\n+  assert(m->is_method(), \"checking frame value\");\n+  assert(!m->is_native() && bci >= 0 && bci < m->code_size(),\n+         \"invalid bci value\");\n+\n+  InterpreterFrameClosure blk(this, m->max_locals(), m->max_stack(), NULL, f);\n+\n+  \/\/ process locals & expression stack\n+  InterpreterOopMap mask;\n+  m->mask_for(bci, &mask);\n+  mask.iterate_oop(&blk);\n+}\n@@ -1027,0 +1071,1 @@\n+    assert(_offset < _arg_size, \"out of bounds\");\n@@ -1053,5 +1098,1 @@\n-    _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);\n-\n-    int arg_size;\n-    _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &arg_size);\n-    assert(arg_size == _arg_size, \"wrong arg size\");\n+    _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &_arg_size);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":50,"deletions":9,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -457,0 +457,1 @@\n+  void buffered_values_interpreted_do(BufferedValueClosure* f);\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -784,0 +784,18 @@\n+  notproduct(bool, PrintInlineLayout, false,                                \\\n+          \"Print field layout for each inline type\")                        \\\n+                                                                            \\\n+  notproduct(bool, PrintFlatArrayLayout, false,                             \\\n+          \"Print array layout for each inline type array\")                  \\\n+                                                                            \\\n+  product(intx, FlatArrayElementMaxSize, -1,                                \\\n+          \"Max size for flattening inline array elements, <0 no limit\")     \\\n+                                                                            \\\n+  product(intx, InlineFieldMaxFlatSize, 128,                                \\\n+          \"Max size for flattening inline type fields, <0 no limit\")        \\\n+                                                                            \\\n+  product(intx, FlatArrayElementMaxOops, 4,                                 \\\n+          \"Max nof embedded object references in an inline type to flatten, <0 no limit\")  \\\n+                                                                            \\\n+  product(bool, InlineArrayAtomicAccess, false,                             \\\n+          \"Atomic inline array accesses by-default, for all inline arrays\") \\\n+                                                                            \\\n@@ -2048,0 +2066,20 @@\n+  product(bool, EnableValhalla, true,                                       \\\n+          \"Enable experimental Valhalla features\")                          \\\n+                                                                            \\\n+  product_pd(bool, InlineTypePassFieldsAsArgs,                              \\\n+          \"Pass each inline type field as an argument at calls\")            \\\n+                                                                            \\\n+  product_pd(bool, InlineTypeReturnedAsFields,                              \\\n+          \"Return fields instead of an inline type reference\")              \\\n+                                                                            \\\n+  develop(bool, StressInlineTypeReturnedAsFields, false,                    \\\n+          \"Stress return of fields instead of an inline type reference\")    \\\n+                                                                            \\\n+  product(bool, UseArrayMarkWordCheck, NOT_LP64(false) LP64_ONLY(true),     \\\n+          \"Use bits in the mark word to check for flat\/null-free arrays\")   \\\n+                                                                            \\\n+  product(ccstrlist, ForceNonTearable, \"\", DIAGNOSTIC,                      \\\n+          \"List of inline classes which are forced to be atomic \"           \\\n+          \"(whitespace and commas separate names, \"                         \\\n+          \"and leading and trailing stars '*' are wildcards)\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class InlineKlass;\n@@ -131,0 +132,1 @@\n+DEF_HANDLE(flatArray        , is_flatArray_noinline        )\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+DEF_HANDLE_CONSTR(flatArray, is_flatArray_noinline)\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+  VMRegImpl::set_regName();       \/\/ need this before generate_stubs (for printing oop maps).\n@@ -136,1 +137,0 @@\n-  VMRegImpl::set_regName(); \/\/ need this before generate_stubs (for printing oop maps).\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -151,4 +152,4 @@\n-    case T_BOOLEAN: \/\/ fall through\n-    case T_CHAR   : \/\/ fall through\n-    case T_SHORT  : \/\/ fall through\n-    case T_INT    : \/\/ fall through\n+    case T_BOOLEAN  : \/\/ fall through\n+    case T_CHAR     : \/\/ fall through\n+    case T_SHORT    : \/\/ fall through\n+    case T_INT      : \/\/ fall through\n@@ -156,2 +157,3 @@\n-    case T_OBJECT : \/\/ fall through\n-    case T_ARRAY  : \/\/ fall through\n+    case T_OBJECT   : \/\/ fall through\n+    case T_ARRAY    : \/\/ fall through\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -159,5 +161,5 @@\n-    case T_BYTE   : \/\/ fall through\n-    case T_VOID   : return T_INT;\n-    case T_LONG   : return T_LONG;\n-    case T_FLOAT  : return T_FLOAT;\n-    case T_DOUBLE : return T_DOUBLE;\n+    case T_BYTE     : \/\/ fall through\n+    case T_VOID     : return T_INT;\n+    case T_LONG     : return T_LONG;\n+    case T_FLOAT    : return T_FLOAT;\n+    case T_DOUBLE   : return T_DOUBLE;\n@@ -165,2 +167,3 @@\n-    case T_ARRAY  : \/\/ fall through\n-    case T_OBJECT:  return T_OBJECT;\n+    case T_ARRAY    : \/\/ fall through\n+    case T_OBJECT   : return T_OBJECT;\n+    case T_PRIMITIVE_OBJECT: return T_PRIMITIVE_OBJECT;\n@@ -294,0 +297,13 @@\n+\n+  \/\/ Special case for factory methods\n+  if (!constructor_signature->is_void_method_signature()) {\n+    assert(klass->is_inline_klass(), \"inline classes must use factory methods\");\n+    JavaValue factory_result(T_OBJECT);\n+    JavaCalls::call_static(&factory_result, klass,\n+                           vmSymbols::object_initializer_name(),\n+                           constructor_signature, args, CHECK_NH);\n+    return Handle(THREAD, factory_result.get_oop());\n+  }\n+\n+  \/\/ main branch of code creates a non-inline object:\n+  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n@@ -395,0 +411,12 @@\n+  jobject value_buffer = NULL;\n+  if (InlineTypeReturnedAsFields && (result->get_type() == T_PRIMITIVE_OBJECT || result->get_type() == T_OBJECT)) {\n+    \/\/ Pre allocate a buffered inline type in case the result is returned\n+    \/\/ flattened by compiled code\n+    InlineKlass* vk = method->returns_inline_type(thread);\n+    if (vk != NULL && vk->can_be_returned_as_fields()) {\n+      oop instance = vk->allocate_instance(CHECK);\n+      value_buffer = JNIHandles::make_local(thread, instance);\n+      result->set_jobject(value_buffer);\n+    }\n+  }\n+\n@@ -445,0 +473,1 @@\n+    JNIHandles::destroy_local(value_buffer);\n@@ -581,0 +610,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -593,1 +623,1 @@\n-  if (is_reference_type(return_type)) return_type = T_OBJECT;\n+  if (return_type == T_ARRAY) return_type = T_OBJECT;\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":44,"deletions":14,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  oop           _return_buffered_value; \/\/ buffered value being returned\n@@ -697,0 +698,3 @@\n+  oop return_buffered_value() const              { return _return_buffered_value; }\n+  void set_return_buffered_value(oop val)        { _return_buffered_value = val; }\n+\n@@ -770,0 +774,1 @@\n+  static ByteSize return_buffered_value_offset() { return byte_offset_of(JavaThread, _return_buffered_value); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -300,0 +302,38 @@\n+bool JNIHandles::is_same_object(jobject handle1, jobject handle2) {\n+  oop obj1 = resolve_no_keepalive(handle1);\n+  oop obj2 = resolve_no_keepalive(handle2);\n+\n+  bool ret = obj1 == obj2;\n+\n+  if (EnableValhalla) {\n+    if (!ret && obj1 != NULL && obj2 != NULL && obj1->klass() == obj2->klass() && obj1->klass()->is_inline_klass()) {\n+      \/\/ The two references are different, they are not null and they are both inline types,\n+      \/\/ a full substitutability test is required, calling PrimitiveObjectMethods.isSubstitutable()\n+      \/\/ (similarly to InterpreterRuntime::is_substitutable)\n+      JavaThread* THREAD = JavaThread::current();\n+      Handle ha(THREAD, obj1);\n+      Handle hb(THREAD, obj2);\n+      JavaValue result(T_BOOLEAN);\n+      JavaCallArguments args;\n+      args.push_oop(ha);\n+      args.push_oop(hb);\n+      methodHandle method(THREAD, Universe::is_substitutable_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        \/\/ Something really bad happened because isSubstitutable() should not throw exceptions\n+        \/\/ If it is an error, just let it propagate\n+        \/\/ If it is an exception, wrap it into an InternalError\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in substitutability test\", e, false);\n+        }\n+      }\n+      ret = result.get_jboolean();\n+    }\n+  }\n+\n+  return ret;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                          \/\/ 'B','Z','J','I','S','C','D','F','V','L','['\n+                          \/\/ 'B','Z','J','I','S','C','D','F','V','L','Q','['\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -55,0 +56,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -350,1 +352,5 @@\n-    return oopFactory::new_objArray(k, length, THREAD);\n+    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+      return oopFactory::new_valueArray(k, length, THREAD);\n+    } else {\n+      return oopFactory::new_objArray(k, length, THREAD);\n+    }\n@@ -391,1 +397,5 @@\n-  klass = klass->array_klass(dim, CHECK_NULL);\n+  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+    klass = InlineKlass::cast(klass)->value_array_klass(dim, CHECK_NULL);\n+  } else {\n+    klass = klass->array_klass(dim, CHECK_NULL);\n+  }\n@@ -768,3 +778,0 @@\n-  if (log_is_enabled(Debug, class, resolve)) {\n-    trace_class_resolution(nt);\n-  }\n@@ -776,2 +783,1 @@\n-  assert(!method()->is_initializer() ||\n-         (for_constant_pool_access && method()->is_static()),\n+  assert(!method()->name()->starts_with('<') || for_constant_pool_access,\n@@ -826,1 +832,3 @@\n-  assert(method()->is_initializer(), \"should call new_method instead\");\n+  assert(method()->is_object_constructor() ||\n+         method()->is_static_init_factory(),\n+         \"should call new_method instead\");\n@@ -879,1 +887,2 @@\n-  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n+  int modifiers = fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n+  java_lang_reflect_Field::set_modifiers(rh(), modifiers);\n@@ -1150,0 +1159,2 @@\n+  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_inline_klass()) {\n+    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_PRIMITIVE_OBJECT;\n@@ -1184,0 +1195,16 @@\n+\n+  \/\/ Special case for factory methods\n+  if (!method->signature()->is_void_method_signature()) {\n+    assert(klass->is_inline_klass(), \"inline classes must use factory methods\");\n+    Handle no_receiver; \/\/ null instead of receiver\n+    BasicType rtype;\n+    if (klass->is_hidden()) {\n+      rtype = T_OBJECT;\n+    } else {\n+      rtype = T_PRIMITIVE_OBJECT;\n+    }\n+    return invoke(klass, method, no_receiver, override, ptypes, rtype, args, false, CHECK_NULL);\n+  }\n+\n+  \/\/ main branch of code creates a non-inline object:\n+  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":36,"deletions":9,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -922,0 +923,1 @@\n+    ResourceMark rm;\n@@ -923,1 +925,2 @@\n-    bool return_oop = nm->method()->is_returning_oop();\n+    Method* method = nm->method();\n+    bool return_oop = method->is_returning_oop();\n@@ -925,1 +928,17 @@\n-    Handle return_value;\n+\n+    GrowableArray<Handle> return_values;\n+    InlineKlass* vk = NULL;\n+    if (return_oop && InlineTypeReturnedAsFields &&\n+        (method->result_type() == T_PRIMITIVE_OBJECT || method->result_type() == T_OBJECT)) {\n+      \/\/ Check if an inline type is returned as fields\n+      vk = InlineKlass::returned_inline_klass(map);\n+      if (vk != NULL) {\n+        \/\/ We're at a safepoint at the return of a method that returns\n+        \/\/ multiple values. We must make sure we preserve the oop values\n+        \/\/ across the safepoint.\n+        assert(vk == method->returns_inline_type(thread()), \"bad inline klass\");\n+        vk->save_oop_fields(map, return_values);\n+        return_oop = false;\n+      }\n+    }\n+\n@@ -932,1 +951,1 @@\n-      return_value = Handle(self, result);\n+      return_values.push(Handle(self, result));\n@@ -946,1 +965,4 @@\n-      caller_fr.set_saved_oop_result(&map, return_value());\n+      assert(return_values.length() == 1, \"only one return value\");\n+      caller_fr.set_saved_oop_result(&map, return_values.pop()());\n+    } else if (vk != NULL) {\n+      vk->restore_oop_results(map, return_values);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -49,0 +50,2 @@\n+#include \"oops\/access.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -53,0 +56,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -54,0 +58,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -89,1 +94,0 @@\n-address             SharedRuntime::_resolve_static_call_entry;\n@@ -109,1 +113,0 @@\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n@@ -998,0 +1001,1 @@\n+\n@@ -1106,0 +1110,15 @@\n+  \/\/ Substitutability test implementation piggy backs on static call resolution\n+  Bytecodes::Code code = caller->java_code_at(bci);\n+  if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {\n+    bc = Bytecodes::_invokestatic;\n+    methodHandle attached_method(THREAD, extract_attached_method(vfst));\n+    assert(attached_method.not_null(), \"must have attached method\");\n+    vmClasses::PrimitiveObjectMethods_klass()->initialize(CHECK_NH);\n+    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);\n+#ifdef ASSERT\n+    Method* is_subst = vmClasses::PrimitiveObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    assert(callinfo.selected_method() == is_subst, \"must be isSubstitutable method\");\n+#endif\n+    return receiver;\n+  }\n+\n@@ -1141,0 +1160,6 @@\n+    } else {\n+      assert(attached_method->has_scalarized_args(), \"invalid use of attached method\");\n+      if (!attached_method->method_holder()->is_inline_klass()) {\n+        \/\/ Ignore the attached method in this case to not confuse below code\n+        attached_method = methodHandle(current, NULL);\n+      }\n@@ -1149,0 +1174,1 @@\n+  bool check_null_and_abstract = true;\n@@ -1161,0 +1187,5 @@\n+    bool caller_is_c1 = false;\n+\n+    if (callerFrame.is_compiled_frame() && !callerFrame.is_deoptimized_frame()) {\n+      caller_is_c1 = callerFrame.cb()->is_compiled_by_c1();\n+    }\n@@ -1162,2 +1193,3 @@\n-    if (attached_method.is_null()) {\n-      Method* callee = bytecode.static_target(CHECK_NH);\n+    Method* callee = attached_method();\n+    if (callee == NULL) {\n+      callee = bytecode.static_target(CHECK_NH);\n@@ -1168,7 +1200,15 @@\n-\n-    \/\/ Retrieve from a compiled argument list\n-    receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n-    assert(oopDesc::is_oop_or_null(receiver()), \"\");\n-\n-    if (receiver.is_null()) {\n-      THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);\n+    if (!caller_is_c1 && callee->is_scalarized_arg(0)) {\n+      \/\/ If the receiver is an inline type that is passed as fields, no oop is available\n+      \/\/ Resolve the call without receiver null checking.\n+      assert(attached_method.not_null() && !attached_method->is_abstract(), \"must have non-abstract attached method\");\n+      if (bc == Bytecodes::_invokeinterface) {\n+        bc = Bytecodes::_invokevirtual; \/\/ C2 optimistically replaces interface calls by virtual calls\n+      }\n+      check_null_and_abstract = false;\n+    } else {\n+      \/\/ Retrieve from a compiled argument list\n+      receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n+      assert(oopDesc::is_oop_or_null(receiver()), \"\");\n+      if (receiver.is_null()) {\n+        THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);\n+      }\n@@ -1181,1 +1221,1 @@\n-    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);\n+    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);\n@@ -1190,1 +1230,1 @@\n-  if (has_receiver) {\n+  if (has_receiver && check_null_and_abstract) {\n@@ -1251,1 +1291,1 @@\n-methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, TRAPS) {\n+methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS) {\n@@ -1253,1 +1293,1 @@\n-  callee_method = resolve_sub_helper(is_virtual, is_optimized, THREAD);\n+  callee_method = resolve_sub_helper(is_virtual, is_optimized, caller_is_c1, THREAD);\n@@ -1270,1 +1310,1 @@\n-      callee_method = resolve_sub_helper(is_virtual, is_optimized, THREAD);\n+      callee_method = resolve_sub_helper(is_virtual, is_optimized, caller_is_c1, THREAD);\n@@ -1301,0 +1341,1 @@\n+  bool caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1303,1 +1344,8 @@\n-    assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, \"sanity check\");\n+    Klass* receiver_klass = NULL;\n+    if (!caller_is_c1 && callee_method->is_scalarized_arg(0)) {\n+      \/\/ If the receiver is an inline type that is passed as fields, no oop is available\n+      receiver_klass = callee_method->method_holder();\n+    } else {\n+      assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, \"sanity check\");\n+      receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();\n+    }\n@@ -1305,3 +1353,2 @@\n-    Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();\n-    CompiledIC::compute_monomorphic_entry(callee_method, klass,\n-                     is_optimized, static_bound, is_nmethod, virtual_call_info,\n+    CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,\n+                     is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,\n@@ -1311,1 +1358,1 @@\n-    CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);\n+    CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);\n@@ -1364,1 +1411,1 @@\n-methodHandle SharedRuntime::resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS) {\n+methodHandle SharedRuntime::resolve_sub_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS) {\n@@ -1376,0 +1423,1 @@\n+  *caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1479,0 +1527,2 @@\n+  bool is_optimized = false;\n+  bool caller_is_c1 = false;\n@@ -1480,1 +1530,1 @@\n-    callee_method = SharedRuntime::handle_ic_miss_helper(CHECK_NULL);\n+    callee_method = SharedRuntime::handle_ic_miss_helper(is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1485,2 +1535,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);\n@@ -1533,0 +1582,3 @@\n+  bool is_static_call = false;\n+  bool is_optimized = false;\n+  bool caller_is_c1 = false;\n@@ -1535,1 +1587,1 @@\n-    callee_method = SharedRuntime::reresolve_call_site(CHECK_NULL);\n+    callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1539,2 +1591,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);\n@@ -1581,0 +1632,1 @@\n+  bool caller_is_c1;\n@@ -1583,1 +1635,1 @@\n-    callee_method = SharedRuntime::resolve_helper(false, false, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(false, false, &caller_is_c1, CHECK_NULL);\n@@ -1611,2 +1663,4 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  address entry = caller_is_c1 ?\n+    callee_method->verified_inline_code_entry() : callee_method->verified_code_entry();\n+  assert(entry != NULL, \"Jump to zero!\");\n+  return entry;\n@@ -1619,0 +1673,1 @@\n+  bool caller_is_c1;\n@@ -1620,1 +1675,1 @@\n-    callee_method = SharedRuntime::resolve_helper(true, false, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(true, false, &caller_is_c1, CHECK_NULL);\n@@ -1624,2 +1679,4 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  address entry = caller_is_c1 ?\n+    callee_method->verified_inline_code_entry() : callee_method->verified_inline_ro_code_entry();\n+  assert(entry != NULL, \"Jump to zero!\");\n+  return entry;\n@@ -1633,0 +1690,1 @@\n+  bool caller_is_c1;\n@@ -1634,1 +1692,1 @@\n-    callee_method = SharedRuntime::resolve_helper(true, true, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(true, true, &caller_is_c1, CHECK_NULL);\n@@ -1638,2 +1696,4 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  address entry = caller_is_c1 ?\n+    callee_method->verified_inline_code_entry() : callee_method->verified_code_entry();\n+  assert(entry != NULL, \"Jump to zero!\");\n+  return entry;\n@@ -1650,1 +1710,1 @@\n-                                                   bool& needs_ic_stub_refill, TRAPS) {\n+                                                   bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS) {\n@@ -1661,0 +1721,1 @@\n+    is_optimized = true;\n@@ -1698,0 +1759,1 @@\n+                                            caller_nm->is_compiled_by_c1(),\n@@ -1706,1 +1768,1 @@\n-    bool successful = inline_cache->set_to_megamorphic(&call_info, bc, needs_ic_stub_refill, CHECK_false);\n+    bool successful = inline_cache->set_to_megamorphic(&call_info, bc, needs_ic_stub_refill, caller_is_c1, CHECK_false);\n@@ -1722,1 +1784,1 @@\n-methodHandle SharedRuntime::handle_ic_miss_helper(TRAPS) {\n+methodHandle SharedRuntime::handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1742,1 +1804,3 @@\n-    methodHandle callee_method = SharedRuntime::reresolve_call_site(CHECK_(methodHandle()));\n+    bool is_static_call = false;\n+    methodHandle callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));\n+    assert(!is_static_call, \"IC miss at static call?\");\n@@ -1801,0 +1865,1 @@\n+  caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1806,1 +1871,1 @@\n-                                                     bc, call_info, needs_ic_stub_refill, CHECK_(methodHandle()));\n+                                                     bc, call_info, needs_ic_stub_refill, is_optimized, caller_is_c1, CHECK_(methodHandle()));\n@@ -1838,1 +1903,1 @@\n-methodHandle SharedRuntime::reresolve_call_site(TRAPS) {\n+methodHandle SharedRuntime::reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1858,1 +1923,1 @@\n-    bool is_static_call = false;\n+    caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1900,1 +1965,2 @@\n-        bool is_static_call = false;\n+        is_static_call = false;\n+        is_optimized = false;\n@@ -1907,0 +1973,1 @@\n+            is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);\n@@ -1932,1 +1999,0 @@\n-\n@@ -2028,2 +2094,0 @@\n-  address entry_point = moop->from_compiled_entry_no_trampoline();\n-\n@@ -2041,1 +2105,5 @@\n-  if (cb == NULL || !cb->is_compiled() || entry_point == moop->get_c2i_entry()) {\n+  if (cb == NULL || !cb->is_compiled()) {\n+    return;\n+  }\n+  address entry_point = moop->from_compiled_entry_no_trampoline(cb->is_compiled_by_c1());\n+  if (entry_point == moop->get_c2i_entry()) {\n@@ -2428,1 +2496,1 @@\n-  static int adapter_encoding(BasicType in) {\n+  static BasicType adapter_encoding(BasicType in) {\n@@ -2434,1 +2502,1 @@\n-        \/\/ There are all promoted to T_INT in the calling convention\n+        \/\/ They are all promoted to T_INT in the calling convention\n@@ -2461,1 +2529,1 @@\n-  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n+  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n@@ -2464,0 +2532,1 @@\n+    int total_args_passed = (sig != NULL) ? sig->length() : 0;\n@@ -2481,0 +2550,2 @@\n+    BasicType prev_bt = T_ILLEGAL;\n+    int vt_count = 0;\n@@ -2483,4 +2554,27 @@\n-      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n-        int bt = adapter_encoding(sig_bt[sig_index++]);\n-        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt;\n+      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n+        BasicType bt = T_ILLEGAL;\n+        if (sig_index < total_args_passed) {\n+          bt = sig->at(sig_index++)._bt;\n+          if (bt == T_PRIMITIVE_OBJECT) {\n+            \/\/ Found start of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+            if (sig_index == 1 && has_ro_adapter) {\n+              \/\/ With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching\n+              \/\/ with other adapters that have the same inline type as first argument and no receiver.\n+              bt = T_VOID;\n+            }\n+            vt_count++;\n+          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+            \/\/ Found end of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+            vt_count--;\n+            assert(vt_count >= 0, \"invalid vt_count\");\n+          } else if (vt_count == 0) {\n+            \/\/ Widen fields that are not part of a scalarized inline type argument\n+            bt = adapter_encoding(bt);\n+          }\n+          prev_bt = bt;\n+        }\n+        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n+        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt_val;\n@@ -2490,0 +2584,1 @@\n+    assert(vt_count == 0, \"invalid vt_count\");\n@@ -2554,8 +2649,4 @@\n-        }\n-        switch (v) {\n-          case T_INT:    st.print(\"I\");    break;\n-          case T_LONG:   long_prev = true; break;\n-          case T_FLOAT:  st.print(\"F\");    break;\n-          case T_DOUBLE: st.print(\"D\");    break;\n-          case T_VOID:   break;\n-          default: ShouldNotReachHere();\n+        } else if (v == T_LONG) {\n+          long_prev = true;\n+        } else if (v != T_VOID){\n+          st.print(\"%c\", type2char((BasicType)v));\n@@ -2616,1 +2707,3 @@\n-  AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {\n+  AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,\n+                                 address c2i_inline_entry, address c2i_inline_ro_entry,\n+                                 address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry) {\n@@ -2618,1 +2711,2 @@\n-    entry->init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+    entry->init(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry,\n+                c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -2634,1 +2728,1 @@\n-  AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {\n+  AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n@@ -2636,1 +2730,1 @@\n-    AdapterFingerPrint fp(total_args_passed, sig_bt);\n+    AdapterFingerPrint fp(sig, has_ro_adapter);\n@@ -2737,1 +2831,1 @@\n-const int AdapterHandlerLibrary_size = 16*K;\n+const int AdapterHandlerLibrary_size = 32*K;\n@@ -2785,1 +2879,1 @@\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n@@ -2787,0 +2881,1 @@\n+                                                                wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n@@ -2788,1 +2883,0 @@\n-\n@@ -2791,1 +2885,3 @@\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, NULL, true);\n+    CompiledEntrySignature no_args;\n+    no_args.compute_calling_conventions();\n+    _no_arg_handler = create_adapter(no_arg_blob, no_args, true);\n@@ -2793,2 +2889,4 @@\n-    BasicType obj_args[] = { T_OBJECT };\n-    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args, true);\n+    CompiledEntrySignature obj_args;\n+    SigEntry::add_entry(&obj_args.sig(), T_OBJECT, NULL);\n+    obj_args.compute_calling_conventions();\n+    _obj_arg_handler = create_adapter(obj_arg_blob, obj_args, true);\n@@ -2796,2 +2894,4 @@\n-    BasicType int_args[] = { T_INT };\n-    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args, true);\n+    CompiledEntrySignature int_args;\n+    SigEntry::add_entry(&int_args.sig(), T_INT, NULL);\n+    int_args.compute_calling_conventions();\n+    _int_arg_handler = create_adapter(int_arg_blob, int_args, true);\n@@ -2799,2 +2899,5 @@\n-    BasicType obj_int_args[] = { T_OBJECT, T_INT };\n-    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args, true);\n+    CompiledEntrySignature obj_int_args;\n+    SigEntry::add_entry(&obj_int_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(&obj_int_args.sig(), T_INT, NULL);\n+    obj_int_args.compute_calling_conventions();\n+    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, obj_int_args, true);\n@@ -2802,2 +2905,5 @@\n-    BasicType obj_obj_args[] = { T_OBJECT, T_OBJECT };\n-    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args, true);\n+    CompiledEntrySignature obj_obj_args;\n+    SigEntry::add_entry(&obj_obj_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(&obj_obj_args.sig(), T_OBJECT, NULL);\n+    obj_obj_args.compute_calling_conventions();\n+    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, obj_obj_args, true);\n@@ -2811,0 +2917,1 @@\n+  return;\n@@ -2823,0 +2930,2 @@\n+                                                      address c2i_inline_entry,\n+                                                      address c2i_inline_ro_entry,\n@@ -2824,0 +2933,1 @@\n+                                                      address c2i_unverified_inline_entry,\n@@ -2825,1 +2935,2 @@\n-  return _adapters->new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return _adapters->new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n+                              c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -2830,1 +2941,1 @@\n-    return _abstract_method_handler;\n+    return NULL;\n@@ -2837,0 +2948,3 @@\n+      if (InlineTypePassFieldsAsArgs && method->method_holder()->is_inline_klass()) {\n+        return NULL;\n+      }\n@@ -2840,1 +2954,10 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          InlineKlass* vk = ss.as_inline_klass(method->method_holder());\n+          if (vk != NULL) {\n+            return NULL;\n+          }\n+        }\n+        return _obj_arg_handler;\n+      }\n@@ -2851,1 +2974,1 @@\n-             !method->is_static()) {\n+             !method->is_static() && (!InlineTypePassFieldsAsArgs || !method->method_holder()->is_inline_klass())) {\n@@ -2853,1 +2976,10 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          InlineKlass* vk = ss.as_inline_klass(method->method_holder());\n+          if (vk != NULL) {\n+            return NULL;\n+          }\n+        }\n+        return _obj_obj_arg_handler;\n+      }\n@@ -2867,5 +2999,9 @@\n-class AdapterSignatureIterator : public SignatureIterator {\n- private:\n-  BasicType stack_sig_bt[16];\n-  BasicType* sig_bt;\n-  int index;\n+CompiledEntrySignature::CompiledEntrySignature(Method* method) :\n+  _method(method), _num_inline_args(0), _has_inline_recv(false),\n+  _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),\n+  _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),\n+  _c1_needs_stack_repair(false), _c2_needs_stack_repair(false) {\n+  _sig = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig_cc = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig_cc_ro = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+}\n@@ -2873,13 +3009,10 @@\n- public:\n-  AdapterSignatureIterator(Symbol* signature,\n-                           fingerprint_t fingerprint,\n-                           bool is_static,\n-                           int total_args_passed) :\n-    SignatureIterator(signature, fingerprint),\n-    index(0)\n-  {\n-    sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n-    if (!is_static) { \/\/ Pass in receiver first\n-      sig_bt[index++] = T_OBJECT;\n-    }\n-    do_parameters_on(this);\n+\/\/ See if we can save space by sharing the same entry for VIEP and VIEP(RO),\n+\/\/ or the same entry for VEP and VIEP(RO).\n+CodeOffsets::Entries CompiledEntrySignature::c1_inline_ro_entry_type() const {\n+  if (!has_scalarized_args()) {\n+    \/\/ VEP\/VIEP\/VIEP(RO) all share the same entry. There's no packing.\n+    return CodeOffsets::Verified_Entry;\n+  }\n+  if (_method->is_static()) {\n+    \/\/ Static methods don't need VIEP(RO)\n+    return CodeOffsets::Verified_Entry;\n@@ -2888,2 +3021,13 @@\n-  BasicType* basic_types() {\n-    return sig_bt;\n+  if (has_inline_recv()) {\n+    if (num_inline_args() == 1) {\n+      \/\/ Share same entry for VIEP and VIEP(RO).\n+      \/\/ This is quite common: we have an instance method in an InlineKlass that has\n+      \/\/ no inline type args other than <this>.\n+      return CodeOffsets::Verified_Inline_Entry;\n+    } else {\n+      assert(num_inline_args() > 1, \"must be\");\n+      \/\/ No sharing:\n+      \/\/   VIEP(RO) -- <this> is passed as object\n+      \/\/   VEP      -- <this> is passed as fields\n+      return CodeOffsets::Verified_Inline_Entry_RO;\n+    }\n@@ -2892,3 +3036,63 @@\n-#ifdef ASSERT\n-  int slots() {\n-    return index;\n+  \/\/ Either a static method, or <this> is not an inline type\n+  if (args_on_stack_cc() != args_on_stack_cc_ro()) {\n+    \/\/ No sharing:\n+    \/\/ Some arguments are passed on the stack, and we have inserted reserved entries\n+    \/\/ into the VEP, but we never insert reserved entries into the VIEP(RO).\n+    return CodeOffsets::Verified_Inline_Entry_RO;\n+  } else {\n+    \/\/ Share same entry for VEP and VIEP(RO).\n+    return CodeOffsets::Verified_Entry;\n+  }\n+}\n+\n+void CompiledEntrySignature::compute_calling_conventions(bool init) {\n+  \/\/ Iterate over arguments and compute scalarized and non-scalarized signatures\n+  bool has_scalarized = false;\n+  if (_method != NULL) {\n+    InstanceKlass* holder = _method->method_holder();\n+    int arg_num = 0;\n+    if (!_method->is_static()) {\n+      if (holder->is_inline_klass() && InlineKlass::cast(holder)->can_be_passed_as_fields() &&\n+          (init || _method->is_scalarized_arg(arg_num))) {\n+        _sig_cc->appendAll(InlineKlass::cast(holder)->extended_sig());\n+        has_scalarized = true;\n+        _has_inline_recv = true;\n+        _num_inline_args++;\n+      } else {\n+        SigEntry::add_entry(_sig_cc, T_OBJECT, holder->name());\n+      }\n+      SigEntry::add_entry(_sig, T_OBJECT, holder->name());\n+      SigEntry::add_entry(_sig_cc_ro, T_OBJECT, holder->name());\n+      arg_num++;\n+    }\n+    for (SignatureStream ss(_method->signature()); !ss.at_return_type(); ss.next()) {\n+      BasicType bt = ss.type();\n+      if (bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) {\n+        InlineKlass* vk = ss.as_inline_klass(holder);\n+        \/\/ TODO 8284443 Mismatch handling, we need to check parent method args (look at klassVtable::needs_new_vtable_entry)\n+        if (vk != NULL && vk->can_be_passed_as_fields() && (init || _method->is_scalarized_arg(arg_num))) {\n+          _num_inline_args++;\n+          has_scalarized = true;\n+          int last = _sig_cc->length();\n+          int last_ro = _sig_cc_ro->length();\n+          _sig_cc->appendAll(vk->extended_sig());\n+          _sig_cc_ro->appendAll(vk->extended_sig());\n+          if (bt == T_OBJECT) {\n+            \/\/ Nullable inline type argument, insert InlineTypeBaseNode::IsInit field right after T_PRIMITIVE_OBJECT\n+            _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, NULL));\n+            _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, NULL));\n+          }\n+        } else {\n+          SigEntry::add_entry(_sig_cc, T_OBJECT, ss.as_symbol());\n+          SigEntry::add_entry(_sig_cc_ro, T_OBJECT, ss.as_symbol());\n+        }\n+        bt = T_OBJECT;\n+      } else {\n+        SigEntry::add_entry(_sig_cc, ss.type(), ss.as_symbol());\n+        SigEntry::add_entry(_sig_cc_ro, ss.type(), ss.as_symbol());\n+      }\n+      SigEntry::add_entry(_sig, bt, ss.as_symbol());\n+      if (bt != T_VOID) {\n+        arg_num++;\n+      }\n+    }\n@@ -2896,2 +3100,3 @@\n-#endif\n- private:\n+  \/\/ Compute the non-scalarized calling convention\n+  _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig->length());\n+  _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);\n@@ -2900,5 +3105,16 @@\n-  friend class SignatureIterator;  \/\/ so do_parameters_on can call do_type\n-  void do_type(BasicType type) {\n-    sig_bt[index++] = type;\n-    if (type == T_LONG || type == T_DOUBLE) {\n-      sig_bt[index++] = T_VOID; \/\/ Longs & doubles take 2 Java slots\n+  \/\/ Compute the scalarized calling conventions if there are scalarized inline types in the signature\n+  if (has_scalarized && !_method->is_native()) {\n+    _regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc->length());\n+    _args_on_stack_cc = SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);\n+\n+    _regs_cc_ro = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc_ro->length());\n+    _args_on_stack_cc_ro = SharedRuntime::java_calling_convention(_sig_cc_ro, _regs_cc_ro);\n+\n+    _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n+    _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n+\n+    \/\/ Upper bound on stack arguments to avoid hitting the argument limit and\n+    \/\/ bailing out of compilation (\"unsupported incoming calling sequence\").\n+    \/\/ TODO we need a reasonable limit (flag?) here\n+    if (MAX2(_args_on_stack_cc, _args_on_stack_cc_ro) <= 60) {\n+      return; \/\/ Success\n@@ -2907,1 +3123,10 @@\n-};\n+\n+  \/\/ No scalarized args\n+  _sig_cc = _sig;\n+  _regs_cc = _regs;\n+  _args_on_stack_cc = _args_on_stack;\n+\n+  _sig_cc_ro = _sig;\n+  _regs_cc_ro = _regs;\n+  _args_on_stack_cc_ro = _args_on_stack;\n+}\n@@ -2925,2 +3150,9 @@\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n+  CompiledEntrySignature ces(method());\n+  ces.compute_calling_conventions();\n+  if (ces.has_scalarized_args()) {\n+    method->set_has_scalarized_args(true);\n+    method->set_c1_needs_stack_repair(ces.c1_needs_stack_repair());\n+    method->set_c2_needs_stack_repair(ces.c2_needs_stack_repair());\n+  } else if (method->is_abstract()) {\n+    return _abstract_method_handler;\n+  }\n@@ -2928,4 +3160,0 @@\n-  AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(),\n-                              method->is_static(), total_args_passed);\n-  assert(si.slots() == total_args_passed, \"\");\n-  BasicType* sig_bt = si.basic_types();\n@@ -2935,0 +3163,13 @@\n+    if (ces.has_scalarized_args() && method->is_abstract()) {\n+      \/\/ Save a C heap allocated version of the signature for abstract methods with scalarized inline type arguments\n+      address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+      entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n+                                               StubRoutines::throw_AbstractMethodError_entry(),\n+                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                                               wrong_method_abstract, wrong_method_abstract);\n+      GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(ces.sig_cc_ro().length(), mtInternal);\n+      heap_sig->appendAll(&ces.sig_cc_ro());\n+      entry->set_sig_cc(heap_sig);\n+      return entry;\n+    }\n+\n@@ -2936,1 +3177,1 @@\n-    entry = _adapters->lookup(total_args_passed, sig_bt);\n+    entry = _adapters->lookup(&ces.sig_cc(), ces.has_inline_recv());\n@@ -2942,1 +3183,1 @@\n-        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, false);\n+        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, ces, false);\n@@ -2952,1 +3193,1 @@\n-    entry = create_adapter(new_adapter, total_args_passed, sig_bt, \/* allocate_code_blob *\/ true);\n+    entry = create_adapter(new_adapter, ces, \/* allocate_code_blob *\/ true);\n@@ -2963,2 +3204,1 @@\n-                                                           int total_args_passed,\n-                                                           BasicType* sig_bt,\n+                                                           CompiledEntrySignature& ces,\n@@ -2973,5 +3213,0 @@\n-  VMRegPair stack_regs[16];\n-  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n-\n-  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n-  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2985,1 +3220,1 @@\n-  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);\n+  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(&ces.sig_cc(), ces.has_inline_recv());\n@@ -2988,5 +3223,17 @@\n-                                                total_args_passed,\n-                                                comp_args_on_stack,\n-                                                sig_bt,\n-                                                regs,\n-                                                fingerprint);\n+                                                ces.args_on_stack(),\n+                                                &ces.sig(),\n+                                                ces.regs(),\n+                                                &ces.sig_cc(),\n+                                                ces.regs_cc(),\n+                                                &ces.sig_cc_ro(),\n+                                                ces.regs_cc_ro(),\n+                                                fingerprint,\n+                                                new_adapter,\n+                                                allocate_code_blob);\n+\n+  if (ces.has_scalarized_args()) {\n+    \/\/ Save a C heap allocated version of the scalarized signature and store it in the adapter\n+    GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(ces.sig_cc().length(), mtInternal);\n+    heap_sig->appendAll(&ces.sig_cc());\n+    entry->set_sig_cc(heap_sig);\n+  }\n@@ -3003,1 +3250,0 @@\n-  new_adapter = AdapterBlob::create(&buffer);\n@@ -3044,0 +3290,2 @@\n+  assert(base <= _c2i_inline_entry || _c2i_inline_entry == NULL, \"\");\n+  assert(base <= _c2i_inline_ro_entry || _c2i_inline_ro_entry == NULL, \"\");\n@@ -3045,0 +3293,1 @@\n+  assert(base <= _c2i_unverified_inline_entry || _c2i_unverified_inline_entry == NULL, \"\");\n@@ -3057,0 +3306,4 @@\n+  if (_c2i_inline_entry != NULL)\n+    _c2i_inline_entry += delta;\n+  if (_c2i_inline_ro_entry != NULL)\n+    _c2i_inline_ro_entry += delta;\n@@ -3059,0 +3312,2 @@\n+  if (_c2i_unverified_inline_entry != NULL)\n+    _c2i_unverified_inline_entry += delta;\n@@ -3067,0 +3322,3 @@\n+  if (_sig_cc != NULL) {\n+    delete _sig_cc;\n+  }\n@@ -3146,0 +3404,1 @@\n+      BasicType stack_sig_bt[16];\n@@ -3147,0 +3406,1 @@\n+      BasicType* sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n@@ -3149,5 +3409,13 @@\n-      AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(),\n-                              method->is_static(), total_args_passed);\n-      BasicType* sig_bt = si.basic_types();\n-      assert(si.slots() == total_args_passed, \"\");\n-      BasicType ret_type = si.return_type();\n+      int i = 0;\n+      if (!method->is_static()) {  \/\/ Pass in receiver first\n+        sig_bt[i++] = T_OBJECT;\n+      }\n+      SignatureStream ss(method->signature());\n+      for (; !ss.at_return_type(); ss.next()) {\n+        sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+        if (ss.type() == T_LONG || ss.type() == T_DOUBLE) {\n+          sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+        }\n+      }\n+      assert(i == total_args_passed, \"\");\n+      BasicType ret_type = ss.type();\n@@ -3383,0 +3651,9 @@\n+  if (get_c2i_entry() != NULL) {\n+    st->print(\" c2iVE: \" INTPTR_FORMAT, p2i(get_c2i_inline_entry()));\n+  }\n+  if (get_c2i_entry() != NULL) {\n+    st->print(\" c2iVROE: \" INTPTR_FORMAT, p2i(get_c2i_inline_ro_entry()));\n+  }\n+  if (get_c2i_unverified_entry() != NULL) {\n+    st->print(\" c2iUE: \" INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));\n+  }\n@@ -3384,1 +3661,1 @@\n-    st->print(\" c2iUV: \" INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));\n+    st->print(\" c2iUVE: \" INTPTR_FORMAT, p2i(get_c2i_unverified_inline_entry()));\n@@ -3472,0 +3749,196 @@\n+\n+\/\/ We are at a compiled code to interpreter call. We need backing\n+\/\/ buffers for all inline type arguments. Allocate an object array to\n+\/\/ hold them (convenient because once we're done with it we don't have\n+\/\/ to worry about freeing it).\n+oop SharedRuntime::allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS) {\n+  assert(InlineTypePassFieldsAsArgs, \"no reason to call this\");\n+  ResourceMark rm;\n+\n+  int nb_slots = 0;\n+  InstanceKlass* holder = callee->method_holder();\n+  allocate_receiver &= !callee->is_static() && holder->is_inline_klass() && callee->is_scalarized_arg(0);\n+  if (allocate_receiver) {\n+    nb_slots++;\n+  }\n+  int arg_num = callee->is_static() ? 0 : 1;\n+  for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {\n+    BasicType bt = ss.type();\n+    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+      nb_slots++;\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n+  }\n+  objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);\n+  objArrayHandle array(THREAD, array_oop);\n+  arg_num = callee->is_static() ? 0 : 1;\n+  int i = 0;\n+  if (allocate_receiver) {\n+    InlineKlass* vk = InlineKlass::cast(holder);\n+    oop res = vk->allocate_instance(CHECK_NULL);\n+    array->obj_at_put(i++, res);\n+  }\n+  for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {\n+    BasicType bt = ss.type();\n+    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+      InlineKlass* vk = ss.as_inline_klass(holder);\n+      assert(vk != NULL, \"Unexpected klass\");\n+      oop res = vk->allocate_instance(CHECK_NULL);\n+      array->obj_at_put(i++, res);\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n+  }\n+  return array();\n+}\n+\n+JRT_ENTRY(void, SharedRuntime::allocate_inline_types(JavaThread* current, Method* callee_method, bool allocate_receiver))\n+  methodHandle callee(current, callee_method);\n+  oop array = SharedRuntime::allocate_inline_types_impl(current, callee, allocate_receiver, CHECK);\n+  current->set_vm_result(array);\n+  current->set_vm_result_2(callee()); \/\/ TODO: required to keep callee live?\n+JRT_END\n+\n+\/\/ We're returning from an interpreted method: load each field into a\n+\/\/ register following the calling convention\n+JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res))\n+{\n+  assert(res->klass()->is_inline_klass(), \"only inline types here\");\n+  ResourceMark rm;\n+  RegisterMap reg_map(current,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame stubFrame = current->last_frame();\n+  frame callerFrame = stubFrame.sender(&reg_map);\n+  assert(callerFrame.is_interpreted_frame(), \"should be coming from interpreter\");\n+\n+  InlineKlass* vk = InlineKlass::cast(res->klass());\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  if (regs == NULL) {\n+    \/\/ The fields of the inline klass don't fit in registers, bail out\n+    return;\n+  }\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    address loc = reg_map.location(pair.first(), nullptr);\n+    switch(bt) {\n+    case T_BOOLEAN:\n+      *(jboolean*)loc = res->bool_field(off);\n+      break;\n+    case T_CHAR:\n+      *(jchar*)loc = res->char_field(off);\n+      break;\n+    case T_BYTE:\n+      *(jbyte*)loc = res->byte_field(off);\n+      break;\n+    case T_SHORT:\n+      *(jshort*)loc = res->short_field(off);\n+      break;\n+    case T_INT: {\n+      *(jint*)loc = res->int_field(off);\n+      break;\n+    }\n+    case T_LONG:\n+#ifdef _LP64\n+      *(intptr_t*)loc = res->long_field(off);\n+#else\n+      Unimplemented();\n+#endif\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY: {\n+      *(oop*)loc = res->obj_field(off);\n+      break;\n+    }\n+    case T_FLOAT:\n+      *(jfloat*)loc = res->float_field(off);\n+      break;\n+    case T_DOUBLE:\n+      *(jdouble*)loc = res->double_field(off);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+#ifdef ASSERT\n+  VMRegPair pair = regs->at(0);\n+  address loc = reg_map.location(pair.first(), nullptr);\n+  assert(*(oopDesc**)loc == res, \"overwritten object\");\n+#endif\n+\n+  current->set_vm_result(res);\n+}\n+JRT_END\n+\n+\/\/ We've returned to an interpreted method, the interpreter needs a\n+\/\/ reference to an inline type instance. Allocate it and initialize it\n+\/\/ from field's values in registers.\n+JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* current, intptr_t res))\n+{\n+  ResourceMark rm;\n+  RegisterMap reg_map(current,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame stubFrame = current->last_frame();\n+  frame callerFrame = stubFrame.sender(&reg_map);\n+\n+#ifdef ASSERT\n+  InlineKlass* verif_vk = InlineKlass::returned_inline_klass(reg_map);\n+#endif\n+\n+  if (!is_set_nth_bit(res, 0)) {\n+    \/\/ We're not returning with inline type fields in registers (the\n+    \/\/ calling convention didn't allow it for this inline klass)\n+    assert(!Metaspace::contains((void*)res), \"should be oop or pointer in buffer area\");\n+    current->set_vm_result((oopDesc*)res);\n+    assert(verif_vk == NULL, \"broken calling convention\");\n+    return;\n+  }\n+\n+  clear_nth_bit(res, 0);\n+  InlineKlass* vk = (InlineKlass*)res;\n+  assert(verif_vk == vk, \"broken calling convention\");\n+  assert(Metaspace::contains((void*)res), \"should be klass\");\n+\n+  \/\/ Allocate handles for every oop field so they are safe in case of\n+  \/\/ a safepoint when allocating\n+  GrowableArray<Handle> handles;\n+  vk->save_oop_fields(reg_map, handles);\n+\n+  \/\/ It's unsafe to safepoint until we are here\n+  JRT_BLOCK;\n+  {\n+    JavaThread* THREAD = current;\n+    oop vt = vk->realloc_result(reg_map, handles, CHECK);\n+    current->set_vm_result(vt);\n+  }\n+  JRT_BLOCK_END;\n+}\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":618,"deletions":145,"binary":false,"changes":763,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"asm\/codeBuffer.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -41,0 +43,1 @@\n+class SigEntry;\n@@ -55,1 +58,1 @@\n-  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS);\n+  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS);\n@@ -65,1 +68,0 @@\n-  static address             _resolve_static_call_entry;\n@@ -86,1 +88,0 @@\n-\n@@ -318,1 +319,1 @@\n-  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS);\n@@ -326,1 +327,1 @@\n-                                             bool& needs_ic_stub_refill, TRAPS);\n+                                             bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS);\n@@ -332,1 +333,1 @@\n-  static methodHandle reresolve_call_site(TRAPS);\n+  static methodHandle reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -336,1 +337,1 @@\n-  static methodHandle handle_ic_miss_helper(TRAPS);\n+  static methodHandle handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -345,0 +346,13 @@\n+  static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {\n+    assert(callee_method->verified_code_entry() != NULL, \"Jump to zero!\");\n+    assert(callee_method->verified_inline_code_entry() != NULL, \"Jump to zero!\");\n+    assert(callee_method->verified_inline_ro_code_entry() != NULL, \"Jump to zero!\");\n+    if (caller_is_c1) {\n+      return callee_method->verified_inline_code_entry();\n+    } else if (is_static_call || is_optimized) {\n+      return callee_method->verified_code_entry();\n+    } else {\n+      return callee_method->verified_inline_ro_code_entry();\n+    }\n+  }\n+\n@@ -367,0 +381,8 @@\n+  static int java_calling_convention(const GrowableArray<SigEntry>* sig, VMRegPair* regs) {\n+    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig->length());\n+    int total_args_passed = SigEntry::fill_sig_bt(sig, sig_bt);\n+    return java_calling_convention(sig_bt, regs, total_args_passed);\n+  }\n+  static int java_return_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);\n+  static const uint java_return_convention_max_int;\n+  static const uint java_return_convention_max_float;\n@@ -414,6 +436,11 @@\n-  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *_masm,\n-                                                      int total_args_passed,\n-                                                      int max_arg,\n-                                                      const BasicType *sig_bt,\n-                                                      const VMRegPair *regs,\n-                                                      AdapterFingerPrint* fingerprint);\n+  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *masm,\n+                                                      int comp_args_on_stack,\n+                                                      const GrowableArray<SigEntry>* sig,\n+                                                      const VMRegPair* regs,\n+                                                      const GrowableArray<SigEntry>* sig_cc,\n+                                                      const VMRegPair* regs_cc,\n+                                                      const GrowableArray<SigEntry>* sig_cc_ro,\n+                                                      const VMRegPair* regs_cc_ro,\n+                                                      AdapterFingerPrint* fingerprint,\n+                                                      AdapterBlob*& new_adapter,\n+                                                      bool allocate_code_blob);\n@@ -422,2 +449,1 @@\n-                              int total_args_passed,\n-                              const BasicType *sig_bt,\n+                              const GrowableArray<SigEntry>* sig,\n@@ -497,0 +523,3 @@\n+  static void load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res);\n+  static void store_inline_type_fields_to_buf(JavaThread* current, intptr_t res);\n+\n@@ -507,0 +536,2 @@\n+  static void allocate_inline_types(JavaThread* current, Method* callee, bool allocate_receiver);\n+  static oop allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS);\n@@ -510,0 +541,1 @@\n+  static BufferedInlineTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);\n@@ -622,0 +654,2 @@\n+  address _c2i_inline_entry;\n+  address _c2i_inline_ro_entry;\n@@ -623,0 +657,1 @@\n+  address _c2i_unverified_inline_entry;\n@@ -625,0 +660,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  const GrowableArray<SigEntry>* _sig_cc;\n+\n@@ -632,1 +670,2 @@\n-  void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {\n+  void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_inline_entry,\n+            address c2i_inline_ro_entry, address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry) {\n@@ -636,0 +675,2 @@\n+    _c2i_inline_entry = c2i_inline_entry;\n+    _c2i_inline_ro_entry = c2i_inline_ro_entry;\n@@ -637,0 +678,1 @@\n+    _c2i_unverified_inline_entry = c2i_unverified_inline_entry;\n@@ -638,0 +680,1 @@\n+    _sig_cc = NULL;\n@@ -649,4 +692,7 @@\n-  address get_i2c_entry()                  const { return _i2c_entry; }\n-  address get_c2i_entry()                  const { return _c2i_entry; }\n-  address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }\n-  address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }\n+  address get_i2c_entry()                   const { return _i2c_entry; }\n+  address get_c2i_entry()                   const { return _c2i_entry; }\n+  address get_c2i_inline_entry()            const { return _c2i_inline_entry; }\n+  address get_c2i_inline_ro_entry()         const { return _c2i_inline_ro_entry; }\n+  address get_c2i_unverified_entry()        const { return _c2i_unverified_entry; }\n+  address get_c2i_unverified_inline_entry() const { return _c2i_unverified_inline_entry; }\n+  address get_c2i_no_clinit_check_entry()   const { return _c2i_no_clinit_check_entry; }\n@@ -657,0 +703,4 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  void set_sig_cc(const GrowableArray<SigEntry>* sig)  { _sig_cc = sig; }\n+  const GrowableArray<SigEntry>* get_sig_cc()    const { return _sig_cc; }\n+\n@@ -673,0 +723,2 @@\n+class CompiledEntrySignature;\n+\n@@ -688,2 +740,1 @@\n-                                             int total_args_passed,\n-                                             BasicType* sig_bt,\n+                                             CompiledEntrySignature& ces,\n@@ -695,4 +746,2 @@\n-                                        address i2c_entry,\n-                                        address c2i_entry,\n-                                        address c2i_unverified_entry,\n-                                        address c2i_no_clinit_check_entry = NULL);\n+                                        address i2c_entry, address c2i_entry, address c2i_inline_entry, address c2i_inline_ro_entry,\n+                                        address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry = NULL);\n@@ -711,0 +760,55 @@\n+\/\/ Utility class for computing the calling convention of the 3 types\n+\/\/ of compiled method entries:\n+\/\/     Method::_from_compiled_entry               - sig_cc\n+\/\/     Method::_from_compiled_inline_ro_entry     - sig_cc_ro\n+\/\/     Method::_from_compiled_inline_entry        - sig\n+class CompiledEntrySignature : public StackObj {\n+  Method* _method;\n+  int  _num_inline_args;\n+  bool _has_inline_recv;\n+  GrowableArray<SigEntry> *_sig;\n+  GrowableArray<SigEntry> *_sig_cc;\n+  GrowableArray<SigEntry> *_sig_cc_ro;\n+  VMRegPair* _regs;\n+  VMRegPair* _regs_cc;\n+  VMRegPair* _regs_cc_ro;\n+\n+  int _args_on_stack;\n+  int _args_on_stack_cc;\n+  int _args_on_stack_cc_ro;\n+\n+  bool _c1_needs_stack_repair;\n+  bool _c2_needs_stack_repair;\n+\n+public:\n+  Method* method()                     const { return _method; }\n+\n+  \/\/ Used by Method::_from_compiled_inline_entry\n+  GrowableArray<SigEntry>& sig()       const { return *_sig; }\n+\n+  \/\/ Used by Method::_from_compiled_entry\n+  GrowableArray<SigEntry>& sig_cc()    const { return *_sig_cc; }\n+\n+  \/\/ Used by Method::_from_compiled_inline_ro_entry\n+  GrowableArray<SigEntry>& sig_cc_ro() const { return *_sig_cc_ro; }\n+\n+  VMRegPair* regs()                    const { return _regs; }\n+  VMRegPair* regs_cc()                 const { return _regs_cc; }\n+  VMRegPair* regs_cc_ro()              const { return _regs_cc_ro; }\n+\n+  int args_on_stack()                  const { return _args_on_stack; }\n+  int args_on_stack_cc()               const { return _args_on_stack_cc; }\n+  int args_on_stack_cc_ro()            const { return _args_on_stack_cc_ro; }\n+\n+  int  num_inline_args()               const { return _num_inline_args; }\n+  bool has_inline_recv()               const { return _has_inline_recv; }\n+\n+  bool has_scalarized_args()           const { return _sig != _sig_cc; }\n+  bool c1_needs_stack_repair()         const { return _c1_needs_stack_repair; }\n+  bool c2_needs_stack_repair()         const { return _c2_needs_stack_repair; }\n+  CodeOffsets::Entries c1_inline_ro_entry_type() const;\n+\n+  CompiledEntrySignature(Method* method = NULL);\n+  void compute_calling_conventions(bool init = true);\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":130,"deletions":26,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -52,1 +54,1 @@\n-\/\/ FieldType  = \"B\" | \"C\" | \"D\" | \"F\" | \"I\" | \"J\" | \"S\" | \"Z\" | \"L\" ClassName \";\" | \"[\" FieldType.\n+\/\/ FieldType  = \"B\" | \"C\" | \"D\" | \"F\" | \"I\" | \"J\" | \"S\" | \"Z\" | \"L\" ClassName \";\" | \"Q\" ValueClassName \";\" | \"[\" FieldType.\n@@ -250,0 +252,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -336,0 +339,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -415,0 +419,1 @@\n+  case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n@@ -496,0 +501,14 @@\n+InlineKlass* SignatureStream::as_inline_klass(InstanceKlass* holder) {\n+  ThreadInVMfromUnknown __tiv;\n+  JavaThread* THREAD = JavaThread::current();\n+  Handle class_loader(THREAD, holder->class_loader());\n+  Handle protection_domain(THREAD, holder->protection_domain());\n+  Klass* k = as_klass(class_loader, protection_domain, SignatureStream::CachedOrNull, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Should never throw\");\n+  if (k != NULL && k->is_inline_klass()) {\n+    return InlineKlass::cast(k);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n@@ -535,1 +554,2 @@\n-  return klass->java_mirror();\n+  return has_Q_descriptor() ? InlineKlass::cast(klass)->val_mirror()\n+                            : klass->java_mirror();\n@@ -592,1 +612,0 @@\n-\n@@ -611,1 +630,1 @@\n-bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {\n+bool SignatureVerifier::is_valid_method_signature(const Symbol* sig) {\n@@ -634,1 +653,1 @@\n-bool SignatureVerifier::is_valid_type_signature(Symbol* sig) {\n+bool SignatureVerifier::is_valid_type_signature(const Symbol* sig) {\n@@ -663,0 +682,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -681,0 +701,53 @@\n+\n+\/\/ Adds an argument to the signature\n+void SigEntry::add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* symbol, int offset) {\n+  sig->append(SigEntry(bt, offset, symbol));\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    sig->append(SigEntry(T_VOID, offset, symbol)); \/\/ Longs and doubles take two stack slots\n+  }\n+}\n+\n+\/\/ Returns true if the argument at index 'i' is not an inline type delimiter\n+bool SigEntry::skip_value_delimiters(const GrowableArray<SigEntry>* sig, int i) {\n+  return (sig->at(i)._bt != T_PRIMITIVE_OBJECT &&\n+          (sig->at(i)._bt != T_VOID || sig->at(i-1)._bt == T_LONG || sig->at(i-1)._bt == T_DOUBLE));\n+}\n+\n+\/\/ Fill basic type array from signature array\n+int SigEntry::fill_sig_bt(const GrowableArray<SigEntry>* sig, BasicType* sig_bt) {\n+  int count = 0;\n+  for (int i = 0; i < sig->length(); i++) {\n+    if (skip_value_delimiters(sig, i)) {\n+      sig_bt[count++] = sig->at(i)._bt;\n+    }\n+  }\n+  return count;\n+}\n+\n+\/\/ Create a temporary symbol from the signature array\n+TempNewSymbol SigEntry::create_symbol(const GrowableArray<SigEntry>* sig) {\n+  ResourceMark rm;\n+  int length = sig->length();\n+  char* sig_str = NEW_RESOURCE_ARRAY(char, 2*length + 3);\n+  int idx = 0;\n+  sig_str[idx++] = '(';\n+  for (int i = 0; i < length; i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT || bt == T_VOID) {\n+      \/\/ Ignore\n+    } else {\n+      if (bt == T_ARRAY) {\n+        bt = T_OBJECT; \/\/ We don't know the element type, treat as Object\n+      }\n+      sig_str[idx++] = type2char(bt);\n+      if (bt == T_OBJECT) {\n+        sig_str[idx++] = ';';\n+      }\n+    }\n+  }\n+  sig_str[idx++] = ')';\n+  \/\/ Add a dummy return type. It won't be used but SignatureStream needs it.\n+  sig_str[idx++] = 'V';\n+  sig_str[idx++] = '\\0';\n+  return SymbolTable::new_symbol(sig_str);\n+}\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":78,"deletions":5,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -127,1 +128,1 @@\n-    return (signature_char == JVM_SIGNATURE_CLASS);\n+    return (signature_char == JVM_SIGNATURE_CLASS) || (signature_char == JVM_SIGNATURE_PRIMITIVE_OBJECT);\n@@ -272,1 +273,2 @@\n-    case T_OBJECT:  type_name(\"jobject\" ); break;\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT:  type_name(\"jobject\" ); break;\n@@ -421,0 +423,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -534,0 +537,4 @@\n+  bool has_Q_descriptor() const {\n+    return has_envelope() && (_signature->char_at(_begin) == JVM_SIGNATURE_PRIMITIVE_OBJECT);\n+  }\n+\n@@ -576,0 +583,1 @@\n+\n@@ -577,0 +585,1 @@\n+  InlineKlass* as_inline_klass(InstanceKlass* holder);\n@@ -580,0 +589,51 @@\n+class SigEntryFilter;\n+typedef GrowableArrayFilterIterator<SigEntry, SigEntryFilter> ExtendedSignature;\n+\n+\/\/ Used for adapter generation. One SigEntry is used per element of\n+\/\/ the signature of the method. Inline type arguments are treated\n+\/\/ specially. See comment for InlineKlass::collect_fields().\n+class SigEntry {\n+ public:\n+  BasicType _bt;\n+  int _offset;\n+  Symbol* _symbol;\n+\n+  SigEntry()\n+    : _bt(T_ILLEGAL), _offset(-1), _symbol(NULL) {}\n+\n+  SigEntry(BasicType bt, int offset, Symbol* symbol)\n+    : _bt(bt), _offset(offset), _symbol(symbol) {}\n+\n+  static int compare(SigEntry* e1, SigEntry* e2) {\n+    if (e1->_offset != e2->_offset) {\n+      return e1->_offset - e2->_offset;\n+    }\n+    assert((e1->_bt == T_LONG && (e2->_bt == T_LONG || e2->_bt == T_VOID)) ||\n+           (e1->_bt == T_DOUBLE && (e2->_bt == T_DOUBLE || e2->_bt == T_VOID)) ||\n+           e1->_bt == T_PRIMITIVE_OBJECT || e2->_bt == T_PRIMITIVE_OBJECT || e1->_bt == T_VOID || e2->_bt == T_VOID, \"bad bt\");\n+    if (e1->_bt == e2->_bt) {\n+      assert(e1->_bt == T_PRIMITIVE_OBJECT || e1->_bt == T_VOID, \"only ones with duplicate offsets\");\n+      return 0;\n+    }\n+    if (e1->_bt == T_VOID ||\n+        e2->_bt == T_PRIMITIVE_OBJECT) {\n+      return 1;\n+    }\n+    if (e1->_bt == T_PRIMITIVE_OBJECT ||\n+        e2->_bt == T_VOID) {\n+      return -1;\n+    }\n+    ShouldNotReachHere();\n+    return 0;\n+  }\n+  static void add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* symbol, int offset = -1);\n+  static bool skip_value_delimiters(const GrowableArray<SigEntry>* sig, int i);\n+  static int fill_sig_bt(const GrowableArray<SigEntry>* sig, BasicType* sig_bt);\n+  static TempNewSymbol create_symbol(const GrowableArray<SigEntry>* sig);\n+};\n+\n+class SigEntryFilter {\n+public:\n+  bool operator()(const SigEntry& entry) { return entry._bt != T_PRIMITIVE_OBJECT && entry._bt != T_VOID; }\n+};\n+\n@@ -651,1 +711,1 @@\n- #ifdef ASSERT\n+#ifdef ASSERT\n@@ -654,2 +714,2 @@\n-    static bool is_valid_method_signature(Symbol* sig);\n-    static bool is_valid_type_signature(Symbol* sig);\n+    static bool is_valid_method_signature(const Symbol* sig);\n+    static bool is_valid_type_signature(const Symbol* sig);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":65,"deletions":5,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -61,8 +61,1 @@\n-  return create_stack_value(sv, stack_value_address(fr, reg_map, sv), reg_map);\n-}\n-\n-template StackValue* StackValue::create_stack_value(ScopeValue*, address, const RegisterMap*);\n-template StackValue* StackValue::create_stack_value(ScopeValue*, address, const SmallRegisterMap*);\n-\n-template<typename RegisterMapT>\n-StackValue* StackValue::create_stack_value(ScopeValue* sv, address value_addr, const RegisterMapT* reg_map) {\n+  address value_addr = stack_value_address(fr, reg_map, sv);\n@@ -206,2 +199,9 @@\n-    Handle ov = ((ObjectValue *)sv)->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    ObjectValue* ov = ((ObjectValue *)sv);\n+    bool scalar_replaced = ov->value().is_null();\n+    if (ov->maybe_null()) {\n+      \/\/ Don't treat inline type as scalar replaced if it is null\n+      intptr_t is_init_value = StackValue::create_stack_value(fr, reg_map, ov->is_init())->get_int();\n+      jint is_init = (jint)*((jint*)&is_init_value);\n+      scalar_replaced &= (is_init != 0);\n+    }\n+    return new StackValue(ov->value(), scalar_replaced ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -173,0 +173,3 @@\n+address StubRoutines::_load_inline_type_fields_in_regs = NULL;\n+address StubRoutines::_store_inline_type_fields_to_buf = NULL;\n+\n@@ -508,0 +511,1 @@\n+  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,0 +263,3 @@\n+  static address _load_inline_type_fields_in_regs;\n+  static address _store_inline_type_fields_to_buf;\n+\n@@ -460,0 +463,3 @@\n+\n+  static address load_inline_type_fields_in_regs() { return _load_inline_type_fields_in_regs; }\n+  static address store_inline_type_fields_to_buf() { return _store_inline_type_fields_to_buf; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,0 +280,14 @@\n+#define CHECK_THROW_NOSYNC_IMSE(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;           \\\n+    ResourceMark rm(THREAD);                \\\n+    THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n+#define CHECK_THROW_NOSYNC_IMSE_0(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;             \\\n+    ResourceMark rm(THREAD);                  \\\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n@@ -306,0 +320,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -354,0 +369,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -473,0 +489,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -522,0 +539,4 @@\n+    if (EnableValhalla && mark.is_inline_type()) {\n+      return;\n+    }\n+    assert(!EnableValhalla || !object->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -585,0 +606,2 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n+\n@@ -595,0 +618,2 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n+\n@@ -615,0 +640,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -634,0 +660,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -672,0 +699,1 @@\n+  CHECK_THROW_NOSYNC_IMSE_0(obj);\n@@ -694,0 +722,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -703,0 +732,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -718,0 +748,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -864,0 +895,4 @@\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+    \/\/ VM should be calling bootstrap method\n+    ShouldNotReachHere();\n+  }\n@@ -975,6 +1010,0 @@\n-\/\/ Deprecated -- use FastHashCode() instead.\n-\n-intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {\n-  return FastHashCode(Thread::current(), obj());\n-}\n-\n@@ -984,0 +1013,3 @@\n+  if (EnableValhalla && h_obj->mark().is_inline_type()) {\n+    return false;\n+  }\n@@ -1218,0 +1250,4 @@\n+  if (EnableValhalla) {\n+    guarantee(!object->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -476,0 +476,1 @@\n+    case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+  template(ClassPrintLayout)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -512,0 +512,4 @@\n+\n+void VM_PrintClassLayout::doit() {\n+  PrintClassLayout::print_class_layout(_out, _class_name);\n+}\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,0 +260,10 @@\n+class VM_PrintClassLayout: public VM_Operation {\n+ private:\n+  outputStream* _out;\n+  char* _class_name;\n+ public:\n+  VM_PrintClassLayout(outputStream* st, char* class_name): _out(st), _class_name(class_name) {}\n+  VMOp_Type type() const { return VMOp_PrintClassHierarchy; }\n+  void doit();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -225,1 +227,1 @@\n-  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ObjArrayKlass*)                        \\\n+  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ArrayKlass*)                        \\\n@@ -240,1 +242,1 @@\n-  nonstatic_field(InstanceKlass,               _misc_flags,                                   u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _misc_flags,                                   u4)                                    \\\n@@ -1232,0 +1234,1 @@\n+           declare_type(FlatArrayKlass, ArrayKlass)                       \\\n@@ -1235,0 +1238,1 @@\n+        declare_type(InlineKlass, InstanceKlass)                          \\\n@@ -1610,0 +1614,1 @@\n+  declare_c2_type(MachVEPNode, MachIdealNode)                             \\\n@@ -2306,0 +2311,2 @@\n+  declare_constant(InstanceKlass::_misc_carries_identity_modifier)        \\\n+  declare_constant(InstanceKlass::_misc_carries_value_modifier)           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintClassLayoutDCmd>(full_export, true, false));\n@@ -145,1 +146,0 @@\n-\n@@ -934,1 +934,25 @@\n-#endif\n+\n+PrintClassLayoutDCmd::PrintClassLayoutDCmd(outputStream* output, bool heap) :\n+                                       DCmdWithParser(output, heap),\n+  _classname(\"classname\", \"Name of class whose layout should be printed. \",\n+             \"STRING\", true) {\n+  _dcmdparser.add_dcmd_argument(&_classname);\n+}\n+\n+void PrintClassLayoutDCmd::execute(DCmdSource source, TRAPS) {\n+  VM_PrintClassLayout printClassLayoutOp(output(), _classname.value());\n+  VMThread::execute(&printClassLayoutOp);\n+}\n+\n+int PrintClassLayoutDCmd::num_arguments() {\n+  ResourceMark rm;\n+  PrintClassLayoutDCmd* dcmd = new PrintClassLayoutDCmd(NULL, false);\n+  if (dcmd != NULL) {\n+    DCmdMark mark(dcmd);\n+    return dcmd->_dcmdparser.num_arguments();\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_SERVICES\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -389,0 +389,25 @@\n+class PrintClassLayoutDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _classname; \/\/ lass name whose layout should be printed.\n+public:\n+  PrintClassLayoutDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.class_print_layout\";\n+  }\n+  static const char* description() {\n+    return \"Print the layout of an instance of a class, including inlined fields. \"\n+           \"The name of each class is followed by the ClassLoaderData* of its ClassLoader, \"\n+           \"or \\\"null\\\" if loaded by the bootstrap class loader.\";\n+  }\n+  static const char* impact() {\n+      return \"Medium: Depends on number of loaded classes.\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  static int num_arguments();\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -312,0 +315,22 @@\n+ * HPROF_FLAT_ARRAYS        list of flat arrays\n+ *\n+ *               [flat array sub-records]*\n+ *\n+ *               HPROF_FLAT_ARRAY      flat array\n+ *\n+ *                          id         array object ID (dumped as HPROF_GC_PRIM_ARRAY_DUMP)\n+ *                          id         element class ID (dumped by HPROF_GC_CLASS_DUMP)\n+ *\n+ * HPROF_INLINED_FIELDS     decribes inlined fields\n+ *\n+ *               [class with inlined fields sub-records]*\n+ *\n+ *               HPROF_CLASS_WITH_INLINED_FIELDS\n+ *\n+ *                          id         class ID (dumped as HPROF_GC_CLASS_DUMP)\n+ *\n+ *                          u2         number of instance inlined fields (not including super)\n+ *                          [u2,       inlined field index,\n+ *                           u2,       synthetic field count,\n+ *                           id,       original field name,\n+ *                           id]*      inlined field class ID (dumped by HPROF_GC_CLASS_DUMP)\n@@ -349,0 +374,7 @@\n+  \/\/ inlined object support\n+  HPROF_FLAT_ARRAYS             = 0x12,\n+  HPROF_INLINED_FIELDS          = 0x13,\n+  \/\/ inlined object subrecords\n+  HPROF_FLAT_ARRAY                  = 0x01,\n+  HPROF_CLASS_WITH_INLINED_FIELDS   = 0x01,\n+\n@@ -383,0 +415,65 @@\n+\n+class AbstractDumpWriter;\n+\n+class InlinedObjects {\n+\n+  struct ClassInlinedFields {\n+    const Klass *klass;\n+    uintx base_index;   \/\/ base index of the inlined field names (1st field has index base_index+1).\n+    ClassInlinedFields(const Klass *klass = nullptr, uintx base_index = 0) : klass(klass), base_index(base_index) {}\n+\n+    \/\/ For GrowableArray::find_sorted().\n+    static int compare(const ClassInlinedFields& a, const ClassInlinedFields& b) {\n+      return a.klass - b.klass;\n+    }\n+    \/\/ For GrowableArray::sort().\n+    static int compare(ClassInlinedFields* a, ClassInlinedFields* b) {\n+      return compare(*a, *b);\n+    }\n+  };\n+\n+  uintx _min_string_id;\n+  uintx _max_string_id;\n+\n+  GrowableArray<ClassInlinedFields> *_inlined_field_map;\n+\n+  \/\/ counters for classes with inlined fields and for the fields\n+  int _classes_count;\n+  int _inlined_fields_count;\n+\n+  static InlinedObjects *_instance;\n+\n+  static void inlined_field_names_callback(InlinedObjects* _this, const Klass *klass, uintx base_index, int count);\n+\n+  GrowableArray<oop> *_flat_arrays;\n+\n+public:\n+  InlinedObjects()\n+    : _min_string_id(0), _max_string_id(0),\n+    _inlined_field_map(nullptr),\n+    _classes_count(0), _inlined_fields_count(0),\n+    _flat_arrays(nullptr) {\n+  }\n+\n+  static InlinedObjects* get_instance() {\n+    return _instance;\n+  }\n+\n+  void init();\n+  void release();\n+\n+  void dump_inlined_field_names(AbstractDumpWriter *writer);\n+\n+  uintx get_base_index_for(Klass* k);\n+  uintx get_next_string_id(uintx id);\n+\n+  void dump_classed_with_inlined_fields(AbstractDumpWriter* writer);\n+\n+  void add_flat_array(oop array);\n+  void dump_flat_arrays(AbstractDumpWriter* writer);\n+\n+};\n+\n+InlinedObjects *InlinedObjects::_instance = nullptr;\n+\n+\n@@ -895,2 +992,2 @@\n-  \/\/ returns the size of the instance of the given class\n-  static u4 instance_size(Klass* k);\n+  \/\/ calculates the total size of the all fields of the given class.\n+  static u4 instance_size(InstanceKlass* ik);\n@@ -908,2 +1005,8 @@\n-  \/\/ dump the raw values of the instance fields of the given object\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o);\n+  \/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+  \/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+  \/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass* klass);\n+  \/\/ dump the raw values of the instance fields of the given inlined object;\n+  \/\/ dump_instance_fields wrapper for inlined objects\n+  static void dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, InlineKlass* klass);\n+\n@@ -913,1 +1016,1 @@\n-  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* k, uintx *inlined_fields_index = nullptr);\n@@ -923,0 +1026,2 @@\n+  \/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+  static void dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array);\n@@ -930,0 +1035,3 @@\n+  \/\/ extended version to dump flat arrays as primitive arrays;\n+  \/\/ type_size specifies size of the inlined objects.\n+  static int calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size);\n@@ -943,0 +1051,10 @@\n+\n+  \/\/ helper methods for inlined fields.\n+  static bool is_inlined_field(const FieldStream& fld) {\n+    return fld.field_descriptor().is_inlined();\n+  }\n+  static InlineKlass* get_inlined_field_klass(const FieldStream &fld) {\n+    assert(is_inlined_field(fld), \"must be inlined field\");\n+    InstanceKlass* holder_klass = fld.field_descriptor().field_holder();\n+    return InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n+  }\n@@ -956,0 +1074,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: return HPROF_NORMAL_OBJECT; \/\/ not inlined Q-object, i.e. identity object.\n@@ -986,0 +1105,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n@@ -1024,0 +1144,1 @@\n+\n@@ -1028,0 +1149,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ not inlined Q-object, i.e. identity object.\n@@ -1088,3 +1210,2 @@\n-\/\/ returns the size of the instance of the given class\n-u4 DumperSupport::instance_size(Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ calculates the total size of the all fields of the given class.\n+u4 DumperSupport::instance_size(InstanceKlass *ik) {\n@@ -1095,1 +1216,5 @@\n-      size += sig2size(fld.signature());\n+      if (is_inlined_field(fld)) {\n+        size += instance_size(get_inlined_field_klass(fld));\n+      } else {\n+        size += sig2size(fld.signature());\n+      }\n@@ -1107,0 +1232,2 @@\n+      assert(!is_inlined_field(fldc), \"static fields cannot be inlined\");\n+\n@@ -1141,0 +1268,2 @@\n+      assert(!is_inlined_field(fld), \"static fields cannot be inlined\");\n+\n@@ -1169,5 +1298,5 @@\n-\/\/ dump the raw values of the instance fields of the given object\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o) {\n-  InstanceKlass* ik = InstanceKlass::cast(o->klass());\n-\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+\/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+\/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+\/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class.\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass *klass) {\n+  for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n@@ -1175,2 +1304,9 @@\n-      Symbol* sig = fld.signature();\n-      dump_field_value(writer, sig->char_at(0), o, fld.offset());\n+      if (is_inlined_field(fld)) {\n+        InlineKlass* field_klass = get_inlined_field_klass(fld);\n+        \/\/ the field is inlined, so all its fields are stored without headers.\n+        int fields_offset = offset + fld.offset() - field_klass->first_field_offset();\n+        dump_inlined_object_fields(writer, o, offset + fld.offset(), field_klass);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        dump_field_value(writer, sig->char_at(0), o, offset + fld.offset());\n+      }\n@@ -1181,1 +1317,6 @@\n-\/\/ dumps the definition of the instance fields for a given class\n+void DumperSupport::dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, InlineKlass* klass) {\n+  \/\/ the object is inlined, so all its fields are stored without headers.\n+  dump_instance_fields(writer, o, offset - klass->first_field_offset(), klass);\n+}\n+\n+\/\/ gets the count of the instance fields for a given class\n@@ -1186,1 +1327,8 @@\n-    if (!fldc.access_flags().is_static()) field_count++;\n+    if (!fldc.access_flags().is_static()) {\n+      if (is_inlined_field(fldc)) {\n+        \/\/ add \"synthetic\" fields for inlined fields.\n+        field_count += get_instance_fields_count(get_inlined_field_klass(fldc));\n+      } else {\n+        field_count++;\n+      }\n+    }\n@@ -1193,2 +1341,8 @@\n-void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ inlined_fields_id is not-NULL for inlined fields (to get synthetic field name IDs\n+\/\/ by using InlinedObjects::get_next_string_id()).\n+void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* ik, uintx* inlined_fields_id) {\n+  \/\/ inlined_fields_id != NULL means ik is a class of inlined field.\n+  \/\/ Inlined field id pointer for this class; lazyly initialized\n+  \/\/ if the class has inlined field(s) and the caller didn't provide inlined_fields_id.\n+  uintx *this_klass_inlined_fields_id = inlined_fields_id;\n+  uintx inlined_id = 0;\n@@ -1199,1 +1353,23 @@\n-      Symbol* sig = fld.signature();\n+      if (is_inlined_field(fld)) {\n+        \/\/ dump \"synthetic\" fields for inlined fields.\n+        if (this_klass_inlined_fields_id == nullptr) {\n+          inlined_id = InlinedObjects::get_instance()->get_base_index_for(ik);\n+          this_klass_inlined_fields_id = &inlined_id;\n+        }\n+        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld), this_klass_inlined_fields_id);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        Symbol* name = nullptr;\n+        \/\/ Use inlined_fields_id provided by caller.\n+        if (inlined_fields_id != nullptr) {\n+          uintx name_id = InlinedObjects::get_instance()->get_next_string_id(*inlined_fields_id);\n+\n+          \/\/ name_id == 0 is returned on error. use original field signature.\n+          if (name_id != 0) {\n+            *inlined_fields_id = name_id;\n+            name = reinterpret_cast<Symbol*>(name_id);\n+          }\n+        }\n+        if (name == nullptr) {\n+          name = fld.name();\n+        }\n@@ -1201,2 +1377,3 @@\n-      writer->write_symbolID(fld.name());   \/\/ name\n-      writer->write_u1(sig2tag(sig));       \/\/ type\n+        writer->write_symbolID(name);         \/\/ name\n+        writer->write_u1(sig2tag(sig));       \/\/ type\n+      }\n@@ -1224,1 +1401,1 @@\n-  dump_instance_fields(writer, o);\n+  dump_instance_fields(writer, o, 0, ik);\n@@ -1269,1 +1446,1 @@\n-  writer->write_u4(DumperSupport::instance_size(ik));\n+  writer->write_u4(HeapWordSize * ik->size_helper());\n@@ -1323,4 +1500,1 @@\n-int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n-  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n-  assert(type >= T_BOOLEAN && type <= T_OBJECT, \"invalid array element type\");\n-\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size) {\n@@ -1329,7 +1503,0 @@\n-  int type_size;\n-  if (type == T_OBJECT) {\n-    type_size = sizeof(address);\n-  } else {\n-    type_size = type2aelembytes(type);\n-  }\n-\n@@ -1343,0 +1510,1 @@\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n@@ -1349,0 +1517,13 @@\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n+  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+  int type_size;\n+  if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {  \/\/ TODO: FIXME\n+    type_size = sizeof(address);\n+  } else {\n+    type_size = type2aelembytes(type);\n+  }\n+\n+  return calculate_array_max_length(writer, array, type_size, header_size);\n+}\n+\n@@ -1380,0 +1561,40 @@\n+\/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+void DumperSupport::dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array) {\n+  FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* element_klass = array_klass->element_klass();\n+  int element_size = instance_size(element_klass);\n+  \/*                          id         array object ID\n+   *                          u4         stack trace serial number\n+   *                          u4         number of elements\n+   *                          u1         element type\n+   *\/\n+  short header_size = 1 + sizeof(address) + 2 * 4 + 1;\n+\n+  \/\/ TODO: use T_SHORT\/T_INT\/T_LONG if needed to avoid truncation\n+  BasicType type = T_BYTE;\n+  int type_size = type2aelembytes(type);\n+  int length = calculate_array_max_length(writer, array, element_size, header_size);\n+  u4 length_in_bytes = (u4)(length * element_size);\n+  u4 size = header_size + length_in_bytes;\n+\n+  writer->start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);\n+  writer->write_objectID(array);\n+  writer->write_u4(STACK_TRACE_ID);\n+  \/\/ TODO: round up array length for T_SHORT\/T_INT\/T_LONG\n+  writer->write_u4(length * element_size);\n+  writer->write_u1(type2tag(type));\n+\n+  for (int index = 0; index < length; index++) {\n+    \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n+    int offset = (int)((address)array->value_at_addr(index, array_klass->layout_helper())\n+                  - cast_from_oop<address>(array));\n+    dump_inlined_object_fields(writer, array, offset, element_klass);\n+  }\n+\n+  \/\/ TODO: write padding bytes for T_SHORT\/T_INT\/T_LONG\n+\n+  InlinedObjects::get_instance()->add_flat_array(array);\n+\n+  writer->end_sub_record();\n+}\n+\n@@ -1501,0 +1722,264 @@\n+class InlinedFieldNameDumper : public LockedClassesDo {\n+public:\n+  typedef void (*Callback)(InlinedObjects *owner, const Klass *klass, uintx base_index, int count);\n+\n+private:\n+  AbstractDumpWriter* _writer;\n+  InlinedObjects *_owner;\n+  Callback       _callback;\n+  uintx _index;\n+\n+  void dump_inlined_field_names(GrowableArray<Symbol*>* super_names, Symbol* field_name, InlineKlass* klass) {\n+    super_names->push(field_name);\n+    for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+        } else {\n+          \/\/ get next string ID.\n+          uintx next_index = _owner->get_next_string_id(_index);\n+          if (next_index == 0) {\n+            \/\/ something went wrong (overflow?)\n+            \/\/ stop generation; the rest of inlined objects will have original field names.\n+            return;\n+          }\n+          _index = next_index;\n+\n+          \/\/ Calculate length.\n+          int len = fld.name()->utf8_length();\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            len += (*it)->utf8_length() + 1;    \/\/ +1 for \".\".\n+          }\n+\n+          DumperSupport::write_header(_writer, HPROF_UTF8, oopSize + len);\n+          _writer->write_symbolID(reinterpret_cast<Symbol*>(_index));\n+          \/\/ Write the string value.\n+          \/\/ 1) super_names.\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            _writer->write_raw((*it)->bytes(), (*it)->utf8_length());\n+            _writer->write_u1('.');\n+          }\n+          \/\/ 2) field name.\n+          _writer->write_raw(fld.name()->bytes(), fld.name()->utf8_length());\n+        }\n+      }\n+    }\n+    super_names->pop();\n+  }\n+\n+  void dump_inlined_field_names(Symbol* field_name, InlineKlass* field_klass) {\n+    GrowableArray<Symbol*> super_names(4, mtServiceability);\n+    dump_inlined_field_names(&super_names, field_name, field_klass);\n+  }\n+\n+public:\n+  InlinedFieldNameDumper(AbstractDumpWriter* writer, InlinedObjects* owner, Callback callback)\n+    : _writer(writer), _owner(owner), _callback(callback), _index(0)  {\n+  }\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    uintx base_index = _index;\n+    int count = 0;\n+\n+    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+          count++;\n+        }\n+      }\n+    }\n+\n+    if (count != 0) {\n+      _callback(_owner, k, base_index, count);\n+    }\n+  }\n+};\n+\n+class InlinedFieldsDumper : public LockedClassesDo {\n+private:\n+  AbstractDumpWriter* _writer;\n+\n+public:\n+  InlinedFieldsDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    \/\/ We can be at a point where java mirror does not exist yet.\n+    \/\/ So we need to check that the class is at least loaded, to avoid crash from a null mirror.\n+    if (!ik->is_loaded()) {\n+      return;\n+    }\n+\n+    u2 inlined_count = 0;\n+    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          inlined_count++;\n+        }\n+      }\n+    }\n+    if (inlined_count != 0) {\n+      _writer->write_u1(HPROF_CLASS_WITH_INLINED_FIELDS);\n+\n+      \/\/ class ID\n+      _writer->write_classID(ik);\n+      \/\/ number of inlined fields\n+      _writer->write_u2(inlined_count);\n+      u2 index = 0;\n+      for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+        if (!fld.access_flags().is_static()) {\n+          if (DumperSupport::is_inlined_field(fld)) {\n+            \/\/ inlined field index\n+            _writer->write_u2(index);\n+            \/\/ synthetic field count\n+            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld));\n+            _writer->write_u2(field_count);\n+            \/\/ original field name\n+            _writer->write_symbolID(fld.name());\n+            \/\/ inlined field class ID\n+            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld));\n+\n+            index += field_count;\n+          } else {\n+            index++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\n+void InlinedObjects::init() {\n+  _instance = this;\n+\n+  struct Closure : public SymbolClosure {\n+    uintx _min_id = max_uintx;\n+    uintx _max_id = 0;\n+    Closure() : _min_id(max_uintx), _max_id(0) {}\n+\n+    void do_symbol(Symbol** p) {\n+      uintx val = reinterpret_cast<uintx>(*p);\n+      if (val < _min_id) {\n+        _min_id = val;\n+      }\n+      if (val > _max_id) {\n+        _max_id = val;\n+      }\n+    }\n+  } closure;\n+\n+  SymbolTable::symbols_do(&closure);\n+\n+  _min_string_id = closure._min_id;\n+  _max_string_id = closure._max_id;\n+}\n+\n+void InlinedObjects::release() {\n+  _instance = nullptr;\n+\n+  if (_inlined_field_map != nullptr) {\n+    delete _inlined_field_map;\n+    _inlined_field_map = nullptr;\n+  }\n+  if (_flat_arrays != nullptr) {\n+    delete _flat_arrays;\n+    _flat_arrays = nullptr;\n+  }\n+}\n+\n+void InlinedObjects::inlined_field_names_callback(InlinedObjects* _this, const Klass* klass, uintx base_index, int count) {\n+  if (_this->_inlined_field_map == nullptr) {\n+    _this->_inlined_field_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n+  }\n+  _this->_inlined_field_map->append(ClassInlinedFields(klass, base_index));\n+\n+  \/\/ counters for dumping classes with inlined fields\n+  _this->_classes_count++;\n+  _this->_inlined_fields_count += count;\n+}\n+\n+void InlinedObjects::dump_inlined_field_names(AbstractDumpWriter* writer) {\n+  InlinedFieldNameDumper nameDumper(writer, this, inlined_field_names_callback);\n+  ClassLoaderDataGraph::classes_do(&nameDumper);\n+\n+  if (_inlined_field_map != nullptr) {\n+    \/\/ prepare the map for  get_base_index_for().\n+    _inlined_field_map->sort(ClassInlinedFields::compare);\n+  }\n+}\n+\n+uintx InlinedObjects::get_base_index_for(Klass* k) {\n+  if (_inlined_field_map != nullptr) {\n+    bool found = false;\n+    int idx = _inlined_field_map->find_sorted<ClassInlinedFields, ClassInlinedFields::compare>(ClassInlinedFields(k, 0), found);\n+    if (found) {\n+        return _inlined_field_map->at(idx).base_index;\n+    }\n+  }\n+\n+  \/\/ return max_uintx, so get_next_string_id returns 0.\n+  return max_uintx;\n+}\n+\n+uintx InlinedObjects::get_next_string_id(uintx id) {\n+  if (++id == _min_string_id) {\n+    return _max_string_id + 1;\n+  }\n+  return id;\n+}\n+\n+void InlinedObjects::dump_classed_with_inlined_fields(AbstractDumpWriter* writer) {\n+  if (_classes_count != 0) {\n+    \/\/ Record for each class contains tag(u1), class ID and count(u2)\n+    \/\/ for each inlined field index(u2), synthetic fields count(u2), original field name and class ID\n+    int size = _classes_count * (1 + sizeof(address) + 2)\n+             + _inlined_fields_count * (2 + 2 + sizeof(address) + sizeof(address));\n+    DumperSupport::write_header(writer, HPROF_INLINED_FIELDS, (u4)size);\n+\n+    InlinedFieldsDumper dumper(writer);\n+    ClassLoaderDataGraph::classes_do(&dumper);\n+  }\n+}\n+\n+void InlinedObjects::add_flat_array(oop array) {\n+  if (_flat_arrays == nullptr) {\n+    _flat_arrays = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(100, mtServiceability);\n+  }\n+  _flat_arrays->append(array);\n+}\n+\n+void InlinedObjects::dump_flat_arrays(AbstractDumpWriter* writer) {\n+  if (_flat_arrays != nullptr) {\n+    \/\/ For each flat array the record contains tag (u1), object ID and class ID.\n+    int size = _flat_arrays->length() * (1 + sizeof(address) + sizeof(address));\n+\n+    DumperSupport::write_header(writer, HPROF_FLAT_ARRAYS, (u4)size);\n+    for (GrowableArrayIterator<oop> it = _flat_arrays->begin(); it != _flat_arrays->end(); ++it) {\n+      flatArrayOop array = flatArrayOop(*it);\n+      FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+      InlineKlass* element_klass = array_klass->element_klass();\n+      writer->write_u1(HPROF_FLAT_ARRAY);\n+      writer->write_objectID(array);\n+      writer->write_classID(element_klass);\n+    }\n+  }\n+}\n+\n+\n@@ -1723,0 +2208,2 @@\n+  } else if (o->is_flatArray()) {\n+    DumperSupport::dump_flat_array(writer(), flatArrayOop(o));\n@@ -1741,0 +2228,8 @@\n+  } else if (o->is_typeArray()) {\n+    flatArrayOop array = flatArrayOop(o);\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+    assert(type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+    int length = array->length();\n+    \/\/TODO: FIXME\n+    \/\/int type_size = type2aelembytes(type);\n+    \/\/size = (size_t)length * type_size;\n@@ -1813,0 +2308,5 @@\n+\n+  \/\/ Inlined object support.\n+  InlinedObjects          _inlined_objects;\n+  InlinedObjects* inlined_objects() { return &_inlined_objects; }\n+\n@@ -2225,0 +2725,7 @@\n+    \/\/ HPROF_UTF8 records for inlined field names.\n+    inlined_objects()->init();\n+    inlined_objects()->dump_inlined_field_names(writer());\n+\n+    \/\/ HPROF_INLINED_FIELDS\n+    inlined_objects()->dump_classed_with_inlined_fields(writer());\n+\n@@ -2303,0 +2810,3 @@\n+\n+  inlined_objects()->dump_flat_arrays(writer());\n+\n@@ -2305,0 +2815,2 @@\n+\n+  inlined_objects()->release();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":548,"deletions":36,"binary":false,"changes":584,"status":"modified"},{"patch":"@@ -255,0 +255,2 @@\n+#define THREAD_AND_LOCATION_DECL                 TRAPS, const char* file, int line\n+#define THREAD_AND_LOCATION_ARGS                 THREAD, file, line\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  assert(num_type_chars == 11, \"must have tested the right number of mappings\");\n+  assert(num_type_chars == 12, \"must have tested the right number of mappings\");\n@@ -139,0 +139,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -204,0 +205,1 @@\n+  _type2aelembytes[T_PRIMITIVE_OBJECT]  = heapOopSize;\n@@ -215,2 +217,2 @@\n-  JVM_SIGNATURE_VOID,    0,\n-  0, 0, 0, 0\n+  JVM_SIGNATURE_PRIMITIVE_OBJECT, JVM_SIGNATURE_VOID,\n+  0, 0, 0, 0, 0\n@@ -232,0 +234,1 @@\n+  \"inline_type\",\n@@ -251,1 +254,1 @@\n-int type2size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, -1};\n+int type2size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 0, 1, 1, 1, 1, -1};\n@@ -268,6 +271,7 @@\n-  T_VOID,                  \/\/ T_VOID     = 14,\n-  T_ADDRESS,               \/\/ T_ADDRESS  = 15,\n-  T_NARROWOOP,             \/\/ T_NARROWOOP= 16,\n-  T_METADATA,              \/\/ T_METADATA = 17,\n-  T_NARROWKLASS,           \/\/ T_NARROWKLASS = 18,\n-  T_CONFLICT               \/\/ T_CONFLICT = 19,\n+  T_PRIMITIVE_OBJECT,      \/\/ T_PRIMITIVE_OBJECT = 14,\n+  T_VOID,                  \/\/ T_VOID     = 15,\n+  T_ADDRESS,               \/\/ T_ADDRESS  = 16,\n+  T_NARROWOOP,             \/\/ T_NARROWOOP= 17,\n+  T_METADATA,              \/\/ T_METADATA = 18,\n+  T_NARROWKLASS,           \/\/ T_NARROWKLASS = 19,\n+  T_CONFLICT               \/\/ T_CONFLICT = 20\n@@ -292,6 +296,7 @@\n-  T_VOID,    \/\/ T_VOID     = 14,\n-  T_ADDRESS, \/\/ T_ADDRESS  = 15,\n-  T_NARROWOOP, \/\/ T_NARROWOOP  = 16,\n-  T_METADATA,  \/\/ T_METADATA   = 17,\n-  T_NARROWKLASS, \/\/ T_NARROWKLASS  = 18,\n-  T_CONFLICT \/\/ T_CONFLICT = 19,\n+  T_OBJECT,  \/\/ T_PRIMITIVE_OBJECT = 14,\n+  T_VOID,    \/\/ T_VOID     = 15,\n+  T_ADDRESS, \/\/ T_ADDRESS  = 16,\n+  T_NARROWOOP, \/\/ T_NARROWOOP  = 17,\n+  T_METADATA,  \/\/ T_METADATA   = 18,\n+  T_NARROWKLASS, \/\/ T_NARROWKLASS  = 19,\n+  T_CONFLICT \/\/ T_CONFLICT = 20\n@@ -316,6 +321,7 @@\n-  0,                         \/\/ T_VOID     = 14,\n-  T_OBJECT_aelem_bytes,      \/\/ T_ADDRESS  = 15,\n-  T_NARROWOOP_aelem_bytes,   \/\/ T_NARROWOOP= 16,\n-  T_OBJECT_aelem_bytes,      \/\/ T_METADATA = 17,\n-  T_NARROWKLASS_aelem_bytes, \/\/ T_NARROWKLASS= 18,\n-  0                          \/\/ T_CONFLICT = 19,\n+  T_PRIMITIVE_OBJECT_aelem_bytes, \/\/ T_PRIMITIVE_OBJECT = 14,\n+  0,                         \/\/ T_VOID     = 15,\n+  T_OBJECT_aelem_bytes,      \/\/ T_ADDRESS  = 16,\n+  T_NARROWOOP_aelem_bytes,   \/\/ T_NARROWOOP= 17,\n+  T_OBJECT_aelem_bytes,      \/\/ T_METADATA = 18,\n+  T_NARROWKLASS_aelem_bytes, \/\/ T_NARROWKLASS= 19,\n+  0                          \/\/ T_CONFLICT = 20\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -616,0 +616,9 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Prototyping\n+\/\/ \"Code Missing Here\" macro, un-define when integrating back from prototyping stage and break\n+\/\/ compilation on purpose (i.e. \"forget me not\")\n+#define PROTOTYPE\n+#ifdef PROTOTYPE\n+#define CMH(m)\n+#endif\n+\n@@ -701,6 +710,7 @@\n-  T_VOID        = 14,\n-  T_ADDRESS     = 15,\n-  T_NARROWOOP   = 16,\n-  T_METADATA    = 17,\n-  T_NARROWKLASS = 18,\n-  T_CONFLICT    = 19, \/\/ for stack value type with conflicting contents\n+  T_PRIMITIVE_OBJECT = 14,\n+  T_VOID        = 15,\n+  T_ADDRESS     = 16,\n+  T_NARROWOOP   = 17,\n+  T_METADATA    = 18,\n+  T_NARROWKLASS = 19,\n+  T_CONFLICT    = 20, \/\/ for stack value type with conflicting contents\n@@ -721,0 +731,1 @@\n+    F(JVM_SIGNATURE_PRIMITIVE_OBJECT, T_PRIMITIVE_OBJECT, N) \\\n@@ -750,1 +761,1 @@\n-  return (t == T_OBJECT || t == T_ARRAY || (include_narrow_oop && t == T_NARROWOOP));\n+  return (t == T_OBJECT || t == T_ARRAY || t == T_PRIMITIVE_OBJECT || (include_narrow_oop && t == T_NARROWOOP));\n@@ -811,1 +822,2 @@\n-  T_VOID_size        = 0\n+  T_VOID_size        = 0,\n+  T_PRIMITIVE_OBJECT_size = 1\n@@ -841,0 +853,1 @@\n+  T_PRIMITIVE_OBJECT_aelem_bytes = 8,\n@@ -844,0 +857,1 @@\n+  T_PRIMITIVE_OBJECT_aelem_bytes = 4,\n@@ -936,1 +950,1 @@\n-  vtos = 9,             \/\/ tos not cached\n+  vtos = 9,             \/\/ tos not cached,\n@@ -953,1 +967,2 @@\n-    case T_ARRAY  : \/\/ fall through\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n+    case T_ARRAY  :   \/\/ fall through\n@@ -1266,0 +1281,6 @@\n+\/\/ TEMP!!!!\n+\/\/ This should be removed after LW2 arrays are implemented (JDK-8220790).\n+\/\/ It's an alias to (EnableValhalla && (FlatArrayElementMaxSize != 0)),\n+\/\/ which is actually not 100% correct, but works for the current set of C1\/C2\n+\/\/ implementation and test cases.\n+#define UseFlatArray (EnableValhalla && (FlatArrayElementMaxSize != 0))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -73,0 +74,215 @@\n+class StringMatcher {\n+ public:\n+  typedef int getc_function_t(const char* &source, const char* limit);\n+\n+ private:\n+  \/\/ These do not get properly inlined.\n+  \/\/ For full performance, this should be a template class\n+  \/\/ parameterized by two function arguments.\n+  getc_function_t* _pattern_getc;\n+  getc_function_t* _string_getc;\n+\n+ public:\n+  StringMatcher(getc_function_t pattern_getc,\n+                getc_function_t string_getc)\n+    : _pattern_getc(pattern_getc),\n+      _string_getc(string_getc)\n+  { }\n+\n+  enum {  \/\/ special results from _pattern_getc\n+    string_match_comma  = -0x100 + ',',\n+    string_match_star   = -0x100 + '*',\n+    string_match_eos    = -0x100 + '\\0'\n+  };\n+\n+ private:\n+  const char*\n+  skip_anchor_word(const char* match,\n+                   const char* match_end,\n+                   int anchor_length,\n+                   const char* pattern,\n+                   const char* pattern_end) {\n+    assert(pattern < pattern_end && anchor_length > 0, \"\");\n+    const char* begp = pattern;\n+    int ch1 = _pattern_getc(begp, pattern_end);\n+    \/\/ note that begp is now advanced over ch1\n+    assert(ch1 > 0, \"regular char only\");\n+    const char* matchp = match;\n+    const char* limitp = match_end - anchor_length;\n+    while (matchp <= limitp) {\n+      int mch = _string_getc(matchp, match_end);\n+      if (mch == ch1) {\n+        const char* patp = begp;\n+        const char* anchorp = matchp;\n+        while (patp < pattern_end) {\n+          char ch = _pattern_getc(patp, pattern_end);\n+          char mch = _string_getc(anchorp, match_end);\n+          if (mch != ch) {\n+            anchorp = NULL;\n+            break;\n+          }\n+        }\n+        if (anchorp != NULL) {\n+          return anchorp;  \/\/ Found a full copy of the anchor.\n+        }\n+        \/\/ That did not work, so restart the search for ch1.\n+      }\n+    }\n+    return NULL;\n+  }\n+\n+ public:\n+  bool string_match(const char* pattern,\n+                    const char* string) {\n+    return string_match(pattern, pattern + strlen(pattern),\n+                        string, string + strlen(string));\n+  }\n+  bool string_match(const char* pattern, const char* pattern_end,\n+                    const char* string, const char* string_end) {\n+    const char* patp = pattern;\n+    switch (_pattern_getc(patp, pattern_end)) {\n+    case string_match_eos:\n+      return false;  \/\/ Empty pattern is always false.\n+    case string_match_star:\n+      if (patp == pattern_end) {\n+        return true;   \/\/ Lone star pattern is always true.\n+      }\n+      break;\n+    }\n+    patp = pattern;  \/\/ Reset after lookahead.\n+    const char* matchp = string;  \/\/ NULL if failing\n+    for (;;) {\n+      int ch = _pattern_getc(patp, pattern_end);\n+      switch (ch) {\n+      case string_match_eos:\n+      case string_match_comma:\n+        \/\/ End of a list item; see if it's a match.\n+        if (matchp == string_end) {\n+          return true;\n+        }\n+        if (ch == string_match_comma) {\n+          \/\/ Get ready to match the next item.\n+          matchp = string;\n+          continue;\n+        }\n+        return false;  \/\/ End of all items.\n+\n+      case string_match_star:\n+        if (matchp != NULL) {\n+          \/\/ Wildcard:  Parse out following anchor word and look for it.\n+          const char* begp = patp;\n+          const char* endp = patp;\n+          int anchor_len = 0;\n+          for (;;) {\n+            \/\/ get as many following regular characters as possible\n+            endp = patp;\n+            ch = _pattern_getc(patp, pattern_end);\n+            if (ch <= 0) {\n+              break;\n+            }\n+            anchor_len += 1;\n+          }\n+          \/\/ Anchor word [begp..endp) does not contain ch, so back up.\n+          \/\/ Now do an eager match to the anchor word, and commit to it.\n+          patp = endp;\n+          if (ch == string_match_eos ||\n+              ch == string_match_comma) {\n+            \/\/ Anchor word is at end of pattern, so treat it as a fixed pattern.\n+            const char* limitp = string_end - anchor_len;\n+            matchp = limitp;\n+            patp = begp;\n+            \/\/ Resume normal scanning at the only possible match position.\n+            continue;\n+          }\n+          \/\/ Find a floating occurrence of the anchor and continue matching.\n+          \/\/ Note:  This is greedy; there is no backtrack here.  Good enough.\n+          matchp = skip_anchor_word(matchp, string_end, anchor_len, begp, endp);\n+        }\n+        continue;\n+      }\n+      \/\/ Normal character.\n+      if (matchp != NULL) {\n+        int mch = _string_getc(matchp, string_end);\n+        if (mch != ch) {\n+          matchp = NULL;\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Match a wildcarded class list to a proposed class name (in internal form).\n+\/\/ Commas or newlines separate multiple possible matches; stars are shell-style wildcards.\n+class ClassListMatcher : public StringMatcher {\n+ public:\n+  ClassListMatcher()\n+    : StringMatcher(pattern_list_getc, class_name_getc)\n+  { }\n+\n+ private:\n+  static int pattern_list_getc(const char* &pattern_ptr,\n+                               const char* pattern_end) {\n+    if (pattern_ptr == pattern_end) {\n+      return string_match_eos;\n+    }\n+    int ch = (unsigned char) *pattern_ptr++;\n+    switch (ch) {\n+    case ' ': case '\\t': case '\\n': case '\\r':\n+    case ',':\n+      \/\/ End of list item.\n+      for (;;) {\n+        switch (*pattern_ptr) {\n+        case ' ': case '\\t': case '\\n': case '\\r':\n+        case ',':\n+          pattern_ptr += 1;  \/\/ Collapse multiple commas or spaces.\n+          continue;\n+        }\n+        break;\n+      }\n+      return string_match_comma;\n+\n+    case '*':\n+      \/\/ Wildcard, matching any number of chars.\n+      while (*pattern_ptr == '*') {\n+        pattern_ptr += 1;  \/\/ Collapse multiple stars.\n+      }\n+      return string_match_star;\n+\n+    case '.':\n+      ch = '\/';   \/\/ Look for internal form of package separator\n+      break;\n+\n+    case '\\\\':\n+      \/\/ Superquote in pattern escapes * , whitespace, and itself.\n+      if (pattern_ptr < pattern_end) {\n+        ch = (unsigned char) *pattern_ptr++;\n+      }\n+      break;\n+    }\n+\n+    assert(ch > 0, \"regular char only\");\n+    return ch;\n+  }\n+\n+  static int class_name_getc(const char* &name_ptr,\n+                             const char* name_end) {\n+    if (name_ptr == name_end) {\n+      return string_match_eos;\n+    }\n+    int ch = (unsigned char) *name_ptr++;\n+    if (ch == '.') {\n+      ch = '\/';   \/\/ Normalize to internal form of package separator\n+    }\n+    return ch;  \/\/ plain character\n+  }\n+};\n+\n+bool StringUtils::class_list_match(const char* class_pattern_list,\n+                                   const char* class_name) {\n+  if (class_pattern_list == NULL || class_name == NULL || class_name[0] == '\\0')\n+    return false;\n+  ClassListMatcher clm;\n+  return clm.string_match(class_pattern_list, class_name);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":216,"deletions":0,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+  \/\/ Match a wildcarded class list to a proposed class name (in internal form).\n+  \/\/ Commas separate multiple possible matches; stars are shell-style wildcards.\n+  static bool class_list_match(const char* class_list, const char* class_name);\n+\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1187,0 +1187,2 @@\n+            } else if (cl.isValue()) {\n+                throw new NotSerializableException(cl.getName());\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.InaccessibleObjectException;\n@@ -446,0 +447,2 @@\n+            } else if (cl.isValue() && writeReplaceMethod == null) {\n+                deserializeEx = new ExceptionInfo(name, cl.isPrimitiveClass() ? \"primitive class\" : \"value class\");\n@@ -1433,1 +1436,1 @@\n-        } catch (NoSuchMethodException ex) {\n+        } catch (NoSuchMethodException | InaccessibleObjectException ex) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -203,3 +203,5 @@\n-    private static final int ANNOTATION= 0x00002000;\n-    private static final int ENUM      = 0x00004000;\n-    private static final int SYNTHETIC = 0x00001000;\n+    private static final int ANNOTATION = 0x00002000;\n+    private static final int ENUM       = 0x00004000;\n+    private static final int SYNTHETIC  = 0x00001000;\n+    private static final int VALUE_CLASS     = 0x00000040;\n+    private static final int PRIMITIVE_CLASS = 0x00000800;\n@@ -237,2 +239,16 @@\n-        String kind = isInterface() ? \"interface \" : isPrimitive() ? \"\" : \"class \";\n-        return kind.concat(getName());\n+        String s = getName();\n+        if (isPrimitive()) {\n+            return s;\n+        }\n+        \/\/ Avoid invokedynamic based String concat, might be not available\n+        \/\/ Prepend type of class\n+        s = (isInterface() ? \"interface \" : \"class \").concat(s);\n+        if (isValue()) {\n+            \/\/ prepend value class type\n+            s = (isPrimitiveClass() ? \"primitive \" : \"value \").concat(s);\n+            if (isPrimitiveClass() && isPrimaryType()) {\n+                \/\/ Append .ref\n+                s = s.concat(\".ref\");\n+            }\n+        }\n+        return s;\n@@ -291,0 +307,2 @@\n+                \/\/ Modifier.toString() below mis-interprets SYNCHRONIZED, STRICT, and VOLATILE bits\n+                modifiers &= ~(Modifier.SYNCHRONIZED | Modifier.STRICT | Modifier.VOLATILE);\n@@ -299,0 +317,3 @@\n+                if (isValue()) {\n+                    sb.append(isPrimitiveClass() ? \"primitive \" : \"value \");\n+                }\n@@ -501,2 +522,2 @@\n-                                            ClassLoader loader,\n-                                            Class<?> caller)\n+                                    ClassLoader loader,\n+                                    Class<?> caller)\n@@ -591,0 +612,121 @@\n+    \/\/ set by VM if this class is an exotic type such as primitive class\n+    \/\/ otherwise, these two fields are null\n+    private transient Class<T> primaryType;\n+    private transient Class<T> secondaryType;\n+\n+    \/**\n+     * Returns {@code true} if this class is a primitive class.\n+     * <p>\n+     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n+     * representing the <em>primitive reference type<\/em> and a\n+     * {@linkplain #isPrimitiveValueType() secondary type} representing\n+     * the <em>primitive value type<\/em>.  The primitive reference type\n+     * and primitive value type can be obtained by calling the\n+     * {@link #asPrimaryType()} and {@link #asValueType} method\n+     * of a primitive class respectively.\n+     * <p>\n+     * A primitive class is a {@linkplain #isValue() value class}.\n+     *\n+     * @return {@code true} if this class is a primitive class, otherwise {@code false}\n+     * @see #isValue()\n+     * @see #asPrimaryType()\n+     * @see #asValueType()\n+     * @since Valhalla\n+     *\/\n+    public boolean isPrimitiveClass() {\n+        return (this.getModifiers() & PRIMITIVE_CLASS) != 0;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this class is a value class.\n+     *\n+     * @return {@code true} if this class is a value class;\n+     * otherwise {@code false}\n+     * @since Valhalla\n+     *\/\n+    public boolean isValue() {\n+        return (this.getModifiers() & VALUE_CLASS) != 0;\n+    }\n+\n+    \/**\n+     * Returns a {@code Class} object representing the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this {@code Class} object represents a primitive type or an array type,\n+     * then this method returns this class.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n+     * type of this primitive class.\n+     * <p>\n+     * Otherwise, this {@code Class} object represents a non-primitive class or interface\n+     * and this method returns this class.\n+     *\n+     * @return the {@code Class} representing the primary type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    @IntrinsicCandidate\n+    public Class<?> asPrimaryType() {\n+        return isPrimitiveClass() ? primaryType : this;\n+    }\n+\n+    \/**\n+     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n+     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n+     *\n+     * @apiNote Alternatively, this method returns null if this class is not\n+     *          a primitive class rather than throwing UOE.\n+     *\n+     * @return the {@code Class} representing the {@linkplain #isPrimitiveValueType()\n+     * primitive value type} of this class if this class is a primitive class\n+     * @throws UnsupportedOperationException if this class or interface\n+     *         is not a primitive class\n+     * @since Valhalla\n+     *\/\n+    @IntrinsicCandidate\n+    public Class<?> asValueType() {\n+        if (isPrimitiveClass())\n+            return secondaryType;\n+\n+        throw new UnsupportedOperationException(this.getName().concat(\" is not a primitive class\"));\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this {@code Class} object represents a primitive type or an array type,\n+     * then this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive}, then this method returns {@code true} if this {@code Class}\n+     * object represents a primitive reference type, or returns {@code false}\n+     * if this {@code Class} object represents a primitive value type.\n+     * <p>\n+     * If this {@code Class} object represents a non-primitive class or interface,\n+     * then this method returns {@code true}.\n+     *\n+     * @return {@code true} if this {@code Class} object represents\n+     * the primary type of this class or interface\n+     * @since Valhalla\n+     *\/\n+    public boolean isPrimaryType() {\n+        if (isPrimitiveClass()) {\n+            return this == primaryType;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents\n+     * a {@linkplain #isPrimitiveClass() primitive} value type.\n+     *\n+     * @return {@code true} if this {@code Class} object represents\n+     * the value type of a primitive class\n+     * @since Valhalla\n+     *\/\n+    public boolean isPrimitiveValueType() {\n+        return isPrimitiveClass() && this == secondaryType;\n+    }\n+\n@@ -735,0 +877,4 @@\n+     * object represents the {@linkplain #isPrimaryType() reference type}\n+     * of a {@linkplain #isPrimitiveClass() primitive class}, this method\n+     * return {@code true} if the specified {@code Class} parameter represents\n+     * the same primitive class. If this {@code Class}\n@@ -743,3 +889,3 @@\n-     * or via a widening reference conversion. See <cite>The Java Language\n-     * Specification<\/cite>, sections {@jls 5.1.1} and {@jls 5.1.4},\n-     * for details.\n+     * or via a widening reference conversion or via a primitive widening\n+     * conversion. See <cite>The Java Language Specification<\/cite>,\n+     * sections {@jls 5.1.1} and {@jls 5.1.4}, for details.\n@@ -873,0 +1019,2 @@\n+     * <tr><th scope=\"row\"> {@linkplain #isPrimitiveClass() primitive class} with <a href=\"ClassLoader.html#binary-name\">binary name<\/a> <i>N<\/i>\n+     *                                      <td style=\"text-align:center\"> {@code Q}<em>N<\/em>{@code ;}\n@@ -891,0 +1039,2 @@\n+     * Point.class.getName()\n+     *     returns \"Point\"\n@@ -893,0 +1043,4 @@\n+     * (new Point[3]).getClass().getName()\n+     *     returns \"[QPoint;\"\n+     * (new Point.ref[3][4]).getClass().getName()\n+     *     returns \"[[LPoint;\"\n@@ -1327,1 +1481,1 @@\n-    \/**\n+   \/**\n@@ -1361,1 +1515,1 @@\n-    \/**\n+   \/**\n@@ -1371,1 +1525,0 @@\n-\n@@ -1377,1 +1530,0 @@\n-\n@@ -1759,1 +1911,1 @@\n-                return cl.getName().concat(\"[]\".repeat(dimensions));\n+                return cl.getTypeName().concat(\"[]\".repeat(dimensions));\n@@ -1762,1 +1914,6 @@\n-        return getName();\n+        if (isPrimitiveClass()) {\n+            \/\/ TODO: null-default\n+            return isPrimaryType() ? getName().concat(\".ref\") : getName();\n+        } else {\n+            return getName();\n+        }\n@@ -3973,1 +4130,3 @@\n-     * null and is not assignable to the type T.\n+     * {@code null} and is not assignable to the type T.\n+     * @throws NullPointerException if this class is an {@linkplain #isPrimitiveValueType()\n+     * primitive value type} and the object is {@code null}\n@@ -3980,0 +4139,3 @@\n+        if (isPrimitiveValueType() && obj == null)\n+            throw new NullPointerException(getName() + \" is a primitive value type\");\n+\n@@ -4275,1 +4437,1 @@\n-         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);\n+        return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);\n@@ -4490,1 +4652,3 @@\n-        } else if (isHidden()) {\n+        }\n+        char typeDesc = isPrimitiveValueType() ? 'Q' : 'L';\n+        if (isHidden()) {\n@@ -4494,1 +4658,1 @@\n-                    .append('L')\n+                    .append(typeDesc)\n@@ -4503,1 +4667,1 @@\n-                    .append('L')\n+                    .append(typeDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":185,"deletions":21,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.util.Objects;\n@@ -243,1 +246,2 @@\n-     * The {@code toString} method for class {@code Object}\n+     * If this object is an instance of an identity class, then\n+     * the {@code toString} method for class {@code Object}\n@@ -253,0 +257,6 @@\n+     * <p>\n+     * If this object is an instance of a primitive class, then\n+     * the {@code toString} method returns a string which contains\n+     * the name of the primitive class, and string representations of\n+     * all its fields.  The precise format produced by this method\n+     * is unspecified and subject to change.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isConstructor())\n+            if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())\n@@ -82,1 +82,2 @@\n-            mtype = mtype.insertParameterTypes(0, refc);\n+            Class<?> receiverType = refc.isPrimitiveClass() ? refc.asValueType() : refc;\n+            mtype = mtype.insertParameterTypes(0, receiverType);\n@@ -130,1 +131,1 @@\n-        if (member.isConstructor())\n+        if (member.isObjectConstructor() && member.getReturnType() == void.class)\n@@ -135,1 +136,2 @@\n-        assert(ctor.isConstructor() && ctor.getName().equals(\"<init>\"));\n+        assert(ctor.isObjectConstructor() && !ctor.getDeclaringClass().isValue()) : ctor;\n+\n@@ -137,2 +139,2 @@\n-        ctor = ctor.asConstructor();\n-        assert(ctor.isConstructor() && ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;\n+        ctor = ctor.asObjectConstructor();\n+        assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;\n@@ -552,3 +554,3 @@\n-        private final Class<?> fieldType;\n-        private final Object   staticBase;\n-        private final long     staticOffset;\n+        final Class<?> fieldType;\n+        final Object staticBase;\n+        final long staticOffset;\n@@ -602,0 +604,10 @@\n+    @ForceInline\n+    \/*non-public*\/ static Class<?> fieldType(Object accessorObj) {\n+        return ((Accessor) accessorObj).fieldType;\n+    }\n+\n+    @ForceInline\n+    \/*non-public*\/ static Class<?> staticFieldType(Object accessorObj) {\n+        return ((StaticAccessor) accessorObj).fieldType;\n+    }\n+\n@@ -616,1 +628,1 @@\n-    \/\/ with an extra case added for checked references.\n+    \/\/ with an extra case added for checked references and value field access\n@@ -618,5 +630,6 @@\n-            FT_LAST_WRAPPER    = Wrapper.COUNT-1,\n-            FT_UNCHECKED_REF   = Wrapper.OBJECT.ordinal(),\n-            FT_CHECKED_REF     = FT_LAST_WRAPPER+1,\n-            FT_LIMIT           = FT_LAST_WRAPPER+2;\n-    private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {\n+            FT_LAST_WRAPPER     = Wrapper.COUNT-1,\n+            FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),\n+            FT_CHECKED_REF      = FT_LAST_WRAPPER+1,\n+            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flattened and non-flattened\n+            FT_LIMIT            = FT_LAST_WRAPPER+4;\n+    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {\n@@ -625,0 +638,1 @@\n+                + (isFlatValue ? 1 : 0)\n@@ -629,2 +643,2 @@\n-            = new LambdaForm[afIndex(AF_LIMIT, false, 0)];\n-    static int ftypeKind(Class<?> ftype) {\n+            = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];\n+    static int ftypeKind(Class<?> ftype, boolean isValue) {\n@@ -637,1 +651,2 @@\n-            return FT_CHECKED_REF;\n+            \/\/ null check for value type in addition to check cast\n+            return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;\n@@ -658,1 +673,1 @@\n-            preparedFieldLambdaForm(formOp, isVolatile, ftype);\n+            preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);\n@@ -663,1 +678,1 @@\n-        LambdaForm lform = preparedFieldLambdaForm(formOp, isVolatile, ftype);\n+        LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);\n@@ -670,3 +685,4 @@\n-    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, Class<?> ftype) {\n-        int ftypeKind = ftypeKind(ftype);\n-        int afIndex = afIndex(formOp, isVolatile, ftypeKind);\n+\n+    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class<?> ftype) {\n+        int ftypeKind = ftypeKind(ftype, isValue);\n+        int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);\n@@ -675,1 +691,1 @@\n-        lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind);\n+        lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);\n@@ -682,1 +698,1 @@\n-    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, Wrapper wrapper) {\n+    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {\n@@ -694,1 +710,1 @@\n-                    case OBJECT:  return GET_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n@@ -706,1 +722,1 @@\n-                    case OBJECT:  return GET_REFERENCE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;\n@@ -720,1 +736,1 @@\n-                    case OBJECT:  return PUT_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;\n@@ -732,1 +748,1 @@\n-                    case OBJECT:  return PUT_REFERENCE;\n+                    case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;\n@@ -739,1 +755,6 @@\n-    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {\n+    \/** invoked by GenerateJLIClassesHelper *\/\n+    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {\n+        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);\n+    }\n+\n+    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {\n@@ -743,1 +764,1 @@\n-        boolean needsCast = (ftypeKind == FT_CHECKED_REF);\n+        boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);\n@@ -746,1 +767,1 @@\n-        assert(ftypeKind(needsCast ? String.class : ft) == ftypeKind);\n+        assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);\n@@ -749,1 +770,1 @@\n-        Kind kind = getFieldKind(isGetter, isVolatile, fw);\n+        Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);\n@@ -752,4 +773,8 @@\n-        if (isGetter)\n-            linkerType = MethodType.methodType(ft, Object.class, long.class);\n-        else\n-            linkerType = MethodType.methodType(void.class, Object.class, long.class, ft);\n+        boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;\n+        if (isGetter) {\n+            linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)\n+                                 : MethodType.methodType(ft, Object.class, long.class);\n+        } else {\n+            linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)\n+                                     : MethodType.methodType(void.class, Object.class, long.class, ft);\n+        }\n@@ -786,0 +811,1 @@\n+        final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);\n@@ -796,1 +822,1 @@\n-        assert(outArgs.length == (isGetter ? 3 : 4));\n+        assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));\n@@ -805,0 +831,5 @@\n+        int x = 3;\n+        if (hasValueTypeArg) {\n+            outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])\n+                                                        : new Name(getFunction(NF_fieldType), names[DMH_THIS]);\n+        }\n@@ -806,1 +837,1 @@\n-            outArgs[3] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);\n+            outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);\n@@ -857,1 +888,3 @@\n-            NF_LIMIT = 12;\n+            NF_fieldType = 12,\n+            NF_staticFieldType = 13,\n+            NF_LIMIT = 14;\n@@ -872,0 +905,2 @@\n+    private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);\n+\n@@ -908,3 +943,7 @@\n-                            MemberName.getFactory().resolveOrFail(REF_invokeVirtual, member,\n-                                                                  DirectMethodHandle.class, LM_TRUSTED,\n-                                                                  NoSuchMethodException.class));\n+                        MemberName.getFactory().resolveOrFail(REF_invokeVirtual, member,\n+                                                              DirectMethodHandle.class, LM_TRUSTED,\n+                                                              NoSuchMethodException.class));\n+                case NF_fieldType:\n+                    return getNamedFunction(\"fieldType\", CLS_OBJ_TYPE);\n+                case NF_staticFieldType:\n+                    return getNamedFunction(\"staticFieldType\", CLS_OBJ_TYPE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":82,"deletions":43,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.HashSet;\n@@ -360,0 +361,10 @@\n+        \/\/ generate Preload attribute if it references any value class\n+        PreloadAttributeBuilder builder = new PreloadAttributeBuilder(targetClass);\n+        builder.add(factoryType)\n+               .add(interfaceMethodType)\n+               .add(implMethodType)\n+               .add(dynamicMethodType)\n+               .add(altMethods);\n+        if (!builder.isEmpty())\n+            cw.visitAttribute(builder.build());\n+\n@@ -593,0 +604,66 @@\n+    \/*\n+     * Preload attribute builder\n+     *\/\n+    static class PreloadAttributeBuilder {\n+        private final Set<Class<?>> preloadClasses = new HashSet<>();\n+        PreloadAttributeBuilder(Class<?> targetClass) {\n+            if (requiresPreload(targetClass)) {\n+                preloadClasses.add(targetClass);\n+            }\n+        }\n+\n+        \/*\n+         * Add the value types referenced in the given MethodType.\n+         *\/\n+        PreloadAttributeBuilder add(MethodType mt) {\n+            \/\/ parameter types\n+            for (Class<?> paramType : mt.ptypes()) {\n+                if (requiresPreload(paramType)) {\n+                    preloadClasses.add(paramType);\n+                }\n+            }\n+            \/\/ return type\n+            if (requiresPreload(mt.returnType())) {\n+                preloadClasses.add(mt.returnType());\n+            }\n+            return this;\n+        }\n+\n+        PreloadAttributeBuilder add(MethodType... mtypes) {\n+            for (MethodType mt : mtypes) {\n+                add(mt);\n+            }\n+            return this;\n+        }\n+\n+        boolean requiresPreload(Class<?> cls) {\n+            Class<?> c = cls;\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+            }\n+            return (c.isValue() && !c.isPrimitiveClass()) || c.isPrimitiveValueType();\n+        }\n+\n+        boolean isEmpty() {\n+            return preloadClasses.isEmpty();\n+        }\n+\n+        Attribute build() {\n+            return new Attribute(\"Preload\") {\n+                @Override\n+                protected ByteVector write(ClassWriter cw,\n+                                           byte[] code,\n+                                           int len,\n+                                           int maxStack,\n+                                           int maxLocals) {\n+                    ByteVector attr = new ByteVector();\n+                    attr.putShort(preloadClasses.size());\n+                    for (Class<?> c : preloadClasses) {\n+                        attr.putShort(cw.newClass(Type.getInternalName(c)));\n+                    }\n+                    return attr;\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -274,0 +274,4 @@\n+        GET_VALUE(\"getValue\"),\n+        PUT_VALUE(\"putValue\"),\n+        GET_VALUE_VOLATILE(\"getValueVolatile\"),\n+        PUT_VALUE_VOLATILE(\"putValueVolatile\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -194,2 +194,3 @@\n-        if (isConstructor() && getReferenceKind() == REF_newInvokeSpecial)\n-            return itype.changeReturnType(clazz);\n+        Class<?> c = clazz.isPrimitiveClass() ? clazz.asValueType() : clazz;\n+        if (isObjectConstructor() && getReferenceKind() == REF_newInvokeSpecial)\n+            return itype.changeReturnType(c);\n@@ -197,1 +198,1 @@\n-            return itype.insertParameterTypes(0, clazz);\n+            return itype.insertParameterTypes(0, c);\n@@ -286,1 +287,1 @@\n-        } else if (isConstructor()) {\n+        } else if (isObjectConstructor()) {\n@@ -432,0 +433,2 @@\n+        \/\/ all fields declared in a value type are effectively final\n+        assert(!clazz.isValue() || !isField() || Modifier.isFinal(flags));\n@@ -453,5 +456,6 @@\n-    static final int BRIDGE    = 0x00000040;\n-    static final int VARARGS   = 0x00000080;\n-    static final int SYNTHETIC = 0x00001000;\n-    static final int ANNOTATION= 0x00002000;\n-    static final int ENUM      = 0x00004000;\n+    static final int BRIDGE      = 0x00000040;\n+    static final int VARARGS     = 0x00000080;\n+    static final int SYNTHETIC   = 0x00001000;\n+    static final int ANNOTATION  = 0x00002000;\n+    static final int ENUM        = 0x00004000;\n+\n@@ -471,0 +475,12 @@\n+    \/** Query whether this member is a flattened field *\/\n+    public boolean isFlattened() { return (flags & MN_FLATTENED) == MN_FLATTENED; }\n+\n+    \/** Query whether this member is a field of a primitive class. *\/\n+    public boolean isInlineableField()  {\n+        if (isField()) {\n+            Class<?> type = getFieldType();\n+            return type.isPrimitiveValueType() || (type.isValue() && !type.isPrimitiveClass());\n+        }\n+        return false;\n+    }\n+\n@@ -473,0 +489,1 @@\n+    \/\/ modifiers exported by the JVM:\n@@ -478,6 +495,6 @@\n-            IS_METHOD        = MN_IS_METHOD,        \/\/ method (not constructor)\n-            IS_CONSTRUCTOR   = MN_IS_CONSTRUCTOR,   \/\/ constructor\n-            IS_FIELD         = MN_IS_FIELD,         \/\/ field\n-            IS_TYPE          = MN_IS_TYPE,          \/\/ nested type\n-            CALLER_SENSITIVE = MN_CALLER_SENSITIVE, \/\/ @CallerSensitive annotation detected\n-            TRUSTED_FINAL    = MN_TRUSTED_FINAL;    \/\/ trusted final field\n+            IS_METHOD             = MN_IS_METHOD,              \/\/ method (not object constructor)\n+            IS_OBJECT_CONSTRUCTOR = MN_IS_OBJECT_CONSTRUCTOR,  \/\/ object constructor\n+            IS_FIELD              = MN_IS_FIELD,               \/\/ field\n+            IS_TYPE               = MN_IS_TYPE,                \/\/ nested type\n+            CALLER_SENSITIVE      = MN_CALLER_SENSITIVE,       \/\/ @CallerSensitive annotation detected\n+            TRUSTED_FINAL         = MN_TRUSTED_FINAL;    \/\/ trusted final field\n@@ -486,2 +503,2 @@\n-    static final int ALL_KINDS = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE;\n-    static final int IS_INVOCABLE = IS_METHOD | IS_CONSTRUCTOR;\n+    static final int ALL_KINDS = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE;\n+    static final int IS_INVOCABLE = IS_METHOD | IS_OBJECT_CONSTRUCTOR;\n@@ -504,2 +521,6 @@\n-    public boolean isConstructor() {\n-        return testAllFlags(IS_CONSTRUCTOR);\n+    public boolean isObjectConstructor() {\n+        return testAllFlags(IS_OBJECT_CONSTRUCTOR);\n+    }\n+    \/** Query whether this member is an object constructor or static <init> factory *\/\n+    public boolean isObjectConstructorOrStaticInitMethod() {\n+        return isObjectConstructor() || (getName().equals(CONSTRUCTOR_NAME) && testAllFlags(IS_METHOD));\n@@ -636,1 +657,1 @@\n-    public MemberName asConstructor() {\n+    public MemberName asObjectConstructor() {\n@@ -677,2 +698,8 @@\n-        if (this.type == null)\n-            this.type = new Object[] { void.class, ctor.getParameterTypes() };\n+        if (this.type == null) {\n+            Class<?> rtype = void.class;\n+            if (isStatic()) {  \/\/ a static init factory, not a true constructor\n+                rtype = getDeclaringClass();\n+                \/\/ FIXME: If it's a hidden class, this sig won't work.\n+            }\n+            this.type = new Object[] { rtype, ctor.getParameterTypes() };\n+        }\n@@ -819,1 +846,1 @@\n-        int initFlags = (name != null && name.equals(CONSTRUCTOR_NAME) ? IS_CONSTRUCTOR : IS_METHOD);\n+        int initFlags = (name != null && name.equals(CONSTRUCTOR_NAME) && type.returnType() == void.class ? IS_OBJECT_CONSTRUCTOR : IS_METHOD);\n@@ -837,1 +864,1 @@\n-            kindFlags = IS_CONSTRUCTOR;\n+            kindFlags = IS_OBJECT_CONSTRUCTOR;\n@@ -960,1 +987,1 @@\n-        else if (isConstructor())\n+        else if (isObjectConstructor())\n@@ -973,1 +1000,1 @@\n-        else if (isConstructor())\n+        else if (isObjectConstructor())\n@@ -1154,1 +1181,1 @@\n-        \/** Return a list of all constructors defined by the given class.\n+        \/** Return a list of all object constructors defined by the given class.\n@@ -1158,2 +1185,2 @@\n-        public List<MemberName> getConstructors(Class<?> defc, Class<?> lookupClass) {\n-            return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);\n+        public List<MemberName> getObjectConstructors(Class<?> defc, Class<?> lookupClass) {\n+            return getMembers(defc, null, null, IS_OBJECT_CONSTRUCTOR, lookupClass);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":56,"deletions":29,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -115,8 +115,9 @@\n-            MN_IS_METHOD           = 0x00010000, \/\/ method (not constructor)\n-            MN_IS_CONSTRUCTOR      = 0x00020000, \/\/ constructor\n-            MN_IS_FIELD            = 0x00040000, \/\/ field\n-            MN_IS_TYPE             = 0x00080000, \/\/ nested type\n-            MN_CALLER_SENSITIVE    = 0x00100000, \/\/ @CallerSensitive annotation detected\n-            MN_TRUSTED_FINAL       = 0x00200000, \/\/ trusted final field\n-            MN_REFERENCE_KIND_SHIFT = 24, \/\/ refKind\n-            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n+            MN_IS_METHOD             = 0x00010000, \/\/ method (not object constructor)\n+            MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ object constructor\n+            MN_IS_FIELD              = 0x00040000, \/\/ field\n+            MN_IS_TYPE               = 0x00080000, \/\/ nested type\n+            MN_CALLER_SENSITIVE      = 0x00100000, \/\/ @CallerSensitive annotation detected\n+            MN_TRUSTED_FINAL         = 0x00200000, \/\/ trusted final field\n+            MN_FLATTENED             = 0x00400000, \/\/ flattened field\n+            MN_REFERENCE_KIND_SHIFT  = 24, \/\/ refKind\n+            MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n@@ -124,2 +125,2 @@\n-            MN_SEARCH_SUPERCLASSES = 0x00100000,\n-            MN_SEARCH_INTERFACES   = 0x00200000;\n+            MN_SEARCH_SUPERCLASSES   = 0x00100000,\n+            MN_SEARCH_INTERFACES     = 0x00200000;\n@@ -179,1 +180,1 @@\n-    static boolean refKindIsConstructor(byte refKind) {\n+    static boolean refKindIsObjectConstructor(byte refKind) {\n@@ -587,1 +588,1 @@\n-            sb.append(getCharType(pt));\n+            sb.append(getCharErasedType(pt));\n@@ -589,1 +590,1 @@\n-        sb.append('_').append(getCharType(guardType.returnType()));\n+        sb.append('_').append(getCharErasedType(guardType.returnType()));\n@@ -592,1 +593,1 @@\n-    static char getCharType(Class<?> pt) {\n+    static char getCharErasedType(Class<?> pt) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1626,0 +1626,1 @@\n+            assert lookupClass.isPrimaryType();\n@@ -2598,0 +2599,6 @@\n+            \/\/ resolveOrFail could return a non-static <init> method if present\n+            \/\/ detect and throw NSME before producing a MethodHandle\n+            if (!method.isStatic() && name.equals(\"<init>\")) {\n+                throw new NoSuchMethodException(\"illegal method name: \" + name);\n+            }\n+\n@@ -2743,0 +2750,7 @@\n+         *\n+         * @apiNote\n+         * This method does not find a static {@code <init>} factory method as it is invoked\n+         * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an\n+         * object constructor.  To look up static {@code <init>} factory method, use\n+         * the {@link #findStatic(Class, String, MethodType) findStatic} method.\n+         *\n@@ -2758,0 +2772,3 @@\n+            if (type.returnType() != void.class) {\n+                throw new NoSuchMethodException(\"Constructors must have void return type: \" + refc.getName());\n+            }\n@@ -3444,1 +3461,1 @@\n-            assert(ctor.isConstructor());\n+            assert(ctor.isObjectConstructorOrStaticInitMethod());\n@@ -3447,1 +3464,10 @@\n-            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+            Class<?> defc = c.getDeclaringClass();\n+            if (ctor.isObjectConstructor()) {\n+                assert(ctor.getReturnType() == void.class);\n+                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n+            } else {\n+                \/\/ static init factory is a static method\n+                assert(ctor.isMethod() && ctor.getReturnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n+                assert(!MethodHandleNatives.isCallerSensitive(ctor));  \/\/ must not be caller-sensitive\n+                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n+            }\n@@ -3716,2 +3742,5 @@\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial)\n-                throw new NoSuchMethodException(\"illegal method name: \"+name);\n+            \/\/ \"<init>\" can only be invoked via invokespecial or it's a static init factory\n+            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial &&\n+                    !(refKind == REF_invokeStatic && name.equals(\"<init>\"))) {\n+                    throw new NoSuchMethodException(\"illegal method name: \" + name);\n+            }\n@@ -3821,1 +3850,1 @@\n-            if (!fullPrivilegeLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && defc.asPrimaryType() != refc.asPrimaryType()) {\n@@ -3829,1 +3858,1 @@\n-            if (m.isConstructor())\n+            if (m.isObjectConstructor())\n@@ -3904,1 +3933,1 @@\n-                               (defc == refc ||\n+                               (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3909,1 +3938,1 @@\n-                           (defc == refc ||\n+                           (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3986,1 +4015,0 @@\n-\n@@ -4130,1 +4158,1 @@\n-            assert(ctor.isConstructor());\n+            assert(ctor.isObjectConstructor());\n@@ -4309,1 +4337,3 @@\n-     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be\n+     * is {@code null} or if the array's element type is a {@link Class#isPrimitiveValueType()\n+     * a primitive value type} and attempts to set {@code null} in the\n+     * array element.  An {@code ArrayIndexOutOfBoundsException} will be\n@@ -5022,1 +5052,3 @@\n-     * @throws NullPointerException if the {@code type} argument is null\n+     * @throws NullPointerException if the given {@code type} is null, or\n+     *         if the given {@code type} is primitive or a primitive value type\n+     *         and the given value is null\n@@ -5036,1 +5068,1 @@\n-            if (value == null)\n+            if (!type.isPrimitiveValueType() && value == null)\n@@ -5081,1 +5113,9 @@\n-        return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);\n+        if (type.isPrimitive()) {\n+            return zero(Wrapper.forPrimitiveType(type), type);\n+        } else if (type.isPrimitiveValueType()) {\n+            \/\/ singleton default value\n+            Object value = UNSAFE.uninitializedDefaultValue(type);\n+            return identity(type).bindTo(value);\n+        } else {\n+            return zero(Wrapper.OBJECT, type);\n+        }\n@@ -5091,1 +5131,5 @@\n-     * That is, it returns a zero primitive value, a {@code null}, or {@code void}.\n+     * If the requested type is a primitive type or {@code void}, it returns\n+     * a zero primitive value or {@code void}.\n+     * If the requested type is a {@linkplain Class#isPrimitiveValueType() primitive value type},\n+     * it returns a primitive object with the default value.\n+     * If the requested type is a reference type, it returns {@code null}.\n@@ -5111,1 +5155,1 @@\n-        MethodType mtype = methodType(ptype, ptype);\n+        MethodType mtype = MethodType.methodType(ptype, ptype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":60,"deletions":16,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -944,1 +945,1 @@\n-                \")\" + rtype.getSimpleName());\n+                \")\" + toSimpleName(rtype));\n@@ -946,1 +947,1 @@\n-            sj.add(ptypes[i].getSimpleName());\n+            sj.add(toSimpleName(ptypes[i]));\n@@ -951,0 +952,7 @@\n+    static String toSimpleName(Class<?> c) {\n+        if (c.isPrimitiveClass() && c.isPrimaryType()) {\n+            return c.getSimpleName() + \".ref\";\n+        } else {\n+            return c.getSimpleName();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -508,1 +508,4 @@\n-             VarHandleShorts.FieldStaticReadOnly {\n+             VarHandleShorts.FieldStaticReadOnly,\n+             VarHandleValues.Array,\n+             VarHandleValues.FieldInstanceReadOnly,\n+             VarHandleValues.FieldStaticReadOnly {\n@@ -1681,0 +1684,6 @@\n+            \/\/ the field type (value) is mapped to the return type of MethodType\n+            \/\/ the receiver type is mapped to a parameter type of MethodType\n+            \/\/ So use the value type if it's a primitive class\n+            if (receiver != null && receiver.isPrimitiveClass()) {\n+                receiver = receiver.asValueType();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,1 +59,6 @@\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                if (f.isFlattened()) {\n+                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                        ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)\n+                        : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type));\n+                } else {\n+                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n@@ -62,0 +67,1 @@\n+                }\n@@ -120,3 +126,9 @@\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)\n-                       : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type));\n+                if (f.isFlattened()) {\n+                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                            ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)\n+                            : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type));\n+                } else {\n+                    return f.isFinal() && !isWriteAllowedOnFinalFields\n+                            ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)\n+                            : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);\n+                }\n@@ -213,1 +225,6 @@\n-            return maybeAdapt(new VarHandleReferences.Array(aoffset, ashift, arrayClass));\n+            \/\/ the redundant componentType.isPrimitiveValueType() check is\n+            \/\/ there to minimize the performance impact to non-value array.\n+            \/\/ It should be removed when Unsafe::isFlattenedArray is intrinsified.\n+            return maybeAdapt(componentType.isPrimitiveValueType() && UNSAFE.isFlattenedArray(arrayClass)\n+                ? new VarHandleValues.Array(aoffset, ashift, arrayClass)\n+                : new VarHandleReferences.Array(aoffset, ashift, arrayClass));\n@@ -632,1 +649,1 @@\n-            } else if (MethodHandleNatives.refKindIsConstructor(refKind)) {\n+            } else if (MethodHandleNatives.refKindIsObjectConstructor(refKind)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -104,1 +104,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -111,1 +111,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -118,1 +118,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -125,1 +125,0 @@\n-\n@@ -149,0 +148,9 @@\n+#if[Object]\n+        @ForceInline\n+        static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {\n+            if (handle.fieldType.isPrimitiveValueType())\n+                Objects.requireNonNull(value);\n+            return handle.fieldType.cast(value);\n+        }\n+#end[Object]\n+\n@@ -153,2 +161,2 @@\n-                             handle.fieldOffset,\n-                             {#if[Object]?handle.fieldType.cast(value):value});\n+                             handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                             {#if[Object]?checkCast(handle, value):value});\n@@ -161,2 +169,2 @@\n-                                     handle.fieldOffset,\n-                                     {#if[Object]?handle.fieldType.cast(value):value});\n+                                     handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                     {#if[Object]?checkCast(handle, value):value});\n@@ -169,2 +177,2 @@\n-                                   handle.fieldOffset,\n-                                   {#if[Object]?handle.fieldType.cast(value):value});\n+                                   handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                   {#if[Object]?checkCast(handle, value):value});\n@@ -177,2 +185,2 @@\n-                                    handle.fieldOffset,\n-                                    {#if[Object]?handle.fieldType.cast(value):value});\n+                                    handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                    {#if[Object]?checkCast(handle, value):value});\n@@ -186,3 +194,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -195,3 +203,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -204,3 +212,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -213,3 +221,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -222,3 +230,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -231,3 +239,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -240,3 +248,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -249,3 +257,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -258,2 +266,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -266,2 +274,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -274,2 +282,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -443,1 +451,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -450,1 +458,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -457,1 +465,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -464,1 +472,1 @@\n-                                 handle.fieldOffset);\n+                                 handle.fieldOffset{#if[Value]?, handle.fieldType});\n@@ -471,1 +479,0 @@\n-\n@@ -495,0 +502,8 @@\n+#if[Object]\n+        static Object checkCast(FieldStaticReadWrite handle, $type$ value) {\n+            if (handle.fieldType.isPrimitiveValueType())\n+                Objects.requireNonNull(value);\n+            return handle.fieldType.cast(value);\n+        }\n+#end[Object]\n+\n@@ -499,2 +514,2 @@\n-                             handle.fieldOffset,\n-                             {#if[Object]?handle.fieldType.cast(value):value});\n+                             handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                             {#if[Object]?checkCast(handle, value):value});\n@@ -507,2 +522,2 @@\n-                                     handle.fieldOffset,\n-                                     {#if[Object]?handle.fieldType.cast(value):value});\n+                                     handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                     {#if[Object]?checkCast(handle, value):value});\n@@ -515,2 +530,2 @@\n-                                   handle.fieldOffset,\n-                                   {#if[Object]?handle.fieldType.cast(value):value});\n+                                   handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                   {#if[Object]?checkCast(handle, value):value});\n@@ -523,2 +538,2 @@\n-                                    handle.fieldOffset,\n-                                    {#if[Object]?handle.fieldType.cast(value):value});\n+                                    handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                    {#if[Object]?checkCast(handle, value):value});\n@@ -532,3 +547,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -542,3 +557,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -551,3 +566,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -560,3 +575,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -569,3 +584,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -578,3 +593,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -587,3 +602,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -596,3 +611,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -605,2 +620,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -613,2 +628,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -621,2 +636,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[Value]?, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -729,0 +744,8 @@\n+#if[Reference]\n+    static VarHandle makeVarHandleValuesArray(Class<?> arrayClass) {\n+        Class<?> componentType = arrayClass.getComponentType();\n+        assert componentType.isPrimitiveValueType() && UNSAFE.isFlattenedArray(arrayClass);\n+        \/\/ should cache these VarHandle for performance\n+        return VarHandles.makeArrayElementHandle(arrayClass);\n+    }\n+#end[Reference]\n@@ -783,0 +806,3 @@\n+            if (handle.componentType.isPrimitiveValueType())\n+                 Objects.requireNonNull(value);\n+\n@@ -821,1 +847,9 @@\n-            array[index] = {#if[Object]?handle.componentType.cast(value):value};\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                vh.set(oarray, index, reflectiveTypeCheck(array, value));\n+                return;\n+            }\n+#end[Reference]\n+            array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};\n@@ -832,0 +866,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.getVolatile(oarray, index);\n+            }\n+#end[Reference]\n@@ -833,1 +874,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType});\n@@ -844,0 +885,8 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                vh.setVolatile(oarray, index, reflectiveTypeCheck(array, value));\n+                return;\n+            }\n+#end[Reference]\n@@ -845,1 +894,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType},\n@@ -857,0 +906,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.getOpaque(oarray, index);\n+            }\n+#end[Reference]\n@@ -858,1 +914,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType});\n@@ -869,0 +925,8 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                vh.setOpaque(oarray, index, reflectiveTypeCheck(array, value));\n+                return;\n+            }\n+#end[Reference]\n@@ -870,1 +934,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType},\n@@ -882,0 +946,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.getAcquire(oarray, index);\n+            }\n+#end[Reference]\n@@ -883,1 +954,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType});\n@@ -894,0 +965,8 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                vh.setRelease(oarray, index, reflectiveTypeCheck(array, value));\n+                return;\n+            }\n+#end[Reference]\n@@ -895,1 +974,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType},\n@@ -908,0 +987,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.compareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -909,1 +995,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -922,0 +1008,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.compareAndExchange(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -923,1 +1016,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -936,0 +1029,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.compareAndExchangeAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -937,1 +1037,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -950,0 +1050,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.compareAndExchangeRelease(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -951,1 +1058,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -964,0 +1071,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.weakCompareAndSetPlain(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -965,1 +1079,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -978,0 +1092,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.weakCompareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -979,1 +1100,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -992,0 +1113,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.weakCompareAndSetAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -993,1 +1121,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1006,0 +1134,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.weakCompareAndSetRelease(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -1007,1 +1142,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1020,0 +1155,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.getAndSet(oarray, index, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -1021,1 +1163,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType},\n@@ -1033,0 +1175,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.getAndSetAcquire(oarray, index, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -1034,1 +1183,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType},\n@@ -1046,0 +1195,7 @@\n+#if[Reference]\n+            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n+                \/\/ for flattened array, delegate to VarHandle of the inline type array\n+                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+                return vh.getAndSetRelease(oarray, index, reflectiveTypeCheck(array, value));\n+            }\n+#end[Reference]\n@@ -1047,1 +1203,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Value]?, handle.componentType},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":260,"deletions":104,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+ * <p>\n+ * The referent must not be an instance of a {@linkplain Class#isValue()\n+ * value class}; such a value can never have another reference to it\n+ * and cannot be held in a reference type.\n@@ -90,0 +94,2 @@\n+     * @throws IllegalArgumentException if the referent is an instance of an\n+     *         {@link Class#isValue() value class}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.Objects;\n+\n@@ -40,0 +42,4 @@\n+ * <p>\n+ * References can only refer to identity objects.\n+ * Attempts to create a reference to a {@linkplain Class#isValue() value object}\n+ * results in an {@link IdentityException}.\n@@ -508,0 +514,3 @@\n+        if (referent != null) {\n+            Objects.requireIdentity(referent);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+ * <p>\n+ * The referent must not be an instance of a {@linkplain Class#isValue()\n+ * value class}; such a value can never have another reference to it\n+ * and cannot be held in a reference type.\n@@ -84,0 +88,2 @@\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isValue() value class}\n@@ -97,1 +103,2 @@\n-     *\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isValue() value class}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/SoftReference.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+ * <p>\n+ * The referent must not be an instance of a {@linkplain Class#isValue()\n+ * value class}; such a value can never have another reference to it\n+ * and cannot be held in a reference type.\n@@ -56,0 +60,2 @@\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isValue() value class}\n@@ -68,0 +74,2 @@\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isValue() value class}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/WeakReference.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,0 +143,6 @@\n+    \/**\n+     * The access flag {@code ACC_IDENTITY} with a mask value of {@code\n+     * 0x0020}.\n+     *\/\n+\/\/    IDENTITY(0x0000_0020, false, Location.SET_CLASS),\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+     * <li>fields declared in a {@linkplain Class#isValue() value class}<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -366,1 +367,1 @@\n-        sb.append(getDeclaringClass().getTypeName());\n+        sb.append(getDeclaringClassTypeName());\n@@ -372,1 +373,1 @@\n-        sb.append(getDeclaringClass().getTypeName());\n+        sb.append(getDeclaringClassTypeName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -796,0 +796,8 @@\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -423,1 +424,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n@@ -429,1 +430,1 @@\n-        return \"method \" + getDeclaringClass().getTypeName() +\n+        return \"method \" + getDeclaringClassTypeName() +\n@@ -492,1 +493,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,0 +125,12 @@\n+    \/**\n+     * Return {@code true} if the integer argument includes the\n+     * {@code identity} modifier, {@code false} otherwise.\n+     *\n+     * @param   mod a set of modifiers\n+     * @return {@code true} if {@code mod} includes the\n+     * {@code identity} modifier; {@code false} otherwise.\n+     *\/\n+    public static boolean isIdentity(int mod) {\n+        return (mod & IDENTITY) != 0;\n+    }\n+\n@@ -296,0 +308,6 @@\n+    \/**\n+     * The {@code int} value representing the {@code ACC_IDENTITY}\n+     * modifier.\n+     *\/\n+    public static final int IDENTITY            = 0x00000020;\n+\n@@ -342,3 +360,3 @@\n-    static final int BRIDGE    = 0x00000040;\n-    static final int VARARGS   = 0x00000080;\n-    static final int SYNTHETIC = 0x00001000;\n+    static final int BRIDGE      = 0x00000040;\n+    static final int VARARGS     = 0x00000080;\n+    static final int SYNTHETIC   = 0x00001000;\n@@ -346,2 +364,2 @@\n-    static final int ENUM      = 0x00004000;\n-    static final int MANDATED  = 0x00008000;\n+    static final int ENUM        = 0x00004000;\n+    static final int MANDATED    = 0x00008000;\n@@ -373,1 +391,1 @@\n-        Modifier.STRICT;\n+        Modifier.STRICT         | Modifier.IDENTITY;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -522,1 +522,1 @@\n-                if ((accessFlags & ~Modifier.PUBLIC) != 0) {\n+                if ((accessFlags & ~(Modifier.PUBLIC | Modifier.IDENTITY)) != 0) {\n@@ -545,1 +545,1 @@\n-                                                                      context.accessFlags() | Modifier.FINAL);\n+                                                                      context.accessFlags() | Modifier.FINAL | Modifier.IDENTITY);\n@@ -879,1 +879,1 @@\n-            if (type != c) {\n+            if (type.asPrimaryType() != c.asPrimaryType()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ByteVector;\n@@ -43,0 +45,1 @@\n+import java.util.HashSet;\n@@ -47,0 +50,1 @@\n+import java.util.Set;\n@@ -494,0 +498,1 @@\n+        Set<Class<?>> preloadClasses = new HashSet<>();\n@@ -502,0 +507,1 @@\n+                preloadClasses.addAll(pm.preloadClasses());\n@@ -504,0 +510,3 @@\n+        if (preloadClasses.size() > 0) {\n+            generatePreloadAttribute(preloadClasses);\n+        }\n@@ -685,0 +694,18 @@\n+    private void generatePreloadAttribute(Set<Class<?>> preloadClasses) {\n+        Attribute attr = new Attribute(\"Preload\") {\n+            @Override\n+            protected ByteVector write(ClassWriter cw,\n+                                       byte[] code,\n+                                       int len,\n+                                       int maxStack,\n+                                       int maxLocals) {\n+                ByteVector attr = new ByteVector();\n+                attr.putShort(preloadClasses.size());\n+                for (Class<?> c : preloadClasses) {\n+                    attr.putShort(cw.newClass(Type.getInternalName(c)));\n+                }\n+                return attr;\n+            }\n+        };\n+        visitAttribute(attr);\n+    }\n@@ -814,0 +841,21 @@\n+        Set<Class<?>> preloadClasses() {\n+            Set<Class<?>> preloadClasses = new HashSet<>();\n+            for (Class<?> type : parameterTypes) {\n+                if (requiresPreload(type)) {\n+                    preloadClasses.add(type);\n+                }\n+            }\n+            if (requiresPreload(returnType)) {\n+                preloadClasses.add(returnType);\n+            }\n+            return preloadClasses;\n+        }\n+\n+        boolean requiresPreload(Class<?> cls) {\n+            Class<?> c = cls;\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+            }\n+            return (c.isValue() && !c.isPrimitiveClass()) || c.isPrimitiveValueType();\n+        }\n+\n@@ -848,1 +896,5 @@\n-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n+                String internalName = dotToSlash(type.getName());\n+                if (type.isPrimitiveValueType()) {\n+                    internalName = 'Q' + internalName + \";\";\n+                }\n+                mv.visitTypeInsn(CHECKCAST, internalName);\n@@ -900,4 +952,6 @@\n-         * class to get its Class object at runtime.  The code is written to\n-         * the supplied stream.  Note that the code generated by this method\n-         * may cause the checked ClassNotFoundException to be thrown. A class\n-         * loader is anticipated at local variable index 0.\n+         * class to get its Class object at runtime.  And also generate code\n+         * to invoke Class::asValueType if the class is a primitive value type.\n+         *\n+         * The code is written to the supplied stream.  Note that the code generated\n+         * by this method may caused the checked ClassNotFoundException to be thrown.\n+         * A class loader is anticipated at local variable index 0.\n@@ -914,0 +968,6 @@\n+            if (cl.isPrimitiveValueType()) {\n+              mv.visitMethodInsn(INVOKEVIRTUAL,\n+                                 JL_CLASS,\n+                                 \"asValueType\", \"()Ljava\/lang\/Class;\", false);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":65,"deletions":5,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-    private static final HashMap<Class<?>, MethodHandle> primitiveEquals = new HashMap<>();\n+    \/* package-private *\/\n+    static final HashMap<Class<?>, MethodHandle> primitiveEquals = new HashMap<>();\n+\n@@ -254,0 +256,1 @@\n+     * @param simpleName      the simple name of the record class\n@@ -260,0 +263,1 @@\n+                                            String simpleName,\n@@ -265,1 +269,1 @@\n-            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, receiverClass.getSimpleName() + \"[]\");\n+            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, simpleName + \"[]\");\n@@ -286,1 +290,1 @@\n-                    recipe = receiverClass.getSimpleName() + \"[\";\n+                    recipe = simpleName + \"[\";\n@@ -415,1 +419,2 @@\n-        if (type instanceof MethodType mt)\n+        Class<?> receiverType = recordClass.isPrimitiveClass() ? recordClass.asValueType() : recordClass;\n+        if (type instanceof MethodType mt) {\n@@ -417,1 +422,4 @@\n-        else {\n+            if (mt.parameterType(0) != receiverType) {\n+                throw new IllegalArgumentException(\"Bad method type: \" + mt);\n+            }\n+        } else {\n@@ -423,0 +431,5 @@\n+        for (MethodHandle getter : getterList) {\n+            if (getter.type().parameterType(0) != receiverType) {\n+                throw new IllegalArgumentException(\"Bad receiver type: \" + getter);\n+            }\n+        }\n@@ -425,1 +438,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(boolean.class, recordClass, Object.class)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(boolean.class, receiverType, Object.class)))\n@@ -427,1 +440,1 @@\n-                yield makeEquals(recordClass, getterList);\n+                yield makeEquals(receiverType, getterList);\n@@ -430,1 +443,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(int.class, recordClass)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(int.class, receiverType)))\n@@ -432,1 +445,1 @@\n-                yield makeHashCode(recordClass, getterList);\n+                yield makeHashCode(receiverType, getterList);\n@@ -435,1 +448,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(String.class, recordClass)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(String.class, receiverType)))\n@@ -440,1 +453,1 @@\n-                yield makeToString(lookup, recordClass, getters, nameList);\n+                yield makeToString(lookup, receiverType, recordClass.getSimpleName(), getters, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1857,0 +1857,2 @@\n+                case Opcodes.DEFAULT:\n+                case Opcodes.WITHFIELD:\n@@ -2469,0 +2471,1 @@\n+                case Opcodes.WITHFIELD:\n@@ -2475,3 +2478,1 @@\n-                        if (opcode < Opcodes.INVOKEVIRTUAL) {\n-                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n-                        } else {\n+                        if (opcode >= Opcodes.INVOKEVIRTUAL && opcode <= Opcodes.INVOKEINTERFACE) {\n@@ -2481,0 +2482,2 @@\n+                        } else {\n+                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n@@ -2515,0 +2518,1 @@\n+                case Opcodes.DEFAULT:\n@@ -3266,1 +3270,2 @@\n-                    if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n+                    char descType = methodDescriptor.charAt(currentMethodDescritorOffset);\n+                    if (descType == 'L' || descType == 'Q') {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -188,4 +188,2 @@\n-    static final int ASM_OPCODE_DELTA = 49;\n-\n-    \/\/ The delta between the ASM_IFNULL and ASM_IFNONNULL opcodes and IFNULL and IFNONNULL.\n-    static final int ASM_IFNULL_OPCODE_DELTA = 20;\n+    \/\/ Offset to next available opcode after WITHFIELD from IFEQ\n+    static final int ASM_OPCODE_DELTA = (Opcodes.WITHFIELD + 1) - Opcodes.IFEQ;\n@@ -211,0 +209,5 @@\n+\n+    \/\/ The delta between the ASM_IFNULL and ASM_IFNONNULL opcodes and IFNULL and IFNONNULL.\n+    \/\/ Offset to next available opcode after ASM_JSR from IFNULL.\n+    static final int ASM_IFNULL_OPCODE_DELTA = (ASM_JSR + 1) - Opcodes.IFNULL;\n+\n@@ -213,1 +216,1 @@\n-    static final int ASM_GOTO_W = 220;\n+    static final int ASM_GOTO_W = GOTO_W + ASM_IFNULL_OPCODE_DELTA;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Constants.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+            case 'Q':\n@@ -398,0 +399,1 @@\n+                    case 'Q':\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Frame.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,1 +315,4 @@\n-        NA \/\/ jsr_w = 201 (0xc9)\n+        NA, \/\/ jsr_w = 201 (0xc9)\n+        NA, \/\/ breakpoint = 202 (0xca)\n+        NA, \/\/ default = 203 (0xcb)\n+        NA, \/\/ withfield = 204 (0xcc)\n@@ -1011,1 +1014,1 @@\n-            } else if (opcode == Opcodes.NEW) {\n+            } else if (opcode == Opcodes.NEW || opcode == Opcodes.DEFAULT) {\n@@ -1037,0 +1040,3 @@\n+                    case Opcodes.WITHFIELD:\n+                        size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);\n+                        break;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodWriter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -334,0 +334,1 @@\n+    int ACC_IDENTITY = 0x0020; \/\/ class\n@@ -338,0 +339,1 @@\n+    int ACC_VALUE = 0x0040; \/\/ class\n@@ -343,0 +345,1 @@\n+    int ACC_INLINE = 0x0100; \/\/ inline class\n@@ -345,0 +348,1 @@\n+    int ACC_PRIMITIVE = 0x0800; \/\/ class\n@@ -587,0 +591,2 @@\n+    int DEFAULT = 203; \/\/ visitTypeInsn\n+    int WITHFIELD = 204; \/\/ visitFieldInsn\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -338,1 +339,2 @@\n-            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n+            char c = methodDescriptor.charAt(currentOffset++);\n+            if (c == 'L' || c == 'Q') {\n@@ -357,1 +359,2 @@\n-            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n+            char c = methodDescriptor.charAt(currentOffset++);\n+            if (c == 'L' || c == 'Q') {\n@@ -428,1 +431,2 @@\n-            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n+            char c = methodDescriptor.charAt(currentOffset++);\n+            if (c == 'L' || c == 'Q') {\n@@ -471,0 +475,1 @@\n+            case 'Q':\n@@ -676,1 +681,1 @@\n-            stringBuilder.append('L').append(getInternalName(currentClass)).append(';');\n+            stringBuilder.append(isPrimitiveClass(currentClass) ? 'Q' : 'L').append(getInternalName(currentClass)).append(';');\n@@ -680,0 +685,5 @@\n+    static boolean isPrimitiveClass(Class<?> clazz) {\n+        int mods = clazz.getModifiers();\n+        return (mods & 0x00000100) != 0;\n+    }\n+\n@@ -773,1 +783,2 @@\n-                if (methodDescriptor.charAt(currentOffset++) == 'L') {\n+                char c = methodDescriptor.charAt(currentOffset++);\n+                if (c == 'L' || c == 'Q') {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -536,0 +536,1 @@\n+            case 'Q':\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AnalyzerAdapter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+            \/\/ FIXME: support Q-type\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/Method.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+            \/\/ FIXME: support Q-type\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/Remapper.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-                if (currentChar == 'L' || currentChar == '[' || currentChar == 'T') {\n+                if (currentChar == 'L' || currentChar == 'Q' || currentChar == '[' || currentChar == 'T') {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-        while (getChar(signature, pos) == 'L') {\n+        while (getChar(signature, pos) == 'L' || getChar(signature, pos) == 'Q') {\n@@ -670,1 +670,1 @@\n-        while (\"ZCBSIFJDL[T\".indexOf(getChar(signature, pos)) != -1) {\n+        while (\"ZCBSIFJDLQ[T\".indexOf(getChar(signature, pos)) != -1) {\n@@ -681,1 +681,1 @@\n-            if (getChar(signature, pos) == 'L') {\n+            if (getChar(signature, pos) == 'L' || getChar(signature, pos) == 'Q') {\n@@ -797,1 +797,6 @@\n-        pos = checkChar('L', signature, pos);\n+        if (getChar(signature, pos) == 'L' || getChar(signature, pos) == 'Q') {\n+            pos = pos + 1;\n+        } else {\n+            throw new IllegalArgumentException(signature + \": 'L' or 'Q' expected at index \" + pos);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckClassAdapter.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1421,0 +1421,1 @@\n+            case 'Q':\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckMethodAdapter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,25 @@\n+\n+    protected boolean isFlattened() {\n+        return unsafe.isFlattened(field);\n+    }\n+\n+    protected boolean canBeNull() {\n+        return !field.getType().isPrimitiveClass() || field.getType().isPrimaryType();\n+    }\n+\n+    protected Object checkValue(Object value) {\n+        if (!canBeNull() && value == null)\n+            throw new NullPointerException(field + \" cannot be set to null\");\n+\n+        if (value != null) {\n+            Class<?> type = value.getClass();\n+            if (type.isPrimitiveClass()) {\n+                type = type.asValueType();\n+            }\n+            if (!field.getType().isInstance(value)) {\n+                throwSetIllegalArgumentException(value);\n+            }\n+        }\n+        return value;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-        return unsafe.getReference(obj, fieldOffset);\n+        return isFlattened() ? unsafe.getValue(obj, fieldOffset, field.getType())\n+                             : unsafe.getReference(obj, fieldOffset, field.getType());\n@@ -79,4 +80,5 @@\n-        if (value != null) {\n-            if (!field.getType().isInstance(value)) {\n-                throwSetIllegalArgumentException(value);\n-            }\n+        checkValue(value);\n+        if (isFlattened()) {\n+            unsafe.putValue(obj, fieldOffset, field.getType(), value);\n+        } else {\n+            unsafe.putReference(obj, fieldOffset, value);\n@@ -84,1 +86,0 @@\n-        unsafe.putReference(obj, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeObjectFieldAccessorImpl.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-        return unsafe.getReferenceVolatile(obj, fieldOffset);\n+        return isFlattened() ? unsafe.getValue(obj, fieldOffset, field.getType())\n+                             : unsafe.getReferenceVolatile(obj, fieldOffset, field.getType());\n@@ -81,4 +82,5 @@\n-        if (value != null) {\n-            if (!field.getType().isInstance(value)) {\n-                throwSetIllegalArgumentException(value);\n-            }\n+        checkValue(value);\n+        if (isFlattened()) {\n+            unsafe.putValue(obj, fieldOffset, field.getType(), value);\n+        } else {\n+            unsafe.putReferenceVolatile(obj, fieldOffset, value);\n@@ -86,1 +88,0 @@\n-        unsafe.putReferenceVolatile(obj, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeQualifiedObjectFieldAccessorImpl.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-        return unsafe.getReferenceVolatile(base, fieldOffset);\n+        return isFlattened() ? unsafe.getValue(obj, fieldOffset, field.getType())\n+                             : unsafe.getReferenceVolatile(base, fieldOffset, field.getType());\n@@ -79,4 +80,5 @@\n-        if (value != null) {\n-            if (!field.getType().isInstance(value)) {\n-                throwSetIllegalArgumentException(value);\n-            }\n+        checkValue(value);\n+        if (isFlattened()) {\n+            unsafe.putValue(base, fieldOffset, field.getType(), value);\n+        } else {\n+            unsafe.putReferenceVolatile(base, fieldOffset, value);\n@@ -84,1 +86,0 @@\n-        unsafe.putReferenceVolatile(base, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeQualifiedStaticObjectFieldAccessorImpl.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-        return unsafe.getReference(base, fieldOffset);\n+        return isFlattened() ? unsafe.getValue(base, fieldOffset, field.getType())\n+                             : unsafe.getReference(base, fieldOffset, field.getType());\n@@ -77,4 +78,5 @@\n-        if (value != null) {\n-            if (!field.getType().isInstance(value)) {\n-                throwSetIllegalArgumentException(value);\n-            }\n+        checkValue(value);\n+        if (isFlattened()) {\n+            unsafe.putValue(obj, fieldOffset, field.getType(), value);\n+        } else {\n+            unsafe.putReference(base, fieldOffset, value);\n@@ -82,1 +84,0 @@\n-        unsafe.putReference(base, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeStaticObjectFieldAccessorImpl.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -298,0 +298,7 @@\n+        \/**\n+         * Used for instances of {@link DefaultValueTree}.\n+         *\n+         * @since valhalla\n+         *\/\n+        DEFAULT_VALUE(DefaultValueTree.class),\n+\n@@ -348,0 +355,5 @@\n+        \/**\n+         * Used for instances of {@link WithFieldTree}.\n+         *\/\n+        WITH_FIELD(WithFieldTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -174,0 +174,8 @@\n+    \/**\n+     * Visits a {@code DefaultValue} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\/\n+    R visitDefaultValue(DefaultValueTree node, P p);\n+\n@@ -548,0 +556,9 @@\n+     * Visits a {@code WithFieldTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\/\n+    R visitWithField(WithFieldTree node, P p);\n+\n+    \/**\n+     * Visits a WildcardTypeTree node.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -249,0 +249,12 @@\n+    public R visitWithField(WithFieldTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n@@ -333,0 +345,12 @@\n+    public R visitDefaultValue(DefaultValueTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -317,0 +317,14 @@\n+    public R visitWithField(WithFieldTree node, P p) {\n+        R r = scan(node.getField(), p);\n+        r = scanAndReduce(node.getValue(), p, r);\n+        return r;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n@@ -413,0 +427,12 @@\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n+    public R visitDefaultValue(DefaultValueTree node, P p) {\n+        return scan(node.getType(), p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -101,0 +101,7 @@\n+    \/** Marks a type as a primitive class. We can't reuse the class file encoding (ACC_PRIMITIVE)\n+     * since the latter shares its value (0x800) with ACC_STRICT (javac speak: STRICT_FP) and while\n+     * STRICT_FP is not a valid flag for a class in the class file level, javac's ASTs flag a class\n+     * as being STRICT_FP so as to propagate the FP strictness to methods of the class thereby causing\n+     * a clash *\/\n+    public static final int PRIMITIVE_CLASS  = 1<<16;\n+\n@@ -107,1 +114,2 @@\n-    public static final int ACC_SUPER    = 0x0020;\n+    public static final int ACC_IDENTITY = 0x0020;\n+    public static final int ACC_VALUE    = 0x0040;\n@@ -110,0 +118,1 @@\n+    public static final int ACC_PRIMITIVE = 0x0800;\n@@ -125,0 +134,21 @@\n+    \/** Flag is set for a class symbol if it defines one or more non-empty\n+     *  instance initializer block(s). This is relevenat only for class symbols\n+     *  that originate from source types. For binary types the instance initializer\n+     *  blocks are \"normalized\" into the constructors.\n+     *\/\n+    public static final int HASINITBLOCK         = 1<<18;\n+\n+    \/** Flag is set for a method symbol if it is an empty no-arg ctor.\n+     *  i.e. one that simply returns (jlO) or merely chains to a super's\n+     *  no-arg ctor\n+     *\/\n+    public static final int EMPTYNOARGCONSTR         = 1<<18;\n+\n+    \/** Flag is set for a class or interface whose instances have identity\n+     * i.e. class\/interface declarations that are expressly declared with\n+     * the modifier `identity' or (b) any concrete class not declared with the\n+     * modifier `value' (c) abstract class not declared `value' but meets various\n+     * stipulations (d) older class files with ACC_SUPER bit set\n+     *\/\n+    public static final int IDENTITY_TYPE            = 1<<19;\n+\n@@ -130,3 +160,2 @@\n-    \/** Flag bit 21 is available. (used earlier to tag compiler-generated abstract methods that implement\n-     *  an interface method (Miranda methods)).\n-     *\/\n+    \/** Marks a type as a value class *\/\n+    public static final int VALUE_CLASS  = 1<<21;\n@@ -398,2 +427,2 @@\n-        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n-        StaticLocalFlags                  = LocalClassFlags | STATIC | INTERFACE,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | ACC_IDENTITY,\n+        StaticLocalClassFlags             = LocalClassFlags | STATIC | INTERFACE,\n@@ -411,1 +440,2 @@\n-                                            SYNCHRONIZED | FINAL | STRICTFP;\n+                                            SYNCHRONIZED | FINAL | STRICTFP,\n+        AdjustedClassFlags                = ClassFlags | ACC_PRIMITIVE | ACC_VALUE;\n@@ -413,5 +443,7 @@\n-        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n-        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED,\n-        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED,\n-        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED,\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedLocalClassFlags           = (long) LocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n@@ -443,0 +475,2 @@\n+            if (0 != (flags & PRIMITIVE_CLASS))     modifiers.add(Modifier.PRIMITIVE);\n+            if (0 != (flags & VALUE_CLASS))     modifiers.add(Modifier.VALUE);\n@@ -484,0 +518,8 @@\n+        HASINITBLOCK(Flags.HASINITBLOCK),\n+        EMPTYNOARGCONSTR(Flags.EMPTYNOARGCONSTR),\n+        IDENTITY_TYPE(Flags.IDENTITY_TYPE) {\n+            @Override\n+            public String toString() {\n+                return \"identity\";\n+            }\n+        },\n@@ -487,0 +529,2 @@\n+        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n+        VALUE(Flags.VALUE_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":56,"deletions":12,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -250,0 +250,2 @@\n+        PRIMITIVE_CLASSES(JDK19, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n+        VALUE_CLASSES(JDK19, Fragments.FeatureValueClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -418,0 +419,20 @@\n+    public boolean isPrimitiveClass() {\n+        return (flags() & PRIMITIVE_CLASS) != 0;\n+    }\n+\n+    public boolean isValueClass() {\n+        return !isInterface() && (flags() & VALUE_CLASS) != 0;\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return !isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+    }\n+\n+    public boolean isValueInterface() {\n+        return isInterface() && (flags() & VALUE_CLASS) != 0;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+    }\n+\n@@ -459,1 +480,7 @@\n-        return name == name.table.names.init;\n+        return name == name.table.names.init && (flags() & STATIC) == 0;\n+    }\n+\n+    \/** Is this symbol a value object factory?\n+     *\/\n+    public boolean isValueObjectFactory() {\n+        return ((name == name.table.names.init && this.type.getReturnType().tsym == this.owner));\n@@ -1319,1 +1346,1 @@\n-                new ClassType(Type.noType, null, null),\n+                new ClassType(Type.noType, null, null, TypeMetadata.EMPTY, Flavor.X_Typeof_X),\n@@ -1356,1 +1383,2 @@\n-                                              type.getMetadata());\n+                                              type.getMetadata(),\n+                                              type.getFlavor());\n@@ -1364,1 +1392,1 @@\n-            else\n+\n@@ -1417,0 +1445,8 @@\n+            } finally {\n+                if (this.type != null && this.type.hasTag(CLASS)) {\n+                    ClassType ct = (ClassType) this.type;\n+                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n+                    if (!this.type.isIntersection() && this.erasure_field != null && this.erasure_field.hasTag(CLASS)) {\n+                        ((ClassType) this.erasure_field).flavor = ct.flavor;\n+                    }\n+                }\n@@ -1601,0 +1637,1 @@\n+                classType.flavor = Flavor.X_Typeof_X;\n@@ -2021,1 +2058,1 @@\n-                types.asSuper(owner.type, other.owner) != null &&\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n@@ -2090,1 +2127,1 @@\n-                types.asSuper(owner.type, other.owner) != null) {\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n@@ -2139,0 +2176,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Type.WildcardType;\n@@ -68,0 +69,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -277,2 +279,11 @@\n-                if (type.getTag() == ARRAY || type.getTag() == CLASS)\n-                    arg = types.erasure(type);\n+                if (type.getTag() == ARRAY || type.getTag() == CLASS) {\n+                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n+                       I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>\n+                    *\/\n+                    if (type.isPrimitiveClass()) {\n+                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());\n+                        arg = new WildcardType(bounds.size() > 1 ? types.makeIntersectionType(bounds) : objectType, BoundKind.EXTENDS, boundClass);\n+                    } else {\n+                        arg = types.erasure(type);\n+                    }\n+                }\n@@ -637,1 +648,3 @@\n-        arrayClassType.interfaces_field = List.of(cloneableType, serializableType);\n+        arrayClassType.interfaces_field =\n+                List.of(cloneableType, serializableType);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -239,0 +240,69 @@\n+    public boolean isPrimitiveClass() {\n+        return false;\n+    }\n+\n+    public boolean isValueClass() {\n+        return false;\n+    }\n+\n+    public boolean isValueInterface() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return false;\n+    }\n+\n+    \/\/ Does this type need to be preloaded in the context of the referring class ??\n+    public boolean requiresPreload(Symbol referringClass) {\n+        if (this.tsym == referringClass)\n+            return false; \/\/ pointless\n+        if (this.isReferenceProjection())\n+            return true;\n+        return this.isValueClass() && !this.isPrimitiveClass();\n+    }\n+\n+    \/**\n+     * Return the `flavor' associated with a ClassType.\n+     * @see ClassType.Flavor\n+     *\/\n+    public Flavor getFlavor() {\n+        throw new AssertionError(\"Unexpected call to getFlavor() on a Type that is not a ClassType: \" + this);\n+    }\n+\n+    \/**\n+     * @return true IFF the receiver is a reference projection of a primitive class type and false\n+     * for primitives or plain references\n+     *\/\n+    public boolean isReferenceProjection() {\n+        return false;\n+    }\n+\n+    \/**\n+     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n+     * and null otherwise\n+     *\/\n+    public Type valueProjection() {\n+        return null;\n+    }\n+\n+    \/**\n+     * @return the reference projection type IFF the receiver is a primitive class type\n+     * and null otherwise\n+     *\/\n+    public Type referenceProjection() {\n+        return null;\n+    }\n+\n+    \/**\n+     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n+     *\/\n+    public Type referenceProjectionOrSelf() {\n+        Type projection = referenceProjection();\n+        return projection != null ? projection : this;\n+    }\n+\n@@ -253,1 +323,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.getFlavor()) {\n@@ -949,0 +1019,34 @@\n+    public static class ConstantPoolQType implements PoolConstant {\n+\n+        public final Type type;\n+        final Types types;\n+\n+        public ConstantPoolQType(Type type, Types types) {\n+            this.type = type;\n+            this.types = types;\n+        }\n+\n+        @Override\n+        public Object poolKey(Types types) {\n+            return this;\n+        }\n+\n+        @Override\n+        public int poolTag() {\n+            return ClassFile.CONSTANT_Class;\n+        }\n+\n+        public int hashCode() {\n+            return types.hashCode(type);\n+        }\n+\n+        public boolean equals(Object obj) {\n+            return (obj instanceof ConstantPoolQType) &&\n+                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n+        }\n+\n+        public String toString() {\n+            return type.toString();\n+        }\n+    }\n+\n@@ -952,0 +1056,78 @@\n+        \/**\n+         * The 'flavor' of a ClassType indicates its reference\/primitive projectionness\n+         * viewed against the default nature of the associated class.\n+         *\/\n+        public enum Flavor {\n+\n+            \/**\n+             * Classic reference type. Also reference projection type of a reference-favoring aka\n+             * reference-default primitive class type\n+             *\/\n+            L_TypeOf_L,\n+\n+            \/**\n+             * Reference projection type of a primitive-favoring aka primitive-default\n+             * plain vanilla primitive class type,\n+             *\/\n+            L_TypeOf_Q,\n+\n+            \/**\n+             * Value projection type of a primitive-favoring aka primitive-default\n+             * plain vanilla primitive class type,\n+             *\/\n+            Q_TypeOf_Q,\n+\n+            \/**\n+             * Value projection type of a reference-favoring aka\n+             * reference-default primitive class type\n+             *\/\n+            Q_TypeOf_L,\n+\n+            \/**\n+             * Reference projection type of a class type of an as yet unknown default provenance, 'X' will be\n+             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n+             *\/\n+            L_TypeOf_X,\n+\n+            \/**\n+             * Value projection type of a class type of an as yet unknown default provenance, 'X' will be\n+             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n+             *\/\n+            Q_TypeOf_X,\n+\n+            \/**\n+             *  As yet unknown projection type of an as yet unknown default provenance class.\n+             *\/\n+            X_Typeof_X,\n+\n+            \/**\n+             *  An error type - we don't care to discriminate them any further.\n+             *\/\n+             E_Typeof_X;\n+\n+            \/\/ We don't seem to need X_Typeof_L or X_Typeof_Q so far.\n+\n+            \/\/ Transform a larval form into a more evolved form\n+            public Flavor metamorphose(boolean isPrimtiveClass) {\n+\n+                switch (this) {\n+\n+                    case E_Typeof_X:  \/\/ stunted form\n+                    case L_TypeOf_L:\n+                    case L_TypeOf_Q:\n+                    case Q_TypeOf_L:\n+                    case Q_TypeOf_Q:\n+                            \/\/ These are fully evolved sealed forms or stunted - no futher transformation\n+                            return this;\n+                    case L_TypeOf_X:\n+                            return isPrimtiveClass ? L_TypeOf_Q : L_TypeOf_L;\n+                    case Q_TypeOf_X:\n+                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n+                    case X_Typeof_X:\n+                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n+                    default:\n+                            throw new AssertionError(\"Unexpected class type flavor\");\n+                }\n+            }\n+        }\n+\n@@ -980,0 +1162,13 @@\n+        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n+         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n+        *\/\n+        public ClassType projection;\n+\n+        \/** Is this L of default {L, Q, X} or Q of default {L, Q, X} ?\n+         *\/\n+        public Flavor flavor;\n+\n+        \/*\n+         * Use of this constructor is kinda sorta deprecated, use the other constructor\n+         * that forces the call site to consider and include the class type flavor.\n+         *\/\n@@ -981,1 +1176,1 @@\n-            this(outer, typarams, tsym, TypeMetadata.EMPTY);\n+            this(outer, typarams, tsym, TypeMetadata.EMPTY, Flavor.L_TypeOf_L);\n@@ -985,1 +1180,1 @@\n-                         TypeMetadata metadata) {\n+                         TypeMetadata metadata, Flavor flavor) {\n@@ -992,0 +1187,1 @@\n+            this.flavor = flavor;\n@@ -1000,1 +1196,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md) {\n+            return new ClassType(outer_field, typarams_field, tsym, md, flavor) {\n@@ -1018,1 +1214,1 @@\n-            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {\n+            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata, flavor) {\n@@ -1061,0 +1257,11 @@\n+            boolean isReferenceProjection;\n+            try {\n+                isReferenceProjection = isReferenceProjection();\n+            } catch (CompletionFailure cf) {\n+                isReferenceProjection = false; \/\/ handle missing types gracefully.\n+            }\n+            if (isReferenceProjection) {\n+                buf.append('.');\n+                buf.append(tsym.name.table.names.ref);\n+            }\n+\n@@ -1092,2 +1299,4 @@\n-                } else if (longform) {\n-                    return sym.getQualifiedName().toString();\n+                }\n+                String s;\n+                if (longform) {\n+                    s =  sym.getQualifiedName().toString();\n@@ -1095,1 +1304,1 @@\n-                    return sym.name.toString();\n+                    s = sym.name.toString();\n@@ -1097,0 +1306,1 @@\n+                return s;\n@@ -1099,0 +1309,4 @@\n+        public Flavor getFlavor() {\n+            return flavor;\n+        }\n+\n@@ -1115,0 +1329,3 @@\n+            if (outer_field != null && outer_field.isReferenceProjection()) {\n+                outer_field = outer_field.valueProjection();\n+            }\n@@ -1146,0 +1363,74 @@\n+        @Override\n+        public boolean isPrimitiveClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n+        }\n+\n+        @Override\n+        public boolean isValueClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isValueClass();\n+        }\n+\n+        @Override\n+        public boolean isValueInterface() {\n+            return tsym != null && tsym.isValueInterface();\n+        }\n+\n+        @Override\n+        public boolean isIdentityClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+        }\n+\n+        @Override\n+        public boolean isIdentityInterface() {\n+            return isInterface() && tsym.isIdentityInterface();\n+        }\n+\n+        @Override\n+        public boolean isReferenceProjection() {\n+            \/\/ gaurd against over-eager and\/or inopportune completion\n+            if (tsym != null) {\n+                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n+                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n+                }\n+            }\n+            return flavor == Flavor.L_TypeOf_Q;\n+        }\n+\n+        @Override\n+        public Type valueProjection() {\n+            if (!isReferenceProjection())\n+                return null;\n+\n+            if (projection !=  null)\n+                return projection;\n+\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n+            projection.allparams_field = allparams_field;\n+            projection.supertype_field = supertype_field;\n+\n+            projection.interfaces_field = interfaces_field;\n+            projection.all_interfaces_field = all_interfaces_field;\n+            projection.projection = this;\n+            return projection;\n+        }\n+\n+        \/\/ return the reference projection type preserving parameterizations\n+        @Override\n+        public ClassType referenceProjection() {\n+\n+            if (!isPrimitiveClass())\n+                return null;\n+\n+            if (projection != null)\n+                return projection;\n+\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.L_TypeOf_Q);\n+            projection.allparams_field = allparams_field;\n+            projection.supertype_field = supertype_field;\n+\n+            projection.interfaces_field = interfaces_field;\n+            projection.all_interfaces_field = all_interfaces_field;\n+            projection.projection = this;\n+            return projection;\n+        }\n+\n@@ -1194,1 +1485,1 @@\n-            super(outer, List.nil(), tsym, metadata);\n+            super(outer, List.nil(), tsym, metadata, tsym.type.getFlavor());\n@@ -2361,2 +2652,1 @@\n-            super(noType, List.nil(), null);\n-            this.tsym = tsym;\n+            super(noType, List.nil(), tsym, TypeMetadata.EMPTY, Flavor.E_Typeof_X);\n@@ -2367,2 +2657,2 @@\n-                          TypeMetadata metadata) {\n-            super(noType, List.nil(), null, metadata);\n+                          TypeMetadata metadata, Flavor flavor) {\n+            super(noType, List.nil(), null, metadata, flavor);\n@@ -2375,1 +2665,1 @@\n-            return new ErrorType(originalType, tsym, md) {\n+            return new ErrorType(originalType, tsym, md, getFlavor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":304,"deletions":14,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-                                                      t.getMetadata());\n+                                                      t.getMetadata(), t.getFlavor());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import com.sun.tools.javac.comp.LambdaToMethod;\n@@ -97,0 +96,1 @@\n+    final boolean allowValueBasedClasses;\n@@ -126,0 +126,2 @@\n+        Options options = Options.instance(context);\n+        allowValueBasedClasses = options.isSet(\"allowValueBasedClasses\");\n@@ -274,1 +276,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n@@ -605,0 +607,9 @@\n+\n+        boolean tValue = t.isPrimitiveClass();\n+        boolean sValue = s.isPrimitiveClass();\n+        if (tValue != sValue) {\n+            return tValue ?\n+                    isSubtype(t.referenceProjection(), s) :\n+                    !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n+        }\n+\n@@ -767,2 +778,4 @@\n-            } else if (abstracts.size() == 1) {\n-                return new FunctionDescriptor(abstracts.first());\n+            }\n+            FunctionDescriptor descRes;\n+            if (abstracts.size() == 1) {\n+                descRes = new FunctionDescriptor(abstracts.first());\n@@ -770,1 +783,1 @@\n-                FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());\n+                descRes = mergeDescriptors(origin, abstracts.toList());\n@@ -789,1 +802,11 @@\n-                return descRes;\n+            \/\/ an interface must be neither an identity interface nor a value interface to be functional.\n+            List<Type> allInterfaces = closure(origin.type);\n+            for (Type iface : allInterfaces) {\n+                if (iface.isValueInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.ValueInterfaceNonfunctional));\n+                }\n+                if (iface.isIdentityInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.IdentityInterfaceNonfunctional));\n+                }\n+            }\n+            return descRes;\n@@ -1030,1 +1053,11 @@\n-                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                    \/\/ if T.ref <: S, then T[] <: S[]\n+                    Type es = elemtype(s);\n+                    Type et = elemtype(t);\n+                    if (et.isPrimitiveClass()) {\n+                        et = et.referenceProjection();\n+                        if (es.isPrimitiveClass())\n+                            es = es.referenceProjection();  \/\/ V <: V, surely\n+                    }\n+                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                        return false;\n+                    return true;\n@@ -1127,1 +1160,1 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                         s.hasTag(BOT) || (s.hasTag(CLASS) && !s.isPrimitiveClass()) ||\n@@ -1194,0 +1227,1 @@\n+                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1205,2 +1239,11 @@\n-                    else\n-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n+                    else {\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (et.isPrimitiveClass()) {\n+                            et = et.referenceProjection();\n+                            if (es.isPrimitiveClass())\n+                                es = es.referenceProjection();  \/\/ V <: V, surely\n+                        }\n+                        return isSubtypeNoCapture(et, es);\n+                    }\n@@ -1429,1 +1472,2 @@\n-                    && visit(t.getEnclosingType(), s.getEnclosingType())\n+                    && t.isReferenceProjection() == s.isReferenceProjection()\n+                    && visit(getEnclosingType(t), getEnclosingType(s))\n@@ -1432,0 +1476,8 @@\n+                \/\/ where\n+                private Type getEnclosingType(Type t) {\n+                    Type et = t.getEnclosingType();\n+                    if (et.isReferenceProjection()) {\n+                        et = et.valueProjection();\n+                    }\n+                    return et;\n+                }\n@@ -1591,0 +1643,9 @@\n+\n+                    \/\/ -----------------------------------  Unspecified behavior ----------------\n+\n+                    \/* If a primitive class V implements an interface I, then does \"? extends I\" contain V?\n+                       It seems widening must be applied here to answer yes to compile some common code\n+                       patterns.\n+                    *\/\n+\n+                    \/\/ ---------------------------------------------------------------------------\n@@ -1680,1 +1741,1 @@\n-            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n+            if (isSubtype(erasure(ts.type.referenceProjectionOrSelf()), erasure(ss.type))) {\n@@ -1735,1 +1796,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || (s.hasTag(BOT) && !t.isPrimitiveClass()))\n@@ -1754,0 +1815,8 @@\n+                    if (t.isPrimitiveClass()) {\n+                        \/\/ (s) Value ? == (s) Value.ref\n+                        t = t.referenceProjection();\n+                    }\n+                    if (s.isPrimitiveClass()) {\n+                        \/\/ (Value) t ? == (Value.ref) t\n+                        s = s.referenceProjection();\n+                    }\n@@ -1859,1 +1928,5 @@\n-                        return visit(elemtype(t), elemtype(s));\n+                        Type et = elemtype(t);\n+                        Type es = elemtype(s);\n+                        if (!visit(et, es))\n+                            return false;\n+                        return true;\n@@ -2147,0 +2220,29 @@\n+     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n+     * this method.\n+     *\n+     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n+     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n+     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n+     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n+     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n+     *    really need the cast cannot\/shouldn't be gated on\n+     *\n+     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n+     *\n+     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n+     *    types. When we operate in terms of symbols, there is a loss of type information leading\n+     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n+     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n+     *    may be required at the call site. Also where the concerned symbol corresponds to a\n+     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n+     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n+     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n+     *\n+     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n+     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n+     *    that is NOT what we want. An example of such a hazardous call used to occur in\n+     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n+     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n+     *    These hazardous calls should be rewritten as\n+     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n+     *\n@@ -2159,0 +2261,6 @@\n+\n+        if (t.isPrimitiveClass()) {\n+            \/\/ No man may be an island, but the bell tolls for a value.\n+            return t.tsym == sym ? t : null;\n+        }\n+\n@@ -2289,3 +2397,12 @@\n-        return (sym.flags() & STATIC) != 0\n-            ? sym.type\n-            : memberType.visit(t, sym);\n+\n+        if ((sym.flags() & STATIC) != 0)\n+            return sym.type;\n+\n+        \/* If any primitive class types are involved, switch over to the reference universe,\n+           where the hierarchy is navigable. V and V.ref have identical membership\n+           with no bridging needs.\n+        *\/\n+        if (t.isPrimitiveClass())\n+            t = t.referenceProjection();\n+\n+        return memberType.visit(t, sym);\n@@ -2444,7 +2561,19 @@\n-                Type erased = t.tsym.erasure(Types.this);\n-                if (recurse) {\n-                    erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,\n-                            t.getMetadata().without(Kind.ANNOTATIONS));\n-                    return erased;\n-                } else {\n-                    return combineMetadata(erased, t);\n+                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n+                Type erased = eraseClassType(t, recurse);\n+                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n+                    erased = new ClassType(erased.getEnclosingType(),\n+                            List.nil(), erased.tsym,\n+                            erased.getMetadata(), t.flavor);\n+                }\n+                return erased;\n+            }\n+                \/\/ where\n+                private Type eraseClassType(ClassType t, Boolean recurse) {\n+                    Type erased = t.tsym.erasure(Types.this);\n+                    if (recurse) {\n+                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                                t.getMetadata().without(Kind.ANNOTATIONS));\n+                        return erased;\n+                    } else {\n+                        return combineMetadata(erased, t);\n+                    }\n@@ -2452,1 +2581,0 @@\n-            }\n@@ -2501,0 +2629,1 @@\n+        long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;\n@@ -2502,1 +2631,1 @@\n-            new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,\n+            new ClassSymbol(flags,\n@@ -2772,1 +2901,1 @@\n-                                         t.getMetadata());\n+                                         t.getMetadata(), t.getFlavor());\n@@ -3899,1 +4028,1 @@\n-                                 class1.tsym);\n+                                 class1.tsym, TypeMetadata.EMPTY, class1.getFlavor());\n@@ -3971,1 +4100,0 @@\n-\n@@ -4459,1 +4587,1 @@\n-                                 cls.getMetadata());\n+                                 cls.getMetadata(), cls.getFlavor());\n@@ -4870,0 +4998,1 @@\n+        private boolean encodeTypeSig;\n@@ -4871,1 +5000,1 @@\n-        public UniqueType(Type type, Types types) {\n+        public UniqueType(Type type, Types types, boolean encodeTypeSig) {\n@@ -4874,0 +5003,5 @@\n+            this.encodeTypeSig = encodeTypeSig;\n+        }\n+\n+        public UniqueType(Type type, Types types) {\n+            this(type, types, true);\n@@ -4885,0 +5019,4 @@\n+        public boolean encodeTypeSig() {\n+            return encodeTypeSig;\n+        }\n+\n@@ -5123,1 +5261,4 @@\n-                    append('L');\n+                    if (type.isPrimitiveClass())\n+                        append('Q');\n+                    else\n+                        append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":173,"deletions":32,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -174,0 +175,1 @@\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source);\n@@ -208,0 +210,4 @@\n+    \/** Switch: allow primitive classes ?\n+     *\/\n+    boolean allowPrimitiveClasses;\n+\n@@ -827,1 +833,1 @@\n-                List<Type> bounds = List.of(attribType(tvar.bounds.head, env));\n+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n@@ -829,1 +835,1 @@\n-                    bounds = bounds.prepend(attribType(bound, env));\n+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n@@ -1216,1 +1222,1 @@\n-                            TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {\n+                            TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {\n@@ -1229,0 +1235,6 @@\n+                    } else if ((env.enclClass.sym.flags() & VALUE_CLASS) != 0 &&\n+                        (tree.mods.flags & GENERATEDCONSTR) == 0 &&\n+                        TreeInfo.isSuperCall(body.stats.head)) {\n+                        \/\/ value constructors are not allowed to call super directly,\n+                        \/\/ but tolerate compiler generated ones, these are ignored during code generation\n+                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInValueCtor);\n@@ -1316,0 +1328,3 @@\n+            \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n+               as these can undergo updates via copy on write.\n+            *\/\n@@ -1317,1 +1332,1 @@\n-                if ((v.flags_field & FINAL) == 0 ||\n+                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isValueClass()) ||\n@@ -1357,1 +1372,2 @@\n-        return false;\n+        \/\/ isValueObject is not included in Object yet so we need a work around\n+        return name == names.isValueObject;\n@@ -1549,1 +1565,1 @@\n-                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n@@ -1565,1 +1581,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n@@ -1886,1 +1902,1 @@\n-        chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));\n+        chk.checkIdentityType(tree.pos(), attribExpr(tree.lock, env));\n@@ -1975,1 +1991,1 @@\n-            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n@@ -2165,1 +2181,2 @@\n-            \/\/ Those were all the cases that could result in a primitive\n+            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n+            \/\/ value conversions bring about a convergence.\n@@ -2167,1 +2184,2 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n+                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n@@ -2178,1 +2196,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t.isPrimitiveClass() ? t.referenceProjection() : t))\n@@ -2181,1 +2199,1 @@\n-            \/\/ both are known to be reference types.  The result is\n+            \/\/ both are known to be reference types (or projections).  The result is\n@@ -2622,0 +2640,4 @@\n+                \/\/ Special treatment for primitive classes: Given an expression v of type V where\n+                \/\/ V is a primitive class, v.getClass() is typed to be Class<? extends |V.ref|>\n+                Type wcb = types.erasure(qualifierType.isPrimitiveClass() ?\n+                                                qualifierType.referenceProjection() : qualifierType);\n@@ -2623,1 +2645,1 @@\n-                        List.of(new WildcardType(types.erasure(qualifierType),\n+                        List.of(new WildcardType(wcb,\n@@ -2627,1 +2649,2 @@\n-                        restype.getMetadata());\n+                        restype.getMetadata(),\n+                        restype.getFlavor());\n@@ -2796,0 +2819,8 @@\n+            \/\/ Check that it is an instantiation of a class and not a projection type\n+            if (clazz.hasTag(SELECT)) {\n+                JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n+                if (fieldAccess.selected.type.isPrimitiveClass() &&\n+                        (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n+                    log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n+                }\n+            }\n@@ -2820,1 +2851,2 @@\n-                                               clazztype.getMetadata());\n+                                               clazztype.getMetadata(),\n+                                               clazztype.getFlavor());\n@@ -2974,0 +3006,1 @@\n+                    chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n@@ -3046,0 +3079,3 @@\n+        \/\/ Likewise arg can't be null if it is a primitive class instance.\n+        if (arg.type.isPrimitiveClass())\n+            return arg;\n@@ -4060,0 +4096,1 @@\n+                chk.checkForSuspectClassLiteralComparison(tree, left, right);\n@@ -4371,0 +4408,10 @@\n+        Assert.check(site == tree.selected.type);\n+        if (tree.name == names._class && site.isPrimitiveClass()) {\n+            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n+             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n+             * always matching the behavior of Object::getClass\n+             *\/\n+             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n+                 tree.selected.setType(site = site.referenceProjection());\n+             }\n+        }\n@@ -4383,1 +4430,1 @@\n-                return ;\n+                return;\n@@ -4391,0 +4438,1 @@\n+\n@@ -4487,1 +4535,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n@@ -4530,0 +4578,2 @@\n+                } else if (site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n+                    return site.tsym;\n@@ -4633,1 +4683,1 @@\n-                \/\/ except for two situations:\n+                \/\/ except for three situations:\n@@ -4636,0 +4686,1 @@\n+                    Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n@@ -4639,1 +4690,8 @@\n-                    \/\/ (a) If the symbol's type is parameterized, erase it\n+                    \/\/ (a) If symbol is a primitive class and its reference projection\n+                    \/\/ is requested via the .ref notation, then adjust the computed type to\n+                    \/\/ reflect this.\n+                    if (owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n+                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n+                    }\n+\n+                    \/\/ (b) If the symbol's type is parameterized, erase it\n@@ -4646,1 +4704,1 @@\n-                    \/\/ (b) If the symbol's type is an inner class, then\n+                    \/\/ (c) If the symbol's type is an inner class, then\n@@ -4666,1 +4724,1 @@\n-                                owntype.getMetadata());\n+                                owntype.getMetadata(), owntype.getFlavor());\n@@ -4983,0 +5041,28 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        if (!allowPrimitiveClasses) {\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n+        }\n+\n+        \/\/ Attribute the qualifier expression, and determine its symbol (if any).\n+        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n+        if (!pkind().contains(KindSelector.TYP_PCK))\n+            site = capture(site); \/\/ Capture field access\n+\n+        Symbol sym = switch (site.getTag()) {\n+                case WILDCARD -> throw new AssertionError(tree);\n+                case PACKAGE -> {\n+                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n+                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n+                    yield syms.errSymbol;\n+                }\n+                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n+                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n+        };\n+\n+        if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n+            site = types.skipTypeVars(site, true);\n+        }\n+        result = checkId(tree, site, sym, env, resultInfo);\n+    }\n+\n@@ -5049,1 +5135,1 @@\n-                                        clazztype.getMetadata());\n+                                        clazztype.getMetadata(), clazztype.getFlavor());\n@@ -5176,1 +5262,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT),\n+                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n@@ -5199,1 +5285,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n@@ -5317,0 +5403,5 @@\n+            if (c.type.isPrimitiveClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5437,1 +5528,1 @@\n-            } else {\n+            } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n@@ -5492,0 +5583,5 @@\n+                if (c.isValueClass()) {\n+                    Assert.check(env.tree.hasTag(CLASSDEF));\n+                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":122,"deletions":26,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -146,1 +146,0 @@\n-\n@@ -511,1 +510,1 @@\n-\/* *************************************************************************\n+    \/* *************************************************************************\n@@ -617,0 +616,5 @@\n+        } else {\n+            if (found.hasTag(CLASS)) {\n+                if (inferenceContext != infer.emptyContext)\n+                    checkParameterizationByPrimitiveClass(pos, found);\n+            }\n@@ -747,0 +751,53 @@\n+    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+        for (Type st : types.closure(c.type)) {\n+            if (st == null || st.tsym == null || st.tsym.kind == ERR)\n+                continue;\n+            if  (st.tsym == syms.objectType.tsym || st.tsym == syms.recordType.tsym || st.isInterface())\n+                continue;\n+            if (!st.tsym.isAbstract()) {\n+                if (c != st.tsym) {\n+                    log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n+                }\n+                continue;\n+            }\n+            \/\/ dealing with an abstract value or value super class below.\n+            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n+            if ((st.tsym.flags() & HASINITBLOCK) != 0) {\n+                log.error(pos, Errors.SuperClassDeclaresInitBlock(fragment));\n+            }\n+            \/\/ No instance fields and no arged constructors both mean inner classes\n+            \/\/ cannot be super classes for primitive classes.\n+            Type encl = st.getEnclosingType();\n+            if (encl != null && encl.hasTag(CLASS)) {\n+                log.error(pos, Errors.SuperClassCannotBeInner(fragment));\n+            }\n+            for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                case VAR:\n+                    if ((s.flags() & STATIC) == 0) {\n+                        log.error(pos, Errors.SuperFieldNotAllowed(s, fragment));\n+                    }\n+                    break;\n+                case MTH:\n+                    if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                        log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));\n+                    } else if (s.isConstructor()) {\n+                        MethodSymbol m = (MethodSymbol)s;\n+                        if (m.getParameters().size() > 0) {\n+                            log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, fragment));\n+                        } else if (m.getTypeParameters().size() > 0) {\n+                            log.error(pos, Errors.SuperConstructorCannotBeGeneric(m, fragment));\n+                        } else if (m.type.getThrownTypes().size() > 0) {\n+                            log.error(pos, Errors.SuperConstructorCannotThrow(m, fragment));\n+                        } else if (protection(m.flags()) > protection(m.owner.flags())) {\n+                            log.error(pos, Errors.SuperConstructorAccessRestricted(m, fragment));\n+                        } else if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n+                                log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, fragment));\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -749,2 +806,2 @@\n-    Type checkConstructorRefType(DiagnosticPosition pos, Type t) {\n-        t = checkClassOrArrayType(pos, t);\n+    Type checkConstructorRefType(JCExpression expr, Type t) {\n+        t = checkClassOrArrayType(expr, t);\n@@ -753,1 +810,1 @@\n-                log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));\n+                log.error(expr, Errors.AbstractCantBeInstantiated(t.tsym));\n@@ -756,1 +813,1 @@\n-                log.error(pos, Errors.EnumCantBeInstantiated);\n+                log.error(expr, Errors.EnumCantBeInstantiated);\n@@ -759,1 +816,10 @@\n-                t = checkClassType(pos, t, true);\n+                \/\/ Projection types may not be mentioned in constructor references\n+                if (expr.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n+                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n+                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n+                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n+                        t = types.createErrorType(t);\n+                    }\n+                }\n+                t = checkClassType(expr, t, true);\n@@ -763,1 +829,1 @@\n-                log.error(pos, Errors.GenericArrayCreation);\n+                log.error(expr, Errors.GenericArrayCreation);\n@@ -794,0 +860,1 @@\n+     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -795,2 +862,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        if (t.isReference())\n+    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n+        if (t.isReference() && (primitiveClassOK || !t.isPrimitiveClass()))\n@@ -804,0 +871,31 @@\n+    \/** Check that type is an identity type, i.e. not a primitive\/value type\n+     *  nor its reference projection. When not discernible statically,\n+     *  give it the benefit of doubt and defer to runtime.\n+     *\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    void checkIdentityType(DiagnosticPosition pos, Type t) {\n+        if (t.hasTag(TYPEVAR)) {\n+            t = types.skipTypeVars(t, false);\n+        }\n+        if (t.isIntersection()) {\n+            IntersectionClassType ict = (IntersectionClassType)t;\n+            for (Type component : ict.getExplicitComponents()) {\n+                checkIdentityType(pos, component);\n+            }\n+            return;\n+        }\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+            typeTagError(pos, diags.fragment(Fragments.TypeReqIdentity), t);\n+    }\n+\n+    \/** Check that type is a reference type, i.e. a class, interface or array type\n+     *  or a type variable.\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        return checkRefType(pos, t, true);\n+    }\n+\n@@ -812,1 +910,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head);\n+            l.head = checkRefType(tl.head.pos(), l.head, false);\n@@ -848,0 +946,49 @@\n+    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n+        parameterizationByPrimitiveClassChecker.visit(t, pos);\n+    }\n+\n+    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n+     *  being used as type arguments and issues error against those usages.\n+     *\/\n+    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n+            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n+\n+        @Override\n+        public Void visitType(Type t, DiagnosticPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n+            for (Type targ : t.allparams()) {\n+                if (targ.isPrimitiveClass()) {\n+                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n+                }\n+                visit(targ, pos);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n+             return null;\n+        }\n+\n+        @Override\n+        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n+            return visit(t.elemtype, pos);\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n+            return visit(t.type, pos);\n+        }\n+    };\n+\n+\n+\n@@ -996,1 +1143,38 @@\n-        return types.upward(t, types.captures(t));\n+        Type varType = types.upward(t, types.captures(t));\n+        if (varType.hasTag(CLASS)) {\n+            checkParameterizationByPrimitiveClass(pos, varType);\n+        }\n+        return varType;\n+    }\n+\n+    public void checkForSuspectClassLiteralComparison(\n+            final JCBinary tree,\n+            final Type leftType,\n+            final Type rightType) {\n+\n+        if (lint.isEnabled(LintCategory.MIGRATION)) {\n+            if (isInvocationOfGetClass(tree.lhs) && isClassOfSomeInterface(rightType) ||\n+                    isInvocationOfGetClass(tree.rhs) && isClassOfSomeInterface(leftType)) {\n+                log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);\n+            }\n+        }\n+    }\n+    \/\/where\n+    private boolean isClassOfSomeInterface(Type someClass) {\n+        if (someClass.tsym.flatName() == names.java_lang_Class) {\n+            List<Type> arguments = someClass.getTypeArguments();\n+            if (arguments.length() == 1) {\n+                return arguments.head.isInterface();\n+            }\n+        }\n+        return false;\n+    }\n+    \/\/where\n+    private boolean isInvocationOfGetClass(JCExpression tree) {\n+        tree = TreeInfo.skipParens(tree);\n+        if (tree.hasTag(APPLY)) {\n+            JCMethodInvocation apply = (JCMethodInvocation)tree;\n+            MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);\n+            return msym.name == names.getClass && msym.implementedIn(syms.objectType.tsym, types) != null;\n+        }\n+        return false;\n@@ -1194,1 +1378,1 @@\n-            else\n+            else {\n@@ -1196,0 +1380,4 @@\n+                if (sym.owner.type.isValueClass() && (flags & STATIC) == 0) {\n+                    implicit |= FINAL;\n+                }\n+            }\n@@ -1221,1 +1409,2 @@\n-                mask = RecordMethodFlags;\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        RecordMethodFlags & ~SYNCHRONIZED : RecordMethodFlags;\n@@ -1223,1 +1412,3 @@\n-                mask = MethodFlags;\n+                \/\/ value objects do not have an associated monitor\/lock\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        MethodFlags & ~SYNCHRONIZED : MethodFlags;\n@@ -1240,1 +1431,1 @@\n-                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? StaticLocalFlags : LocalClassFlags;\n+                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? ExtendedStaticLocalClassFlags : ExtendedLocalClassFlags;\n@@ -1260,2 +1451,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n@@ -1274,0 +1465,11 @@\n+\n+            \/\/ primitive classes are implicitly final value classes.\n+            if ((flags & PRIMITIVE_CLASS) != 0)\n+                implicit |= VALUE_CLASS | FINAL;\n+\n+            \/\/ concrete value classes are implicitly final\n+            if ((flags & (ABSTRACT | INTERFACE | VALUE_CLASS)) == VALUE_CLASS)\n+                implicit |= FINAL;\n+\n+            \/\/ TYPs can't be declared synchronized\n+            mask &= ~SYNCHRONIZED;\n@@ -1302,1 +1504,5 @@\n-                               FINAL | NATIVE | SYNCHRONIZED)\n+                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                 &&\n+                 checkDisjoint(pos, flags,\n+                        IDENTITY_TYPE,\n+                        PRIMITIVE_CLASS | VALUE_CLASS)\n@@ -1312,1 +1518,1 @@\n-                 checkDisjoint(pos, flags,\n+                 checkDisjoint(pos, (flags | implicit), \/\/ complain against volatile & implcitly final entities too.\n@@ -1328,1 +1534,7 @@\n-                                ANNOTATION)) {\n+                                ANNOTATION)\n+                 && checkDisjoint(pos, flags,\n+                                IDENTITY_TYPE,\n+                                ANNOTATION)\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n+                                ANNOTATION) ) {\n@@ -1501,1 +1713,2 @@\n-                tree.selected.type.isParameterized()) {\n+                tree.selected.type.isParameterized() &&\n+                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n@@ -1505,0 +1718,2 @@\n+                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n+                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -1831,4 +2046,0 @@\n-        if (shouldCheckPreview(m, other, origin)) {\n-            checkPreview(tree.pos(), m, other);\n-        }\n-\n@@ -2290,0 +2501,38 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                    }\n+                }\n+            }\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n+        }\n+\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isPrimitiveClass();\n+        }\n+\n@@ -2538,0 +2787,22 @@\n+\n+        boolean cIsValue = (c.tsym.flags() & VALUE_CLASS) != 0;\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        Type identitySuper = null, valueSuper = null;\n+        for (Type t : types.closure(c)) {\n+            if (t != c) {\n+                if ((t.tsym.flags() & IDENTITY_TYPE) != 0)\n+                    identitySuper = t;\n+                else if ((t.tsym.flags() & VALUE_CLASS) != 0)\n+                    valueSuper = t;\n+                if (cIsValue &&  identitySuper != null) {\n+                    log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, identitySuper));\n+                    break;\n+                } else if (cHasIdentity &&  valueSuper != null) {\n+                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, valueSuper));\n+                    break;\n+                } else if (identitySuper != null && valueSuper != null) {\n+                    log.error(pos, Errors.MutuallyIncompatibleSupers(c, identitySuper, valueSuper));\n+                    break;\n+                }\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":297,"deletions":26,"binary":false,"changes":323,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;\n+import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;\n@@ -1430,1 +1432,1 @@\n-                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n@@ -1853,0 +1855,8 @@\n+    \/** Enum to model whether constructors allowed to \"leak\" this reference before\n+        all instance fields are DA.\n+     *\/\n+    enum ThisExposability {\n+        ALLOWED,     \/\/ identity Object classes - NOP\n+        BANNED,      \/\/ primitive\/value classes - Error\n+    }\n+\n@@ -1941,0 +1951,3 @@\n+        \/\/ Are constructors allowed to leak this reference ?\n+        ThisExposability thisExposability = ALLOWED;\n+\n@@ -2066,0 +2079,22 @@\n+        void checkEmbryonicThisExposure(JCTree node) {\n+            if (this.thisExposability == ALLOWED || classDef == null)\n+                return;\n+\n+            \/\/ Note: for non-initial constructors, firstadr is post all instance fields.\n+            for (int i = firstadr; i < nextadr; i++) {\n+                VarSymbol sym = vardecls[i].sym;\n+                if (sym.owner != classDef.sym)\n+                    continue;\n+                if ((sym.flags() & (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)\n+                    continue;\n+                if (sym.pos < startPos || sym.adr < firstadr)\n+                    continue;\n+                if (!inits.isMember(sym.adr)) {\n+                    if (this.thisExposability == BANNED) {\n+                        log.error(node, Errors.ThisExposedPrematurely);\n+                    }\n+                    return; \/\/ don't flog a dead horse.\n+                }\n+            }\n+        }\n+\n@@ -2270,0 +2305,1 @@\n+            ThisExposability priorThisExposability = this.thisExposability;\n@@ -2293,0 +2329,6 @@\n+                        this.thisExposability = ALLOWED;\n+                    } else {\n+                        if (tree.sym.owner.type.isValueClass())\n+                            this.thisExposability = BANNED;\n+                        else\n+                            this.thisExposability = ALLOWED;\n@@ -2355,0 +2397,1 @@\n+                this.thisExposability = priorThisExposability;\n@@ -2830,0 +2873,5 @@\n+            if (tree.meth.hasTag(IDENT)) {\n+                JCIdent ident = (JCIdent) tree.meth;\n+                if (ident.name != names._super && !ident.sym.isStatic())\n+                    checkEmbryonicThisExposure(tree);\n+            }\n@@ -2836,0 +2884,6 @@\n+            if (classDef != null && tree.encl == null && tree.clazz.hasTag(IDENT)) {\n+                JCIdent clazz = (JCIdent) tree.clazz;\n+                if (!clazz.sym.isStatic() && clazz.type.getEnclosingType().tsym == classDef.sym) {\n+                    checkEmbryonicThisExposure(tree);\n+                }\n+            }\n@@ -2898,1 +2952,8 @@\n-            super.visitSelect(tree);\n+            ThisExposability priorThisExposability = this.thisExposability;\n+            try {\n+                if (tree.name == names._this && classDef != null && tree.sym.owner == classDef.sym) {\n+                    checkEmbryonicThisExposure(tree);\n+                } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {\n+                    this.thisExposability = ALLOWED;\n+                }\n+                super.visitSelect(tree);\n@@ -2901,1 +2962,4 @@\n-                checkInit(tree.pos(), (VarSymbol)tree.sym);\n+                    checkInit(tree.pos(), (VarSymbol)tree.sym);\n+                }\n+            } finally {\n+                 this.thisExposability = priorThisExposability;\n@@ -2965,0 +3029,3 @@\n+            if (tree.name == names._this) {\n+                checkEmbryonicThisExposure(tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":70,"deletions":3,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-                make.QualIdent(lambdaType.getReturnType().tsym),\n+                make.QualIdent(lambdaType.getReturnType().tsym).setType(lambdaType.getReturnType()),\n@@ -1866,1 +1866,1 @@\n-                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n+                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n@@ -2343,1 +2343,1 @@\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner() || tree.sym.owner.isValueClass()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,\n+            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE,\n@@ -1143,0 +1143,3 @@\n+                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n+                boolean requireReferenceProjection =\n+                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1158,0 +1161,3 @@\n+                    if (requireReferenceProjection) {\n+                        tree.setType(tree.type.referenceProjection());\n+                    }\n@@ -1161,0 +1167,3 @@\n+                    if (requireReferenceProjection) {\n+                        tree.setType(tree.type.referenceProjection());\n+                    }\n@@ -1289,1 +1298,1 @@\n-                ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;\n+                ctag = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, topClass).sym;\n@@ -1465,0 +1474,1 @@\n+            final Type type = v.erasure(types);\n@@ -1466,1 +1476,1 @@\n-                flags, proxyName, v.erasure(types), owner);\n+                flags, proxyName, type, owner);\n@@ -1533,1 +1543,3 @@\n-        VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);\n+        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n+        long flags = FINAL | SYNTHETIC;\n+        VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);\n@@ -1716,1 +1728,1 @@\n-        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n+        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n@@ -1868,1 +1880,1 @@\n-        return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;\n+        return makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, clazz).sym;\n@@ -1920,1 +1932,1 @@\n-        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;\n+        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, outermostClassDef.sym).sym;\n@@ -2100,1 +2112,2 @@\n-        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n+        return (tree == null) ? null :\n+                applyPrimitiveConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);\n@@ -2239,1 +2252,1 @@\n-        tree.mods.flags &= ClassFlags;\n+        tree.mods.flags &= AdjustedClassFlags;\n@@ -3119,0 +3132,14 @@\n+    \/** Apply primitive value\/reference conversions as needed *\/\n+    @SuppressWarnings(\"unchecked\")\n+    <T extends JCExpression> T applyPrimitiveConversionsAsNeeded(T tree, Type type) {\n+        boolean haveValue = tree.type.isPrimitiveClass();\n+        if (haveValue == type.isPrimitiveClass())\n+            return tree;\n+        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n+        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n+        return (T) make.TypeCast(type, tree);\n+\n+    }\n+\n+\n+\n@@ -3517,1 +3544,1 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n@@ -3530,1 +3557,1 @@\n-                                            types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)),\n+                                            types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)),\n@@ -3607,0 +3634,17 @@\n+    public void visitWithField(JCWithField tree) {\n+        Type fieldType = tree.field.type;\n+        tree.field = translate(tree.field, tree);\n+        tree.value = translate(tree.value, fieldType); \/\/ important to use pre-translation type.\n+\n+        \/\/ If translated field is an Apply, we are\n+        \/\/ seeing an access method invocation. In this case, append\n+        \/\/ right hand side as last argument of the access method.\n+        if (tree.field.hasTag(APPLY)) {\n+            JCMethodInvocation app = (JCMethodInvocation) tree.field;\n+            app.args = List.of(tree.value).prependList(app.args);\n+            result = app;\n+        } else {\n+            result = tree;\n+        }\n+    }\n+\n@@ -4097,0 +4141,5 @@\n+        \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n+         * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n+         * always matching the behavior of Object::getClass\n+         *\/\n+        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n@@ -4098,0 +4147,3 @@\n+        if (needPrimaryMirror && tree.selected.type.isPrimitiveClass()) {\n+            tree.selected.setType(tree.selected.type.referenceProjection());\n+        }\n@@ -4105,1 +4157,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":64,"deletions":12,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -68,1 +67,0 @@\n-import java.util.function.Consumer;\n@@ -424,37 +422,54 @@\n-        switch ((short)(sym.flags() & AccessFlags)) {\n-        case PRIVATE:\n-            return\n-                (env.enclClass.sym == sym.owner \/\/ fast special case\n-                 ||\n-                 env.enclClass.sym.outermostClass() ==\n-                 sym.owner.outermostClass())\n-                &&\n-                sym.isInheritedIn(site.tsym, types);\n-        case 0:\n-            return\n-                (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n-                 ||\n-                 env.toplevel.packge == sym.packge())\n-                &&\n-                isAccessible(env, site, checkInner)\n-                &&\n-                sym.isInheritedIn(site.tsym, types)\n-                &&\n-                notOverriddenIn(site, sym);\n-        case PROTECTED:\n-            return\n-                (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n-                 ||\n-                 env.toplevel.packge == sym.packge()\n-                 ||\n-                 isProtectedAccessible(sym, env.enclClass.sym, site)\n-                 ||\n-                 \/\/ OK to select instance method or field from 'super' or type name\n-                 \/\/ (but type names should be disallowed elsewhere!)\n-                 env.info.selectSuper && (sym.flags() & STATIC) == 0 && sym.kind != TYP)\n-                &&\n-                isAccessible(env, site, checkInner)\n-                &&\n-                notOverriddenIn(site, sym);\n-        default: \/\/ this case includes erroneous combinations as well\n-            return isAccessible(env, site, checkInner) && notOverriddenIn(site, sym);\n+        ClassSymbol enclosingCsym = env.enclClass.sym;\n+        if (sym.kind == MTH || sym.kind == VAR) {\n+            \/* If any primitive class types are involved, ask the same question in the reference universe,\n+               where the hierarchy is navigable\n+            *\/\n+            if (site.isPrimitiveClass())\n+                site = site.referenceProjection();\n+        } else if (sym.kind == TYP) {\n+            \/\/ A type is accessible in a reference projection if it was\n+            \/\/ accessible in the value projection.\n+            if (site.isReferenceProjection())\n+                site = site.valueProjection();\n+        }\n+        try {\n+            switch ((short)(sym.flags() & AccessFlags)) {\n+                case PRIVATE:\n+                    return\n+                            (env.enclClass.sym == sym.owner \/\/ fast special case\n+                                    ||\n+                                    env.enclClass.sym.outermostClass() ==\n+                                            sym.owner.outermostClass())\n+                                    &&\n+                                    sym.isInheritedIn(site.tsym, types);\n+                case 0:\n+                    return\n+                            (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n+                                    ||\n+                                    env.toplevel.packge == sym.packge())\n+                                    &&\n+                                    isAccessible(env, site, checkInner)\n+                                    &&\n+                                    sym.isInheritedIn(site.tsym, types)\n+                                    &&\n+                                    notOverriddenIn(site, sym);\n+                case PROTECTED:\n+                    return\n+                            (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n+                                    ||\n+                                    env.toplevel.packge == sym.packge()\n+                                    ||\n+                                    isProtectedAccessible(sym, env.enclClass.sym, site)\n+                                    ||\n+                                    \/\/ OK to select instance method or field from 'super' or type name\n+                                    \/\/ (but type names should be disallowed elsewhere!)\n+                                    env.info.selectSuper && (sym.flags() & STATIC) == 0 && sym.kind != TYP)\n+                                    &&\n+                                    isAccessible(env, site, checkInner)\n+                                    &&\n+                                    notOverriddenIn(site, sym);\n+                default: \/\/ this case includes erroneous combinations as well\n+                    return isAccessible(env, site, checkInner) && notOverriddenIn(site, sym);\n+            }\n+        } finally {\n+            env.enclClass.sym = enclosingCsym;\n@@ -473,5 +488,10 @@\n-        else {\n-            Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n-            return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n-                    !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n-        }\n+\n+        \/* If any primitive class types are involved, ask the same question in the reference universe,\n+           where the hierarchy is navigable\n+        *\/\n+        if (site.isPrimitiveClass())\n+            site = site.referenceProjection();\n+\n+        Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n+        return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n+                !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n@@ -1698,1 +1718,1 @@\n-                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n@@ -1703,1 +1723,1 @@\n-                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n@@ -2305,0 +2325,16 @@\n+        return findMemberTypeInternal(env,site, name, c);\n+    }\n+\n+    \/** Find qualified member type.\n+     *  @param env       The current environment.\n+     *  @param site      The original type from where the selection takes\n+     *                   place.\n+     *  @param name      The type's name.\n+     *  @param c         The class to search for the member type. This is\n+     *                   always a superclass or implemented interface of\n+     *                   site's class.\n+     *\/\n+    Symbol findMemberTypeInternal(Env<AttrContext> env,\n+                          Type site,\n+                          Name name,\n+                          TypeSymbol c) {\n@@ -2353,0 +2389,8 @@\n+        return findTypeInternal(env, name);\n+    }\n+\n+    \/** Find an unqualified type symbol.\n+     *  @param env       The current environment.\n+     *  @param name      The type's name.\n+     *\/\n+    Symbol findTypeInternal(Env<AttrContext> env, Name name) {\n@@ -3577,1 +3621,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n@@ -3630,1 +3674,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n@@ -3689,1 +3733,1 @@\n-                this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());\n+                this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata(), site.getFlavor());\n@@ -3779,1 +3823,1 @@\n-                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":94,"deletions":50,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -513,0 +513,7 @@\n+    public void visitWithField(JCWithField tree) {\n+        tree.field = translate(tree.field, null);\n+        tree.value = translate(tree.value, erasure(tree.field.type));\n+        tree.type = erasure(tree.type);\n+        result = retype(tree, tree.type, pt);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -55,0 +56,1 @@\n+import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;\n@@ -752,1 +754,0 @@\n-\n@@ -1101,0 +1102,11 @@\n+\n+            if (tree.sym != syms.objectType.tsym && tree.sym != syms.recordType.tsym) {\n+                if ((tree.sym.flags() & (ABSTRACT | INTERFACE | VALUE_CLASS)) == 0) {\n+                    tree.sym.flags_field |= IDENTITY_TYPE;\n+                }\n+                if ((tree.sym.flags() & (ABSTRACT | IDENTITY_TYPE | INTERFACE)) == ABSTRACT) {\n+                    if (abstractClassHasImplicitIdentity(tree)) {\n+                        tree.sym.flags_field |= IDENTITY_TYPE;\n+                    }\n+                }\n+            }\n@@ -1103,0 +1115,44 @@\n+            \/\/ where\n+            private boolean abstractClassHasImplicitIdentity(JCClassDecl tree) {\n+\n+                Type t = tree.sym.type;\n+\n+                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n+                    return false;\n+\n+                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n+                    return true;\n+                }\n+\n+                \/\/ No instance fields and no arged constructors both mean inner classes cannot be value class supers.\n+                Type encl = t.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    return true;\n+                }\n+                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0) {\n+                                return true;\n+                            }\n+                            break;\n+                        case MTH:\n+                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                                return true;\n+                            } else if (s.isConstructor()) {\n+                                MethodSymbol m = (MethodSymbol)s;\n+                                if (m.getParameters().size() > 0\n+                                        || m.getTypeParameters().size() > 0\n+                                        || m.type.getThrownTypes().nonEmpty()\n+                                        || (m.flags() & EMPTYNOARGCONSTR) == 0\n+                                        || (Check.protection(m.flags()) > Check.protection(m.owner.flags()))) {\n+                                    return true;\n+                                }\n+                            }\n+                            break;\n+                    }\n+                }\n+                return false;\n+            }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -285,0 +284,7 @@\n+        public void visitWithField(JCWithField tree) {\n+            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n+            sr.mergeWith(csp(tree.field));\n+            sr.mergeWith(csp(tree.value));\n+            result = sr;\n+        }\n+\n@@ -381,0 +387,7 @@\n+        @Override\n+        public void visitDefaultValue(JCDefaultValue tree) {\n+            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n+            sr.mergeWith(csp(tree.clazz));\n+            result = sr;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     classig    ::= 'L' name [typeargs] ';'\n+ *     classig    ::= 'L' name [typeargs] ';' | 'Q' name [typeargs] ';'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import com.sun.tools.javac.code.Scope.WriteableScope;\n@@ -145,0 +146,2 @@\n+    private final Symtab syms;\n+\n@@ -178,0 +181,1 @@\n+        syms = Symtab.instance(context);\n@@ -217,1 +221,0 @@\n-\n@@ -237,1 +240,1 @@\n-            \"SUPER\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n+            \"IDENTITY\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n@@ -830,1 +833,0 @@\n-            flags &= ~STRICTFP; \/\/inner classes should not have the strictfp flag set.\n@@ -846,0 +848,11 @@\n+     \/** Write out \"Preload\" attribute by enumerating the value classes encountered in field\/method descriptors during this compilation.\n+      *\/\n+     void writePreloadAttribute() {\n+        int alenIdx = writeAttr(names.Preload);\n+        databuf.appendChar(poolWriter.preloadClasses.size());\n+        for (ClassSymbol c : poolWriter.preloadClasses) {\n+            databuf.appendChar(poolWriter.putClass(c));\n+        }\n+        endAttr(alenIdx);\n+     }\n+\n@@ -959,0 +972,4 @@\n+        Type fldType = v.erasure(types);\n+        if (fldType.requiresPreload(v.owner)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) fldType.tsym);\n+        }\n@@ -984,0 +1001,10 @@\n+        MethodType mtype = (MethodType) m.externalType(types);\n+        for (Type t : mtype.getParameterTypes()) {\n+            if (t.requiresPreload(m.owner)) {\n+                poolWriter.enterPreloadClass((ClassSymbol) t.tsym);\n+            }\n+        }\n+        Type returnType = mtype.getReturnType();\n+        if (returnType.requiresPreload(m.owner)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) returnType.tsym);\n+        }\n@@ -1008,1 +1035,3 @@\n-        if (target.hasMethodParameters() && (options.isSet(PARAMETERS) || m.isConstructor() && (m.flags_field & RECORD) != 0)) {\n+        if (target.hasMethodParameters() && (\n+                options.isSet(PARAMETERS)\n+                || ((m.flags_field & RECORD) != 0 && (m.isConstructor() || m.isValueObjectFactory())))) {\n@@ -1228,0 +1257,4 @@\n+                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n+                databuf.appendByte(7);\n+                databuf.appendChar(t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n+                break;\n@@ -1539,1 +1572,1 @@\n-            flags = adjustFlags(c.flags() & ~DEFAULT);\n+            flags = adjustFlags(c.flags() & ~(DEFAULT | STRICTFP));\n@@ -1541,2 +1574,1 @@\n-            flags = flags & ClassFlags & ~STRICTFP;\n-            if ((flags & INTERFACE) == 0) flags |= ACC_SUPER;\n+            flags = flags & AdjustedClassFlags;\n@@ -1570,1 +1602,1 @@\n-            case TYP: poolWriter.enterInner((ClassSymbol)sym); break;\n+            case TYP: poolWriter.enterInnerClass((ClassSymbol)sym); break;\n@@ -1577,1 +1609,1 @@\n-                poolWriter.enterInner(local);\n+                poolWriter.enterInnerClass(local);\n@@ -1668,0 +1700,5 @@\n+        if (!poolWriter.preloadClasses.isEmpty()) {\n+            writePreloadAttribute();\n+            acount++;\n+        }\n+\n@@ -1711,0 +1748,6 @@\n+        if ((flags & PRIMITIVE_CLASS) != 0)\n+            result |= ACC_PRIMITIVE;\n+        if ((flags & VALUE_CLASS) != 0)\n+            result |= ACC_VALUE;\n+        if ((flags & IDENTITY_TYPE) != 0)\n+            result |= ACC_IDENTITY;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.function.ToIntFunction;\n@@ -40,11 +39,0 @@\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;\n@@ -402,0 +390,11 @@\n+    public void emitLdc(LoadableConstant constant, int od) {\n+        if (od <= 255) {\n+            emitop1(ldc1, od, constant);\n+        }\n+        else {\n+            emitop2(ldc2, od, constant);\n+        }\n+    }\n+\n+    \/** Emit a ldc (or ldc_w) instruction, taking into account operand size\n+     *\/\n@@ -1023,1 +1022,6 @@\n-            state.push(uninitializedObject(t.tsym.erasure(types), cp-3));\n+            state.push(uninitializedObject(t.tsym.erasure(types), cp - 3));\n+            break;\n+        }\n+        case aconst_init: {\n+            Type t = (Type)data;\n+            state.push(t.tsym.erasure(types));\n@@ -1052,0 +1056,3 @@\n+        case withfield:\n+            state.pop(((Symbol)data).erasure(types));\n+            break;\n@@ -1062,1 +1069,1 @@\n-            Type t = types.erasure((Type)data);\n+            Type t = types.erasure(data instanceof  ConstantPoolQType ? ((ConstantPoolQType)data).type: (Type)data);\n@@ -1776,2 +1783,2 @@\n-                Assert.check(types.isSubtype(types.erasure(old),\n-                                       types.erasure(t)));\n+                Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n+                        (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n@@ -2451,0 +2458,2 @@\n+            mnem[aconst_init] = \"aconst_init\";\n+            mnem[withfield] = \"withfield\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -80,0 +81,1 @@\n+    private final TransValues transValues;\n@@ -116,0 +118,1 @@\n+        transValues = TransValues.instance(context);\n@@ -264,0 +267,14 @@\n+    \/** Insert a reference to given type in the constant pool,\n+     *  checking for an array with too many dimensions;\n+     *  return the reference's index.\n+     *  @param type   The type for which a reference is inserted.\n+     *\/\n+    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n+        checkDimension(pos, type);\n+        if (emitQtype) {\n+            return poolWriter.putClass(new ConstantPoolQType(type, types));\n+        } else {\n+            return poolWriter.putClass(type);\n+        }\n+    }\n+\n@@ -270,1 +287,1 @@\n-        return poolWriter.putClass(checkDimension(pos, type));\n+        return makeRef(pos, type, false);\n@@ -990,0 +1007,3 @@\n+                    } else if (env.enclMethod.sym.isValueObjectFactory()) {\n+                        items.makeLocalItem(env.enclMethod.factoryProduct).load();\n+                        code.emitop0(areturn);\n@@ -1093,0 +1113,4 @@\n+        Type localType = v.erasure(types);\n+        if (localType.requiresPreload(env.enclClass.sym)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) localType.tsym);\n+        }\n@@ -1118,0 +1142,31 @@\n+    public void visitWithField(JCWithField tree) {\n+        switch(tree.field.getTag()) {\n+            case IDENT:\n+                Symbol sym = ((JCIdent) tree.field).sym;\n+                items.makeThisItem().load();\n+                genExpr(tree.value, tree.field.type).load();\n+                sym = binaryQualifier(sym, env.enclClass.type);\n+                code.emitop2(withfield, sym, PoolWriter::putMember);\n+                result = items.makeStackItem(tree.type);\n+                break;\n+            case SELECT:\n+                JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;\n+                sym = TreeInfo.symbol(fieldAccess);\n+                \/\/ JDK-8207332: To maintain the order of side effects, must compute value ahead of field\n+                genExpr(tree.value, tree.field.type).load();\n+                genExpr(fieldAccess.selected, fieldAccess.selected.type).load();\n+                if (Code.width(tree.field.type) == 2) {\n+                    code.emitop0(dup_x2);\n+                    code.emitop0(pop);\n+                } else {\n+                    code.emitop0(swap);\n+                }\n+                sym = binaryQualifier(sym, fieldAccess.selected.type);\n+                code.emitop2(withfield, sym, PoolWriter::putMember);\n+                result = items.makeStackItem(tree.type);\n+                break;\n+            default:\n+                Assert.check(false);\n+        }\n+    }\n+\n@@ -1974,0 +2029,1 @@\n+\n@@ -2012,1 +2068,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype), type);\n+                code.emitAnewarray(makeRef(pos, elemtype, elemtype.isPrimitiveClass()), type);\n@@ -2238,0 +2294,1 @@\n+        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2240,2 +2297,9 @@\n-           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n-            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n+           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n+            checkDimension(tree.pos(), tree.clazz.type);\n+            if (tree.clazz.type.isPrimitiveClass()) {\n+                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n+            } else {\n+                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n+            }\n+\n@@ -2303,1 +2367,1 @@\n-            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n@@ -2306,1 +2370,1 @@\n-       }\n+        }\n@@ -2362,0 +2426,12 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        if (tree.type.isValueClass()) {\n+            code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n+        } else if (tree.type.isReference()) {\n+            code.emitop0(aconst_null);\n+        } else {\n+            code.emitop0(zero(Code.typecode(tree.type)));\n+        }\n+        result = items.makeStackItem(tree.type);\n+        return;\n+    }\n+\n@@ -2418,0 +2494,1 @@\n+            cdef = transValues.translateTopLevelClass(cdef, make);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":83,"deletions":6,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Flags.Flag;\n@@ -52,0 +53,1 @@\n+import static com.sun.tools.javac.code.Flags.asFlagSet;\n@@ -60,0 +62,1 @@\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;\n@@ -191,0 +194,4 @@\n+        this.allowPrimitiveClasses = (!preview.isPreview(Feature.PRIMITIVE_CLASSES) || preview.isEnabled()) &&\n+                Feature.PRIMITIVE_CLASSES.allowedInSource(source);\n+        this.allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -228,0 +235,8 @@\n+    \/** Switch: are primitive classes allowed in this source level?\n+     *\/\n+     boolean allowPrimitiveClasses;\n+\n+    \/** Switch: are value classes allowed in this source level?\n+     *\/\n+    boolean allowValueClasses;\n+\n@@ -475,0 +490,16 @@\n+    \/** If next input token matches one of the two given tokens, skip it, otherwise report\n+     *  an error.\n+     *\n+     * @return The actual token kind.\n+     *\/\n+    public TokenKind accept2(TokenKind tk1, TokenKind tk2) {\n+        TokenKind returnValue = token.kind;\n+        if (token.kind == tk1 || token.kind == tk2) {\n+            nextToken();\n+        } else {\n+            setErrorEndPos(token.pos);\n+            reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));\n+        }\n+        return returnValue;\n+    }\n+\n@@ -1383,0 +1414,6 @@\n+                            case DEFAULT:\n+                                if (typeArgs != null) return illegal();\n+                                selectExprMode();\n+                                t = to(F.at(pos).DefaultValue(t));\n+                                nextToken();\n+                                break loop;\n@@ -1440,3 +1477,4 @@\n-                        if ((mode & TYPE) == 0 && isUnboundMemberRef()) {\n-                            \/\/this is an unbound method reference whose qualifier\n-                            \/\/is a generic type i.e. A<S>::m\n+                        if ((mode & TYPE) == 0 && isParameterizedTypePrefix()) {\n+                            \/\/this is either an unbound method reference whose qualifier\n+                            \/\/is a generic type i.e. A<S>::m or a default value creation of\n+                            \/\/the form ValueType<S>.default\n@@ -1455,0 +1493,6 @@\n+                                if (token.kind == DEFAULT) {\n+                                    t =  toP(F.at(token.pos).DefaultValue(t));\n+                                    nextToken();\n+                                    selectExprMode();\n+                                    return term3Rest(t, typeArgs);\n+                                }\n@@ -1621,1 +1665,1 @@\n-                } else if (token.kind == NEW && (mode & EXPR) != 0) {\n+                } else if ((token.kind == NEW) && (mode & EXPR) != 0) {\n@@ -1675,1 +1719,2 @@\n-     * method reference or a binary expression. To disambiguate, look for a\n+     * method reference or a default value creation that uses a parameterized type\n+     * or a binary expression. To disambiguate, look for a\n@@ -1679,1 +1724,1 @@\n-    boolean isUnboundMemberRef() {\n+    boolean isParameterizedTypePrefix() {\n@@ -2279,1 +2324,1 @@\n-            accept(CLASS);\n+            TokenKind selector = accept2(CLASS, DEFAULT);\n@@ -2297,1 +2342,5 @@\n-                t = toP(F.at(pos).Select(t, names._class));\n+                if (selector == CLASS) {\n+                    t = toP(F.at(pos).Select(t, names._class));\n+                } else {\n+                    t = toP(F.at(pos).DefaultValue(t));\n+                }\n@@ -2342,2 +2391,5 @@\n-        List<JCAnnotation> newAnnotations = typeAnnotationsOpt();\n-\n+        final JCModifiers mods = modifiersOpt();\n+        List<JCAnnotation> newAnnotations = mods.annotations;\n+        if (!newAnnotations.isEmpty()) {\n+            checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);\n+        }\n@@ -2347,0 +2399,3 @@\n+            if (mods.flags != 0) {\n+                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n+            }\n@@ -2415,0 +2470,3 @@\n+            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            if (badModifiers != 0)\n+                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));\n@@ -2419,1 +2477,5 @@\n-            return classCreatorRest(newpos, null, typeArgs, t);\n+            JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);\n+            if ((newClass.def == null) && (mods.flags != 0)) {\n+                log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n+            }\n+            return newClass;\n@@ -2444,1 +2506,1 @@\n-        return classCreatorRest(newpos, encl, typeArgs, t);\n+        return classCreatorRest(newpos, encl, typeArgs, t, 0);\n@@ -2522,1 +2584,2 @@\n-                                  JCExpression t)\n+                                  JCExpression t,\n+                                  long flags)\n@@ -2529,1 +2592,1 @@\n-            JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n+            JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);\n@@ -2532,1 +2595,2 @@\n-        return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n+        JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n+        return newClass;\n@@ -2765,0 +2829,4 @@\n+        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+            dc = token.comment(CommentStyle.JAVADOC);\n+            return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));\n+        }\n@@ -3224,1 +3292,4 @@\n-                return variableDeclarators(modifiersOpt(), t, stats, true).toList();\n+                pos = token.pos;\n+                JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n+                F.at(pos);\n+                return variableDeclarators(mods, t, stats, true).toList();\n@@ -3321,0 +3392,12 @@\n+                if (isPrimitiveModifier()) {\n+                    flag = Flags.PRIMITIVE_CLASS;\n+                    break;\n+                }\n+                if (isValueModifier()) {\n+                    flag = Flags.VALUE_CLASS;\n+                    break;\n+                }\n+                if (isIdentityModifier()) {\n+                    flag = Flags.IDENTITY_TYPE;\n+                    break;\n+                }\n@@ -3334,2 +3417,9 @@\n-                    annotations.append(ann);\n-                    flag = 0;\n+                    final Name name = TreeInfo.name(ann.annotationType);\n+                    if (name == names.__primitive__ || name == names.java_lang___primitive__) {\n+                        flag = Flags.PRIMITIVE_CLASS;\n+                    } else if (name == names.__value__ || name == names.java_lang___value__) {\n+                        flag = Flags.VALUE_CLASS;\n+                    } else {\n+                        annotations.append(ann);\n+                        flag = 0;\n+                    }\n@@ -3575,0 +3665,21 @@\n+        if (name == names.primitive) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n+        if (name == names.value) {\n+            if (allowValueClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n+        if (name == names.identity) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -4474,0 +4585,78 @@\n+    protected boolean isPrimitiveModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n+            boolean isPrimitiveModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isPrimitiveModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                            || next.name() == names.value || (mode & EXPR) != 0)\n+                        isPrimitiveModifier = true;\n+                    break;\n+            }\n+            if (isPrimitiveModifier) {\n+                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isValueModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.value) {\n+            boolean isValueModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isValueModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value || next.name() == names.identity\n+                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                        isValueModifier = true;\n+                    break;\n+            }\n+            if (isValueModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isIdentityModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.identity) {\n+            boolean isIdentityModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isIdentityModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ identity record R || identity primitive || || identity identity || identity value || new identity Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                            || next.name() == names.value || (mode & EXPR) != 0)\n+                        isIdentityModifier = true;\n+                    break;\n+            }\n+            if (isIdentityModifier) {\n+                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -4501,1 +4690,4 @@\n-                case IDENTIFIER -> isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;\n+                case IDENTIFIER -> isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) ||\n+                        next.name() == names.sealed ||\n+                        next.name() == names.value ||\n+                        next.name() == names.identity;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":211,"deletions":19,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -266,0 +266,6 @@\n+compiler.misc.value.interface.nonfunctional=\\\n+    since it is a value interface\n+\n+compiler.misc.identity.interface.nonfunctional=\\\n+    since it is an identity interface\n+\n@@ -699,1 +705,1 @@\n-    improperly formed type, some parameters are missing\n+    improperly formed type, some parameters are missing or misplaced\n@@ -2580,0 +2586,3 @@\n+compiler.misc.type.req.identity=\\\n+    a type with identity\n+\n@@ -3928,0 +3937,93 @@\n+compiler.misc.feature.primitive.classes=\\\n+    primitive classes\n+\n+compiler.misc.feature.value.classes=\\\n+    value classes\n+\n+# 0: symbol\n+compiler.err.cyclic.primitive.class.membership=\\\n+    cyclic primitive class membership involving {0}\n+\n+compiler.warn.get.class.compared.with.interface=\\\n+    return value of getClass() can never equal the class literal of an interface\n+\n+# 0: name (of method)\n+compiler.err.value.class.does.not.support=\\\n+    value classes do not support {0}\n+\n+compiler.err.value.class.may.not.extend=\\\n+    inappropriate super class declaration for a value class\n+\n+compiler.err.this.exposed.prematurely=\\\n+    value class instance should not be passed around before being fully initialized\n+\n+# 0: type\n+compiler.err.generic.parameterization.with.primitive.class=\\\n+    Inferred type {0} involves generic parameterization by a primitive class\n+\n+# 0: type, 1: type\n+compiler.err.value.type.has.identity.super.type=\\\n+    The identity type {1} cannot be a supertype of the value type {0}\n+\n+# 0: type, 1: type\n+compiler.err.identity.type.has.value.super.type=\\\n+    The value type {1} cannot be a supertype of the identity type {0}\n+\n+# 0: type, 1: type, 2: type\n+compiler.err.mutually.incompatible.supers=\\\n+    The type {0} has mutually incompatible supertypes: the identity type {1} and the value type {2}\n+\n+# 0: symbol, 1: type\n+compiler.err.concrete.supertype.for.value.class=\\\n+    The concrete class {1} is not allowed to be a super class of the value class {0} either directly or indirectly\n+\n+# 0: symbol, 1: symbol, 2: type\n+compiler.err.super.method.cannot.be.synchronized=\\\n+    The method {0} in the super class {2} of the value class {1} is synchronized. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.cannot.take.arguments=\\\n+    {1} defines a constructor {0} that takes arguments. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.cannot.be.generic=\\\n+    {1} defines a generic constructor {0}. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.cannot.throw=\\\n+    {1} defines a constructor {0} that throws an exception. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.access.restricted=\\\n+    {1} defines a constructor {0} with a weaker access privilege than the declaring class. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.field.not.allowed=\\\n+    {1} defines an instance field {0}. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.no.arg.constructor.must.be.empty=\\\n+    {1} defines a nonempty no-arg constructor {0}. This is disallowed\n+\n+# 0: message segment\n+compiler.err.super.class.declares.init.block=\\\n+    {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n+\n+# 0: message segment\n+compiler.err.super.class.cannot.be.inner=\\\n+    {0} is an inner class. This is disallowed.\n+\n+# 0: symbol, 1: type\n+compiler.misc.superclass.of.value.class=\\\n+    The super class {1} of the value class {0}\n+\n+# 0: symbol\n+compiler.misc.abstract.value.class=\\\n+    The abstract value class {0}\n+\n+compiler.err.projection.cant.be.instantiated=\\\n+    Illegal attempt to instantiate a projection type\n+\n+compiler.err.call.to.super.not.allowed.in.value.ctor=\\\n+    call to super not allowed in value class constructor\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -216,0 +216,3 @@\n+javac.opt.Xlint.desc.migration=\\\n+    Warn about issues related to migration of JDK classes.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,0 +136,4 @@\n+        \/** Withfields, of type WithField.\n+         *\/\n+        WITHFIELD,\n+\n@@ -260,0 +264,4 @@\n+        \/** Default values, of type DefaultValueTree.\n+         *\/\n+        DEFAULT_VALUE,\n+\n@@ -724,1 +732,0 @@\n-\n@@ -884,0 +891,3 @@\n+        \/** nascent value that evolves into the return value for a value factory *\/\n+        public VarSymbol factoryProduct;\n+\n@@ -1163,0 +1173,30 @@\n+    \/**\n+     * A withfield expression\n+     *\/\n+    public static class JCWithField extends JCExpression implements WithFieldTree {\n+        public JCExpression field;\n+        public JCExpression value;\n+        protected JCWithField(JCExpression field, JCExpression value) {\n+            this.field = field;\n+            this.value = value;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitWithField(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.WITH_FIELD; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getField() { return field; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getValue() { return value; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitWithField(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return WITHFIELD;\n+        }\n+    }\n+\n@@ -1365,0 +1405,26 @@\n+    \/**\n+     * A \"Identifier<TA1, TA2>.default\" construction.\n+     *\/\n+    public static class JCDefaultValue extends JCPolyExpression implements DefaultValueTree {\n+        public JCExpression clazz;\n+\n+        protected JCDefaultValue(JCExpression clazz) {\n+            this.clazz = clazz;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitDefaultValue(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.DEFAULT_VALUE; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getType() { return clazz; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitDefaultValue(this, d);\n+        }\n+        @Override\n+        public Tag getTag() {\n+            return DEFAULT_VALUE;\n+        }\n+    }\n+\n@@ -3423,0 +3489,1 @@\n+        JCDefaultValue DefaultValue(JCExpression type);\n@@ -3495,0 +3562,1 @@\n+        public void visitWithField(JCWithField that)         { visitTree(that); }\n@@ -3500,0 +3568,1 @@\n+        public void visitDefaultValue(JCDefaultValue that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -736,0 +736,9 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        try {\n+            printExpr(tree.clazz, TreeInfo.postfixPrec);\n+            print(\".default\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n@@ -772,0 +781,12 @@\n+    public void visitWithField(JCWithField tree) {\n+        try {\n+            print(\"__WithField(\");\n+            printExpr(tree.field);\n+            print(\", \");\n+            printExpr(tree.value);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -201,0 +201,7 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDefaultValue(DefaultValueTree node, P p) {\n+        JCDefaultValue t = (JCDefaultValue) node;\n+        JCExpression clazz = copy(t.clazz, p);\n+        return M.at(t.pos).DefaultValue(clazz);\n+    }\n+\n@@ -245,1 +252,2 @@\n-        return M.at(t.pos).Ident(t.name);\n+        JCIdent ident = M.at(t.pos).Ident(t.name);\n+        return ident;\n@@ -361,1 +369,2 @@\n-        return M.at(t.pos).Select(selected, t.name);\n+        JCFieldAccess select = M.at(t.pos).Select(selected, t.name);\n+        return select;\n@@ -566,0 +575,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitWithField(WithFieldTree node, P p) {\n+        JCWithField t = (JCWithField) node;\n+        JCExpression field = copy(t.field, p);\n+        JCExpression value = copy(t.value, p);\n+        return M.at(t.pos).WithField(field, value);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+     *  Optionally, check only for no-arg ctor invocation\n@@ -115,1 +116,1 @@\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names) {\n+    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names, boolean argsAllowed) {\n@@ -121,4 +122,6 @@\n-                    Name methName = TreeInfo.name(apply.meth);\n-                    if (methName == names._this ||\n-                        methName == names._super) {\n-                        return methName;\n+                    if (argsAllowed || apply.args.size() == 0) {\n+                        Name methName = TreeInfo.name(apply.meth);\n+                        if (methName == names._this ||\n+                                methName == names._super) {\n+                            return methName;\n+                        }\n@@ -488,0 +491,2 @@\n+            case DEFAULT_VALUE:\n+                return getStartPos(((JCDefaultValue) tree).clazz);\n@@ -635,0 +640,2 @@\n+            case WITHFIELD:\n+                return getEndPos(((JCWithField) tree).value, endPosTable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -266,0 +266,6 @@\n+    public JCWithField WithField(JCExpression field, JCExpression value) {\n+        JCWithField tree = new JCWithField(field, value);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -301,0 +307,6 @@\n+    public JCDefaultValue DefaultValue(JCExpression type) {\n+        JCDefaultValue tree = new JCDefaultValue(type);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -855,7 +867,22 @@\n-                Type outer = t.getEnclosingType();\n-                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n-                        ? Select(Type(outer), t.tsym)\n-                        : QualIdent(t.tsym);\n-                tp = t.getTypeArguments().isEmpty()\n-                        ? clazz\n-                        : TypeApply(clazz, Types(t.getTypeArguments()));\n+                if (t.isReferenceProjection()) {\n+                    \/\/ For parameterized types, we want V.ref<A1 ... An> not V<A1 ... An>.ref\n+                    JCExpression vp = Type(t.valueProjection());\n+                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n+                        \/\/ vp now is V<A1 ... An>, build V.ref<A1 ... An>\n+                        JCFieldAccess f = (JCFieldAccess) Select(((JCTypeApply) vp).clazz, t.tsym);\n+                        f.name = names.ref;\n+                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n+                    } else {\n+                        JCFieldAccess f = (JCFieldAccess) Select(vp, t.tsym);\n+                        f.name = names.ref;\n+                        tp = f;\n+                    }\n+                } else {\n+                    Type outer = t.getEnclosingType();\n+                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n+                            ? Select(Type(outer), t.tsym)\n+                            : QualIdent(t.tsym);\n+                    tp = t.getTypeArguments().isEmpty()\n+                            ? clazz\n+                            : TypeApply(clazz, Types(t.getTypeArguments()));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -157,0 +157,5 @@\n+    public void visitWithField(JCWithField tree) {\n+        scan(tree.field);\n+        scan(tree.value);\n+    }\n+\n@@ -184,0 +189,4 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        scan(tree.clazz);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,0 +183,6 @@\n+    public void visitWithField(JCWithField tree) {\n+        tree.field = translate(tree.field);\n+        tree.value = translate(tree.value);\n+        result = tree;\n+    }\n+\n@@ -401,0 +407,5 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        tree.clazz = translate(tree.clazz);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    public final Name _default;\n@@ -103,0 +104,2 @@\n+    public final Name primitive;\n+    public final Name identity;\n@@ -107,0 +110,1 @@\n+    public final Name isValueObject;\n@@ -114,0 +118,5 @@\n+    public final Name java_lang_System;\n+    public final Name __primitive__;\n+    public final Name java_lang___primitive__;\n+    public final Name __value__;\n+    public final Name java_lang___value__;\n@@ -151,0 +160,1 @@\n+    public final Name Preload;\n@@ -204,0 +214,6 @@\n+    \/\/ values\n+    public final Name dollarValue;\n+    public final Name ref;\n+    public final Name val;\n+\n+\n@@ -241,0 +257,1 @@\n+        _default = fromString(\"default\");\n@@ -284,0 +301,2 @@\n+        primitive = fromString(\"primitive\");\n+        identity = fromString(\"identity\");\n@@ -288,0 +307,1 @@\n+        isValueObject = fromString(\"isValueObject\");\n@@ -296,0 +316,5 @@\n+        java_lang_System = fromString(\"java.lang.System\");\n+        __primitive__ = fromString(\"__primitive__\");\n+        java_lang___primitive__ = fromString(\"java.lang.__primitive__\");\n+        __value__ = fromString(\"__value__\");\n+        java_lang___value__ = fromString(\"java.lang.__value__\");\n@@ -333,0 +358,1 @@\n+        Preload = fromString(\"Preload\");\n@@ -385,0 +411,5 @@\n+        \/\/ primitive classes\n+        dollarValue = fromString(\"$value\");\n+        ref = fromString(\"ref\");\n+        val = fromString(\"val\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    metadataTypeArray = new Type[9];\n+    metadataTypeArray = new Type[11];\n@@ -127,0 +127,2 @@\n+    metadataTypeArray[9] = db.lookupType(\"FlatArrayKlass\");\n+    metadataTypeArray[10] = db.lookupType(\"InlineKlass\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    metadataConstructor.addMapping(\"InlineKlass\", InlineKlass.class);\n@@ -69,0 +70,1 @@\n+    metadataConstructor.addMapping(\"FlatArrayKlass\", FlatArrayKlass.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Metadata.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,0 +109,2 @@\n+            new UnknownProfileData(this, config.dataLayoutArrayLoadStoreDataTag),\n+            new UnknownProfileData(this, config.dataLayoutACmpDataTag),\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        assert tag >= config.dataLayoutNoTag && tag <= config.dataLayoutSpeculativeTrapDataTag : \"profile data tag out of bounds: \" + tag;\n+        assert tag >= config.dataLayoutNoTag && tag <= config.dataLayoutACmpDataTag : \"profile data tag out of bounds: \" + tag;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodDataAccessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags\", Integer.class, \"u2\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags\", Integer.class, \"u4\");\n@@ -318,0 +318,2 @@\n+    final int dataLayoutArrayLoadStoreDataTag = getConstant(\"DataLayout::array_load_store_data_tag\", Integer.class);\n+    final int dataLayoutACmpDataTag = getConstant(\"DataLayout::acmp_data_tag\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                   super.equals(obj);\n+                    super.equals(obj);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ObjectReferenceImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,1 +366,0 @@\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+# Valhalla\n+\n+runtime\/valhalla\/inlinetypes\/ClassInitializationFailuresTest.java 8274131 linux-aarch64-debug,macosx-aarch64-debug\n+\n@@ -124,0 +128,27 @@\n+# Valhalla TODO:\n+serviceability\/sa\/ClhsdbCDSCore.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbFindPC.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbInspect.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbLongConstant.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJdis.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJstack.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintStatics.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSource.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSymbol.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbWhere.java 8190936 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8190936 generic-all\n+serviceability\/sa\/TestClassDump.java 8190936 generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestCpoolForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForLargeArray.java 8190936 generic-all\n+serviceability\/sa\/TestIntConstant.java 8190936 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCore.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8190936 generic-all\n+serviceability\/sa\/TestPrintMdo.java 8190936 generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 8190936 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  runtime\n+  runtime \\\n@@ -59,0 +59,8 @@\n+hotspot_valhalla = \\\n+  runtime\/valhalla \\\n+  compiler\/valhalla \\\n+  serviceability\/jvmti\/Valhalla\n+\n+hotspot_valhalla_runtime = \\\n+  runtime\/valhalla\n+\n@@ -147,1 +155,1 @@\n-  compiler\/codegen\/aes \\\n+  compiler\/codegen\/aes \\\n@@ -201,0 +209,1 @@\n+  compiler\/valhalla\/ \\\n@@ -257,0 +266,7 @@\n+tier1_compiler_no_valhalla = \\\n+  :tier1_compiler_1 \\\n+  :tier1_compiler_2 \\\n+  :tier1_compiler_3 \\\n+  :tier1_compiler_not_xcomp \\\n+  -compiler\/valhalla\n+\n@@ -405,0 +421,4 @@\n+tier1_runtime_no_valhalla = \\\n+  :tier1_runtime \\\n+  -runtime\/valhalla\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -87,5 +87,5 @@\n-        test(T1.class,                                      PUBLIC | STATIC);\n-        test(T2.class,                                      PUBLIC | FINAL | STATIC);\n-        test(T3.class,                                      PRIVATE | STATIC);\n-        test(T4.class,                                      PROTECTED | STATIC);\n-        test(new TestGetModifiers().new T5().getClass(),    0);\n+        test(T1.class,                                      PUBLIC | STATIC | IDENTITY);\n+        test(T2.class,                                      PUBLIC | FINAL | STATIC | IDENTITY);\n+        test(T3.class,                                      PRIVATE | STATIC | IDENTITY);\n+        test(T4.class,                                      PROTECTED | STATIC | IDENTITY);\n+        test(new TestGetModifiers().new T5().getClass(),    IDENTITY);\n@@ -112,5 +112,5 @@\n-        test(new TestGetModifiers().getClass(),             PUBLIC);\n-        test(new T1().getClass(),                           PUBLIC | STATIC);\n-        test(new T2().getClass(),                           PUBLIC | FINAL | STATIC);\n-        test(new T3().getClass(),                           PRIVATE | STATIC);\n-        test(new T4().getClass(),                           PROTECTED | STATIC);\n+        test(new TestGetModifiers().getClass(),             PUBLIC | IDENTITY);\n+        test(new T1().getClass(),                           PUBLIC | STATIC | IDENTITY);\n+        test(new T2().getClass(),                           PUBLIC | FINAL | STATIC | IDENTITY);\n+        test(new T3().getClass(),                           PRIVATE | STATIC | IDENTITY);\n+        test(new T4().getClass(),                           PROTECTED | STATIC | IDENTITY);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/TestGetModifiers.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -190,1 +190,2 @@\n-    @Test\n+    \/\/ TODO Re-enable once JDK-8291719 is fixed.\n+    \/\/ @Test\n@@ -268,1 +269,3 @@\n-            assertEquals(expected.length, actual.length);\n+            \/\/ With injection of the IdentityObject interface by the JVM, the number of\n+            \/\/ interfaces visible through reflection and through JVMCI could differ by one\n+            assertTrue(expected.length == actual.length || (actual.length - expected.length) == 1);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -535,0 +535,12 @@\n+    \/**\n+     * Checks if deopt of {@code m} is stable at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if deopt of {@code m} is stable at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isStableDeopt(Method m, CompLevel compLevel) {\n+        return TestVM.isStableDeopt(m, compLevel);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -253,2 +253,5 @@\n-        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n-            checkAnnotationsInClass(clazz, \"inner\");\n+        \/\/ TODO remove this once JDK-8273591 is fixed\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+                checkAnnotationsInClass(clazz, \"inner\");\n+            }\n@@ -894,1 +897,1 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n+        if (isStableDeopt(m, CompLevel.C1_SIMPLE)) {\n@@ -901,1 +904,1 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n+        if (isStableDeopt(m, CompLevel.C2)) {\n@@ -910,1 +913,1 @@\n-    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n+    public static boolean isStableDeopt(Method m, CompLevel level) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.opt.final.TieredCompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/ConstantGettersTransitionsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.final.TieredCompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestMeetIncompatibleInterfaceArrays.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,782 @@\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #5 #11; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #10\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #11\n+    Field #13 #14; \/\/ #12\n+    class #15; \/\/ #13\n+    NameAndType #16 #17; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #15\n+    Utf8 \"rect\"; \/\/ #16\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #17\n+    String #19; \/\/ #18\n+    Utf8 \"\"; \/\/ #19\n+    Field #13 #21; \/\/ #20\n+    NameAndType #22 #23; \/\/ #21\n+    Utf8 \"name\"; \/\/ #22\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n+    Field #8 #25; \/\/ #24\n+    NameAndType #26 #27; \/\/ #25\n+    Utf8 \"p1\"; \/\/ #26\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #27\n+    Field #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #32 #33; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #31\n+    Utf8 \"x\"; \/\/ #32\n+    Utf8 \"I\"; \/\/ #33\n+    Utf8 \"Code\"; \/\/ #34\n+    Utf8 \"LineNumberTable\"; \/\/ #35\n+    Utf8 \"getP1X\"; \/\/ #36\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #37\n+    Utf8 \"getP1\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"NamedRectangleN.java\"; \/\/ #41\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012AB80007;\n+            0xB5000C2A1212B500;\n+            0x14B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #36; \/\/ name_index\n+      #37; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B4;\n+            0x001CAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  31;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #5 #11; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #10\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #11\n+    Field #13 #14; \/\/ #12\n+    class #15; \/\/ #13\n+    NameAndType #16 #17; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #15\n+    Utf8 \"rect\"; \/\/ #16\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #17\n+    String #19; \/\/ #18\n+    Utf8 \"\"; \/\/ #19\n+    Field #13 #21; \/\/ #20\n+    NameAndType #22 #23; \/\/ #21\n+    Utf8 \"name\"; \/\/ #22\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n+    Field #8 #25; \/\/ #24\n+    NameAndType #26 #27; \/\/ #25\n+    Utf8 \"p1\"; \/\/ #26\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #27\n+    Field #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #32 #33; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #31\n+    Utf8 \"x\"; \/\/ #32\n+    Utf8 \"I\"; \/\/ #33\n+    Utf8 \"Code\"; \/\/ #34\n+    Utf8 \"LineNumberTable\"; \/\/ #35\n+    Utf8 \"getP1X\"; \/\/ #36\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #37\n+    Utf8 \"getP1\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"NamedRectangleP.java\"; \/\/ #41\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012AB80007;\n+            0xB5000C2A1212B500;\n+            0x14B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #36; \/\/ name_index\n+      #37; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B4;\n+            0x001CAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  31;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleP\n+\n+class compiler\/valhalla\/inlinetypes\/PointN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x1\"; \/\/ #5                \/\/ field name changed from x to x1\n+    Utf8 \"I\"; \/\/ #6\n+    Field #1 #8; \/\/ #7\n+    NameAndType #9 #6; \/\/ #8\n+    Utf8 \"y\"; \/\/ #9\n+    InvokeDynamic 0s #11; \/\/ #10\n+    NameAndType #12 #13; \/\/ #11\n+    Utf8 \"toString\"; \/\/ #12\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/PointN;)Ljava\/lang\/String;\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"<init>\"; \/\/ #19\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"PointN.java\"; \/\/ #22\n+    Utf8 \"NestHost\"; \/\/ #23\n+    Utf8 \"BootstrapMethods\"; \/\/ #24\n+    MethodHandle 6b #26; \/\/ #25\n+    Method #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #29\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #30\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #31\n+    Utf8 \"InnerClasses\"; \/\/ #32\n+    class #34; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #34\n+    class #36; \/\/ #35\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #36\n+    Utf8 \"Lookup\"; \/\/ #37\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #12; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA000A0000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #19; \/\/ name_index\n+      #20; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B072A5FCC;\n+            0x00034B10072A5FCC;\n+            0x00074B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23) { \/\/ NestHost\n+      #14;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#24) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#32) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #33 #35 #37 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/PointN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #2\n+    Method #4 #5; \/\/ #3\n+    class #6; \/\/ #4\n+    NameAndType #7 #8; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #6\n+    Utf8 \"<init>\"; \/\/ #7\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #8\n+    Field #1 #10; \/\/ #9\n+    NameAndType #11 #12; \/\/ #10\n+    Utf8 \"p0\"; \/\/ #11\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Field #1 #14; \/\/ #13\n+    NameAndType #15 #12; \/\/ #14\n+    Utf8 \"p1\"; \/\/ #15\n+    InvokeDynamic 0s #17; \/\/ #16\n+    NameAndType #18 #19; \/\/ #17\n+    Utf8 \"toString\"; \/\/ #18\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleN;)Ljava\/lang\/String;\"; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #25\n+    Utf8 \"SourceFile\"; \/\/ #26\n+    Utf8 \"RectangleN.java\"; \/\/ #27\n+    Utf8 \"NestHost\"; \/\/ #28\n+    Utf8 \"BootstrapMethods\"; \/\/ #29\n+    MethodHandle 6b #31; \/\/ #30\n+    Method #32 #33; \/\/ #31\n+    class #34; \/\/ #32\n+    NameAndType #35 #36; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n+    Utf8 \"InnerClasses\"; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n+    Utf8 \"Lookup\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #15; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #18; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00100000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #25; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014BB800032A;\n+            0x5FCC00094BB80003;\n+            0x2A5FCC000D4B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                13  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#26) { \/\/ SourceFile\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28) { \/\/ NestHost\n+      #20;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#29) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #30; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#37) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #38 #40 #42 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #2\n+    Method #4 #5; \/\/ #3\n+    class #6; \/\/ #4\n+    NameAndType #7 #8; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #6\n+    Utf8 \"<init>\"; \/\/ #7\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #8\n+    Field #1 #10; \/\/ #9\n+    NameAndType #11 #12; \/\/ #10\n+    Utf8 \"p0\"; \/\/ #11\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #12\n+    Field #1 #14; \/\/ #13\n+    NameAndType #15 #12; \/\/ #14\n+    Utf8 \"p1\"; \/\/ #15\n+    InvokeDynamic 0s #17; \/\/ #16\n+    NameAndType #18 #19; \/\/ #17\n+    Utf8 \"toString\"; \/\/ #18\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleP;)Ljava\/lang\/String;\"; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #25\n+    Utf8 \"SourceFile\"; \/\/ #26\n+    Utf8 \"RectangleP.java\"; \/\/ #27\n+    Utf8 \"NestHost\"; \/\/ #28\n+    Utf8 \"BootstrapMethods\"; \/\/ #29\n+    MethodHandle 6b #31; \/\/ #30\n+    Method #32 #33; \/\/ #31\n+    class #34; \/\/ #32\n+    NameAndType #35 #36; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n+    Utf8 \"InnerClasses\"; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n+    Utf8 \"Lookup\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0012; \/\/ access  \/\/ Access flags have been modified to make field p1 private\n+      #15; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #18; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00100000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #25; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014BB800032A;\n+            0x5FCC00094BB80003;\n+            0x2A5FCC000D4B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                13  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#26) { \/\/ SourceFile\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28) { \/\/ NestHost\n+      #20;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#29) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #30; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#37) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #38 #40 #42 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleP\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":782,"deletions":0,"binary":false,"changes":782,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ GENERATED FROM THE FOLLOWING JAVA FILE:\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+primitive class MyValue5 {\n+    public int x = 42;\n+\n+    public MyValue5 withField(int x) {\n+        return __WithField(this.x, x);\n+    }\n+\n+    public static MyValue5.ref withField(MyValue5.ref val, int x) {\n+        return __WithField(val.x, x);\n+    }\n+}\n+*\/\n+\n+class compiler\/valhalla\/inlinetypes\/MyValue5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8\n+    Utf8 \"withField\"; \/\/ #9\n+    Utf8 \"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue5;I)Lcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #13\n+    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #15\n+    Utf8 \"SourceFile\"; \/\/ #16\n+    Utf8 \"MyValue5.java\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0011; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index\n+      #13; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  11;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #14; \/\/ name_index\n+      #15; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#16) { \/\/ SourceFile\n+      #17;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue5\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,630 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary Test inline type calling convention with compiled to compiled calls.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @compile TestC2CCalls.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   TestC2CCalls\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls*::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch -XX:-ProfileInterpreter\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls*::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch -XX:-ProfileInterpreter\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestC2CCalls {\n+    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    public static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+    public static final int rI = Utils.getRandomInstance().nextInt() % 1000;\n+\n+    static primitive class OtherVal {\n+        public final int x;\n+\n+        private OtherVal(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static interface MyInterface1 {\n+        public MyInterface1 test1(OtherVal other, int y);\n+        public MyInterface1 test2(OtherVal other1, OtherVal.ref other2, int y);\n+        public MyInterface1 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt);\n+        public MyInterface1 test4(OtherVal other1, OtherVal.ref other2, int y);\n+        public MyInterface1 test5(OtherVal other1, OtherVal.ref other2, int y);\n+        public MyInterface1 test6();\n+        public MyInterface1 test7(int i1, int i2, int i3, int i4, int i5, int i6);\n+        public MyInterface1 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7);\n+        public MyInterface1 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6);\n+        public MyInterface1 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6);\n+\n+        public int getValue();\n+    }\n+\n+    static primitive class MyValue1 implements MyInterface1 {\n+        public final int x;\n+\n+        private MyValue1(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public MyValue1 test1(OtherVal other, int y) {\n+            return new MyValue1(x + other.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test2(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyValue1(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {\n+            if (!deopt) {\n+              return new MyValue1(x + other1.x + other2.x + y);\n+            } else {\n+              \/\/ Uncommon trap\n+              return test1(other1, y);\n+            }\n+        }\n+\n+        @Override\n+        public MyValue1 test4(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyValue1(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test5(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyValue1(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test6() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MyValue1 test7(int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue1(x + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue1 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue1(x + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue1 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue1(x + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue1 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue1(x + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static primitive class MyValue2 implements MyInterface1 {\n+        public final int x;\n+\n+        private MyValue2(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public MyValue2 test1(OtherVal other, int y) {\n+            return new MyValue2(x + other.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test2(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyValue2(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {\n+            if (!deopt) {\n+              return new MyValue2(x + other1.x + other2.x + y);\n+            } else {\n+              \/\/ Uncommon trap\n+              return test1(other1, y);\n+            }\n+        }\n+\n+        @Override\n+        public MyValue2 test4(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyValue2(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test5(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyValue2(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test6() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MyValue2 test7(int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue2(x + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue2 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue2(x + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue2 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue2(x + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue2 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue2(x + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static primitive class MyValue3 implements MyInterface1 {\n+        public final double d1;\n+        public final double d2;\n+        public final double d3;\n+        public final double d4;\n+\n+        private MyValue3(double d) {\n+            this.d1 = d;\n+            this.d2 = d;\n+            this.d3 = d;\n+            this.d4 = d;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return (int)d4;\n+        }\n+\n+        @Override\n+        public MyValue3 test1(OtherVal other, int y) { return MyValue3.default; }\n+        @Override\n+        public MyValue3 test2(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }\n+        @Override\n+        public MyValue3 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt)  { return MyValue3.default; }\n+        @Override\n+        public MyValue3 test4(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }\n+        @Override\n+        public MyValue3 test5(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }\n+        @Override\n+        public MyValue3 test6()  { return MyValue3.default; }\n+\n+        @Override\n+        public MyValue3 test7(int i1, int i2, int i3, int i4, int i5, int i6)  {\n+            return new MyValue3(d1 + d2 + d3 + d4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue3 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue3(d1 + d2 + d3 + d4 + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue3 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue3(d1 + d2 + d3 + d4 + other.d1 + other.d2 + other.d3 + other.d4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue3 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue3(d1 + d2 + d3 + d4 + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static primitive class MyValue4 implements MyInterface1 {\n+        public final int x1;\n+        public final int x2;\n+        public final int x3;\n+        public final int x4;\n+\n+        private MyValue4(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+            this.x3 = i;\n+            this.x4 = i;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x4;\n+        }\n+\n+        @Override\n+        public MyValue4 test1(OtherVal other, int y) { return MyValue4.default; }\n+        @Override\n+        public MyValue4 test2(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }\n+        @Override\n+        public MyValue4 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt)  { return MyValue4.default; }\n+        @Override\n+        public MyValue4 test4(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }\n+        @Override\n+        public MyValue4 test5(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }\n+        @Override\n+        public MyValue4 test6()  { return MyValue4.default; }\n+\n+        @Override\n+        public MyValue4 test7(int i1, int i2, int i3, int i4, int i5, int i6)  {\n+            return new MyValue4(x1 + x2 + x3 + x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue4 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue4(x1 + x2 + x3 + x4 + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue4 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue4(x1 + x2 + x3 + x4 + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue4 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue4(x1 + x2 + x3 + x4 + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static class MyObject implements MyInterface1 {\n+        private final int x;\n+\n+        private MyObject(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public MyObject test1(OtherVal other, int y) {\n+            return new MyObject(x + other.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test2(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyObject(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {\n+            if (!deopt) {\n+              return new MyObject(x + other1.x + other2.x + y);\n+            } else {\n+              \/\/ Uncommon trap\n+              return test1(other1, y);\n+            }\n+        }\n+\n+        @Override\n+        public MyObject test4(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyObject(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test5(OtherVal other1, OtherVal.ref other2, int y) {\n+            return new MyObject(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test6() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MyObject test7(int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyObject(x + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyObject test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyObject(x + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyObject test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyObject(x + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyObject test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyObject(x + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    \/\/ Test calling methods with inline type arguments through an interface\n+    public static int test1(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test1(other, y).getValue();\n+    }\n+\n+    public static int test2(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Test mixing null-tolerant and null-free inline type arguments\n+    public static int test3(MyValue1 vt, OtherVal other, int y) {\n+        return vt.test2(other, other, y).getValue();\n+    }\n+\n+    public static int test4(MyObject obj, OtherVal other, int y) {\n+        return obj.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Optimized interface call with inline type receiver\n+    public static int test5(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test1(other, y).getValue();\n+    }\n+\n+    public static int test6(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Optimized interface call with object receiver\n+    public static int test7(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test1(other, y).getValue();\n+    }\n+\n+    public static int test8(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Interface calls with deoptimized callee\n+    public static int test9(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test10(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    \/\/ Optimized interface calls with deoptimized callee\n+    public static int test11(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test12(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test13(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test14(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    \/\/ Interface calls without warmed up \/ compiled callees\n+    public static int test15(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test4(other, other, y).getValue();\n+    }\n+\n+    public static int test16(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test5(other, other, y).getValue();\n+    }\n+\n+    \/\/ Interface call with no arguments\n+    public static int test17(MyInterface1 intf) {\n+        return intf.test6().getValue();\n+    }\n+\n+    \/\/ Calls that require stack extension\n+    public static int test18(MyInterface1 intf, int y) {\n+        return intf.test7(y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static int test19(MyInterface1 intf, int y) {\n+        return intf.test8(y, y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static int test20(MyInterface1 intf, MyValue3 v, int y) {\n+        return intf.test9(v, y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static int test21(MyInterface1 intf, MyValue4 v, int y) {\n+        return intf.test10(v, y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Sometimes, exclude some methods from compilation with C2 to stress test the calling convention\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            ArrayList<Method> methods = new ArrayList<Method>();\n+            Collections.addAll(methods, MyValue1.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyValue2.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyValue3.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyValue4.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyObject.class.getDeclaredMethods());\n+            Collections.addAll(methods, TestC2CCalls.class.getDeclaredMethods());\n+            System.out.println(\"Excluding methods from C2 compilation:\");\n+            for (Method m : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(m);\n+                    WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+                }\n+            }\n+        }\n+\n+        MyValue1 val1 = new MyValue1(rI);\n+        MyValue2 val2 = new MyValue2(rI+1);\n+        MyValue3 val3 = new MyValue3(rI+2);\n+        MyValue4 val4 = new MyValue4(rI+3);\n+        OtherVal other = new OtherVal(rI+4);\n+        MyObject obj = new MyObject(rI+5);\n+\n+        \/\/ Make sure callee methods are compiled\n+        for (int i = 0; i < 10_000; ++i) {\n+            Asserts.assertEQ(val1.test1(other, rI).getValue(), val1.x + other.x + rI);\n+            Asserts.assertEQ(val2.test1(other, rI).getValue(), val2.x + other.x + rI);\n+            Asserts.assertEQ(obj.test1(other, rI).getValue(), obj.x + other.x + rI);\n+            Asserts.assertEQ(val1.test2(other, other, rI).getValue(), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(val2.test2(other, other, rI).getValue(), val2.x + 2*other.x + rI);\n+            Asserts.assertEQ(obj.test2(other, other, rI).getValue(), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(val1.test3(other, other, rI, false).getValue(), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(val2.test3(other, other, rI, false).getValue(), val2.x + 2*other.x + rI);\n+            Asserts.assertEQ(obj.test3(other, other, rI, false).getValue(), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(val1.test7(rI, rI, rI, rI, rI, rI).getValue(), val1.x + 6*rI);\n+            Asserts.assertEQ(val2.test7(rI, rI, rI, rI, rI, rI).getValue(), val2.x + 6*rI);\n+            Asserts.assertEQ(val3.test7(rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val4.test7(rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(obj.test7(rI, rI, rI, rI, rI, rI).getValue(), obj.x + 6*rI);\n+            Asserts.assertEQ(val1.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), val1.x + 7*rI);\n+            Asserts.assertEQ(val2.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), val2.x + 7*rI);\n+            Asserts.assertEQ(val3.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 7*rI));\n+            Asserts.assertEQ(val4.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 7*rI));\n+            Asserts.assertEQ(obj.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), obj.x + 7*rI);\n+            Asserts.assertEQ(val1.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(val1.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val2.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(val2.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val3.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val4.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(obj.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(obj.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val1.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(val1.x + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(val2.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(val2.x + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(val3.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(val4.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(obj.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(obj.x + 4*val4.x1 + 6*rI));\n+        }\n+\n+        \/\/ Polute call profile\n+        for (int i = 0; i < 100; ++i) {\n+            Asserts.assertEQ(test15(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test16(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test17(obj), obj.x);\n+        }\n+\n+        \/\/ Trigger compilation of caller methods\n+        for (int i = 0; i < 100_000; ++i) {\n+            val1 = new MyValue1(rI+i);\n+            val2 = new MyValue2(rI+i+1);\n+            val3 = new MyValue3(rI+i+2);\n+            val4 = new MyValue4(rI+i+3);\n+            other = new OtherVal(rI+i+4);\n+            obj = new MyObject(rI+i+5);\n+\n+            Asserts.assertEQ(test1(val1, other, rI), val1.x + other.x + rI);\n+            Asserts.assertEQ(test1(obj, other, rI), obj.x + other.x + rI);\n+            Asserts.assertEQ(test2(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test2(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test3(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test4(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test5(val1, other, rI), val1.x + other.x + rI);\n+            Asserts.assertEQ(test6(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test7(obj, other, rI), obj.x + other.x + rI);\n+            Asserts.assertEQ(test8(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test9(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test9(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test10(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test10(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test11(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test12(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test13(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test14(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test15(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test16(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test17(val1), val1.x);\n+            Asserts.assertEQ(test18(val1, rI), val1.x + 6*rI);\n+            Asserts.assertEQ(test18(val2, rI), val2.x + 6*rI);\n+            Asserts.assertEQ(test18(val3, rI), (int)(4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test18(val4, rI), 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test18(obj, rI), obj.x + 6*rI);\n+            Asserts.assertEQ(test19(val1, rI), val1.x + 7*rI);\n+            Asserts.assertEQ(test19(val2, rI), val2.x + 7*rI);\n+            Asserts.assertEQ(test19(val3, rI), (int)(4*val3.d1 + 7*rI));\n+            Asserts.assertEQ(test19(val4, rI), 4*val4.x1 + 7*rI);\n+            Asserts.assertEQ(test19(obj, rI), obj.x + 7*rI);\n+            Asserts.assertEQ(test20(val1, val3, rI), (int)(val1.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(val2, val3, rI), (int)(val2.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(val3, val3, rI), (int)(4*val3.d1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(val4, val3, rI), (int)(4*val4.x1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(obj, val3, rI), (int)(obj.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test21(val1, val4, rI), val1.x + 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test21(val2, val4, rI), val2.x + 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test21(val3, val4, rI), (int)(4*val3.d1 + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(test21(val4, val4, rI), 4*val4.x1 + 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test21(obj, val4, rI), obj.x + 4*val4.x1 + 6*rI);\n+        }\n+\n+        \/\/ Trigger deoptimization\n+        Asserts.assertEQ(val1.test3(other, other, rI, true).getValue(), val1.x + other.x + rI);\n+        Asserts.assertEQ(obj.test3(other, other, rI, true).getValue(), obj.x + other.x + rI);\n+\n+        \/\/ Check results of methods still calling the deoptimized methods\n+        Asserts.assertEQ(test9(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test9(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test10(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test10(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test11(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test11(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test12(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test12(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test13(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test13(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test14(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test14(val1, other, rI, false), val1.x + 2*other.x + rI);\n+\n+        \/\/ Check with unexpected arguments\n+        Asserts.assertEQ(test1(val2, other, rI), val2.x + other.x + rI);\n+        Asserts.assertEQ(test2(val2, other, rI), val2.x + 2*other.x + rI);\n+        Asserts.assertEQ(test5(val2, other, rI), val2.x + other.x + rI);\n+        Asserts.assertEQ(test6(val2, other, rI), val2.x + 2*other.x + rI);\n+        Asserts.assertEQ(test7(val1, other, rI), val1.x + other.x + rI);\n+        Asserts.assertEQ(test8(val1, other, rI), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test15(val1, other, rI), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test16(obj, other, rI), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test17(obj), obj.x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC2CCalls.java","additions":630,"deletions":0,"binary":false,"changes":630,"status":"added"},{"patch":"@@ -0,0 +1,2369 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calls from {C1} to {C2, Interpreter}, and vice versa.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @run driver\/timeout=300 compiler.valhalla.inlinetypes.TestCallingConventionC1\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestCallingConventionC1 {\n+\n+    public static void main(String[] args) {\n+        final Scenario[] scenarios = {\n+                \/\/ Default: both C1 and C2 are enabled, tiered compilation enabled\n+                new Scenario(0,\n+                             \"-XX:CICompilerCount=2\",\n+                             \"-XX:TieredStopAtLevel=4\",\n+                             \"-XX:+TieredCompilation\"),\n+                \/\/ Default: both C1 and C2 are enabled, tiered compilation enabled\n+                new Scenario(1,\n+                             \"-XX:CICompilerCount=2\",\n+                             \"-XX:TieredStopAtLevel=4\",\n+                             \"-XX:+TieredCompilation\",\n+                             \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                             \"-XX:+StressInlineTypeReturnedAsFields\"),\n+                \/\/ Same as above, but flip all the compLevel=CompLevel.C1_SIMPLE and compLevel=CompLevel.C2, so we test\n+                \/\/ the compliment of the above scenario.\n+                new Scenario(2,\n+                             \"-XX:CICompilerCount=2\",\n+                             \"-XX:TieredStopAtLevel=4\",\n+                             \"-XX:+TieredCompilation\",\n+                             \"-DFlipC1C2=true\"),\n+                \/\/ Only C1. Tiered compilation disabled.\n+                new Scenario(3,\n+                             \"-XX:TieredStopAtLevel=1\",\n+                             \"-XX:+TieredCompilation\"),\n+                \/\/ Only C2.\n+                new Scenario(4,\n+                             \"-XX:TieredStopAtLevel=4\",\n+                             \"-XX:-TieredCompilation\")\n+        };\n+\n+        System.gc(); \/\/ Resolve this call, to avoid C1 code patching in the test cases.\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .start();\n+    }\n+\n+    \/\/ Helper methods and classes\n+\n+    static primitive class Point {\n+        final int x;\n+        final int y;\n+        public Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @DontCompile\n+        public int func() {\n+            return x + y;\n+        }\n+\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        @DontInline\n+        public int func_c1(Point p) {\n+            return x + y + p.x + p.y;\n+        }\n+    }\n+\n+    static interface FunctorInterface {\n+        public int apply_interp(Point p);\n+    }\n+\n+    static class Functor implements FunctorInterface {\n+        @DontCompile\n+        public int apply_interp(Point p) {\n+            return p.func() + 0;\n+        }\n+    }\n+\n+    static class Functor1 extends Functor {\n+        @DontCompile\n+        public int apply_interp(Point p) {\n+            return p.func() + 10000;\n+        }\n+    }\n+\n+    static class Functor2 extends Functor {\n+        @DontCompile\n+        public int apply_interp(Point p) {\n+            return p.func() + 20000;\n+        }\n+    }\n+\n+    static class Functor3 extends Functor {\n+        @DontCompile\n+        public int apply_interp(Point p) {\n+            return p.func() + 30000;\n+        }\n+    }\n+\n+    static class Functor4 extends Functor {\n+        @DontCompile\n+        public int apply_interp(Point p) {\n+            return p.func() + 40000;\n+        }\n+    }\n+\n+    static Functor functors[] = {\n+        new Functor(),\n+        new Functor1(),\n+        new Functor2(),\n+        new Functor3(),\n+        new Functor4()\n+    };\n+    static int functorCounter = 0;\n+    static Functor getFunctor() {\n+        int n = (++ functorCounter) % functors.length;\n+        return functors[n];\n+    }\n+\n+    static Point pointField  = new Point(123, 456);\n+    static Point pointField1 = new Point(1123, 1456);\n+    static Point pointField2 = new Point(2123, 2456);\n+\n+    static interface Intf {\n+        public int func1(int a, int b);\n+        public int func2(int a, int b, Point p);\n+    }\n+\n+    static class MyImplPojo0 implements Intf {\n+        int field = 0;\n+        @DontCompile\n+        public int func1(int a, int b)             { return field + a + b + 1; }\n+        @DontCompile\n+        public int func2(int a, int b, Point p)     { return field + a + b + p.x + p.y + 1; }\n+    }\n+\n+    static class MyImplPojo1 implements Intf {\n+        int field = 1000;\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func1(int a, int b)             { return field + a + b + 20; }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 20; }\n+    }\n+\n+    static class MyImplPojo2 implements Intf {\n+        int field = 2000;\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C2)\n+        public int func1(int a, int b)             { return field + a + b + 20; }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C2)\n+        public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 20; }\n+    }\n+\n+    static class MyImplPojo3 implements Intf {\n+        int field = 0;\n+        @DontInline \/\/ will be compiled with counters\n+        public int func1(int a, int b)             { return field + a + b + 1; }\n+        @DontInline \/\/ will be compiled with counters\n+        public int func2(int a, int b, Point p)     { return field + a + b + p.x + p.y + 1; }\n+    }\n+\n+    static primitive class MyImplVal1 implements Intf {\n+        final int field;\n+        MyImplVal1() {\n+            field = 11000;\n+        }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func1(int a, int b) { return field + a + b + 300; }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }\n+    }\n+\n+    static primitive class MyImplVal2 implements Intf {\n+        final int field;\n+        MyImplVal2() {\n+            field = 12000;\n+        }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C2)\n+        public int func1(int a, int b)             { return field + a + b + 300; }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C2)\n+        public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }\n+    }\n+\n+    static primitive class MyImplVal1X implements Intf {\n+        final int field;\n+        MyImplVal1X() {\n+            field = 11000;\n+        }\n+\n+        @DontCompile\n+        public int func1(int a, int b)             { return field + a + b + 300; }\n+\n+        @DontCompile\n+        public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }\n+    }\n+\n+    static primitive class MyImplVal2X implements Intf {\n+        final int field;\n+        MyImplVal2X() {\n+            field = 12000;\n+        }\n+\n+        @DontInline \/\/ will be compiled with counters\n+        public int func1(int a, int b)             { return field + a + b + 300; }\n+\n+        @DontInline \/\/ will be compiled with counters\n+        public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }\n+    }\n+\n+    static Intf intfs[] = {\n+        new MyImplPojo0(), \/\/ methods not compiled\n+        new MyImplPojo1(), \/\/ methods compiled by C1\n+        new MyImplPojo2(), \/\/ methods compiled by C2\n+        new MyImplVal1(),  \/\/ methods compiled by C1\n+        new MyImplVal2()   \/\/ methods compiled by C2\n+    };\n+    static Intf getIntf(int i) {\n+        int n = i % intfs.length;\n+        return intfs[n];\n+    }\n+\n+    static primitive class FixedPoints {\n+        final boolean Z0 = false;\n+        final boolean Z1 = true;\n+        final byte    B  = (byte)2;\n+        final char    C  = (char)34;\n+        final short   S  = (short)456;\n+        final int     I  = 5678;\n+        final long    J  = 0x1234567800abcdefL;\n+    }\n+    static FixedPoints fixedPointsField = new FixedPoints();\n+\n+    static primitive class FloatPoint {\n+        final float x;\n+        final float y;\n+        public FloatPoint(float x, float y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    static primitive class DoublePoint {\n+        final double x;\n+        final double y;\n+        public DoublePoint(double x, double y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+    static FloatPoint floatPointField = new FloatPoint(123.456f, 789.012f);\n+    static DoublePoint doublePointField = new DoublePoint(123.456, 789.012);\n+\n+    static primitive class EightFloats {\n+        float f1, f2, f3, f4, f5, f6, f7, f8;\n+        public EightFloats() {\n+            f1 = 1.1f;\n+            f2 = 2.2f;\n+            f3 = 3.3f;\n+            f4 = 4.4f;\n+            f5 = 5.5f;\n+            f6 = 6.6f;\n+            f7 = 7.7f;\n+            f8 = 8.8f;\n+        }\n+    }\n+    static EightFloats eightFloatsField = new EightFloats();\n+\n+    static class Number {\n+        int n;\n+        Number(int v) {\n+            n = v;\n+        }\n+        void set(int v) {\n+            n = v;\n+        }\n+    }\n+\n+    static interface RefPoint_Access {\n+        public int func1(RefPoint rp2);\n+        public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2);\n+    }\n+\n+    static primitive class RefPoint implements RefPoint_Access {\n+        final Number x;\n+        final Number y;\n+        public RefPoint(int x, int y) {\n+            this.x = new Number(x);\n+            this.y = new Number(y);\n+        }\n+        public RefPoint(Number x, Number y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public final int final_func(RefPoint rp2) { \/\/ opt_virtual_call\n+            return this.x.n + this.y.n + rp2.x.n + rp2.y.n;\n+        }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func1(RefPoint rp2) {\n+            return this.x.n + this.y.n + rp2.x.n + rp2.y.n;\n+        }\n+\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+            return x.n + y.n +\n+                   rp1.x.n + rp1.y.n +\n+                   rp2.x.n + rp2.y.n +\n+                   n1.n +\n+                   rp3.x.n + rp3.y.n +\n+                   rp4.x.n + rp4.y.n +\n+                   n2.n;\n+        }\n+    }\n+\n+    static class RefPoint_Access_Impl1 implements RefPoint_Access {\n+        @DontCompile\n+        public int func1(RefPoint rp2) {\n+            return rp2.x.n + rp2.y.n + 1111111;\n+        }\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+            return 111111 +\n+                   rp1.x.n + rp1.y.n +\n+                   rp2.x.n + rp2.y.n +\n+                   n1.n +\n+                   rp3.x.n + rp3.y.n +\n+                   rp4.x.n + rp4.y.n +\n+                   n2.n;\n+        }\n+    }\n+\n+    static class RefPoint_Access_Impl2 implements RefPoint_Access {\n+        @DontCompile\n+        public int func1(RefPoint rp2) {\n+            return rp2.x.n + rp2.y.n + 2222222;\n+        }\n+        @DontInline\n+        @ForceCompile(CompLevel.C1_SIMPLE)\n+        public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+            return 222222 +\n+                   rp1.x.n + rp1.y.n +\n+                   rp2.x.n + rp2.y.n +\n+                   n1.n +\n+                   rp3.x.n + rp3.y.n +\n+                   rp4.x.n + rp4.y.n +\n+                   n2.n;\n+        }\n+    }\n+\n+    static RefPoint_Access refPoint_Access_impls[] = {\n+        new RefPoint_Access_Impl1(),\n+        new RefPoint_Access_Impl2(),\n+        new RefPoint(0x12345, 0x6789a)\n+    };\n+\n+    static int next_RefPoint_Access = 0;\n+    static RefPoint_Access get_RefPoint_Access() {\n+        int i = next_RefPoint_Access ++;\n+        return refPoint_Access_impls[i % refPoint_Access_impls.length];\n+    }\n+\n+    static RefPoint refPointField1 = new RefPoint(12, 34);\n+    static RefPoint refPointField2 = new RefPoint(56789, 0x12345678);\n+\n+    \/\/ This inline class has too many fields to fit in registers on x64 for\n+    \/\/ InlineTypeReturnedAsFields.\n+    static primitive class TooBigToReturnAsFields {\n+        int a0 = 0;\n+        int a1 = 1;\n+        int a2 = 2;\n+        int a3 = 3;\n+        int a4 = 4;\n+        int a5 = 5;\n+        int a6 = 6;\n+        int a7 = 7;\n+        int a8 = 8;\n+        int a9 = 9;\n+    }\n+\n+    static TooBigToReturnAsFields tooBig = new TooBigToReturnAsFields();\n+\n+    \/\/**********************************************************************\n+    \/\/ PART 1 - C1 calls interpreted code\n+    \/\/**********************************************************************\n+\n+    \/\/** C1 passes inline type to interpreter (static)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test1() {\n+        return test1_helper(pointField);\n+    }\n+\n+    @DontCompile\n+    private static int test1_helper(Point p) {\n+        return p.func();\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 10;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test1() + i;\n+            Asserts.assertEQ(result, pointField.func() + i);\n+        }\n+    }\n+\n+    \/\/** C1 passes inline type to interpreter (monomorphic)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test2() {\n+        return test2_helper(pointField);\n+    }\n+\n+    @DontCompile\n+    private int test2_helper(Point p) {\n+        return p.func();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 10;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test2() + i;\n+            Asserts.assertEQ(result, pointField.func() + i);\n+        }\n+    }\n+\n+    \/\/ C1 passes inline type to interpreter (megamorphic: vtable)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test3(Functor functor) {\n+        return functor.apply_interp(pointField);\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 100;\n+        for (int i=0; i<count; i++) {  \/\/ need a loop to test inline cache and vtable indexing\n+            Functor functor = info.isWarmUp() ? functors[0] : getFunctor();\n+            int result = test3(functor) + i;\n+            Asserts.assertEQ(result, functor.apply_interp(pointField) + i);\n+        }\n+    }\n+\n+    \/\/ Same as test3, but compiled with C2. Test the hastable of VtableStubs\n+    @Test(compLevel = CompLevel.C2)\n+    public int test3b(Functor functor) {\n+        return functor.apply_interp(pointField);\n+    }\n+\n+    @Run(test = \"test3b\")\n+    public void test3b_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 100;\n+        for (int i=0; i<count; i++) {  \/\/ need a loop to test inline cache and vtable indexing\n+            Functor functor = info.isWarmUp() ? functors[0] : getFunctor();\n+            int result = test3b(functor) + i;\n+            Asserts.assertEQ(result, functor.apply_interp(pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C1 passes inline type to interpreter (megamorphic: itable)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test4(FunctorInterface fi) {\n+        return fi.apply_interp(pointField);\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 100;\n+        for (int i=0; i<count; i++) {  \/\/ need a loop to test inline cache and itable indexing\n+            Functor functor = info.isWarmUp() ? functors[0] : getFunctor();\n+            int result = test4(functor) + i;\n+            Asserts.assertEQ(result, functor.apply_interp(pointField) + i);\n+        }\n+    }\n+\n+    \/\/**********************************************************************\n+    \/\/ PART 2 - interpreter calls C1\n+    \/\/**********************************************************************\n+\n+    \/\/ Interpreter passes inline type to C1 (static)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    static public int test20(Point p1, long l, Point p2) {\n+        return p1.x + p2.y;\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        int result = test20(pointField1, 0, pointField2);\n+        int n = pointField1.x + pointField2.y;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/ Interpreter passes inline type to C1 (instance method in inline class)\n+    @Test\n+    public int test21(Point p) {\n+        return test21_helper(p);\n+    }\n+\n+    @DontCompile\n+    int test21_helper(Point p) {\n+        return p.func_c1(p);\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        int result = test21(pointField);\n+        int n = 2 * (pointField.x + pointField.y);\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+\n+    \/\/**********************************************************************\n+    \/\/ PART 3 - C2 calls C1\n+    \/\/**********************************************************************\n+\n+    \/\/ C2->C1 invokestatic, single inline arg\n+    @Test(compLevel = CompLevel.C2)\n+    public int test30() {\n+        return test30_helper(pointField);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test30_helper(Point p) {\n+        return p.x + p.y;\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test30();\n+            int n = pointField.x + pointField.y;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, two single inline args\n+    @Test(compLevel = CompLevel.C2)\n+    public int test31() {\n+      return test31_helper(pointField1, pointField2);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test31_helper(Point p1, Point p2) {\n+        return p1.x + p2.y;\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test31();\n+            int n = pointField1.x + pointField2.y;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, two single inline args and interleaving ints (all passed in registers on x64)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test32() {\n+      return test32_helper(0, pointField1, 1, pointField2);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test32_helper(int x, Point p1, int y, Point p2) {\n+        return p1.x + p2.y + x + y;\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test32();\n+            int n = pointField1.x + pointField2.y + 0 + 1;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface -- no verified_ro_entry (no inline args except for receiver)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test33(Intf intf, int a, int b) {\n+        return intf.func1(a, b);\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = info.isWarmUp() ? intfs[0] : getIntf(i+1);\n+            int result = test33(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func1(123, 456) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface -- use verified_ro_entry (has inline args other than receiver)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test34(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = info.isWarmUp() ? intfs[0] : getIntf(i+1);\n+            int result = test34(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, Point.y is on stack (x64)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test35() {\n+        return test35_helper(1, 2, 3, 4, 5, pointField);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test35_helper(int a1, int a2, int a3, int a4, int a5, Point p) {\n+        return a1 + a2 + a3 + a4 + a5 + p.x + p.y;\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test35();\n+            int n = 1 + 2 + 3  + 4 + 5 + pointField.x + pointField.y;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, shuffling arguments that are passed on stack\n+    @Test(compLevel = CompLevel.C2)\n+    public int test36() {\n+        return test36_helper(pointField, 1, 2, 3, 4, 5, 6, 7, 8);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test36_helper(Point p, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8) {\n+        return a6 + a8;\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test36();\n+            int n = 6 + 8;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, shuffling long arguments\n+    @Test(compLevel = CompLevel.C2)\n+    public int test37() {\n+        return test37_helper(pointField, 1, 2, 3, 4, 5, 6, 7, 8);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test37_helper(Point p, long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8) {\n+        return (int)(a6 + a8);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test37();\n+            int n = 6 + 8;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, shuffling boolean, byte, char, short, int, long arguments\n+    @Test(compLevel = CompLevel.C2)\n+    public int test38() {\n+        return test38_helper(pointField, true, (byte)1, (char)2, (short)3, 4, 5, (byte)6, (short)7, 8);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test38_helper(Point p, boolean a0, byte a1, char a2, short a3, int a4, long a5, byte a6, short a7, int a8) {\n+        if (a0) {\n+            return (int)(a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8);\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test38();\n+            int n = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8;\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, packing an inline type with all types of fixed point primitive fields.\n+    @Test(compLevel = CompLevel.C2)\n+    public long test39() {\n+        return test39_helper(1, fixedPointsField, 2, fixedPointsField);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static long test39_helper(int a1, FixedPoints f1, int a2, FixedPoints f2) {\n+        if (f1.Z0 == false && f1.Z1 == true && f2.Z0 == false && f2.Z1 == true) {\n+            return f1.B + f2.C + f1.S + f2.I + f1.J;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            long result = test39();\n+            long n = test39_helper(1, fixedPointsField, 2, fixedPointsField);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, shuffling floating point args\n+    @Test(compLevel = CompLevel.C2)\n+    public double test40() {\n+        return test40_helper(1.1f, 1.2, floatPointField, doublePointField, 1.3f, 1.4, 1.5f, 1.7, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static double test40_helper(float a1, double a2, FloatPoint fp, DoublePoint dp, float a3, double a4, float a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12) {\n+        return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + fp.x + fp.y - dp.x - dp.y;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            double result = test40();\n+            double n = test40_helper(1.1f, 1.2, floatPointField, doublePointField, 1.3f, 1.4, 1.5f, 1.7, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, mixing floats and ints\n+    @Test(compLevel = CompLevel.C2)\n+    public double test41() {\n+        return test41_helper(1, 1.2, pointField, floatPointField, doublePointField, 1.3f, 4, 1.5f, 1.7, 1.7, 1.8, 9, 1.10, 1.11, 1.12);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static double test41_helper(int a1, double a2, Point p, FloatPoint fp, DoublePoint dp, float a3, int a4, float a5, double a6, double a7, double a8, long a9, double a10, double a11, double a12) {\n+      return a1 + a2  + fp.x + fp.y - dp.x - dp.y + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12;\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            double result = test41();\n+            double n = test41_helper(1, 1.2, pointField, floatPointField, doublePointField, 1.3f, 4, 1.5f, 1.7, 1.7, 1.8, 9, 1.10, 1.11, 1.12);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, circular dependency (between rdi and first stack slot on x64)\n+    @Test(compLevel = CompLevel.C2)\n+    public float test42() {\n+        return test42_helper(eightFloatsField, pointField, 3, 4, 5, floatPointField, 7);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test42_helper(EightFloats ep1, \/\/ (xmm0 ... xmm7) -> rsi\n+                                       Point p2,        \/\/ (rsi, rdx) -> rdx\n+                                       int i3,          \/\/ rcx -> rcx\n+                                       int i4,          \/\/ r8 -> r8\n+                                       int i5,          \/\/ r9 -> r9\n+                                       FloatPoint fp6,  \/\/ (stk[0], stk[1]) -> rdi   ** circ depend\n+                                       int i7)          \/\/ rdi -> stk[0]             ** circ depend\n+    {\n+        return ep1.f1 + ep1.f2 + ep1.f3 + ep1.f4 + ep1.f5 + ep1.f6 + ep1.f7 + ep1.f8 +\n+            p2.x + p2.y + i3 + i4 + i5 + fp6.x + fp6.y + i7;\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            float result = test42();\n+            float n = test42_helper(eightFloatsField, pointField, 3, 4, 5, floatPointField, 7);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, packing causes stack growth (1 extra stack word)\n+    @Test(compLevel = CompLevel.C2)\n+    public float test43() {\n+        return test43_helper(floatPointField, 1, 2, 3, 4, 5, 6);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test43_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5, int a6) {\n+        \/\/ On x64:\n+        \/\/    Scalarized entry -- all parameters are passed in registers\n+        \/\/    Non-scalarized entry -- a6 is passed on stack[0]\n+        return fp.x + fp.y + a1 + a2 + a3 + a4 + a5 + a6;\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            float result = test43();\n+            float n = test43_helper(floatPointField, 1, 2, 3, 4, 5, 6);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, packing causes stack growth (2 extra stack words)\n+    @Test(compLevel = CompLevel.C2)\n+    public float test44() {\n+      return test44_helper(floatPointField, floatPointField, 1, 2, 3, 4, 5, 6);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test44_helper(FloatPoint fp1, FloatPoint fp2, int a1, int a2, int a3, int a4, int a5, int a6) {\n+        \/\/ On x64:\n+        \/\/    Scalarized entry -- all parameters are passed in registers\n+        \/\/    Non-scalarized entry -- a5 is passed on stack[0]\n+        \/\/    Non-scalarized entry -- a6 is passed on stack[1]\n+        return fp1.x + fp1.y +\n+               fp2.x + fp2.y +\n+               a1 + a2 + a3 + a4 + a5 + a6;\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            float result = test44();\n+            float n = test44_helper(floatPointField, floatPointField, 1, 2, 3, 4, 5, 6);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, packing causes stack growth (5 extra stack words)\n+    @Test(compLevel = CompLevel.C2)\n+    public float test45() {\n+      return test45_helper(floatPointField, floatPointField, floatPointField, floatPointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test45_helper(FloatPoint fp1, FloatPoint fp2, FloatPoint fp3, FloatPoint fp4, FloatPoint fp5, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {\n+        return fp1.x + fp1.y +\n+               fp2.x + fp2.y +\n+               fp3.x + fp3.y +\n+               fp4.x + fp4.y +\n+               fp5.x + fp5.y +\n+               a1 + a2 + a3 + a4 + a5 + a6 + a7;\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            float result = test45();\n+            float n = test45_helper(floatPointField, floatPointField, floatPointField, floatPointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, packing causes stack growth (1 extra stack word -- mixing Point and FloatPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public float test46() {\n+      return test46_helper(floatPointField, floatPointField, pointField, floatPointField, floatPointField, pointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test46_helper(FloatPoint fp1, FloatPoint fp2, Point p1, FloatPoint fp3, FloatPoint fp4, Point p2, FloatPoint fp5, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {\n+        return p1.x + p1.y +\n+               p2.x + p2.y +\n+               fp1.x + fp1.y +\n+               fp2.x + fp2.y +\n+               fp3.x + fp3.y +\n+               fp4.x + fp4.y +\n+               fp5.x + fp5.y +\n+               a1 + a2 + a3 + a4 + a5 + a6 + a7;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 2;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            float result = test46();\n+            float n = test46_helper(floatPointField, floatPointField, pointField, floatPointField, floatPointField, pointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    static class MyRuntimeException extends RuntimeException {\n+        MyRuntimeException(String s) {\n+            super(s);\n+        }\n+    }\n+\n+    static void checkStackTrace(Throwable t, String... methodNames) {\n+        StackTraceElement[] trace = t.getStackTrace();\n+        for (int i=0; i<methodNames.length; i++) {\n+            if (!methodNames[i].equals(trace[i].getMethodName())) {\n+                String error = \"Unexpected stack trace: level \" + i + \" should be \" + methodNames[i];\n+                System.out.println(error);\n+                t.printStackTrace(System.out);\n+                throw new RuntimeException(error, t);\n+            }\n+        }\n+    }\n+    \/\/*\n+\n+    \/\/ C2->C1 invokestatic, make sure stack walking works (with static variable)\n+    @Test(compLevel = CompLevel.C2)\n+    public void test47(int n) {\n+        try {\n+            test47_helper(floatPointField, 1, 2, 3, 4, 5);\n+            test47_value = 666;\n+        } catch (MyRuntimeException e) {\n+            \/\/ expected;\n+        }\n+        test47_value = n;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test47_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5) {\n+        test47_thrower();\n+        return 0.0f;\n+    }\n+\n+    @DontCompile\n+    private static void test47_thrower() {\n+        MyRuntimeException e = new MyRuntimeException(\"This exception should have been caught!\");\n+        checkStackTrace(e, \"test47_thrower\", \"test47_helper\", \"test47\", \"test47_verifier\");\n+        throw e;\n+    }\n+\n+    static int test47_value = 999;\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            test47_value = 777 + i;\n+            test47(i);\n+            Asserts.assertEQ(test47_value, i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, make sure stack walking works (with returned inline type)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test48(int n) {\n+        try {\n+            test48_helper(floatPointField, 1, 2, 3, 4, 5);\n+            return 666;\n+        } catch (MyRuntimeException e) {\n+            \/\/ expected;\n+        }\n+        return n;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test48_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5) {\n+        test48_thrower();\n+        return 0.0f;\n+    }\n+\n+    @DontCompile\n+    private static void test48_thrower() {\n+        MyRuntimeException e = new MyRuntimeException(\"This exception should have been caught!\");\n+        checkStackTrace(e, \"test48_thrower\", \"test48_helper\", \"test48\", \"test48_verifier\");\n+        throw e;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int n = test48(i);\n+            Asserts.assertEQ(n, i);\n+        }\n+    }\n+\n+    \/\/ C2->interpreter invokestatic, make sure stack walking works (same as test 48, but with stack extension\/repair)\n+    \/\/ (this is the baseline for test50 --\n+    \/\/ the only difference is: test49_helper is interpreted but test50_helper is compiled by C1).\n+    @Test(compLevel = CompLevel.C2)\n+    public int test49(int n) {\n+        try {\n+            test49_helper(floatPointField, 1, 2, 3, 4, 5, 6);\n+            return 666;\n+        } catch (MyRuntimeException e) {\n+            \/\/ expected;\n+        }\n+        return n;\n+    }\n+\n+    @DontCompile\n+    private static float test49_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5, int a6) {\n+        test49_thrower();\n+        return 0.0f;\n+    }\n+\n+    @DontCompile\n+    private static void test49_thrower() {\n+        MyRuntimeException e = new MyRuntimeException(\"This exception should have been caught!\");\n+        checkStackTrace(e, \"test49_thrower\", \"test49_helper\", \"test49\", \"test49_verifier\");\n+        throw e;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int n = test49(i);\n+            Asserts.assertEQ(n, i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, make sure stack walking works (same as test 48, but with stack extension\/repair)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test50(int n) {\n+        try {\n+            test50_helper(floatPointField, 1, 2, 3, 4, 5, 6);\n+            return 666;\n+        } catch (MyRuntimeException e) {\n+            \/\/ expected;\n+        }\n+        return n;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test50_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5, int a6) {\n+        test50_thrower();\n+        return 0.0f;\n+    }\n+\n+    @DontCompile\n+    private static void test50_thrower() {\n+        MyRuntimeException e = new MyRuntimeException(\"This exception should have been caught!\");\n+        checkStackTrace(e, \"test50_thrower\", \"test50_helper\", \"test50\", \"test50_verifier\");\n+        throw e;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int n = test50(i);\n+            Asserts.assertEQ(n, i);\n+        }\n+    }\n+\n+\n+    \/\/ C2->C1 invokestatic, inline class with ref fields (RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test51() {\n+        return test51_helper(refPointField1);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test51_helper(RefPoint rp1) {\n+        return rp1.x.n + rp1.y.n;\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test51();\n+            int n = test51_helper(refPointField1);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, inline class with ref fields (Point, RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test52() {\n+        return test52_helper(pointField, refPointField1);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test52_helper(Point p1, RefPoint rp1) {\n+        return p1.x + p1.y + rp1.x.n + rp1.y.n;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test52();\n+            int n = test52_helper(pointField, refPointField1);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, inline class with ref fields (RefPoint, RefPoint, RefPoint, RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test53() {\n+        return test53_helper(refPointField1, refPointField2, refPointField1, refPointField2);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test53_helper(RefPoint rp1, RefPoint rp2, RefPoint rp3, RefPoint rp4) {\n+        return rp1.x.n + rp1.y.n +\n+               rp2.x.n + rp2.y.n +\n+               rp3.x.n + rp3.y.n +\n+               rp4.x.n + rp4.y.n;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test53();\n+            int n = test53_helper(refPointField1, refPointField2, refPointField1, refPointField2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, inline class with ref fields (RefPoint, RefPoint, float, int, RefPoint, RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test54() {\n+        return test54_helper(refPointField1, refPointField2, 1.0f, 2, refPointField1, refPointField2);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test54_helper(RefPoint rp1, RefPoint rp2, float f, int i, RefPoint rp3, RefPoint rp4) {\n+        return rp1.x.n + rp1.y.n +\n+               rp2.x.n + rp2.y.n +\n+               (int)(f) + i +\n+               rp3.x.n + rp3.y.n +\n+               rp4.x.n + rp4.y.n;\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            int result = test54();\n+            int n = test54_helper(refPointField1, refPointField2, 1.0f, 2, refPointField1, refPointField2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/**\n+     * Each allocation with a \"try\" block like this will cause a GC\n+     *\n+     *       try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {\n+     *           result = test55(p1);\n+     *       }\n+     *\/\n+\n+    static final String ScavengeALot = \"ScavengeALot\";\n+\n+    static class ForceGCMarker implements java.io.Closeable {\n+        ForceGCMarker() {\n+            WhiteBox.getWhiteBox().setBooleanVMFlag(ScavengeALot, true);\n+        }\n+        public void close() {\n+            WhiteBox.getWhiteBox().setBooleanVMFlag(ScavengeALot, false);\n+        }\n+\n+        static ForceGCMarker mark(boolean warmup) {\n+            return warmup ? null : new ForceGCMarker();\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, force GC for every allocation when entering a C1 VEP (Point)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test55(Point p1) {\n+        return test55_helper(p1);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test55_helper(Point p1) {\n+        return p1.x + p1.y;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            Point p1 = new Point(1, 2);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test55(p1);\n+            }\n+            int n = test55_helper(p1);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, force GC for every allocation when entering a C1 VEP (RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test56(RefPoint rp1) {\n+        return test56_helper(rp1);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test56_helper(RefPoint rp1) {\n+        return rp1.x.n + rp1.y.n;\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test56(rp1);\n+            }\n+            int n = test56_helper(rp1);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->Interpreter (same as test56, but test C2i entry instead of C1)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test57(RefPoint rp1) {\n+        return test57_helper(rp1);\n+    }\n+\n+    @DontCompile\n+    private static int test57_helper(RefPoint rp1) {\n+        return rp1.x.n + rp1.y.n;\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test57(rp1);\n+            }\n+            int n = test57_helper(rp1);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, force GC for every allocation when entering a C1 VEP (a bunch of RefPoints and Numbers);\n+    @Test(compLevel = CompLevel.C2)\n+    public int test58(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+        return test58_helper(rp1, rp2, n1, rp3, rp4, n2);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test58_helper(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+        return rp1.x.n + rp1.y.n +\n+               rp2.x.n + rp2.y.n +\n+               n1.n +\n+               rp3.x.n + rp3.y.n +\n+               rp4.x.n + rp4.y.n +\n+               n2.n;\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            RefPoint rp2 = refPointField1;\n+            RefPoint rp3 = new RefPoint(222, 777);\n+            RefPoint rp4 = refPointField2;\n+            Number n1 = new Number(5878);\n+            Number n2 = new Number(1234);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test58(rp1, rp2, n1, rp3, rp4, n2);\n+            }\n+            int n = test58_helper(rp1, rp2, n1, rp3, rp4, n2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, GC inside main body of C1-compiled method (caller's args should not be GC'ed).\n+    @Test(compLevel = CompLevel.C2)\n+    public int test59(RefPoint rp1, boolean doGC) {\n+      return test59_helper(rp1, 11, 222, 3333, 4444, doGC);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test59_helper(RefPoint rp1, int a1, int a2, int a3, int a4, boolean doGC) {\n+        if (doGC) {\n+            System.gc();\n+        }\n+        return rp1.x.n + rp1.y.n + a1 + a2 + a3 + a4;\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        boolean doGC = !info.isWarmUp();\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            int result = test59(rp1, doGC);\n+            int n = test59_helper(rp1, 11, 222, 3333, 4444, doGC);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic, GC inside main body of C1-compiled method (caller's args should not be GC'ed).\n+    \/\/ same as test59, but the incoming (scalarized) oops are passed in both registers and stack.\n+    @Test(compLevel = CompLevel.C2)\n+    public int test60(RefPoint rp1, RefPoint rp2, boolean doGC) {\n+        return test60_helper(555, 6666, 77777, rp1, rp2, 11, 222, 3333, 4444, doGC);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static int test60_helper(int x0, int x1, int x2, RefPoint rp1, RefPoint rp2,int a1, int a2, int a3, int a4, boolean doGC) {\n+        \/\/ On x64, C2 passes:   reg0=x1, reg1=x1, reg2=x2, reg3=rp1.x, reg4=rp1.y, reg5=rp2.x stack0=rp2.y ....\n+        \/\/         C1 expects:  reg0=x1, reg1=x1, reg2=x2, reg3=rp1,   reg4=rp2,   reg5=a1    stack0=a2 ...\n+        \/\/ When GC happens, make sure it does not treat reg5 and stack0 as oops!\n+        if (doGC) {\n+            System.gc();\n+        }\n+        return x0 + x1 + x2 + rp1.x.n + rp1.y.n + rp2.x.n + rp2.y.n + a1 + a2 + a3 + a4;\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        boolean doGC = !info.isWarmUp();\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            RefPoint rp2 = new RefPoint(33, 44);\n+            int result = test60(rp1, rp2, doGC);\n+            int n = test60_helper(555, 6666, 77777, rp1, rp2, 11, 222, 3333, 4444, doGC);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface via VVEP(RO)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test61(RefPoint_Access rpa, RefPoint rp2) {\n+        return rpa.func1(rp2);\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint_Access rpa = get_RefPoint_Access();\n+            RefPoint rp2 = refPointField2;\n+            int result = test61(rpa, rp2);\n+            int n = rpa.func1(rp2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface via VVEP(RO) -- force GC for every allocation when entering a C1 VVEP(RO) (RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test62(RefPoint_Access rpa, RefPoint rp2) {\n+        return rpa.func1(rp2);\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint_Access rpa = get_RefPoint_Access();\n+            RefPoint rp2 = new RefPoint(111, 2222);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test62(rpa, rp2);\n+            }\n+            int n = rpa.func1(rp2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface via VVEP(RO) -- force GC for every allocation when entering a C1 VVEP(RO) (a bunch of RefPoints and Numbers)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test63(RefPoint_Access rpa, RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+        return rpa.func2(rp1, rp2, n1, rp3, rp4, n2);\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint_Access rpa = get_RefPoint_Access();\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            RefPoint rp2 = refPointField1;\n+            RefPoint rp3 = new RefPoint(222, 777);\n+            RefPoint rp4 = refPointField2;\n+            Number n1 = new Number(5878);\n+            Number n2 = new Number(1234);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test63(rpa, rp1, rp2, n1, rp3, rp4, n2);\n+            }\n+            int n = rpa.func2(rp1, rp2, n1, rp3, rp4, n2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokestatic (same as test63, but use invokestatic instead)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test64(RefPoint_Access rpa, RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+        return test64_helper(rpa, rp1, rp2, n1, rp3, rp4, n2);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    public static int test64_helper(RefPoint_Access rpa, RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {\n+        return rp3.y.n;\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint_Access rpa = get_RefPoint_Access();\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            RefPoint rp2 = refPointField1;\n+            RefPoint rp3 = new RefPoint(222, 777);\n+            RefPoint rp4 = refPointField2;\n+            Number n1 = new Number(5878);\n+            Number n2 = new Number(1234);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test64(rpa, rp1, rp2, n1, rp3, rp4, n2);\n+            }\n+            int n = test64_helper(rpa, rp1, rp2, n1, rp3, rp4, n2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokevirtual via VVEP(RO) (opt_virtual_call)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test76(RefPoint rp1, RefPoint rp2) {\n+        return rp1.final_func(rp2);\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = refPointField1;\n+            RefPoint rp2 = refPointField2;\n+            int result = test76(rp1, rp2);\n+            int n = rp1.final_func(rp2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokevirtual, force GC for every allocation when entering a C1 VEP (RefPoint)\n+    \/\/ Same as test56, except we call the VVEP(RO) instead of VEP.\n+    @Test(compLevel = CompLevel.C2)\n+    public int test77(RefPoint rp1, RefPoint rp2) {\n+        return rp1.final_func(rp2);\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+            RefPoint rp1 = new RefPoint(1, 2);\n+            RefPoint rp2 = new RefPoint(22, 33);\n+            int result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test77(rp1, rp2);\n+            }\n+            int n = rp1.final_func(rp2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/-------------------------------------------------------------------------------\n+    \/\/ Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns\n+    \/\/-------------------------------------------------------------------------------\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (Point)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test78(Point p) {\n+        Point np = test78_helper(p);\n+        return np.x + np.y;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static Point test78_helper(Point p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        int result = test78(pointField1);\n+        int n = pointField1.x + pointField1.y;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test79(RefPoint p) {\n+        RefPoint np = test79_helper(p);\n+        return np.x.n + np.y.n;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static RefPoint test79_helper(RefPoint p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        int result = test79(refPointField1);\n+        int n = refPointField1.x.n + refPointField1.y.n;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/ C1->C2 invokestatic with InlineTypeReturnedAsFields (RefPoint)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test80(RefPoint p) {\n+        RefPoint np = test80_helper(p);\n+        return np.x.n + np.y.n;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C2)\n+    private static RefPoint test80_helper(RefPoint p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        int result = test80(refPointField1);\n+        int n = refPointField1.x.n + refPointField1.y.n;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/ Interpreter->C1 invokestatic with InlineTypeReturnedAsFields (Point)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public Point test81(Point p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        Point p = test81(pointField1);\n+        Asserts.assertEQ(p.x, pointField1.x);\n+        Asserts.assertEQ(p.y, pointField1.y);\n+        p = test81(pointField2);\n+        Asserts.assertEQ(p.x, pointField2.x);\n+        Asserts.assertEQ(p.y, pointField2.y);\n+    }\n+\n+    \/\/ C1->Interpreter invokestatic with InlineTypeReturnedAsFields (RefPoint)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test82(RefPoint p) {\n+        RefPoint np = test82_helper(p);\n+        return np.x.n + np.y.n;\n+    }\n+\n+    @DontCompile\n+    private static RefPoint test82_helper(RefPoint p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        int result = test82(refPointField1);\n+        int n = refPointField1.x.n + refPointField1.y.n;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/-------------------------------------------------------------------------------\n+    \/\/ Tests for InlineTypeReturnedAsFields vs the inline class TooBigToReturnAsFields\n+    \/\/-------------------------------------------------------------------------------\n+\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test83(TooBigToReturnAsFields p) {\n+        TooBigToReturnAsFields np = test83_helper(p);\n+        return p.a0 + p.a5;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static TooBigToReturnAsFields test83_helper(TooBigToReturnAsFields p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier() {\n+        int result = test83(tooBig);\n+        int n = tooBig.a0 + tooBig.a5;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/ C1->C2 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test84(TooBigToReturnAsFields p) {\n+        TooBigToReturnAsFields np = test84_helper(p);\n+        return p.a0 + p.a5;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C2)\n+    private static TooBigToReturnAsFields test84_helper(TooBigToReturnAsFields p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        int result = test84(tooBig);\n+        int n = tooBig.a0 + tooBig.a5;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/ Interpreter->C1 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public TooBigToReturnAsFields test85(TooBigToReturnAsFields p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        TooBigToReturnAsFields p = test85(tooBig);\n+        Asserts.assertEQ(p.a0, tooBig.a0);\n+        Asserts.assertEQ(p.a2, tooBig.a2);\n+    }\n+\n+    \/\/ C1->Interpreter invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test86(TooBigToReturnAsFields p) {\n+        TooBigToReturnAsFields np = test86_helper(p);\n+        return p.a0 + p.a5;\n+    }\n+\n+    @DontCompile\n+    private static TooBigToReturnAsFields test86_helper(TooBigToReturnAsFields p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        int result = test86(tooBig);\n+        int n = tooBig.a0 + tooBig.a5;\n+        Asserts.assertEQ(result, n);\n+    }\n+\n+    \/\/-------------------------------------------------------------------------------\n+    \/\/ Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns (RefPoint.ref)\n+    \/\/-------------------------------------------------------------------------------\n+\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)\n+    @Test(compLevel = CompLevel.C2)\n+    public RefPoint.ref test87(RefPoint.ref p) {\n+        return test87_helper(p);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static RefPoint.ref test87_helper(RefPoint.ref p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier() {\n+        Asserts.assertEQ(test87(null), null);\n+        Asserts.assertEQ(test87(refPointField1), refPointField1);\n+    }\n+\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref with constant null)\n+    @Test(compLevel = CompLevel.C2)\n+    public RefPoint.ref test88() {\n+        return test88_helper();\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static RefPoint.ref test88_helper() {\n+        return null;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        Asserts.assertEQ(test88(), null);\n+    }\n+\n+    \/\/ C1->C2 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public RefPoint.ref test89(RefPoint.ref p) {\n+        return test89_helper(p);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C2)\n+    private static RefPoint.ref test89_helper(RefPoint.ref p) {\n+        return p;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        Asserts.assertEQ(test89(null), null);\n+        Asserts.assertEQ(test89(refPointField1), refPointField1);\n+    }\n+\n+    \/\/----------------------------------------------------------------------------------\n+    \/\/ Tests for unverified entries: there are 6 cases:\n+    \/\/ C1 -> Unverified Value Entry compiled by C1\n+    \/\/ C1 -> Unverified Value Entry compiled by C2\n+    \/\/ C2 -> Unverified Entry compiled by C1 (target is NOT an inline type)\n+    \/\/ C2 -> Unverified Entry compiled by C2 (target is NOT an inline type)\n+    \/\/ C2 -> Unverified Entry compiled by C1 (target IS an inline type, i.e., has VVEP_RO)\n+    \/\/ C2 -> Unverified Entry compiled by C2 (target IS an inline type, i.e., has VVEP_RO)\n+    \/\/----------------------------------------------------------------------------------\n+\n+    \/\/ C1->C1 invokeinterface -- call Unverified Value Entry of MyImplPojo1.func2 (compiled by C1)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test90(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    static Intf test90_intfs[] = {\n+        new MyImplPojo1(),\n+        new MyImplPojo2(),\n+    };\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test90_intfs[i % test90_intfs.length];\n+            int result = test90(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C1->C2 invokeinterface -- call Unverified Value Entry of MyImplPojo2.func2 (compiled by C2)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test91(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    static Intf test91_intfs[] = {\n+        new MyImplPojo2(),\n+        new MyImplPojo1(),\n+    };\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test91_intfs[i % test91_intfs.length];\n+            int result = test91(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface -- call Unverified Entry of MyImplPojo1.func2 (compiled by C1)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test92(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    static Intf test92_intfs[] = {\n+        new MyImplPojo1(),\n+        new MyImplPojo2(),\n+    };\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test92_intfs[i % test92_intfs.length];\n+            int result = test92(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C2 invokeinterface -- call Unverified Entry of MyImplPojo2.func2 (compiled by C2)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test93(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    static Intf test93_intfs[] = {\n+        new MyImplPojo2(),\n+        new MyImplPojo1(),\n+    };\n+\n+    @Run(test = \"test93\")\n+    public void test93_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test93_intfs[i % test93_intfs.length];\n+            int result = test93(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface -- call Unverified Entry of MyImplVal1.func2 (compiled by C1 - has VVEP_RO)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test94(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    static Intf test94_intfs[] = {\n+        new MyImplVal1(),\n+        new MyImplVal2(),\n+    };\n+\n+    @Run(test = \"test94\")\n+    public void test94_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test94_intfs[i % test94_intfs.length];\n+            int result = test94(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C2 invokeinterface -- call Unverified Entry of MyImplVal2.func2 (compiled by C2 - has VVEP_RO)\n+    @Test(compLevel = CompLevel.C2)\n+    public int test95(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    static Intf test95_intfs[] = {\n+        new MyImplVal2(),\n+        new MyImplVal1(),\n+    };\n+\n+    @Run(test = \"test95\")\n+    public void test95_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test95_intfs[i % test95_intfs.length];\n+            int result = test95(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);\n+        }\n+    }\n+\n+    \/\/ C1->C2 GC handling in StubRoutines::store_inline_type_fields_to_buf()\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public RefPoint test96(RefPoint rp, boolean b) {\n+        RefPoint p = test96_helper(rp);\n+        if (b) {\n+            return rp;\n+        }\n+        return p;\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C2)\n+    public RefPoint test96_helper(RefPoint rp) {\n+        return rp;\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20000; \/\/ Do enough iteration to cause GC inside StubRoutines::store_inline_type_fields_to_buf\n+        Number x = new Number(10); \/\/ old object\n+        for (int i=0; i<count; i++) {\n+            Number y = new Number(i); \/\/ new object for each iteraton\n+            RefPoint rp1 = new RefPoint(x, y);\n+            RefPoint rp2 = test96(rp1, info.isWarmUp());\n+\n+            Asserts.assertEQ(rp1.x, x);\n+            Asserts.assertEQ(rp1.y, y);\n+            Asserts.assertEQ(rp1.y.n, i);\n+        }\n+    }\n+\n+    \/\/ C1->C1  - caller is compiled first. It invokes callee(test97) a few times while the\n+    \/\/           callee is executed by the interpreter. Then, callee is compiled\n+    \/\/           and SharedRuntime::fixup_callers_callsite is called to fix up the\n+    \/\/           callsite from test97_verifier->test97.\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int test97(Point p1, Point p2) {\n+        return test97_helper(p1, p2);\n+    }\n+\n+    @DontCompile\n+    public int test97_helper(Point p1, Point p2) {\n+        return p1.x + p1.y + p2.x + p2.y;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    public void test97_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            int result = test97(pointField1, pointField2);\n+            int n = test97_helper(pointField1, pointField2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void run_test97_verifier(RunInfo info) {\n+        test97_verifier(info);\n+    }\n+\n+    \/\/ C1->C2  - same as test97, except the callee is compiled by C2.\n+    @Test(compLevel = CompLevel.C2)\n+    public int test98(Point p1, Point p2) {\n+        return test98_helper(p1, p2);\n+    }\n+\n+    @DontCompile\n+    public int test98_helper(Point p1, Point p2) {\n+        return p1.x + p1.y + p2.x + p2.y;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    public void test98_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            int result = test98(pointField1, pointField2);\n+            int n = test98_helper(pointField1, pointField2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void run_test98_verifier(RunInfo info) {\n+        test98_verifier(info);\n+    }\n+\n+    \/\/ C1->C2  - same as test97, except the callee is a static method.\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public static int test99(Point p1, Point p2) {\n+        return test99_helper(p1, p2);\n+    }\n+\n+    @DontCompile\n+    public static int test99_helper(Point p1, Point p2) {\n+        return p1.x + p1.y + p2.x + p2.y;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    public void test99_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            int result = test99(pointField1, pointField2);\n+            int n = test99_helper(pointField1, pointField2);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void run_test99_verifier(RunInfo info) {\n+        test99_verifier(info);\n+    }\n+\n+    \/\/ C2->C1 invokestatic, packing causes stack growth (1 extra stack word).\n+    \/\/ Make sure stack frame is set up properly for GC.\n+    @Test(compLevel = CompLevel.C2)\n+    public float test100(FloatPoint fp1, FloatPoint fp2, RefPoint rp, int a1, int a2, int a3, int a4) {\n+        return test100_helper(fp1, fp2, rp, a1, a2, a3, a4);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    private static float test100_helper(FloatPoint fp1, FloatPoint fp2, RefPoint rp, int a1, int a2, int a3, int a4) {\n+        \/\/ On x64:\n+        \/\/    Scalarized entry -- all parameters are passed in registers\n+        \/\/          xmm0 = fp1.x\n+        \/\/          xmm1 = fp1.y\n+        \/\/          xmm2 = fp2.x\n+        \/\/          xmm3 = fp2.y\n+        \/\/          rsi  = rp.x  (oop)\n+        \/\/          rdx  = rp.y  (oop)\n+        \/\/          cx   = a1\n+        \/\/          r8   = a2\n+        \/\/          r9   = a3\n+        \/\/          di   = a4\n+        \/\/    Non-scalarized entry -- a6 is passed on stack[0]\n+        \/\/          rsi  = fp1\n+        \/\/          rdx  = fp2\n+        \/\/          rcx  = rp\n+        \/\/          r8   = a1\n+        \/\/          r9   = a2\n+        \/\/          di   = a3\n+        \/\/    [sp + ??]  = a4\n+        return fp1.x + fp1.y + fp2.x + fp2.y + rp.x.n + rp.y.n + a1 + a2 + a3 + a4;\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 4;\n+        for (int i=0; i<count; i++) {\n+            FloatPoint fp1 = new FloatPoint(i+0,  i+11);\n+            FloatPoint fp2 = new FloatPoint(i+222, i+3333);\n+            RefPoint rp = new RefPoint(i+44444, i+555555);\n+            float result;\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test100(fp1, fp2, rp, 1, 2, 3, 4);\n+            }\n+            float n = test100_helper(fp1, fp2, rp, 1, 2, 3, 4);\n+            Asserts.assertEQ(result, n);\n+        }\n+    }\n+\n+    \/\/ C1->C2 force GC for every allocation when storing the returned\n+    \/\/ fields back into a buffered object.\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public RefPoint test101(RefPoint rp) {\n+        return test101_helper(rp);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C2)\n+    public RefPoint test101_helper(RefPoint rp) {\n+        return rp;\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) {\n+            RefPoint rp = new RefPoint(1, 2);\n+            Object x = rp.x;\n+            Object y = rp.y;\n+            RefPoint result = new RefPoint(3, 4);\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test101(rp);\n+            }\n+            Asserts.assertEQ(rp.x, result.x);\n+            Asserts.assertEQ(rp.y, result.y);\n+            Asserts.assertEQ(x, result.x);\n+            Asserts.assertEQ(y, result.y);\n+        }\n+    }\n+\n+    \/\/ Same as test101, except we have Interpreter->C2 instead.\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public RefPoint test102(RefPoint rp) {\n+        return test102_interp(rp);\n+    }\n+\n+    @DontInline\n+    public RefPoint test102_interp(RefPoint rp) {\n+        return test102_helper(rp);\n+    }\n+\n+    @DontInline\n+    @ForceCompile(CompLevel.C2)\n+    public RefPoint test102_helper(RefPoint rp) {\n+        return rp;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 5;\n+        for (int i=0; i<count; i++) {\n+            RefPoint rp = new RefPoint(11, 22);\n+            Object x = rp.x;\n+            Object y = rp.y;\n+            RefPoint result = new RefPoint(333, 444);\n+            try (ForceGCMarker m = ForceGCMarker.mark(info.isWarmUp())) {\n+                result = test102(rp);\n+            }\n+            Asserts.assertEQ(rp.x, result.x);\n+            Asserts.assertEQ(rp.y, result.y);\n+            Asserts.assertEQ(x, result.x);\n+            Asserts.assertEQ(y, result.y);\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void test103() {\n+        \/\/ when this method is compiled by C1, the Test103Value class is not yet loaded.\n+        test103_v = new Test103Value(); \/\/ invokestatic \"Test103Value.<init>()QTest103Value;\"\n+    }\n+\n+    static primitive class Test103Value {\n+        int x = rI;\n+    }\n+\n+    static Object test103_v;\n+\n+    @Run(test = \"test103\")\n+    public void test103_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ Make sure test103() is compiled before Test103Value is loaded\n+            return;\n+        }\n+        test103();\n+        Test103Value v = (Test103Value)test103_v;\n+        Asserts.assertEQ(v.x, rI);\n+    }\n+\n+\n+    \/\/ Same as test103, but with an inline class that's too big to return as fields.\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void test104() {\n+        \/\/ when this method is compiled by C1, the Test104Value class is not yet loaded.\n+        test104_v = new Test104Value(); \/\/ invokestatic \"Test104Value.<init>()QTest104Value;\"\n+    }\n+\n+    static primitive class Test104Value {\n+        long x0 = rL;\n+        long x1 = rL;\n+        long x2 = rL;\n+        long x3 = rL;\n+        long x4 = rL;\n+        long x5 = rL;\n+        long x6 = rL;\n+        long x7 = rL;\n+        long x8 = rL;\n+        long x9 = rL;\n+        long xa = rL;\n+        long xb = rL;\n+        long xc = rL;\n+        long xd = rL;\n+        long xe = rL;\n+        long xf = rL;\n+    }\n+\n+    static Object test104_v;\n+\n+    @Run(test = \"test104\")\n+    public void test104_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ Make sure test104() is compiled before Test104Value is loaded\n+            return;\n+        }\n+        test104();\n+        Test104Value v = (Test104Value)test104_v;\n+        Asserts.assertEQ(v.x0, rL);\n+    }\n+\n+    \/\/ C2->C1 invokeinterface -- call Unverified Entry of MyImplVal1.func1 (compiled by C1 - has VVEP_RO)\n+    \/\/\/ (same as test94, except we are calling func1, which shares VVEP and VVEP_RO\n+    @Test(compLevel = CompLevel.C2)\n+    public int test105(Intf intf, int a, int b) {\n+        return intf.func1(a, b);\n+    }\n+\n+    static Intf test105_intfs[] = {\n+        new MyImplVal1(),\n+        new MyImplVal2(),\n+    };\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test105_intfs[i % test105_intfs.length];\n+            int result = test105(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func1(123, 456) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C2 invokeinterface -- call Unverified Entry of MyImplVal2.func1 (compiled by C2 - has VVEP_RO)\n+    \/\/\/ (same as test95, except we are calling func1, which shares VVEP and VVEP_RO\n+    @Test(compLevel = CompLevel.C2)\n+    public int test106(Intf intf, int a, int b) {\n+        return intf.func1(a, b);\n+    }\n+\n+    static Intf test106_intfs[] = {\n+        new MyImplVal2(),\n+        new MyImplVal1(),\n+    };\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier(RunInfo info) {\n+        int count = info.isWarmUp() ? 1 : 20;\n+        for (int i=0; i<count; i++) {\n+            Intf intf = test106_intfs[i % test106_intfs.length];\n+            int result = test106(intf, 123, 456) + i;\n+            Asserts.assertEQ(result, intf.func1(123, 456) + i);\n+        }\n+    }\n+\n+    \/\/ C2->C1 invokeinterface -- C2 calls call Unverified Entry of MyImplVal2X.func1 (compiled by\n+    \/\/                           C1, with VVEP_RO==VVEP)\n+    \/\/ This test is developed to validate JDK-8230325.\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public int test107(Intf intf, int a, int b) {\n+        return intf.func1(a, b);\n+    }\n+\n+    @ForceCompile\n+    public void test107_verifier() {\n+        Intf intf1 = new MyImplVal1X();\n+        Intf intf2 = new MyImplVal2X();\n+\n+        for (int i=0; i<1000; i++) {\n+            test107(intf1, 123, 456);\n+        }\n+        for (int i=0; i<500_000; i++) {\n+            \/\/ Run enough loops so that test107 will be compiled by C2.\n+            if (i % 30 == 0) {\n+                \/\/ This will indirectly call MyImplVal2X.func1, but the call frequency is low, so\n+                \/\/ test107 will be compiled by C2, but MyImplVal2X.func1 will compiled by C1 only.\n+                int result = test107(intf2, 123, 456) + i;\n+                Asserts.assertEQ(result, intf2.func1(123, 456) + i);\n+            } else {\n+                \/\/ Call test107 with a mix of intf1 and intf2, so C2 will use a virtual call (not an optimized call)\n+                \/\/ for the invokeinterface bytecode in test107.\n+                test107(intf1, 123, 456);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test107\")\n+    @Warmup(0)\n+    public void run_test107_verifier() {\n+        test107_verifier();\n+    }\n+\n+    \/\/ Same as test107, except we call MyImplVal2X.func2 (compiled by C1, VVEP_RO != VVEP)\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public int test108(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    @ForceCompile\n+    public void test108_verifier() {\n+        Intf intf1 = new MyImplVal1X();\n+        Intf intf2 = new MyImplVal2X();\n+\n+        for (int i=0; i<1000; i++) {\n+            test108(intf1, 123, 456);\n+        }\n+        for (int i=0; i<500_000; i++) {\n+            \/\/ Run enough loops so that test108 will be compiled by C2.\n+            if (i % 30 == 0) {\n+                \/\/ This will indirectly call MyImplVal2X.func2, but the call frequency is low, so\n+                \/\/ test108 will be compiled by C2, but MyImplVal2X.func2 will compiled by C1 only.\n+                int result = test108(intf2, 123, 456) + i;\n+                Asserts.assertEQ(result, intf2.func2(123, 456, pointField) + i);\n+            } else {\n+                \/\/ Call test108 with a mix of intf1 and intf2, so C2 will use a virtual call (not an optimized call)\n+                \/\/ for the invokeinterface bytecode in test108.\n+                test108(intf1, 123, 456);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test108\")\n+    @Warmup(0)\n+    public void run_test108_verifier() {\n+        test108_verifier();\n+    }\n+\n+    \/\/ Same as test107, except we call MyImplPojo3.func2 (compiled by C1, VVEP_RO == VEP)\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public int test109(Intf intf, int a, int b) {\n+        return intf.func2(a, b, pointField);\n+    }\n+\n+    @ForceCompile\n+    public void test109_verifier() {\n+        Intf intf1 = new MyImplPojo0();\n+        Intf intf2 = new MyImplPojo3();\n+\n+        for (int i=0; i<1000; i++) {\n+            test109(intf1, 123, 456);\n+        }\n+        for (int i=0; i<500_000; i++) {\n+            \/\/ Run enough loops so that test109 will be compiled by C2.\n+            if (i % 30 == 0) {\n+                \/\/ This will indirectly call MyImplPojo3.func2, but the call frequency is low, so\n+                \/\/ test109 will be compiled by C2, but MyImplPojo3.func2 will compiled by C1 only.\n+                int result = test109(intf2, 123, 456) + i;\n+                Asserts.assertEQ(result, intf2.func2(123, 456, pointField) + i);\n+            } else {\n+                \/\/ Call test109 with a mix of intf1 and intf2, so C2 will use a virtual call (not an optimized call)\n+                \/\/ for the invokeinterface bytecode in test109.\n+                test109(intf1, 123, 456);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test109\")\n+    @Warmup(0)\n+    public void run_test109_verifier() {\n+        test109_verifier();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConventionC1.java","additions":2369,"deletions":0,"binary":false,"changes":2369,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/**\n+ * @test TestDeoptimizationWhenBuffering\n+ * @summary Test correct execution after deoptimizing from inline type specific runtime calls.\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @build org.openjdk.asmtools.* org.openjdk.asmtools.jasm.*\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver org.openjdk.asmtools.JtregDriver jasm -strict TestDeoptimizationWhenBufferingClasses.jasm\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:-AlwaysIncrementalInline\n+ *                   -XX:-InlineTypePassFieldsAsArgs -XX:-InlineTypeReturnedAsFields -XX:FlatArrayElementMaxSize=1\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:+AlwaysIncrementalInline\n+ *                   -XX:-InlineTypePassFieldsAsArgs -XX:-InlineTypeReturnedAsFields -XX:FlatArrayElementMaxSize=1\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:-AlwaysIncrementalInline\n+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:FlatArrayElementMaxSize=-1\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:+AlwaysIncrementalInline\n+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:FlatArrayElementMaxSize=-1\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:-AlwaysIncrementalInline\n+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=0\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:+AlwaysIncrementalInline\n+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=0\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.*::test*\n+ *                   compiler.valhalla.inlinetypes.TestDeoptimizationWhenBuffering\n+ *\/\n+\n+public class TestDeoptimizationWhenBuffering {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+\n+    static {\n+        try {\n+            Class<?> clazz = TestDeoptimizationWhenBuffering.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(MyValue1.class.asValueType());\n+            test9_mh = lookup.findStatic(clazz, \"test9Callee\", mt);\n+            test10_mh = lookup.findStatic(clazz, \"test10Callee\", mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    MyValue1 test1() {\n+        return new MyValue1();\n+    }\n+\n+    static MyValue1 vtField1;\n+\n+    MyValue1 test2() {\n+        vtField1 = new MyValue1();\n+        return vtField1;\n+    }\n+\n+    public int test3Callee(MyValue1 vt) {\n+        return vt.hash();\n+    }\n+\n+    int test3() {\n+        MyValue1 vt = new MyValue1();\n+        return test3Callee(vt);\n+    }\n+\n+    static MyValue1[] vtArray = new MyValue1[1];\n+\n+    MyValue1 test4() {\n+        vtArray[0] = new MyValue1();\n+        return vtArray[0];\n+    }\n+\n+    Object test5(Object[] array) {\n+        array[0] = new MyValue1();\n+        return array[0];\n+    }\n+\n+    boolean test6(Object obj) {\n+        MyValue1 vt = new MyValue1();\n+        return vt == obj;\n+    }\n+\n+    Object test7(Object[] obj) {\n+        return obj[0];\n+    }\n+\n+    MyValue1.ref test8(MyValue1.ref[] obj) {\n+        return obj[0];\n+    }\n+\n+    static final MethodHandle test9_mh;\n+\n+    public static MyValue1 test9Callee() {\n+        return new MyValue1();\n+    }\n+\n+    MyValue1 test9() throws Throwable {\n+        return (MyValue1)test9_mh.invokeExact();\n+    }\n+\n+    static final MethodHandle test10_mh;\n+    static final MyValue1 test10Field = new MyValue1();\n+    static int test10Counter = 0;\n+\n+    public static MyValue1 test10Callee() {\n+        test10Counter++;\n+        return test10Field;\n+    }\n+\n+    Object test10() throws Throwable {\n+        return test10_mh.invoke();\n+    }\n+\n+    MyValue1 test11(MyValue1 vt) {\n+        return vt.testWithField(42);\n+    }\n+\n+    MyValue1 vtField2;\n+\n+    MyValue1 test12() {\n+        vtField2 = new MyValue1();\n+        return vtField2;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length > 0) {\n+            \/\/ Compile callees with C1 only, to exercise deoptimization while buffering at method entry\n+            Asserts.assertEQ(args[0], \"C1\", \"unsupported mode\");\n+            Method m = MyValue1.class.getMethod(\"testWithField\", int.class);\n+            WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+            m = TestDeoptimizationWhenBuffering.class.getMethod(\"test3Callee\", MyValue1.class.asValueType());\n+            WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+            m = TestDeoptimizationWhenBuffering.class.getMethod(\"test9Callee\");\n+            WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+            m = TestDeoptimizationWhenBuffering.class.getMethod(\"test10Callee\");\n+            WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+        }\n+\n+        MyValue1[] va = new MyValue1[3];\n+        va[0] = new MyValue1();\n+        Object[] oa = new Object[3];\n+        oa[0] = va[0];\n+        TestDeoptimizationWhenBuffering t = new TestDeoptimizationWhenBuffering();\n+        for (int i = 0; i < 100_000; ++i) {\n+            \/\/ Check counters to make sure that we don't accidentially reexecute calls when deoptimizing\n+            int expected = MyValue1.cnt + MyValue2.cnt + MyValue2.cnt;\n+            Asserts.assertEQ(t.test1().hash(), expected + 4);\n+            vtField1 = MyValue1.default;\n+            Asserts.assertEQ(t.test2().hash(), expected + 9);\n+            Asserts.assertEQ(vtField1.hash(), expected + 9);\n+            Asserts.assertEQ(t.test3(), expected + 14);\n+            Asserts.assertEQ(t.test4().hash(), expected + 19);\n+            Asserts.assertEQ(((MyValue1)t.test5(vtArray)).hash(), expected + 24);\n+            Asserts.assertEQ(t.test6(vtField1), false);\n+            Asserts.assertEQ(t.test7(((i % 2) == 0) ? va : oa), va[0]);\n+            Asserts.assertEQ(t.test8(va), va[0]);\n+            Asserts.assertEQ(t.test8(va), va[0]);\n+            Asserts.assertEQ(t.test9().hash(), expected + 34);\n+            int count = test10Counter;\n+            Asserts.assertEQ(((MyValue1)t.test10()).hash(), test10Field.hash());\n+            Asserts.assertEQ(t.test10Counter, count + 1);\n+            Asserts.assertEQ(t.test11(va[0]).hash(), va[0].testWithField(42).hash());\n+            t.vtField2 = MyValue1.default;\n+            Asserts.assertEQ(t.test12().hash(), expected + 39);\n+            Asserts.assertEQ(t.vtField2.hash(), expected + 39);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue1\n+    version 64:0\n+{\n+    static Field cnt:I;\n+    final Field x:I;\n+    final Field vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+    final Field vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+    public static Method <init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+        getstatic cnt:I;\n+        iconst_1;\n+        iadd;\n+        putstatic cnt:I;\n+\n+        aconst_init compiler\/valhalla\/inlinetypes\/MyValue1;\n+\n+        getstatic cnt:I;\n+        withfield x:I;\n+\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        withfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        withfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+        areturn;\n+    }\n+\n+    public Method hash:\"()I\" stack 2 {\n+        aload_0;\n+        getfield x:I;\n+\n+        aload_0;\n+        getfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n+        iadd;\n+\n+        aload_0;\n+        getfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n+        iadd;\n+\n+        ireturn;\n+    }\n+\n+    public Method testWithField:\"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield x:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue2\n+    version 64:0\n+{\n+    static Field cnt:I;\n+    final Field x:I;\n+\n+    public static Method <init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\" stack 2 {\n+        getstatic cnt:I;\n+        iconst_1;\n+        iadd;\n+        putstatic cnt:I;\n+\n+        aconst_init compiler\/valhalla\/inlinetypes\/MyValue2;\n+\n+        getstatic cnt:I;\n+        withfield x:I;\n+\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBufferingClasses.jasm","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,4382 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import jdk.experimental.bytecode.TypeTag;\n+import java.util.Arrays;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile MyValue5.jcod\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver\/timeout=450 compiler.valhalla.inlinetypes.TestLWorld\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestLWorld {\n+\n+    public static void main(String[] args) {\n+        \/\/ Make sure Test140Value is loaded but not linked\n+        Class<?> class1 = Test140Value.class;\n+        \/\/ Make sure Test141Value is linked but not initialized\n+        Class<?> class2 = Test141Value.class;\n+        class2.getDeclaredFields();\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Helper methods\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);\n+\n+    protected long hash() {\n+        return testValue1.hash();\n+    }\n+\n+    \/\/ Test passing an inline type as an Object\n+    @DontInline\n+    public Object test1_dontinline1(Object o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test1_dontinline2(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public Object test1_inline1(Object o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test1_inline2(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test1() {\n+        MyValue1 vt = testValue1;\n+        vt = (MyValue1)test1_dontinline1(vt);\n+        vt =           test1_dontinline2(vt);\n+        vt = (MyValue1)test1_inline1(vt);\n+        vt =           test1_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        Asserts.assertEQ(test1().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from Object and inline type fields\n+    Object objectField1 = null;\n+    Object objectField2 = null;\n+    Object objectField3 = null;\n+    Object objectField4 = null;\n+    Object objectField5 = null;\n+    Object objectField6 = null;\n+\n+    MyValue1 valueField1 = testValue1;\n+    MyValue1 valueField2 = testValue1;\n+    MyValue1.ref valueField3 = testValue1;\n+    MyValue1 valueField4;\n+    MyValue1.ref valueField5;\n+\n+    static MyValue1.ref staticValueField1 = testValue1;\n+    static MyValue1 staticValueField2 = testValue1;\n+    static MyValue1 staticValueField3;\n+    static MyValue1.ref staticValueField4;\n+\n+    @DontInline\n+    public Object readValueField5() {\n+        return (Object)valueField5;\n+    }\n+\n+    @DontInline\n+    public Object readStaticValueField4() {\n+        return (Object)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test2(MyValue1 vt1, Object vt2) {\n+        objectField1 = vt1;\n+        objectField2 = (MyValue1)vt2;\n+        objectField3 = testValue1;\n+        objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        objectField5 = valueField1;\n+        objectField6 = valueField3;\n+        valueField1 = (MyValue1)objectField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)objectField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5() != null || readStaticValueField4() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)objectField1).hash() + ((MyValue1)objectField2).hash() +\n+               ((MyValue1)objectField3).hash() + ((MyValue1)objectField4).hash() +\n+               ((MyValue1)objectField5).hash() + ((MyValue1)objectField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test2(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    \/\/ Test merging inline types and objects\n+    @Test\n+    public Object test3(int state) {\n+        Object res = null;\n+        if (state == 0) {\n+            res = Integer.valueOf(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        } else if (state == 6) {\n+            res = MyValue2.createWithFieldsInline(rI, rD);\n+        } else if (state == 7) {\n+            res = testValue2;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        objectField1 = valueField1;\n+        Object result = null;\n+        result = test3(0);\n+        Asserts.assertEQ((Integer)result, rI);\n+        result = test3(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(5);\n+        Asserts.assertEQ(result, null);\n+        result = test3(6);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+        result = test3(7);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+    }\n+\n+    \/\/ Test merging inline types and objects in loops\n+    @Test\n+    public Object test4(int iters) {\n+        Object res = Integer.valueOf(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof Integer) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        Integer result1 = (Integer)test4(0);\n+        Asserts.assertEQ(result1, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test4(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in object variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP})\n+    public long test5(MyValue1 arg, boolean deopt, Method m) {\n+        Object vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        Object vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        Object vt3 = arg;\n+        Object vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier(RunInfo info) {\n+        long result = test5(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with objects\n+    @Test\n+    public boolean test6(Object arg) {\n+        Object vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (Object)valueField1 || vt == objectField1 || vt == null ||\n+            arg == vt || (Object)valueField1 == vt || objectField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        boolean result = test6(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ merge of inline type and non-inline type\n+    @Test\n+    public Object test7(boolean flag) {\n+        Object res = null;\n+        if (flag) {\n+            res = valueField1;\n+        } else {\n+            res = objectField1;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        test7(true);\n+        test7(false);\n+    }\n+\n+    @Test\n+    public Object test8(boolean flag) {\n+        Object res = null;\n+        if (flag) {\n+            res = objectField1;\n+        } else {\n+            res = valueField1;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        test8(true);\n+        test8(false);\n+    }\n+\n+    \/\/ merge of inline types in a loop, stored in an object local\n+    @Test\n+    public Object test9() {\n+        Object o = valueField1;\n+        for (int i = 1; i < 100; i *= 2) {\n+            MyValue1 v = (MyValue1)o;\n+            o = MyValue1.setX(v, v.x + 1);\n+        }\n+        return o;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9();\n+    }\n+\n+    \/\/ merge of inline types in an object local\n+    @ForceInline\n+    public Object test10_helper() {\n+        return valueField1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test10(boolean flag) {\n+        Object o = null;\n+        if (flag) {\n+            o = valueField1;\n+        } else {\n+            o = test10_helper();\n+        }\n+        valueField1 = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        test10(true);\n+        test10(false);\n+    }\n+\n+    \/\/ Interface tests\n+\n+    @DontInline\n+    public MyInterface test11_dontinline1(MyInterface o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test11_dontinline2(MyInterface o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public MyInterface test11_inline1(MyInterface o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test11_inline2(MyInterface o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    public MyValue1 test11() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        vt = (MyValue1)test11_dontinline1(vt);\n+        vt =           test11_dontinline2(vt);\n+        vt = (MyValue1)test11_inline1(vt);\n+        vt =           test11_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        Asserts.assertEQ(test11().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from interface and inline type fields\n+    MyInterface interfaceField1 = null;\n+    MyInterface interfaceField2 = null;\n+    MyInterface interfaceField3 = null;\n+    MyInterface interfaceField4 = null;\n+    MyInterface interfaceField5 = null;\n+    MyInterface interfaceField6 = null;\n+\n+    @DontInline\n+    public MyInterface readValueField5AsInterface() {\n+        return (MyInterface)valueField5;\n+    }\n+\n+    @DontInline\n+    public MyInterface readStaticValueField4AsInterface() {\n+        return (MyInterface)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test12(MyValue1 vt1, MyInterface vt2) {\n+        interfaceField1 = vt1;\n+        interfaceField2 = (MyValue1)vt2;\n+        interfaceField3 = MyValue1.createWithFieldsInline(rI, rL);\n+        interfaceField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        interfaceField5 = valueField1;\n+        interfaceField6 = valueField3;\n+        valueField1 = (MyValue1)interfaceField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)interfaceField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +\n+               ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +\n+               ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test12(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    class MyObject1 implements MyInterface {\n+        public int x;\n+\n+        public MyObject1(int x) {\n+            this.x = x;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Test merging inline types and interfaces\n+    @Test\n+    public MyInterface test13(int state) {\n+        MyInterface res = null;\n+        if (state == 0) {\n+            res = new MyObject1(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        objectField1 = valueField1;\n+        MyInterface result = null;\n+        result = test13(0);\n+        Asserts.assertEQ(((MyObject1)result).x, rI);\n+        result = test13(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(5);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ Test merging inline types and interfaces in loops\n+    @Test\n+    public MyInterface test14(int iters) {\n+        MyInterface res = new MyObject1(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof MyObject1) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        MyObject1 result1 = (MyObject1)test14(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test14(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in interface variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP})\n+    public long test15(MyValue1 arg, boolean deopt, Method m) {\n+        MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyInterface vt3 = arg;\n+        MyInterface vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier(RunInfo info) {\n+        long result = test15(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with interfaces\n+    @Test\n+    public boolean test16(Object arg) {\n+        MyInterface vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (MyInterface)valueField1 || vt == interfaceField1 || vt == null ||\n+            arg == vt || (MyInterface)valueField1 == vt || interfaceField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        boolean result = test16(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Test subtype check when casting to inline type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test17(MyValue1 vt, Object obj) {\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test17(vt, Integer.valueOf(rI));\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public MyValue1 test18(MyValue1 vt) {\n+        Object obj = vt;\n+        vt = (MyValue1)obj;\n+        return vt;\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test18(vt);\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test19(MyValue1 vt) {\n+        Object obj = vt;\n+        try {\n+            MyValue2 vt2 = (MyValue2)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        test19(valueField1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test20(MyValue1 vt) {\n+        Object obj = vt;\n+        try {\n+            Integer i = (Integer)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        test20(valueField1);\n+    }\n+\n+    \/\/ Array tests\n+\n+    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,\n+                                                                      testValue1,\n+                                                                      testValue1};\n+\n+    private static final MyValue1[][] testValue1Array2 = new MyValue1[][] {testValue1Array,\n+                                                                           testValue1Array,\n+                                                                           testValue1Array};\n+\n+    private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,\n+                                                                      testValue2,\n+                                                                      testValue2};\n+\n+    private static final Integer[] testIntegerArray = new Integer[42];\n+\n+    \/\/ Test load from (flattened) inline type array disguised as object array\n+    @Test\n+    public Object test21(Object[] oa, int index) {\n+        return oa[index];\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test load from (flattened) inline type array disguised as interface array\n+    @Test\n+    public Object test22Interface(MyInterface[] ia, int index) {\n+        return ia[index];\n+    }\n+\n+    @Run(test = \"test22Interface\")\n+    public void test22Interface_verifier() {\n+        MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test load from (flattened) inline type array disguised as abstract array\n+    @Test\n+    public Object test22Abstract(MyAbstract[] ia, int index) {\n+        return ia[index];\n+    }\n+\n+    @Run(test = \"test22Abstract\")\n+    public void test22Abstract_verifier() {\n+        MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test23_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test23(Object[] oa, MyValue1 vt, int index) {\n+        test23_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test23(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test23(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test24_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test24(Object[] oa, MyValue1 vt, int index) {\n+        test24_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test24(testIntegerArray, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test25_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test25(Object[] oa, MyValue1 vt, int index) {\n+        test25_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test25(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as interface array\n+    @ForceInline\n+    public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {\n+      test26Interface_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test26Interface\")\n+    public void test26Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test26Interface(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test26Interface(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {\n+        test27Interface_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test27Interface\")\n+    public void test27Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test27Interface(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as abstract array\n+    @ForceInline\n+    public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {\n+      test26Abstract_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test26Abstract\")\n+    public void test26Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test26Abstract(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test26Abstract(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {\n+        test27Abstract_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test27Abstract\")\n+    public void test27Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test27Abstract(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test object store to (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test28_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test28(Object[] oa, Object o, int index) {\n+        test28_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test28(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test28(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test29_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test29(Object[] oa, Object o, int index) {\n+        test29_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test29(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test30_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test30(Object[] oa, Object o, int index) {\n+        test30_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test30(testIntegerArray, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as interface array\n+    @ForceInline\n+    public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test31Interface(MyInterface[] ia, MyInterface i, int index) {\n+        test31Interface_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test31Interface\")\n+    public void test31Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test31Interface(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test31Interface(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test32Interface(MyInterface[] ia, MyInterface i, int index) {\n+        test32Interface_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test32Interface\")\n+    public void test32Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test32Interface(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as abstract array\n+    @ForceInline\n+    public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {\n+        test31Abstract_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test31Abstract\")\n+    public void test31Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test31Abstract(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test31Abstract(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {\n+        test32Abstract_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test32Abstract\")\n+    public void test32Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test32Abstract(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test writing null to a (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test33_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test33(Object[] oa, Object o, int index) {\n+        test33_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test33(testValue1Array, null, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing constant null to a (flattened) inline type array disguised as object array\n+\n+    @ForceInline\n+    public void test34_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test34(Object[] oa, int index) {\n+        test34_inline(oa, null, index);\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test34(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing constant null to a (flattened) inline type array\n+\n+    private static final MethodHandle setArrayElementNull = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementNull\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aconst_null().\n+            aastore().\n+            return_();\n+        });\n+\n+    @Test\n+    public void test35(MyValue1[] va, int index) throws Throwable {\n+        setArrayElementNull.invoke(this, va, index);\n+    }\n+\n+    @Run(test = \"test35\")\n+    @Warmup(10000)\n+    public void test35_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test35(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing an inline type to a null inline type array\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G})\n+    public void test36(MyValue1[] va, MyValue1 vt, int index) {\n+        va[index] = vt;\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test36(null, testValue1Array[index], index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test incremental inlining\n+    @ForceInline\n+    public void test37_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test37(MyValue1[] va, Object o, int index) {\n+        test37_inline(va, o, index);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test37(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test37(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    \/\/ Test merging of inline type arrays\n+\n+    @ForceInline\n+    public Object[] test38_inline() {\n+        return new MyValue1[42];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public Object[] test38(Object[] oa, Object o, int i1, int i2, int num) {\n+        Object[] result = null;\n+        switch (num) {\n+        case 0:\n+            result = test38_inline();\n+            break;\n+        case 1:\n+            result = oa;\n+            break;\n+        case 2:\n+            result = testValue1Array;\n+            break;\n+        case 3:\n+            result = testValue2Array;\n+            break;\n+        case 4:\n+            result = testIntegerArray;\n+            break;\n+        case 5:\n+            result = null;\n+            break;\n+        case 6:\n+            result = testValue1Array2;\n+            break;\n+        }\n+        result[i1] = result[i2];\n+        result[i2] = o;\n+        return result;\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1[] va = new MyValue1[42];\n+        Object[] result = test38(null, testValue1, index, index, 0);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(testValue1Array, testValue1, index, index, 1);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(null, testValue1, index, index, 2);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(null, testValue2, index, index, 3);\n+        Asserts.assertEQ(((MyValue2)result[index]).hash(), testValue2.hash());\n+        try {\n+            result = test38(null, null, index, index, 3);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test38(null, null, index, index, 4);\n+        try {\n+            result = test38(null, testValue1, index, index, 4);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            result = test38(null, testValue1, index, index, 5);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test38(null, testValue1Array, index, index, 6);\n+        Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test39_inline() {\n+        return new MyValue1[42];\n+    }\n+\n+    \/\/ Same as above but merging into Object instead of Object[]\n+    @Test\n+    public Object test39(Object oa, Object o, int i1, int i2, int num) {\n+        Object result = null;\n+        switch (num) {\n+        case 0:\n+            result = test39_inline();\n+            break;\n+        case 1:\n+            result = oa;\n+            break;\n+        case 2:\n+            result = testValue1Array;\n+            break;\n+        case 3:\n+            result = testValue2Array;\n+            break;\n+        case 4:\n+            result = testIntegerArray;\n+            break;\n+        case 5:\n+            result = null;\n+            break;\n+        case 6:\n+            result = testValue1;\n+            break;\n+        case 7:\n+            result = testValue2;\n+            break;\n+        case 8:\n+            result = MyValue1.createWithFieldsInline(rI, rL);\n+            break;\n+        case 9:\n+            result = Integer.valueOf(42);\n+            break;\n+        case 10:\n+            result = testValue1Array2;\n+            break;\n+        }\n+        if (result instanceof Object[]) {\n+            ((Object[])result)[i1] = ((Object[])result)[i2];\n+            ((Object[])result)[i2] = o;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1[] va = new MyValue1[42];\n+        Object result = test39(null, testValue1, index, index, 0);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(testValue1Array, testValue1, index, index, 1);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 2);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(null, testValue2, index, index, 3);\n+        Asserts.assertEQ(((MyValue2[])result)[index].hash(), testValue2.hash());\n+        try {\n+            result = test39(null, null, index, index, 3);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test39(null, null, index, index, 4);\n+        try {\n+            result = test39(null, testValue1, index, index, 4);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        result = test39(null, testValue1, index, index, 5);\n+        Asserts.assertEQ(result, null);\n+        result = test39(null, testValue1, index, index, 6);\n+        Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 7);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+        result = test39(null, testValue1, index, index, 8);\n+        Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 9);\n+        Asserts.assertEQ(((Integer)result), 42);\n+        result = test39(null, testValue1Array, index, index, 10);\n+        Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Test instanceof with inline types and arrays\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC_G})\n+    public long test40(Object o, int index) {\n+        if (o instanceof MyValue1) {\n+          return ((MyValue1)o).hashInterpreted();\n+        } else if (o instanceof MyValue1[]) {\n+          return ((MyValue1[])o)[index].hashInterpreted();\n+        } else if (o instanceof MyValue2) {\n+          return ((MyValue2)o).hash();\n+        } else if (o instanceof MyValue2[]) {\n+          return ((MyValue2[])o)[index].hash();\n+        } else if (o instanceof MyValue1[][]) {\n+          return ((MyValue1[][])o)[index][index].hash();\n+        } else if (o instanceof Long) {\n+          return (long)o;\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        long result = test40(testValue1, 0);\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n+        result = test40(testValue1Array, index);\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n+        result = test40(testValue2, index);\n+        Asserts.assertEQ(result, testValue2.hash());\n+        result = test40(testValue2Array, index);\n+        Asserts.assertEQ(result, testValue2.hash());\n+        result = test40(testValue1Array2, index);\n+        Asserts.assertEQ(result, testValue1.hash());\n+        result = test40(Long.valueOf(42), index);\n+        Asserts.assertEQ(result, 42L);\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    @DontInline\n+    public void test41_dontinline(Object o) {\n+        Asserts.assertEQ(o, rI);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test41() {\n+        MyValue1[] vals = new MyValue1[] {testValue1};\n+        test41_dontinline(vals[0].oa[0]);\n+        test41_dontinline(vals[0].oa[0]);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        test41();\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test42() {\n+        MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};\n+        Asserts.assertEQ(vals[0].hash(), test42VT1.hash());\n+        Asserts.assertEQ(vals[1].hash(), test42VT2.hash());\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        if (!info.isWarmUp()) test42(); \/\/ We need -Xcomp behavior\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test43(boolean deopt, Method m) {\n+        MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};\n+\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+            Asserts.assertEQ(vals[0].hash(), test42VT1.hash());\n+            Asserts.assertEQ(vals[1].hash(), test42VT2.hash());\n+        }\n+\n+        return vals[0].hash();\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        test43(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatible = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementIncompatible\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class.asValueType()),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aload_3().\n+            aastore().\n+            return_();\n+        });\n+\n+    @Test\n+    public void test44(MyValue1[] va, int index, MyValue2 v) throws Throwable {\n+        setArrayElementIncompatible.invoke(this, va, index, v);\n+    }\n+\n+    @Run(test = \"test44\")\n+    @Warmup(10000)\n+    public void test44_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test44(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    @ForceInline\n+    public void test45_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test45(MyValue1[] va, int index, MyValue2 v) throws Throwable {\n+        test45_inline(va, v, index);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test45(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ instanceof tests with inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test46(MyValue1 vt) {\n+        Object obj = vt;\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test46(vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test47(MyValue1 vt) {\n+        Object obj = vt;\n+        return obj instanceof MyValue2;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test47(vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test48(Object obj) {\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test48(vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test49(Object obj) {\n+        return obj instanceof MyValue2;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test49(vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test50(Object obj) {\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        boolean result = test49(Integer.valueOf(42));\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Inline type with some non-flattened fields\n+    final primitive class Test51Value {\n+        final Object objectField1;\n+        final Object objectField2;\n+        final Object objectField3;\n+        final Object objectField4;\n+        final Object objectField5;\n+        final Object objectField6;\n+\n+        final MyValue1 valueField1;\n+        final MyValue1 valueField2;\n+        final MyValue1.ref valueField3;\n+        final MyValue1 valueField4;\n+        final MyValue1.ref valueField5;\n+\n+        public Test51Value() {\n+            objectField1 = null;\n+            objectField2 = null;\n+            objectField3 = null;\n+            objectField4 = null;\n+            objectField5 = null;\n+            objectField6 = null;\n+            valueField1 = testValue1;\n+            valueField2 = testValue1;\n+            valueField3 = testValue1;\n+            valueField4 = MyValue1.createDefaultDontInline();\n+            valueField5 = MyValue1.createDefaultDontInline();\n+        }\n+\n+        public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,\n+                           MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {\n+            objectField1 = o1;\n+            objectField2 = o2;\n+            objectField3 = o3;\n+            objectField4 = o4;\n+            objectField5 = o5;\n+            objectField6 = o6;\n+            valueField1 = vt1;\n+            valueField2 = vt2;\n+            valueField3 = vt3;\n+            valueField4 = vt4;\n+            valueField5 = vt5;\n+        }\n+\n+        @ForceInline\n+        public long test(Test51Value holder, MyValue1 vt1, Object vt2) {\n+            holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, MyValue1.createWithFieldsDontInline(rI, rL), holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.valueField1, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.valueField3,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);\n+\n+            return ((MyValue1)holder.objectField1).hash() +\n+                   ((MyValue1)holder.objectField2).hash() +\n+                   ((MyValue1)holder.objectField3).hash() +\n+                   ((MyValue1)holder.objectField4).hash() +\n+                   ((MyValue1)holder.objectField5).hash() +\n+                   ((MyValue1)holder.objectField6).hash() +\n+                   holder.valueField1.hash() +\n+                   holder.valueField2.hash() +\n+                   holder.valueField3.hash() +\n+                   holder.valueField4.hashPrimitive();\n+        }\n+    }\n+\n+    \/\/ Same as test2 but with field holder being an inline type\n+    @Test\n+    public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {\n+        return holder.test(holder, vt1, vt2);\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        Test51Value holder = new Test51Value();\n+        Asserts.assertEQ(testValue1.hash(), vt.hash());\n+        Asserts.assertEQ(holder.valueField1.hash(), vt.hash());\n+        long result = test51(holder, vt, vt);\n+        Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());\n+    }\n+\n+    \/\/ Access non-flattened, uninitialized inline type field with inline type holder\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test52(Test51Value holder) {\n+        if ((Object)holder.valueField5 != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        Test51Value vt = Test51Value.default;\n+        test52(vt);\n+    }\n+\n+    \/\/ Merging inline types of different types\n+    @Test\n+    public Object test53(Object o, boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        return b ? vt : o;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        test53(new Object(), false);\n+        MyValue1 result = (MyValue1)test53(new Object(), true);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    @Test\n+    public Object test54(boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        return b ? vt : testValue2;\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        MyValue1 result1 = (MyValue1)test54(true);\n+        Asserts.assertEQ(result1.hash(), hash());\n+        MyValue2 result2 = (MyValue2)test54(false);\n+        Asserts.assertEQ(result2.hash(), testValue2.hash());\n+    }\n+\n+    @Test\n+    public Object test55(boolean b) {\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, rD);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        MyValue1 result1 = (MyValue1)test55(true);\n+        Asserts.assertEQ(result1.hash(), hash());\n+        MyValue2 result2 = (MyValue2)test55(false);\n+        Asserts.assertEQ(result2.hash(), testValue2.hash());\n+    }\n+\n+    \/\/ Test synchronization on inline types\n+    @Test\n+    public void test56(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test56 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        try {\n+            test56(testValue1);\n+            throw new RuntimeException(\"test56 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test57_inline(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test57 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test57(MyValue1 vt) {\n+        test57_inline(vt);\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        try {\n+            test57(testValue1);\n+            throw new RuntimeException(\"test57 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test58_inline(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test58 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test58() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test58_inline(vt);\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier() {\n+        try {\n+            test58();\n+            throw new RuntimeException(\"test58 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public void test59(Object o, boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object sync = b ? vt : o;\n+        synchronized (sync) {\n+            if (b) {\n+                throw new RuntimeException(\"test59 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() {\n+        test59(new Object(), false);\n+        try {\n+            test59(new Object(), true);\n+            throw new RuntimeException(\"test59 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public void test60(boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object sync = b ? vt : testValue2;\n+        synchronized (sync) {\n+            throw new RuntimeException(\"test60 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        try {\n+            test60(false);\n+            throw new RuntimeException(\"test60 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test60(true);\n+            throw new RuntimeException(\"test60 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test catching the IllegalMonitorStateException in compiled code\n+    @Test\n+    public void test61(Object vt) {\n+        boolean thrown = false;\n+        try {\n+            synchronized (vt) {\n+                throw new RuntimeException(\"test61 failed: no exception thrown\");\n+            }\n+        } catch (IllegalMonitorStateException ex) {\n+            thrown = true;\n+        }\n+        if (!thrown) {\n+            throw new RuntimeException(\"test61 failed: no exception thrown\");\n+        }\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        test61(testValue1);\n+    }\n+\n+    @Test\n+    public void test62(Object o) {\n+        try {\n+            synchronized (o) { }\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+            return;\n+        }\n+        throw new RuntimeException(\"test62 failed: no exception thrown\");\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        test62(testValue1);\n+    }\n+\n+    \/\/ Test synchronization without any instructions in the synchronized block\n+    @Test\n+    public void test63(Object o) {\n+        synchronized (o) { }\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        try {\n+            test63(testValue1);\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+            return;\n+        }\n+        throw new RuntimeException(\"test63 failed: no exception thrown\");\n+    }\n+\n+    \/\/ type system test with interface and inline type\n+    @ForceInline\n+    public MyInterface test64Interface_helper(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyInterface test64Interface(MyValue1 vt) {\n+        return test64Interface_helper(vt);\n+    }\n+\n+    @Run(test = \"test64Interface\")\n+    public void test64Interface_verifier() {\n+        test64Interface(testValue1);\n+    }\n+\n+    \/\/ type system test with abstract and inline type\n+    @ForceInline\n+    public MyAbstract test64Abstract_helper(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyAbstract test64Abstract(MyValue1 vt) {\n+        return test64Abstract_helper(vt);\n+    }\n+\n+    @Run(test = \"test64Abstract\")\n+    public void test64Abstract_verifier() {\n+        test64Abstract(testValue1);\n+    }\n+\n+    \/\/ Array store tests\n+    @Test\n+    public void test65(Object[] array, MyValue1 vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        Object[] array = new Object[1];\n+        test65(array, testValue1);\n+        Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test66(Object[] array, MyValue1 vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1[] array = new MyValue1[1];\n+        test66(array, testValue1);\n+        Asserts.assertEQ(array[0].hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test67(Object[] array, Object vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1[] array = new MyValue1[1];\n+        test67(array, testValue1);\n+        Asserts.assertEQ(array[0].hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test68(Object[] array, Integer o) {\n+        array[0] = o;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        Integer[] array = new Integer[1];\n+        test68(array, 1);\n+        Asserts.assertEQ(array[0], Integer.valueOf(1));\n+    }\n+\n+    \/\/ Test convertion between an inline type and java.lang.Object without an allocation\n+    @ForceInline\n+    public Object test69_sum(Object a, Object b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test69(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test69_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        int result = test69(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Same as test69 but with an Interface\n+    @ForceInline\n+    public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test70Interface(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test70Interface_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test70Interface\")\n+    public void test70Interface_verifier() {\n+        int result = test70Interface(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Same as test69 but with an Abstract\n+    @ForceInline\n+    public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test70Abstract(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test70Abstract_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test70Abstract\")\n+    public void test70Abstract_verifier() {\n+        int result = test70Abstract(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Test that allocated inline type is not used in non-dominated path\n+    public MyValue1 test71_inline(Object obj) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test71() {\n+        return test71_inline(null);\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        MyValue1 vt = test71();\n+        Asserts.assertEquals(vt.hash(), hash());\n+    }\n+\n+    \/\/ Test calling a method on an uninitialized inline type\n+    final primitive class Test72Value {\n+        final int x = 42;\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Make sure Test72Value is loaded but not initialized\n+    public void unused(Test72Value vt) { }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public int test72() {\n+        Test72Value vt = Test72Value.default;\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test72\")\n+    @Warmup(0)\n+    public void test72_verifier() {\n+        int result = test72();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Tests for loading\/storing unkown values\n+    @Test\n+    public Object test73(Object[] va) {\n+        return va[0];\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        MyValue1 vt = (MyValue1)test73(testValue1Array);\n+        Asserts.assertEquals(testValue1Array[0].hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public void test74(Object[] va, Object vt) {\n+        va[0] = vt;\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        test74(va, testValue1);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Verify that mixing instances and arrays with the clone api\n+    \/\/ doesn't break anything\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public Object test75(Object o) {\n+        MyValue1[] va = new MyValue1[1];\n+        Object[] next = va;\n+        Object[] arr = va;\n+        for (int i = 0; i < 10; i++) {\n+            arr = next;\n+            next = new Integer[1];\n+        }\n+        return arr[0];\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        test75(42);\n+    }\n+\n+    \/\/ Casting a null Integer to a (non-nullable) inline type should throw a NullPointerException\n+    @ForceInline\n+    public MyValue1 test76_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test76(Integer i) throws Throwable {\n+        return test76_helper(i);\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() throws Throwable {\n+        try {\n+            test76(null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test76 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting an Integer to a (non-nullable) inline type should throw a ClassCastException\n+    @ForceInline\n+    public MyValue1 test77_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test77(Integer i) throws Throwable {\n+        return test77_helper(i);\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() throws Throwable {\n+        try {\n+            test77(Integer.valueOf(42));\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test77 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting a null Integer to a nullable inline type should not throw\n+    @ForceInline\n+    public MyValue1.ref test78_helper(Object o) {\n+        return (MyValue1.ref)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test78(Integer i) throws Throwable {\n+        return test78_helper(i);\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() throws Throwable {\n+        try {\n+            test78(null); \/\/ Should not throw\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test78 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting an Integer to a nullable inline type should throw a ClassCastException\n+    @ForceInline\n+    public MyValue1.ref test79_helper(Object o) {\n+        return (MyValue1.ref)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test79(Integer i) throws Throwable {\n+        return test79_helper(i);\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() throws Throwable {\n+        try {\n+            test79(Integer.valueOf(42));\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test79 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Test flattened field with non-flattenend (but flattenable) inline type field\n+    static primitive class Small {\n+        final int i;\n+        final Big big; \/\/ Too big to be flattened\n+\n+        private Small() {\n+            i = rI;\n+            big = new Big();\n+        }\n+    }\n+\n+    static primitive class Big {\n+        long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9;\n+        long l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;\n+        long l20,l21,l22,l23,l24,l25,l26,l27,l28,l29;\n+\n+        private Big() {\n+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = rL;\n+            l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = rL+1;\n+            l20 = l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = rL+2;\n+        }\n+    }\n+\n+    Small small = new Small();\n+    Small smallDefault;\n+    Big big = new Big();\n+    Big bigDefault;\n+\n+    @Test\n+    public long test80() {\n+        return small.i + small.big.l0 + smallDefault.i + smallDefault.big.l29 + big.l0 + bigDefault.l29;\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() throws Throwable {\n+        long result = test80();\n+        Asserts.assertEQ(result, rI + 2*rL);\n+    }\n+\n+    \/\/ Test scalarization with exceptional control flow\n+    public int test81Callee(MyValue1 vt)  {\n+        return vt.x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public int test81()  {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        int result = 0;\n+        for (int i = 0; i < 10; i++) {\n+            try {\n+                result += test81Callee(vt);\n+            } catch (NullPointerException npe) {\n+                result += rI;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        int result = test81();\n+        Asserts.assertEQ(result, 10*rI);\n+    }\n+\n+    \/\/ Test check for null free array when storing to inline tpye array\n+    @Test\n+    public void test82(Object[] dst, Object v) {\n+        dst[0] = v;\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier(RunInfo info) {\n+        MyValue2[] dst = new MyValue2[1];\n+        test82(dst, testValue2);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test82(dst, null);\n+                throw new RuntimeException(\"No ArrayStoreException thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test83(Object[] dst, Object v, boolean flag) {\n+        if (dst == null) { \/\/ null check\n+        }\n+        if (flag) {\n+            if (dst.getClass() == MyValue1[].class) { \/\/ trigger split if\n+            }\n+        } else {\n+            dst = new MyValue2[1]; \/\/ constant null free property\n+        }\n+        dst[0] = v;\n+    }\n+\n+    @Run(test = \"test83\")\n+    @Warmup(10000)\n+    public void test83_verifier(RunInfo info) {\n+        MyValue2[] dst = new MyValue2[1];\n+        test83(dst, testValue2, false);\n+        test83(dst, testValue2, true);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test83(dst, null, true);\n+                throw new RuntimeException(\"No ArrayStoreException thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    private void rerun_and_recompile_for(Method m, int num, Runnable test) {\n+        for (int i = 1; i < num; i++) {\n+            test.run();\n+\n+            if (!TestFramework.isCompiled(m)) {\n+                TestFramework.compile(m, CompLevel.C2);\n+            }\n+        }\n+    }\n+\n+    \/\/ Tests for the Loop Unswitching optimization\n+    \/\/ Should make 2 copies of the loop, one for non flattened arrays, one for other cases.\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 1\"})\n+    public void test84(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test84\")\n+    @Warmup(0)\n+    public void test84_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[100];\n+        Arrays.fill(src, testValue2);\n+        MyValue2[] dst = new MyValue2[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () ->  { test84(src, dst);\n+                                         Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 4\"})\n+    public void test85(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test85\")\n+    @Warmup(0)\n+    public void test85_verifier(RunInfo info) {\n+        Object[] src = new Object[100];\n+        Arrays.fill(src, new Object());\n+        src[0] = null;\n+        Object[] dst = new Object[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test85(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP, \"= 2\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    public void test86(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test86\")\n+    @Warmup(0)\n+    public void test86_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[100];\n+        Arrays.fill(src, testValue2);\n+        Object[] dst = new Object[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test86(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 1\"})\n+    public void test87(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test87\")\n+    @Warmup(0)\n+    public void test87_verifier(RunInfo info) {\n+        Object[] src = new Object[100];\n+        Arrays.fill(src, testValue2);\n+        MyValue2[] dst = new MyValue2[100];\n+\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test87(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 0\"})\n+    public void test88(Object[] src1, Object[] dst1, Object[] src2, Object[] dst2) {\n+        for (int i = 0; i < src1.length; i++) {\n+            dst1[i] = src1[i];\n+            dst2[i] = src2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test88\")\n+    @Warmup(0)\n+    public void test88_verifier(RunInfo info) {\n+        MyValue2[] src1 = new MyValue2[100];\n+        Arrays.fill(src1, testValue2);\n+        MyValue2[] dst1 = new MyValue2[100];\n+        Object[] src2 = new Object[100];\n+        Arrays.fill(src2, new Object());\n+        Object[] dst2 = new Object[100];\n+\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test88(src1, dst1, src2, dst2);\n+                                        Asserts.assertTrue(Arrays.equals(src1, dst1));\n+                                        Asserts.assertTrue(Arrays.equals(src2, dst2)); });\n+    }\n+\n+    @Test\n+    public boolean test89(Object obj) {\n+        return obj.getClass() == Integer.class;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        Asserts.assertTrue(test89(Integer.valueOf(42)));\n+        Asserts.assertFalse(test89(new Object()));\n+    }\n+\n+    @Test\n+    public Integer test90(Object obj) {\n+        return (Integer)obj;\n+    }\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier() {\n+        test90(Integer.valueOf(42));\n+        try {\n+            test90(new Object());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public boolean test91(Object obj) {\n+        return obj.getClass() == MyValue2[].class;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        Asserts.assertTrue(test91(new MyValue2[1]));\n+        Asserts.assertFalse(test91(new MyValue2.ref[1]));\n+        Asserts.assertFalse(test91(new Object()));\n+    }\n+\n+    static primitive class Test92Value {\n+        final int field;\n+        public Test92Value() {\n+            field = 0x42;\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, ALLOC_G, MEMBAR})\n+    public Object test92(Object[] array) {\n+        \/\/ Dummy loops to ensure we run enough passes of split if\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+              for (int k = 0; k < 2; k++) {\n+              }\n+            }\n+        }\n+\n+        return (Integer)array[0];\n+    }\n+\n+    @Run(test = \"test92\")\n+    @Warmup(10000)\n+    public void test92_verifier() {\n+        Object[] array = new Object[1];\n+        array[0] = 0x42;\n+        Object result = test92(array);\n+        Asserts.assertEquals(result, 0x42);\n+    }\n+\n+    \/\/ If the class check succeeds, the flattened array check that\n+    \/\/ precedes will never succeed and the flat array branch should\n+    \/\/ trigger an uncommon trap.\n+    @Test\n+    public Object test93(Object[] array) {\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+            }\n+        }\n+\n+        Object v = (Integer)array[0];\n+        return v;\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object[] array = new Object[1];\n+            array[0] = 0x42;\n+            Object result = test93(array);\n+            Asserts.assertEquals(result, 0x42);\n+        } else {\n+            Object[] array = new Test92Value[1];\n+            Method m = info.getTest();\n+            int extra = 3;\n+            for (int j = 0; j < extra; j++) {\n+                for (int i = 0; i < 10; i++) {\n+                    try {\n+                        test93(array);\n+                    } catch (ClassCastException cce) {\n+                    }\n+                }\n+                boolean compiled = TestFramework.isCompiled(m);\n+                boolean compilationSkipped = info.isCompilationSkipped();\n+                Asserts.assertTrue(compilationSkipped || compiled || (j != extra-1));\n+                if (!compilationSkipped && !compiled) {\n+                    TestFramework.compile(m, CompLevel.ANY);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\", LOOP, \"= 1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, ALLOC_G, MEMBAR})\n+    public int test94(Object[] array) {\n+        int res = 0;\n+        for (int i = 1; i < 4; i *= 2) {\n+            Object v = array[i];\n+            res += (Integer)v;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test94\")\n+    @Warmup(10000)\n+    public void test94_verifier() {\n+        Object[] array = new Object[4];\n+        array[0] = 0x42;\n+        array[1] = 0x42;\n+        array[2] = 0x42;\n+        array[3] = 0x42;\n+        int result = test94(array);\n+        Asserts.assertEquals(result, 0x42 * 2);\n+    }\n+\n+    @Test\n+    public boolean test95(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test95\")\n+    @Warmup(10000)\n+    public void test95_verifier() {\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        Asserts.assertTrue(test95(o1, o1));\n+        Asserts.assertTrue(test95(null, null));\n+        Asserts.assertFalse(test95(o1, null));\n+        Asserts.assertFalse(test95(o1, o2));\n+    }\n+\n+    @Test\n+    public boolean test96(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test96\")\n+    @Warmup(10000)\n+    public void test96_verifier(RunInfo info) {\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        Asserts.assertTrue(test96(o1, o1));\n+        Asserts.assertFalse(test96(o1, o2));\n+        if (!info.isWarmUp()) {\n+            Asserts.assertTrue(test96(null, null));\n+            Asserts.assertFalse(test96(o1, null));\n+        }\n+    }\n+\n+    \/\/ Abstract class tests\n+\n+    @DontInline\n+    public MyAbstract test97_dontinline1(MyAbstract o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test97_dontinline2(MyAbstract o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public MyAbstract test97_inline1(MyAbstract o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test97_inline2(MyAbstract o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    public MyValue1 test97() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        vt = (MyValue1)test97_dontinline1(vt);\n+        vt =           test97_dontinline2(vt);\n+        vt = (MyValue1)test97_inline1(vt);\n+        vt =           test97_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        Asserts.assertEQ(test97().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from abstract and inline type fields\n+    MyAbstract abstractField1 = null;\n+    MyAbstract abstractField2 = null;\n+    MyAbstract abstractField3 = null;\n+    MyAbstract abstractField4 = null;\n+    MyAbstract abstractField5 = null;\n+    MyAbstract abstractField6 = null;\n+\n+    @DontInline\n+    public MyAbstract readValueField5AsAbstract() {\n+        return (MyAbstract)valueField5;\n+    }\n+\n+    @DontInline\n+    public MyAbstract readStaticValueField4AsAbstract() {\n+        return (MyAbstract)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test98(MyValue1 vt1, MyAbstract vt2) {\n+        abstractField1 = vt1;\n+        abstractField2 = (MyValue1)vt2;\n+        abstractField3 = MyValue1.createWithFieldsInline(rI, rL);\n+        abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        abstractField5 = valueField1;\n+        abstractField6 = valueField3;\n+        valueField1 = (MyValue1)abstractField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)abstractField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +\n+               ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +\n+               ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void test98_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test98(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    class MyObject2 extends MyAbstract {\n+        public int x;\n+\n+        public MyObject2(int x) {\n+            this.x = x;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Test merging inline types and abstract classes\n+    @Test\n+    public MyAbstract test99(int state) {\n+        MyAbstract res = null;\n+        if (state == 0) {\n+            res = new MyObject2(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void test99_verifier() {\n+        objectField1 = valueField1;\n+        MyAbstract result = null;\n+        result = test99(0);\n+        Asserts.assertEQ(((MyObject2)result).x, rI);\n+        result = test99(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(5);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ Test merging inline types and abstract classes in loops\n+    @Test\n+    public MyAbstract test100(int iters) {\n+        MyAbstract res = new MyObject2(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof MyObject2) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier() {\n+        MyObject2 result1 = (MyObject2)test100(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test100(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in abstract class variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP})\n+    public long test101(MyValue1 arg, boolean deopt, Method m) {\n+        MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyAbstract vt3 = arg;\n+        MyAbstract vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier(RunInfo info) {\n+        long result = test101(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with abstract classes\n+    @Test\n+    public boolean test102(Object arg) {\n+        MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||\n+            arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier() {\n+        boolean result = test102(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ An abstract class with a non-static field can never be implemented by an inline type\n+    abstract class NoValueImplementors1 {\n+        int field = 42;\n+    }\n+\n+    class MyObject3 extends NoValueImplementors1 {\n+\n+    }\n+\n+    class MyObject4 extends NoValueImplementors1 {\n+\n+    }\n+\n+    \/\/ Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test103\")\n+    public void test103_verifier() {\n+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];\n+        MyObject3[] array2 = new MyObject3[3];\n+        MyObject4[] array3 = new MyObject4[3];\n+        NoValueImplementors1 result = test103(array1, 0);\n+        Asserts.assertEquals(result, array1[0]);\n+\n+        result = test103(array2, 1);\n+        Asserts.assertEquals(result, array1[1]);\n+\n+        result = test103(array3, 2);\n+        Asserts.assertEquals(result, array1[2]);\n+    }\n+\n+    \/\/ Storing to an abstract class array does not require a flatness\/null check if the abstract class has a non-static field\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test104\")\n+    public void test104_verifier() {\n+        MyObject4 v = new MyObject4();\n+        MyObject3 o = new MyObject3();\n+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];\n+        MyObject3[] array2 = new MyObject3[3];\n+        MyObject4[] array3 = new MyObject4[3];\n+        NoValueImplementors1 result = test104(array1, v, o, 0);\n+        Asserts.assertEquals(array1[0], v);\n+        Asserts.assertEquals(array1[1], v);\n+        Asserts.assertEquals(array1[2], o);\n+        Asserts.assertEquals(result, v);\n+\n+        result = test104(array2, o, o, 1);\n+        Asserts.assertEquals(array2[0], o);\n+        Asserts.assertEquals(array2[1], o);\n+        Asserts.assertEquals(array2[2], o);\n+        Asserts.assertEquals(result, o);\n+\n+        result = test104(array3, v, null, 1);\n+        Asserts.assertEquals(array3[0], v);\n+        Asserts.assertEquals(array3[1], v);\n+        Asserts.assertEquals(array3[2], null);\n+        Asserts.assertEquals(result, v);\n+    }\n+\n+    \/\/ An abstract class with a single, non-inline implementor\n+    abstract class NoValueImplementors2 {\n+\n+    }\n+\n+    class MyObject5 extends NoValueImplementors2 {\n+\n+    }\n+\n+    \/\/ Loading from an abstract class array does not require a flatness check if the abstract class has no inline implementor\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier() {\n+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];\n+        MyObject5[] array2 = new MyObject5[3];\n+        NoValueImplementors2 result = test105(array1, 0);\n+        Asserts.assertEquals(result, array1[0]);\n+\n+        result = test105(array2, 1);\n+        Asserts.assertEquals(result, array1[1]);\n+    }\n+\n+    \/\/ Storing to an abstract class array does not require a flatness\/null check if the abstract class has no inline implementor\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier() {\n+        MyObject5 v = new MyObject5();\n+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];\n+        MyObject5[] array2 = new MyObject5[3];\n+        NoValueImplementors2 result = test106(array1, v, null, 0);\n+        Asserts.assertEquals(array1[0], v);\n+        Asserts.assertEquals(array1[1], v);\n+        Asserts.assertEquals(array1[2], null);\n+        Asserts.assertEquals(result, v);\n+\n+        result = test106(array2, v, v, 1);\n+        Asserts.assertEquals(array2[0], v);\n+        Asserts.assertEquals(array2[1], v);\n+        Asserts.assertEquals(array2[2], v);\n+        Asserts.assertEquals(result, v);\n+    }\n+\n+    \/\/ More tests for the Loop Unswitching optimization (similar to test84 and following)\n+    Object oFld1, oFld2;\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 2\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 3\", LOAD_UNKNOWN_INLINE, \"= 2\"})\n+    public void test107(Object[] src1, Object[] src2) {\n+        for (int i = 0; i < src1.length; i++) {\n+            oFld1 = src1[i];\n+            oFld2 = src2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test107\")\n+    @Warmup(0)\n+    public void test107_verifier(RunInfo info) {\n+        MyValue2[] src1 = new MyValue2[100];\n+        Arrays.fill(src1, testValue2);\n+        Object[] src2 = new Object[100];\n+        Object obj = new Object();\n+        Arrays.fill(src2, obj);\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test107(src1, src2);\n+                                        Asserts.assertEquals(oFld1, testValue2);\n+                                        Asserts.assertEquals(oFld2, obj);\n+                                        test107(src2, src1);\n+                                        Asserts.assertEquals(oFld1, obj);\n+                                        Asserts.assertEquals(oFld2, testValue2);  });\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 9\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 12\"})\n+    public void test108(Object[] dst1, Object[] dst2, Object o1, Object o2) {\n+        for (int i = 0; i < dst1.length; i++) {\n+            dst1[i] = o1;\n+            dst2[i] = o2;\n+        }\n+    }\n+\n+    @Run(test = \"test108\")\n+    @Warmup(0)\n+    public void test108_verifier(RunInfo info) {\n+        MyValue2[] dst1 = new MyValue2[100];\n+        Object[] dst2 = new Object[100];\n+        Object o1 = new Object();\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test108(dst1, dst2, testValue2, o1);\n+                                        for (int i = 0; i < dst1.length; i++) {\n+                                            Asserts.assertEquals(dst1[i], testValue2);\n+                                            Asserts.assertEquals(dst2[i], o1);\n+                                        }\n+                                        test108(dst2, dst1, o1, testValue2);\n+                                        for (int i = 0; i < dst1.length; i++) {\n+                                            Asserts.assertEquals(dst1[i], testValue2);\n+                                            Asserts.assertEquals(dst2[i], o1);\n+                                        } });\n+    }\n+\n+    \/\/ Escape analysis tests\n+\n+    static interface WrapperInterface {\n+        long value();\n+\n+        final static WrapperInterface ZERO = new LongWrapper(0);\n+\n+        @ForceInline\n+        static WrapperInterface wrap(long val) {\n+            return (val == 0L) ? ZERO : new LongWrapper(val);\n+        }\n+    }\n+\n+    @ForceCompileClassInitializer\n+    static primitive class LongWrapper implements WrapperInterface {\n+        final static LongWrapper ZERO = new LongWrapper(0);\n+        private long val;\n+\n+        @ForceInline\n+        LongWrapper(long val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        static LongWrapper wrap(long val) {\n+            return (val == 0L) ? ZERO : new LongWrapper(val);\n+        }\n+\n+        @ForceInline\n+        public long value() {\n+            return val;\n+        }\n+    }\n+\n+    static class InterfaceBox {\n+        WrapperInterface content;\n+\n+        @ForceInline\n+        InterfaceBox(WrapperInterface content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox box_sharp(long val) {\n+            return new InterfaceBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox box(long val) {\n+            return new InterfaceBox(WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class ObjectBox {\n+        Object content;\n+\n+        @ForceInline\n+        ObjectBox(Object content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static ObjectBox box_sharp(long val) {\n+            return new ObjectBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static ObjectBox box(long val) {\n+            return new ObjectBox(WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class RefBox {\n+        LongWrapper.ref content;\n+\n+        @ForceInline\n+        RefBox(LongWrapper.ref content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static RefBox box_sharp(long val) {\n+            return new RefBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static RefBox box(long val) {\n+            return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class InlineBox {\n+        LongWrapper content;\n+\n+        @ForceInline\n+        InlineBox(long val) {\n+            this.content = LongWrapper.wrap(val);\n+        }\n+\n+        @ForceInline\n+        static InlineBox box(long val) {\n+            return new InlineBox(val);\n+        }\n+    }\n+\n+    static class GenericBox<T> {\n+        T content;\n+\n+        @ForceInline\n+        static GenericBox<LongWrapper.ref> box_sharp(long val) {\n+            GenericBox<LongWrapper.ref> res = new GenericBox<>();\n+            res.content = LongWrapper.wrap(val);\n+            return res;\n+        }\n+\n+        @ForceInline\n+        static GenericBox<WrapperInterface> box(long val) {\n+            GenericBox<WrapperInterface> res = new GenericBox<>();\n+            res.content = WrapperInterface.wrap(val);\n+            return res;\n+        }\n+    }\n+\n+    long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};\n+\n+    \/\/ Test removal of allocations when inline type instance is wrapped into box object\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test109() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test109\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test109_verifier() {\n+        long res = test109();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+\/\/ TODO Tobias\n+\/\/    @IR(failOn = {ALLOC_G, MEMBAR},\n+\/\/        counts = {PREDICATE_TRAP, \"= 1\"})\n+    @IR(failOn = {ALLOC_G, MEMBAR})\n+    public long test109_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test109_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test109_sharp_verifier() {\n+        long res = test109_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with ObjectBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test110() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test110\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test110_verifier() {\n+        long res = test110();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+\/\/ TODO Tobias\n+\/\/    @IR(failOn = {ALLOC_G, MEMBAR},\n+\/\/        counts = {PREDICATE_TRAP, \"= 1\"})\n+    @IR(failOn = {ALLOC_G, MEMBAR})\n+    public long test110_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test110_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test110_sharp_verifier() {\n+        long res = test110_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with RefBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test111() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += RefBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        long res = test111();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test111_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += RefBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test111_sharp\")\n+    public void test111_sharp_verifier() {\n+        long res = test111_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with InlineBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test112() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InlineBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier() {\n+        long res = test112();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with GenericBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test113() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += GenericBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test113\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test113_verifier() {\n+        long res = test113();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test113_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += GenericBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test113_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test113_sharp_verifier() {\n+        long res = test113_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    static interface WrapperInterface2 {\n+        public long value();\n+\n+        static final InlineWrapper.ref ZERO = new InlineWrapper(0);\n+\n+        @ForceInline\n+        public static WrapperInterface2 wrap(long val) {\n+            return (val == 0) ? ZERO.content : new LongWrapper2(val);\n+        }\n+\n+        @ForceInline\n+        public static WrapperInterface2 wrap_default(long val) {\n+            return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);\n+        }\n+    }\n+\n+    static primitive class LongWrapper2 implements WrapperInterface2 {\n+        private long val;\n+\n+        @ForceInline\n+        public LongWrapper2(long val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        public long value() {\n+            return val;\n+        }\n+    }\n+\n+    static primitive class InlineWrapper {\n+        WrapperInterface2 content;\n+\n+        @ForceInline\n+        public InlineWrapper(long val) {\n+            content = new LongWrapper2(val);\n+        }\n+    }\n+\n+    static class InterfaceBox2 {\n+        WrapperInterface2 content;\n+\n+        @ForceInline\n+        public InterfaceBox2(long val, boolean def) {\n+            this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox2 box(long val) {\n+            return new InterfaceBox2(val, false);\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox2 box_default(long val) {\n+            return new InterfaceBox2(val, true);\n+        }\n+    }\n+\n+    \/\/ Same as tests above but with ZERO hidden in field of another inline type\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test114() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox2.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test114\")\n+    @Warmup(10000)\n+    public void test114_verifier() {\n+        long res = test114();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test114 but with .default instead of ZERO field\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test115() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox2.box_default(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test115\")\n+    @Warmup(10000)\n+    public void test115_verifier() {\n+        long res = test115();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    static MyValueEmpty     fEmpty1;\n+    static MyValueEmpty.ref fEmpty2 = MyValueEmpty.default;\n+           MyValueEmpty     fEmpty3;\n+           MyValueEmpty.ref fEmpty4 = MyValueEmpty.default;\n+\n+    \/\/ Test fields loads\/stores with empty inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G, TRAP})\n+    public void test116() {\n+        fEmpty1 = fEmpty4;\n+        fEmpty2 = fEmpty1;\n+        fEmpty3 = fEmpty2;\n+        fEmpty4 = fEmpty3;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier() {\n+        test116();\n+        Asserts.assertEquals(fEmpty1, fEmpty2);\n+        Asserts.assertEquals(fEmpty2, fEmpty3);\n+        Asserts.assertEquals(fEmpty3, fEmpty4);\n+    }\n+\n+    \/\/ Test array loads\/stores with empty inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty.ref[] arr2) {\n+        arr1[0] = arr2[0];\n+        arr2[0] = new MyValueEmpty();\n+        return arr1[0];\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        MyValueEmpty[] arr1 = new MyValueEmpty[]{MyValueEmpty.default};\n+        MyValueEmpty res = test117(arr1, arr1);\n+        Asserts.assertEquals(res, MyValueEmpty.default);\n+        Asserts.assertEquals(arr1[0], MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test acmp with empty inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test118(MyValueEmpty v1, MyValueEmpty.ref v2, Object o1) {\n+        return (v1 == v2) && (v2 == o1);\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        boolean res = test118(MyValueEmpty.default, MyValueEmpty.default, new MyValueEmpty());\n+        Asserts.assertTrue(res);\n+    }\n+\n+    static primitive class EmptyContainer {\n+        private MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    static primitive class MixedContainer {\n+        public int val = rI;\n+        private EmptyContainer empty = EmptyContainer.default;\n+    }\n+\n+    \/\/ Test re-allocation of empty inline type array during deoptimization\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test119(boolean deopt, Method m) {\n+        MyValueEmpty[]   array1 = new MyValueEmpty[]{MyValueEmpty.default};\n+        EmptyContainer[] array2 = new EmptyContainer[]{EmptyContainer.default};\n+        MixedContainer[] array3 = new MixedContainer[]{MixedContainer.default};\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        Asserts.assertEquals(array1[0], MyValueEmpty.default);\n+        Asserts.assertEquals(array2[0], EmptyContainer.default);\n+        Asserts.assertEquals(array3[0], MixedContainer.default);\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier(RunInfo info) {\n+        test119(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    \/\/ Test removal of empty inline type field stores\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    public void test120(MyValueEmpty empty) {\n+        fEmpty1 = empty;\n+        fEmpty3 = empty;\n+        \/\/ fEmpty2 and fEmpty4 could be null, store can't be removed\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        test120(MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty1, MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty2, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test removal of empty inline type field loads\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    public boolean test121() {\n+        return fEmpty1.equals(fEmpty3);\n+        \/\/ fEmpty2 and fEmpty4 could be null, load can't be removed\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        boolean res = test121();\n+        Asserts.assertTrue(res);\n+    }\n+\n+    \/\/ Verify that empty inline type field loads check for null holder\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValueEmpty test122(TestLWorld t) {\n+        return t.fEmpty3;\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        MyValueEmpty res = test122(this);\n+        Asserts.assertEquals(res, MyValueEmpty.default);\n+        try {\n+            test122(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Verify that empty inline type field stores check for null holder\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test123(TestLWorld t) {\n+        t.fEmpty3 = MyValueEmpty.default;\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier() {\n+        test123(this);\n+        Asserts.assertEquals(fEmpty3, MyValueEmpty.default);\n+        try {\n+            test123(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ acmp doesn't need substitutability test when one input is known\n+    \/\/ not to be a value type\n+    @Test\n+    @IR(failOn = SUBSTITUTABILITY_TEST)\n+    public boolean test124(Integer o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier() {\n+        test124(42, 42);\n+        test124(42, testValue1);\n+    }\n+\n+    \/\/ acmp doesn't need substitutability test when one input null\n+    @Test\n+    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    public boolean test125(Object o1) {\n+        Object o2 = null;\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test125\")\n+    public void test125_verifier() {\n+        test125(testValue1);\n+        test125(null);\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after loop opts\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test126(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test126\")\n+    @Warmup(10000)\n+    public void test126_verifier(RunInfo info) {\n+        long res = test126(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test126(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test126 but with interface type\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test127(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test127\")\n+    @Warmup(10000)\n+    public void test127_verifier(RunInfo info) {\n+        long res = test127(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test127(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after CCP\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test128(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test128\")\n+    @Warmup(10000)\n+    public void test128_verifier(RunInfo info) {\n+        long res = test128(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test128(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test128 but with interface type\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test129(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 0; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test129\")\n+    @Warmup(10000)\n+    public void test129_verifier(RunInfo info) {\n+        long res = test129(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test129(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Lock on inline type (known after inlining)\n+    @ForceInline\n+    public Object test130_inlinee() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD},\n+        \/\/ LockNode keeps MyValue1 allocation alive up until macro expansion which in turn keeps MyValue2\n+        \/\/ alloc alive. Although the MyValue1 allocation is removed (unused), MyValue2 is expanded first\n+        \/\/ and therefore stays.\n+        counts = {ALLOC, \"<= 1\", STORE, \"<= 1\"})\n+    public void test130() {\n+        Object obj = test130_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test130 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test130\")\n+    public void test130_verifier() {\n+        try {\n+            test130();\n+            throw new RuntimeException(\"test130 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test130 but with field load instead of allocation\n+    @ForceInline\n+    public Object test131_inlinee() {\n+        return testValue1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test131() {\n+        Object obj = test131_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test131 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test131\")\n+    public void test131_verifier() {\n+        try {\n+            test131();\n+            throw new RuntimeException(\"test131 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test locking on object that is known to be an inline type only after CCP\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public void test132() {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        Object obj = Integer.valueOf(42);\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            obj = vt;\n+        }\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test132 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test132\")\n+    @Warmup(10000)\n+    public void test132_verifier() {\n+        try {\n+            test132();\n+            throw new RuntimeException(\"test132 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test conditional locking on inline type and non-escaping object\n+    @Test\n+    public void test133(boolean b) {\n+        Object obj = b ? Integer.valueOf(42) : MyValue2.createWithFieldsInline(rI, rD);\n+        synchronized (obj) {\n+            if (!b) {\n+                throw new RuntimeException(\"test133 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test133\")\n+    public void test133_verifier() {\n+        test133(true);\n+        try {\n+            test133(false);\n+            throw new RuntimeException(\"test133 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Variant with non-scalarized inline type\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public static void test134(boolean b) {\n+        Object obj = null;\n+        if (b) {\n+            obj = MyValue2.createWithFieldsInline(rI, rD);\n+        }\n+        synchronized (obj) {\n+\n+        }\n+    }\n+\n+    @Run(test = \"test134\")\n+    public void test134_verifier() {\n+        try {\n+            test134(true);\n+            throw new RuntimeException(\"test134 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test that acmp of the same inline object is removed\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test135() {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        return val == val;\n+    }\n+\n+    @Run(test = \"test135\")\n+    public void test135_verifier() {\n+        Asserts.assertTrue(test135());\n+    }\n+\n+    \/\/ Same as test135 but with .ref\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test136(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val == val;\n+    }\n+\n+    @Run(test = \"test136\")\n+    public void test136_verifier() {\n+        Asserts.assertTrue(test136(false));\n+        Asserts.assertTrue(test136(true));\n+    }\n+\n+    \/\/ Test that acmp of different inline objects with same content is removed\n+    @Test\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test137(int i) {\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(i, rD);\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test137\")\n+    public void test137_verifier() {\n+        Asserts.assertTrue(test137(rI));\n+    }\n+\n+    \/\/ Same as test137 but with .ref\n+    @Test\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test138(int i, boolean b) {\n+        MyValue2.ref val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2.ref val2 = MyValue2.createWithFieldsInline(i, rD);\n+        if (b) {\n+            val1 = null;\n+            val2 = null;\n+        }\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test138\")\n+    public void test138_verifier() {\n+        Asserts.assertTrue(test138(rI, false));\n+        Asserts.assertTrue(test138(rI, true));\n+    }\n+\n+    static primitive class Test139Value {\n+        Object obj = null;\n+        MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    static primitive class Test139Wrapper {\n+        Test139Value value = Test139Value.default;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public MyValueEmpty test139() {\n+        Test139Wrapper w = new Test139Wrapper();\n+        return w.value.empty;\n+    }\n+\n+    @Run(test = \"test139\")\n+    public void test139_verifier() {\n+        MyValueEmpty empty = test139();\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test calling a method on a loaded but not linked inline type\n+    final primitive class Test140Value {\n+        final int x = 42;\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public int test140() {\n+        Test140Value vt = Test140Value.default;\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test140\")\n+    @Warmup(0)\n+    public void test140_verifier() {\n+        int result = test140();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Test calling a method on a linked but not initialized inline type\n+    final primitive class Test141Value {\n+        final int x = 42;\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public int test141() {\n+        Test141Value vt = Test141Value.default;\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test141\")\n+    @Warmup(0)\n+    public void test141_verifier() {\n+        int result = test141();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Test that virtual calls on inline type receivers are properly inlined\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test142() {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test142\")\n+    public void test142_verifier() {\n+        long res = test142();\n+        Asserts.assertEquals(res, testValue2.hash());\n+    }\n+\n+    public int intField;\n+\n+    private static final MethodHandle withfieldWithInvalidHolder = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"withfieldWithInvalidHolder\",\n+        MethodType.methodType(void.class, TestLWorld.class, int.class),\n+        CODE -> {\n+            CODE.\n+            aload_0().\n+            iload_1().\n+            withfield(TestLWorld.class, \"intField\", \"I\").\n+            return_();\n+        });\n+\n+    \/\/ Test withfield on identity class\n+    @Test\n+    public void test143() throws Throwable {\n+        withfieldWithInvalidHolder.invoke(this, 0);\n+    }\n+\n+    @Run(test = \"test143\")\n+    @Warmup(10000)\n+    public void test143_verifier() throws Throwable {\n+        try {\n+            test143();\n+            throw new RuntimeException(\"IncompatibleClassChangeError expected\");\n+        } catch (IncompatibleClassChangeError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test merging of buffered default and non-default inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public Object test144(int i) {\n+        if (i == 0) {\n+            return MyValue1.default;\n+        } else if (i == 1) {\n+            return testValue1;\n+        } else {\n+            return MyValue1.default;\n+        }\n+    }\n+\n+    @Run(test = \"test144\")\n+    public void test144_verifier() {\n+        Asserts.assertEquals(test144(0), MyValue1.default);\n+        Asserts.assertEquals(test144(1), testValue1);\n+        Asserts.assertEquals(test144(2), MyValue1.default);\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatibleRef = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementIncompatibleRef\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class.asPrimaryType()),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aload_3().\n+            aastore().\n+            return_();\n+        });\n+\n+    \/\/ Same as test44 but with .ref store to array\n+    @Test\n+    public void test145(MyValue1[] va, int index, MyValue2.ref v) throws Throwable {\n+        setArrayElementIncompatibleRef.invoke(this, va, index, v);\n+    }\n+\n+    @Run(test = \"test145\")\n+    @Warmup(10000)\n+    public void test145_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test145(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test inline type connected to result node\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test146(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    @Run(test = \"test146\")\n+    @Warmup(10000)\n+    public void test146_verifier() {\n+        Asserts.assertEQ(test146(testValue1), testValue1);\n+    }\n+\n+    \/\/ Same as test146 but with .ref cast\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test147(Object obj) {\n+        return (MyValue1.ref)obj;\n+    }\n+\n+    @Run(test = \"test147\")\n+    @Warmup(10000)\n+    public void test147_verifier() {\n+        Asserts.assertEQ(test147(testValue1), testValue1);\n+        Asserts.assertEQ(test147(null), null);\n+    }\n+\n+    @ForceInline\n+    public Object test148_helper(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    \/\/ Same as test146 but with helper method\n+    @Test\n+    public Object test148(Object obj) {\n+        return test148_helper(obj);\n+    }\n+\n+    @Run(test = \"test148\")\n+    @Warmup(10000)\n+    public void test148_verifier() {\n+        Asserts.assertEQ(test148(testValue1), testValue1);\n+    }\n+\n+    @ForceInline\n+    public Object test149_helper(Object obj) {\n+        return (MyValue1.ref)obj;\n+    }\n+\n+    \/\/ Same as test147 but with helper method\n+    @Test\n+    public Object test149(Object obj) {\n+        return test149_helper(obj);\n+    }\n+\n+    @Run(test = \"test149\")\n+    @Warmup(10000)\n+    public void test149_verifier() {\n+        Asserts.assertEQ(test149(testValue1), testValue1);\n+        Asserts.assertEQ(test149(null), null);\n+    }\n+\n+    \/\/ Test post-parse call devirtualization with inline type receiver\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test150() {\n+        MyValue2 val = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test150\")\n+    public void test150_verifier() {\n+        Asserts.assertEquals(test150(), testValue2.hash());\n+    }\n+\n+    \/\/ Same as test150 but with val not being allocated in the scope of the method\n+    @Test\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test151(MyValue2 val) {\n+        MyAbstract receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 100; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test151\")\n+    @Warmup(0) \/\/ Make sure there is no receiver type profile\n+    public void test151_verifier() {\n+        Asserts.assertEquals(test151(testValue2), testValue2.hash());\n+    }\n+\n+    static interface MyInterface2 {\n+        public int val();\n+    }\n+\n+    static abstract class MyAbstract2 implements MyInterface2 {\n+\n+    }\n+\n+    static class MyClass152 extends MyAbstract2 {\n+        private int val;\n+\n+        @ForceInline\n+        public MyClass152(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public int val() {\n+            return val;\n+        }\n+    }\n+\n+    static primitive class MyValue152 extends MyAbstract2 {\n+        private int unused = 0; \/\/ Make sure sub-offset of val is field non-zero\n+        private int val;\n+\n+        @ForceInline\n+        public MyValue152(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public int val() {\n+            return val;\n+        }\n+    }\n+\n+    static primitive class MyWrapper152 {\n+        private int unused = 0; \/\/ Make sure sub-offset of val field is non-zero\n+        MyValue152 val;\n+\n+        @ForceInline\n+        public MyWrapper152(MyInterface2 val) {\n+            this.val = (MyValue152)val;\n+        }\n+    }\n+\n+    \/\/ Test that checkcast with speculative type does not break scalarization in return\n+    @Test\n+    public MyWrapper152 test152(MyInterface2 val) {\n+        return new MyWrapper152(val);\n+    }\n+\n+    @Run(test = \"test152\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test152_verifier() {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test152(val).val, val);\n+    }\n+\n+    @DontInline\n+    static void test153_helper(MyWrapper152 arg) {\n+\n+    }\n+\n+    \/\/ Test that checkcast with speculative type does not prevent scalarization in args\n+    @Test\n+    public void test153(MyInterface2 val) {\n+        test153_helper(new MyWrapper152(val));\n+    }\n+\n+    @Run(test = \"test153\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test153_verifier() {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        test153(val);\n+    }\n+\n+    \/\/ Test that checkcast with speculative type enables scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test154(Method m, MyInterface2 val, boolean b1, boolean b2) {\n+        MyInterface2 obj = new MyValue152(rI);\n+        if (b1) {\n+            \/\/ Speculative cast to MyValue152 enables scalarization\n+            obj = (MyAbstract2)val;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.val();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test154\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test154_verifier(RunInfo info) {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test154(info.getTest(), val, false, false), -1);\n+        Asserts.assertEquals(test154(info.getTest(), val, true, false), -1);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test154(info.getTest(), val, false, true), rI);\n+        }\n+    }\n+\n+    \/\/ Same as test154 but with null val\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test155(Method m, MyInterface2 val, boolean b1, boolean b2) {\n+        MyInterface2 obj = new MyValue152(rI);\n+        if (b1) {\n+            \/\/ Speculative cast to MyValue152 enables scalarization\n+            obj = (MyAbstract2)val;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.val();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test155\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test155_verifier(RunInfo info) {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test155(info.getTest(), val, false, false), -1);\n+        Asserts.assertEquals(test155(info.getTest(), val, true, false), -1);\n+        Asserts.assertEquals(test155(info.getTest(), null, true, false), -1);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test155(info.getTest(), val, false, true), rI);\n+        }\n+    }\n+\n+    \/\/ Test withfield directly operating on inline type arg (instead of on defaultvalue)\n+    @Test\n+    public MyValue5 test156(MyValue5 vt) {\n+        return vt.withField(rI);\n+    }\n+\n+    @Run(test = \"test156\")\n+    @Warmup(10000)\n+    public void test156_verifier() {\n+        Asserts.assertEquals(test156(new MyValue5()).x, rI);\n+    }\n+\n+    final static MyValue1 test157Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Test merging buffered inline type from field load with non-buffered inline type\n+    @Test\n+    public MyValue1 test157(long val) {\n+        return (val == 0L) ? test157Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test157\")\n+    public void test157_verifier() {\n+        Asserts.assertEquals(test157(0), test157Cache);\n+        Asserts.assertEquals(test157(rL).hash(), testValue1.hash());\n+    }\n+\n+    static MyValue1 test158Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Same as test157 but with non-final field load\n+    @Test\n+    public MyValue1 test158(long val) {\n+        return (val == 0L) ? test158Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test158\")\n+    public void test158_verifier() {\n+        Asserts.assertEquals(test158(0), test158Cache);\n+        Asserts.assertEquals(test158(rL).hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Test null check on withfield receiver\n+    @Test\n+    public MyValue5.ref test159(MyValue5.ref vt) {\n+        return MyValue5.withField(vt, rI);\n+    }\n+\n+    @Run(test = \"test159\")\n+    @Warmup(10000)\n+    public void test159_verifier(RunInfo info) {\n+        Asserts.assertEquals(test159(new MyValue5()).x, rI);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test159(null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify that cast that with incompatible types is properly handled\n+    @Test\n+    public void test160(Integer arg) {\n+        Object tmp = arg;\n+        MyValue1 res = (MyValue1)tmp;\n+    }\n+\n+    @Run(test = \"test160\")\n+    @Warmup(10000)\n+    public void test160_verifier(RunInfo info) {\n+        try {\n+            test160(42);\n+            throw new RuntimeException(\"No CCE thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test160(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":4382,"deletions":0,"binary":false,"changes":4382,"status":"added"},{"patch":"@@ -0,0 +1,1124 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline type specific profiling\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @run driver\/timeout=300 compiler.valhalla.inlinetypes.TestLWorldProfiling\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestLWorldProfiling {\n+\n+    public static void main(String[] args) {\n+        final Scenario[] scenarios = {\n+                new Scenario(0,\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\",\n+                        \"-XX:-MonomorphicArrayCheck\"),\n+                new Scenario(1,\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:+UseArrayLoadStoreProfile\",\n+                        \"-XX:+UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\"),\n+                new Scenario(2,\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=222\",\n+                        \"-XX:-MonomorphicArrayCheck\"),\n+                new Scenario(3,\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\",\n+                        \"-XX:-MonomorphicArrayCheck\",\n+                        \"-XX:TieredStopAtLevel=4\",\n+                        \"-XX:-TieredCompilation\"),\n+                new Scenario(4,\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:+UseArrayLoadStoreProfile\",\n+                        \"-XX:+UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\",\n+                        \"-XX:TieredStopAtLevel=4\",\n+                        \"-XX:-TieredCompilation\"),\n+                new Scenario(5,\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=222\",\n+                        \"-XX:-MonomorphicArrayCheck\",\n+                        \"-XX:TieredStopAtLevel=4\",\n+                        \"-XX:-TieredCompilation\")\n+        };\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\")\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class)\n+                   .start();\n+    }\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);\n+    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1};\n+    private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2};\n+    private static final Integer[] testIntegerArray = new Integer[] {42};\n+    private static final Long[] testLongArray = new Long[] {42L};\n+    private static final Double[] testDoubleArray = new Double[] {42.0D};\n+    private static final MyValue1.ref[] testValue1NotFlatArray = new MyValue1.ref[] {testValue1};\n+    private static final MyValue1[][] testValue1ArrayArray = new MyValue1[][] {testValue1Array};\n+\n+    \/\/ Wrap these variables into helper class because\n+    \/\/ WhiteBox API needs to be initialized by TestFramework first.\n+    static class WBFlags {\n+        static final boolean UseACmpProfile = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"UseACmpProfile\");\n+        static final boolean TieredCompilation = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"TieredCompilation\");\n+        static final boolean ProfileInterpreter = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"ProfileInterpreter\");\n+        static final boolean UseArrayLoadStoreProfile = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"UseArrayLoadStoreProfile\");\n+        static final long TypeProfileLevel = (Long) WhiteBox.getWhiteBox().getVMFlag(\"TypeProfileLevel\");\n+    }\n+\n+    \/\/ aaload\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIfAnd={\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test1(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    public void test1_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object o = test1(testValue1Array);\n+            Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+        } else {\n+            Object o = test1(testValue2Array);\n+            Asserts.assertEQ(((MyValue2)o).hash(), testValue2.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test2(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(10000)\n+    public void test2_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object o = test2(testIntegerArray);\n+            Asserts.assertEQ(o, 42);\n+        } else {\n+            Object o = test2(testLongArray);\n+            Asserts.assertEQ(o, 42L);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test3(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(10000)\n+    public void test3_verifier() {\n+        Object o = test3(testValue1Array);\n+        Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+        o = test3(testValue2Array);\n+        Asserts.assertEQ(((MyValue2)o).hash(), testValue2.hash());\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test4(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(10000)\n+    public void test4_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object o = test4(testIntegerArray);\n+            Asserts.assertEQ(o, 42);\n+            o = test4(testLongArray);\n+            Asserts.assertEQ(o, 42L);\n+        } else {\n+            Object o = test4(testValue2Array);\n+            Asserts.assertEQ(((MyValue2)o).hash(), testValue2.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test5(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(10000)\n+    public void test5_verifier() {\n+        Object o = test5(testValue1Array);\n+        Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+        o = test5(testValue1NotFlatArray);\n+        Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Check that profile data that's useless at the aaload is\n+    \/\/ leveraged at a later point\n+    @DontInline\n+    public void test6_no_inline() {\n+    }\n+\n+\n+    public void test6_helper(Number[] arg) {\n+        if (arg instanceof Long[]) {\n+            test6_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        counts = {CALL, \"= 3\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\", RANGE_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {CALL, \"= 4\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n+    public Object test6(Number[] array) {\n+        Number v = array[0];\n+        test6_helper(array);\n+        return v;\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(10000)\n+    public void test6_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test6_helper(testLongArray);\n+            test6_helper(testDoubleArray);\n+        }\n+        test6(testIntegerArray);\n+    }\n+\n+    @DontInline\n+    public void test7_no_inline() {\n+    }\n+\n+\n+    public void test7_helper(Number arg) {\n+        if (arg instanceof Long) {\n+            test7_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        counts = {CALL, \"= 4\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\", RANGE_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n+    public Object test7(Number[] array) {\n+        Number v = array[0];\n+        test7_helper(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(10000)\n+    public void test7_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test7_helper(42L);\n+            test7_helper(42.0D);\n+        }\n+        test7(testIntegerArray);\n+    }\n+\n+    @DontInline\n+    public void test8_no_inline() {\n+    }\n+\n+    public void test8_helper(Object arg) {\n+        if (arg instanceof Long) {\n+            test8_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {CALL, \"= 5\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\",\n+                  RANGE_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n+    public Object test8(Object[] array) {\n+        Object v = array[0];\n+        test8_helper(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(10000)\n+    public void test8_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test8_helper(42L);\n+            test8_helper(42.0D);\n+        }\n+        test8(testValue1Array);\n+        test8(testValue1NotFlatArray);\n+    }\n+\n+    \/\/ aastore\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test9(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(10000)\n+    public void test9_verifier() {\n+        test9(testValue1Array, testValue1);\n+        Asserts.assertEQ(testValue1Array[0].hash(), testValue1.hash());\n+    }\n+\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test10(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test10\")\n+    @Warmup(10000)\n+    public void test10_verifier() {\n+        test10(testIntegerArray, 42);\n+    }\n+\n+    @Test\n+    @IR(counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test11(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(10000)\n+    public void test11_verifier() {\n+        test11(testValue1Array, testValue1);\n+        test11(testValue2Array, testValue2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test12(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test12\")\n+    @Warmup(10000)\n+    public void test12_verifier() {\n+        test12(testIntegerArray, 42);\n+        test12(testLongArray, 42L);\n+    }\n+\n+    @Test\n+    @IR(counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test13(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(10000)\n+    public void test13_verifier() {\n+        test13(testValue1Array, testValue1);\n+        test13(testValue1NotFlatArray, testValue1);\n+    }\n+\n+    \/\/ MonomorphicArrayCheck\n+    @Test\n+    public void test14(Number[] array, Number v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test14\")\n+    @Warmup(10000)\n+    public void test14_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            test14(testIntegerArray, 42);\n+        } else {\n+            Method m = info.getTest();\n+            boolean deopt = false;\n+            for (int i = 0; i < 100; i++) {\n+                test14(testIntegerArray, 42);\n+                if (!info.isCompilationSkipped() && !TestFramework.isCompiled(m)) {\n+                    deopt = true;\n+                }\n+            }\n+            if (deopt && TestFramework.isStableDeopt(m, CompLevel.C2) && !WBFlags.TieredCompilation && WBFlags.ProfileInterpreter &&\n+                (WBFlags.UseArrayLoadStoreProfile || WBFlags.TypeProfileLevel == 222)) {\n+                throw new RuntimeException(\"Monomorphic array check should rely on profiling and be accurate\");\n+            }\n+        }\n+    }\n+\n+    \/\/ null free array profiling\n+\n+    primitive static class NotFlattenable {\n+        private final Object o1 = null;\n+        private final Object o2 = null;\n+        private final Object o3 = null;\n+        private final Object o4 = null;\n+        private final Object o5 = null;\n+        private final Object o6 = null;\n+    }\n+\n+    private static final NotFlattenable notFlattenable = new NotFlattenable();\n+    private static final NotFlattenable[] testNotFlattenableArray = new NotFlattenable[] { notFlattenable };\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        counts = {NULL_CHECK_TRAP, \"= 2\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test15(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test15\")\n+    @Warmup(10000)\n+    public void test15_verifier() {\n+        test15(testNotFlattenableArray, notFlattenable);\n+        try {\n+            test15(testNotFlattenableArray, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {NULL_CHECK_TRAP, \"= 2\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test16(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test16\")\n+    @Warmup(10000)\n+    public void test16_verifier() {\n+        test16(testNotFlattenableArray, notFlattenable);\n+        try {\n+            test16(testNotFlattenableArray, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        test16(testIntegerArray, 42);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {NULL_CHECK_TRAP, \"= 1\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test17(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test17\")\n+    @Warmup(10000)\n+    public void test17_verifier() {\n+        test17(testIntegerArray, 42);\n+        test17(testIntegerArray, null);\n+        testIntegerArray[0] = 42;\n+        test17(testLongArray, 42L);\n+    }\n+\n+    public void test18_helper(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {NULL_CHECK_TRAP, \"= 1\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test18(Object[] array, Object v1) {\n+        Object v2 = array[0];\n+        test18_helper(array, v1);\n+        return v2;\n+    }\n+\n+    @Run(test = \"test18\")\n+    @Warmup(10000)\n+    public void test18_verifier() {\n+        test18_helper(testValue1Array, testValue1); \/\/ pollute profile\n+        test18(testIntegerArray, 42);\n+        test18(testIntegerArray, null);\n+        testIntegerArray[0] = 42;\n+        test18(testLongArray, 42L);\n+    }\n+\n+    \/\/ maybe null free, not flat\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test19(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test19\")\n+    @Warmup(10000)\n+    public void test19_verifier() {\n+        Object o = test19(testIntegerArray);\n+        Asserts.assertEQ(o, 42);\n+        o = test19(testNotFlattenableArray);\n+        Asserts.assertEQ(o, notFlattenable);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test20(Object[] array, Object o) {\n+        array[0] = o;\n+    }\n+\n+    @Run(test = \"test20\")\n+    @Warmup(10000)\n+    public void test20_verifier() {\n+        test20(testIntegerArray, 42);\n+        test20(testNotFlattenableArray, notFlattenable);\n+    }\n+\n+    \/\/ acmp tests\n+\n+    \/\/ branch frequency profiling causes not equal branch to be optimized out\n+    @Test\n+    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    public boolean test21(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test21\")\n+    @Warmup(10000)\n+    public void test21_verifier() {\n+        test21(42, 42);\n+        test21(testValue1, testValue1);\n+    }\n+\n+    \/\/ Input profiled non null\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test22(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test22\")\n+    @Warmup(10000)\n+    public void test22_verifier(RunInfo info) {\n+        test22(42, null);\n+        test22(42.0, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test22(42, 42.0);\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test23(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test23\")\n+    @Warmup(10000)\n+    public void test23_verifier(RunInfo info) {\n+        test23(null, 42);\n+        test23(null, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test23(42, 42.0);\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test24(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test24\")\n+    @Warmup(10000)\n+    public void test24_verifier(RunInfo info) {\n+        test24(42, null);\n+        test24(42.0, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test24(42, 42.0);\n+             if (WBFlags.UseACmpProfile) {\n+                 TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test25(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test25\")\n+    @Warmup(10000)\n+    public void test25_verifier(RunInfo info) {\n+        test25(null, 42);\n+        test25(null, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test25(42, 42.0);\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    \/\/ Input profiled not inline type with known type\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test26(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test26\")\n+    @Warmup(10000)\n+    public void test26_verifier(RunInfo info) {\n+        test26(42, 42);\n+        test26(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test26(42.0, 42);\n+            }\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = { NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test27(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test27\")\n+    @Warmup(10000)\n+    public void test27_verifier(RunInfo info) {\n+        test27(42, 42);\n+        test27(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test27(42, 42.0);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test28(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test28\")\n+    @Warmup(10000)\n+    public void test28_verifier(RunInfo info) {\n+        test28(42, 42);\n+        test28(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test28(42.0, 42);\n+            }\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test29(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test29\")\n+    @Warmup(10000)\n+    public void test29_verifier(RunInfo info) {\n+        test29(42, 42);\n+        test29(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test29(42, 42.0);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test30(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(10000)\n+    public void test30_verifier(RunInfo info) {\n+        test30(42, 42);\n+        test30(42, 42.0);\n+        test30(null, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test30(42.0, 42);\n+            }\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test31(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test31\")\n+    @Warmup(10000)\n+    public void test31_verifier(RunInfo info) {\n+        test31(42, 42);\n+        test31(42.0, 42);\n+        test31(42, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test31(42, 42.0);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    \/\/ Input profiled not inline type with unknown type\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test32(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test32\")\n+    @Warmup(10000)\n+    public void test32_verifier(RunInfo info) {\n+        test32(42, 42);\n+        test32(42, testValue1);\n+        test32(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test32(testValue1, 42);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test33(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test33\")\n+    @Warmup(10000)\n+    public void test33_verifier(RunInfo info) {\n+        test33(42, 42);\n+        test33(testValue1, 42);\n+        test33(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test33(42, testValue1);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test34(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test34\")\n+    @Warmup(10000)\n+    public void test34_verifier(RunInfo info) {\n+        test34(42, 42);\n+        test34(42, testValue1);\n+        test34(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test34(testValue1, 42);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test35(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test35\")\n+    @Warmup(10000)\n+    public void test35_verifier(RunInfo info) {\n+        test35(42, 42);\n+        test35(testValue1, 42);\n+        test35(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test35(42, testValue1);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test36(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test36\")\n+    @Warmup(10000)\n+    public void test36_verifier(RunInfo info) {\n+        test36(42, 42.0);\n+        test36(42.0, testValue1);\n+        test36(null, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test36(testValue1, 42);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test37(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test37\")\n+    @Warmup(10000)\n+    public void test37_verifier(RunInfo info) {\n+        test37(42.0, 42);\n+        test37(testValue1, 42.0);\n+        test37(42, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test37(42, testValue1);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that acmp profile data that's unused at the acmp is fed to\n+    \/\/ speculation and leverage later\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public void test38(Object o1, Object o2, Object o3) {\n+        if (o1 == o2) {\n+            test38_helper2();\n+        }\n+        test38_helper(o1, o3);\n+    }\n+\n+    public void test38_helper(Object o1, Object o2) {\n+        if (o1 == o2) {\n+        }\n+    }\n+\n+    public void test38_helper2() {\n+    }\n+\n+    @Run(test = \"test38\")\n+    @Warmup(10000)\n+    public void test38_verifier() {\n+        test38(42, 42, 42);\n+        test38_helper(testValue1, testValue2);\n+    }\n+\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public void test39(Object o1, Object o2, Object o3) {\n+        if (o1 == o2) {\n+            test39_helper2();\n+        }\n+        test39_helper(o2, o3);\n+    }\n+\n+    public void test39_helper(Object o1, Object o2) {\n+        if (o1 == o2) {\n+        }\n+    }\n+\n+    public void test39_helper2() {\n+    }\n+\n+    @Run(test = \"test39\")\n+    @Warmup(10000)\n+    public void test39_verifier() {\n+        test39(42, 42, 42);\n+        test39_helper(testValue1, testValue2);\n+    }\n+\n+    \/\/ Test array access with polluted array type profile\n+    static abstract class Test40Abstract { }\n+    static class Test40Class extends Test40Abstract { }\n+    static primitive class Test40Inline extends Test40Abstract { }\n+\n+    @ForceInline\n+    public Object test40_access(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Test\n+    public Object test40(Test40Abstract[] array) {\n+        return test40_access(array);\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(10000)\n+    public void test40_verifier(RunInfo info) {\n+        \/\/ Make sure multiple implementors of Test40Abstract are loaded\n+        Test40Inline tmp1 = new Test40Inline();\n+        Test40Class tmp2 = new Test40Class();\n+        if (info.isWarmUp()) {\n+            \/\/ Pollute profile with Object[] (exact)\n+            test40_access(new Object[1]);\n+        } else {\n+            \/\/ When inlining test40_access, profiling contradicts actual type of array\n+            test40(new Test40Class[1]);\n+        }\n+    }\n+\n+    \/\/ Same as test40 but with array store\n+    @ForceInline\n+    public void test41_access(Object[] array, Object val) {\n+        array[0] = val;\n+    }\n+\n+    @Test\n+    public void test41(Test40Inline[] array, Object val) {\n+        test41_access(array, val);\n+    }\n+\n+    @Run(test = \"test41\")\n+    @Warmup(10000)\n+    public void test41_verifier(RunInfo info) {\n+        \/\/ Make sure multiple implementors of Test40Abstract are loaded\n+        Test40Inline tmp1 = new Test40Inline();\n+        Test40Class tmp2 = new Test40Class();\n+        if (info.isWarmUp()) {\n+            \/\/ Pollute profile with exact Object[]\n+            test41_access(new Object[1], new Object());\n+        } else {\n+            \/\/ When inlining test41_access, profiling contradicts actual type of array\n+            test41(new Test40Inline[1], new Test40Inline());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":1124,"deletions":0,"binary":false,"changes":1124,"status":"added"},{"patch":"@@ -0,0 +1,506 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @run driver\/timeout=300 compiler.valhalla.inlinetypes.TestMethodHandles\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestMethodHandles {\n+\n+    static {\n+        try {\n+            Class<?> clazz = TestMethodHandles.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(MyValue3.class.asValueType());\n+            test1_mh = lookup.findVirtual(clazz, \"test1_target\", mt);\n+            test2_mh = lookup.findVirtual(clazz, \"test2_target\", mt);\n+            test3_mh = lookup.findVirtual(clazz, \"test3_target\", mt);\n+\n+            MethodType test4_mt1 = MethodType.methodType(int.class, MyValue1.class.asValueType());\n+            MethodType test4_mt2 = MethodType.methodType(MyValue1.class.asValueType());\n+            MethodHandle test4_mh1 = lookup.findStatic(clazz, \"test4_helper1\", test4_mt1);\n+            MethodHandle test4_mh2 = lookup.findStatic(clazz, \"test4_helper2\", test4_mt2);\n+            test4_mh = MethodHandles.filterReturnValue(test4_mh2, test4_mh1);\n+\n+            MethodType test5_mt = MethodType.methodType(int.class, MyValue1.class.asValueType());\n+            test5_mh = lookup.findVirtual(clazz, \"test5_target\", test5_mt);\n+\n+            MethodType test6_mt = MethodType.methodType(MyValue3.class.asValueType());\n+            MethodHandle test6_mh1 = lookup.findVirtual(clazz, \"test6_target1\", test6_mt);\n+            MethodHandle test6_mh2 = lookup.findVirtual(clazz, \"test6_target2\", test6_mt);\n+            MethodType boolean_mt = MethodType.methodType(boolean.class);\n+            MethodHandle test6_mh_test = lookup.findVirtual(clazz, \"test6_test\", boolean_mt);\n+            test6_mh = MethodHandles.guardWithTest(test6_mh_test, test6_mh1, test6_mh2);\n+\n+            MethodType myvalue2_mt = MethodType.methodType(MyValue2.class.asValueType());\n+            test7_mh1 = lookup.findStatic(clazz, \"test7_target1\", myvalue2_mt);\n+            MethodHandle test7_mh2 = lookup.findStatic(clazz, \"test7_target2\", myvalue2_mt);\n+            MethodHandle test7_mh_test = lookup.findStatic(clazz, \"test7_test\", boolean_mt);\n+            test7_mh = MethodHandles.guardWithTest(test7_mh_test,\n+                                                    MethodHandles.invoker(myvalue2_mt),\n+                                                    MethodHandles.dropArguments(test7_mh2, 0, MethodHandle.class));\n+\n+            MethodHandle test8_mh1 = lookup.findStatic(clazz, \"test8_target1\", myvalue2_mt);\n+            test8_mh2 = lookup.findStatic(clazz, \"test8_target2\", myvalue2_mt);\n+            MethodHandle test8_mh_test = lookup.findStatic(clazz, \"test8_test\", boolean_mt);\n+            test8_mh = MethodHandles.guardWithTest(test8_mh_test,\n+                                                    MethodHandles.dropArguments(test8_mh1, 0, MethodHandle.class),\n+                                                    MethodHandles.invoker(myvalue2_mt));\n+\n+            MethodType test9_mt = MethodType.methodType(MyValue3.class.asValueType());\n+            MethodHandle test9_mh1 = lookup.findVirtual(clazz, \"test9_target1\", test9_mt);\n+            MethodHandle test9_mh2 = lookup.findVirtual(clazz, \"test9_target2\", test9_mt);\n+            MethodHandle test9_mh3 = lookup.findVirtual(clazz, \"test9_target3\", test9_mt);\n+            MethodType test9_mt2 = MethodType.methodType(boolean.class);\n+            MethodHandle test9_mh_test1 = lookup.findVirtual(clazz, \"test9_test1\", test9_mt2);\n+            MethodHandle test9_mh_test2 = lookup.findVirtual(clazz, \"test9_test2\", test9_mt2);\n+            test9_mh = MethodHandles.guardWithTest(test9_mh_test1,\n+                                                    test9_mh1,\n+                                                    MethodHandles.guardWithTest(test9_mh_test2, test9_mh2, test9_mh3));\n+\n+            MethodType test10_mt = MethodType.methodType(MyValue2.class.asValueType());\n+            MethodHandle test10_mh1 = lookup.findStatic(clazz, \"test10_target1\", test10_mt);\n+            test10_mh2 = lookup.findStatic(clazz, \"test10_target2\", test10_mt);\n+            test10_mh3 = lookup.findStatic(clazz, \"test10_target3\", test10_mt);\n+            MethodType test10_mt2 = MethodType.methodType(boolean.class);\n+            MethodType test10_mt3 = MethodType.methodType(MyValue2.class.asValueType());\n+            MethodHandle test10_mh_test1 = lookup.findStatic(clazz, \"test10_test1\", test10_mt2);\n+            MethodHandle test10_mh_test2 = lookup.findStatic(clazz, \"test10_test2\", test10_mt2);\n+            test10_mh = MethodHandles.guardWithTest(test10_mh_test1,\n+                                                    MethodHandles.dropArguments(test10_mh1, 0, MethodHandle.class, MethodHandle.class),\n+                                                    MethodHandles.guardWithTest(test10_mh_test2,\n+                                                                                MethodHandles.dropArguments(MethodHandles.invoker(test10_mt3), 1, MethodHandle.class),\n+                                                                                MethodHandles.dropArguments(MethodHandles.invoker(test10_mt3), 0, MethodHandle.class))\n+                                                    );\n+\n+            MethodHandle test11_mh1 = lookup.findStatic(clazz, \"test11_target1\", myvalue2_mt);\n+            test11_mh2 = lookup.findStatic(clazz, \"test11_target2\", myvalue2_mt);\n+            MethodHandle test11_mh_test = lookup.findStatic(clazz, \"test11_test\", boolean_mt);\n+            test11_mh = MethodHandles.guardWithTest(test11_mh_test,\n+                                                    MethodHandles.dropArguments(test11_mh1, 0, MethodHandle.class),\n+                                                    MethodHandles.invoker(myvalue2_mt));\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+\n+        \/\/ Prevent inlining through MethodHandle linkTo adapters to stress the calling convention\n+        scenarios[2].addFlags(\"-DVerifyIR=false\",\n+                              \"-XX:CompileCommand=dontinline,java.lang.invoke.DirectMethodHandle::internalMemberName\");\n+        scenarios[4].addFlags(\"-XX:CompileCommand=dontinline,java.lang.invoke.DirectMethodHandle::internalMemberName\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    \/\/ Everything inlined\n+    final MyValue3 test1_vt = MyValue3.create();\n+\n+    @ForceInline\n+    MyValue3 test1_target() {\n+        return test1_vt;\n+    }\n+\n+    static final MethodHandle test1_mh;\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, STORE, CALL})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC, \"= 1\", STORE, \"= 14\"})\n+    public MyValue3 test1() throws Throwable {\n+        return (MyValue3)test1_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    public void test1_verifier() throws Throwable {\n+        MyValue3 vt = test1();\n+        test1_vt.verify(vt);\n+    }\n+\n+    \/\/ Leaf method not inlined but returned type is known\n+    final MyValue3 test2_vt = MyValue3.create();\n+    @DontInline\n+    MyValue3 test2_target() {\n+        return test2_vt;\n+    }\n+\n+    static final MethodHandle test2_mh;\n+\n+    @Test\n+    public MyValue3 test2() throws Throwable {\n+        return (MyValue3)test2_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier(RunInfo info) throws Throwable {\n+        if (!info.isWarmUp()) {\n+            Method helper_m = getClass().getDeclaredMethod(\"test2_target\");\n+            if (!TestFramework.isCompiled(helper_m)) {\n+                TestFramework.compile(helper_m, CompLevel.C2);\n+            }\n+        }\n+        MyValue3 vt = test2();\n+        test2_vt.verify(vt);\n+    }\n+\n+    \/\/ Leaf method not inlined and returned type not known\n+    final MyValue3 test3_vt = MyValue3.create();\n+    @DontInline\n+    MyValue3 test3_target() {\n+        return test3_vt;\n+    }\n+\n+    static final MethodHandle test3_mh;\n+\n+    @Test\n+    public MyValue3 test3() throws Throwable {\n+        return (MyValue3)test3_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier(RunInfo info) throws Throwable {\n+        \/\/ hack so C2 doesn't know the target of the invoke call\n+        Class c = Class.forName(\"java.lang.invoke.DirectMethodHandle\");\n+        Method m = c.getDeclaredMethod(\"internalMemberName\", Object.class);\n+        WhiteBox.getWhiteBox().testSetDontInlineMethod(m, info.isWarmUp());\n+        MyValue3 vt = test3();\n+        test3_vt.verify(vt);\n+    }\n+\n+    \/\/ When test75_helper1 is inlined in test75, the method handle\n+    \/\/ linker that called it is passed a pointer to a copy of vt\n+    \/\/ stored in memory. The method handle linker needs to load the\n+    \/\/ fields from memory before it inlines test75_helper1.\n+    static public int test4_helper1(MyValue1 vt) {\n+        return vt.x;\n+    }\n+\n+    static MyValue1 test4_vt = MyValue1.createWithFieldsInline(rI, rL);\n+    static public MyValue1 test4_helper2() {\n+        return test4_vt;\n+    }\n+\n+    static final MethodHandle test4_mh;\n+\n+    @Test\n+    public int test4() throws Throwable {\n+        return (int)test4_mh.invokeExact();\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() throws Throwable {\n+        int i = test4();\n+        Asserts.assertEQ(i, test4_vt.x);\n+    }\n+\n+    \/\/ Test method handle call with inline type argument\n+    public int test5_target(MyValue1 vt) {\n+        return vt.x;\n+    }\n+\n+    static final MethodHandle test5_mh;\n+    MyValue1 test5_vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    @Test\n+    public int test5() throws Throwable {\n+        return (int)test5_mh.invokeExact(this, test5_vt);\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() throws Throwable {\n+        int i = test5();\n+        Asserts.assertEQ(i, test5_vt.x);\n+    }\n+\n+    \/\/ Return of target1 and target2 merged in a Lambda Form as an\n+    \/\/ Object. Shouldn't cause any allocation\n+    final MyValue3 test6_vt1 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test6_target1() {\n+        return test6_vt1;\n+    }\n+\n+    final MyValue3 test6_vt2 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test6_target2() {\n+        return test6_vt2;\n+    }\n+\n+    boolean test6_bool = true;\n+    @ForceInline\n+    boolean test6_test() {\n+        return test6_bool;\n+    }\n+\n+    static final MethodHandle test6_mh;\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, ALLOCA, STORE, STORE_INLINE_FIELDS})\n+    public MyValue3 test6() throws Throwable {\n+        return (MyValue3)test6_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() throws Throwable {\n+        test6_bool = !test6_bool;\n+        MyValue3 vt = test6();\n+        vt.verify(test6_bool ? test6_vt1 : test6_vt2);\n+    }\n+\n+    \/\/ Similar as above but with the method handle for target1 not\n+    \/\/ constant. Shouldn't cause any allocation.\n+    @ForceInline\n+    static MyValue2 test7_target1() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test7_target2() {\n+        return MyValue2.createWithFieldsInline(rI+1, rD+1);\n+    }\n+\n+    static boolean test7_bool = true;\n+    @ForceInline\n+    static boolean test7_test() {\n+        return test7_bool;\n+    }\n+\n+    static final MethodHandle test7_mh;\n+    static MethodHandle test7_mh1;\n+\n+    @Test\n+    public long test7() throws Throwable {\n+        return ((MyValue2)test7_mh.invokeExact(test7_mh1)).hash();\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() throws Throwable {\n+        test7_bool = !test7_bool;\n+        long hash = test7();\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test7_bool ? 0 : 1), rD+(test7_bool ? 0 : 1)).hash());\n+    }\n+\n+    \/\/ Same as above but with the method handle for target2 not\n+    \/\/ constant. Shouldn't cause any allocation.\n+    @ForceInline\n+    static MyValue2 test8_target1() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test8_target2() {\n+        return MyValue2.createWithFieldsInline(rI+1, rD+1);\n+    }\n+\n+    static boolean test8_bool = true;\n+    @ForceInline\n+    static boolean test8_test() {\n+        return test8_bool;\n+    }\n+\n+    static final MethodHandle test8_mh;\n+    static MethodHandle test8_mh2;\n+\n+    @Test\n+    public long test8() throws Throwable {\n+        return ((MyValue2)test8_mh.invokeExact(test8_mh2)).hash();\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() throws Throwable {\n+        test8_bool = !test8_bool;\n+        long hash = test8();\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test8_bool ? 0 : 1), rD+(test8_bool ? 0 : 1)).hash());\n+    }\n+\n+    \/\/ Return of target1, target2 and target3 merged in Lambda Forms\n+    \/\/ as an Object. Shouldn't cause any allocation\n+    final MyValue3 test9_vt1 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test9_target1() {\n+        return test9_vt1;\n+    }\n+\n+    final MyValue3 test9_vt2 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test9_target2() {\n+        return test9_vt2;\n+    }\n+\n+    final MyValue3 test9_vt3 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test9_target3() {\n+        return test9_vt3;\n+    }\n+\n+    boolean test9_bool1 = true;\n+    @ForceInline\n+    boolean test9_test1() {\n+        return test9_bool1;\n+    }\n+\n+    boolean test9_bool2 = true;\n+    @ForceInline\n+    boolean test9_test2() {\n+        return test9_bool2;\n+    }\n+\n+    static final MethodHandle test9_mh;\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, ALLOCA, STORE, STORE_INLINE_FIELDS})\n+   public MyValue3 test9() throws Throwable {\n+        return (MyValue3)test9_mh.invokeExact(this);\n+    }\n+\n+    static int test9_i = 0;\n+    @Run(test = \"test9\")\n+    public void test9_verifier() throws Throwable {\n+        test9_i++;\n+        test9_bool1 = (test9_i % 2) == 0;\n+        test9_bool2 = (test9_i % 3) == 0;\n+        MyValue3 vt = test9();\n+        vt.verify(test9_bool1 ? test9_vt1 : (test9_bool2 ? test9_vt2 : test9_vt3));\n+    }\n+\n+    \/\/ Same as above but with non constant target2 and target3\n+    @ForceInline\n+    static MyValue2 test10_target1() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test10_target2() {\n+        return MyValue2.createWithFieldsInline(rI+1, rD+1);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test10_target3() {\n+        return MyValue2.createWithFieldsInline(rI+2, rD+2);\n+    }\n+\n+    static boolean test10_bool1 = true;\n+    @ForceInline\n+    static boolean test10_test1() {\n+        return test10_bool1;\n+    }\n+\n+    static boolean test10_bool2 = true;\n+    @ForceInline\n+    static boolean test10_test2() {\n+        return test10_bool2;\n+    }\n+\n+    static final MethodHandle test10_mh;\n+    static MethodHandle test10_mh2;\n+    static MethodHandle test10_mh3;\n+\n+    @Test\n+    public long test10() throws Throwable {\n+        return ((MyValue2)test10_mh.invokeExact(test10_mh2, test10_mh3)).hash();\n+    }\n+\n+    static int test10_i = 0;\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() throws Throwable {\n+        test10_i++;\n+        test10_bool1 = (test10_i % 2) == 0;\n+        test10_bool2 = (test10_i % 3) == 0;\n+        long hash = test10();\n+        int i = rI + (test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));\n+        double d = rD + (test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(i, d).hash());\n+    }\n+\n+    static int test11_i = 0;\n+\n+    @ForceInline\n+    static MyValue2 test11_target1() {\n+        return MyValue2.createWithFieldsInline(rI+test11_i, rD+test11_i);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test11_target2() {\n+        return MyValue2.createWithFieldsInline(rI-test11_i, rD-test11_i);\n+    }\n+\n+    @ForceInline\n+    static boolean test11_test() {\n+        return (test11_i % 100) == 0;\n+    }\n+\n+    static final MethodHandle test11_mh;\n+    static MethodHandle test11_mh2;\n+\n+    \/\/ Check that a buffered inline type returned by a compiled lambda form\n+    \/\/ is properly handled by the caller.\n+    @Test\n+    public long test11() throws Throwable {\n+        return ((MyValue2)test11_mh.invokeExact(test11_mh2)).hash();\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(11000)\n+    public void test11_verifier() throws Throwable {\n+        test11_i++;\n+        long hash = test11();\n+        boolean b = (test11_i % 100) == 0;\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+test11_i * (b ? 1 : -1), rD+test11_i * (b ? 1 : -1)).hash());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":506,"deletions":0,"binary":false,"changes":506,"status":"added"},{"patch":"@@ -0,0 +1,1910 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestNewAcmp\n+ * @summary Verifies correctness of the new acmp bytecode.\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @compile TestNewAcmp.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                               compiler.valhalla.inlinetypes.TestNewAcmp\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.invoke.*;\n+import java.lang.reflect.Method;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\n+interface MyInterface {\n+\n+}\n+\n+abstract class MyAbstract implements MyInterface {\n+\n+\n+}\n+\n+primitive class MyValue1 extends MyAbstract {\n+    final int x;\n+\n+    MyValue1(int x) {\n+        this.x = x;\n+    }\n+\n+    static MyValue1 createDefault() {\n+        return MyValue1.default;\n+    }\n+\n+    static MyValue1 setX(MyValue1 v, int x) {\n+        return new MyValue1(x);\n+    }\n+}\n+\n+primitive class MyValue2 extends MyAbstract {\n+    final int x;\n+\n+    MyValue2(int x) {\n+        this.x = x;\n+    }\n+\n+    static MyValue2 createDefault() {\n+        return MyValue2.default;\n+    }\n+\n+    static MyValue2 setX(MyValue2 v, int x) {\n+        return new MyValue2(x);\n+    }\n+}\n+\n+class MyObject extends MyAbstract {\n+    int x;\n+}\n+\n+\/\/ Mark test methods that return false if the argument is null\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface FalseIfNull { }\n+\n+\/\/ Mark test methods that return true if the argument is null\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface TrueIfNull { }\n+\n+public class TestNewAcmp {\n+\n+    public boolean testEq01_1(Object u1, Object u2) {\n+        return get(u1) == u2; \/\/ new acmp\n+    }\n+\n+    public boolean testEq01_2(Object u1, Object u2) {\n+        return u1 == get(u2); \/\/ new acmp\n+    }\n+\n+    public boolean testEq01_3(Object u1, Object u2) {\n+        return get(u1) == get(u2); \/\/ new acmp\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq01_4(Object u1, Object u2) {\n+        return getNotNull(u1) == u2; \/\/ new acmp without null check\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq01_5(Object u1, Object u2) {\n+        return u1 == getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq01_6(Object u1, Object u2) {\n+        return getNotNull(u1) == getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    public boolean testEq02_1(MyValue1 v1, MyValue1 v2) {\n+        return get(v1) == (Object)v2; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq02_2(MyValue1 v1, MyValue1 v2) {\n+        return (Object)v1 == get(v2); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq02_3(MyValue1 v1, MyValue1 v2) {\n+        return get(v1) == get(v2); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq03_1(MyValue1 v, Object u) {\n+        return get(v) == u; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq03_2(MyValue1 v, Object u) {\n+        return (Object)v == get(u); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq03_3(MyValue1 v, Object u) {\n+        return get(v) == get(u); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq04_1(Object u, MyValue1 v) {\n+        return get(u) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq04_2(Object u, MyValue1 v) {\n+        return u == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq04_3(Object u, MyValue1 v) {\n+        return get(u) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq05_1(MyObject o, MyValue1 v) {\n+        return get(o) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq05_2(MyObject o, MyValue1 v) {\n+        return o == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq05_3(MyObject o, MyValue1 v) {\n+        return get(o) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq06_1(MyValue1 v, MyObject o) {\n+        return get(v) == o; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq06_2(MyValue1 v, MyObject o) {\n+        return (Object)v == get(o); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq06_3(MyValue1 v, MyObject o) {\n+        return get(v) == get(o); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq07_1(MyValue1 v1, MyValue1 v2) {\n+        return getNotNull(v1) == (Object)v2; \/\/ false\n+    }\n+\n+    public boolean testEq07_2(MyValue1 v1, MyValue1 v2) {\n+        return (Object)v1 == getNotNull(v2); \/\/ false\n+    }\n+\n+    public boolean testEq07_3(MyValue1 v1, MyValue1 v2) {\n+        return getNotNull(v1) == getNotNull(v2); \/\/ false\n+    }\n+\n+    public boolean testEq08_1(MyValue1 v, Object u) {\n+        return getNotNull(v) == u; \/\/ false\n+    }\n+\n+    public boolean testEq08_2(MyValue1 v, Object u) {\n+        return (Object)v == getNotNull(u); \/\/ false\n+    }\n+\n+    public boolean testEq08_3(MyValue1 v, Object u) {\n+        return getNotNull(v) == getNotNull(u); \/\/ false\n+    }\n+\n+    public boolean testEq09_1(Object u, MyValue1 v) {\n+        return getNotNull(u) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq09_2(Object u, MyValue1 v) {\n+        return u == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq09_3(Object u, MyValue1 v) {\n+        return getNotNull(u) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq10_1(MyObject o, MyValue1 v) {\n+        return getNotNull(o) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq10_2(MyObject o, MyValue1 v) {\n+        return o == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq10_3(MyObject o, MyValue1 v) {\n+        return getNotNull(o) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq11_1(MyValue1 v, MyObject o) {\n+        return getNotNull(v) == o; \/\/ false\n+    }\n+\n+    public boolean testEq11_2(MyValue1 v, MyObject o) {\n+        return (Object)v == getNotNull(o); \/\/ false\n+    }\n+\n+    public boolean testEq11_3(MyValue1 v, MyObject o) {\n+        return getNotNull(v) == getNotNull(o); \/\/ false\n+    }\n+\n+    public boolean testEq12_1(MyObject o1, MyObject o2) {\n+        return get(o1) == o2; \/\/ old acmp\n+    }\n+\n+    public boolean testEq12_2(MyObject o1, MyObject o2) {\n+        return o1 == get(o2); \/\/ old acmp\n+    }\n+\n+    public boolean testEq12_3(MyObject o1, MyObject o2) {\n+        return get(o1) == get(o2); \/\/ old acmp\n+    }\n+\n+    public boolean testEq13_1(Object u, MyObject o) {\n+        return get(u) == o; \/\/ old acmp\n+    }\n+\n+    public boolean testEq13_2(Object u, MyObject o) {\n+        return u == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testEq13_3(Object u, MyObject o) {\n+        return get(u) == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testEq14_1(MyObject o, Object u) {\n+        return get(o) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testEq14_2(MyObject o, Object u) {\n+        return o == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq14_3(MyObject o, Object u) {\n+        return get(o) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq15_1(Object[] a, Object u) {\n+        return get(a) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testEq15_2(Object[] a, Object u) {\n+        return a == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq15_3(Object[] a, Object u) {\n+        return get(a) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq16_1(Object u, Object[] a) {\n+        return get(u) == a; \/\/ old acmp\n+    }\n+\n+    public boolean testEq16_2(Object u, Object[] a) {\n+        return u == get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testEq16_3(Object u, Object[] a) {\n+        return get(u) == get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testEq17_1(Object[] a, MyValue1 v) {\n+        return get(a) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq17_2(Object[] a, MyValue1 v) {\n+        return a == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq17_3(Object[] a, MyValue1 v) {\n+        return get(a) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq18_1(MyValue1 v, Object[] a) {\n+        return get(v) == a; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq18_2(MyValue1 v, Object[] a) {\n+        return (Object)v == get(a); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq18_3(MyValue1 v, Object[] a) {\n+        return get(v) == get(a); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq19_1(Object[] a, MyValue1 v) {\n+        return getNotNull(a) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq19_2(Object[] a, MyValue1 v) {\n+        return a == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq19_3(Object[] a, MyValue1 v) {\n+        return getNotNull(a) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq20_1(MyValue1 v, Object[] a) {\n+        return getNotNull(v) == a; \/\/ false\n+    }\n+\n+    public boolean testEq20_2(MyValue1 v, Object[] a) {\n+        return (Object)v == getNotNull(a); \/\/ false\n+    }\n+\n+    public boolean testEq20_3(MyValue1 v, Object[] a) {\n+        return getNotNull(v) == getNotNull(a); \/\/ false\n+    }\n+\n+    public boolean testEq21_1(MyInterface u1, MyInterface u2) {\n+        return get(u1) == u2; \/\/ new acmp\n+    }\n+\n+    public boolean testEq21_2(MyInterface u1, MyInterface u2) {\n+        return u1 == get(u2); \/\/ new acmp\n+    }\n+\n+    public boolean testEq21_3(MyInterface u1, MyInterface u2) {\n+        return get(u1) == get(u2); \/\/ new acmp\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq21_4(MyInterface u1, MyInterface u2) {\n+        return getNotNull(u1) == u2; \/\/ new acmp without null check\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq21_5(MyInterface u1, MyInterface u2) {\n+        return u1 == getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq21_6(MyInterface u1, MyInterface u2) {\n+        return getNotNull(u1) == getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    public boolean testEq21_7(MyAbstract u1, MyAbstract u2) {\n+        return get(u1) == u2; \/\/ new acmp\n+    }\n+\n+    public boolean testEq21_8(MyAbstract u1, MyAbstract u2) {\n+        return u1 == get(u2); \/\/ new acmp\n+    }\n+\n+    public boolean testEq21_9(MyAbstract u1, MyAbstract u2) {\n+        return get(u1) == get(u2); \/\/ new acmp\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq21_10(MyAbstract u1, MyAbstract u2) {\n+        return getNotNull(u1) == u2; \/\/ new acmp without null check\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq21_11(MyAbstract u1, MyAbstract u2) {\n+        return u1 == getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    @FalseIfNull\n+    public boolean testEq21_12(MyAbstract u1, MyAbstract u2) {\n+        return getNotNull(u1) == getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    public boolean testEq22_1(MyValue1 v, MyInterface u) {\n+        return get(v) == u; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq22_2(MyValue1 v, MyInterface u) {\n+        return (Object)v == get(u); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq22_3(MyValue1 v, MyInterface u) {\n+        return get(v) == get(u); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq22_4(MyValue1 v, MyAbstract u) {\n+        return get(v) == u; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq22_5(MyValue1 v, MyAbstract u) {\n+        return (Object)v == get(u); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq22_6(MyValue1 v, MyAbstract u) {\n+        return get(v) == get(u); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq23_1(MyInterface u, MyValue1 v) {\n+        return get(u) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq23_2(MyInterface u, MyValue1 v) {\n+        return u == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq23_3(MyInterface u, MyValue1 v) {\n+        return get(u) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq23_4(MyAbstract u, MyValue1 v) {\n+        return get(u) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq23_5(MyAbstract u, MyValue1 v) {\n+        return u == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq23_6(MyAbstract u, MyValue1 v) {\n+        return get(u) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq24_1(MyValue1 v, MyInterface u) {\n+        return getNotNull(v) == u; \/\/ false\n+    }\n+\n+    public boolean testEq24_2(MyValue1 v, MyInterface u) {\n+        return (Object)v == getNotNull(u); \/\/ false\n+    }\n+\n+    public boolean testEq24_3(MyValue1 v, MyInterface u) {\n+        return getNotNull(v) == getNotNull(u); \/\/ false\n+    }\n+\n+    public boolean testEq24_4(MyValue1 v, MyAbstract u) {\n+        return getNotNull(v) == u; \/\/ false\n+    }\n+\n+    public boolean testEq24_5(MyValue1 v, MyAbstract u) {\n+        return (Object)v == getNotNull(u); \/\/ false\n+    }\n+\n+    public boolean testEq24_6(MyValue1 v, MyAbstract u) {\n+        return getNotNull(v) == getNotNull(u); \/\/ false\n+    }\n+\n+    public boolean testEq25_1(MyInterface u, MyValue1 v) {\n+        return getNotNull(u) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq25_2(MyInterface u, MyValue1 v) {\n+        return u == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq25_3(MyInterface u, MyValue1 v) {\n+        return getNotNull(u) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq25_4(MyAbstract u, MyValue1 v) {\n+        return getNotNull(u) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq25_5(MyAbstract u, MyValue1 v) {\n+        return u == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq25_6(MyAbstract u, MyValue1 v) {\n+        return getNotNull(u) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq26_1(MyInterface u, MyObject o) {\n+        return get(u) == o; \/\/ old acmp\n+    }\n+\n+    public boolean testEq26_2(MyInterface u, MyObject o) {\n+        return u == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testEq26_3(MyInterface u, MyObject o) {\n+        return get(u) == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testEq26_4(MyAbstract u, MyObject o) {\n+        return get(u) == o; \/\/ old acmp\n+    }\n+\n+    public boolean testEq26_5(MyAbstract u, MyObject o) {\n+        return u == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testEq26_6(MyAbstract u, MyObject o) {\n+        return get(u) == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testEq27_1(MyObject o, MyInterface u) {\n+        return get(o) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testEq27_2(MyObject o, MyInterface u) {\n+        return o == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq27_3(MyObject o, MyInterface u) {\n+        return get(o) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq27_4(MyObject o, MyAbstract u) {\n+        return get(o) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testEq27_5(MyObject o, MyAbstract u) {\n+        return o == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq27_6(MyObject o, MyAbstract u) {\n+        return get(o) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq28_1(MyInterface[] a, MyInterface u) {\n+        return get(a) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testEq28_2(MyInterface[] a, MyInterface u) {\n+        return a == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq28_3(MyInterface[] a, MyInterface u) {\n+        return get(a) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq28_4(MyAbstract[] a, MyAbstract u) {\n+        return get(a) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testEq28_5(MyAbstract[] a, MyAbstract u) {\n+        return a == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq28_6(MyAbstract[] a, MyAbstract u) {\n+        return get(a) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testEq29_1(MyInterface u, MyInterface[] a) {\n+        return get(u) == a; \/\/ old acmp\n+    }\n+\n+    public boolean testEq29_2(MyInterface u, MyInterface[] a) {\n+        return u == get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testEq29_3(MyInterface u, MyInterface[] a) {\n+        return get(u) == get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testEq29_4(MyAbstract u, MyAbstract[] a) {\n+        return get(u) == a; \/\/ old acmp\n+    }\n+\n+    public boolean testEq29_5(MyAbstract u, MyAbstract[] a) {\n+        return u == get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testEq29_6(MyAbstract u, MyAbstract[] a) {\n+        return get(u) == get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testEq30_1(MyInterface[] a, MyValue1 v) {\n+        return get(a) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq30_2(MyInterface[] a, MyValue1 v) {\n+        return a == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq30_3(MyInterface[] a, MyValue1 v) {\n+        return get(a) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq30_4(MyAbstract[] a, MyValue1 v) {\n+        return get(a) == (Object)v; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq30_5(MyAbstract[] a, MyValue1 v) {\n+        return a == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq30_6(MyAbstract[] a, MyValue1 v) {\n+        return get(a) == get(v); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq31_1(MyValue1 v, MyInterface[] a) {\n+        return get(v) == a; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq31_2(MyValue1 v, MyInterface[] a) {\n+        return (Object)v == get(a); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq31_3(MyValue1 v, MyInterface[] a) {\n+        return get(v) == get(a); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq31_4(MyValue1 v, MyAbstract[] a) {\n+        return get(v) == a; \/\/ only true if both null\n+    }\n+\n+    public boolean testEq31_5(MyValue1 v, MyAbstract[] a) {\n+        return (Object)v == get(a); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq31_6(MyValue1 v, MyAbstract[] a) {\n+        return get(v) == get(a); \/\/ only true if both null\n+    }\n+\n+    public boolean testEq32_1(MyInterface[] a, MyValue1 v) {\n+        return getNotNull(a) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq32_2(MyInterface[] a, MyValue1 v) {\n+        return a == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq32_3(MyInterface[] a, MyValue1 v) {\n+        return getNotNull(a) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq32_4(MyAbstract[] a, MyValue1 v) {\n+        return getNotNull(a) == (Object)v; \/\/ false\n+    }\n+\n+    public boolean testEq32_5(MyAbstract[] a, MyValue1 v) {\n+        return a == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq32_6(MyAbstract[] a, MyValue1 v) {\n+        return getNotNull(a) == getNotNull(v); \/\/ false\n+    }\n+\n+    public boolean testEq33_1(MyValue1 v, MyInterface[] a) {\n+        return getNotNull(v) == a; \/\/ false\n+    }\n+\n+    public boolean testEq33_2(MyValue1 v, MyInterface[] a) {\n+        return (Object)v == getNotNull(a); \/\/ false\n+    }\n+\n+    public boolean testEq33_3(MyValue1 v, MyInterface[] a) {\n+        return getNotNull(v) == getNotNull(a); \/\/ false\n+    }\n+\n+    public boolean testEq33_4(MyValue1 v, MyAbstract[] a) {\n+        return getNotNull(v) == a; \/\/ false\n+    }\n+\n+    public boolean testEq33_5(MyValue1 v, MyAbstract[] a) {\n+        return (Object)v == getNotNull(a); \/\/ false\n+    }\n+\n+    public boolean testEq33_6(MyValue1 v, MyAbstract[] a) {\n+        return getNotNull(v) == getNotNull(a); \/\/ false\n+    }\n+\n+\n+    \/\/ Null tests\n+\n+    public boolean testNull01_1(MyValue1 v) {\n+        return (Object)v == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull01_2(MyValue1 v) {\n+        return get(v) == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull01_3(MyValue1 v) {\n+        return (Object)v == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull01_4(MyValue1 v) {\n+        return get(v) == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull02_1(MyValue1 v) {\n+        return null == (Object)v; \/\/ old acmp\n+    }\n+\n+    public boolean testNull02_2(MyValue1 v) {\n+        return get((Object)null) == (Object)v; \/\/ old acmp\n+    }\n+\n+    public boolean testNull02_3(MyValue1 v) {\n+        return null == get(v); \/\/ old acmp\n+    }\n+\n+    public boolean testNull02_4(MyValue1 v) {\n+        return get((Object)null) == get(v); \/\/ old acmp\n+    }\n+\n+    public boolean testNull03_1(Object u) {\n+        return u == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull03_2(Object u) {\n+        return get(u) == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull03_3(Object u) {\n+        return u == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull03_4(Object u) {\n+        return get(u) == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull04_1(Object u) {\n+        return null == u; \/\/ old acmp\n+    }\n+\n+    public boolean testNull04_2(Object u) {\n+        return get((Object)null) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testNull04_3(Object u) {\n+        return null == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNull04_4(Object u) {\n+        return get((Object)null) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNull05_1(MyObject o) {\n+        return o == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull05_2(MyObject o) {\n+        return get(o) == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull05_3(MyObject o) {\n+        return o == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull05_4(MyObject o) {\n+        return get(o) == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull06_1(MyObject o) {\n+        return null == o; \/\/ old acmp\n+    }\n+\n+    public boolean testNull06_2(MyObject o) {\n+        return get((Object)null) == o; \/\/ old acmp\n+    }\n+\n+    public boolean testNull06_3(MyObject o) {\n+        return null == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNull06_4(MyObject o) {\n+        return get((Object)null) == get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_1(MyInterface u) {\n+        return u == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_2(MyInterface u) {\n+        return get(u) == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_3(MyInterface u) {\n+        return u == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_4(MyInterface u) {\n+        return get(u) == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_5(MyAbstract u) {\n+        return u == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_6(MyAbstract u) {\n+        return get(u) == null; \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_7(MyAbstract u) {\n+        return u == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull07_8(MyAbstract u) {\n+        return get(u) == get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_1(MyInterface u) {\n+        return null == u; \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_2(MyInterface u) {\n+        return get((Object)null) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_3(MyInterface u) {\n+        return null == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_4(MyInterface u) {\n+        return get((Object)null) == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_5(MyAbstract u) {\n+        return null == u; \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_6(MyAbstract u) {\n+        return get((Object)null) == u; \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_7(MyAbstract u) {\n+        return null == get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNull08_8(MyAbstract u) {\n+        return get((Object)null) == get(u); \/\/ old acmp\n+    }\n+\n+    \/\/ Same tests as above but negated\n+\n+    public boolean testNotEq01_1(Object u1, Object u2) {\n+        return get(u1) != u2; \/\/ new acmp\n+    }\n+\n+    public boolean testNotEq01_2(Object u1, Object u2) {\n+        return u1 != get(u2); \/\/ new acmp\n+    }\n+\n+    public boolean testNotEq01_3(Object u1, Object u2) {\n+        return get(u1) != get(u2); \/\/ new acmp\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq01_4(Object u1, Object u2) {\n+        return getNotNull(u1) != u2; \/\/ new acmp without null check\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq01_5(Object u1, Object u2) {\n+        return u1 != getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq01_6(Object u1, Object u2) {\n+        return getNotNull(u1) != getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    public boolean testNotEq02_1(MyValue1 v1, MyValue1 v2) {\n+        return get(v1) != (Object)v2; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq02_2(MyValue1 v1, MyValue1 v2) {\n+        return (Object)v1 != get(v2); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq02_3(MyValue1 v1, MyValue1 v2) {\n+        return get(v1) != get(v2); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq03_1(MyValue1 v, Object u) {\n+        return get(v) != u; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq03_2(MyValue1 v, Object u) {\n+        return (Object)v != get(u); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq03_3(MyValue1 v, Object u) {\n+        return get(v) != get(u); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq04_1(Object u, MyValue1 v) {\n+        return get(u) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq04_2(Object u, MyValue1 v) {\n+        return u != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq04_3(Object u, MyValue1 v) {\n+        return get(u) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq05_1(MyObject o, MyValue1 v) {\n+        return get(o) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq05_2(MyObject o, MyValue1 v) {\n+        return o != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq05_3(MyObject o, MyValue1 v) {\n+        return get(o) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq06_1(MyValue1 v, MyObject o) {\n+        return get(v) != o; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq06_2(MyValue1 v, MyObject o) {\n+        return (Object)v != get(o); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq06_3(MyValue1 v, MyObject o) {\n+        return get(v) != get(o); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq07_1(MyValue1 v1, MyValue1 v2) {\n+        return getNotNull(v1) != (Object)v2; \/\/ true\n+    }\n+\n+    public boolean testNotEq07_2(MyValue1 v1, MyValue1 v2) {\n+        return (Object)v1 != getNotNull(v2); \/\/ true\n+    }\n+\n+    public boolean testNotEq07_3(MyValue1 v1, MyValue1 v2) {\n+        return getNotNull(v1) != getNotNull(v2); \/\/ true\n+    }\n+\n+    public boolean testNotEq08_1(MyValue1 v, Object u) {\n+        return getNotNull(v) != u; \/\/ true\n+    }\n+\n+    public boolean testNotEq08_2(MyValue1 v, Object u) {\n+        return (Object)v != getNotNull(u); \/\/ true\n+    }\n+\n+    public boolean testNotEq08_3(MyValue1 v, Object u) {\n+        return getNotNull(v) != getNotNull(u); \/\/ true\n+    }\n+\n+    public boolean testNotEq09_1(Object u, MyValue1 v) {\n+        return getNotNull(u) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq09_2(Object u, MyValue1 v) {\n+        return u != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq09_3(Object u, MyValue1 v) {\n+        return getNotNull(u) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq10_1(MyObject o, MyValue1 v) {\n+        return getNotNull(o) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq10_2(MyObject o, MyValue1 v) {\n+        return o != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq10_3(MyObject o, MyValue1 v) {\n+        return getNotNull(o) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq11_1(MyValue1 v, MyObject o) {\n+        return getNotNull(v) != o; \/\/ true\n+    }\n+\n+    public boolean testNotEq11_2(MyValue1 v, MyObject o) {\n+        return (Object)v != getNotNull(o); \/\/ true\n+    }\n+\n+    public boolean testNotEq11_3(MyValue1 v, MyObject o) {\n+        return getNotNull(v) != getNotNull(o); \/\/ true\n+    }\n+\n+    public boolean testNotEq12_1(MyObject o1, MyObject o2) {\n+        return get(o1) != o2; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq12_2(MyObject o1, MyObject o2) {\n+        return o1 != get(o2); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq12_3(MyObject o1, MyObject o2) {\n+        return get(o1) != get(o2); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq13_1(Object u, MyObject o) {\n+        return get(u) != o; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq13_2(Object u, MyObject o) {\n+        return u != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq13_3(Object u, MyObject o) {\n+        return get(u) != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq14_1(MyObject o, Object u) {\n+        return get(o) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq14_2(MyObject o, Object u) {\n+        return o != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq14_3(MyObject o, Object u) {\n+        return get(o) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq15_1(Object[] a, Object u) {\n+        return get(a) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq15_2(Object[] a, Object u) {\n+        return a != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq15_3(Object[] a, Object u) {\n+        return get(a) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq16_1(Object u, Object[] a) {\n+        return get(u) != a; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq16_2(Object u, Object[] a) {\n+        return u != get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq16_3(Object u, Object[] a) {\n+        return get(u) != get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq17_1(Object[] a, MyValue1 v) {\n+        return get(a) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq17_2(Object[] a, MyValue1 v) {\n+        return a != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq17_3(Object[] a, MyValue1 v) {\n+        return get(a) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq18_1(MyValue1 v, Object[] a) {\n+        return get(v) != a; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq18_2(MyValue1 v, Object[] a) {\n+        return (Object)v != get(a); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq18_3(MyValue1 v, Object[] a) {\n+        return get(v) != get(a); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq19_1(Object[] a, MyValue1 v) {\n+        return getNotNull(a) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq19_2(Object[] a, MyValue1 v) {\n+        return a != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq19_3(Object[] a, MyValue1 v) {\n+        return getNotNull(a) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq20_1(MyValue1 v, Object[] a) {\n+        return getNotNull(v) != a; \/\/ true\n+    }\n+\n+    public boolean testNotEq20_2(MyValue1 v, Object[] a) {\n+        return (Object)v != getNotNull(a); \/\/ true\n+    }\n+\n+    public boolean testNotEq20_3(MyValue1 v, Object[] a) {\n+        return getNotNull(v) != getNotNull(a); \/\/ true\n+    }\n+\n+    public boolean testNotEq21_1(MyInterface u1, MyInterface u2) {\n+        return get(u1) != u2; \/\/ new acmp\n+    }\n+\n+    public boolean testNotEq21_2(MyInterface u1, MyInterface u2) {\n+        return u1 != get(u2); \/\/ new acmp\n+    }\n+\n+    public boolean testNotEq21_3(MyInterface u1, MyInterface u2) {\n+        return get(u1) != get(u2); \/\/ new acmp\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq21_4(MyInterface u1, MyInterface u2) {\n+        return getNotNull(u1) != u2; \/\/ new acmp without null check\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq21_5(MyInterface u1, MyInterface u2) {\n+        return u1 != getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq21_6(MyInterface u1, MyInterface u2) {\n+        return getNotNull(u1) != getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    public boolean testNotEq21_7(MyAbstract u1, MyAbstract u2) {\n+        return get(u1) != u2; \/\/ new acmp\n+    }\n+\n+    public boolean testNotEq21_8(MyAbstract u1, MyAbstract u2) {\n+        return u1 != get(u2); \/\/ new acmp\n+    }\n+\n+    public boolean testNotEq21_9(MyAbstract u1, MyAbstract u2) {\n+        return get(u1) != get(u2); \/\/ new acmp\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq21_10(MyAbstract u1, MyAbstract u2) {\n+        return getNotNull(u1) != u2; \/\/ new acmp without null check\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq21_11(MyAbstract u1, MyAbstract u2) {\n+        return u1 != getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    @TrueIfNull\n+    public boolean testNotEq21_12(MyAbstract u1, MyAbstract u2) {\n+        return getNotNull(u1) != getNotNull(u2); \/\/ new acmp without null check\n+    }\n+\n+    public boolean testNotEq22_1(MyValue1 v, MyInterface u) {\n+        return get(v) != u; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq22_2(MyValue1 v, MyInterface u) {\n+        return (Object)v != get(u); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq22_3(MyValue1 v, MyInterface u) {\n+        return get(v) != get(u); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq22_4(MyValue1 v, MyAbstract u) {\n+        return get(v) != u; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq22_5(MyValue1 v, MyAbstract u) {\n+        return (Object)v != get(u); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq22_6(MyValue1 v, MyAbstract u) {\n+        return get(v) != get(u); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq23_1(MyInterface u, MyValue1 v) {\n+        return get(u) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq23_2(MyInterface u, MyValue1 v) {\n+        return u != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq23_3(MyInterface u, MyValue1 v) {\n+        return get(u) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq23_4(MyAbstract u, MyValue1 v) {\n+        return get(u) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq23_5(MyAbstract u, MyValue1 v) {\n+        return u != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq23_6(MyAbstract u, MyValue1 v) {\n+        return get(u) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq24_1(MyValue1 v, MyInterface u) {\n+        return getNotNull(v) != u; \/\/ true\n+    }\n+\n+    public boolean testNotEq24_2(MyValue1 v, MyInterface u) {\n+        return (Object)v != getNotNull(u); \/\/ true\n+    }\n+\n+    public boolean testNotEq24_3(MyValue1 v, MyInterface u) {\n+        return getNotNull(v) != getNotNull(u); \/\/ true\n+    }\n+\n+    public boolean testNotEq24_4(MyValue1 v, MyAbstract u) {\n+        return getNotNull(v) != u; \/\/ true\n+    }\n+\n+    public boolean testNotEq24_5(MyValue1 v, MyAbstract u) {\n+        return (Object)v != getNotNull(u); \/\/ true\n+    }\n+\n+    public boolean testNotEq24_6(MyValue1 v, MyAbstract u) {\n+        return getNotNull(v) != getNotNull(u); \/\/ true\n+    }\n+\n+    public boolean testNotEq25_1(MyInterface u, MyValue1 v) {\n+        return getNotNull(u) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq25_2(MyInterface u, MyValue1 v) {\n+        return u != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq25_3(MyInterface u, MyValue1 v) {\n+        return getNotNull(u) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq25_4(MyAbstract u, MyValue1 v) {\n+        return getNotNull(u) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq25_5(MyAbstract u, MyValue1 v) {\n+        return u != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq25_6(MyAbstract u, MyValue1 v) {\n+        return getNotNull(u) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq26_1(MyInterface u, MyObject o) {\n+        return get(u) != o; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq26_2(MyInterface u, MyObject o) {\n+        return u != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq26_3(MyInterface u, MyObject o) {\n+        return get(u) != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq26_4(MyAbstract u, MyObject o) {\n+        return get(u) != o; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq26_5(MyAbstract u, MyObject o) {\n+        return u != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq26_6(MyAbstract u, MyObject o) {\n+        return get(u) != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq27_1(MyObject o, MyInterface u) {\n+        return get(o) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq27_2(MyObject o, MyInterface u) {\n+        return o != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq27_3(MyObject o, MyInterface u) {\n+        return get(o) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq27_4(MyObject o, MyAbstract u) {\n+        return get(o) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq27_5(MyObject o, MyAbstract u) {\n+        return o != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq27_6(MyObject o, MyAbstract u) {\n+        return get(o) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq28_1(MyInterface[] a, MyInterface u) {\n+        return get(a) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq28_2(MyInterface[] a, MyInterface u) {\n+        return a != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq28_3(MyInterface[] a, MyInterface u) {\n+        return get(a) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq28_4(MyAbstract[] a, MyAbstract u) {\n+        return get(a) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq28_5(MyAbstract[] a, MyAbstract u) {\n+        return a != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq28_6(MyAbstract[] a, MyAbstract u) {\n+        return get(a) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq29_1(MyInterface u, MyInterface[] a) {\n+        return get(u) != a; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq29_2(MyInterface u, MyInterface[] a) {\n+        return u != get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq29_3(MyInterface u, MyInterface[] a) {\n+        return get(u) != get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq29_4(MyAbstract u, MyAbstract[] a) {\n+        return get(u) != a; \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq29_5(MyAbstract u, MyAbstract[] a) {\n+        return u != get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq29_6(MyAbstract u, MyAbstract[] a) {\n+        return get(u) != get(a); \/\/ old acmp\n+    }\n+\n+    public boolean testNotEq30_1(MyInterface[] a, MyValue1 v) {\n+        return get(a) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq30_2(MyInterface[] a, MyValue1 v) {\n+        return a != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq30_3(MyInterface[] a, MyValue1 v) {\n+        return get(a) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq30_4(MyAbstract[] a, MyValue1 v) {\n+        return get(a) != (Object)v; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq30_5(MyAbstract[] a, MyValue1 v) {\n+        return a != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq30_6(MyAbstract[] a, MyValue1 v) {\n+        return get(a) != get(v); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq31_1(MyValue1 v, MyInterface[] a) {\n+        return get(v) != a; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq31_2(MyValue1 v, MyInterface[] a) {\n+        return (Object)v != get(a); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq31_3(MyValue1 v, MyInterface[] a) {\n+        return get(v) != get(a); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq31_4(MyValue1 v, MyAbstract[] a) {\n+        return get(v) != a; \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq31_5(MyValue1 v, MyAbstract[] a) {\n+        return (Object)v != get(a); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq31_6(MyValue1 v, MyAbstract[] a) {\n+        return get(v) != get(a); \/\/ only false if both null\n+    }\n+\n+    public boolean testNotEq32_1(MyInterface[] a, MyValue1 v) {\n+        return getNotNull(a) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq32_2(MyInterface[] a, MyValue1 v) {\n+        return a != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq32_3(MyInterface[] a, MyValue1 v) {\n+        return getNotNull(a) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq32_4(MyAbstract[] a, MyValue1 v) {\n+        return getNotNull(a) != (Object)v; \/\/ true\n+    }\n+\n+    public boolean testNotEq32_5(MyAbstract[] a, MyValue1 v) {\n+        return a != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq32_6(MyAbstract[] a, MyValue1 v) {\n+        return getNotNull(a) != getNotNull(v); \/\/ true\n+    }\n+\n+    public boolean testNotEq33_1(MyValue1 v, MyInterface[] a) {\n+        return getNotNull(v) != a; \/\/ true\n+    }\n+\n+    public boolean testNotEq33_2(MyValue1 v, MyInterface[] a) {\n+        return (Object)v != getNotNull(a); \/\/ true\n+    }\n+\n+    public boolean testNotEq33_3(MyValue1 v, MyInterface[] a) {\n+        return getNotNull(v) != getNotNull(a); \/\/ true\n+    }\n+\n+    public boolean testNotEq33_4(MyValue1 v, MyAbstract[] a) {\n+        return getNotNull(v) != a; \/\/ true\n+    }\n+\n+    public boolean testNotEq33_5(MyValue1 v, MyAbstract[] a) {\n+        return (Object)v != getNotNull(a); \/\/ true\n+    }\n+\n+    public boolean testNotEq33_6(MyValue1 v, MyAbstract[] a) {\n+        return getNotNull(v) != getNotNull(a); \/\/ true\n+    }\n+\n+    \/\/ Null tests\n+\n+    public boolean testNotNull01_1(MyValue1 v) {\n+        return (Object)v != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull01_2(MyValue1 v) {\n+        return get(v) != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull01_3(MyValue1 v) {\n+        return (Object)v != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull01_4(MyValue1 v) {\n+        return get(v) != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull02_1(MyValue1 v) {\n+        return null != (Object)v; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull02_2(MyValue1 v) {\n+        return get((Object)null) != (Object)v; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull02_3(MyValue1 v) {\n+        return null != get(v); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull02_4(MyValue1 v) {\n+        return get((Object)null) != get(v); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull03_1(Object u) {\n+        return u != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull03_2(Object u) {\n+        return get(u) != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull03_3(Object u) {\n+        return u != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull03_4(Object u) {\n+        return get(u) != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull04_1(Object u) {\n+        return null != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull04_2(Object u) {\n+        return get((Object)null) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull04_3(Object u) {\n+        return null != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull04_4(Object u) {\n+        return get((Object)null) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull05_1(MyObject o) {\n+        return o != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull05_2(MyObject o) {\n+        return get(o) != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull05_3(MyObject o) {\n+        return o != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull05_4(MyObject o) {\n+        return get(o) != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull06_1(MyObject o) {\n+        return null != o; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull06_2(MyObject o) {\n+        return get((Object)null) != o; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull06_3(MyObject o) {\n+        return null != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull06_4(MyObject o) {\n+        return get((Object)null) != get(o); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_1(MyInterface u) {\n+        return u != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_2(MyInterface u) {\n+        return get(u) != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_3(MyInterface u) {\n+        return u != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_4(MyInterface u) {\n+        return get(u) != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_5(MyAbstract u) {\n+        return u != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_6(MyAbstract u) {\n+        return get(u) != null; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_7(MyAbstract u) {\n+        return u != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull07_8(MyAbstract u) {\n+        return get(u) != get((Object)null); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_1(MyInterface u) {\n+        return null != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_2(MyInterface u) {\n+        return get((Object)null) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_3(MyInterface u) {\n+        return null != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_4(MyInterface u) {\n+        return get((Object)null) != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_5(MyAbstract u) {\n+        return null != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_6(MyAbstract u) {\n+        return get((Object)null) != u; \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_7(MyAbstract u) {\n+        return null != get(u); \/\/ old acmp\n+    }\n+\n+    public boolean testNotNull08_8(MyAbstract u) {\n+        return get((Object)null) != get(u); \/\/ old acmp\n+    }\n+\n+    \/\/ The following methods are used with -XX:+AlwaysIncrementalInline to hide exact types during parsing\n+\n+    public Object get(Object u) {\n+        return u;\n+    }\n+\n+    public Object getNotNull(Object u) {\n+        return (u != null) ? u : new Object();\n+    }\n+\n+    public Object get(MyValue1 v) {\n+        return v;\n+    }\n+\n+    public Object getNotNull(MyValue1 v) {\n+        return ((Object)v != null) ? v : MyValue1.createDefault();\n+    }\n+\n+    public Object get(MyObject o) {\n+        return o;\n+    }\n+\n+    public Object getNotNull(MyObject o) {\n+        return (o != null) ? o : MyValue1.createDefault();\n+    }\n+\n+    public Object get(Object[] a) {\n+        return a;\n+    }\n+\n+    public Object getNotNull(Object[] a) {\n+        return (a != null) ? a : new Object[1];\n+    }\n+\n+    public boolean trueIfNull(Method m) {\n+        return m.isAnnotationPresent(TrueIfNull.class);\n+    }\n+\n+    public boolean falseIfNull(Method m) {\n+        return m.isAnnotationPresent(FalseIfNull.class);\n+    }\n+\n+    public boolean isNegated(Method m) {\n+        return m.getName().startsWith(\"testNot\");\n+    }\n+\n+    \/\/ Tests with profiling\n+    public boolean cmpAlwaysEqual1(Object a, Object b) {\n+        return a == b;\n+    }\n+\n+    public boolean cmpAlwaysEqual2(Object a, Object b) {\n+        return a != b;\n+    }\n+\n+    public boolean cmpAlwaysEqual3(Object a) {\n+        return a == a;\n+    }\n+\n+    public boolean cmpAlwaysEqual4(Object a) {\n+        return a != a;\n+    }\n+\n+    public boolean cmpAlwaysUnEqual1(Object a, Object b) {\n+        return a == b;\n+    }\n+\n+    public boolean cmpAlwaysUnEqual2(Object a, Object b) {\n+        return a != b;\n+    }\n+\n+    public boolean cmpAlwaysUnEqual3(Object a) {\n+        return a == a;\n+    }\n+\n+    public boolean cmpAlwaysUnEqual4(Object a) {\n+        return a != a;\n+    }\n+\n+    public boolean cmpSometimesEqual1(Object a) {\n+        return a == a;\n+    }\n+\n+    public boolean cmpSometimesEqual2(Object a) {\n+        return a != a;\n+    }\n+\n+    static int get_full_opt_level() {\n+        int n = (int)TieredStopAtLevel;\n+        if (n >= 4) {\n+            n = 4;\n+        }\n+        return n;\n+    }\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    protected static final long TieredStopAtLevel = (Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\");\n+    protected static final int COMP_LEVEL_FULL_OPTIMIZATION = get_full_opt_level();\n+\n+    public void runTest(Method m, Object[] args, int warmup, int nullMode, boolean[][] equalities) throws Exception {\n+        Class<?>[] parameterTypes = m.getParameterTypes();\n+        int parameterCount = parameterTypes.length;\n+        \/\/ Nullness mode for first argument\n+        \/\/ 0: default, 1: never null, 2: always null\n+        int start = (nullMode != 1) ? 0 : 1;\n+        int end = (nullMode != 2) ? args.length : 1;\n+        for (int i = start; i < end; ++i) {\n+            if (args[i] != null && !parameterTypes[0].isInstance(args[i])) {\n+                continue;\n+            }\n+            if (args[i] == null && parameterTypes[0] == MyValue1.class.asValueType()) {\n+                continue;\n+            }\n+            if (parameterCount == 1) {\n+                \/\/ Null checks\n+                System.out.print(\"Testing \" + m.getName() + \"(\" + args[i] + \")\");\n+                \/\/ Avoid acmp in the computation of the expected result!\n+                boolean expected = isNegated(m) ? (i != 0) : (i == 0);\n+                for (int run = 0; run < warmup; ++run) {\n+                    Boolean result = (Boolean)m.invoke(this, args[i]);\n+                    if (result != expected && WHITE_BOX.isMethodCompiled(m, false)) {\n+                        System.out.println(\" = \" + result);\n+                        throw new RuntimeException(\"Test failed: should return \" + expected);\n+                    }\n+                }\n+                System.out.println(\" = \" + expected);\n+            } else {\n+                \/\/ Equality checks\n+                for (int j = 0; j < args.length; ++j) {\n+                    if (args[j] != null && !parameterTypes[1].isInstance(args[j])) {\n+                        continue;\n+                    }\n+                    if (args[j] == null && parameterTypes[1] == MyValue1.class.asValueType()) {\n+                        continue;\n+                    }\n+                    System.out.print(\"Testing \" + m.getName() + \"(\" + args[i] + \", \" + args[j] + \")\");\n+                    \/\/ Avoid acmp in the computation of the expected result!\n+                    boolean equal = equalities[i][j];\n+                    equal = isNegated(m) ? !equal : equal;\n+                    boolean expected = ((i == 0 || j == 0) && trueIfNull(m)) || (equal && !(i == 0 && falseIfNull(m)));\n+                    for (int run = 0; run < warmup; ++run) {\n+                        Boolean result = (Boolean)m.invoke(this, args[i], args[j]);\n+                        if (result != expected && WHITE_BOX.isMethodCompiled(m, false) && warmup == 1) {\n+                            System.out.println(\" = \" + result);\n+                            throw new RuntimeException(\"Test failed: should return \" + expected);\n+                        }\n+                    }\n+                    System.out.println(\" = \" + expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void run(int nullMode) throws Exception {\n+        \/\/ Prepare test arguments\n+        Object[] args =  { null,\n+                           new Object(),\n+                           new MyObject(),\n+                           MyValue1.setX(MyValue1.createDefault(), 42),\n+                           new Object[10],\n+                           new MyObject[10],\n+                           MyValue1.setX(MyValue1.createDefault(), 0x42),\n+                           MyValue1.setX(MyValue1.createDefault(), 42),\n+                           MyValue2.setX(MyValue2.createDefault(), 42), };\n+\n+        boolean[][] equalities = { { true,  false, false, false, false, false, false, false, false },\n+                                   { false, true,  false, false, false, false, false, false, false },\n+                                   { false, false, true,  false, false, false, false, false, false },\n+                                   { false, false, false, true,  false, false, false, true,  false },\n+                                   { false, false, false, false, true,  false, false, false, false },\n+                                   { false, false, false, false, false, true,  false, false, false },\n+                                   { false, false, false, false, false, false, true,  false, false },\n+                                   { false, false, false, true,  false, false, false, true,  false },\n+                                   { false, false, false, false, false, false, false, false, true  } };\n+\n+        \/\/ Run tests\n+        for (Method m : getClass().getMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                \/\/ Do some warmup runs\n+                runTest(m, args, 1000, nullMode, equalities);\n+                \/\/ Make sure method is compiled\n+                TestFramework.compile(m, CompLevel.ANY);\n+                Asserts.assertTrue(WHITE_BOX.isMethodCompiled(m, false), m + \" not compiled\");\n+                \/\/ Run again to verify correctness of compiled code\n+                runTest(m, args, 1, nullMode, equalities);\n+            }\n+        }\n+\n+        Method cmpAlwaysUnEqual3_m = getClass().getMethod(\"cmpAlwaysUnEqual3\", Object.class);\n+        Method cmpAlwaysUnEqual4_m = getClass().getMethod(\"cmpAlwaysUnEqual4\", Object.class);\n+        Method cmpSometimesEqual1_m = getClass().getMethod(\"cmpSometimesEqual1\", Object.class);\n+        Method cmpSometimesEqual2_m = getClass().getMethod(\"cmpSometimesEqual2\", Object.class);\n+\n+        for (int i = 0; i < 20_000; ++i) {\n+            Asserts.assertTrue(cmpAlwaysEqual1(args[1], args[1]));\n+            Asserts.assertFalse(cmpAlwaysEqual2(args[1], args[1]));\n+            Asserts.assertTrue(cmpAlwaysEqual3(args[1]));\n+            Asserts.assertFalse(cmpAlwaysEqual4(args[1]));\n+\n+            Asserts.assertFalse(cmpAlwaysUnEqual1(args[1], args[2]));\n+            Asserts.assertTrue(cmpAlwaysUnEqual2(args[1], args[2]));\n+            boolean res = cmpAlwaysUnEqual3(args[3]);\n+            Asserts.assertTrue(res);\n+            res = cmpAlwaysUnEqual4(args[3]);\n+            Asserts.assertFalse(res);\n+\n+            int idx = i % args.length;\n+            res = cmpSometimesEqual1(args[idx]);\n+            Asserts.assertTrue(res);\n+            res = cmpSometimesEqual2(args[idx]);\n+            Asserts.assertFalse(res);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            enumerateVMOptions();\n+        } else {\n+            int nullMode = Integer.valueOf(args[0]);\n+            TestNewAcmp t = new TestNewAcmp();\n+            t.run(nullMode);\n+        }\n+    }\n+\n+    private static String[] addOptions(String prefix[], String... extra) {\n+        ArrayList<String> list = new ArrayList<String>();\n+        if (prefix != null) {\n+            for (String s : prefix) {\n+                list.add(s);\n+            }\n+        }\n+        if (extra != null) {\n+            for (String s : extra) {\n+                System.out.println(\"    \" + s);\n+                list.add(s);\n+            }\n+        }\n+\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    private static void enumerateVMOptions() throws Exception {\n+        String[] baseOptions = {\n+            \"-Xbootclasspath\/a:.\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xbatch\",\n+            \"-XX:TypeProfileLevel=222\",\n+            \"-XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestNewAcmp::test*\",\n+            \"-XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestNewAcmp::cmp*\"};\n+\n+        String SCENARIOS = System.getProperty(\"Scenarios\", \"\");\n+        List<String> scenarios = null;\n+        if (!SCENARIOS.isEmpty()) {\n+           scenarios = Arrays.asList(SCENARIOS.split(\",\"));\n+        }\n+\n+        int scenario = -1;\n+        for (int nullMode = 0; nullMode <= 2; nullMode++) {          \/\/ null mode\n+            for (int incrInline = 0; incrInline < 2; incrInline++) { \/\/ 0 = default, 1 = -XX:+AlwaysIncrementalInline\n+                scenario++;\n+                System.out.println(\"Scenario #\" + scenario + \" -------------------\");\n+                String[] cmds = baseOptions;\n+                if (incrInline != 0) {\n+                    cmds = addOptions(cmds, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlwaysIncrementalInline\");\n+                }\n+\n+                cmds = addOptions(cmds, \"compiler.valhalla.inlinetypes.TestNewAcmp\");\n+                cmds = addOptions(cmds, Integer.toString(nullMode));\n+\n+                if (scenarios != null && !scenarios.contains(Integer.toString(scenario))) {\n+                    System.out.println(\"Scenario #\" + scenario + \" is skipped due to -Dscenarios=\" + SCENARIOS);\n+                    continue;\n+                }\n+\n+                OutputAnalyzer oa = ProcessTools.executeTestJvm(cmds);\n+                String output = oa.getOutput();\n+                oa.shouldHaveExitValue(0);\n+                System.out.println(output);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNewAcmp.java","additions":1910,"deletions":0,"binary":false,"changes":1910,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275825 8289686\n+ * @summary Verify that trivial accessor methods operating on an inline type\n+ *          field are C2 compiled to enable scalarization of the arg\/return value.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @compile TestTrivialMethods.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields\n+ *                   -XX:CompileCommand=dontinline,*::getter* -XX:CompileCommand=dontinline,*::setter*\n+ *                   compiler.valhalla.inlinetypes.TestTrivialMethods\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestTrivialMethods {\n+    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    static MyValue3 staticField = MyValue3.create();\n+    static MyValue3.ref staticFieldRef = MyValue3.create();\n+    MyValue3 field = MyValue3.create();\n+    MyValue3.ref fieldRef = MyValue3.create();\n+    Object objField = null;\n+\n+    public MyValue3 getter1() {\n+        return staticField;\n+    }\n+\n+    public static MyValue3 getter2() {\n+        return staticField;\n+    }\n+\n+    public MyValue3 getter3() {\n+        return field;\n+    }\n+\n+    public Object getter4(MyValue3 unusedArg) {\n+        return objField;\n+    }\n+\n+    public int constantGetter(MyValue3 unusedArg) {\n+        return 0;\n+    }\n+\n+    public MyValue3.ref getter1Ref() {\n+        return staticFieldRef;\n+    }\n+\n+    public static MyValue3.ref getter2Ref() {\n+        return staticFieldRef;\n+    }\n+\n+    public MyValue3.ref getter3Ref() {\n+        return fieldRef;\n+    }\n+\n+    public Object getter4Ref(MyValue3.ref unusedArg) {\n+        return objField;\n+    }\n+\n+    public int constantGetterRef(MyValue3.ref unusedArg) {\n+        return 0;\n+    }\n+\n+    public void setter1(MyValue3 val) {\n+        staticField = val;\n+    }\n+\n+    public static void setter2(MyValue3 val) {\n+        staticField = val;\n+    }\n+\n+    public void setter3(MyValue3 val) {\n+        field = val;\n+    }\n+\n+    public void setter1Ref(MyValue3.ref val) {\n+        staticFieldRef = val;\n+    }\n+\n+    public static void setter2Ref(MyValue3.ref val) {\n+        staticFieldRef = val;\n+    }\n+\n+    public void setter3Ref(MyValue3.ref val) {\n+        fieldRef = val;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        TestTrivialMethods t = new TestTrivialMethods();\n+        \/\/ Warmup to trigger compilation\n+        for (int i = 0; i < 100_000; ++i) {\n+            t.getter1();\n+            t.getter2();\n+            t.getter3();\n+            t.getter4(staticField);\n+            t.constantGetter(staticField);\n+            t.getter1Ref();\n+            t.getter2Ref();\n+            t.getter3Ref();\n+            t.getter3Ref();\n+            t.getter4Ref(null);\n+            t.constantGetterRef(null);\n+            t.setter1(staticField);\n+            t.setter2(staticField);\n+            t.setter3(staticField);\n+            t.setter1Ref(staticField);\n+            t.setter2Ref(staticField);\n+            t.setter3Ref(staticField);\n+        }\n+        Method m = TestTrivialMethods.class.getMethod(\"getter1\");\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter1 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter2\");\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter2 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter3\");\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter3 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter4\", MyValue3.class.asValueType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter4 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"constantGetter\", MyValue3.class.asValueType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"constantGetter is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter1Ref\");\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter1Ref is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter2Ref\");\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter2Ref is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter3Ref\");\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter3Ref is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"getter4Ref\", MyValue3.class.asPrimaryType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"getter4Ref is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"constantGetterRef\", MyValue3.class.asPrimaryType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"constantGetterRef is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"setter1\", MyValue3.class.asValueType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter1 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"setter2\", MyValue3.class.asValueType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter2 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"setter3\", MyValue3.class.asValueType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter3 is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"setter1Ref\", MyValue3.class.asPrimaryType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter1Ref is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"setter2Ref\", MyValue3.class.asPrimaryType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter2Ref is not C2 compiled\");\n+        m = TestTrivialMethods.class.getMethod(\"setter3Ref\", MyValue3.class.asPrimaryType());\n+        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter3Ref is not C2 compiled\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTrivialMethods.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test scalarization in returns with unloaded return types.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::test*\n+ *                   TestUnloadedReturnTypes\n+ *\/\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+primitive class MyPrimitive {\n+    int x;\n+\n+    public MyPrimitive(int x) {\n+        this.x = x;\n+    }\n+}\n+\n+value class MyValue {\n+    int x;\n+\n+    public MyValue(int x) {\n+        this.x = x;\n+    }\n+}\n+\n+class MyClass {\n+\n+    static MyPrimitive test1() {\n+        return new MyPrimitive(42);\n+    }\n+\n+    static MyPrimitive.ref test2(boolean b) {\n+        return b ? new MyPrimitive(42) : null;\n+    }\n+\n+    static MyValue test3(boolean b) {\n+        return b ? new MyValue(42) : null;\n+    }\n+}\n+\n+public class TestUnloadedReturnTypes {\n+    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    static Object res1 = null;\n+\n+    public static void test1() {\n+        res1 = MyClass.test1();\n+    }\n+\n+    static Object res2 = null;\n+\n+    public static void test2(boolean b) {\n+        res2 = MyClass.test2(b);\n+    }\n+\n+    static Object res3 = null;\n+\n+    public static void test3(boolean b) {\n+        res3 = MyClass.test3(b);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ C1 compile all caller methods\n+        Method m = TestUnloadedReturnTypes.class.getMethod(\"test1\");\n+        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n+\n+        m = TestUnloadedReturnTypes.class.getMethod(\"test2\", boolean.class);\n+        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n+\n+        m = TestUnloadedReturnTypes.class.getMethod(\"test3\", boolean.class);\n+        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n+\n+        \/\/ Make sure the callee methods are C2 compiled\n+        for (int i = 0; i < 100_000; ++i) {\n+            MyClass.test1();\n+            MyClass.test2((i % 2) == 0);\n+            MyClass.test3((i % 2) == 0);\n+        }\n+\n+        test1();\n+        if (((MyPrimitive)res1).x != 42) {\n+            throw new RuntimeException(\"Test1 failed\");\n+        }\n+\n+        test2(true);\n+        if (((MyPrimitive)res2).x != 42) {\n+            throw new RuntimeException(\"Test2 failed\");\n+        }\n+\n+        test2(false);\n+        if (res2 != null) {\n+            throw new RuntimeException(\"Test2 failed\");\n+        }\n+        test3(true);\n+        if (((MyValue)res3).x != 42) {\n+            throw new RuntimeException(\"Test3 failed\");\n+        }\n+\n+        test3(false);\n+        if (res3 != null) {\n+            throw new RuntimeException(\"Test3 failed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedReturnTypes.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler\/valhalla\/inlinetypes;\n+\n+public final primitive value class FooValue\n+    version 64:0\n+{\n+    public final Field x:I;\n+    public final Field y:I;\n+\n+    \/\/ escape with putstatic\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test1:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; putstatic TestWithfieldC1.foo_static:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape with putfield\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test2:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_1;\n+        aload_1; iconst_1; withfield FooValue.x:I; astore_1;\n+        aload_1; iconst_1; withfield FooValue.y:I; astore_1;\n+\n+        aload_0; aload_1; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_1; areturn;\n+    }\n+\n+    \/\/ escape with function call\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test3:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape and then branch backwards\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test4:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        iconst_1; istore_1;\n+\n+        loop: stack_frame_type append; locals_map class \"Qcompiler\/valhalla\/inlinetypes\/FooValue;\", int;\n+            \/\/ iterate two times\n+            iload_1; iconst_2; if_icmpgt end;\n+\n+            aload_0; iload_1; withfield x:I; astore_0;\n+            aload_0; iload_1; withfield y:I; astore_0;\n+\n+            aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+            iinc 1,1; goto loop;\n+\n+        end: stack_frame_type same;\n+            aload_0; areturn;\n+    }\n+\n+    \/\/ escape using a different local variable\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test5:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        aconst_init FooValue; astore_1;\n+        aload_0; astore_1;\n+\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_1; areturn;\n+    }\n+\n+    \/\/ escape using aastore\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test6:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 3 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        getstatic TestWithfieldC1.foo_static_arr:\"[Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+        iconst_0; aload_0; aastore;\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ Copying a value into different local slots -- disable withfield optimization\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test7:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        aconst_init FooValue; astore_1;\n+        aload_0; astore_1;\n+\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape by invoking non-static method\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test8:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokevirtual non_static_method:\"()V\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    @+compiler\/lib\/ir_framework\/DontInline{}\n+    private Method non_static_method:\"()V\" stack 1 {\n+        aload_0;\n+        invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+        return;\n+    }\n+\n+    \/\/ duplicate reference with local variables\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test9:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 3 {\n+        aconst_init FooValue; astore_1;\n+        aload_1; iconst_1; withfield x:I; astore_1;\n+        aload_1; iconst_1; withfield y:I; astore_1;\n+\n+        aload_1; astore_2;\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_2; iconst_3; withfield x:I; astore_2;\n+        aload_2; iconst_3; withfield y:I; astore_2;\n+\n+        aload_0; aload_2; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_1; areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1Classes.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8280006\n+ * @summary Test that field flattening works as expected if primitive classes of\n+ *          holder and field were loaded by different class loaders (bootstrap + app).\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox TestBootClassloader InstallBootstrapClasses\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver InstallBootstrapClasses\n+ * @run main\/othervm -Xbootclasspath\/a:boot -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:CompileCommand=compileonly,TestBootClassloader::test*\n+ *                   -XX:CompileCommand=inline,*::get* TestBootClassloader\n+ *\/\n+\n+public class TestBootClassloader {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static final int COMP_LEVEL_FULL_OPTIMIZATION = 4;\n+\n+    static primitive class Wrapper1 {\n+        ValueOnBootclasspath val; \/\/ Type will be loaded by boot classloader\n+\n+        public Wrapper1(ValueOnBootclasspath val) {\n+            this.val = val;\n+        }\n+\n+        Object get() {\n+            return val.get();\n+        }\n+    }\n+\n+    static primitive class Wrapper2 {\n+        Wrapper1 val;\n+\n+        public Wrapper2(Wrapper1 val) {\n+            this.val = val;\n+        }\n+\n+        Object get() {\n+            return val.get();\n+        }\n+    }\n+\n+    static Object test1(Wrapper1 w) {\n+        return w.get();\n+    }\n+\n+    static Object test2(Wrapper2 w) {\n+        return w.get();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Wrapper1 wrapper1 = new Wrapper1(new ValueOnBootclasspath());\n+        Wrapper2 wrapper2 = new Wrapper2(wrapper1);\n+        for (int i = 0; i < 50_000; ++i) {\n+            test1(wrapper1);\n+            test2(wrapper2);\n+        }\n+        Method method = TestBootClassloader.class.getDeclaredMethod(\"test1\", Wrapper1.class.asValueType());\n+        Asserts.assertTrue(WB.isMethodCompilable(method, COMP_LEVEL_FULL_OPTIMIZATION, false), \"Test1 method not compilable\");\n+        Asserts.assertTrue(WB.isMethodCompiled(method), \"Test1 method not compiled\");\n+\n+        method = TestBootClassloader.class.getDeclaredMethod(\"test2\", Wrapper2.class.asValueType());\n+        Asserts.assertTrue(WB.isMethodCompilable(method, COMP_LEVEL_FULL_OPTIMIZATION, false), \"Test2 method not compilable\");\n+        Asserts.assertTrue(WB.isMethodCompiled(method), \"Test2 method not compiled\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/bootstrap\/TestBootClassloader.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -168,1 +168,1 @@\n-        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s*\\\\[Verified Entry Point\\\\]\\\\s*  # \\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n+        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s[^{]+\\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Use Lookup.defineClass() to load a class with rewritten bytecode. Make sure\n+ *          the archived class with the same name is not loaded.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/RewriteBytecodesInline.java test-classes\/Util.java test-classes\/Point.java test-classes\/WithInlinedField.java\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver RewriteBytecodesInlineTest\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class RewriteBytecodesInlineTest {\n+  public static void main(String[] args) throws Exception {\n+    String wbJar = JarBuilder.build(true, \"WhiteBox\", \"jdk\/test\/whitebox\/WhiteBox\");\n+    String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+\n+    String appJar = JarBuilder.build(\"dynamic_define\", \"RewriteBytecodesInline\", \"Util\", \"Point\", \"WithInlinedField\");\n+    String superClsFile = (new File(System.getProperty(\"test.classes\", \".\"), \"Point.class\")).getPath();\n+\n+    TestCommon.dump(appJar, TestCommon.list(\"RewriteBytecodesInline\", \"Point\", \"WithInlinedField\"),\n+                    \/\/ command-line arguments ...\n+                    use_whitebox_jar);\n+\n+    OutputAnalyzer output = TestCommon.exec(appJar,\n+                    \/\/ command-line arguments ...\n+                    use_whitebox_jar,\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:+WhiteBoxAPI\",\n+                    \"RewriteBytecodesInline\", superClsFile);\n+    TestCommon.checkExec(output);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/RewriteBytecodesInlineTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- * @build Hello\n+ * @build HelloRelocation\n@@ -35,1 +35,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar HelloRelocation HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Rectangle\n@@ -81,1 +81,1 @@\n-        String mainClass = \"Hello\";\n+        String mainClass = \"HelloRelocation\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveRelocationTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Hello World test for dynamic archive\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build HelloInlineClassApp\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello_inline.jar HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Rectangle\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. HelloDynamicInlineClass\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class HelloDynamicInlineClass extends DynamicArchiveTestBase {\n+    public static void main(String[] args) throws Exception {\n+        runTest(HelloDynamicInlineClass::testDefaultBase);\n+        runTest(HelloDynamicInlineClass::testCustomBase);\n+    }\n+\n+    \/\/ (1) Test with default base archive + top archive\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(null, topArchiveName);\n+    }\n+\n+    \/\/ (2) Test with custom base archive + top archive\n+    static void testCustomBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top2\");\n+        String baseArchiveName = getNewArchiveName(\"base\");\n+        TestCommon.dumpBaseArchive(baseArchiveName);\n+        doTest(baseArchiveName, topArchiveName);\n+    }\n+\n+    private static void doTest(String baseArchiveName, String topArchiveName) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"hello_inline.jar\");\n+        String mainClass = \"HelloInlineClassApp\";\n+        dump2(baseArchiveName, topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+        run2(baseArchiveName, topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"HelloInlineClassApp$Point source: shared objects file\")\n+                          .shouldHaveExitValue(0);\n+              });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicInlineClass.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.lang.invoke.MethodHandles;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class RewriteBytecodesInline {\n+  public static void main(String args[]) throws Throwable {\n+    String from = \"___xxx___\";\n+    String to   = \"___yyy___\";\n+    File clsFile = new File(args[0]);\n+    Class fieldClass = Util.defineModifiedClass(MethodHandles.lookup(), clsFile, from, to);\n+\n+    WithInlinedField wif = new WithInlinedField();\n+\n+    if (wif.p.getClass() != fieldClass) {\n+      throw new RuntimeException(\"Mismatched field class\");\n+    }\n+\n+    \/\/ Even if the Point class is not loaded from the CDS archive, make sure the WithInlinedField class\n+    \/\/ can still be loaded successfully, and properly get the rewritten version of Point.\n+    \/\/ The archived version of WithInlinedField must not be loaded, because it references the archived\n+    \/\/ version of Point, but a different version of Point has been loaded.\n+\n+    if (!wif.p.msg().equals(to)) {\n+      throw new RuntimeException(\"Wrong output, expected: \" + to + \", but got: \" + wif.p.msg());\n+    }\n+\n+    WhiteBox wb = WhiteBox.getWhiteBox();\n+    if (wb.isSharedClass(fieldClass)) {\n+      throw new RuntimeException(\"wb.isSharedClass(superClass) should be false\");\n+    }\n+    if (wb.isSharedClass(wif.p.getClass())) {\n+      throw new RuntimeException(\"wb.isSharedClass(child.getClass()) should be false\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/RewriteBytecodesInline.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ These classes are based on the following source.  The return type of factory\n+\/\/ method <init> in class HiddenPoint was changed to java.lang.Object because\n+\/\/ HiddenPoint will be defined as an inline hidden class.\n+\/\/\n+\/\/  inline class HiddenPoint {\n+\/\/      int x;\n+\/\/      int y;\n+\/\/\n+\/\/      HiddenPoint() {\n+\/\/          this.x = 0;\n+\/\/          this.y = 0;\n+\/\/      }\n+\/\/      public String getValue() {\n+\/\/          return \"x: \" + x + \", y: \" + y;\n+\/\/      }\n+\/\/  }\n+\n+class HiddenPoint {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [40] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"HiddenPoint\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1B\n+    NameAndType #5 #6; \/\/ #4     at 0x20\n+    Utf8 \"x\"; \/\/ #5     at 0x25\n+    Utf8 \"I\"; \/\/ #6     at 0x29\n+    Field #1 #8; \/\/ #7     at 0x2D\n+    NameAndType #9 #6; \/\/ #8     at 0x32\n+    Utf8 \"y\"; \/\/ #9     at 0x37\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x3B\n+    NameAndType #12 #13; \/\/ #11     at 0x40\n+    Utf8 \"makeConcatWithConstants\"; \/\/ #12     at 0x45\n+    Utf8 \"(II)Ljava\/lang\/String;\"; \/\/ #13     at 0x5F\n+    class #15; \/\/ #14     at 0x78\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15     at 0x7B\n+    Utf8 \"getValue\"; \/\/ #16     at 0x8E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #17     at 0x99\n+    Utf8 \"Code\"; \/\/ #18     at 0xB0\n+    Utf8 \"LineNumberTable\"; \/\/ #19     at 0xB7\n+    Utf8 \"<init>\"; \/\/ #20     at 0xC9\n+    Utf8 \"()Ljava\/lang\/Object;\"; \/\/ #21     at 0xD2\n+    Utf8 \"SourceFile\"; \/\/ #22     at 0xE4\n+    Utf8 \"HiddenPoint.java\"; \/\/ #23     at 0xF1\n+    Utf8 \"BootstrapMethods\"; \/\/ #24     at 0x0104\n+    MethodHandle 6b #26; \/\/ #25     at 0x0117\n+    Method #27 #28; \/\/ #26     at 0x011B\n+    class #29; \/\/ #27     at 0x0120\n+    NameAndType #12 #30; \/\/ #28     at 0x0123\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\"; \/\/ #29     at 0x0128\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #30     at 0x014F\n+    String #32; \/\/ #31     at 0x01EA\n+    Utf8 \"x: , y: \"; \/\/ #32     at 0x01ED\n+    Utf8 \"InnerClasses\"; \/\/ #33     at 0x01FA\n+    class #35; \/\/ #34     at 0x0209\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #35     at 0x020C\n+    class #37; \/\/ #36     at 0x0234\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #37     at 0x0237\n+    Utf8 \"Lookup\"; \/\/ #38     at 0x0258\n+    Utf8 \"Preload\"; \/\/ #39     at 0x0261\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_VALUE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0x0275\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x027D\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index       : y\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0287\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index       : getValue\n+      #17; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#18, 38) { \/\/ Code at 0x028F\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[14]{\n+            0x2AB400032AB40007;\n+            0xBA000A0000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#19, 6) { \/\/ LineNumberTable at 0x02AF\n+              [1] { \/\/ line_number_table\n+                0  10; \/\/  at 0x02BB\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x02BB\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index       : <init>\n+      #21; \/\/ descriptor_index : ()LHiddenPoint;\n+      [1] { \/\/ Attributes\n+        Attr(#18, 56) { \/\/ Code at 0x02C3\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#19, 18) { \/\/ LineNumberTable at 0x02E9\n+              [4] { \/\/ line_number_table\n+                0  5; \/\/  at 0x02F5\n+                4  6; \/\/  at 0x02F9\n+                11  7; \/\/  at 0x02FD\n+                18  8; \/\/  at 0x0301\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#22, 2) { \/\/ SourceFile at 0x0303\n+      #23;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#24, 8) { \/\/ BootstrapMethods at 0x030B\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [1] { \/\/ bootstrap_arguments\n+            #31; \/\/  at 0x0319\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#33, 10) { \/\/ InnerClasses at 0x0319\n+      [1] { \/\/ classes\n+        #34 #36 #38 25; \/\/  at 0x0329\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#39, 4) { \/\/ Preload at 0x0329\n+      0x00010001;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class HiddenPoint\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,644 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.invoke.*;\n+import java.lang.ref.*;\n+import java.util.concurrent.*;\n+\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+\/**\n+ * @test InlineOops_int_Serial\n+ * @requires vm.gc.Serial\n+ * @summary Test embedding oops into Inline types\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile Person.java InlineOops.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -XX:+UseSerialGC -Xmx128m -XX:InlineFieldMaxFlatSize=128\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   runtime.valhalla.inlinetypes.InlineOops\n+ *\/\n+\n+\/**\n+ * @test InlineOops_int_G1\n+ * @requires vm.gc.G1\n+ * @summary Test embedding oops into Inline types\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile Person.java InlineOops.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -XX:+UseG1GC -Xmx128m -XX:InlineFieldMaxFlatSize=128\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   runtime.valhalla.inlinetypes.InlineOops 20\n+ *\/\n+\n+\/**\n+ * @test InlineOops_int_Parallel\n+ * @requires vm.gc.Parallel\n+ * @summary Test embedding oops into Inline types\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile Person.java InlineOops.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -XX:+UseParallelGC -Xmx128m -XX:InlineFieldMaxFlatSize=128\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   runtime.valhalla.inlinetypes.InlineOops\n+ *\/\n+\n+\/**\n+ * @test InlineOops_int_Z\n+ * @requires vm.gc.Z\n+ * @summary Test embedding oops into Inline types\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile Person.java InlineOops.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx128m\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews -XX:InlineFieldMaxFlatSize=128\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   runtime.valhalla.inlinetypes.InlineOops\n+ *\/\n+public class InlineOops {\n+\n+    \/\/ Extra debug: -XX:+VerifyOops -XX:+VerifyStack -XX:+VerifyLastFrame -XX:+VerifyBeforeGC -XX:+VerifyAfterGC -XX:+VerifyDuringGC -XX:VerifySubSet=threads,heap\n+    \/\/ Even more debugging: -XX:+TraceNewOopMapGeneration -Xlog:gc*=info\n+\n+    static final int NOF_PEOPLE = 10000; \/\/ Exercise arrays of this size\n+\n+    static int MIN_ACTIVE_GC_COUNT = 10; \/\/ Run active workload for this number of GC passes\n+\n+    static int MED_ACTIVE_GC_COUNT = 4;  \/\/ Medium life span in terms of GC passes\n+\n+    static final String TEST_STRING1 = \"Test String 1\";\n+    static final String TEST_STRING2 = \"Test String 2\";\n+\n+    static WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    static boolean USE_COMPILER = WB.getBooleanVMFlag(\"UseCompiler\");\n+\n+    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    public static void main(String[] args) {\n+        if (args.length > 0) {\n+            MIN_ACTIVE_GC_COUNT = Integer.parseInt(args[0]);\n+        }\n+        testClassLoad();\n+        testValues();\n+\n+        if (!USE_COMPILER) {\n+            testOopMaps();\n+        }\n+\n+        \/\/ Check we survive GC...\n+        testOverGc();   \/\/ Exercise root scan \/ oopMap\n+        testActiveGc(); \/\/ Brute force\n+    }\n+\n+    \/**\n+     * Test ClassFileParser can load inline types with reference fields\n+     *\/\n+    public static void testClassLoad() {\n+        String s = Person.class.toString();\n+        new Bar();\n+        new BarWithValue();\n+        s = BarValue.class.toString();\n+        s = ObjectWithObjectValue.class.toString();\n+        s = ObjectWithObjectValues.class.toString();\n+    }\n+\n+\n+    static class Couple {\n+        public Person onePerson;\n+        public Person otherPerson;\n+    }\n+\n+    static final primitive class Composition {\n+        public final Person onePerson;\n+        public final Person otherPerson;\n+\n+        public Composition(Person onePerson, Person otherPerson) {\n+            this.onePerson = onePerson;\n+            this.otherPerson = otherPerson;\n+        }\n+    }\n+\n+    \/**\n+     * Check inline type operations with \"Valhalla Inline Types\" (VVT)\n+     *\/\n+    public static void testValues() {\n+        \/\/ Exercise creation, getfield, vreturn with null refs\n+        validateDefaultPerson(createDefaultPerson());\n+\n+        \/\/ anewarray, aaload, aastore\n+        int index = 7;\n+        Person[] array =  new Person[NOF_PEOPLE];\n+        validateDefaultPerson(array[index]);\n+\n+        \/\/ Now with refs...\n+        validateIndexedPerson(createIndexedPerson(index), index);\n+        array[index] = createIndexedPerson(index);\n+        validateIndexedPerson(array[index], index);\n+\n+        \/\/ Check the neighbours\n+        validateDefaultPerson(array[index - 1]);\n+        validateDefaultPerson(array[index + 1]);\n+\n+        \/\/ getfield\/putfield\n+        Couple couple = new Couple();\n+        validateDefaultPerson(couple.onePerson);\n+        validateDefaultPerson(couple.otherPerson);\n+\n+        couple.onePerson = createIndexedPerson(index);\n+        validateIndexedPerson(couple.onePerson, index);\n+\n+        Composition composition = new Composition(couple.onePerson, couple.onePerson);\n+        validateIndexedPerson(composition.onePerson, index);\n+        validateIndexedPerson(composition.otherPerson, index);\n+    }\n+\n+    \/**\n+     * Check oop map generation for klass layout and frame...\n+     *\/\n+    public static void testOopMaps() {\n+        Object[] objects = WB.getObjectsViaKlassOopMaps(new Couple());\n+        assertTrue(objects.length == 4, \"Expected 4 oops\");\n+        for (int i = 0; i < objects.length; i++) {\n+            assertTrue(objects[i] == null, \"not-null\");\n+        }\n+\n+        String fn1 = \"Sam\";\n+        String ln1 = \"Smith\";\n+        String fn2 = \"Jane\";\n+        String ln2 = \"Jones\";\n+        Couple couple = new Couple();\n+        couple.onePerson = new Person(0, fn1, ln1);\n+        couple.otherPerson = new Person(1, fn2, ln2);\n+        objects = WB.getObjectsViaKlassOopMaps(couple);\n+        assertTrue(objects.length == 4, \"Expected 4 oops\");\n+        assertTrue(objects[0] == fn1, \"Bad oop fn1\");\n+        assertTrue(objects[1] == ln1, \"Bad oop ln1\");\n+        assertTrue(objects[2] == fn2, \"Bad oop fn2\");\n+        assertTrue(objects[3] == ln2, \"Bad oop ln2\");\n+\n+        objects = WB.getObjectsViaOopIterator(couple);\n+        assertTrue(objects.length == 4, \"Expected 4 oops\");\n+        assertTrue(objects[0] == fn1, \"Bad oop fn1\");\n+        assertTrue(objects[1] == ln1, \"Bad oop ln1\");\n+        assertTrue(objects[2] == fn2, \"Bad oop fn2\");\n+        assertTrue(objects[3] == ln2, \"Bad oop ln2\");\n+\n+        \/\/ Array..\n+        objects = WB.getObjectsViaOopIterator(createPeople());\n+        assertTrue(objects.length == NOF_PEOPLE * 2, \"Unexpected length: \" + objects.length);\n+        int o = 0;\n+        for (int i = 0; i < NOF_PEOPLE; i++) {\n+            assertTrue(objects[o++].equals(firstName(i)), \"Bad firstName\");\n+            assertTrue(objects[o++].equals(lastName(i)), \"Bad lastName\");\n+        }\n+\n+        \/\/ Sanity check, FixMe need more test cases\n+        objects = testFrameOops(couple);\n+        assertTrue(objects.length == 5, \"Number of frame oops incorrect = \" + objects.length);\n+        assertTrue(objects[0] == couple, \"Bad oop 0\");\n+        assertTrue(objects[1] == fn1, \"Bad oop 1\");\n+        assertTrue(objects[2] == ln1, \"Bad oop 2\");\n+        assertTrue(objects[3] == TEST_STRING1, \"Bad oop 3\");\n+        assertTrue(objects[4] == TEST_STRING2, \"Bad oop 4\");\n+\n+        testFrameOopsVBytecodes();\n+    }\n+\n+    static final String GET_OOP_MAP_NAME = \"getOopMap\";\n+    static final String GET_OOP_MAP_DESC = \"()[Ljava\/lang\/Object;\";\n+\n+    public static Object[] getOopMap() {\n+        Object[] oopMap = WB.getObjectsViaFrameOopIterator(2);\n+        \/* Remove this frame (class mirror for this method), and above class mirror *\/\n+        Object[] trimmedOopMap = new Object[oopMap.length - 2];\n+        System.arraycopy(oopMap, 2, trimmedOopMap, 0, trimmedOopMap.length);\n+        return trimmedOopMap;\n+    }\n+\n+    \/\/ Expecting Couple couple, Person couple.onePerson, and Person (created here)\n+    public static Object[] testFrameOops(Couple couple) {\n+        int someId = 89898;\n+        Person person = couple.onePerson;\n+        assertTrue(person.getId() == 0, \"Bad Person\");\n+        Person anotherPerson = new Person(someId, TEST_STRING1, TEST_STRING2);\n+        assertTrue(anotherPerson.getId() == someId, \"Bad Person\");\n+        return getOopMap();\n+    }\n+\n+    \/\/ Debug...\n+    static void dumpOopMap(Object[] oopMap) {\n+        System.out.println(\"Oop Map len: \" + oopMap.length);\n+        for (int i = 0; i < oopMap.length; i++) {\n+            System.out.println(\"[\" + i + \"] = \" + oopMap[i]);\n+        }\n+    }\n+\n+    \/**\n+     * Just some check sanity checks with aconst_init, withfield, astore and aload\n+     *\n+     * Changes to javac slot usage may well break this test\n+     *\/\n+    public static void testFrameOopsVBytecodes() {\n+        int nofOopMaps = 4;\n+        Object[][] oopMaps = new Object[nofOopMaps][];\n+        String[] inputArgs = new String[] { \"aName\", \"aDescription\", \"someNotes\" };\n+\n+        FooValue.testFrameOopsDefault(oopMaps);\n+\n+        \/\/ Test-D0 Slots=R Stack=Q(RRR)RV\n+        assertTrue(oopMaps[0].length == 5 &&\n+                oopMaps[0][1] == null &&\n+                oopMaps[0][2] == null &&\n+                oopMaps[0][3] == null, \"Test-D0 incorrect\");\n+\n+        \/\/ Test-D1 Slots=R Stack=RV\n+        assertTrue(oopMaps[1].length == 2, \"Test-D1 incorrect\");\n+\n+        \/\/ Test-D2 Slots=RQ(RRR) Stack=RV\n+        assertTrue(oopMaps[2].length == 5 &&\n+                oopMaps[2][1] == null &&\n+                oopMaps[2][2] == null &&\n+                oopMaps[2][3] == null, \"Test-D2 incorrect\");\n+\n+        \/\/ Test-D3 Slots=R Stack=Q(RRR)RV\n+        assertTrue(oopMaps[3].length == 6 &&\n+                oopMaps[3][1] == null &&\n+                oopMaps[3][2] == null &&\n+                oopMaps[3][3] == null &&\n+                oopMaps[3][4] == null, \"Test-D3 incorrect\");\n+\n+        \/\/ With ref fields...\n+        String name = \"TestName\";\n+        String desc = \"TestDesc\";\n+        String note = \"TestNotes\";\n+        FooValue.testFrameOopsRefs(name, desc, note, oopMaps);\n+\n+        \/\/ Test-R0 Slots=RR Stack=Q(RRR)RV\n+        assertTrue(oopMaps[0].length == 6 &&\n+                oopMaps[0][2] == name &&\n+                oopMaps[0][3] == desc &&\n+                oopMaps[0][4] == note, \"Test-R0 incorrect\");\n+\n+        \/**\n+         * TODO: vwithfield from method handle cooked from anonymous class within the inline class\n+         *       even with \"MethodHandles.privateLookupIn()\" will fail final putfield rules\n+         *\/\n+    }\n+\n+    \/**\n+     * Check forcing GC for combination of VT on stack\/LVT etc works\n+     *\/\n+    public static void testOverGc() {\n+        try {\n+            Class<?> vtClass = Person.class.asValueType();\n+\n+            System.out.println(\"vtClass=\"+vtClass);\n+\n+            doGc();\n+\n+            \/\/ VT on stack and lvt, null refs, see if GC flies\n+            MethodHandle moveValueThroughStackAndLvt = InstructionHelper.loadCode(\n+                    LOOKUP,\n+                    \"gcOverPerson\",\n+                    MethodType.methodType(vtClass, vtClass),\n+                    CODE->{\n+                        CODE\n+                        .aload(0)\n+                        .invokestatic(InlineOops.class, \"doGc\", \"()V\", false) \/\/ Stack\n+                        .astore(0)\n+                        .invokestatic(InlineOops.class, \"doGc\", \"()V\", false) \/\/ LVT\n+                        .aload(0)\n+                        .astore(1024) \/\/ LVT wide index\n+                        .aload(1024)\n+                        .iconst_1()  \/\/ push a litte further down\n+                        .invokestatic(InlineOops.class, \"doGc\", \"()V\", false) \/\/ Stack,LVT\n+                        .pop()\n+                        .areturn();\n+                    });\n+            Person person = (Person) moveValueThroughStackAndLvt.invokeExact(createDefaultPerson());\n+            validateDefaultPerson(person);\n+            doGc();\n+\n+            int index = 4711;\n+            person = (Person) moveValueThroughStackAndLvt.invokeExact(createIndexedPerson(index));\n+            validateIndexedPerson(person, index);\n+            doGc();\n+            person = createDefaultPerson();\n+            doGc();\n+        }\n+        catch (Throwable t) { fail(\"testOverGc\", t); }\n+    }\n+\n+    static void submitNewWork(ForkJoinPool fjPool) {\n+        for (int j = 0; j < 100; j++) {\n+            fjPool.execute(InlineOops::testValues);\n+        }\n+    }\n+\n+    static void sleepNoThrow(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        }\n+        catch (Throwable t) {}\n+    }\n+\n+    \/**\n+     * Run some workloads with different object\/value life times...\n+     *\/\n+    public static void testActiveGc() {\n+        try {\n+            int nofThreads = 1;\n+\n+            Object longLivedObjects = createLongLived();\n+            Object longLivedPeople = createPeople();\n+\n+            Object medLivedObjects = createLongLived();\n+            Object medLivedPeople = createPeople();\n+\n+            doGc();\n+\n+            \/\/ Setup some background work, where GC roots are stack local only, short lifetimes...\n+            ForkJoinPool fjPool = new ForkJoinPool(nofThreads, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);\n+\n+            \/\/ Work on this stack's long and medium lived objects\n+            for (int nofActiveGc = 0; nofActiveGc < MIN_ACTIVE_GC_COUNT; nofActiveGc++) {\n+                \/\/ Medium lifetime, check and renew\n+                if (nofActiveGc % MED_ACTIVE_GC_COUNT == 0) {\n+                    validateLongLived(medLivedObjects);\n+                    validatePeople(medLivedPeople);\n+\n+                    medLivedObjects = createLongLived();\n+                    medLivedPeople = createPeople();\n+                }\n+                \/\/ More short lived background, if needed\n+                if (!fjPool.hasQueuedSubmissions()) {\n+                    submitNewWork(fjPool);\n+                }\n+                \/\/ Forced, synchronous GC\n+                doGc();\n+            }\n+\n+            fjPool.shutdown();\n+\n+            validateLongLived(medLivedObjects);\n+            validatePeople(medLivedPeople);\n+            medLivedObjects = null;\n+            medLivedPeople = null;\n+\n+            validateLongLived(longLivedObjects);\n+            validatePeople(longLivedPeople);\n+\n+            longLivedObjects = null;\n+            longLivedPeople = null;\n+\n+            doGc();\n+        }\n+        catch (Throwable t) { fail(\"testActiveGc\", t); }\n+    }\n+\n+    static final ReferenceQueue<Object> REFQ = new ReferenceQueue<>();\n+\n+    public static void doGc() {\n+        WB.fullGC();\n+    }\n+\n+    static void validatePerson(Person person, int id, String fn, String ln, boolean equals) {\n+        assertTrue(person.id == id);\n+        if (equals) {\n+            assertTrue(fn.equals(person.getFirstName()), \"Invalid field firstName\");\n+            assertTrue(ln.equals(person.getLastName()), \"Invalid  field lastName\");\n+        }\n+        else {\n+            assertTrue(person.getFirstName() == fn, \"Invalid field firstName\");\n+            assertTrue(person.getLastName() == ln, \"Invalid  field lastName\");\n+        }\n+    }\n+\n+    static Person createIndexedPerson(int i) {\n+        return new Person(i, firstName(i), lastName(i));\n+    }\n+\n+    static void validateIndexedPerson(Person person, int i) {\n+        validatePerson(person, i, firstName(i), lastName(i), true);\n+    }\n+\n+    static Person createDefaultPerson() {\n+        return Person.default;\n+    }\n+\n+    static void validateDefaultPerson(Person person) {\n+        validatePerson(person, 0, null, null, false);\n+    }\n+\n+    static String firstName(int i) {\n+        return \"FirstName-\" + i;\n+    }\n+\n+    static String lastName(int i) {\n+        return \"LastName-\" + i;\n+    }\n+\n+    static Object createLongLived()  throws Throwable {\n+        Object[] population = new Object[1];\n+        population[0] = createPeople();\n+        return population;\n+    }\n+\n+    static void validateLongLived(Object pop) throws Throwable {\n+        Object[] population = (Object[]) pop;\n+        validatePeople(population[0]);\n+    }\n+\n+    static Object createPeople() {\n+        int arrayLength = NOF_PEOPLE;\n+        Person[] people = new Person[arrayLength];\n+        for (int i = 0; i < arrayLength; i++) {\n+            people[i] = createIndexedPerson(i);\n+        }\n+        return people;\n+    }\n+\n+    static void validatePeople(Object array) {\n+        Person[] people = (Person[]) array;\n+        int arrayLength = people.length;\n+        assertTrue(arrayLength == NOF_PEOPLE);\n+        for (int i = 0; i < arrayLength; i++) {\n+            validateIndexedPerson(people[i], i);\n+        }\n+    }\n+\n+    \/\/ Various field layouts...sanity testing, see MVTCombo testing for full-set\n+\n+    static final primitive class ObjectValue {\n+        final Object object;\n+\n+        private ObjectValue(Object obj) {\n+            object = obj;\n+        }\n+    }\n+\n+    static class ObjectWithObjectValue {\n+        ObjectValue value1;\n+        Object      ref1;\n+    }\n+\n+    static class ObjectWithObjectValues {\n+        ObjectValue value1;\n+        ObjectValue value2;\n+        Object      ref1;\n+    }\n+\n+    static class Foo {\n+        int id;\n+        String name;\n+        String description;\n+        long timestamp;\n+        String notes;\n+    }\n+\n+    static class Bar extends Foo {\n+        long extendedId;\n+        String moreNotes;\n+        int count;\n+        String otherStuff;\n+    }\n+\n+    public static final primitive class FooValue {\n+        public final int id;\n+        public final String name;\n+        public final String description;\n+        public final long timestamp;\n+        public final String notes;\n+\n+        public FooValue(int id, String name, String description, long timestamp, String notes) {\n+            this.id = id;\n+            this.name = name;\n+            this.description = description;\n+            this.timestamp = timestamp;\n+            this.notes = notes;\n+        }\n+\n+        public static void testFrameOopsDefault(Object[][] oopMaps) {\n+            MethodType mt = MethodType.methodType(Void.TYPE, oopMaps.getClass());\n+            int oopMapsSlot   = 0;\n+            int vtSlot        = 1;\n+\n+            \/\/ Slots 1=oopMaps\n+            \/\/ OopMap Q=RRR (.name .description .someNotes)\n+            try {\n+                InstructionHelper.loadCode(\n+                        LOOKUP, \"exerciseVBytecodeExprStackWithDefault\", mt,\n+                        CODE->{\n+                            CODE\n+                            .aconst_init(FooValue.class.asValueType())\n+                            .aload(oopMapsSlot)\n+                            .iconst_0()  \/\/ Test-D0 Slots=R Stack=Q(RRR)RV\n+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .aastore()\n+                            .pop()\n+                            .aload(oopMapsSlot)\n+                            .iconst_1()  \/\/ Test-D1 Slots=R Stack=RV\n+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .aastore()\n+                            .aconst_init(FooValue.class.asValueType())\n+                            .astore(vtSlot)\n+                            .aload(oopMapsSlot)\n+                            .iconst_2()  \/\/ Test-D2 Slots=RQ(RRR) Stack=RV\n+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .aastore()\n+                            .aload(vtSlot)\n+                            .aconst_null()\n+                            .astore(vtSlot) \/\/ Storing null over the Q slot won't remove the ref, but should be single null ref\n+                            .aload(oopMapsSlot)\n+                            .iconst_3()  \/\/ Test-D3 Slots=R Stack=Q(RRR)RV\n+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .aastore()\n+                            .pop()\n+                            .return_();\n+                        }).invoke(oopMaps);\n+            } catch (Throwable t) { fail(\"exerciseVBytecodeExprStackWithDefault\", t); }\n+        }\n+\n+        public static void testFrameOopsRefs(String name, String description, String notes, Object[][] oopMaps) {\n+            FooValue f = new FooValue(4711, name, description, 9876543231L, notes);\n+            FooValue[] fa = new FooValue[] { f };\n+            MethodType mt = MethodType.methodType(Void.TYPE, fa.getClass(), oopMaps.getClass());\n+            int fooArraySlot  = 0;\n+            int oopMapsSlot   = 1;\n+            try {\n+                InstructionHelper.loadCode(LOOKUP, \"exerciseVBytecodeExprStackWithRefs\", mt,\n+                        CODE->{\n+                            CODE\n+                            .aload(fooArraySlot)\n+                            .iconst_0()\n+                            .aaload()\n+                            .aload(oopMapsSlot)\n+                            .iconst_0()  \/\/ Test-R0 Slots=RR Stack=Q(RRR)RV\n+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .aastore()\n+                            .pop()\n+                            .return_();\n+                        }).invoke(fa, oopMaps);\n+            } catch (Throwable t) { fail(\"exerciseVBytecodeExprStackWithRefs\", t); }\n+        }\n+    }\n+\n+    static class BarWithValue {\n+        FooValue foo;\n+        long extendedId;\n+        String moreNotes;\n+        int count;\n+        String otherStuff;\n+    }\n+\n+    static final primitive class BarValue {\n+        final FooValue foo;\n+        final long extendedId;\n+        final String moreNotes;\n+        final int count;\n+        final String otherStuff;\n+\n+        private BarValue(FooValue f, long extId, String mNotes, int c, String other) {\n+            foo = f;\n+            extendedId = extId;\n+            moreNotes = mNotes;\n+            count = c;\n+            otherStuff = other;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":644,"deletions":0,"binary":false,"changes":644,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.management.MemoryPoolMXBean;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test InlineTypeDensity\n+ * @summary Heap density test for InlineTypes\n+ * @library \/test\/lib\n+ * @compile InlineTypeDensity.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 -XX:+UseCompressedOops\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                    -XX:+WhiteBoxAPI InlineTypeDensity\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 -XX:-UseCompressedOops\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                    -XX:+WhiteBoxAPI InlineTypeDensity\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI InlineTypeDensity\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:ForceNonTearable=*\n+ *                   -XX:+WhiteBoxAPI InlineTypeDensity\n+ *\/\n+\n+public class InlineTypeDensity {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final boolean VM_FLAG_FORCENONTEARABLE = WHITE_BOX.getStringVMFlag(\"ForceNonTearable\").equals(\"*\");\n+\n+    public InlineTypeDensity() {\n+        if (WHITE_BOX.getIntxVMFlag(\"FlatArrayElementMaxSize\") != -1) {\n+            throw new IllegalStateException(\"FlatArrayElementMaxSize should be -1\");\n+        }\n+    }\n+\n+    interface LocalDate {\n+        public int getYear();\n+        public short getMonth();\n+        public short getDay();\n+    }\n+\n+    interface LocalTime {\n+        public byte getHour();\n+        public byte getMinute();\n+        public byte getSecond();\n+        public int getNano();\n+    }\n+\n+    interface LocalDateTime extends LocalDate, LocalTime {}\n+\n+    static final primitive class LocalDateValue implements LocalDate {\n+        final int   year;\n+        final short month;\n+        final short day;\n+\n+        public LocalDateValue(int year, short month, short day) {\n+            this.year = year;\n+            this.month = month;\n+            this.day = day;\n+        }\n+\n+        public int   getYear()  { return year; }\n+        public short getMonth() { return month; }\n+        public short getDay()   { return day; }\n+\n+    }\n+\n+    static final primitive class LocalTimeValue implements LocalTime {\n+        final byte hour;\n+        final byte minute;\n+        final byte second;\n+        final int nano;\n+\n+        public LocalTimeValue(byte hour, byte minute, byte second, int nano) {\n+            this.hour = hour;\n+            this.minute = minute;\n+            this.second = second;\n+            this.nano = nano;\n+        }\n+\n+        public byte getHour()   { return hour; }\n+        public byte getMinute() { return minute; }\n+        public byte getSecond() { return second; }\n+        public int getNano()    { return nano; }\n+\n+    }\n+\n+    static final primitive class LocalDateTimeValue implements LocalDateTime {\n+        final LocalDateValue date;\n+        final LocalTimeValue time;\n+\n+        public LocalDateTimeValue(LocalDateValue date, LocalTimeValue time) {\n+            this.date = date;\n+            this.time = time;\n+        }\n+\n+        public int   getYear()  { return date.year; }\n+        public short getMonth() { return date.month; }\n+        public short getDay()   { return date.day; }\n+\n+        public byte getHour()   { return time.hour; }\n+        public byte getMinute() { return time.minute; }\n+        public byte getSecond() { return time.second; }\n+        public int getNano()    { return time.nano; }\n+\n+    }\n+\n+    static final class LocalDateClass implements LocalDate {\n+        final int   year;\n+        final short month;\n+        final short day;\n+\n+        LocalDateClass(int year, short month, short day) {\n+            this.year  = year;\n+            this.month = month;\n+            this.day   = day;\n+        }\n+\n+        public int   getYear()  { return year; }\n+        public short getMonth() { return month; }\n+        public short getDay()   { return day; }\n+    }\n+\n+    static final class LocalTimeClass implements LocalTime {\n+        final byte hour;\n+        final byte minute;\n+        final byte second;\n+        final int nano;\n+\n+        LocalTimeClass(byte hour, byte minute, byte second, int nano) {\n+            this.hour   = hour;\n+            this.minute = minute;\n+            this.second = second;\n+            this.nano   = nano;\n+        }\n+\n+        public byte getHour()   { return hour; }\n+        public byte getMinute() { return minute; }\n+        public byte getSecond() { return second; }\n+        public int getNano()    { return nano; }\n+    }\n+\n+    static final class LocalDateTimeClass implements LocalDateTime {\n+        final LocalDateClass date;\n+        final LocalTimeClass time;\n+\n+        LocalDateTimeClass(LocalDateClass date, LocalTimeClass time) {\n+            this.date = date;\n+            this.time = time;\n+        }\n+\n+        public LocalDateClass getDate() { return date; }\n+        public LocalTimeClass getTime() { return time; }\n+\n+        public int   getYear()  { return date.year; }\n+        public short getMonth() { return date.month; }\n+        public short getDay()   { return date.day; }\n+\n+        public byte getHour()   { return time.hour; }\n+        public byte getMinute() { return time.minute; }\n+        public byte getSecond() { return time.second; }\n+        public int getNano()    { return time.nano; }\n+    }\n+\n+    public void ensureArraySizeWin() {\n+        int arrayLength = 1000;\n+        System.out.println(\"ensureArraySizeWin for length \" + arrayLength);\n+        LocalDateTimeClass[] objectArray = new LocalDateTimeClass[arrayLength];\n+        for (int i = 0; i < arrayLength; i++) {\n+            objectArray[i] = new LocalDateTimeClass(new LocalDateClass(0, (short)0, (short)0),\n+                    new LocalTimeClass((byte)0, (byte)0, (byte)0, 0));\n+        }\n+\n+        long objectArraySize = WHITE_BOX.getObjectSize(objectArray);\n+        System.out.println(\"Empty object array size: \" + objectArraySize);\n+        objectArraySize += (arrayLength *\n+                (WHITE_BOX.getObjectSize(objectArray[0]) +\n+                        WHITE_BOX.getObjectSize(objectArray[0].getDate()) +\n+                        WHITE_BOX.getObjectSize(objectArray[0].getTime())));\n+\n+        LocalDateTimeValue[] flatArray = new LocalDateTimeValue[arrayLength];\n+        \/\/ CMH: add \"isFlatValueArray\" to WhiteBox API, to ensure we are correctly account size\n+\n+        long flatArraySize = WHITE_BOX.getObjectSize(flatArray);\n+        System.out.println(\"Object array and elements: \" + objectArraySize + \" versus Flat Array: \" + flatArraySize);\n+        Asserts.assertLessThan(flatArraySize, objectArraySize, \"Flat array accounts for more heap than object array + elements !\");\n+    }\n+\n+    static primitive class MyByte  { byte  v = 0; }\n+    static primitive class MyShort { short v = 0; }\n+    static primitive class MyInt   { int   v = 0; }\n+    static primitive class MyLong  { long  v = 0; }\n+\n+    void assertArraySameSize(Object a, Object b, int nofElements) {\n+        long aSize = WHITE_BOX.getObjectSize(a);\n+        long bSize = WHITE_BOX.getObjectSize(b);\n+        Asserts.assertEquals(aSize, bSize,\n+            a + \"(\" + aSize + \" bytes) not equivalent size \" +\n+            b + \"(\" + bSize + \" bytes)\" +\n+            (nofElements >= 0 ? \" (array of \" + nofElements + \" elements)\" : \"\"));\n+    }\n+\n+    void testByteArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            byte[] ba = new byte[testSize];\n+            MyByte[] mba = new MyByte[testSize];\n+            assertArraySameSize(ba, mba, testSize);\n+        }\n+    }\n+\n+    void testShortArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            short[] sa = new short[testSize];\n+            MyShort[] msa = new MyShort[testSize];\n+            assertArraySameSize(sa, msa, testSize);\n+        }\n+    }\n+\n+    void testIntArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            int[] ia = new int[testSize];\n+            MyInt[] mia = new MyInt[testSize];\n+            assertArraySameSize(ia, mia, testSize);\n+        }\n+    }\n+\n+    void testLongArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            long[] la = new long[testSize];\n+            MyLong[] mla = new MyLong[testSize];\n+            assertArraySameSize(la, mla, testSize);\n+        }\n+    }\n+\n+    public void testPrimitiveArraySizesSame() {\n+        int[] testSizes = new int[] { 0, 1, 2, 3, 4, 7, 10, 257 };\n+        testByteArraySizesSame(testSizes);\n+        testShortArraySizesSame(testSizes);\n+        testIntArraySizesSame(testSizes);\n+        testLongArraySizesSame(testSizes);\n+    }\n+\n+    static primitive class bbValue { byte b = 0; byte b2 = 0;}\n+    static primitive class bsValue { byte b = 0; short s = 0;}\n+    static primitive class siValue { short s = 0; int i = 0;}\n+    static primitive class ssiValue { short s = 0; short s2 = 0; int i = 0;}\n+    static primitive class blValue { byte b = 0; long l = 0; }\n+\n+    \/\/ Expect aligned array addressing to nearest pow2\n+    void testAlignedSize() {\n+        int testSize = 10;\n+        assertArraySameSize(new short[testSize], new bbValue[testSize], testSize);\n+        assertArraySameSize(new long[testSize], new siValue[testSize], testSize);\n+        assertArraySameSize(new long[testSize], new ssiValue[testSize], testSize);\n+        assertArraySameSize(new long[testSize*2], new blValue[testSize], testSize);\n+        assertArraySameSize(new int[testSize], new bsValue[testSize], testSize);\n+    }\n+\n+    public void test() {\n+        ensureArraySizeWin();\n+        testPrimitiveArraySizesSame();\n+        if (!VM_FLAG_FORCENONTEARABLE) {\n+          testAlignedSize();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new InlineTypeDensity().test();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeDensity.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This class provides two static methods equivalent to this Java source code:\n+ * void createArray0() {\n+ *     Element0 array = new Element0[10][10]; \/\/ Element0 is expected to be an inline type\n+ * }\n+ * void createArray1() {\n+ *     Element1 array = new Element1[10][10]; \/\/ Element1 is expected to be a reference type\n+ * }\n+ *\/\n+\n+class MultiANewArrayTypeCheck {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"[[QElement0;\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"[[LElement1;\"; \/\/ #10\n+    class #12; \/\/ #11\n+    Utf8 \"MultiANewArrayTypeCheck\"; \/\/ #12\n+    Utf8 \"Code\"; \/\/ #13\n+    Utf8 \"LineNumberTable\"; \/\/ #14\n+    Utf8 \"createArray0\"; \/\/ #15\n+    Utf8 \"createArray1\"; \/\/ #16\n+    Utf8 \"SourceFile\"; \/\/ #17\n+    Utf8 \"MultiANewArrayTypeCheck.java\"; \/\/ #18\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #11;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x100A100AC5000702;\n+            0x4BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                9  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #16; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x100A100AC5000902;\n+            0x4BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                9  9;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#17) { \/\/ SourceFile\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MultiANewArrayTypeCheck\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTypeCheck.jcod","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/TestPrimitiveClass\n+    version 64:0\n+{\n+    final Field nullableField:   \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+    final Field nullfreeField:   \"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ flattened\n+    final Field nullField:       \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ src of null\n+    final Field nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ not flattened\n+    final Field nullBigField:    \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ src of null\n+\n+    public Method withNullableField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullableField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        areturn;\n+    }\n+\n+    public Method withNullfreeField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullfreeField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        areturn;\n+    }\n+\n+    public Method withNullfreeBigField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\";\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullabilityClasses.jasm","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClass version 64:0 {\n+\n+    Field field:\"Qruntime\/valhalla\/inlinetypes\/MyValue;\";\n+\n+    public Method \"<init>\":\"()V\"\n+      stack 1 locals 1\n+    {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public Method test:\"()V\" stack 2 locals 1 {\n+        aload_0;\n+        aconst_null;\n+        putfield Field field:\"Qruntime\/valhalla\/inlinetypes\/MyValue;\";\n+        return;\n+    }\n+}\n+\n+super public final class runtime\/valhalla\/inlinetypes\/MyValue version 64:0 {\n+    Field foo:I = 42;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClasses.jasm","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The test class is based in the Java source code below, but the constant\n+\/\/ pool entry #33 (used by the Preload attribute) has been modified to\n+\/\/ contain the name of a non-existing class.\n+\/\/\n+\/\/ public class ValuePreloadClient1 {\n+\/\/     PreloadValue0 value;\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         System.out.print(\"Success\");\n+\/\/     }\n+\/\/ }\n+\n+ class ValuePreloadClient1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/System\"; \/\/ #10\n+    Utf8 \"out\"; \/\/ #11\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"Success\"; \/\/ #14\n+    Method #16 #17; \/\/ #15\n+    class #18; \/\/ #16\n+    NameAndType #19 #20; \/\/ #17\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18\n+    Utf8 \"print\"; \/\/ #19\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"ValuePreloadClient1\"; \/\/ #22\n+    Utf8 \"value\"; \/\/ #23\n+    Utf8 \"LPreloadValue0;\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"main\"; \/\/ #27\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"ValuePreloadClient1.java\"; \/\/ #30\n+    Utf8 \"Preload\"; \/\/ #31\n+    class #33; \/\/ #32\n+    Utf8 \"PreloadValue1\"; \/\/ #33\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#31) { \/\/ Preload\n+      0x00010020;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class ValuePreloadClient1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadClient1.jcod","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.Optional;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.whitebox.WhiteBox;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test ValueTearing\n+ * @summary Test tearing of inline fields and array elements\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile ValueTearing.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=\n+ *                   -DSTEP_COUNT=10000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueTearing\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*\n+ *                   -DSTEP_COUNT=10000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueTearing\n+ * @run main\/othervm -DSTEP_COUNT=10000000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueTearing\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=\n+ *                   -DTEAR_MODE=fieldonly -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueTearing\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=\n+ *                   -DTEAR_MODE=arrayonly -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueTearing\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*\n+ *                   -DTEAR_MODE=both -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueTearing\n+ *\/\n+public class ValueTearing {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    private static final boolean ALWAYS_ATOMIC = WHITE_BOX.getStringVMFlag(\"ForceNonTearable\").contains(\"*\");\n+    private static final String TEAR_MODE = System.getProperty(\"TEAR_MODE\", \"both\");\n+    private static final boolean TEAR_FIELD = !TEAR_MODE.equals(\"arrayonly\");\n+    private static final boolean TEAR_ARRAY = !TEAR_MODE.equals(\"fieldonly\");\n+    private static final int STEP_COUNT = Integer.getInteger(\"STEP_COUNT\", 100_000);\n+    private static final boolean TFIELD_FLAT, TARRAY_FLAT;\n+    private static final boolean NTFIELD_FLAT, NTARRAY_FLAT;\n+    static {\n+        try {\n+            Field TPB_field = TPointBox.class.getDeclaredField(\"field\");\n+            Field TPB_array = TPointBox.class.getDeclaredField(\"array\");\n+            Field NTPB_field = NTPointBox.class.getDeclaredField(\"field\");\n+            Field NTPB_array = NTPointBox.class.getDeclaredField(\"array\");\n+            TFIELD_FLAT = UNSAFE.isFlattened(TPB_field);\n+            TARRAY_FLAT = UNSAFE.isFlattenedArray(TPB_array.getType());\n+            NTFIELD_FLAT = UNSAFE.isFlattened(NTPB_field);\n+            NTARRAY_FLAT = UNSAFE.isFlattenedArray(NTPB_array.getType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+    private static final String SETTINGS =\n+        String.format(\"USE_COMPILER=%s ALWAYS_ATOMIC=%s TEAR_MODE=%s STEP_COUNT=%s FLAT TF\/TA=%s\/%s NTF\/NTA=%s\/%s\",\n+                      USE_COMPILER, ALWAYS_ATOMIC, TEAR_MODE, STEP_COUNT,\n+                      TFIELD_FLAT, TARRAY_FLAT, NTFIELD_FLAT, NTARRAY_FLAT);\n+    private static final String NOTE_TORN_POINT = \"Note: torn point\";\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(SETTINGS);\n+        ValueTearing valueTearing = new ValueTearing();\n+        valueTearing.run();\n+        \/\/ Extra representation check:\n+        assert(!NTFIELD_FLAT) : \"NT field must be indirect not flat\";\n+        assert(!NTARRAY_FLAT) : \"NT array must be indirect not flat\";\n+        if (ALWAYS_ATOMIC) {\n+            assert(!TFIELD_FLAT) : \"field must be indirect not flat\";\n+            assert(!TARRAY_FLAT) : \"array must be indirect not flat\";\n+        }\n+    }\n+\n+    \/\/ A normally tearable inline value.\n+    static primitive class TPoint {\n+        TPoint(long x, long y) { this.x = x; this.y = y; }\n+        final long x, y;\n+        public String toString() { return String.format(\"(%d,%d)\", x, y); }\n+    }\n+\n+    static class TooTearable extends AssertionError {\n+        final Object badPoint;\n+        TooTearable(String msg, Object badPoint) {\n+            super(msg);\n+            this.badPoint = badPoint;\n+        }\n+    }\n+\n+    interface PointBox {\n+        void step();    \/\/ mutate inline value state\n+        void check();   \/\/ check sanity of inline value state\n+    }\n+\n+    class TPointBox implements PointBox {\n+        TPoint field;\n+        TPoint[] array = new TPoint[1];\n+        \/\/ Step the points forward by incrementing their components\n+        \/\/ \"simultaneously\".  A racing thread will catch flaws in the\n+        \/\/ simultaneity.\n+        TPoint step(TPoint p) {\n+            return new TPoint(p.x + 1, p.y + 1);\n+        }\n+        public @Override\n+        void step() {\n+            if (TEAR_FIELD) {\n+                field = step(field);\n+            }\n+            if (TEAR_ARRAY) {\n+                array[0] = step(array[0]);\n+            }\n+            check();\n+        }\n+        \/\/ Invariant:  The components of each point are \"always\" equal.\n+        \/\/ As long as simultaneity is preserved, this is true.\n+        public @Override\n+        void check() {\n+            if (TEAR_FIELD) {\n+                check(field, \"field\");\n+            }\n+            if (TEAR_ARRAY) {\n+                check(array[0], \"array element\");\n+            }\n+        }\n+        void check(TPoint p, String where) {\n+            if (p.x == p.y)  return;\n+            String msg = String.format(\"%s %s in %s; settings = %s\",\n+                                       NOTE_TORN_POINT,\n+                                       p, where, SETTINGS);\n+            throw new TooTearable(msg, p);\n+        }\n+        public String toString() {\n+            return String.format(\"TPB[%s, {%s}]\", field, array[0]);\n+        }\n+    }\n+\n+    \/\/ Add an indirection, as an extra test.\n+    interface NT extends NonTearable { }\n+\n+    \/\/ A hardened, non-tearable version of TPoint.\n+    static primitive class NTPoint implements NT {\n+        NTPoint(long x, long y) { this.x = x; this.y = y; }\n+        final long x, y;\n+        public String toString() { return String.format(\"(%d,%d)\", x, y); }\n+    }\n+\n+    class NTPointBox implements PointBox {\n+        NTPoint field;\n+        NTPoint[] array = new NTPoint[1];\n+        \/\/ Step the points forward by incrementing their components\n+        \/\/ \"simultaneously\".  A racing thread will catch flaws in the\n+        \/\/ simultaneity.\n+        NTPoint step(NTPoint p) {\n+            return new NTPoint(p.x + 1, p.y + 1);\n+        }\n+        public @Override\n+        void step() {\n+            field = step(field);\n+            array[0] = step(array[0]);\n+            check();\n+        }\n+        \/\/ Invariant:  The components of each point are \"always\" equal.\n+        public @Override\n+        void check() {\n+            check(field, \"field\");\n+            check(array[0], \"array element\");\n+        }\n+        void check(NTPoint p, String where) {\n+            if (p.x == p.y)  return;\n+            String msg = String.format(\"%s *NonTearable* %s in %s; settings = %s\",\n+                                       NOTE_TORN_POINT,\n+                                       p, where, SETTINGS);\n+            throw new TooTearable(msg, p);\n+        }\n+        public String toString() {\n+            return String.format(\"NTPB[%s, {%s}]\", field, array[0]);\n+        }\n+    }\n+\n+    class AsyncObserver extends Thread {\n+        volatile boolean done;\n+        long observationCount;\n+        final PointBox pointBox;\n+        volatile Object badPointObserved;\n+        AsyncObserver(PointBox pointBox) {\n+            this.pointBox = pointBox;\n+        }\n+        public void run() {\n+            try {\n+                while (!done) {\n+                    observationCount++;\n+                    pointBox.check();\n+                }\n+            } catch (TooTearable ex) {\n+                done = true;\n+                badPointObserved = ex.badPoint;\n+                System.out.println(ex);\n+                if (ALWAYS_ATOMIC || ex.badPoint instanceof NonTearable) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void run() throws Exception {\n+        System.out.println(\"Test for tearing of NTPoint, which must not happen...\");\n+        run(new NTPointBox(), false);\n+        System.out.println(\"Test for tearing of TPoint, which \"+\n+                           (ALWAYS_ATOMIC ? \"must not\" : \"is allowed to\")+\n+                           \" happen...\");\n+        run(new TPointBox(), ALWAYS_ATOMIC ? false : true);\n+    }\n+    public void run(PointBox pointBox, boolean canTear) throws Exception {\n+        var observer = new AsyncObserver(pointBox);\n+        observer.start();\n+        for (int i = 0; i < STEP_COUNT; i++) {\n+            pointBox.step();\n+            if (observer.done)  break;\n+        }\n+        observer.done = true;\n+        observer.join();\n+        var obCount = observer.observationCount;\n+        var badPoint = observer.badPointObserved;\n+        System.out.println(String.format(\"finished after %d observations at %s; %s\",\n+                                         obCount, pointBox,\n+                                         (badPoint == null\n+                                          ? \"no tearing observed\"\n+                                          : \"bad point = \" + badPoint)));\n+        if (canTear && badPoint == null) {\n+            var complain = String.format(\"%s NOT observed after %d observations\",\n+                                         NOTE_TORN_POINT, obCount);\n+            System.out.println(\"?????? \"+complain);\n+            if (STEP_COUNT >= 3_000_000) {\n+                \/\/ If it's a small count, OK, but if it's big the test is broken.\n+                throw new AssertionError(complain + \", but it should have been\");\n+            }\n+        }\n+        if (!canTear && badPoint != null) {\n+            throw new AssertionError(\"should not reach here; other thread must throw\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueTearing.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldOwner\n+    version 64:0\n+{\n+    NestHost runtime\/valhalla\/inlinetypes\/WithFieldNestHost;\n+\n+    public final Field c:C;\n+    protected final Field l:J;\n+    final Field d:D;\n+    private final Field i:I;\n+\n+    public Method checkFields:\"(CJDI)V\" stack 4 {\n+        aload_0;\n+        getfield c:C;\n+        invokestatic java\/lang\/Character.valueOf:\"(C)Ljava\/lang\/Character;\";\n+        iload_1;\n+        invokestatic java\/lang\/Character.valueOf:\"(C)Ljava\/lang\/Character;\";\n+        ldc \"unexpected c value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield l:J;\n+        invokestatic java\/lang\/Long.valueOf:\"(J)Ljava\/lang\/Long;\";\n+        lload_2;\n+        invokestatic java\/lang\/Long.valueOf:\"(J)Ljava\/lang\/Long;\";\n+        ldc \"unexpected l value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield d:D;\n+        invokestatic java\/lang\/Double.valueOf:\"(D)Ljava\/lang\/Double;\";\n+        dload 4;\n+        invokestatic java\/lang\/Double.valueOf:\"(D)Ljava\/lang\/Double;\";\n+        ldc \"unexpected d value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield i:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload 6;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"unexpected i value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        return;\n+    }\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldNestmate\n+    version 64:0\n+{\n+    NestHost runtime\/valhalla\/inlinetypes\/WithFieldNestHost;\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldNestHost\n+    version 64:0\n+{\n+    NestMembers runtime\/valhalla\/inlinetypes\/WithFieldOwner, runtime\/valhalla\/inlinetypes\/WithFieldNestmate;\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldSamePackage\n+    version 64:0\n+{\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTestClasses.jasm","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldPoint\n+    version 64:0\n+{\n+\n+    private final Field x:I;\n+    private final Field y:I;\n+\n+    public static Method make:\"(II)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\"\n+        stack 4\n+    {\n+        aconst_init runtime\/valhalla\/inlinetypes\/WithFieldPoint;\n+        dup;\n+        iconst_0;\n+        iconst_0;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        iload_0;\n+        withfield x:I;\n+        dup;\n+        iload_0;\n+        iconst_0;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        iload_1;\n+        withfield y:I;\n+        dup;\n+        iload_0;\n+        iload_1;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        areturn;\n+    }\n+\n+    public Method getX:\"()I\" stack 1 {\n+        aload_0;\n+        getfield x:I;\n+        ireturn;\n+    }\n+\n+    public Method getY:\"()I\" stack 1 {\n+        aload_0;\n+        getfield y:I;\n+        ireturn;\n+    }\n+\n+    public Method withX:\"(I)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield x:I;\n+        areturn;\n+    }\n+\n+    public Method withY:\"(I)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield y:I;\n+        areturn;\n+    }\n+\n+    public Method checkFields:\"(II)V\" stack 3 {\n+        aload_0;\n+        getfield x:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload_1;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"invalid x value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield y:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload_2;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"invalid y value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        return;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/AllTypes\n+    version 64:0\n+{\n+\n+    public final Field z:Z;\n+    public final Field b:B;\n+    public final Field s:S;\n+    public final Field c:C;\n+    public final Field i:I;\n+    public final Field l:J;\n+    public final Field f:F;\n+    public final Field d:D;\n+    public final Field o:\"Ljava\/lang\/Object;\";\n+    public final Field p:\"Qruntime\/valhalla\/inlinetypes\/Point;\";\n+\n+    public Method set_z:\"(Z)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield z:Z;\n+        areturn;\n+    }\n+\n+    public Method set_b:\"(B)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield b:B;\n+        areturn;\n+    }\n+\n+    public Method set_s:\"(S)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield s:S;\n+        areturn;\n+    }\n+\n+    public Method set_c:\"(C)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield c:C;\n+        areturn;\n+    }\n+\n+    public Method set_i:\"(I)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield i:I;\n+        areturn;\n+    }\n+\n+    public Method set_l:\"(J)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 3 {\n+        aload_0;\n+        lload_1;\n+        withfield l:J;\n+        areturn;\n+    }\n+\n+    public Method set_f:\"(F)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        fload_1;\n+        withfield f:F;\n+        areturn;\n+    }\n+\n+    public Method set_d:\"(D)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 3 {\n+        aload_0;\n+        dload_1;\n+        withfield d:D;\n+        areturn;\n+    }\n+\n+    public Method set_o:\"(Ljava\/lang\/Object;)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        aload_1;\n+        withfield o:\"Ljava\/lang\/Object;\";\n+        areturn;\n+    }\n+\n+    public Method set_p:\"(Qruntime\/valhalla\/inlinetypes\/Point;)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        aload_1;\n+        withfield p:\"Qruntime\/valhalla\/inlinetypes\/Point;\";\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldTestClasses.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,581 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ These tests are based on this .java file.  Each test case changed an access\n+\/\/ flag to cause a ClassFormatError exception when loading the class.\n+\/*\n+public abstract value class AbstractV {\n+\n+    static int x = 3;\n+\n+    public static synchronized void meth() {\n+        System.out.println(\"hi\");\n+    }\n+}\n+*\/\n+\n+\/\/ Removed ACC_STATIC from field access flags.\n+class AbstractVField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVField\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVField.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0441; \/\/ access [ ACC_PUBLIC ACC_ABSTRACT ACC_VALUE ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0000; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVField\n+\n+\n+\/\/ Added ACC_FINAL to class access flags.\n+class AbstractVFinal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVFinal\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVFinal.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0451; \/\/ access [ ACC_FINAL ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVFinal\n+\n+\n+\/\/ Added ACC_INTERFACE to class access flags\n+class AbstractVintf {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVintf\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVintf.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0641; \/\/ access [ ACC_INTERFACE ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVintf\n+\n+\n+\/\/ Changed the access flags for synchronized method meth() to not be static.\n+class AbstractVMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVMethod\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVMethod.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0441; \/\/ access [ ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x016F\n+      0x0021; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVMethod\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCCFETests.jcod","additions":581,"deletions":0,"binary":false,"changes":581,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This is an abstract class that cannot be a super class for value classes\n+\/\/ because ACC_IDENTITY is set in its class access flags.\n+\/\/ It's based on the following source:\n+\/*\n+public abstract class NonPVSuper {\n+\n+    static int x = 3;\n+\n+    public static void meth() {\n+        System.out.println(\"hi\");\n+    }\n+}\n+*\/\n+class NonPVSuper {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"NonPVSuper\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"NonPVSuper.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0421; \/\/ access [ ACC_PUBLIC ACC_IDENTITY ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0009; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NonPVSuper\n+\n+\n+\/\/ Dot is a value class that tries to inherit from a super class (NonPVSuper)\n+\/\/ that has access flag ACC_IDENTITY set.\n+\/\/ Dot is based on the following source:\n+\/*\n+public value final class Dot extends NonPVSuper {\n+    int x = 3;\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+class Dot {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [18] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"Dot\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"NonPVSuper\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x35\n+    Utf8 \"()I\"; \/\/ #10     at 0x3C\n+    Utf8 \"Code\"; \/\/ #11     at 0x42\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x49\n+    Utf8 \"<init>\"; \/\/ #13     at 0x5B\n+    Utf8 \"()LDot;\"; \/\/ #14     at 0x64\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x6E\n+    Utf8 \"Dot.java\"; \/\/ #16     at 0x7B\n+    Utf8 \"Preload\"; \/\/ #17     at 0x86\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9A\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xA4\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xAC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xC3\n+              [1] { \/\/ line_number_table\n+                0  5; \/\/  at 0xCF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xCF\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <init>\n+      #14; \/\/ descriptor_index : ()LDot;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 41) { \/\/ Code at 0xD7\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B062A5FCC;\n+            0x00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 10) { \/\/ LineNumberTable at 0xF6\n+              [2] { \/\/ line_number_table\n+                0  1; \/\/  at 0x0102\n+                4  2; \/\/  at 0x0106\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0108\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#17, 4) { \/\/ Preload at 0x0110\n+      0x00010001;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class Dot\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCICCETests.jcod","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,2696 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This file contains multiple illegal inline type classes that should cause\n+\/\/ ClassFormatError exceptions when attempted to be loaded.\n+\/\/\n+\/\/ Many of these test were originally generated from this Java file and then\n+\/\/ modified to cause ClassFormatError or ClassCircularityError exceptions.  The\n+\/\/ '(bad)' comments in most of the tests show where the modifications were made.\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_ABSTRACT set.\n+\/\/\n+class ValueAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueAbstract\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueAbstract;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueAbstract\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueAbstract;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueAbstract.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x0C30; \/\/ access [  ACC_PRIMITIVE ACC_ABSTRACT(bad) ACC_SUPER ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueAbstract\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_ENUM set.\n+\/\/\n+class ValueEnum {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueEnum\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueEnum;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueEnum\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueEnum;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueEnum.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x04850; \/\/ access [  ACC_VALUE ACC_PRIMITIVE ACC_ENUM(bad) ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueEnum\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that inline type fields must be final.\n+\/\/\n+class ValueFieldNotFinal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueFieldNotFinal\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueFieldNotFinal;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueFieldNotFinal\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueFieldNotFinal;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueFieldNotFinal.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0000; \/\/ access [ Field not ACC_FINAL(bad) ]\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueFieldNotFinal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_INTERFACE set.\n+\/\/\n+class ValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LValueInterface;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x3C\n+    Utf8 \"I\"; \/\/ #11     at 0x44\n+    Utf8 \"<init>\"; \/\/ #12     at 0x48\n+    Utf8 \"()V\"; \/\/ #13     at 0x51\n+    Utf8 \"Code\"; \/\/ #14     at 0x57\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5E\n+    Utf8 \"makeValueInterface\"; \/\/ #16     at 0x70\n+    Utf8 \"(I)LValueInterface;\"; \/\/ #17     at 0x80\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x91\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x9C\n+    Utf8 \"ValueInterface.java\"; \/\/ #20     at 0xA9\n+    NameAndType #12 #13; \/\/ #21     at 0xBA\n+    NameAndType #10 #11; \/\/ #22     at 0xBF\n+    Utf8 \"ValueInterface\"; \/\/ #23     at 0xC4\n+    NameAndType #16 #17; \/\/ #24     at 0xD0\n+    NameAndType #8 #9; \/\/ #25     at 0xD5\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xDA\n+  } \/\/ Constant Pool\n+\n+  0x0A30; \/\/ access [ ACC_PRIMITIVE ACC_INTERFACE(bad) ACC_SUPER ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF7\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xFF\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0141\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0149\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0167\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0173\n+                4  9; \/\/  at 0x0177\n+                10  10; \/\/  at 0x017B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x01AC\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueInterface\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that inline type instance methods cannot be synchronized.\n+\/\/\n+\/\/ final inline class ValueMethodSynch {\n+\/\/     final int int_v;\n+\/\/\n+\/\/     ValueMethodSynch() { int_v = 1; }\n+\/\/\n+\/\/     int getInt(int x) { return x; }\n+\/\/ }\n+\n+class ValueMethodSynch {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"getInt\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)I\"; \/\/ #10     at 0x39\n+    Utf8 \"Code\"; \/\/ #11     at 0x40\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x47\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x59\n+    Utf8 \"()I\"; \/\/ #14     at 0x64\n+    Utf8 \"equals\"; \/\/ #15     at 0x6A\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x73\n+    Utf8 \"toString\"; \/\/ #17     at 0x8B\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0x96\n+    Utf8 \"<init>\"; \/\/ #19     at 0xAD\n+    Utf8 \"()QValueMethodSynch;\"; \/\/ #20     at 0xB6\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xCD\n+    Utf8 \"ValueMethodSynch.java\"; \/\/ #22     at 0xDA\n+    Utf8 \"ValueMethodSynch\"; \/\/ #23     at 0xF2\n+    NameAndType #7 #8; \/\/ #24     at 0x0105\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010A\n+    MethodHandle 6b #31; \/\/ #26     at 0x011D\n+    NameAndType #13 #32; \/\/ #27     at 0x0121\n+    NameAndType #15 #33; \/\/ #28     at 0x0126\n+    NameAndType #17 #34; \/\/ #29     at 0x012B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0130\n+    Method #35 #36; \/\/ #31     at 0x0143\n+    Utf8 \"(QValueMethodSynch;)I\"; \/\/ #32     at 0x0148\n+    Utf8 \"(QValueMethodSynch;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x0160\n+    Utf8 \"(QValueMethodSynch;)Ljava\/lang\/String;\"; \/\/ #34     at 0x018A\n+    class #37; \/\/ #35     at 0x01B3\n+    NameAndType #38 #42; \/\/ #36     at 0x01B6\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01BB\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01E4\n+    class #44; \/\/ #39     at 0x01FA\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01FD\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x0206\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0215\n+    class #45; \/\/ #43     at 0x028B\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x028E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02B6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02E1\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02EB\n+      0x0020; \/\/ access [ ACC_SYNCHRONIZED(bad) ]\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 26) { \/\/ Code at 0x02F3\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[2]{\n+            0x1BAC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0307\n+              [1] { \/\/ LineNumberTable\n+                0  9; \/\/  at 0x0313\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0313\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031B\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0334\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0340\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x0348\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0362\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x036E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036E\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0376\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x038F\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039B\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A3\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C2\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03CE\n+                4  5; \/\/  at 0x03D2\n+                11  6; \/\/  at 0x03D6\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03D8\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E0\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F0\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F0\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class ValueMethodSynch\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Inline types Circ and Circ2 have fields of each other's type.  This should\n+\/\/ cause a ClassCircularityError exception when one of them is being loaded.\n+\/\/\n+\/\/ The inline types are based on these two Java classes:\n+\/\/\n+\/\/ final inline class Circ {\n+\/\/     static final Circ VT = makeCirc(0x01234567);\n+\/\/     final int int_v;\n+\/\/     final Circ2 v2;\n+\/\/     Circ() {\n+\/\/         int_v = 1;\n+\/\/         v2 = Circ2.default;\n+\/\/     }\n+\/\/     static Circ makeCirc(int x) {\n+\/\/         Circ v = Circ.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/----------------------------------------------------------------\n+\/\/ final inline class Circ2 {\n+\/\/     static final Circ2 VT = makeCirc2('\\u0123');\n+\/\/     final char char_v;\n+\/\/     final Circ vv;\n+\/\/     Circ2() {\n+\/\/         char_v = 'z';\n+\/\/         vv = Circ.default;\n+\/\/     }\n+\/\/     static Circ2 makeCirc2(char c) {\n+\/\/         Circ2 v = Circ2.default;\n+\/\/         v = __WithField(v.char_v, c);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+class Circ {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    class #36; \/\/ #3     at 0x12\n+    Field #1 #37; \/\/ #4     at 0x15\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1A\n+    InvokeDynamic 0s #41; \/\/ #6     at 0x1F\n+    InvokeDynamic 0s #42; \/\/ #7     at 0x24\n+    int 0x01234567; \/\/ #8     at 0x29\n+    Method #1 #43; \/\/ #9     at 0x2E\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCirc;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x49\n+    Utf8 \"I\"; \/\/ #15     at 0x51\n+    Utf8 \"v2\"; \/\/ #16     at 0x55\n+    Utf8 \"QCirc2;\"; \/\/ #17     at 0x5A\n+    Utf8 \"makeCirc\"; \/\/ #18     at 0x64\n+    Utf8 \"(I)QCirc;\"; \/\/ #19     at 0x6F\n+    Utf8 \"Code\"; \/\/ #20     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x82\n+    Utf8 \"hashCode\"; \/\/ #22     at 0x94\n+    Utf8 \"()I\"; \/\/ #23     at 0x9F\n+    Utf8 \"equals\"; \/\/ #24     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xAE\n+    Utf8 \"toString\"; \/\/ #26     at 0xC6\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xD1\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0xE8\n+    Utf8 \"()V\"; \/\/ #29     at 0xF3\n+    Utf8 \"<init>\"; \/\/ #30     at 0xF9\n+    Utf8 \"()QCirc;\"; \/\/ #31     at 0x0102\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x010D\n+    Utf8 \"Circ.java\"; \/\/ #33     at 0x011A\n+    Utf8 \"Circ\"; \/\/ #34     at 0x0126\n+    NameAndType #14 #15; \/\/ #35     at 0x012D\n+    Utf8 \"Circ2\"; \/\/ #36     at 0x0132\n+    NameAndType #16 #17; \/\/ #37     at 0x013A\n+    Utf8 \"BootstrapMethods\"; \/\/ #38     at 0x013F\n+    MethodHandle 6b #46; \/\/ #39     at 0x0152\n+    NameAndType #22 #47; \/\/ #40     at 0x0156\n+    NameAndType #24 #48; \/\/ #41     at 0x015B\n+    NameAndType #26 #49; \/\/ #42     at 0x0160\n+    NameAndType #18 #19; \/\/ #43     at 0x0165\n+    NameAndType #12 #13; \/\/ #44     at 0x016A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x016F\n+    Method #50 #51; \/\/ #46     at 0x0182\n+    Utf8 \"(QCirc;)I\"; \/\/ #47     at 0x0187\n+    Utf8 \"(QCirc;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x0193\n+    Utf8 \"(QCirc;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01B1\n+    class #52; \/\/ #50     at 0x01CE\n+    NameAndType #53 #57; \/\/ #51     at 0x01D1\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x01D6\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x01FF\n+    class #59; \/\/ #54     at 0x0215\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0218\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x0221\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x0230\n+    class #60; \/\/ #58     at 0x02A6\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02A9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x02D1\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x02FC\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0304\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030C\n+      0x0010; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0316\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x031E\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x033D\n+              [3] { \/\/ LineNumberTable\n+                0  12; \/\/  at 0x0349\n+                4  13; \/\/  at 0x034D\n+                11  14; \/\/  at 0x0351\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0351\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x0359\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0372\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x037E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x037E\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x0386\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00060000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03A0\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03AC\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03AC\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03B4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00070000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03CD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03D9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03D9\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 33) { \/\/ Code at 0x03E1\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1208B80009B3000A;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03FC\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0408\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0408\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 58) { \/\/ Code at 0x0410\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[22]{\n+            0xCB00014B042A5FCC;\n+            0x00024BCB00032A5F;\n+            0xCC00044B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 18) { \/\/ LineNumberTable at 0x0438\n+              [4] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0444\n+                4  7; \/\/  at 0x0448\n+                11  8; \/\/  at 0x044C\n+                20  9; \/\/  at 0x0450\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x0452\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x045A\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x046A\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#38, 6) { \/\/ BootstrapMethods at 0x046A\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #39; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class Circ\n+\n+class Circ2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [60] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #33; \/\/ #1     at 0x0A\n+    Field #1 #34; \/\/ #2     at 0x0D\n+    class #35; \/\/ #3     at 0x12\n+    Field #1 #36; \/\/ #4     at 0x15\n+    InvokeDynamic 0s #39; \/\/ #5     at 0x1A\n+    InvokeDynamic 0s #40; \/\/ #6     at 0x1F\n+    InvokeDynamic 0s #41; \/\/ #7     at 0x24\n+    Method #1 #42; \/\/ #8     at 0x29\n+    Field #1 #43; \/\/ #9     at 0x2E\n+    class #44; \/\/ #10     at 0x33\n+    Utf8 \"VT\"; \/\/ #11     at 0x36\n+    Utf8 \"QCirc2;\"; \/\/ #12     at 0x3B\n+    Utf8 \"char_v\"; \/\/ #13     at 0x45\n+    Utf8 \"C\"; \/\/ #14     at 0x4E\n+    Utf8 \"vv\"; \/\/ #15     at 0x52\n+    Utf8 \"QCirc;\"; \/\/ #16     at 0x57\n+    Utf8 \"makeCirc2\"; \/\/ #17     at 0x60\n+    Utf8 \"(C)QCirc2;\"; \/\/ #18     at 0x6C\n+    Utf8 \"Code\"; \/\/ #19     at 0x79\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0x80\n+    Utf8 \"hashCode\"; \/\/ #21     at 0x92\n+    Utf8 \"()I\"; \/\/ #22     at 0x9D\n+    Utf8 \"equals\"; \/\/ #23     at 0xA3\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAC\n+    Utf8 \"toString\"; \/\/ #25     at 0xC4\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #26     at 0xCF\n+    Utf8 \"<clinit>\"; \/\/ #27     at 0xE6\n+    Utf8 \"()V\"; \/\/ #28     at 0xF1\n+    Utf8 \"<init>\"; \/\/ #29     at 0xF7\n+    Utf8 \"()QCirc2;\"; \/\/ #30     at 0x0100\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x010C\n+    Utf8 \"Circ2.java\"; \/\/ #32     at 0x0119\n+    Utf8 \"Circ2\"; \/\/ #33     at 0x0126\n+    NameAndType #13 #14; \/\/ #34     at 0x012E\n+    Utf8 \"Circ\"; \/\/ #35     at 0x0133\n+    NameAndType #15 #16; \/\/ #36     at 0x013A\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x013F\n+    MethodHandle 6b #45; \/\/ #38     at 0x0152\n+    NameAndType #21 #46; \/\/ #39     at 0x0156\n+    NameAndType #23 #47; \/\/ #40     at 0x015B\n+    NameAndType #25 #48; \/\/ #41     at 0x0160\n+    NameAndType #17 #18; \/\/ #42     at 0x0165\n+    NameAndType #11 #12; \/\/ #43     at 0x016A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #44     at 0x016F\n+    Method #49 #50; \/\/ #45     at 0x0182\n+    Utf8 \"(QCirc2;)I\"; \/\/ #46     at 0x0187\n+    Utf8 \"(QCirc2;Ljava\/lang\/Object;)Z\"; \/\/ #47     at 0x0194\n+    Utf8 \"(QCirc2;)Ljava\/lang\/String;\"; \/\/ #48     at 0x01B3\n+    class #51; \/\/ #49     at 0x01D1\n+    NameAndType #52 #56; \/\/ #50     at 0x01D4\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #51     at 0x01D9\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #52     at 0x0202\n+    class #58; \/\/ #53     at 0x0218\n+    Utf8 \"Lookup\"; \/\/ #54     at 0x021B\n+    Utf8 \"InnerClasses\"; \/\/ #55     at 0x0224\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #56     at 0x0233\n+    class #59; \/\/ #57     at 0x02A9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #58     at 0x02AC\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #59     at 0x02D4\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #10;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x02FF\n+      0x0018; \/\/ access\n+      #11; \/\/ name_cpx\n+      #12; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0307\n+      0x0010; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030F\n+      0x0010; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0319\n+      0x0008; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 45) { \/\/ Code at 0x0321\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 14) { \/\/ LineNumberTable at 0x0340\n+              [3] { \/\/ LineNumberTable\n+                0  12; \/\/  at 0x034C\n+                4  13; \/\/  at 0x0350\n+                11  14; \/\/  at 0x0354\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0354\n+      0x0011; \/\/ access\n+      #21; \/\/ name_cpx\n+      #22; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 31) { \/\/ Code at 0x035C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x0375\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0381\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0381\n+      0x0011; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 32) { \/\/ Code at 0x0389\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00060000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x03A3\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03AF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03AF\n+      0x0011; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 31) { \/\/ Code at 0x03B7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00070000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x03D0\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03DC\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03DC\n+      0x0008; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 34) { \/\/ Code at 0x03E4\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[10]{\n+            0x110123B80008B300;\n+            0x09B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x0400\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x040C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x040C\n+      0x0008; \/\/ access\n+      #29; \/\/ name_cpx\n+      #30; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 59) { \/\/ Code at 0x0414\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B107A2A5F;\n+            0xCC00024BCB00032A;\n+            0x5FCC00044B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 18) { \/\/ LineNumberTable at 0x043D\n+              [4] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0449\n+                4  7; \/\/  at 0x044D\n+                12  8; \/\/  at 0x0451\n+                21  9; \/\/  at 0x0455\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x0457\n+      #32;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#55, 10) { \/\/ InnerClasses at 0x045F\n+      [1] { \/\/ InnerClasses\n+        #53 #57 #54 25; \/\/  at 0x046F\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x046F\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class Circ2\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Inline types CircStaticA and CircStaticB have static fields of each other's\n+\/\/ type.  This should cause a ClassCircularityError exception when one of them\n+\/\/ is being loaded.\n+\/\/\n+\/\/ The inline types are based on these two Java classes:\n+\/\/\n+\/\/ final inline class CircStaticA {\n+\/\/     static final CircStaticA VT = makeCircStaticA(0x01234567);\n+\/\/     final int int_v;\n+\/\/     static final CircStaticB v2 = CircStaticB.default;\n+\/\/     CircStaticA() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static CircStaticA makeCircStaticA(int x) {\n+\/\/         CircStaticA v = CircStaticA.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/----------------------------------------------------------------\n+\/\/ final inline class CircStaticB {\n+\/\/     static final CircStaticB VT = makeCircStaticB(0x01234567);\n+\/\/     final int int_v;\n+\/\/     static final CircStaticA v2 = CircStaticA.default;\n+\/\/     CircStaticB() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static CircStaticB makeCircStaticB(int x) {\n+\/\/         CircStaticB v = CircStaticB.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+class CircStaticA {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #38; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #39; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1C\n+    int 0x01234567; \/\/ #6     at 0x21\n+    Method #1 #41; \/\/ #7     at 0x26\n+    Field #1 #42; \/\/ #8     at 0x2B\n+    class #43; \/\/ #9     at 0x30\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCircStaticA;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x50\n+    Utf8 \"I\"; \/\/ #15     at 0x58\n+    Utf8 \"v2\"; \/\/ #16     at 0x5C\n+    Utf8 \"QCircStaticB;\"; \/\/ #17     at 0x61\n+    Utf8 \"makeCircStaticA\"; \/\/ #18     at 0x71\n+    Utf8 \"(I)QCircStaticA;\"; \/\/ #19     at 0x83\n+    Utf8 \"Code\"; \/\/ #20     at 0x96\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x9D\n+    Utf8 \"hashCode\"; \/\/ #22     at 0xAF\n+    Utf8 \"()I\"; \/\/ #23     at 0xBA\n+    Utf8 \"equals\"; \/\/ #24     at 0xC0\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xC9\n+    Utf8 \"toString\"; \/\/ #26     at 0xE1\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xEC\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0x0103\n+    Utf8 \"()V\"; \/\/ #29     at 0x010E\n+    Utf8 \"<init>\"; \/\/ #30     at 0x0114\n+    Utf8 \"()QCircStaticA;\"; \/\/ #31     at 0x011D\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x012F\n+    Utf8 \"CircStaticA.java\"; \/\/ #33     at 0x013C\n+    Utf8 \"CircStaticA\"; \/\/ #34     at 0x014F\n+    NameAndType #14 #15; \/\/ #35     at 0x015D\n+    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0162\n+    MethodHandle 6b #46; \/\/ #37     at 0x0175\n+    NameAndType #22 #47; \/\/ #38     at 0x0179\n+    NameAndType #24 #48; \/\/ #39     at 0x017E\n+    NameAndType #26 #49; \/\/ #40     at 0x0183\n+    NameAndType #18 #19; \/\/ #41     at 0x0188\n+    NameAndType #12 #13; \/\/ #42     at 0x018D\n+    Utf8 \"CircStaticB\"; \/\/ #43     at 0x0192\n+    NameAndType #16 #17; \/\/ #44     at 0x01A0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x01A5\n+    Method #50 #51; \/\/ #46     at 0x01B8\n+    Utf8 \"(QCircStaticA;)I\"; \/\/ #47     at 0x01BD\n+    Utf8 \"(QCircStaticA;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x01D0\n+    Utf8 \"(QCircStaticA;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01F5\n+    class #52; \/\/ #50     at 0x0219\n+    NameAndType #53 #57; \/\/ #51     at 0x021C\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x0221\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x024A\n+    class #59; \/\/ #54     at 0x0260\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0263\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x026C\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x027B\n+    class #60; \/\/ #58     at 0x02F1\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02F4\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x031C\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x0347\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x034F\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0357\n+      0x0018; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0361\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0369\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0388\n+              [3] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x0394\n+                4  12; \/\/  at 0x0398\n+                11  13; \/\/  at 0x039C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039C\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03A4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03BD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C9\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x03D1\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03EB\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F7\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03FF\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0418\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0424\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0424\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 43) { \/\/ Code at 0x042C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[15]{\n+            0x1206B80007B30008;\n+            0xCB0009B3000AB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 10) { \/\/ LineNumberTable at 0x044D\n+              [2] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0459\n+                8  4; \/\/  at 0x045D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x045D\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0465\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0484\n+              [3] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0490\n+                4  7; \/\/  at 0x0494\n+                11  8; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x049A\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x04A2\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x04B2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#36, 6) { \/\/ BootstrapMethods at 0x04B2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #37; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class CircStaticA\n+\n+class CircStaticB {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #38; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #39; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1C\n+    int 0x01234567; \/\/ #6     at 0x21\n+    Method #1 #41; \/\/ #7     at 0x26\n+    Field #1 #42; \/\/ #8     at 0x2B\n+    class #43; \/\/ #9     at 0x30\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCircStaticB;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x50\n+    Utf8 \"I\"; \/\/ #15     at 0x58\n+    Utf8 \"v2\"; \/\/ #16     at 0x5C\n+    Utf8 \"QCircStaticA;\"; \/\/ #17     at 0x61\n+    Utf8 \"makeCircStaticB\"; \/\/ #18     at 0x71\n+    Utf8 \"(I)QCircStaticB;\"; \/\/ #19     at 0x83\n+    Utf8 \"Code\"; \/\/ #20     at 0x96\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x9D\n+    Utf8 \"hashCode\"; \/\/ #22     at 0xAF\n+    Utf8 \"()I\"; \/\/ #23     at 0xBA\n+    Utf8 \"equals\"; \/\/ #24     at 0xC0\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xC9\n+    Utf8 \"toString\"; \/\/ #26     at 0xE1\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xEC\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0x0103\n+    Utf8 \"()V\"; \/\/ #29     at 0x010E\n+    Utf8 \"<init>\"; \/\/ #30     at 0x0114\n+    Utf8 \"()QCircStaticB;\"; \/\/ #31     at 0x011D\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x012F\n+    Utf8 \"CircStaticB.java\"; \/\/ #33     at 0x013C\n+    Utf8 \"CircStaticB\"; \/\/ #34     at 0x014F\n+    NameAndType #14 #15; \/\/ #35     at 0x015D\n+    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0162\n+    MethodHandle 6b #46; \/\/ #37     at 0x0175\n+    NameAndType #22 #47; \/\/ #38     at 0x0179\n+    NameAndType #24 #48; \/\/ #39     at 0x017E\n+    NameAndType #26 #49; \/\/ #40     at 0x0183\n+    NameAndType #18 #19; \/\/ #41     at 0x0188\n+    NameAndType #12 #13; \/\/ #42     at 0x018D\n+    Utf8 \"CircStaticA\"; \/\/ #43     at 0x0192\n+    NameAndType #16 #17; \/\/ #44     at 0x01A0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x01A5\n+    Method #50 #51; \/\/ #46     at 0x01B8\n+    Utf8 \"(QCircStaticB;)I\"; \/\/ #47     at 0x01BD\n+    Utf8 \"(QCircStaticB;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x01D0\n+    Utf8 \"(QCircStaticB;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01F5\n+    class #52; \/\/ #50     at 0x0219\n+    NameAndType #53 #57; \/\/ #51     at 0x021C\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x0221\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x024A\n+    class #59; \/\/ #54     at 0x0260\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0263\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x026C\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x027B\n+    class #60; \/\/ #58     at 0x02F1\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02F4\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x031C\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x0347\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x034F\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0357\n+      0x0018; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0361\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0369\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0388\n+              [3] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x0394\n+                4  12; \/\/  at 0x0398\n+                11  13; \/\/  at 0x039C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039C\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03A4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03BD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C9\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x03D1\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03EB\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F7\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03FF\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0418\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0424\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0424\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 43) { \/\/ Code at 0x042C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[15]{\n+            0x1206B80007B30008;\n+            0xCB0009B3000AB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 10) { \/\/ LineNumberTable at 0x044D\n+              [2] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0459\n+                8  4; \/\/  at 0x045D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x045D\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0465\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0484\n+              [3] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0490\n+                4  7; \/\/  at 0x0494\n+                11  8; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x049A\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x04A2\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x04B2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#36, 6) { \/\/ BootstrapMethods at 0x04B2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #37; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class CircStaticB\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that an inline type cannot be Cloneable.\n+\/\/\n+\/\/ final inline class ValueCloneable implements Cloneable {\n+\/\/    final int field;\n+\/\/    private ValueCloneable() { field = 0; }\n+\/\/}\n+\n+class ValueCloneable {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #22; \/\/ #1     at 0x0A\n+    Field #1 #23; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #26; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #27; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #28; \/\/ #5     at 0x1C\n+    class #29; \/\/ #6     at 0x21\n+    class #30; \/\/ #7     at 0x24\n+    Utf8 \"field\"; \/\/ #8     at 0x27\n+    Utf8 \"I\"; \/\/ #9     at 0x2F\n+    Utf8 \"hashCode\"; \/\/ #10     at 0x33\n+    Utf8 \"()I\"; \/\/ #11     at 0x3E\n+    Utf8 \"Code\"; \/\/ #12     at 0x44\n+    Utf8 \"LineNumberTable\"; \/\/ #13     at 0x4B\n+    Utf8 \"equals\"; \/\/ #14     at 0x5D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #15     at 0x66\n+    Utf8 \"toString\"; \/\/ #16     at 0x7E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #17     at 0x89\n+    Utf8 \"<init>\"; \/\/ #18     at 0xA0\n+    Utf8 \"()QValueCloneable;\"; \/\/ #19     at 0xA9\n+    Utf8 \"SourceFile\"; \/\/ #20     at 0xBE\n+    Utf8 \"ValueCloneable.java\"; \/\/ #21     at 0xCB\n+    Utf8 \"ValueCloneable\"; \/\/ #22     at 0xE1\n+    NameAndType #8 #9; \/\/ #23     at 0xF2\n+    Utf8 \"BootstrapMethods\"; \/\/ #24     at 0xF7\n+    MethodHandle 6b #31; \/\/ #25     at 0x010A\n+    NameAndType #10 #32; \/\/ #26     at 0x010E\n+    NameAndType #14 #33; \/\/ #27     at 0x0113\n+    NameAndType #16 #34; \/\/ #28     at 0x0118\n+    Utf8 \"java\/lang\/Object\"; \/\/ #29     at 0x011D\n+    Utf8 \"java\/lang\/Cloneable\"; \/\/ #30     at 0x0130\n+    Method #35 #36; \/\/ #31     at 0x0146\n+    Utf8 \"(QValueCloneable;)I\"; \/\/ #32     at 0x014B\n+    Utf8 \"(QValueCloneable;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x0161\n+    Utf8 \"(QValueCloneable;)Ljava\/lang\/String;\"; \/\/ #34     at 0x0189\n+    class #37; \/\/ #35     at 0x01B0\n+    NameAndType #38 #42; \/\/ #36     at 0x01B3\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01B8\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01E1\n+    class #44; \/\/ #39     at 0x01F7\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01FA\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0212\n+    class #45; \/\/ #43     at 0x0288\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x028B\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02B3\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [1] { \/\/ Interfaces\n+    #7;\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02E0\n+      0x0010; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [4] { \/\/ methods\n+    { \/\/ Member at 0x02EA\n+      0x0011; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 31) { \/\/ Code at 0x02F2\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x030B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0317\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0317\n+      0x0011; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 32) { \/\/ Code at 0x031F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0339\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0345\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0345\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 31) { \/\/ Code at 0x034D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0366\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0372\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0372\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 37) { \/\/ Code at 0x037A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B032A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0399\n+              [1] { \/\/ LineNumberTable\n+                0  3; \/\/  at 0x03A5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#20, 2) { \/\/ SourceFile at 0x03A7\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03AF\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03BF\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#24, 6) { \/\/ BootstrapMethods at 0x03BF\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class ValueCloneable\n+\n+\n+\/\/ Test that a class with an old class file version cannot contain a Q signature.\n+class OldClassWithQSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [29] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"OldClassWithQSig\"; \/\/ #1     at 0x0A\n+    class #1; \/\/ #2     at 0x1A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #3     at 0x1D\n+    class #3; \/\/ #4     at 0x30\n+    Utf8 \"inlineclasses.scala\"; \/\/ #5     at 0x33\n+    Utf8 \"Lscala\/reflect\/ScalaSignature;\"; \/\/ #6     at 0x49\n+    Utf8 \"bytes\"; \/\/ #7     at 0x6A\n+    Utf8 \"i1QB\\t!AAC\\bI\\t\\tQ!!Q\\nEAQ!YQ\\\"T=J]2Lg.Z\\\"mCN(\\\"q*W;z}\\r1C\\n!\\tQQ\\\"D\\fa!B:dC2\\fB\\b\\f\\te.*fM\\t.F!\\tQ!#\\tJ;%Aj]&$h\\b3AA!)qba#\"; \/\/ #8     at 0x72\n+    Utf8 \"i\"; \/\/ #9     at 0x0128\n+    Utf8 \"I\"; \/\/ #10     at 0x012C\n+    Utf8 \"()I\"; \/\/ #11     at 0x0130\n+    NameAndType #9 #10; \/\/ #12     at 0x0136\n+    Field #2 #12; \/\/ #13     at 0x013B\n+    Utf8 \"this\"; \/\/ #14     at 0x0140\n+    Utf8 \"QOldClassWithQSig;\"; \/\/ #15     at 0x0147\n+    Utf8 \"<init>\"; \/\/ #16     at 0x0159\n+    Utf8 \"(I)V\"; \/\/ #17     at 0x0162\n+    Utf8 \"()V\"; \/\/ #18     at 0x0169\n+    NameAndType #16 #18; \/\/ #19     at 0x016F\n+    Method #4 #19; \/\/ #20     at 0x0174\n+    Utf8 \"Code\"; \/\/ #21     at 0x0179\n+    Utf8 \"LineNumberTable\"; \/\/ #22     at 0x0180\n+    Utf8 \"LocalVariableTable\"; \/\/ #23     at 0x0192\n+    Utf8 \"MethodParameters\"; \/\/ #24     at 0x01A7\n+    Utf8 \"SourceFile\"; \/\/ #25     at 0x01BA\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #26     at 0x01C7\n+    Utf8 \"ScalaInlineInfo\"; \/\/ #27     at 0x01E3\n+    Utf8 \"ScalaSig\"; \/\/ #28     at 0x01F5\n+  } \/\/ Constant Pool\n+\n+  0x0121; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x020A\n+      0x0012; \/\/ access\n+      #9; \/\/ name_index       : i\n+      #10; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0214\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : i\n+      #11; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#21, 47) { \/\/ Code at 0x021C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB4000DAC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#22, 6) { \/\/ LineNumberTable at 0x0233\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0x023F\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23, 12) { \/\/ LocalVariableTable at 0x023F\n+              [1] { \/\/ LocalVariableTable\n+                0 5 14 15 0; \/\/  at 0x0251\n+              }\n+            } \/\/ end LocalVariableTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0251\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index       : <init>\n+      #17; \/\/ descriptor_index : (I)V\n+      [2] { \/\/ Attributes\n+        Attr(#21, 70) { \/\/ Code at 0x0259\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[10]{\n+            0x2A1BB5000D2AB700;\n+            0x14B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#22, 14) { \/\/ LineNumberTable at 0x0275\n+              [3] { \/\/ line_number_table\n+                0  1; \/\/  at 0x0281\n+                5  3; \/\/  at 0x0285\n+                9  1; \/\/  at 0x0289\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23, 22) { \/\/ LocalVariableTable at 0x0289\n+              [2] { \/\/ LocalVariableTable\n+                0 10 14 15 0; \/\/  at 0x029B\n+                0 10 9 10 1; \/\/  at 0x02A5\n+              }\n+            } \/\/ end LocalVariableTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#24, 5) { \/\/ MethodParameters at 0x02A5\n+          [1]b { \/\/ MethodParameters\n+            #9  0x0010; \/\/  at 0x02B0\n+          }\n+        } \/\/ end MethodParameters\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#25, 2) { \/\/ SourceFile at 0x02B2\n+      #5;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#26, 11) { \/\/ RuntimeVisibleAnnotations at 0x02BA\n+      [1] { \/\/ annotations\n+        {  \/\/  annotation\n+          #6;\n+          [1] { \/\/ element_value_pairs\n+            {  \/\/  element value pair\n+              #7;\n+              {  \/\/  element_value\n+                's';\n+                #8;\n+              }  \/\/  element_value\n+            }  \/\/  element value pair\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27, 14) { \/\/ ScalaInlineInfo at 0x02CB\n+      0x0100000200100011;\n+      0x000009000B00;\n+    } \/\/ end ScalaInlineInfo\n+    ;\n+    Attr(#28, 3) { \/\/ ScalaSig at 0x02DF\n+      0x050200;\n+    } \/\/ end ScalaSig\n+  } \/\/ Attributes\n+} \/\/ end class OldClassWithQSig\n+\n+\n+\/\/ Test that a class with an old class file version cannot contain an array Q signature.\n+class OldClassWithQArraySig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"java\/lang\/Integer\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x50\n+    class #12; \/\/ #10     at 0x55\n+    NameAndType #13 #14; \/\/ #11     at 0x58\n+    Utf8 \"OldClassWithQArraySig\"; \/\/ #12     at 0x5D\n+    Utf8 \"ia\"; \/\/ #13     at 0x65\n+    Utf8 \"[Qjava\/lang\/Integer;\"; \/\/ #14     at 0x6A\n+    Utf8 \"Code\"; \/\/ #15     at 0x81\n+    Utf8 \"LineNumberTable\"; \/\/ #16     at 0x88\n+    Utf8 \"runIt\"; \/\/ #17     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0xA2\n+    Utf8 \"OldClassWithQArraySig.java\"; \/\/ #19     at 0xAF\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xC6\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : ia\n+      #14; \/\/ descriptor_index : [Qjava\/lang\/Integer;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD0\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#15, 29) { \/\/ Code at 0xD8\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#16, 6) { \/\/ LineNumberTable at 0xEF\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFB\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFB\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index       : runIt\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#15, 37) { \/\/ Code at 0x0103\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0x2A05BD0007B50009;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#16, 10) { \/\/ LineNumberTable at 0x011E\n+              [2] { \/\/ line_number_table\n+                0  6; \/\/  at 0x012A\n+                8  7; \/\/  at 0x012E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x0130\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class OldClassWithQArraySig\n+\n+\n+\/\/ This class has a super_cpx of zero.  This should cause a ClassFormatError\n+\/\/ exception when this class is loaded.\n+class SuperIsZero {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [15] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"SuperIsZero\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1A\n+    NameAndType #5 #6; \/\/ #4     at 0x1F\n+    Utf8 \"x\"; \/\/ #5     at 0x24\n+    Utf8 \"I\"; \/\/ #6     at 0x28\n+    class #8; \/\/ #7     at 0x2C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x2F\n+    Utf8 \"<init>\"; \/\/ #9     at 0x42\n+    Utf8 \"()QSuperIsZero;\"; \/\/ #10     at 0x4B\n+    Utf8 \"Code\"; \/\/ #11     at 0x5C\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x63\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x75\n+    Utf8 \"SuperIsZero.java\"; \/\/ #14     at 0x82\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #0;\/\/ super_cpx \/\/ !!! changed 7 to 0\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9E\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xA8\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <init>\n+      #10; \/\/ descriptor_index : ()QSuperIsZero;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0xB0\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B082A5FCC;\n+            0x00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0xCF\n+              [3] { \/\/ line_number_table\n+                0  4; \/\/  at 0xDB\n+                4  5; \/\/  at 0xDF\n+                11  6; \/\/  at 0xE3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0xE5\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SuperIsZero\n+\n+\n+\/\/ This class file tests that a ClassFormatError exception is thrown for an old\n+\/\/ class file (version 49) containing a Q signature.  This file is based on the\n+\/\/ following Java code, except the signature for method callDot() was changed\n+\/\/ to \"(QDot;)V\";.\n+\/*\n+public class QInOldClass {\n+\n+    public static void callDot(Dot d) {\n+        System.out.println(\"Hi Dot\");\n+    }\n+\n+}\n+*\/\n+class QInOldClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  49; \/\/ version\n+  [32] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"Hi Dot\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x83\n+    class #18; \/\/ #16     at 0x88\n+    NameAndType #19 #20; \/\/ #17     at 0x8B\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x90\n+    Utf8 \"println\"; \/\/ #19     at 0xA6\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xB0\n+    class #22; \/\/ #21     at 0xC8\n+    Utf8 \"QInOldClass\"; \/\/ #22     at 0xCB\n+    Utf8 \"Code\"; \/\/ #23     at 0xD6\n+    Utf8 \"LineNumberTable\"; \/\/ #24     at 0xDD\n+    Utf8 \"callDot\"; \/\/ #25     at 0xEF\n+    Utf8 \"(QDot;)V\"; \/\/ #26     at 0xF9\n+    Utf8 \"SourceFile\"; \/\/ #27     at 0x0104\n+    Utf8 \"QInOldClass.java\"; \/\/ #28     at 0x0111\n+    Utf8 \"Preload\"; \/\/ #29     at 0x0121\n+    class #31; \/\/ #30     at 0x012B\n+    Utf8 \"Dot\"; \/\/ #31     at 0x012E\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0140\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#23, 29) { \/\/ Code at 0x0148\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 6) { \/\/ LineNumberTable at 0x015F\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016B\n+      0x0009; \/\/ access\n+      #25; \/\/ name_index       : callDot\n+      #26; \/\/ descriptor_index : (LDot;)V\n+      [1] { \/\/ Attributes\n+        Attr(#23, 37) { \/\/ Code at 0x0173\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 10) { \/\/ LineNumberTable at 0x018E\n+              [2] { \/\/ line_number_table\n+                0  5; \/\/  at 0x019A\n+                8  6; \/\/  at 0x019E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#27, 2) { \/\/ SourceFile at 0x01A0\n+      #28;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#29, 4) { \/\/ Preload at 0x01A8\n+      0x0001001E;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class QInOldClass\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":2696,"deletions":0,"binary":false,"changes":2696,"status":"added"},{"patch":"@@ -0,0 +1,832 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ class ValueClassExtendingIdentityClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingIdentityClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"IdentityAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingIdentityClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingIdentityClass.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingIdentityClass\n+\n+class ValueClassExtendingAbstractClassWithField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingAbstractClassWithField\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"AbstractWithField\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingAbstractClassWithField;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingAbstractClassWithField.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingAbstractClassWithField\n+\n+class ValueClassExtendingAbstractClassWithSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingAbstractClassWithSynchMethod\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"AbstractWithSynchMethod\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingAbstractClassWithSynchMethod;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingAbstractClassWithSynchMethod.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingAbstractClassWithSynchMethod\n+\n+class ValueClassImplementingIdentityInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassImplementingIdentityInterface\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"IdentityInterface\"; \/\/ #6\n+    Utf8 \"<init>\"; \/\/ #7\n+    Utf8 \"()LValueClassImplementingIdentityInterface;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClassImplementingIdentityInterface.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassImplementingIdentityInterface\n+\n+class IdentityClassExtendingValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"ValueAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClassExtendingValueClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"IdentityClassExtendingValueClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class IdentityClassExtendingValueClass\n+\n+class IdentityClassImplementingValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClassImplementingValueInterface\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"ValueInterface\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"IdentityClassImplementingValueInterface.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #9;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class IdentityClassImplementingValueInterface\n+\n+class AbstractClassWithFieldExtendingValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"ValueAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldExtendingValueClass\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"AbstractClassWithFieldExtendingValueClass.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0420; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldExtendingValueClass\n+\n+class AbstractClassWithFieldImplementingValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldImplementingValueInterface\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"ValueInterface\"; \/\/ #10\n+    Utf8 \"i\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    Utf8 \"Code\"; \/\/ #13\n+    Utf8 \"LineNumberTable\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"AbstractClassWithFieldImplementingValueInterface.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0420; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #9;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldImplementingValueInterface\n+\n+class AbstractClassWithFieldWithNoIdentityModifier {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldWithNoIdentityModifier\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"AbstractClassWithFieldWithNoIdentityModifier.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0400; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldWithNoIdentityModifier\n+\n+class AbstractClassWithSynchMethodWithNoIdentityModifier {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithSynchMethodWithNoIdentityModifier\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"foo\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"AbstractClassWithSynchMethodWithNoIdentityModifier.java\"; \/\/ #13\n+  } \/\/ Constant Pool\n+\n+  0x0400; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0020; \/\/ access\n+      #11; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithSynchMethodWithNoIdentityModifier\n+\n+class AbstractClassWithBothModifiers {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithBothModifiers\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractClassWithBothModifiers.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0460; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithBothModifiers\n+\n+class ConcreteClassWithNoModifiers {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ConcreteClassWithNoModifiers\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ConcreteClassWithNoModifiers.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0000; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ConcreteClassWithNoModifiers\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/ClassesWithInvalidModifiers.jcod","additions":832,"deletions":0,"binary":false,"changes":832,"status":"added"},{"patch":"@@ -0,0 +1,2637 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ The test cases in this .jcod file are based on this .java file:\n+\/\/ public primitive final class Point extends AbstractClass {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private Point() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/ }\n+\n+\/\/ Primitive class with a super class that is not abstract.\n+class PrimitiveSuperNotAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperNotAbstract\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperNotAbstract;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperNotAbstract;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperNotAbstract;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"NotAbstract\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperNotAbstract;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperNotAbstract.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperNotAbstract\n+\n+\n+\n+\/\/ Primitive class with a super class that has instance fields.\n+class PrimitiveSuperHasNonStaticFields {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperHasNonStaticFields\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"HasNonStaticFields\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperHasNonStaticFields;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperHasNonStaticFields.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperHasNonStaticFields\n+\n+\n+\n+\/\/ primitive value class with a super class whose super class has a syncronized instance method.\n+class PrimitiveSuperHasSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperHasSynchMethod\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"ValidSuper\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperHasSynchMethod;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperHasSynchMethod.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperHasSynchMethod\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has arguments.\n+class PrimitiveSuperCtorHasArgs {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperCtorHasArgs\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorHasArgs\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperCtorHasArgs;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperCtorHasArgs.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperCtorHasArgs\n+\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has a non-empty\n+\/\/ method body.\n+class PrimitiveSuperCtorIsNotEmpty {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperCtorIsNotEmpty\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorIsNotEmpty\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperCtorIsNotEmpty;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperCtorIsNotEmpty.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperCtorIsNotEmpty\n+\n+\/\/ Again for value objects...\n+\n+\/\/ Value class with a super class that is not abstract.\n+class ValueSuperNotAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperNotAbstract\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperNotAbstract;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperNotAbstract;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperNotAbstract;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"NotAbstract\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperNotAbstract;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperNotAbstract.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperNotAbstract\n+\n+\n+\n+\/\/ Value class with a super class that has instance fields.\n+class ValueSuperHasNonStaticFields {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperHasNonStaticFields\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperHasNonStaticFields;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperHasNonStaticFields;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperHasNonStaticFields;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"HasNonStaticFields\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperHasNonStaticFields;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperHasNonStaticFields.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperHasNonStaticFields\n+\n+\n+\n+\/\/ primitive value class with a super class whose super class has a syncronized instance method.\n+class ValueSuperHasSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperHasSynchMethod\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperHasSynchMethod;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperHasSynchMethod;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperHasSynchMethod;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"ValidSuper\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperHasSynchMethod;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperHasSynchMethod.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperHasSynchMethod\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has arguments.\n+class ValueSuperCtorHasArgs {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperCtorHasArgs\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperCtorHasArgs;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperCtorHasArgs;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperCtorHasArgs;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorHasArgs\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperCtorHasArgs;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperCtorHasArgs.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperCtorHasArgs\n+\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has a non-empty\n+\/\/ method body.\n+class ValueSuperCtorIsNotEmpty {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperCtorIsNotEmpty\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorIsNotEmpty\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperCtorIsNotEmpty;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperCtorIsNotEmpty.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperCtorIsNotEmpty\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/InlineClassWithBadSupers.jcod","additions":2637,"deletions":0,"binary":false,"changes":2637,"status":"added"},{"patch":"@@ -0,0 +1,1608 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Many of the jcod classes in this file were derived from this Java inline type:\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ The changes for each test were made to the bytecodes for method makeValue(int x).\n+\/\/ Its bytecodes are:\n+\/\/\n+\/\/  static Value makeValue(int); descriptor: (I)LValue; flags: (0x0008) ACC_STATIC\n+\/\/    Code:\n+\/\/      stack=2, locals=2, args_size=1\n+\/\/         0: aconst_init   #3                  \/\/ class Value\n+\/\/         3: astore_1\n+\/\/         4: aload_1\n+\/\/         5: iload_0\n+\/\/         6: withfield     #2                  \/\/ Field int_v:I\n+\/\/         9: astore_1\n+\/\/        10: aload_1\n+\/\/        11: areturn\n+\n+\n+\/\/ The constant pool index of the aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 0x93.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class defValBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadCP;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadCP;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadCP.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadCP\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00934C2B1ACC00; \/\/ Changed CP index from 3 to 0x93 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54.  Since this class has a\n+\/\/ aconst_init opcode (0xCB), this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class defValBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 2.  Since this index now points to a Field\n+\/\/ entry instead of a Class entry, a VerifyError exception should get thrown.\n+\/\/\n+class defValWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValWrongCPType;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValWrongCPType;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValWrongCPType.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValWrongCPType\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00024C2B1ACC00; \/\/ Changed CP index from 3 to 2 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the cp index no longer points to a cp Class entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of the withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 0x82.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadCP\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadCP\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadCP;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadCP.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 0x82 for opcode 0xCC (withfield)\n+            0x824C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 5 in the Code array was changed to aload_1\n+\/\/ (0x2B).  This should cause a VerifyError because now the first operand on the\n+\/\/ stack for the withfield opcode (0xCC at bytecode position 6) does not match\n+\/\/ the type (int) of the field being assigned to.\n+\/\/\n+class wthFldBadFldVal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldVal\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldVal\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldVal;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldVal.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B2BCC00; \/\/ Changed opcode at bytecode 5 from iload_0 to aload_1\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldVal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 4 in the Code array was changed to iload_1\n+\/\/ (0x1A).  This should cause a VerifyError because the second operand on the stack\n+\/\/ for the withfield opcode (0xCC at bytecode position 6) must be a reference.\n+\/\/\n+class wthFldBadFldRef {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldRef\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldRef\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldRef;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldRef.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C1A1ACC00; \/\/ Changed opcode at bytecode 4 from aload_1 to iload_0\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldRef\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54 and the first opcode in the Code\n+\/\/ attribute was changed to a withfield (0xCC)..  Since withfield opcodes are not\n+\/\/ allowed in classes with major version 54, this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class wthFldBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LwthFldBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LwthFldBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"wthFldBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"wthFldBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCC00034C2B1ACC00; \/\/ Changed the first opcode to 0xCC (withfield) in order to\n+            0x024C2BB0;         \/\/ test withfield opcode with an illegal major version.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 1.  Since this index now points to a Method\n+\/\/ entry instead of a Field entry, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldWrongCPType\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldWrongCPType\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldWrongCPType;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldWrongCPType.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 1 for opcode 0xCC (withfield)\n+            0x014C2BB0;         \/\/ so that the cp index no longer points to a cp Field entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The cp entry for the aconst_init opcode was changed to a reference that\n+\/\/ is not an inline type.\n+\/\/ This should cause a VerifyError because the cp entry for opcode aconst_init\n+\/\/ must be an inline type.\n+\/\/\n+class defValueObj {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"makedefValueObj\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)QdefValueObj;\"; \/\/ #10     at 0x41\n+    Utf8 \"Code\"; \/\/ #11     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x5A\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x6C\n+    Utf8 \"()I\"; \/\/ #14     at 0x77\n+    Utf8 \"equals\"; \/\/ #15     at 0x7D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x86\n+    Utf8 \"toString\"; \/\/ #17     at 0x9E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0xA9\n+    Utf8 \"<init>\"; \/\/ #19     at 0xC0\n+    Utf8 \"()QdefValueObj;\"; \/\/ #20     at 0xC9\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xDA\n+    Utf8 \"defValueObj.java\"; \/\/ #22     at 0xE7\n+    Utf8 \"defValueObj\"; \/\/ #23     at 0xF9\n+    NameAndType #7 #8; \/\/ #24     at 0x0106\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010B\n+    MethodHandle 6b #31; \/\/ #26     at 0x011E\n+    NameAndType #13 #32; \/\/ #27     at 0x0122\n+    NameAndType #15 #33; \/\/ #28     at 0x0127\n+    NameAndType #17 #34; \/\/ #29     at 0x012C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0131\n+    Method #35 #36; \/\/ #31     at 0x0144\n+    Utf8 \"(QdefValueObj;)I\"; \/\/ #32     at 0x0149\n+    Utf8 \"(QdefValueObj;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x015B\n+    Utf8 \"(QdefValueObj;)Ljava\/lang\/String;\"; \/\/ #34     at 0x017F\n+    class #37; \/\/ #35     at 0x01A2\n+    NameAndType #38 #42; \/\/ #36     at 0x01A5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01AA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01D3\n+    class #44; \/\/ #39     at 0x01E9\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01EC\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x01F5\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0204\n+    class #45; \/\/ #43     at 0x027A\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x027D\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02A5\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02D0\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02DA\n+      0x0008; \/\/ access\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x02E2\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00044C1A2B5FCC; \/\/ Changed aconst_init's cp index at byte 3 from 3 to 4.\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x0301\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x030D\n+                4  9; \/\/  at 0x0311\n+                11  10; \/\/  at 0x0315\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0315\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0336\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0342\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0342\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x034A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0364\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0370\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0370\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0378\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0391\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039D\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A5\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C4\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03D0\n+                4  5; \/\/  at 0x03D4\n+                11  6; \/\/  at 0x03D8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03DA\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E2\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class defValueObj\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ This class has a withfield opcode with a non-Q type operand.\n+class withfieldL {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldL\"; \/\/ #2     at 0x0D\n+    class #2; \/\/ #3     at 0x17\n+    Field #1 #5; \/\/ #4     at 0x1A\n+    NameAndType #6 #7; \/\/ #5     at 0x1F\n+    Utf8 \"x\"; \/\/ #6     at 0x24\n+    Utf8 \"I\"; \/\/ #7     at 0x28\n+    Field #1 #9; \/\/ #8     at 0x2C\n+    NameAndType #10 #7; \/\/ #9     at 0x31\n+    Utf8 \"y\"; \/\/ #10     at 0x36\n+    class #12; \/\/ #11     at 0x3A\n+    Utf8 \"QwithfieldL;\"; \/\/ #12     at 0x3D\n+    class #14; \/\/ #13     at 0x49\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14     at 0x4C\n+    Utf8 \"makePoint\"; \/\/ #15     at 0x5F\n+    Utf8 \"(II)QwithfieldL;\"; \/\/ #16     at 0x6B\n+    Utf8 \"Code\"; \/\/ #17     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x82\n+    Utf8 \"<init>\"; \/\/ #19     at 0x94\n+    Utf8 \"()QwithfieldL;\"; \/\/ #20     at 0x9D\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xAB\n+    Utf8 \"X.java\"; \/\/ #22     at 0xB8\n+    Utf8 \"NestHost\"; \/\/ #23     at 0xC1\n+    class #25; \/\/ #24     at 0xCC\n+    Utf8 \"X\"; \/\/ #25     at 0xCF\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0xD3\n+    Utf8 \"Point\"; \/\/ #27     at 0xE2\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #13;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0xF4\n+      0x0010; \/\/ access\n+      #6; \/\/ name_index       : x\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0xFC\n+      0x0010; \/\/ access\n+      #10; \/\/ name_index       : y\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0106\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index       : makePoint\n+      #16; \/\/ descriptor_index : (II)QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x010E\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[26]{\n+            0xCB0001C000034D1A;\n+            0x2C5FCC00044D1B2C;\n+            0x5FCC00084D2CC000;\n+            0x0BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x013A\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0146\n+                7  5; \/\/  at 0x014A\n+                14  6; \/\/  at 0x014E\n+                21  7; \/\/  at 0x0152\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0152\n+      0x000A; \/\/ access\n+      #19; \/\/ name_index       : <init>\n+      #20; \/\/ descriptor_index : ()QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 55) { \/\/ Code at 0x015A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B032A5FCC;\n+            0x0008594BB400082A;\n+            0x5FCC00044B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0183\n+              [3] { \/\/ line_number_table\n+                0  9; \/\/  at 0x018F\n+                4  10; \/\/  at 0x0193\n+                21  11; \/\/  at 0x0197\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0199\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x01A1\n+      #24; \/\/ X at 0x01A9\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 10) { \/\/ InnerClasses at 0x01A9\n+      [1] { \/\/ classes\n+        #1 #24 #27 280; \/\/  at 0x01B9\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class withfieldL\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that a VerifyError exception is thrown when trying to pass a null\n+\/\/ when the formal parameter is an inline type.\n+\/\/\n+\/\/ \/\/ Java program emulating the jcod contents.\n+\/\/ public inline final class NoNullVT {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private NoNullVT() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/\n+\/\/     public boolean isSameNoNullVT(NoNullVT that) {\n+\/\/         return this.getX() == that.getX() && this.getY() == that.getY();\n+\/\/     }\n+\/\/\n+\/\/     public boolean equals(Object o) {\n+\/\/         if(o instanceof NoNullVT) {\n+\/\/             return ((NoNullVT)o).x == x &&  ((NoNullVT)o).y == y;\n+\/\/         } else {\n+\/\/             return false;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     public static NoNullVT createNoNullVT(int x, int y) {\n+\/\/         NoNullVT p = NoNullVT.default;\n+\/\/         p = __WithField(p.x, x);\n+\/\/         p = __WithField(p.y, y);\n+\/\/         return p;\n+\/\/     }\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         String str = null;\n+\/\/         NoNullVT a = createNoNullVT(3, 4);\n+\/\/         NoNullVT b = createNoNullVT(2, 4);\n+\/\/         boolean res = a.isSameNoNullVT(null); \/\/ Should throw VerifyError\n+\/\/     }\n+\/\/ }\n+\n+class NoNullVT {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [63] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #36; \/\/ #1     at 0x0A\n+    Field #1 #37; \/\/ #2     at 0x0D\n+    Field #1 #38; \/\/ #3     at 0x12\n+    Method #1 #39; \/\/ #4     at 0x17\n+    Method #1 #40; \/\/ #5     at 0x1C\n+    class #41; \/\/ #6     at 0x21\n+    Method #1 #42; \/\/ #7     at 0x24\n+    Method #1 #43; \/\/ #8     at 0x29\n+    InvokeDynamic 0s #46; \/\/ #9     at 0x2E\n+    InvokeDynamic 0s #47; \/\/ #10     at 0x33\n+    class #48; \/\/ #11     at 0x38\n+    Utf8 \"x\"; \/\/ #12     at 0x3B\n+    Utf8 \"I\"; \/\/ #13     at 0x3F\n+    Utf8 \"y\"; \/\/ #14     at 0x43\n+    Utf8 \"getX\"; \/\/ #15     at 0x47\n+    Utf8 \"()I\"; \/\/ #16     at 0x4E\n+    Utf8 \"Code\"; \/\/ #17     at 0x54\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x5B\n+    Utf8 \"getY\"; \/\/ #19     at 0x6D\n+    Utf8 \"isSameNoNullVT\"; \/\/ #20     at 0x74\n+    Utf8 \"(QNoNullVT;)Z\"; \/\/ #21     at 0x85\n+    Utf8 \"StackMapTable\"; \/\/ #22     at 0x95\n+    Utf8 \"equals\"; \/\/ #23     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAE\n+    Utf8 \"createNoNullVT\"; \/\/ #25     at 0xC6\n+    Utf8 \"(II)QNoNullVT;\"; \/\/ #26     at 0xD7\n+    Utf8 \"main\"; \/\/ #27     at 0xE8\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28     at 0xEF\n+    Utf8 \"hashCode\"; \/\/ #29     at 0x0108\n+    Utf8 \"toString\"; \/\/ #30     at 0x0113\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x011E\n+    Utf8 \"<init>\"; \/\/ #32     at 0x0135\n+    Utf8 \"()QNoNullVT;\"; \/\/ #33     at 0x013E\n+    Utf8 \"SourceFile\"; \/\/ #34     at 0x014D\n+    Utf8 \"NoNullVT.java\"; \/\/ #35     at 0x015A\n+    Utf8 \"NoNullVT\"; \/\/ #36     at 0x016A\n+    NameAndType #12 #13; \/\/ #37     at 0x0175\n+    NameAndType #14 #13; \/\/ #38     at 0x017A\n+    NameAndType #15 #16; \/\/ #39     at 0x017F\n+    NameAndType #19 #16; \/\/ #40     at 0x0184\n+    Utf8 \"QNoNullVT;\"; \/\/ #41     at 0x0189\n+    NameAndType #25 #26; \/\/ #42     at 0x0196\n+    NameAndType #20 #21; \/\/ #43     at 0x019B\n+    Utf8 \"BootstrapMethods\"; \/\/ #44     at 0x01A0\n+    MethodHandle 6b #49; \/\/ #45     at 0x01B3\n+    NameAndType #29 #50; \/\/ #46     at 0x01B7\n+    NameAndType #30 #51; \/\/ #47     at 0x01BC\n+    Utf8 \"java\/lang\/Object\"; \/\/ #48     at 0x01C1\n+    Method #52 #53; \/\/ #49     at 0x01D4\n+    Utf8 \"(QNoNullVT;)I\"; \/\/ #50     at 0x01D9\n+    Utf8 \"(QNoNullVT;)Ljava\/lang\/String;\"; \/\/ #51     at 0x01E9\n+    class #54; \/\/ #52     at 0x020A\n+    NameAndType #55 #59; \/\/ #53     at 0x020D\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #54     at 0x0212\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #55     at 0x023B\n+    class #61; \/\/ #56     at 0x0251\n+    Utf8 \"Lookup\"; \/\/ #57     at 0x0254\n+    Utf8 \"InnerClasses\"; \/\/ #58     at 0x025D\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #59     at 0x026C\n+    class #62; \/\/ #60     at 0x02E2\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #61     at 0x02E5\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #62     at 0x030D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0338\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [9] { \/\/ methods\n+    { \/\/ Member at 0x034A\n+      0x0001; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0352\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40002AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0369\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x0375\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0375\n+      0x0001; \/\/ access\n+      #19; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x037D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0394\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x03A0\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03A0\n+      0x0001; \/\/ access\n+      #20; \/\/ name_cpx\n+      #21; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 63) { \/\/ Code at 0x03A8\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[28]{\n+            0x2AB600042BB60004;\n+            0xA000122AB600052B;\n+            0xB60005A0000704A7;\n+            0x000403AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x03D6\n+              [1] { \/\/ LineNumberTable\n+                0  14; \/\/  at 0x03E2\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 5) { \/\/ StackMapTable at 0x03E2\n+              [2] { \/\/\n+                26b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03ED\n+      0x0001; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 87) { \/\/ Code at 0x03F5\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[43]{\n+            0x2BC100019900252B;\n+            0xC00006B400022AB4;\n+            0x0002A000152BC000;\n+            0x06B400032AB40003;\n+            0xA0000704A7000403;\n+            0xAC03AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0432\n+              [3] { \/\/ LineNumberTable\n+                0  18; \/\/  at 0x043E\n+                7  19; \/\/  at 0x0442\n+                41  21; \/\/  at 0x0446\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 6) { \/\/ StackMapTable at 0x0446\n+              [3] { \/\/\n+                39b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+                0b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0452\n+      0x0009; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x045A\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014D1A2C5FCC;\n+            0x00024D1B2C5FCC00;\n+            0x034D2CB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x0480\n+              [4] { \/\/ LineNumberTable\n+                0  26; \/\/  at 0x048C\n+                4  27; \/\/  at 0x0490\n+                11  28; \/\/  at 0x0494\n+                18  29; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0498\n+      0x0009; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x04A0\n+          2; \/\/ max_stack\n+          5; \/\/ max_locals\n+          Bytes[22]{\n+            0x014C0607B800074D;\n+            0x0507B800074E2C2B; \/\/ Change last nibble from C to B to load null\n+            0xB600083604B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 22) { \/\/ LineNumberTable at 0x04C8\n+              [5] { \/\/ LineNumberTable\n+                0  33; \/\/  at 0x04D4\n+                2  34; \/\/  at 0x04D8\n+                8  35; \/\/  at 0x04DC\n+                14  36; \/\/  at 0x04E0\n+                21  37; \/\/  at 0x04E4\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x04E4\n+      0x0011; \/\/ access\n+      #29; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x04EC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00090000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0505\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0511\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0511\n+      0x0011; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x0519\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0532\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x053E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x053E\n+      0x000A; \/\/ access\n+      #32; \/\/ name_cpx\n+      #33; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x0546\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00024B032A5FCC00;\n+            0x034B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x056C\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x0578\n+                4  6; \/\/  at 0x057C\n+                11  7; \/\/  at 0x0580\n+                18  8; \/\/  at 0x0584\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#34, 2) { \/\/ SourceFile at 0x0586\n+      #35;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#58, 10) { \/\/ InnerClasses at 0x058E\n+      [1] { \/\/ InnerClasses\n+        #56 #60 #57 25; \/\/  at 0x059E\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#44, 6) { \/\/ BootstrapMethods at 0x059E\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #45; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class NoNullVT\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":1608,"deletions":0,"binary":false,"changes":1608,"status":"added"},{"patch":"@@ -0,0 +1,1120 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* This jcod class is based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+ public class withfieldObject {\n+\n+     String y;\n+\n+     public withfieldObject() {\n+         try {\n+             y = \"abc\";  \/\/ Change this putfield to a withfield\n+         } catch (IncompatibleClassChangeError e) {\n+             y = \"cde\";\n+         }\n+     }\n+\n+     public String getfield() {\n+         return y;\n+     }\n+ }\n+*\/\n+\n+class withfieldObject {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [26] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    String #8; \/\/ #7     at 0x39\n+    Utf8 \"abc\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x42\n+    class #12; \/\/ #10     at 0x47\n+    NameAndType #13 #14; \/\/ #11     at 0x4A\n+    Utf8 \"withfieldObject\"; \/\/ #12     at 0x4F\n+    Utf8 \"y\"; \/\/ #13     at 0x60\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #14     at 0x64\n+    class #16; \/\/ #15     at 0x79\n+    Utf8 \"java\/lang\/IncompatibleClassChangeError\"; \/\/ #16     at 0x7C\n+    String #18; \/\/ #17     at 0xA5\n+    Utf8 \"cde\"; \/\/ #18     at 0xA8\n+    Utf8 \"Code\"; \/\/ #19     at 0xAE\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0xB5\n+    Utf8 \"StackMapTable\"; \/\/ #21     at 0xC7\n+    Utf8 \"getfield\"; \/\/ #22     at 0xD7\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #23     at 0xE2\n+    Utf8 \"SourceFile\"; \/\/ #24     at 0xF9\n+    Utf8 \"withfieldObject.java\"; \/\/ #25     at 0x0106\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x0126\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : y\n+      #14; \/\/ descriptor_index : Ljava\/lang\/String;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0130\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#19, 96) { \/\/ Code at 0x0138  \/\/ !!!! Changed 95 -> 96\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[22]{                \/\/ !!!! Changed from 21 -> 22\n+            0x2AB700012A1207CC;     \/\/ !!!! Changed last byte from B5 (putfield) to CC (withfield)\n+            0x000957A7000A4C2A;     \/\/ !!!! Inserted 0x57 (pop) to clear the stack.\n+            0x1211B50009B1;\n+          }\n+          [1] { \/\/ Traps\n+            4 11 14 15; \/\/  at 0x0165  \/\/ !!!! Changed 10 -> 11 and 13 -> 14\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#20, 26) { \/\/ LineNumberTable at 0x0167\n+              [6] { \/\/ line_number_table\n+                0  6; \/\/  at 0x0173\n+                4  8; \/\/  at 0x0177\n+                10  11; \/\/  at 0x017B\n+                13  9; \/\/  at 0x017F\n+                14  10; \/\/  at 0x0183\n+                20  12; \/\/  at 0x0187\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21, 16) { \/\/ StackMapTable at 0x0187\n+              [2] { \/\/\n+                255b, 14, [1]{7b,10}, [1]{7b,15}; \/\/ full_frame  \/\/ !!!! Changed 13 to 14\n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x019D\n+      0x0001; \/\/ access\n+      #22; \/\/ name_index       : getfield\n+      #23; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#19, 29) { \/\/ Code at 0x01A5\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40009B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x01BC\n+              [1] { \/\/ line_number_table\n+                0  15; \/\/  at 0x01C8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#24, 2) { \/\/ SourceFile at 0x01CA\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldObject\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   orignal jcod file, search for !!!!.\n+ public class putfieldObject {\n+     String y;\n+     public putfieldObject() {\n+         y = \"abc\";\n+     }\n+     public void withfieldFunc() {\n+         y = \"cde\";  \/\/ Change this putfield to a withfield\n+     }\n+     public String getfield() {\n+         return y;\n+     }\n+ }\n+*\/\n+class putfieldObject {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [24] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    String #8; \/\/ #7     at 0x39\n+    Utf8 \"abc\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x42\n+    class #12; \/\/ #10     at 0x47\n+    NameAndType #13 #14; \/\/ #11     at 0x4A\n+    Utf8 \"putfieldObject\"; \/\/ #12     at 0x4F\n+    Utf8 \"y\"; \/\/ #13     at 0x60\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #14     at 0x64\n+    String #16; \/\/ #15     at 0x79\n+    Utf8 \"cde\"; \/\/ #16     at 0x7C\n+    Utf8 \"Code\"; \/\/ #17     at 0x82\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x89\n+    Utf8 \"withfieldFunc\"; \/\/ #19     at 0x9B\n+    Utf8 \"getfield\"; \/\/ #20     at 0xAB\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #21     at 0xB6\n+    Utf8 \"SourceFile\"; \/\/ #22     at 0xCD\n+    Utf8 \"putfieldObject.java\"; \/\/ #23     at 0xDA\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xFA\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : y\n+      #14; \/\/ descriptor_index : Ljava\/lang\/String;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0104\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#17, 43) { \/\/ Code at 0x010C\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[11]{\n+            0x2AB700012A1207B5;\n+            0x0009B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0129\n+              [3] { \/\/ line_number_table\n+                0  6; \/\/  at 0x0135\n+                4  7; \/\/  at 0x0139\n+                10  8; \/\/  at 0x013D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x013D\n+      0x0001; \/\/ access\n+      #19; \/\/ name_index       : withfieldFunc\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#17, 35) { \/\/ Code at 0x0145\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2A120FCC0009B1;  \/\/ !!!! Change 0xB5 (putfield) to 0xCC (withfield)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 10) { \/\/ LineNumberTable at 0x015E\n+              [2] { \/\/ line_number_table\n+                0  11; \/\/  at 0x016A\n+                6  12; \/\/  at 0x016E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016E\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index       : getfield\n+      #21; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0176\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40009B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x018D\n+              [1] { \/\/ line_number_table\n+                0  15; \/\/  at 0x0199\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#22, 2) { \/\/ SourceFile at 0x019B\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class putfieldObject\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   original jcod file, search for !!!!.\n+public primitive final class putfieldPrimitive {\n+    int x;\n+\n+    public putfieldPrimitive(boolean odd) {\n+        if (odd) {\n+            x = 5;\n+        } else {\n+            x = 6;\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+\n+\/\/ If putfieldPrimitive.<init>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ Otherwise, it uses a putfield bytecode.\n+\n+class putfieldPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"putfieldPrimitive\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x3B\n+    Utf8 \"()I\"; \/\/ #10     at 0x42\n+    Utf8 \"Code\"; \/\/ #11     at 0x48\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x4F\n+    Utf8 \"<init>\"; \/\/ #13     at 0x61\n+    Utf8 \"(Z)QputfieldPrimitive;\"; \/\/ #14     at 0x6A\n+    Utf8 \"StackMapTable\"; \/\/ #15     at 0x75\n+    class #17; \/\/ #16     at 0x85\n+    Utf8 \"QputfieldPrimitive;\"; \/\/ #17     at 0x88\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0x90\n+    Utf8 \"putfieldPrimitive.java\"; \/\/ #19     at 0x9D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xB2\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xBC\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xC4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xDB\n+              [1] { \/\/ line_number_table\n+                0  13; \/\/  at 0xE7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xE7\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <init>\n+      #14; \/\/ descriptor_index : (Z)QputfieldPrimitive;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 84) { \/\/ Code at 0xEF  \/\/ !!! Change 83 -> 84\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[29]{             \/\/ !!!! Change 28 -> 29\n+            0xCB00014C1A99000D;\n+            0x082B5FCC00034CA7;\n+            0x000C10062B5FB500;  \/\/ !!!! Change goto target B -> C and 0xCC (withfield) to 0xB5 (putfield)\n+            0x032B4C2BB0;        \/\/ !!!! Inserted 0x2B (aload_1)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#12, 22) { \/\/ LineNumberTable at 0x011D\n+              [5] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0129\n+                4  5; \/\/  at 0x012D\n+                8  6; \/\/  at 0x0131\n+                18  8; \/\/  at 0x0135\n+                26  10; \/\/  at 0x0139\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#15, 9) { \/\/ StackMapTable at 0x0139\n+              [2] { \/\/\n+                252b, 18, [1]z{7b,16}; \/\/ append_frame 1\n+                8b; \/\/ same_frame    \/\/ !!!! change 7 -> 8\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x014A\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class putfieldPrimitive\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   original jcod file, search for !!!!.\n+public primitive final class withfieldPrimitive {\n+    int x;\n+\n+    public withfieldPrimitive(boolean odd) {\n+        if (odd) {\n+            x = 5;\n+        } else {\n+            x = 6;\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+\n+\/\/ This class is identical to putfieldPrimitive except for its name.  A new class\n+\/\/ was needed for a fresh constant pool resolution.\n+\/\/ If withfieldPrimitive.<init>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ Otherwise, it uses a putfield bytecode.\n+\n+class withfieldPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldPrimitive\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x3B\n+    Utf8 \"()I\"; \/\/ #10     at 0x42\n+    Utf8 \"Code\"; \/\/ #11     at 0x48\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x4F\n+    Utf8 \"<init>\"; \/\/ #13     at 0x61\n+    Utf8 \"(Z)QwithfieldPrimitive;\"; \/\/ #14     at 0x6A\n+    Utf8 \"StackMapTable\"; \/\/ #15     at 0x75\n+    class #17; \/\/ #16     at 0x85\n+    Utf8 \"QwithfieldPrimitive;\"; \/\/ #17     at 0x88\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0x90\n+    Utf8 \"withfieldPrimitive.java\"; \/\/ #19     at 0x9D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xB2\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xBC\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xC4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xDB\n+              [1] { \/\/ line_number_table\n+                0  13; \/\/  at 0xE7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xE7\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <init>\n+      #14; \/\/ descriptor_index : (Z)QwithfieldPrimitive;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 84) { \/\/ Code at 0xEF  \/\/ !!! Change 83 -> 84\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[29]{             \/\/ !!!! Change 28 -> 29\n+            0xCB00014C1A99000D;\n+            0x082B5FCC00034CA7;\n+            0x000C10062B5FB500;  \/\/ !!!! Change goto target B -> C and 0xCC (withfield) to 0xB5 (putfield)\n+            0x032B4C2BB0;        \/\/ !!!! Inserted 0x2B (aload_1)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#12, 22) { \/\/ LineNumberTable at 0x011D\n+              [5] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0129\n+                4  5; \/\/  at 0x012D\n+                8  6; \/\/  at 0x0131\n+                18  8; \/\/  at 0x0135\n+                26  10; \/\/  at 0x0139\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#15, 9) { \/\/ StackMapTable at 0x0139\n+              [2] { \/\/\n+                252b, 18, [1]z{7b,16}; \/\/ append_frame 1\n+                8b; \/\/ same_frame    \/\/ !!!! change 7 -> 8\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x014A\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldPrimitive\n+\n+\n+\n+\/* This jcod class is based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+public primitive final class withfieldNull {\n+    int x;\n+    public withfieldNull() {\n+        String s = null;\n+        x = 5;\n+    }\n+}\n+*\/\n+\/\/ This class tests a withfield bytecode with a stack operand that is null.\n+class withfieldNull {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [15] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldNull\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x19\n+    NameAndType #5 #6; \/\/ #4     at 0x1E\n+    Utf8 \"x\"; \/\/ #5     at 0x23\n+    Utf8 \"I\"; \/\/ #6     at 0x27\n+    class #8; \/\/ #7     at 0x2B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x2E\n+    Utf8 \"<init>\"; \/\/ #9     at 0x41\n+    Utf8 \"()QwithfieldNull;\"; \/\/ #10     at 0x4A\n+    Utf8 \"Code\"; \/\/ #11     at 0x5A\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x61\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x73\n+    Utf8 \"withfieldNull.java\"; \/\/ #14     at 0x80\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9B\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xA5\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <init>\n+      #10; \/\/ descriptor_index : ()QwithfieldNull;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 51) { \/\/ Code at 0xAD\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[15]{\n+            0xCB00014B014C0801; \/\/ !!!! Change 0x2A (aload_0) to 0x01 (aconst_null)\n+            0x5FCC00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 18) { \/\/ LineNumberTable at 0xCE\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0xDA\n+                4  5; \/\/  at 0xDE\n+                6  6; \/\/  at 0xE2\n+                13  7; \/\/  at 0xE6\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0xE8\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldNull\n+\n+\n+\n+\/* Thexe jcod classes are based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+\n+public class WrongPrimWF {\n+\n+    public primitive final class Dot { }\n+\n+    public primitive final class Loc { }\n+\n+    public primitive final class Both {\n+        Dot dot;\n+        Loc loc;\n+        Both(Dot d, Loc l) {\n+            dot = d;   \/\/ this d is changed to l to cause the VerifyError\n+            loc = l;\n+        }\n+    }\n+\n+    public WrongPrimWF() {\n+        Both b = new Both(new Dot(), new Loc());\n+    }\n+}\n+\n+*\/\n+\n+\/\/ Test that a withfield opcode, whose stack operand 'Loc' is a different primitive type\n+\/\/ than the primitive class in its constant pool field_res,f causes a VerifyError exception.\n+class WrongPrimWF$Dot {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1F\n+    NameAndType #5 #6; \/\/ #4     at 0x24\n+    Utf8 \"this$0\"; \/\/ #5     at 0x29\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x32\n+    class #8; \/\/ #7     at 0x42\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x45\n+    Utf8 \"<init>\"; \/\/ #9     at 0x58\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Dot;\"; \/\/ #10     at 0x61\n+    Utf8 \"Code\"; \/\/ #11     at 0x84\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x8B\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x9D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #14     at 0xAA\n+    Utf8 \"NestHost\"; \/\/ #15     at 0xBD\n+    class #17; \/\/ #16     at 0xC8\n+    Utf8 \"WrongPrimWF\"; \/\/ #17     at 0xCB\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xD9\n+    Utf8 \"Dot\"; \/\/ #19     at 0xE8\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xF8\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x0102\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <init>\n+      #10; \/\/ descriptor_index : (LWrongPrimWF;)QWrongPrimWF$Dot;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 37) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C2A2B5FCC;\n+            0x00034C2BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0129\n+              [1] { \/\/ line_number_table\n+                0  3; \/\/  at 0x0135\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0x0137\n+      #14;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#15, 2) { \/\/ NestHost at 0x013F\n+      #16; \/\/ WrongPrimWF at 0x0147\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0147\n+      [1] { \/\/ classes\n+        #1 #16 #19 273; \/\/  at 0x0157\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Dot\n+\n+\n+class WrongPrimWF$Loc {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1F\n+    NameAndType #5 #6; \/\/ #4     at 0x24\n+    Utf8 \"this$0\"; \/\/ #5     at 0x29\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x32\n+    class #8; \/\/ #7     at 0x42\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x45\n+    Utf8 \"<init>\"; \/\/ #9     at 0x58\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Loc;\"; \/\/ #10     at 0x61\n+    Utf8 \"Code\"; \/\/ #11     at 0x84\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x8B\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x9D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #14     at 0xAA\n+    Utf8 \"NestHost\"; \/\/ #15     at 0xBD\n+    class #17; \/\/ #16     at 0xC8\n+    Utf8 \"WrongPrimWF\"; \/\/ #17     at 0xCB\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xD9\n+    Utf8 \"Loc\"; \/\/ #19     at 0xE8\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xF8\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x0102\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <init>\n+      #10; \/\/ descriptor_index : (LWrongPrimWF;)QWrongPrimWF$Loc;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 37) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C2A2B5FCC;\n+            0x00034C2BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0129\n+              [1] { \/\/ line_number_table\n+                0  5; \/\/  at 0x0135\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0x0137\n+      #14;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#15, 2) { \/\/ NestHost at 0x013F\n+      #16; \/\/ WrongPrimWF at 0x0147\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0147\n+      [1] { \/\/ classes\n+        #1 #16 #19 273; \/\/  at 0x0157\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Loc\n+\n+\n+class WrongPrimWF$Both {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [34] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Both\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"this$0\"; \/\/ #5     at 0x2A\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x33\n+    Field #1 #8; \/\/ #7     at 0x43\n+    NameAndType #9 #10; \/\/ #8     at 0x48\n+    Utf8 \"dot\"; \/\/ #9     at 0x4D\n+    Utf8 \"QWrongPrimWF$Dot;\"; \/\/ #10     at 0x53\n+    Field #1 #12; \/\/ #11     at 0x67\n+    NameAndType #13 #14; \/\/ #12     at 0x6C\n+    Utf8 \"loc\"; \/\/ #13     at 0x71\n+    Utf8 \"QWrongPrimWF$Loc;\"; \/\/ #14     at 0x77\n+    class #16; \/\/ #15     at 0x8B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16     at 0x8E\n+    Utf8 \"<init>\"; \/\/ #17     at 0xA1\n+    Utf8 \"(LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\"; \/\/ #18     at 0xAA\n+    Utf8 \"Code\"; \/\/ #19     at 0xF0\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0xF7\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0x0109\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #22     at 0x0116\n+    Utf8 \"NestHost\"; \/\/ #23     at 0x0129\n+    class #25; \/\/ #24     at 0x0134\n+    Utf8 \"WrongPrimWF\"; \/\/ #25     at 0x0137\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0x0145\n+    Utf8 \"Both\"; \/\/ #27     at 0x0154\n+    class #29; \/\/ #28     at 0x015B\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #29     at 0x015E\n+    Utf8 \"Dot\"; \/\/ #30     at 0x0170\n+    class #32; \/\/ #31     at 0x0176\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #32     at 0x0179\n+    Utf8 \"Loc\"; \/\/ #33     at 0x018B\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ Fields\n+    {  \/\/ field at 0x019B\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index       : dot\n+      #10; \/\/ descriptor_index : QWrongPrimWF$Dot;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x01A3\n+      0x0010; \/\/ access\n+      #13; \/\/ name_index       : loc\n+      #14; \/\/ descriptor_index : QWrongPrimWF$Loc;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x01AB\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x01B5\n+      0x0008; \/\/ access\n+      #17; \/\/ name_index       : <init>\n+      #18; \/\/ descriptor_index : (LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\n+      [1] { \/\/ Attributes\n+        Attr(#19, 63) { \/\/ Code at 0x01BD\n+          2; \/\/ max_stack\n+          4; \/\/ max_locals\n+          Bytes[27]{\n+            0xCB00014E2A2D5FCC;\n+            0x00034E2C2D5FCC00; \/\/ !!!! change 2B (aload_1) to 2C (aload_2) to put Loc on the stack.\n+            0x074E2C2D5FCC000B; \/\/      this should cause a VerifyError because withfield is assigning\n+            0x4E2DB0;           \/\/      to a field of type Dot.\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 18) { \/\/ LineNumberTable at 0x01EA\n+              [4] { \/\/ line_number_table\n+                0  10; \/\/  at 0x01F6\n+                11  11; \/\/  at 0x01FA\n+                18  12; \/\/  at 0x01FE\n+                25  13; \/\/  at 0x0202\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0204\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x020C\n+      #24; \/\/ WrongPrimWF at 0x0214\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 26) { \/\/ InnerClasses at 0x0214\n+      [3] { \/\/ classes\n+        #1 #24 #27 273; \/\/  at 0x0224\n+        #28 #24 #30 273; \/\/  at 0x022C\n+        #31 #24 #33 273; \/\/  at 0x0234\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Both\n+\n+\n+class WrongPrimWF {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Method #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #5 #11; \/\/ #9     at 0x41\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #10     at 0x46\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Dot;\"; \/\/ #11     at 0x58\n+    Method #13 #14; \/\/ #12     at 0x7B\n+    class #15; \/\/ #13     at 0x80\n+    NameAndType #5 #16; \/\/ #14     at 0x83\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #15     at 0x88\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Loc;\"; \/\/ #16     at 0x9A\n+    Method #18 #19; \/\/ #17     at 0xBD\n+    class #20; \/\/ #18     at 0xC2\n+    NameAndType #5 #21; \/\/ #19     at 0xC5\n+    Utf8 \"WrongPrimWF$Both\"; \/\/ #20     at 0xCA\n+    Utf8 \"(LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\"; \/\/ #21     at 0xDD\n+    class #23; \/\/ #22     at 0x0123\n+    Utf8 \"WrongPrimWF\"; \/\/ #23     at 0x0126\n+    Utf8 \"Code\"; \/\/ #24     at 0x0134\n+    Utf8 \"LineNumberTable\"; \/\/ #25     at 0x013B\n+    Utf8 \"SourceFile\"; \/\/ #26     at 0x014D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #27     at 0x015A\n+    Utf8 \"NestMembers\"; \/\/ #28     at 0x016D\n+    Utf8 \"InnerClasses\"; \/\/ #29     at 0x017B\n+    Utf8 \"Dot\"; \/\/ #30     at 0x018A\n+    Utf8 \"Loc\"; \/\/ #31     at 0x0190\n+    Utf8 \"Both\"; \/\/ #32     at 0x0196\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x01A9\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#24, 50) { \/\/ Code at 0x01B1\n+          3; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[18]{\n+            0x2AB700012A2AB800;\n+            0x072AB8000CB80011;\n+            0x4CB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#25, 14) { \/\/ LineNumberTable at 0x01D5\n+              [3] { \/\/ line_number_table\n+                0  16; \/\/  at 0x01E1\n+                4  17; \/\/  at 0x01E5\n+                17  18; \/\/  at 0x01E9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#26, 2) { \/\/ SourceFile at 0x01EB\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28, 8) { \/\/ NestMembers at 0x01F3\n+      [3] { \/\/ classes\n+        #18; \/\/ WrongPrimWF$Both at 0x01FD\n+        #13; \/\/ WrongPrimWF$Loc at 0x01FF\n+        #8; \/\/ WrongPrimWF$Dot at 0x0201\n+      }\n+    } \/\/ end NestMembers\n+    ;\n+    Attr(#29, 26) { \/\/ InnerClasses at 0x0201\n+      [3] { \/\/ classes\n+        #8 #22 #30 273; \/\/  at 0x0211\n+        #13 #22 #31 273; \/\/  at 0x0219\n+        #18 #22 #32 273; \/\/  at 0x0221\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/withfieldTests\/withfieldTests.jcod","additions":1120,"deletions":0,"binary":false,"changes":1120,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-    private Object monitor = new Object();\n+    private Object monitor = new Object();;\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstack\/WaitNotifyThreadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    jdk\/modules \\\n@@ -114,1 +115,9 @@\n-    jni\/nullCaller\n+    jni\/nullCaller \\\n+    valhalla\n+\n+# valhalla lworld tests\n+jdk_valhalla = \\\n+    java\/lang\/invoke \\\n+    valhalla \\\n+    java\/lang\/instrument\/valhalla\n+\n","filename":"test\/jdk\/TEST.groups","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.experimental.bytecode.BytePoolHelper;\n+import jdk.experimental.bytecode.ClassBuilder;\n+import jdk.experimental.bytecode.CodeBuilder;\n@@ -29,0 +32,1 @@\n+import jdk.experimental.bytecode.MethodBuilder;\n@@ -31,0 +35,2 @@\n+import jdk.experimental.bytecode.TypeHelper;\n+import jdk.experimental.bytecode.TypeTag;\n@@ -36,0 +42,1 @@\n+import java.util.Iterator;\n@@ -49,0 +56,4 @@\n+    static String generateClassNameFromLookupClass(MethodHandles.Lookup l) {\n+        return l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+    }\n+\n@@ -50,1 +61,1 @@\n-        String className = l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+        String className = generateClassNameFromLookupClass(l);\n@@ -151,0 +162,211 @@\n+\n+\n+    \/\/ loadCode(MethodHandles.Lookup, String, MethodType, Consumer<? super MethodHandleCodeBuilder<?>>) et al...\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return loadCode(lookup, className, methodName, type, builder);\n+    }\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String descriptor = type.toMethodDescriptorString();\n+        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,\n+                    clazz -> {\n+                        try {\n+                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));\n+                        } catch (ReflectiveOperationException ex) {\n+                            throw new IllegalStateException(ex);\n+                        }\n+                    },\n+                    builder);\n+    }\n+\n+    \/\/ Helper method to load code built with \"buildCode()\"\n+    public static MethodHandle loadCodeBytes(MethodHandles.Lookup lookup, String methodName, MethodType type, byte[] byteCode) {\n+        try {\n+            Class<?> clazz = lookup.defineClass(byteCode);\n+            return lookup.findStatic(clazz, methodName, type);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Failed to loadCodeBytes \\\"\" + methodName + \"\\\"\", t);\n+        }\n+    }\n+\n+\n+    private static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(\n+            MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {\n+        try {\n+            byte[] byteArray = buildCode(lookup, className, methodName, type, builderFunc, builder);\n+            Class<?> clazz = lookup.defineClass(byteArray);\n+            return resFunc.apply(clazz);\n+        } catch (Throwable e) {\n+             throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static byte[] buildCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return buildCode(lookup, className, methodName, type.toMethodDescriptorString(), MethodHandleCodeBuilder::new, builder);\n+    }\n+\n+    public static <C extends CodeBuilder<Class<?>, String, byte[], ?>> byte[] buildCode(\n+        MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Consumer<? super C> builder) {\n+\n+                return new IsolatedMethodBuilder(className, lookup)\n+                    .withSuperclass(Object.class)\n+                    .withMajorVersion(64)\n+                    .withMinorVersion(0)\n+                    .withFlags(Flag.ACC_PUBLIC, Flag.ACC_IDENTITY)\n+                    .withMethod(methodName, type, M ->\n+                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n+                            .withCode(builderFunc, builder)).build();\n+\n+    }\n+\n+    private static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {\n+\n+        private static final Class<?> THIS_CLASS = new Object() { }.getClass();\n+\n+        private IsolatedMethodBuilder(String clazz, MethodHandles.Lookup lookup) {\n+            super(new IsolatedMethodPoolHelper(clazz),\n+                  new IsolatedMethodTypeHelper(lookup));\n+            withThisClass(THIS_CLASS);\n+        }\n+\n+        public Class<?> thisClass() {\n+            return THIS_CLASS;\n+        }\n+\n+        static String classToInternalName(Class<?> c) {\n+            if (c.isArray()) {\n+                return c.descriptorString();\n+            }\n+            return c.getName().replace('.', '\/');\n+        }\n+\n+        private static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {\n+\n+            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+            MethodHandles.Lookup lookup;\n+\n+            private IsolatedMethodTypeHelper(MethodHandles.Lookup lookup) {\n+                this.lookup = lookup;\n+            }\n+\n+            @Override\n+            public String elemtype(String s) {\n+                return basicTypeHelper.elemtype(s);\n+            }\n+\n+            @Override\n+            public String arrayOf(String s) {\n+                return basicTypeHelper.arrayOf(s);\n+            }\n+\n+            @Override\n+            public Iterator<String> parameterTypes(String s) {\n+                return basicTypeHelper.parameterTypes(s);\n+            }\n+\n+            @Override\n+            public String fromTag(TypeTag tag) {\n+                return basicTypeHelper.fromTag(tag);\n+            }\n+\n+            @Override\n+            public String returnType(String s) {\n+                return basicTypeHelper.returnType(s);\n+            }\n+\n+            @Override\n+            public String type(Class<?> aClass) {\n+                return aClass.descriptorString();\n+            }\n+\n+            @Override\n+            public boolean isInlineClass(String desc) {\n+                Class<?> aClass = symbol(desc);\n+                return aClass != null && aClass.isPrimitiveValueType();\n+            }\n+\n+            @Override\n+            public Class<?> symbol(String desc) {\n+                try {\n+                    if (desc.startsWith(\"[\")) {\n+                        return Class.forName(desc.replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                    } else {\n+                        Class<?> c = Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        return basicTypeHelper.isInlineClass(desc) ? c.asValueType() : c.asPrimaryType();\n+                    }\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            @Override\n+            public TypeTag tag(String s) {\n+                return basicTypeHelper.tag(s);\n+            }\n+\n+            @Override\n+            public Class<?> symbolFrom(String s) {\n+                return symbol(s);\n+            }\n+\n+            @Override\n+            public String commonSupertype(String t1, String t2) {\n+                return basicTypeHelper.commonSupertype(t1, t2);\n+            }\n+\n+            @Override\n+            public String nullType() {\n+                return basicTypeHelper.nullType();\n+            }\n+        }\n+\n+        private static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {\n+            final String clazz;\n+\n+            private IsolatedMethodPoolHelper(String clazz) {\n+                super(c -> from(c, clazz), s->s);\n+                this.clazz = clazz;\n+            }\n+\n+            static String from(Class<?> c, String clazz) {\n+                return c == THIS_CLASS ? clazz.replace('.', '\/')\n+                                       : classToInternalName(c);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] build() {\n+            return super.build();\n+        }\n+    }\n+\n+    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {\n+\n+        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+\n+        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {\n+            super(methodBuilder);\n+        }\n+\n+        TypeTag getTagType(String s) {\n+            return basicTypeHelper.tag(s);\n+        }\n+\n+        public T ifcmp(String s, CondKind cond, CharSequence label) {\n+            return super.ifcmp(getTagType(s), cond, label);\n+        }\n+\n+        public T return_(String s) {\n+            return super.return_(getTagType(s));\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":224,"deletions":2,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+        vmOptFinalFlag(map, \"TieredCompilation\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+\n@@ -209,0 +210,21 @@\n+\n+# Value types\n+compiler.err.cyclic.primitive.class.membership\n+compiler.err.value.class.does.not.support\n+compiler.err.value.class.may.not.extend\n+compiler.err.this.exposed.prematurely\n+compiler.err.concrete.supertype.for.value.class\n+compiler.err.super.class.cannot.be.inner\n+compiler.err.super.class.declares.init.block\n+compiler.err.super.constructor.cannot.take.arguments\n+compiler.err.super.constructor.access.restricted\n+compiler.err.super.constructor.cannot.be.generic\n+compiler.err.super.constructor.cannot.throw\n+compiler.err.super.field.not.allowed\n+compiler.err.super.method.cannot.be.synchronized\n+compiler.err.super.no.arg.constructor.must.be.empty\n+compiler.err.generic.parameterization.with.primitive.class\n+compiler.misc.feature.primitive.classes\n+compiler.misc.feature.value.classes\n+compiler.misc.abstract.value.class\n+compiler.misc.superclass.of.value.class\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            \"clone\", \"finalize\", \"getClass\", \"hashCode\",\n+            \"clone\", \"finalize\", \"getClass\", \"hashCode\", \"isValueObject\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFeatureGate1.java:10:12: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.primitive.classes), 13, 19\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckFeatureGate1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFeatureGate2.java:11:17: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.primitive.classes), 13, 19\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckFeatureGate2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+- compiler.warn.source.no.system.modules.path: 16\n+PrimitiveAsTypeName.java:9:18: compiler.warn.restricted.type.not.allowed.preview: primitive, 18\n+PrimitiveAsTypeName.java:10:9: compiler.warn.restricted.type.not.allowed.preview: primitive, 18\n+PrimitiveAsTypeName.java:11:9: compiler.warn.restricted.type.not.allowed.preview: primitive, 18\n+PrimitiveAsTypeName.java:12:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.primitive.classes), 16, 19\n+1 error\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PrimitiveAsTypeName.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -152,0 +152,14 @@\n+  private native Object[] getObjectsViaKlassOopMaps0(Object thing);\n+  public Object[] getObjectsViaKlassOopMaps(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaKlassOopMaps0(thing);\n+  }\n+\n+  private native Object[] getObjectsViaOopIterator0(Object thing);\n+  public Object[] getObjectsViaOopIterator(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaOopIterator0(thing);\n+  }\n+\n+  public native Object[] getObjectsViaFrameOopIterator(int depth);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}