{"files":[{"patch":"@@ -222,2 +222,0 @@\n-      $1_JAVAC := $$(INTERIM_LANGTOOLS_ARGS) -m jdk.compiler.interim\/com.sun.tools.sjavac.Main\n-\n@@ -226,1 +224,6 @@\n-      $1_JAVAC_SERVER_CONFIG := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$$($1_SAFE_NAME)-server.conf\n+      $1_JAVAC_SERVER_CONFIG := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$$($1_SAFE_NAME)-javacserver.conf\n+\n+      # Arguments needed to launch the javacserver client, as well as for the\n+      # client to launch the server.\n+      $1_JAVAC_SERVER_ARGS := $$(INTERIM_LANGTOOLS_ARGS) \\\n+          -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes\n@@ -232,3 +235,3 @@\n-      # The servercmd specifies how to launch the server. This will be executed\n-      # by the client, if needed.\n-      $1_JAVAC_SERVER_CMD := $$(call FixPath, $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC))\n+      # The javacmd tells the client how to run java to launch the server.\n+      $1_JAVAC_SERVER_JAVA_CMD := $$(call FixPath, $$(JAVA) $$($1_JAVA_FLAGS) \\\n+          $$($1_JAVAC_SERVER_ARGS))\n@@ -236,1 +239,1 @@\n-      $1_CONFIG_VARDEPS := $$($1_JAVAC_PORT_FILE) $$($1_JAVAC_SERVER_CMD)\n+      $1_CONFIG_VARDEPS := $$($1_JAVAC_PORT_FILE) $$($1_JAVAC_SERVER_JAVA_CMD)\n@@ -240,0 +243,1 @@\n+      # Write these values to a config file\n@@ -242,1 +246,1 @@\n-\t$(ECHO) servercmd=$$($1_JAVAC_SERVER_CMD) >> $$@\n+\t$(ECHO) javacmd=$$($1_JAVAC_SERVER_JAVA_CMD) >> $$@\n@@ -245,2 +249,2 @@\n-      $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC) \\\n-          --server:conf=$$($1_JAVAC_SERVER_CONFIG)\n+      $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC_SERVER_ARGS) \\\n+          javacserver.Main --conf=$$($1_JAVAC_SERVER_CONFIG)\n@@ -406,0 +410,1 @@\n+    $1_MODFILELIST_FIXED := $$($1_MODFILELIST).fixed\n@@ -472,0 +477,6 @@\n+    # Convert the paths in the MODFILELIST file to Windows-style paths\n+    # on Windows. This is needed because javac operates on Windows-style paths\n+    # when running on Windows. On other platforms this just copies the MODFILELIST file.\n+    $$($1_MODFILELIST_FIXED): $$($1_MODFILELIST)\n+\t\t$$(call FixPathFile, $$($1_MODFILELIST), $$($1_MODFILELIST_FIXED))\n+\n@@ -475,1 +486,1 @@\n-        $$($1_MODFILELIST)\n+        $$($1_MODFILELIST_FIXED)\n@@ -480,1 +491,1 @@\n-\t\t        -XDmodifiedInputs=$$($1_MODFILELIST) \\\n+\t\t        -XDmodifiedInputs=$$($1_MODFILELIST_FIXED) \\\n","filename":"make\/common\/JavaCompilation.gmk","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -43,0 +42,1 @@\n+#include \"jvm.h\"\n@@ -89,1 +89,0 @@\n-\n@@ -149,1 +148,3 @@\n-#define CONSTANT_CLASS_DESCRIPTORS        64\n+#define JAVA_21_VERSION                   65\n+\n+#define CONSTANT_CLASS_DESCRIPTORS        65\n@@ -173,1 +174,0 @@\n-  assert(cfs->allocated_on_stack_or_embedded(), \"should be local\");\n@@ -718,2 +718,2 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature\n-          \/\/ unless it's an inline type.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature,\n+          \/\/ or if it is an inline type, <vnew> with return.\n@@ -723,1 +723,2 @@\n-            if (name != vmSymbols::object_initializer_name()) {\n+            if (name != vmSymbols::object_initializer_name() &&\n+                name != vmSymbols::inline_factory_name()) {\n@@ -729,3 +730,4 @@\n-              \/\/ if return type is non-void then it cannot be a basic primitive\n-              \/\/ and primitve types must be supported.\n-              if (!signature->ends_with(JVM_SIGNATURE_ENDCLASS) || !EnableValhalla) {\n+              \/\/ if return type is non-void then it must be an inline type\n+              if (name == vmSymbols::object_initializer_name() ||\n+                  !EnableValhalla || !supports_inline_types() ||\n+                  !signature->ends_with(JVM_SIGNATURE_ENDCLASS)) {\n@@ -752,1 +754,12 @@\n-            if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) { \/\/ <vnew>\n+              \/\/ <vnew> factory methods must be non-void return and invokeStatic.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature() || ref_kind != JVM_REF_invokeStatic) {\n+                classfile_parse_error(\n+                  \"Bad factory method name at constant pool index %u in class file %s\",\n+                  name_ref_index, CHECK);\n+              }\n+            } else if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n@@ -759,1 +772,1 @@\n-            } else {\n+            } else { \/\/ <init>\n@@ -768,3 +781,0 @@\n-              } else if (!signature->is_void_method_signature()\n-                         && ref_kind == JVM_REF_invokeStatic) {\n-                \/\/ also OK, could be a static factory call\n@@ -897,1 +907,1 @@\n-    _local_interface_indexes = new GrowableArray<u2>(itfs_len, mtNone);\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n@@ -1568,3 +1578,3 @@\n-  GrowableArray<FieldInfo>* temp_fieldinfo = new GrowableArray<FieldInfo>(total_fields, mtNone);\n-  GrowableArray<u2>* temp_generic_signature = new GrowableArray<u2>(total_fields, mtNone);\n-  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0, mtNone); \/\/ could be allocated lazily\n+  GrowableArray<FieldInfo>* temp_fieldinfo = new GrowableArray<FieldInfo>(total_fields);\n+  GrowableArray<u2>* temp_generic_signature = new GrowableArray<u2>(total_fields);\n+  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0); \/\/ could be allocated lazily\n@@ -1629,1 +1639,1 @@\n-          fields_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n+          fields_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1637,1 +1647,1 @@\n-          fields_type_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n+          fields_type_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -2314,1 +2324,1 @@\n-                            256, ResourceObj::RESOURCE_AREA, mtInternal,\n+                            256, AnyObj::RESOURCE_AREA, mtInternal,\n@@ -2489,1 +2499,1 @@\n-  if (name == vmSymbols::object_initializer_name()) {\n+  if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) {\n@@ -2491,6 +2501,6 @@\n-      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n-      return NULL;\n-    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n-      \/\/ OK, a constructor\n-    } else if (is_value_class && !signature->is_void_method_signature()) {\n-      \/\/ also OK, a static factory, as long as the return value is good\n+      classfile_parse_error(\"Interface cannot have a method named <vnew>, class file %s\", CHECK_NULL);\n+    } else if (!is_value_class) {\n+       classfile_parse_error(\"Identity class cannot have a method <vnew>, class file %s\", CHECK_NULL);\n+    } else if (signature->is_void_method_signature()) {\n+       classfile_parse_error(\"Factory method <vnew> must have a non-void return type, class file %s\", CHECK_NULL);\n+    } else { \/\/ also OK, a static factory, as long as the return value is good\n@@ -2504,5 +2514,2 @@\n-          \/\/ The original class name in hidden classes gets changed.  So using\n-          \/\/ the original name in the return type is no longer valid.\n-          \/\/ Note that expecting the return type for inline hidden class factory\n-          \/\/ methods to be java.lang.Object works around a JVM Spec issue for\n-          \/\/ hidden classes.\n+          \/\/ The original class name for hidden classes changed.\n+          \/\/\/ So using the original name in the return type is no longer valid.\n@@ -2516,0 +2523,14 @@\n+      \/\/ factory method, with a non-void return.  No other\n+      \/\/ definition of <vnew> is possible.\n+      \/\/\n+      \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+      \/\/ signature of any attempt to invoke <vnew>, and ensure that it\n+      \/\/ returns non-void.\n+    }\n+  }\n+\n+  if (name == vmSymbols::object_initializer_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n+    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n+      \/\/ OK, a constructor\n@@ -2520,4 +2541,2 @@\n-    \/\/ A declared <init> method must always be either a non-static\n-    \/\/ object constructor, with a void return, or else it must be a\n-    \/\/ static factory method, with a non-void return.  No other\n-    \/\/ definition of <init> is possible.\n+    \/\/ A declared <init> method must always be a non-static\n+    \/\/ object constructor, with a void return.\n@@ -2526,11 +2545,2 @@\n-    \/\/ signature of any attempt to invoke <init>, and ensures that it\n-    \/\/ returns non-void if and only if it is being invoked by\n-    \/\/ invokestatic, and void if and only if it is being invoked by\n-    \/\/ invokespecial.\n-    \/\/\n-    \/\/ When a symbolic reference to <init> is resolved for a\n-    \/\/ particular invocation mode (special or static), the mode is\n-    \/\/ matched to the JVM_ACC_STATIC modifier of the <init> method.\n-    \/\/ Thus, it is impossible to statically invoke a constructor, and\n-    \/\/ impossible to \"new + invokespecial\" a static factory, either\n-    \/\/ through bytecode or through reflection.\n+    \/\/ signature of any attempt to invoke <init>, and ensure that it\n+    \/\/ returns void.\n@@ -3403,0 +3413,1 @@\n+    const Symbol* outer_class_name = NULL;\n@@ -3404,1 +3415,1 @@\n-      const Symbol* const outer_class_name = cp->klass_name_at(outer_class_info_index);\n+      outer_class_name = cp->klass_name_at(outer_class_info_index);\n@@ -3425,1 +3436,0 @@\n-    \/\/ JVM_ACC_VALUE, JVM_ACC_PRIMITIVE, and JVM_ACC_IDENTITY are defined for class file version 62 and later\n@@ -3449,1 +3459,1 @@\n-    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n+    verify_legal_class_modifiers(flags, name, outer_class_name, false, CHECK_0);\n@@ -4587,2 +4597,2 @@\n-  return _major_version > JAVA_20_VERSION ||\n-         (_major_version == JAVA_20_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+  return _major_version > JAVA_21_VERSION ||\n+         (_major_version == JAVA_21_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n@@ -4878,0 +4888,17 @@\n+\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n+\/\/ an explict JVM flag EnablePrimitiveClasses.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const {\n+  if (outer_class &&\n+      inner_class &&\n+      (vmSymbols::jdk_internal_vm_vector_VectorSupport() == outer_class ||\n+       vmSymbols::jdk_internal_vm_vector_VectorPayloadMF() == outer_class)) {\n+    if (strstr(inner_class, \"VectorPayloadMF64\")  ||\n+        strstr(inner_class, \"VectorPayloadMF128\") ||\n+        strstr(inner_class, \"VectorPayloadMF256\") ||\n+        strstr(inner_class, \"VectorPayloadMF512\")) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -4880,1 +4907,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, const Symbol* outer_class, bool is_Object, TRAPS) const {\n@@ -4887,2 +4914,0 @@\n-  assert(supports_inline_types() || !is_value_class, \"JVM_ACC_VALUE should not be set\");\n-  assert(supports_inline_types() || !is_primitive_class, \"JVM_ACC_PRIMITIVE should not be set\");\n@@ -4899,3 +4924,1 @@\n-  if (!EnableValhalla) {\n-    if (is_value_class || is_primitive_class) {\n-      const char* bad_flag = is_primitive_class ? \"ACC_PRIMITIVE\" : \"ACC_VALUE\";\n+  if (is_value_class && !EnableValhalla) {\n@@ -4906,2 +4929,13 @@\n-        \"Class modifier %s in class %s requires option -XX:+EnableValhalla\",\n-        bad_flag, _class_name->as_C_string()\n+        \"Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla\",\n+        _class_name->as_C_string()\n+      );\n+    return;\n+  }\n+\n+  if (is_primitive_class && !is_jdk_internal_class(outer_class, name) && !EnablePrimitiveClasses) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Class modifier ACC_PRIMITIVE in class %s requires option -XX:+EnablePrimitiveClasses\",\n+        _class_name->as_C_string()\n@@ -4909,1 +4943,0 @@\n-    }\n@@ -4925,1 +4958,1 @@\n-      (is_interface && major_gte_1_5 && ((is_super && !supports_inline_types()) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (is_interface && major_gte_1_5 && ((is_super && (!EnableValhalla || !supports_inline_types())) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n@@ -4929,2 +4962,2 @@\n-      (supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n-      (supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n+      (EnableValhalla && supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n+      (EnablePrimitiveClasses && supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n@@ -5089,0 +5122,1 @@\n+  const bool is_factory      = (name == vmSymbols::inline_factory_name() && supports_inline_types());\n@@ -5130,3 +5164,3 @@\n-      if (is_initializer) {\n-        if (is_final || is_synchronized || is_native ||\n-            is_abstract || (major_gte_1_5 && is_bridge)) {\n+      if (is_factory) { \/\/ <vnew> factory method\n+        if (is_final || is_synchronized || is_native || !is_static ||\n+            is_abstract || is_bridge) {\n@@ -5134,0 +5168,1 @@\n+          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n@@ -5135,6 +5170,3 @@\n-        if (!is_static && (!is_value_class || is_abstract_class)) {\n-          \/\/ OK, an object constructor in a regular class or an abstract value class\n-        } else if (is_static && is_value_class) {\n-          \/\/ OK, a static init factory in an inline class\n-        } else {\n-          \/\/ but no other combinations are allowed\n+      } else if (is_initializer) {\n+        if (is_static || is_final || is_synchronized || is_native ||\n+            is_abstract || (major_gte_1_5 && is_bridge)) {\n@@ -5142,1 +5174,0 @@\n-          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n@@ -5162,5 +5193,14 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), class_note, flags);\n+    if (is_value_class && is_initializer) {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method <init> is not allowed in value class %s\",\n+        _class_name->as_C_string());\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+        name->as_C_string(), _class_name->as_C_string(),\n+        class_note, flags);\n+    }\n@@ -5325,1 +5365,1 @@\n-      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators.\n+      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators (TODO: JDK-8270852).\n@@ -5327,1 +5367,1 @@\n-      if (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) {\n+      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n@@ -5329,1 +5369,1 @@\n-                              \"in descriptor in class file %s\",\n+                              \"in descriptor in class file %s, requires option -XX:+EnablePrimitiveClasses\",\n@@ -5471,1 +5511,4 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()  ||\n+          (EnableValhalla && supports_inline_types() &&\n+          name == vmSymbols::inline_factory_name())) {\n@@ -5503,1 +5546,1 @@\n-  if (!supports_inline_types() && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n+  if ((!supports_inline_types() || !EnablePrimitiveClasses) && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n@@ -6282,1 +6325,1 @@\n-  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE are defined for class file version 55 and later\n+  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE supported version\n@@ -6308,1 +6351,0 @@\n-  verify_legal_class_modifiers(flags, NULL, is_java_lang_Object, CHECK);\n@@ -6409,0 +6451,3 @@\n+  const Symbol* super_klass_name = _super_class_index ? cp->klass_name_at(_super_class_index) : NULL;\n+  verify_legal_class_modifiers(flags, _class_name->as_C_string(), super_klass_name, is_java_lang_Object, CHECK);\n+\n@@ -6508,0 +6553,12 @@\n+bool ClassFileParser::is_jdk_internal_class(const Klass* cls) {\n+  while(cls) {\n+    const Symbol* cls_name = cls->name();\n+    if(cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayload() ||\n+       cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayloadMF()) {\n+      return true;\n+    }\n+    cls = cls->super();\n+   }\n+   return false;\n+}\n+\n@@ -6559,5 +6616,1 @@\n-  if (_class_name == vmSymbols::java_lang_NonTearable() && _loader_data->class_loader() == NULL) {\n-    \/\/ This is the original source of this condition.\n-    \/\/ It propagates by inheritance, as if testing \"instanceof NonTearable\".\n-    _is_declared_atomic = true;\n-  } else if (*ForceNonTearable != '\\0') {\n+  if (*ForceNonTearable != '\\0') {\n@@ -6655,1 +6708,1 @@\n-  if (EnableValhalla) {\n+  if (EnablePrimitiveClasses || is_jdk_internal_class(_super_klass)) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":147,"deletions":94,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  void verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, const char* name, const Symbol* out_class, bool is_Object, TRAPS) const;\n@@ -521,0 +521,3 @@\n+  bool is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const;\n+  bool is_jdk_internal_class(const Klass* cls);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -31,0 +30,1 @@\n+#include \"jvm.h\"\n@@ -105,1 +105,1 @@\n-    _oop_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+    _oop_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -134,1 +134,1 @@\n-    _multifields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<MultiFieldGroup*>(8);\n+    _multifields = new GrowableArray<MultiFieldGroup*>(INITIAL_LIST_SIZE);\n@@ -137,1 +137,1 @@\n-    mfg = new(ResourceObj::RESOURCE_AREA, mtInternal) MultiFieldGroup(base, fs.signature());\n+    mfg = new MultiFieldGroup(base, fs.signature());\n@@ -172,1 +172,1 @@\n-    _small_primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+    _small_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -179,1 +179,1 @@\n-    _big_primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+    _big_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -191,1 +191,1 @@\n-    _fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(8);\n+    _fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  static const int INITIAL_LIST_SIZE = 16;\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -48,0 +47,1 @@\n+#include \"jvm.h\"\n@@ -972,1 +972,1 @@\n-    new (ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(40, mtClass);\n+    new (mtClass) GrowableArray<Klass*>(40, mtClass);\n@@ -976,1 +976,1 @@\n-    new (ResourceObj::C_HEAP, mtModule) GrowableArray<Klass*>(500, mtModule);\n+    new (mtModule) GrowableArray<Klass*>(500, mtModule);\n@@ -1160,15 +1160,0 @@\n-static void set_klass_field_in_archived_mirror(oop mirror_obj, int offset, Klass* k) {\n-  assert(java_lang_Class::is_instance(mirror_obj), \"must be\");\n-  \/\/ this is the copy of k in the output buffer\n-  Klass* copy = ArchiveBuilder::get_buffered_klass(k);\n-\n-  \/\/ This is the address of k, if the archive is loaded at the requested location\n-  Klass* def = ArchiveBuilder::current()->to_requested(copy);\n-\n-  log_debug(cds, heap, mirror)(\n-      \"Relocate mirror metadata field at %d from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-      offset, p2i(k), p2i(def));\n-\n-  mirror_obj->metadata_field_put(offset, def);\n-}\n-\n@@ -1180,2 +1165,3 @@\n-    oop m = Universe::_mirrors[t].resolve();\n-    if (m != NULL) {\n+    if (!is_reference_type(bt)) {\n+      oop m = Universe::java_mirror(bt);\n+      assert(m != NULL, \"sanity\");\n@@ -1185,5 +1171,0 @@\n-      Klass *ak = (Klass*)(archived_m->metadata_field(_array_klass_offset));\n-      assert(ak != NULL || t == T_VOID, \"should not be NULL\");\n-      if (ak != NULL) {\n-        set_klass_field_in_archived_mirror(archived_m, _array_klass_offset, ak);\n-      }\n@@ -1201,1 +1182,1 @@\n-      Universe::replace_mirror(bt, archived_m);\n+      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n@@ -1309,11 +1290,0 @@\n-  \/\/ The archived mirror's field at _klass_offset is still pointing to the original\n-  \/\/ klass. Updated the field in the archived mirror to point to the relocated\n-  \/\/ klass in the archive.\n-  set_klass_field_in_archived_mirror(archived_mirror, _klass_offset, as_Klass(mirror));\n-\n-  \/\/ The field at _array_klass_offset is pointing to the original one dimension\n-  \/\/ higher array klass if exists. Relocate the pointer.\n-  Klass *arr = array_klass_acquire(mirror);\n-  if (arr != NULL) {\n-    set_klass_field_in_archived_mirror(archived_mirror, _array_klass_offset, arr);\n-  }\n@@ -1323,27 +1293,0 @@\n-void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {\n-  if (MetaspaceShared::relocation_delta() != 0) {\n-    assert(archived_mirror->metadata_field(_klass_offset) == NULL, \"must be for primitive class\");\n-\n-    Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-    if (ak != NULL) {\n-      archived_mirror->metadata_field_put(_array_klass_offset,\n-          (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-    }\n-  }\n-}\n-\n-void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {\n-  assert(MetaspaceShared::relocation_delta() != 0, \"must be\");\n-\n-  Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));\n-  archived_mirror->metadata_field_put(_klass_offset,\n-      (Klass*)(address(k) + MetaspaceShared::relocation_delta()));\n-\n-  Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-  if (ak != NULL) {\n-    archived_mirror->metadata_field_put(_array_klass_offset,\n-        (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-  }\n-}\n-\n-\n@@ -1820,1 +1763,1 @@\n-int java_lang_Thread::_extentLocalBindings_offset;\n+int java_lang_Thread::_scopedValueBindings_offset;\n@@ -1833,1 +1776,1 @@\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+  macro(_scopedValueBindings_offset, k, \"scopedValueBindings\", object_signature, false);\n@@ -1866,2 +1809,3 @@\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+void java_lang_Thread::clear_scopedValueBindings(oop java_thread) {\n+  assert(java_thread != NULL, \"need a java_lang_Thread pointer here\");\n+  java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n@@ -2014,5 +1958,6 @@\n-        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false) {\n-      \/\/ Pick some initial length\n-      int init_length = MaxJavaStackTraceDepth \/ 2;\n-      _methods = new GrowableArray<Method*>(init_length);\n-      _bcis = new GrowableArray<int>(init_length);\n+        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+        _methods(nullptr), _bcis(nullptr) {\n+    }\n+    ~GetStackTraceClosure() {\n+      delete _methods;\n+      delete _bcis;\n@@ -2045,1 +1990,1 @@\n-        if (ce == nullptr || ce->cont_oop() != java_lang_VirtualThread::continuation(_java_thread())) {\n+        if (ce == nullptr || ce->cont_oop(thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n@@ -2055,0 +2000,5 @@\n+      \/\/ Pick minimum length that will cover most cases\n+      int init_length = 64;\n+      _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n+      _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n+\n@@ -2127,4 +2077,0 @@\n-int java_lang_ThreadGroup::_ngroups_offset;\n-int java_lang_ThreadGroup::_groups_offset;\n-int java_lang_ThreadGroup::_nweaks_offset;\n-int java_lang_ThreadGroup::_weaks_offset;\n@@ -2158,22 +2104,0 @@\n-int java_lang_ThreadGroup::ngroups(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->int_field(_ngroups_offset);\n-}\n-\n-objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {\n-  oop groups = java_thread_group->obj_field(_groups_offset);\n-  assert(groups == NULL || groups->is_objArray(), \"just checking\"); \/\/ Todo: Add better type checking code\n-  return objArrayOop(groups);\n-}\n-\n-int java_lang_ThreadGroup::nweaks(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->int_field(_nweaks_offset);\n-}\n-\n-objArrayOop java_lang_ThreadGroup::weaks(oop java_thread_group) {\n-  oop weaks = java_thread_group->obj_field(_weaks_offset);\n-  assert(weaks == NULL || weaks->is_objArray(), \"just checking\");\n-  return objArrayOop(weaks);\n-}\n-\n@@ -2184,5 +2108,1 @@\n-  macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,                false); \\\n-  macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,                 false); \\\n-  macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature,   false); \\\n-  macro(_nweaks_offset,      k, vmSymbols::nweaks_name(),      int_signature,                 false); \\\n-  macro(_weaks_offset,       k, vmSymbols::weaks_name(),       weakreference_array_signature, false);\n+  macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,                false);\n@@ -3978,1 +3898,3 @@\n-  if (!ik->is_initialized())  ik->initialize(CHECK_NULL);\n+  if (!ik->is_initialized()) {\n+    ik->initialize(CHECK_NULL);\n+  }\n@@ -4290,2 +4212,2 @@\n-int jdk_internal_foreign_abi_ABIDescriptor::_targetAddrStorage_offset;\n-int jdk_internal_foreign_abi_ABIDescriptor::_retBufAddrStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch1_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch2_offset;\n@@ -4294,7 +4216,7 @@\n-  macro(_inputStorage_offset,      k, \"inputStorage\",      jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_outputStorage_offset,     k, \"outputStorage\",     jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_volatileStorage_offset,   k, \"volatileStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_stackAlignment_offset,    k, \"stackAlignment\",    int_signature, false); \\\n-  macro(_shadowSpace_offset,       k, \"shadowSpace\",       int_signature, false); \\\n-  macro(_targetAddrStorage_offset, k, \"targetAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false); \\\n-  macro(_retBufAddrStorage_offset, k, \"retBufAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false);\n+  macro(_inputStorage_offset,    k, \"inputStorage\",    jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_outputStorage_offset,   k, \"outputStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_volatileStorage_offset, k, \"volatileStorage\", jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_stackAlignment_offset,  k, \"stackAlignment\",  int_signature, false); \\\n+  macro(_shadowSpace_offset,     k, \"shadowSpace\",     int_signature, false); \\\n+  macro(_scratch1_offset,        k, \"scratch1\",        jdk_internal_foreign_abi_VMStorage_signature, false); \\\n+  macro(_scratch2_offset,        k, \"scratch2\",        jdk_internal_foreign_abi_VMStorage_signature, false);\n@@ -4337,2 +4259,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(oop entry) {\n-  return entry->obj_field(_targetAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch1(oop entry) {\n+  return entry->obj_field(_scratch1_offset);\n@@ -4341,2 +4263,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(oop entry) {\n-  return entry->obj_field(_retBufAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch2(oop entry) {\n+  return entry->obj_field(_scratch2_offset);\n@@ -4346,1 +4268,2 @@\n-int jdk_internal_foreign_abi_VMStorage::_index_offset;\n+int jdk_internal_foreign_abi_VMStorage::_indexOrOffset_offset;\n+int jdk_internal_foreign_abi_VMStorage::_segmentMaskOrSize_offset;\n@@ -4350,3 +4273,4 @@\n-  macro(_type_offset,      k, \"type\",      int_signature, false); \\\n-  macro(_index_offset,     k, \"index\",     int_signature, false); \\\n-  macro(_debugName_offset, k, \"debugName\", string_signature, false); \\\n+  macro(_type_offset,              k, \"type\",              byte_signature, false); \\\n+  macro(_indexOrOffset_offset,     k, \"indexOrOffset\",     int_signature, false); \\\n+  macro(_segmentMaskOrSize_offset, k, \"segmentMaskOrSize\", short_signature, false); \\\n+  macro(_debugName_offset,         k, \"debugName\",         string_signature, false); \\\n@@ -4369,2 +4293,2 @@\n-jint jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n-  return entry->int_field(_type_offset);\n+jbyte jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n+  return entry->byte_field(_type_offset);\n@@ -4373,2 +4297,6 @@\n-jint jdk_internal_foreign_abi_VMStorage::index(oop entry) {\n-  return entry->int_field(_index_offset);\n+jint jdk_internal_foreign_abi_VMStorage::index_or_offset(oop entry) {\n+  return entry->int_field(_indexOrOffset_offset);\n+}\n+\n+jshort jdk_internal_foreign_abi_VMStorage::segment_mask_or_size(oop entry) {\n+  return entry->short_field(_segmentMaskOrSize_offset);\n@@ -4829,0 +4757,5 @@\n+oop java_lang_ClassLoader::parent_no_keepalive(oop loader) {\n+  assert(is_instance(loader), \"loader must be oop\");\n+  return loader->obj_field_access<AS_NO_KEEPALIVE>(_parent_offset);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":60,"deletions":127,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -52,0 +51,1 @@\n+#include \"jvm.h\"\n@@ -119,1 +119,1 @@\n-ResourceHashtable<InvokeMethodKey, Method*, 139, ResourceObj::C_HEAP, mtClass,\n+ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n@@ -121,1 +121,1 @@\n-ResourceHashtable<SymbolHandle, OopHandle, 139, ResourceObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _invoke_method_type_table;\n+ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _invoke_method_type_table;\n@@ -566,0 +566,3 @@\n+  assert(EnableWaitForParallelLoad,\n+         \"Only called when enabling legacy parallel class loading logic \"\n+         \"for non-parallel capable class loaders\");\n@@ -600,3 +603,5 @@\n-\/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n-\/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n-static bool should_wait_for_loading(Handle class_loader) {\n+\/\/ Bootstrap and non-parallel capable class loaders use the LOAD_INSTANCE placeholder to\n+\/\/ wait for parallel class loading and to check for circularity error for Xcomp when loading\n+\/\/ signature classes.\n+\/\/ parallelCapable class loaders do NOT wait for parallel loads to complete\n+static bool needs_load_placeholder(Handle class_loader) {\n@@ -639,1 +644,0 @@\n-        oldprobe = NULL;  \/\/ Other thread could delete this placeholder entry\n@@ -643,1 +647,1 @@\n-        } else {\n+        } else if (EnableWaitForParallelLoad) {\n@@ -645,0 +649,2 @@\n+        } else {\n+          return NULL;\n@@ -664,1 +670,0 @@\n-  assert(event->should_commit(), \"invariant\");\n@@ -682,1 +687,1 @@\n-         !Signature::has_envelope(name), \"invalid class name\");\n+         !Signature::has_envelope(name), \"invalid class name: %s\", name == NULL ? \"NULL\" : name->as_C_string());\n@@ -771,1 +776,1 @@\n-      if (should_wait_for_loading(class_loader)) {\n+      if (needs_load_placeholder(class_loader)) {\n@@ -785,2 +790,3 @@\n-        } else if (should_wait_for_loading(class_loader)) {\n-          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n+        } else if (needs_load_placeholder(class_loader)) {\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread,\n+          \/\/ and check for ClassCircularityError with -Xcomp.\n@@ -1224,6 +1230,0 @@\n-  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n-  ik->set_nest_host(shared_nest_host);\n-\n@@ -1237,0 +1237,6 @@\n+  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n+  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n+  ik->set_nest_host(shared_nest_host);\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  do_klass(PrimitiveObjectMethods_klass,                java_lang_runtime_PrimitiveObjectMethods              ) \\\n+  do_klass(ValueObjectMethods_klass,                    java_lang_runtime_ValueObjectMethods                  ) \\\n@@ -195,0 +195,1 @@\n+  do_klass(vector_VectorPayloadMF_klass,                jdk_internal_vm_vector_VectorPayloadMF                ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  template(java_lang_NonTearable,                     \"java\/lang\/NonTearable\")                    \\\n@@ -97,0 +96,1 @@\n+  template(jdk_internal_vm_vector_VectorPayloadMF,    \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")    \\\n@@ -164,0 +164,2 @@\n+  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n+  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n@@ -403,0 +405,1 @@\n+  template(inline_factory_name,                       \"<vnew>\")                                   \\\n@@ -412,0 +415,1 @@\n+  template(runWith_method_name,                       \"runWith\")                                  \\\n@@ -416,4 +420,0 @@\n-  template(ngroups_name,                              \"ngroups\")                                  \\\n-  template(groups_name,                               \"groups\")                                   \\\n-  template(nweaks_name,                               \"nweaks\")                                   \\\n-  template(weaks_name,                                \"weaks\")                                    \\\n@@ -624,0 +624,1 @@\n+  template(runnable_void_signature,                   \"(Ljava\/lang\/Runnable;)V\")                                   \\\n@@ -626,0 +627,1 @@\n+  template(void_threadgroup_array_signature,          \"()[Ljava\/lang\/ThreadGroup;\")                               \\\n@@ -764,0 +766,4 @@\n+  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n+  template(encodeThrowable_name,                       \"encodeThrowable\")                                         \\\n+  template(encodeThrowable_signature,                  \"(Ljava\/lang\/Throwable;JI)I\")                              \\\n+  template(decodeAndThrowThrowable_name,               \"decodeAndThrowThrowable\")                                 \\\n@@ -795,1 +801,1 @@\n-  template(java_lang_runtime_PrimitiveObjectMethods,        \"java\/lang\/runtime\/PrimitiveObjectMethods\")           \\\n+  template(java_lang_runtime_ValueObjectMethods,            \"java\/lang\/runtime\/ValueObjectMethods\")               \\\n@@ -797,1 +803,1 @@\n-  template(primitiveObjectHashCode_name,                    \"primitiveObjectHashCode\")                            \\\n+  template(valueObjectHashCode_name,                        \"valueObjectHashCode\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -141,1 +142,1 @@\n-enum class MEMFLAGS {\n+enum class MEMFLAGS : uint8_t  {\n@@ -146,0 +147,2 @@\n+\/\/ Extra insurance that MEMFLAGS truly has the same size as uint8_t.\n+STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n@@ -177,1 +180,55 @@\n-template <MEMFLAGS F> class CHeapObj {\n+class CHeapObjBase {\n+ public:\n+  ALWAYSINLINE void* operator new(size_t size, MEMFLAGS f) throw() {\n+    return AllocateHeap(size, f);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const std::nothrow_t&,\n+                                  const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const std::nothrow_t&) throw() {\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size, MEMFLAGS f) throw() {\n+    return AllocateHeap(size, f);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const std::nothrow_t&,\n+                                    const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const std::nothrow_t&) throw() {\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  void operator delete(void* p)     { FreeHeap(p); }\n+  void operator delete [] (void* p) { FreeHeap(p); }\n+};\n+\n+\/\/ Uses the implicitly static new and delete operators of CHeapObjBase\n+template<MEMFLAGS F>\n+class CHeapObj {\n@@ -180,1 +237,1 @@\n-    return (void*)AllocateHeap(size, F);\n+    return CHeapObjBase::operator new(size, F);\n@@ -185,1 +242,1 @@\n-    return (void*)AllocateHeap(size, F, stack);\n+    return CHeapObjBase::operator new(size, F, stack);\n@@ -188,1 +245,1 @@\n-  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&,\n+  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t& nt,\n@@ -190,1 +247,1 @@\n-    return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);\n+    return CHeapObjBase::operator new(size, F, nt, stack);\n@@ -193,2 +250,2 @@\n-  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&) throw() {\n-    return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);\n+  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t& nt) throw() {\n+    return CHeapObjBase::operator new(size, F, nt);\n@@ -198,1 +255,1 @@\n-    return (void*)AllocateHeap(size, F);\n+    return CHeapObjBase::operator new[](size, F);\n@@ -202,2 +259,2 @@\n-                                  const NativeCallStack& stack) throw() {\n-    return (void*)AllocateHeap(size, F, stack);\n+                                    const NativeCallStack& stack) throw() {\n+    return CHeapObjBase::operator new[](size, F, stack);\n@@ -206,1 +263,1 @@\n-  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&,\n+  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t& nt,\n@@ -208,1 +265,5 @@\n-    return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);\n+    return CHeapObjBase::operator new[](size, F, nt, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t& nt) throw() {\n+    return CHeapObjBase::operator new[](size, F, nt);\n@@ -211,2 +272,2 @@\n-  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&) throw() {\n-    return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);\n+  void operator delete(void* p)     {\n+    CHeapObjBase::operator delete(p);\n@@ -215,2 +276,3 @@\n-  void  operator delete(void* p)     { FreeHeap(p); }\n-  void  operator delete [] (void* p) { FreeHeap(p); }\n+  void operator delete [] (void* p) {\n+    CHeapObjBase::operator delete[](p);\n+  }\n@@ -368,1 +430,32 @@\n-extern void resource_free_bytes( char *old, size_t size );\n+extern void resource_free_bytes( Thread* thread, char *old, size_t size );\n+\n+\/\/----------------------------------------------------------------------\n+\/\/ Base class for objects allocated in the resource area.\n+class ResourceObj {\n+ public:\n+  void* operator new(size_t size) throw() {\n+    return resource_allocate_bytes(size);\n+  }\n+\n+  void* operator new(size_t size, const std::nothrow_t& nothrow_constant) throw() {\n+    return resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  void* operator new [](size_t size) throw() = delete;\n+  void* operator new [](size_t size, const std::nothrow_t& nothrow_constant) throw() = delete;\n+\n+  void  operator delete(void* p) = delete;\n+  void  operator delete [](void* p) = delete;\n+};\n+\n+class ArenaObj {\n+ public:\n+  void* operator new(size_t size, Arena *arena) throw();\n+  void* operator new [](size_t size, Arena *arena) throw() = delete;\n+\n+  void* operator new [](size_t size) throw() = delete;\n+  void* operator new [](size_t size, const std::nothrow_t& nothrow_constant) throw() = delete;\n+\n+  void  operator delete(void* p) = delete;\n+  void  operator delete [](void* p) = delete;\n+};\n@@ -373,2 +466,2 @@\n-\/\/ new(ResourceObj::C_HEAP) Foo(...) or in an Arena with new (&arena)\n-\/\/ ResourceObj's can be allocated within other objects, but don't use\n+\/\/ new (AnyObj::C_HEAP) Foo(...) or in an Arena with new (&arena).\n+\/\/ AnyObj's can be allocated within other objects, but don't use\n@@ -377,1 +470,1 @@\n-class ResourceObj {\n+class AnyObj {\n@@ -397,4 +490,4 @@\n-  ResourceObj(); \/\/ default constructor\n-  ResourceObj(const ResourceObj& r); \/\/ default copy constructor\n-  ResourceObj& operator=(const ResourceObj& r); \/\/ default copy assignment\n-  ~ResourceObj();\n+  AnyObj(); \/\/ default constructor\n+  AnyObj(const AnyObj& r); \/\/ default copy constructor\n+  AnyObj& operator=(const AnyObj& r); \/\/ default copy assignment\n+  ~AnyObj();\n@@ -404,6 +497,7 @@\n-  void* operator new(size_t size, allocation_type type, MEMFLAGS flags) throw();\n-  void* operator new [](size_t size, allocation_type type, MEMFLAGS flags) throw() = delete;\n-  void* operator new(size_t size, const std::nothrow_t&  nothrow_constant,\n-      allocation_type type, MEMFLAGS flags) throw();\n-  void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant,\n-      allocation_type type, MEMFLAGS flags) throw() = delete;\n+  \/\/ CHeap allocations\n+  void* operator new(size_t size, MEMFLAGS flags) throw();\n+  void* operator new [](size_t size, MEMFLAGS flags) throw() = delete;\n+  void* operator new(size_t size, const std::nothrow_t&  nothrow_constant, MEMFLAGS flags) throw();\n+  void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant, MEMFLAGS flags) throw() = delete;\n+\n+  \/\/ Arena allocations\n@@ -413,0 +507,1 @@\n+  \/\/ Resource allocations\n@@ -414,3 +509,3 @@\n-      address res = (address)resource_allocate_bytes(size);\n-      DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)\n-      return res;\n+    address res = (address)resource_allocate_bytes(size);\n+    DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)\n+    return res;\n@@ -418,4 +513,3 @@\n-\n-      address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);\n-      DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)\n-      return res;\n+    address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);\n+    DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)\n+    return res;\n@@ -461,1 +555,4 @@\n-  resource_free_bytes((char*)(old), (size) * sizeof(type))\n+  resource_free_bytes(Thread::current(), (char*)(old), (size) * sizeof(type))\n+\n+#define FREE_RESOURCE_ARRAY_IN_THREAD(thread, type, old, size)\\\n+  resource_free_bytes(thread, (char*)(old), (size) * sizeof(type))\n@@ -537,0 +634,2 @@\n+  static E* reallocate_malloc(E* addr, size_t new_length, MEMFLAGS flags);\n+\n@@ -566,0 +665,1 @@\n+  static E* reallocate(E* addr, size_t new_length, MEMFLAGS flags);\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":139,"deletions":39,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-  ResizeableResourceHashtable<address, bool, ResourceObj::C_HEAP,\n+  ResizeableResourceHashtable<address, bool, AnyObj::C_HEAP,\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  friend class ClassPrelinker;       \/\/ CDS\n@@ -707,1 +708,1 @@\n-  void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  bool maybe_archive_resolved_klass_at(int cp_index);\n@@ -899,1 +900,1 @@\n-    ResourceHashtable<const Symbol*, u2, 256, ResourceObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+    ResourceHashtable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -49,0 +48,1 @@\n+#include \"jvm.h\"\n@@ -401,0 +401,1 @@\n+  assert(this_key != NULL, \"sanity\");\n@@ -930,17 +931,7 @@\n-    for (int i = 0; i < methods()->length(); i++) {\n-      Method* m = methods()->at(i);\n-      for (SignatureStream ss(m->signature()); !ss.is_done(); ss.next()) {\n-        if (ss.is_reference()) {\n-          if (ss.is_array()) {\n-            continue;\n-          }\n-          if (ss.type() == T_PRIMITIVE_OBJECT) {\n-            Symbol* symb = ss.as_symbol();\n-            if (symb == name()) continue;\n-            oop loader = class_loader();\n-            oop protection_domain = this->protection_domain();\n-            Klass* klass = SystemDictionary::resolve_or_fail(symb,\n-                                                             Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n-                                                             CHECK_false);\n-            if (klass == NULL) {\n-              THROW_(vmSymbols::java_lang_LinkageError(), false);\n+    if (EnablePrimitiveClasses) {\n+      for (int i = 0; i < methods()->length(); i++) {\n+        Method* m = methods()->at(i);\n+        for (SignatureStream ss(m->signature()); !ss.is_done(); ss.next()) {\n+          if (ss.is_reference()) {\n+            if (ss.is_array()) {\n+              continue;\n@@ -948,6 +939,18 @@\n-            if (!klass->is_inline_klass()) {\n-              Exceptions::fthrow(\n-                THREAD_AND_LOCATION,\n-                vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                \"class %s is not an inline type\",\n-                klass->external_name());\n+            if (ss.type() == T_PRIMITIVE_OBJECT) {\n+              Symbol* symb = ss.as_symbol();\n+              if (symb == name()) continue;\n+              oop loader = class_loader();\n+              oop protection_domain = this->protection_domain();\n+              Klass* klass = SystemDictionary::resolve_or_fail(symb,\n+                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n+                                                              CHECK_false);\n+              if (klass == NULL) {\n+                THROW_(vmSymbols::java_lang_LinkageError(), false);\n+              }\n+              if (!klass->is_inline_klass()) {\n+                Exceptions::fthrow(\n+                  THREAD_AND_LOCATION,\n+                  vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  \"class %s is not an inline type\",\n+                  klass->external_name());\n+              }\n@@ -1111,1 +1114,1 @@\n-ResourceHashtable<const InstanceKlass*, OopHandle, 107, ResourceObj::C_HEAP, mtClass>\n+ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>\n@@ -1278,1 +1281,1 @@\n-  if (EnableValhalla) {\n+  if (EnablePrimitiveClasses) {\n@@ -2181,2 +2184,3 @@\n-    if (name == vmSymbols::object_initializer_name()) {\n-      break;  \/\/ <init> is never inherited, not even as a static factory\n+    if (name == vmSymbols::object_initializer_name() ||\n+        name == vmSymbols::inline_factory_name()) {\n+      break;  \/\/ <init> and <vnew> is never inherited\n@@ -2857,30 +2861,0 @@\n-\n-void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {\n-  switch (loader_type) {\n-  case ClassLoader::BOOT_LOADER:\n-    _misc_flags |= _misc_is_shared_boot_class;\n-    break;\n-  case ClassLoader::PLATFORM_LOADER:\n-    _misc_flags |= _misc_is_shared_platform_class;\n-    break;\n-  case ClassLoader::APP_LOADER:\n-    _misc_flags |= _misc_is_shared_app_class;\n-    break;\n-  default:\n-    ShouldNotReachHere();\n-    break;\n-  }\n-}\n-\n-void InstanceKlass::assign_class_loader_type() {\n-  ClassLoaderData *cld = class_loader_data();\n-  if (cld->is_boot_class_loader_data()) {\n-    set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n-  }\n-  else if (cld->is_platform_class_loader_data()) {\n-    set_shared_class_loader_type(ClassLoader::PLATFORM_LOADER);\n-  }\n-  else if (cld->is_system_class_loader_data()) {\n-    set_shared_class_loader_type(ClassLoader::APP_LOADER);\n-  }\n-}\n@@ -3003,3 +2977,0 @@\n-  int hash_len = 0;\n-  char hash_buf[40];\n-\n@@ -3010,1 +2981,1 @@\n-  char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);\n+  char* dest = NEW_RESOURCE_ARRAY(char, src_length + 3);\n@@ -3030,5 +3001,0 @@\n-  \/\/ If we have a hash, append it\n-  for (int hash_index = 0; hash_index < hash_len; ) {\n-    dest[dest_index++] = hash_buf[hash_index++];\n-  }\n-\n@@ -3680,1 +3646,1 @@\n-  st->print(BULLET\"misc flags:        0x%x\", _misc_flags);                        st->cr();\n+  st->print(BULLET\"misc flags:        0x%x\", _misc_status.flags());               st->cr();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":34,"deletions":68,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/instanceKlassMiscStatus.hpp\"\n@@ -266,1 +267,1 @@\n-  \/\/ _misc_flags.\n+  \/\/ _misc_status right now.\n@@ -273,34 +274,2 @@\n-  enum {\n-    _misc_rewritten                           = 1 << 0,  \/\/ methods rewritten.\n-    _misc_has_nonstatic_fields                = 1 << 1,  \/\/ for sizing with UseCompressedOops\n-    _misc_should_verify_class                 = 1 << 2,  \/\/ allow caching of preverification\n-    _misc_unused                              = 1 << 3,  \/\/ not currently used\n-    _misc_is_contended                        = 1 << 4,  \/\/ marked with contended annotation\n-    _misc_has_nonstatic_concrete_methods      = 1 << 5,  \/\/ class\/superclass\/implemented interfaces has non-static, concrete methods\n-    _misc_declares_nonstatic_concrete_methods = 1 << 6,  \/\/ directly declares non-static, concrete methods\n-    _misc_has_been_redefined                  = 1 << 7,  \/\/ class has been redefined\n-    _misc_shared_loading_failed               = 1 << 8,  \/\/ class has been loaded from shared archive\n-    _misc_is_scratch_class                    = 1 << 9,  \/\/ class is the redefined scratch class\n-    _misc_is_shared_boot_class                = 1 << 10, \/\/ defining class loader is boot class loader\n-    _misc_is_shared_platform_class            = 1 << 11, \/\/ defining class loader is platform class loader\n-    _misc_is_shared_app_class                 = 1 << 12, \/\/ defining class loader is app class loader\n-    _misc_has_contended_annotations           = 1 << 13, \/\/ has @Contended annotation\n-    _misc_has_inline_type_fields              = 1 << 14, \/\/ has inline fields and related embedded section is not empty\n-    _misc_is_empty_inline_type                = 1 << 15, \/\/ empty inline type (*)\n-    _misc_is_naturally_atomic                 = 1 << 16, \/\/ loaded\/stored in one instruction\n-    _misc_is_declared_atomic                  = 1 << 17, \/\/ implements jl.NonTearable\n-    \/\/ _misc_invalid_value_super                 = 1 << 18, \/\/ invalid super type for an value type\n-    \/\/ _misc_invalid_identity_super              = 1 << 19, \/\/ invalid super type for an identity type\n-    _misc_carries_value_modifier              = 1 << 20, \/\/ the class or one of its super types has the ACC_VALUE modifier\n-    _misc_carries_identity_modifier           = 1 << 21, \/\/ the class or one of its super types has the ACC_IDENTITY modifier\n-  };\n-\n-  \/\/ (*) An inline type is considered empty if it contains no non-static fields or\n-  \/\/ if it contains only empty inline fields. Note that JITs have a slightly different\n-  \/\/ definition: empty inline fields must be flattened otherwise the container won't\n-  \/\/ be considered empty\n-\n-  u2 shared_loader_type_bits() const {\n-    return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;\n-  }\n-  u4              _misc_flags;           \/\/ There is more space in access_flags for more flags.\n+  \/\/ State is set while executing, eventually atomically to not disturb other state\n+  InstanceKlassMiscStatus _misc_status;\n@@ -393,9 +362,3 @@\n-  bool is_shared_boot_class() const {\n-    return (_misc_flags & _misc_is_shared_boot_class) != 0;\n-  }\n-  bool is_shared_platform_class() const {\n-    return (_misc_flags & _misc_is_shared_platform_class) != 0;\n-  }\n-  bool is_shared_app_class() const {\n-    return (_misc_flags & _misc_is_shared_app_class) != 0;\n-  }\n+  bool is_shared_boot_class() const { return _misc_status.is_shared_boot_class(); }\n+  bool is_shared_platform_class() const { return _misc_status.is_shared_platform_class(); }\n+  bool is_shared_app_class() const {  return _misc_status.is_shared_app_class(); }\n@@ -403,3 +366,1 @@\n-  bool is_shared_unregistered_class() const {\n-    return (_misc_flags & shared_loader_type_bits()) == 0;\n-  }\n+  bool is_shared_unregistered_class() const { return _misc_status.is_shared_unregistered_class(); }\n@@ -410,7 +371,1 @@\n-  bool shared_loading_failed() const {\n-    return (_misc_flags & _misc_shared_loading_failed) != 0;\n-  }\n-\n-  void set_shared_loading_failed() {\n-    _misc_flags |= _misc_shared_loading_failed;\n-  }\n+  bool shared_loading_failed() const { return _misc_status.shared_loading_failed(); }\n@@ -418,1 +373,1 @@\n-  void set_shared_class_loader_type(s2 loader_type);\n+  void set_shared_loading_failed() { _misc_status.set_shared_loading_failed(true); }\n@@ -420,1 +375,4 @@\n-  void assign_class_loader_type();\n+#if INCLUDE_CDS\n+  void set_shared_class_loader_type(s2 loader_type) { _misc_status.set_shared_class_loader_type(loader_type); }\n+  void assign_class_loader_type() { _misc_status.assign_class_loader_type(_class_loader_data); }\n+#endif\n@@ -422,9 +380,2 @@\n-  bool has_nonstatic_fields() const        {\n-    return (_misc_flags & _misc_has_nonstatic_fields) != 0;\n-  }\n-  void set_has_nonstatic_fields(bool b)    {\n-    assert(!has_nonstatic_fields(), \"set once\");\n-    if (b) {\n-      _misc_flags |= _misc_has_nonstatic_fields;\n-    }\n-  }\n+  bool has_nonstatic_fields() const        { return _misc_status.has_nonstatic_fields(); }\n+  void set_has_nonstatic_fields(bool b)    { _misc_status.set_has_nonstatic_fields(b); }\n@@ -432,6 +383,2 @@\n-  bool has_inline_type_fields() const          {\n-    return (_misc_flags & _misc_has_inline_type_fields) != 0;\n-  }\n-  void set_has_inline_type_fields()  {\n-    _misc_flags |= _misc_has_inline_type_fields;\n-  }\n+  bool has_inline_type_fields() const { return _misc_status.has_inline_type_fields(); }\n+  void set_has_inline_type_fields()   { _misc_status.set_has_inline_type_fields(true); }\n@@ -439,6 +386,2 @@\n-  bool is_empty_inline_type() const {\n-    return (_misc_flags & _misc_is_empty_inline_type) != 0;\n-  }\n-  void set_is_empty_inline_type() {\n-    _misc_flags |= _misc_is_empty_inline_type;\n-  }\n+  bool is_empty_inline_type() const   { return _misc_status.is_empty_inline_type(); }\n+  void set_is_empty_inline_type()     { _misc_status.set_is_empty_inline_type(true); }\n@@ -451,7 +394,2 @@\n-  bool is_naturally_atomic() const {\n-    return (_misc_flags & _misc_is_naturally_atomic) != 0;\n-  }\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_is_naturally_atomic() {\n-    _misc_flags |= _misc_is_naturally_atomic;\n-  }\n+  bool is_naturally_atomic() const  { return _misc_status.is_naturally_atomic(); }\n+  void set_is_naturally_atomic()    { _misc_status.set_is_naturally_atomic(true); }\n@@ -464,16 +402,2 @@\n-  bool is_declared_atomic() const {\n-    return (_misc_flags & _misc_is_declared_atomic) != 0;\n-  }\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_is_declared_atomic() {\n-    _misc_flags |= _misc_is_declared_atomic;\n-  }\n-\n-  bool carries_value_modifier() const {\n-    return (_misc_flags &  _misc_carries_value_modifier) != 0;\n-  }\n-\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_carries_value_modifier() {\n-    _misc_flags |= _misc_carries_value_modifier;\n-  }\n+  bool is_declared_atomic() const { return _misc_status.is_declared_atomic(); }\n+  void set_is_declared_atomic()   { _misc_status.set_is_declared_atomic(true); }\n@@ -481,3 +405,2 @@\n-  bool carries_identity_modifier() const {\n-    return (_misc_flags & _misc_carries_identity_modifier) != 0;\n-  }\n+  bool carries_value_modifier() const { return _misc_status.carries_value_modifier(); }\n+  void set_carries_value_modifier()   { _misc_status.set_carries_value_modifier(true); }\n@@ -485,4 +408,2 @@\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_carries_identity_modifier() {\n-    _misc_flags |= _misc_carries_identity_modifier;\n-  }\n+  bool carries_identity_modifier() const  { return _misc_status.carries_identity_modifier(); }\n+  void set_carries_identity_modifier()    { _misc_status.set_carries_identity_modifier(true); }\n@@ -682,1 +603,1 @@\n-  bool is_rewritten() const                { return (_misc_flags & _misc_rewritten) != 0; }\n+  bool is_rewritten() const                { return _misc_status.rewritten(); }\n@@ -703,9 +624,2 @@\n-  bool should_verify_class() const         {\n-    return (_misc_flags & _misc_should_verify_class) != 0;\n-  }\n-  void set_should_verify_class(bool value) {\n-    assert(!should_verify_class(), \"set once\");\n-    if (value) {\n-      _misc_flags |= _misc_should_verify_class;\n-    }\n-  }\n+  bool should_verify_class() const         { return _misc_status.should_verify_class(); }\n+  void set_should_verify_class(bool value) { _misc_status.set_should_verify_class(value); }\n@@ -718,2 +632,1 @@\n-  static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }\n-  static u4 misc_flag_is_empty_inline_type() { return _misc_is_empty_inline_type; }\n+  static ByteSize misc_status_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_status)); }\n@@ -831,9 +744,2 @@\n-  bool is_contended() const                {\n-    return (_misc_flags & _misc_is_contended) != 0;\n-  }\n-  void set_is_contended(bool value)        {\n-    assert(!is_contended(), \"set once\");\n-    if (value) {\n-      _misc_flags |= _misc_is_contended;\n-    }\n-  }\n+  bool is_contended() const                { return _misc_status.is_contended(); }\n+  void set_is_contended(bool value)        { _misc_status.set_is_contended(value); }\n@@ -868,9 +774,2 @@\n-  bool has_contended_annotations() const {\n-    return ((_misc_flags & _misc_has_contended_annotations) != 0);\n-  }\n-  void set_has_contended_annotations(bool value)  {\n-    assert(!has_contended_annotations(), \"set once\");\n-    if (value) {\n-      _misc_flags |= _misc_has_contended_annotations;\n-    }\n-  }\n+  bool has_contended_annotations() const { return _misc_status.has_contended_annotations(); }\n+  void set_has_contended_annotations(bool value)  { _misc_status.set_has_contended_annotations(value); }\n@@ -911,6 +810,2 @@\n-  bool has_been_redefined() const {\n-    return (_misc_flags & _misc_has_been_redefined) != 0;\n-  }\n-  void set_has_been_redefined() {\n-    _misc_flags |= _misc_has_been_redefined;\n-  }\n+  bool has_been_redefined() const { return _misc_status.has_been_redefined(); }\n+  void set_has_been_redefined() { _misc_status.set_has_been_redefined(true); }\n@@ -918,7 +813,2 @@\n-  bool is_scratch_class() const {\n-    return (_misc_flags & _misc_is_scratch_class) != 0;\n-  }\n-\n-  void set_is_scratch_class() {\n-    _misc_flags |= _misc_is_scratch_class;\n-  }\n+  bool is_scratch_class() const { return _misc_status.is_scratch_class(); }\n+  void set_is_scratch_class() { _misc_status.set_is_scratch_class(true); }\n@@ -980,9 +870,2 @@\n-  bool has_nonstatic_concrete_methods() const {\n-    return (_misc_flags & _misc_has_nonstatic_concrete_methods) != 0;\n-  }\n-  void set_has_nonstatic_concrete_methods(bool b) {\n-    assert(!has_nonstatic_concrete_methods(), \"set once\");\n-    if (b) {\n-      _misc_flags |= _misc_has_nonstatic_concrete_methods;\n-    }\n-  }\n+  bool has_nonstatic_concrete_methods() const { return _misc_status.has_nonstatic_concrete_methods(); }\n+  void set_has_nonstatic_concrete_methods(bool b) { _misc_status.set_has_nonstatic_concrete_methods(b); }\n@@ -990,9 +873,2 @@\n-  bool declares_nonstatic_concrete_methods() const {\n-    return (_misc_flags & _misc_declares_nonstatic_concrete_methods) != 0;\n-  }\n-  void set_declares_nonstatic_concrete_methods(bool b) {\n-    assert(!declares_nonstatic_concrete_methods(), \"set once\");\n-    if (b) {\n-      _misc_flags |= _misc_declares_nonstatic_concrete_methods;\n-    }\n-  }\n+  bool declares_nonstatic_concrete_methods() const { return _misc_status.declares_nonstatic_concrete_methods(); }\n+  void set_declares_nonstatic_concrete_methods(bool b) { _misc_status.set_declares_nonstatic_concrete_methods(b); }\n@@ -1308,1 +1184,1 @@\n-  void set_rewritten()                  { _misc_flags |= _misc_rewritten; }\n+  void set_rewritten()                  { _misc_status.set_rewritten(true); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":45,"deletions":169,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -39,0 +38,1 @@\n+#include \"jvm.h\"\n@@ -44,1 +44,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -70,0 +70,1 @@\n+\n@@ -541,0 +542,1 @@\n+  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -554,0 +556,8 @@\n+  { \"PrintSharedDictionary\",          JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n+\n+  { \"G1ConcRefinementGreenZone\",    JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementYellowZone\",   JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementRedZone\",      JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementThresholdStep\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1UseAdaptiveConcRefinement\",  JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementServiceIntervalMillis\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n@@ -748,109 +758,0 @@\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n-  \/\/ so the range tests could be tautological and might cause compiler warnings.\n-  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  long long v = strtoll(s, endptr, base);\n-  if (errno != 0 || v < min_jint || v > max_jint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  \/\/ Don't use strtoul -- same reason as above.\n-  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  unsigned long long v = strtoull(s, endptr, base);\n-  if (errno != 0 || v > max_juint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoll(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoull(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template<typename T>\n-static bool multiply_by_1k(T& n) {\n-  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n-      n <= std::numeric_limits<T>::max() \/ 1024) {\n-    n *= 1024;\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ All of the integral types that can be used for command line options:\n-\/\/   int, uint, intx, uintx, uint64_t, size_t\n-\/\/\n-\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n-\/\/    {signed, unsigned} x {32-bit, 64-bit}\n-\/\/\n-\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n-template<typename T>\n-static bool parse_integer(const char *s, T* result) {\n-  if (!isdigit(s[0]) && s[0] != '-') {\n-    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n-    return false;\n-  }\n-\n-  T n = 0;\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n-                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n-  char* remainder;\n-\n-  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n-    return false;\n-  }\n-\n-  \/\/ Fail if no number was read at all or if the remainder contains more than a single non-digit character.\n-  if (remainder == s || strlen(remainder) > 1) {\n-    return false;\n-  }\n-\n-  switch (*remainder) {\n-    case 'T': case 't':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'G': case 'g':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'M': case 'm':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'K': case 'k':\n-      if (!multiply_by_1k(n)) return false;\n-      break;\n-    case '\\0':\n-      break;\n-    default:\n-      return false;\n-  }\n-\n-  *result = n;\n-  return true;\n-}\n-\n@@ -2056,1 +1957,11 @@\n-    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+        return false;\n+      }\n+    }\n+  }\n+#endif\n+\n+#if INCLUDE_JFR\n+  if (status && (FlightRecorderOptions || StartFlightRecording)) {\n+    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.jfr\", addmods_count++)) {\n@@ -2383,0 +2294,4 @@\n+bool Arguments::enable_valhalla(const char* prop_value) {\n+  return strstr(\"jdk.incubator.vector\", prop_value);\n+}\n+\n@@ -2490,0 +2405,3 @@\n+      if (enable_valhalla(tail)) {\n+        EnablePrimitiveClasses = true;\n+      }\n@@ -2942,20 +2860,1 @@\n-    } else if (match_option(option, \"-XX:+ExtendedDTraceProbes\")) {\n-#if defined(DTRACE_ENABLED)\n-      warning(\"Option ExtendedDTraceProbes was deprecated in version 19 and will likely be removed in a future release.\");\n-      warning(\"Use the combination of -XX:+DTraceMethodProbes, -XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\");\n-      if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-#else \/\/ defined(DTRACE_ENABLED)\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"ExtendedDTraceProbes flag is not applicable for this configuration\\n\");\n-      return JNI_EINVAL;\n+#if !defined(DTRACE_ENABLED)\n@@ -2974,1 +2873,1 @@\n-#endif \/\/ defined(DTRACE_ENABLED)\n+#endif \/\/ !defined(DTRACE_ENABLED)\n@@ -3036,0 +2935,6 @@\n+  if (!EnableValhalla && EnablePrimitiveClasses) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Cannot specify -XX:+EnablePrimitiveClasses without -XX:+EnableValhalla\");\n+    return JNI_EINVAL;\n+  }\n+\n@@ -3065,1 +2970,1 @@\n-    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n+    _patch_mod_prefix = new (mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n@@ -4293,32 +4198,0 @@\n-const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {\n-  int count = 0;\n-  const char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->key();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n-char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {\n-  int count = 0;\n-  char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->value();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":39,"deletions":166,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-  inline void set_path(const char* path) { _path->set_value(path); }\n@@ -177,1 +176,0 @@\n-  void set_invalid()                        { _state = agent_invalid; }\n@@ -430,0 +428,2 @@\n+  static bool enable_valhalla(const char* prop_value);\n+\n@@ -595,2 +595,0 @@\n-  static const char* PropertyList_get_key_at(SystemProperty* pl,int index);\n-  static char* PropertyList_get_value_at(SystemProperty* pl,int index);\n@@ -621,1 +619,0 @@\n-  static char* get_jdk_boot_class_path_append() { return _jdk_boot_class_path_append->value(); }\n@@ -626,1 +623,0 @@\n-  static char* get_ext_dirs()     { return _ext_dirs;  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-\n-oop fieldDescriptor::loader() const {\n-  return _cp->pool_holder()->class_loader();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-  oop loader()                    const;\n-  \/\/ Offset (in words) of field from start of instanceOop \/ Klass*\n+  \/\/ Offset (in bytes) of field from start of instanceOop \/ Klass*\n@@ -86,1 +85,0 @@\n-  bool is_public()                const    { return access_flags().is_public(); }\n@@ -89,1 +87,0 @@\n-  bool is_package_private()       const    { return !is_public() && !is_private() && !is_protected(); }\n@@ -94,2 +91,0 @@\n-  bool is_volatile()              const    { return access_flags().is_volatile(); }\n-  bool is_transient()             const    { return access_flags().is_transient(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -394,1 +394,1 @@\n-    \/\/FIXME @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    \/\/ FIXME: appeal to general method (see https:\/\/bugs.openjdk.java.net\/browse\/JDK-6176992)\n+    \/\/ FIXME: appeal to general method (see https:\/\/bugs.openjdk.org\/browse\/JDK-6176992)\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}