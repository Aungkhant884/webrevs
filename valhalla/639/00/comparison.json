{"files":[{"patch":"@@ -619,4 +619,0 @@\n-        if (allowUniversalTVars && !t.hasTag(BOT) && s.isPrimitiveClass() && !t.isPrimitiveClass()) {\n-            chk.warnValueConversion(warn.pos(), Warnings.PrimitiveValueConversion);\n-            return true;\n-        }\n@@ -628,1 +624,1 @@\n-            return tValue ?\n+            boolean result = tValue ?\n@@ -631,0 +627,6 @@\n+            if (result && (allowUniversalTVars && !t.hasTag(BOT) &&\n+                    s.isPrimitiveClass() && !t.isPrimitiveClass() &&\n+                    s.referenceProjectionOrSelf().tsym == t.tsym)) {\n+                chk.warnValueConversion(warn.pos(), Warnings.PrimitiveValueConversion);\n+            }\n+            return result;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5104,1 +5104,1 @@\n-        if (!allowUniversalTVars || args == null || args.isEmpty()) {\n+        if (!allowUniversalTVars || args == null || args.isEmpty() || ((ClassType) clazztype.tsym.type).typarams_field.isEmpty()) {\n@@ -5107,7 +5107,15 @@\n-            \/\/ we use argTypes2 to keep a pointer to the original list as we will use argTypes to iterate over it\n-            List<Type> argTypes, argTypes2;\n-            argTypes2 = argTypes = attribAnyTypes(args, env);\n-            for (Type t : ((ClassType) clazztype.tsym.type).typarams_field) {\n-                argTypes.head = chk.checkRefType(args.head.pos(), argTypes.head, ((TypeVar) t).isUniversal());\n-                args = args.tail;\n-                argTypes = argTypes.tail;\n+            \/* the code below has been obtained by unfolding an invocation to `attribTypes`\n+             * with arguments `tree.arguments` and `env`. We need to do this unfolding to\n+             * take into account the \"universality\" of the declared type variables\n+             *\/\n+            List<Type> typarams_field = ((ClassType) clazztype.tsym.type).typarams_field != null ? ((ClassType) clazztype.tsym.type).typarams_field : List.nil();\n+            ListBuffer<Type> argtypes = new ListBuffer<>();\n+            for (List<JCExpression> l = args; l.nonEmpty(); l = l.tail) {\n+                env.info.primitiveClassAllowedAsTypeParam = typarams_field.head != null ? ((TypeVar)typarams_field.head).isUniversal() : false;\n+                \/* we need the new field `primitiveClassAllowedAsTypeParam` because the type attribution below:\n+                 * `attribType(l.head, env)`\n+                 * could be dealing with a wildcard for example and at some point we will need to check\n+                 * if primitives are allowed as bounds\n+                 *\/\n+                argtypes.append(chk.checkRefType(l.head.pos(), attribType(l.head, env), env.info.primitiveClassAllowedAsTypeParam));\n+                typarams_field = typarams_field.tail != null ? typarams_field.tail : typarams_field;\n@@ -5115,1 +5123,1 @@\n-            actuals = argTypes2;\n+            actuals = argtypes.toList();\n@@ -5300,1 +5308,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, allowUniversalTVars),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, env.info.primitiveClassAllowedAsTypeParam),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -134,0 +134,4 @@\n+    \/** indicates if the type parameter being analyzed allows primitive classes\n+     *\/\n+    boolean primitiveClassAllowedAsTypeParam;\n+\n@@ -158,0 +162,1 @@\n+        info.primitiveClassAllowedAsTypeParam = primitiveClassAllowedAsTypeParam;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.primitive.value.conversion\n+\/\/ options: -Xlint:universal\n+\n+class PrimitiveValueConversionTest {\n+    primitive class Point {}\n+\n+    void m() {\n+        Point.ref pr = null;\n+        Point p = pr;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveValueConversionTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}