{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2494,4 +2494,1 @@\n-    \/\/ TODO 8284443 We need to prevent endless pushing through\n-    \/\/ TODO 8284443 We could revisit the same node over and over again, right?\n-    \/\/ TestLWorld -XX:+UseZGC -DScenarios=0 -DTest=test69\n-    \/\/ TestLWorld -XX:-TieredCompilation -XX:-DoEscapeAnalysis -XX:+AlwaysIncrementalInline\n+    \/\/ TODO 8302217 We need to prevent endless pushing through\n@@ -2553,1 +2550,1 @@\n-\/\/ TODO 8275400\n+\/\/ TODO 8302217\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -617,0 +617,1 @@\n+                  _has_circular_inline_type(false),\n@@ -911,0 +912,1 @@\n+    _has_circular_inline_type(false),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,0 +318,1 @@\n+  bool                  _has_circular_inline_type; \/\/ True if method loads an inline type with a circular, non-flattened field\n@@ -600,0 +601,2 @@\n+  bool              has_circular_inline_type() const { return _has_circular_inline_type; }\n+  void          set_has_circular_inline_type(bool z) { _has_circular_inline_type = z; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,5 @@\n-    if (value->is_InlineType()) {\n+    \/\/ We limit scalarization for inline types with circular fields and can therefore observe nodes\n+    \/\/ of the same type but with different scalarization depth during IGVN. To avoid inconsistencies\n+    \/\/ during merging, make sure that we only create Phis for fields that are guaranteed to be scalarized.\n+    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flattened(i);\n+    if (value->is_InlineType() && no_circularity) {\n@@ -358,1 +362,44 @@\n-void InlineTypeNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n+\/\/ We limit scalarization for inline types with circular fields and can therefore observe\n+\/\/ nodes of same type but with different scalarization depth during GVN. This method adjusts\n+\/\/ the scalarization depth to avoid inconsistencies during merging.\n+InlineTypeNode* InlineTypeNode::adjust_scalarization_depth(GraphKit* kit) {\n+  if (!kit->C->has_circular_inline_type()) {\n+    return this;\n+  }\n+  GrowableArray<ciType*> visited;\n+  visited.push(inline_klass());\n+  return adjust_scalarization_depth_impl(kit, visited);\n+}\n+\n+InlineTypeNode* InlineTypeNode::adjust_scalarization_depth_impl(GraphKit* kit, GrowableArray<ciType*>& visited) {\n+  InlineTypeNode* val = this;\n+  for (uint i = 0; i < field_count(); ++i) {\n+    Node* value = field_value(i);\n+    Node* new_value = value;\n+    ciType* ft = field_type(i);\n+    if (value->is_InlineType()) {\n+      if (!field_is_flattened(i) && visited.contains(ft)) {\n+        new_value = value->as_InlineType()->buffer(kit)->get_oop();\n+      } else {\n+        int old_len = visited.length();\n+        visited.push(ft);\n+        new_value = value->as_InlineType()->adjust_scalarization_depth_impl(kit, visited);\n+        visited.trunc_to(old_len);\n+      }\n+    } else if (ft->is_inlinetype() && !visited.contains(ft)) {\n+      int old_len = visited.length();\n+      visited.push(ft);\n+      new_value = make_from_oop_impl(kit, value, ft->as_inline_klass(), field_is_null_free(i), visited);\n+      visited.trunc_to(old_len);\n+    }\n+    if (value != new_value) {\n+      if (val == this) {\n+        val = clone()->as_InlineType();\n+      }\n+      val->set_field_value(i, new_value);\n+    }\n+  }\n+  return (val == this) ? this : kit->gvn().transform(val)->as_InlineType();\n+}\n+\n+void InlineTypeNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, GrowableArray<ciType*>& visited, int holder_offset, DecoratorSet decorators) {\n@@ -368,1 +415,1 @@\n-      value = InlineTypeNode::make_default(kit->gvn(), ft->as_inline_klass());\n+      value = make_default_impl(kit->gvn(), ft->as_inline_klass(), visited);\n@@ -371,1 +418,1 @@\n-      value = InlineTypeNode::make_from_flattened(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators);\n+      value = make_from_flattened_impl(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators, visited);\n@@ -398,4 +445,1 @@\n-        if (is_array) {\n-          decorators |= IS_ARRAY;\n-        }\n-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);\n+        value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n@@ -404,2 +448,7 @@\n-      if (ft->is_inlinetype()) {\n-        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass(), null_free);\n+      if (visited.contains(ft)) {\n+        kit->C->set_has_circular_inline_type(true);\n+      } else if (ft->is_inlinetype()) {\n+        int old_len = visited.length();\n+        visited.push(ft);\n+        value = make_from_oop_impl(kit, value, ft->as_inline_klass(), null_free, visited);\n+        visited.trunc_to(old_len);\n@@ -433,3 +482,0 @@\n-      if (!value->is_InlineType()) {\n-        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());\n-      }\n@@ -444,5 +490,2 @@\n-      const TypeAryPtr* ary_type = kit->gvn().type(base)->isa_aryptr();\n-      if (ary_type != NULL) {\n-        decorators |= IS_ARRAY;\n-      }\n-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);\n+      bool is_array = (kit->gvn().type(base)->isa_aryptr() != NULL);\n+      kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n@@ -707,0 +750,6 @@\n+  GrowableArray<ciType*> visited;\n+  visited.push(vk);\n+  return make_default_impl(gvn, vk, visited);\n+}\n+\n+InlineTypeNode* InlineTypeNode::make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited) {\n@@ -709,1 +758,1 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop, true, vk->is_initialized());\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true, \/* buffered= *\/ vk->is_initialized());\n@@ -712,4 +761,8 @@\n-    ciType* field_type = vt->field_type(i);\n-    Node* value = gvn.zerocon(field_type->basic_type());\n-    if (field_type->is_inlinetype()) {\n-      ciInlineKlass* vk = field_type->as_inline_klass();\n+    ciType* ft = vt->field_type(i);\n+    Node* value = gvn.zerocon(ft->basic_type());\n+    if (!vt->field_is_flattened(i) && visited.contains(ft)) {\n+      gvn.C->set_has_circular_inline_type(true);\n+    } else if (ft->is_inlinetype()) {\n+      int old_len = visited.length();\n+      visited.push(ft);\n+      ciInlineKlass* vk = ft->as_inline_klass();\n@@ -717,1 +770,1 @@\n-        value = make_default(gvn, vk);\n+        value = make_default_impl(gvn, vk, visited);\n@@ -719,1 +772,1 @@\n-        value = InlineTypeNode::make_null(gvn, vk);\n+        value = make_null_impl(gvn, vk, visited);\n@@ -721,0 +774,1 @@\n+      visited.trunc_to(old_len);\n@@ -753,0 +807,6 @@\n+  GrowableArray<ciType*> visited;\n+  visited.push(vk);\n+  return make_from_oop_impl(kit, oop, vk, null_free, visited);\n+}\n+\n+InlineTypeNode* InlineTypeNode::make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited) {\n@@ -756,1 +816,1 @@\n-    InlineTypeNode* def = make_default(gvn, vk);\n+    InlineTypeNode* def = make_default_impl(gvn, vk, visited);\n@@ -774,1 +834,1 @@\n-        vt = make_default(gvn, vk);\n+        vt = make_default_impl(gvn, vk, visited);\n@@ -776,1 +836,1 @@\n-        vt = InlineTypeNode::make_null(gvn, vk);\n+        vt = make_null_impl(gvn, vk, visited);\n@@ -783,1 +843,1 @@\n-    vt->load(kit, not_null_oop, not_null_oop, vk, \/* holder_offset *\/ 0);\n+    vt->load(kit, not_null_oop, not_null_oop, vk, visited);\n@@ -788,1 +848,1 @@\n-        null_vt = make_default(gvn, vk);\n+        null_vt = make_default_impl(gvn, vk, visited);\n@@ -790,1 +850,1 @@\n-        null_vt = InlineTypeNode::make_null(gvn, vk);\n+        null_vt = make_null_impl(gvn, vk, visited);\n@@ -808,1 +868,1 @@\n-    vt->load(kit, oop, oop, vk, \/* holder_offset *\/ 0);\n+    vt->load(kit, oop, oop, vk, visited);\n@@ -818,1 +878,0 @@\n-\/\/ GraphKit wrapper for the 'make_from_flattened' method\n@@ -820,0 +879,7 @@\n+  GrowableArray<ciType*> visited;\n+  visited.push(vk);\n+  return make_from_flattened_impl(kit, vk, obj, ptr, holder, holder_offset, decorators, visited);\n+}\n+\n+\/\/ GraphKit wrapper for the 'make_from_flattened' method\n+InlineTypeNode* InlineTypeNode::make_from_flattened_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n@@ -829,1 +895,1 @@\n-  vt->load(kit, obj, ptr, holder, holder_offset, decorators);\n+  vt->load(kit, obj, ptr, holder, visited, holder_offset, decorators);\n@@ -841,1 +907,3 @@\n-  vt->initialize_fields(kit, multi, base_input, in, null_free);\n+  GrowableArray<ciType*> visited;\n+  visited.push(vk);\n+  vt->initialize_fields(kit, multi, base_input, in, null_free, NULL, visited);\n@@ -847,1 +915,1 @@\n-  InlineTypeNode* res = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n+  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n@@ -885,1 +953,1 @@\n-  InlineTypeNode* res = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n+  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n@@ -992,1 +1060,1 @@\n-void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region) {\n+void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region, GrowableArray<ciType*>& visited) {\n@@ -1030,1 +1098,1 @@\n-      vt->initialize_fields(kit, multi, base_input, in, true, null_check_region);\n+      vt->initialize_fields(kit, multi, base_input, in, true, null_check_region, visited);\n@@ -1044,0 +1112,3 @@\n+          if (parm->is_InlineType() && kit->C->has_circular_inline_type()) {\n+            parm = parm->as_InlineType()->get_oop();\n+          }\n@@ -1049,1 +1120,8 @@\n-        parm = make_from_oop(kit, parm, type->as_inline_klass(), field_is_null_free(i));\n+        if (visited.contains(type)) {\n+          kit->C->set_has_circular_inline_type(true);\n+        } else if (!parm->is_InlineType()) {\n+          int old_len = visited.length();\n+          visited.push(type);\n+          parm = make_from_oop_impl(kit, parm, type->as_inline_klass(), field_is_null_free(i), visited);\n+          visited.trunc_to(old_len);\n+        }\n@@ -1108,7 +1186,18 @@\n-  InlineTypeNode* ptr = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false, true);\n-  ptr->set_req(IsInit, gvn.intcon(0));\n-  for (uint i = 0; i < ptr->field_count(); i++) {\n-    ciType* field_type = ptr->field_type(i);\n-    Node* value = gvn.zerocon(field_type->basic_type());\n-    if (field_type->is_inlinetype()) {\n-      value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n+  GrowableArray<ciType*> visited;\n+  visited.push(vk);\n+  return make_null_impl(gvn, vk, visited);\n+}\n+\n+InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited) {\n+  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false, \/* buffered= *\/ true);\n+  vt->set_req(IsInit, gvn.intcon(0));\n+  for (uint i = 0; i < vt->field_count(); i++) {\n+    ciType* ft = vt->field_type(i);\n+    Node* value = gvn.zerocon(ft->basic_type());\n+    if (!vt->field_is_flattened(i) && visited.contains(ft)) {\n+      gvn.C->set_has_circular_inline_type(true);\n+    } else if (ft->is_inlinetype()) {\n+      int old_len = visited.length();\n+      visited.push(ft);\n+      value = make_null_impl(gvn, ft->as_inline_klass(), visited);\n+      visited.trunc_to(old_len);\n@@ -1116,1 +1205,1 @@\n-    ptr->set_field_value(i, value);\n+    vt->set_field_value(i, value);\n@@ -1118,1 +1207,1 @@\n-  return gvn.transform(ptr)->as_InlineType();\n+  return gvn.transform(vt)->as_InlineType();\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":139,"deletions":50,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free = true, Node* null_check_region = NULL);\n+  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region, GrowableArray<ciType*>& visited);\n@@ -73,1 +73,6 @@\n-public:\n+  InlineTypeNode* adjust_scalarization_depth_impl(GraphKit* kit, GrowableArray<ciType*>& visited);\n+\n+  static InlineTypeNode* make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_from_flattened_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n@@ -75,0 +80,1 @@\n+public:\n@@ -85,1 +91,1 @@\n-\n+  \/\/ Create with null field values\n@@ -124,1 +130,3 @@\n-  void load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  void load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, GrowableArray<ciType*>& visited, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  \/\/ Make sure that inline type is fully scalarized\n+  InlineTypeNode* adjust_scalarization_depth(GraphKit* kit);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2002,1 +2002,1 @@\n-    } else if (type == T_OBJECT) {\n+    } else if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {\n@@ -2335,1 +2335,5 @@\n-            set_result(vt->field_value_by_offset(off, false));\n+            Node* value = vt->field_value_by_offset(off, false);\n+            if (value->is_InlineType()) {\n+              value = value->as_InlineType()->adjust_scalarization_depth(this);\n+            }\n+            set_result(value);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -204,1 +204,0 @@\n-  assert(adr->as_AddP()->in(AddPNode::Base) == ary, \"inconsistent address base\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-    pop();\n@@ -59,0 +58,4 @@\n+    if (value->is_InlineType()) {\n+      value = value->as_InlineType()->adjust_scalarization_depth(this);\n+    }\n+    pop();\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -372,0 +372,7 @@\n+  {\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    int nargs = 1 + field->type()->size();\n+    inc_sp(nargs);\n+    new_vt = new_vt->adjust_scalarization_depth(this);\n+  }\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3055,1 +3055,1 @@\n-        \/\/ TODO 8284443 Mismatch handling, we need to check parent method args (look at klassVtable::needs_new_vtable_entry)\n+        \/\/ TODO 8301007 Mismatch handling, we need to check parent method args (look at klassVtable::needs_new_vtable_entry)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+\n@@ -1491,1 +1492,1 @@\n-            return (MyValue2)U.getReference(v1, V1_OFFSET);\n+            return (MyValue2)U.getReference(v1, offset);\n@@ -1496,1 +1497,1 @@\n-            return (MyValue2)U.getReference(v2, V1_OFFSET);\n+            return (MyValue2)U.getReference(v2, offset);\n@@ -1518,1 +1519,1 @@\n-            return (MyValue2)U.getReference(test73_value1, V1_OFFSET);\n+            return (MyValue2)U.getReference(test73_value1, offset);\n@@ -1523,1 +1524,1 @@\n-            return (MyValue2)U.getReference(test73_value2, V1_OFFSET);\n+            return (MyValue2)U.getReference(test73_value2, offset);\n@@ -1634,0 +1635,27 @@\n+\n+    public static final primitive class Test80Value1 {\n+        final Test80Value2 v = new Test80Value2();\n+    }\n+\n+    public static final primitive class Test80Value2 {\n+        final long l = rL;\n+        final Integer i = rI;\n+    }\n+\n+    \/\/ Test that unsafe access is not incorrectly classified as mismatched\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public Test80Value2 test80(Test80Value1.ref v, boolean flat, long offset) {\n+        if (flat) {\n+            return U.getValue(v, offset, PrimitiveClass.asValueType(Test80Value2.class));\n+        } else {\n+            return (Test80Value2)U.getReference(v, offset);\n+        }\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() throws Exception {\n+        Test80Value1 v = new Test80Value1();\n+        Field field = PrimitiveClass.asValueType(Test80Value1.class).getDeclaredField(\"v\");\n+        Asserts.assertEQ(test80(v, U.isFlattened(field), U.objectFieldOffset(field)), v.v);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3800,1 +3800,1 @@\n-    public static void test134(boolean b) {\n+    public void test134(boolean b) {\n@@ -3823,1 +3823,1 @@\n-    public static boolean test135() {\n+    public boolean test135() {\n@@ -3836,1 +3836,1 @@\n-    public static boolean test136(boolean b) {\n+    public boolean test136(boolean b) {\n@@ -3854,1 +3854,1 @@\n-    public static boolean test137(int i) {\n+    public boolean test137(int i) {\n@@ -3869,1 +3869,1 @@\n-    public static boolean test138(int i, boolean b) {\n+    public boolean test138(int i, boolean b) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2739,0 +2739,132 @@\n+\n+    static primitive class CircularValue1 {\n+        CircularValue1.ref val;\n+        int x;\n+\n+        @ForceInline\n+        public CircularValue1(CircularValue1.ref val) {\n+            this.val = val;\n+            this.x = rI;\n+        }\n+    }\n+\n+    \/\/ Test scalarization of primitive class with circularity in fields\n+    @Test\n+    public CircularValue1 test98(CircularValue1 val) {\n+        return new CircularValue1(val);\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void test98_verifier()  {\n+        CircularValue1 val = new CircularValue1(null);\n+        CircularValue1 res = test98(val);\n+        Asserts.assertEQ(res.x, rI);\n+        Asserts.assertEQ(res.val, val);\n+    }\n+\n+    static primitive class CircularValue2 {\n+        CircularValue1 val;\n+\n+        @ForceInline\n+        public CircularValue2(CircularValue1 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test98 but with circularity in class of flattened field\n+    @Test\n+    public CircularValue2 test99(CircularValue2 val) {\n+        return new CircularValue2(val.val);\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void test99_verifier()  {\n+        CircularValue1 val1 = new CircularValue1(null);\n+        CircularValue2 val2 = new CircularValue2(val1);\n+        CircularValue2 res = test99(val2);\n+        Asserts.assertEQ(res.val, val1);\n+    }\n+\n+    static primitive class CircularValue3 {\n+        CircularValue4.ref val;\n+        int x;\n+\n+        @ForceInline\n+        public CircularValue3(CircularValue4.ref val, int x) {\n+            this.val = val;\n+            this.x = x;\n+        }\n+    }\n+\n+    static primitive class CircularValue4 {\n+        CircularValue3 val;\n+\n+        @ForceInline\n+        public CircularValue4(CircularValue3 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test94 but with \"indirect\" circularity through field of flattened field\n+    @Test\n+    public CircularValue4 test100(CircularValue4 val) {\n+        return new CircularValue4(new CircularValue3(val, rI));\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier()  {\n+        CircularValue3 val3 = new CircularValue3(null, 42);\n+        CircularValue4 val4 = new CircularValue4(val3);\n+        CircularValue4 res = test100(val4);\n+        Asserts.assertEQ(res.val, new CircularValue3(val4, rI));\n+    }\n+\n+    static primitive class CircularValue5 {\n+        CircularValue6 val;\n+        int x;\n+\n+        @ForceInline\n+        public CircularValue5(CircularValue6 val, int x) {\n+            this.val = val;\n+            this.x = x;\n+        }\n+    }\n+\n+    static primitive class CircularValue6 {\n+        CircularValue5.ref val;\n+\n+        @ForceInline\n+        public CircularValue6(CircularValue5.ref val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test100 but with different combination of .ref\/.val fields\n+    @Test\n+    public CircularValue6 test101(CircularValue6 val) {\n+        return new CircularValue6(new CircularValue5(val, rI));\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier()  {\n+        CircularValue5 val5 = new CircularValue5(CircularValue6.default, 42);\n+        CircularValue6 val6 = new CircularValue6(val5);\n+        CircularValue6 res = test101(val6);\n+        Asserts.assertEQ(res.val, new CircularValue5(val6, rI));\n+    }\n+\n+    \/\/ Test merging of fields with different scalarization depth\n+    @Test\n+    public CircularValue1.ref test102(boolean b) {\n+        CircularValue1.ref val = new CircularValue1(CircularValue1.default);\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier() {\n+        Asserts.assertEQ(test102(false), new CircularValue1(CircularValue1.default));\n+        Asserts.assertEQ(test102(true), null);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":133,"deletions":1,"binary":false,"changes":134,"status":"modified"}]}