{"files":[{"patch":"@@ -116,2 +116,4 @@\n-        } else if (ak != NULL && ak->is_flatArray_klass()) {\n-          return ciFlatArrayKlass::make(klass);\n+        } else if (ak->is_flatArray_klass()) {\n+          return CURRENT_THREAD_ENV->get_flat_array_klass(ak);\n+        } else if (ak->is_objArray_klass()) {\n+          return CURRENT_THREAD_ENV->get_obj_array_klass(ak);\n@@ -121,1 +123,1 @@\n-    return ciObjArrayKlass::make(klass, null_free);\n+    return ciObjArrayKlass::make(klass);\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,8 +60,0 @@\n-ciFlatArrayKlass::ciFlatArrayKlass(ciSymbol* array_name,\n-                                     ciInlineKlass* base_element_klass,\n-                                     int dimension)\n-  : ciArrayKlass(array_name, dimension, T_INLINE_TYPE) {\n-  _base_element_klass = base_element_klass;\n-  _element_klass = base_element_klass;\n-}\n-\n@@ -84,73 +76,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::construct_array_name\n-\/\/\n-\/\/ Build an array name from an element name and a dimension.\n-ciSymbol* ciFlatArrayKlass::construct_array_name(ciSymbol* element_name,\n-                                                  int dimension) {\n-  EXCEPTION_CONTEXT;\n-  int element_len = element_name->utf8_length();\n-\n-  Symbol* base_name_sym = element_name->get_symbol();\n-  char* name;\n-\n-  if (base_name_sym->char_at(0) == JVM_SIGNATURE_ARRAY ||\n-      (base_name_sym->char_at(0) == JVM_SIGNATURE_CLASS &&  \/\/ watch package name 'Lxx'\n-       base_name_sym->char_at(element_len-1) == JVM_SIGNATURE_ENDCLASS)) {\n-\n-    int new_len = element_len + dimension + 1; \/\/ for the ['s and '\\0'\n-    name = CURRENT_THREAD_ENV->name_buffer(new_len);\n-\n-    int pos = 0;\n-    for ( ; pos < dimension; pos++) {\n-      name[pos] = JVM_SIGNATURE_ARRAY;\n-    }\n-    strncpy(name+pos, (char*)element_name->base(), element_len);\n-    name[new_len-1] = '\\0';\n-  } else {\n-    int new_len =   3                       \/\/ for L, ;, and '\\0'\n-                  + dimension               \/\/ for ['s\n-                  + element_len;\n-\n-    name = CURRENT_THREAD_ENV->name_buffer(new_len);\n-    int pos = 0;\n-    for ( ; pos < dimension; pos++) {\n-      name[pos] = JVM_SIGNATURE_ARRAY;\n-    }\n-    name[pos++] = JVM_SIGNATURE_INLINE_TYPE;\n-    strncpy(name+pos, (char*)element_name->base(), element_len);\n-    name[new_len-2] = JVM_SIGNATURE_ENDCLASS;\n-    name[new_len-1] = '\\0';\n-  }\n-  return ciSymbol::make(name);\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::make_impl\n-\/\/\n-\/\/ Implementation of make.\n-ciArrayKlass* ciFlatArrayKlass::make_impl(ciKlass* element_klass) {\n-  assert(UseFlatArray, \"should only be used for flat arrays\");\n-  assert(element_klass->is_loaded(), \"unloaded inline klasses are represented by ciInstanceKlass\");\n-  assert(element_klass->is_inlinetype(), \"element type must be an inline type\");\n-  {\n-    EXCEPTION_CONTEXT;\n-    Klass* array = InlineKlass::cast(element_klass->get_Klass())->null_free_inline_array_klass(THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      CLEAR_PENDING_EXCEPTION;\n-      CURRENT_THREAD_ENV->record_out_of_memory_failure();\n-      \/\/ Use unloaded ciObjArrayKlass here because flatArrayKlasses are always loaded\n-      \/\/ and since this is only used for OOM detection, the actual type does not matter.\n-      return ciEnv::unloaded_ciobjarrayklass();\n-    }\n-    return CURRENT_THREAD_ENV->get_flat_array_klass(array);\n-  }\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::make\n-\/\/\n-\/\/ Make an array klass corresponding to the specified primitive type.\n-ciArrayKlass* ciFlatArrayKlass::make(ciKlass* element_klass) {\n-  GUARDED_VM_ENTRY(return make_impl(element_klass);)\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.cpp","additions":1,"deletions":82,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,0 @@\n-  ciFlatArrayKlass(ciSymbol* array_name,\n-                    ciInlineKlass* element_klass,\n-                    int dimension);\n@@ -52,4 +49,0 @@\n-  static ciArrayKlass* make_impl(ciKlass* element_klass);\n-  static ciSymbol* construct_array_name(ciSymbol* element_name,\n-                                        int       dimension);\n-\n@@ -64,1 +57,0 @@\n-\n@@ -80,2 +72,0 @@\n-  static ciArrayKlass* make(ciKlass* element_klass);\n-\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool null_free) {\n+ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass) {\n@@ -145,7 +145,1 @@\n-    Klass* array;\n-    if (null_free) {\n-      assert(element_klass->get_Klass()->is_inline_klass(), \"Only inline classes can have null free arrays\");\n-      array = InlineKlass::cast(element_klass->get_Klass())->null_free_inline_array_klass(THREAD);\n-    } else {\n-      array = element_klass->get_Klass()->array_klass(THREAD);\n-    }\n+    Klass* array = element_klass->get_Klass()->array_klass(THREAD);\n@@ -174,2 +168,2 @@\n-ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool null_free) {\n-  GUARDED_VM_ENTRY(return make_impl(element_klass, null_free);)\n+ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass) {\n+  GUARDED_VM_ENTRY(return make_impl(element_klass);)\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static ciObjArrayKlass* make_impl(ciKlass* element_klass, bool null_free);\n+  static ciObjArrayKlass* make_impl(ciKlass* element_klass);\n@@ -76,1 +76,1 @@\n-  static ciObjArrayKlass* make(ciKlass* element_klass, bool null_free = false);\n+  static ciObjArrayKlass* make(ciKlass* element_klass);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1213,3 +1213,2 @@\n-  Node* c = ctl;\n-  Node* copy = NULL;\n-  Node* alloc = NULL;\n+  Node* call = ctl;\n+  MemBarNode* membar = NULL;\n@@ -1217,1 +1216,1 @@\n-    if (c == NULL || c->is_top()) {\n+    if (call == NULL || call->is_top()) {\n@@ -1220,16 +1219,6 @@\n-    if (c->is_Proj() || c->is_Catch() || c->is_MemBar()) {\n-      c = c->in(0);\n-    } else if (c->Opcode() == Op_CallLeaf &&\n-               c->as_Call()->entry_point() == CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline)) {\n-      copy = c;\n-      c = c->in(0);\n-    } else if (c->is_Allocate()) {\n-      Node* new_obj = c->as_Allocate()->result_cast();\n-      if (copy == NULL || new_obj == NULL) {\n-        return false;\n-      }\n-      Node* copy_dest = copy->in(TypeFunc::Parms + 2);\n-      if (copy_dest != new_obj) {\n-        return false;\n-      }\n-      alloc = c;\n+    if (call->is_Proj() || call->is_Catch() || call->is_MemBar()) {\n+      call = call->in(0);\n+    } else if (call->Opcode() == Op_CallStaticJava &&\n+               call->as_Call()->entry_point() == OptoRuntime::load_unknown_inline_Java()) {\n+      assert(call->in(0)->is_Proj() && call->in(0)->in(0)->is_MemBar(), \"missing membar\");\n+      membar = call->in(0)->in(0)->as_MemBar();\n@@ -1242,1 +1231,1 @@\n-  JVMState* jvms = alloc->jvms();\n+  JVMState* jvms = call->jvms();\n@@ -1247,1 +1236,1 @@\n-  Node* alloc_mem = alloc->in(TypeFunc::Memory);\n+  Node* alloc_mem = call->in(TypeFunc::Memory);\n@@ -1268,8 +1257,3 @@\n-      } else if (m1->Opcode() == Op_CallLeaf &&\n-                 m1->as_Call()->entry_point() == CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline)) {\n-        if (m1 != copy) {\n-          return false;\n-        }\n-        m1 = m1->in(TypeFunc::Memory);\n-      } else if (m1->is_Allocate()) {\n-        if (m1 != alloc) {\n+      } else if (m1->Opcode() == Op_CallStaticJava &&\n+                 m1->as_Call()->entry_point() == OptoRuntime::load_unknown_inline_Java()) {\n+        if (m1 != call) {\n@@ -1296,0 +1280,3 @@\n+  \/\/ Remove membar preceding the call\n+  membar->remove(igvn);\n+\n@@ -1298,5 +1285,5 @@\n-  unc->init_req(TypeFunc::Control, alloc->in(0));\n-  unc->init_req(TypeFunc::I_O, alloc->in(TypeFunc::I_O));\n-  unc->init_req(TypeFunc::Memory, alloc->in(TypeFunc::Memory));\n-  unc->init_req(TypeFunc::FramePtr,  alloc->in(TypeFunc::FramePtr));\n-  unc->init_req(TypeFunc::ReturnAdr, alloc->in(TypeFunc::ReturnAdr));\n+  unc->init_req(TypeFunc::Control, call->in(0));\n+  unc->init_req(TypeFunc::I_O, call->in(TypeFunc::I_O));\n+  unc->init_req(TypeFunc::Memory, call->in(TypeFunc::Memory));\n+  unc->init_req(TypeFunc::FramePtr,  call->in(TypeFunc::FramePtr));\n+  unc->init_req(TypeFunc::ReturnAdr, call->in(TypeFunc::ReturnAdr));\n@@ -1305,1 +1292,1 @@\n-  unc->copy_call_debug_info(igvn, alloc->as_Allocate());\n+  unc->copy_call_debug_info(igvn, call->as_CallStaticJava());\n@@ -1307,1 +1294,1 @@\n-  igvn->replace_input_of(alloc, 0, phase->C->top());\n+  igvn->replace_input_of(call, 0, phase->C->top());\n@@ -1312,1 +1299,1 @@\n-  Node* halt = phase->transform(new HaltNode(ctrl, alloc->in(TypeFunc::FramePtr), \"uncommon trap returned which should never happen\"));\n+  Node* halt = phase->transform(new HaltNode(ctrl, call->in(TypeFunc::FramePtr), \"uncommon trap returned which should never happen\"));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":25,"deletions":38,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -64,0 +65,10 @@\n+\/\/------------------------------Ideal------------------------------------------\n+Node* Conv2BNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1)->is_InlineTypePtr()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the is_init\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    set_req_X(1, in(1)->as_InlineTypePtr()->get_is_init(), phase);\n+    return this;\n+  }\n+  return NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -970,1 +970,2 @@\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0, \"TODO: add failed case check\");\n+      assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+             strncmp(name, \"_load_unknown_inline\", 20) == 0, \"TODO: add failed case check\");\n@@ -1675,1 +1676,2 @@\n-    assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n+    assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+           strncmp(name, \"_load_unknown_inline\", 20) == 0, \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1245,1 +1245,2 @@\n-                                  bool speculative) {\n+                                  bool speculative,\n+                                  bool is_init_check) {\n@@ -1257,1 +1258,1 @@\n-    null_check_common(vtptr->get_is_init(), type, assert_null, null_control, speculative);\n+    null_check_common(vtptr->get_is_init(), T_INT, assert_null, null_control, speculative, true);\n@@ -1368,1 +1369,1 @@\n-  } else if (type == T_OBJECT) {\n+  } else if (type == T_OBJECT || is_init_check) {\n@@ -1451,0 +1452,1 @@\n+      \/\/ Always null\n@@ -1454,1 +1456,1 @@\n-    InlineTypeBaseNode* vt = new InlineTypePtrNode(obj->as_InlineTypePtr());\n+    InlineTypeBaseNode* vt = obj->clone()->as_InlineTypePtr();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -370,1 +370,2 @@\n-                          bool speculative = false);\n+                          bool speculative = false,\n+                          bool is_init_check = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  phi_type = Type::get_const_basic_type(T_BOOLEAN);\n@@ -254,1 +255,1 @@\n-  if (igvn->type(get_is_init())->maybe_null()) {\n+  if (!igvn->type(get_is_init())->is_int()->is_con(1)) {\n@@ -623,0 +624,1 @@\n+  vt->set_is_init(gvn);\n@@ -643,0 +645,1 @@\n+  vt->set_req(IsInit, gvn.intcon(0));\n@@ -1072,0 +1075,1 @@\n+  ptr->set_req(IsInit, gvn.intcon(0));\n@@ -1095,1 +1099,2 @@\n-  if (phase->type(in(IsInit))->isa_ptr() && !phase->type(in(IsInit))->is_ptr()->maybe_null()) {\n+  const Type* tinit = phase->type(in(IsInit));\n+  if (tinit->isa_int() && tinit->is_int()->is_con(1)) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  void  set_is_init(PhaseGVN& gvn) { set_req(IsInit, InlineTypeBaseNode::default_oop(gvn, inline_klass())); }\n+  void  set_is_init(PhaseGVN& gvn) { set_req(IsInit, gvn.intcon(1)); }\n@@ -130,1 +130,0 @@\n-    init_req(IsInit, oop);\n@@ -187,1 +186,0 @@\n-    init_req(IsInit, oop);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-          const Type* init_type = init_node->bottom_type();\n+          const TypeInt* init_type = init_node->bottom_type()->is_int();\n@@ -882,1 +882,1 @@\n-            is_init = new ConstantOopWriteValue(init_type->is_zero_type() ? 0 : init_type->isa_oopptr()->const_oop()->constant_encoding());\n+            is_init = new ConstantIntValue(init_type->get_con());\n@@ -885,1 +885,1 @@\n-            is_init = new_loc_value(C->regalloc(), init_reg, init_type->isa_narrowoop() ? Location::narrowoop : Location::oop);\n+            is_init = new_loc_value(C->regalloc(), init_reg, Location::normal);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -133,11 +133,0 @@\n-        Node* kls = load_object_klass(ary);\n-        Node* k_adr = basic_plus_adr(kls, in_bytes(ArrayKlass::element_klass_offset()));\n-        Node* elem_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n-        Node* obj_size  = NULL;\n-        kill_dead_locals();\n-        \/\/ Re-execute flattened array load if buffering triggers deoptimization\n-        PreserveReexecuteState preexecs(this);\n-        jvms()->set_bci(_bci);\n-        jvms()->set_should_reexecute(true);\n-        inc_sp(2);\n-        Node* alloc_obj = new_instance(elem_klass, NULL, &obj_size, \/*deoptimize_on_exception=*\/true);\n@@ -145,7 +134,2 @@\n-        AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_obj, &_gvn);\n-        assert(alloc->maybe_set_complete(&_gvn), \"\");\n-        alloc->initialization()->set_complete_with_arraycopy();\n-\n-        \/\/ This membar keeps this access to an unknown flattened array\n-        \/\/ correctly ordered with other unknown and known flattened\n-        \/\/ array accesses.\n+        \/\/ Below membars keep this access to an unknown flattened array correctly\n+        \/\/ ordered with other unknown and known flattened array accesses.\n@@ -154,27 +138,13 @@\n-        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-        \/\/ Unknown inline type might contain reference fields\n-        if (false && !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, false, BarrierSetC2::Parsing)) {\n-          \/\/ FIXME 8230656 also merge changes from 8238759 in\n-          int base_off = sizeof(instanceOopDesc);\n-          Node* dst_base = basic_plus_adr(alloc_obj, base_off);\n-          Node* countx = obj_size;\n-          countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));\n-          countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));\n-\n-          assert(Klass::_lh_log2_element_size_shift == 0, \"use shift in place\");\n-          Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));\n-          Node* elem_shift = make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);\n-          uint header = arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE);\n-          Node* base  = basic_plus_adr(ary, header);\n-          idx = Compile::conv_I2X_index(&_gvn, idx, TypeInt::POS, control());\n-          Node* scale = _gvn.transform(new LShiftXNode(idx, elem_shift));\n-          Node* adr = basic_plus_adr(ary, base, scale);\n-\n-          access_clone(adr, dst_base, countx, false);\n-        } else {\n-          ideal.sync_kit(this);\n-          ideal.make_leaf_call(OptoRuntime::load_unknown_inline_type(),\n-                               CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline),\n-                               \"load_unknown_inline\",\n-                               ary, idx, alloc_obj);\n-          sync_kit(ideal);\n+        Node* call = NULL;\n+        {\n+          \/\/ Re-execute flattened array load if runtime call triggers deoptimization\n+          PreserveReexecuteState preexecs(this);\n+          jvms()->set_bci(_bci);\n+          jvms()->set_should_reexecute(true);\n+          inc_sp(2);\n+          kill_dead_locals();\n+          call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                                   OptoRuntime::load_unknown_inline_type(),\n+                                   OptoRuntime::load_unknown_inline_Java(),\n+                                   NULL, TypeRawPtr::BOTTOM,\n+                                   ary, idx);\n@@ -182,0 +152,2 @@\n+        make_slow_call_ex(call, env()->Throwable_klass(), false);\n+        Node* buffer = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n@@ -183,6 +155,0 @@\n-        \/\/ This makes sure no other thread sees a partially initialized buffered inline type\n-        insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc->proj_out_or_null(AllocateNode::RawAddress));\n-\n-        \/\/ Same as MemBarCPUOrder above: keep this unknown flattened\n-        \/\/ array access correctly ordered with other flattened array\n-        \/\/ access\n@@ -191,5 +157,1 @@\n-        \/\/ Prevent any use of the newly allocated inline type before it is fully initialized\n-        alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), ConstraintCastNode::StrongDependency);\n-        alloc_obj->set_req(0, control());\n-        alloc_obj = _gvn.transform(alloc_obj);\n-\n+        \/\/ Keep track of the information that the inline type is flattened in arrays\n@@ -197,1 +159,1 @@\n-        alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));\n+        buffer = _gvn.transform(new CheckCastPPNode(control(), buffer, unknown_value));\n@@ -200,1 +162,1 @@\n-        ideal.set(res, alloc_obj);\n+        ideal.set(res, buffer);\n@@ -305,0 +267,1 @@\n+        sync_kit(ideal);\n@@ -309,1 +272,0 @@\n-          sync_kit(ideal);\n@@ -319,1 +281,0 @@\n-          ideal.sync_kit(this);\n@@ -333,1 +294,0 @@\n-          sync_kit(ideal);\n@@ -348,2 +308,1 @@\n-          ideal.sync_kit(this);\n-        } else if (!ideal.ctrl()->is_top()) {\n+        } else if (!stopped()) {\n@@ -351,1 +310,0 @@\n-          sync_kit(ideal);\n@@ -353,3 +311,2 @@\n-          \/\/ This membar keeps this access to an unknown flattened\n-          \/\/ array correctly ordered with other unknown and known\n-          \/\/ flattened array accesses.\n+          \/\/ Below membars keep this access to an unknown flattened array correctly\n+          \/\/ ordered with other unknown and known flattened array accesses.\n@@ -357,1 +314,0 @@\n-          ideal.sync_kit(this);\n@@ -359,4 +315,5 @@\n-          ideal.make_leaf_call(OptoRuntime::store_unknown_inline_type(),\n-                               CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),\n-                               \"store_unknown_inline\",\n-                               val, casted_ary, idx);\n+          make_runtime_call(RC_LEAF,\n+                            OptoRuntime::store_unknown_inline_type(),\n+                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),\n+                            \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n+                            val, casted_ary, idx);\n@@ -364,4 +321,0 @@\n-          sync_kit(ideal);\n-          \/\/ Same as MemBarCPUOrder above: keep this unknown\n-          \/\/ flattened array access correctly ordered with other\n-          \/\/ flattened array accesses.\n@@ -369,1 +322,0 @@\n-          ideal.sync_kit(this);\n@@ -371,0 +323,1 @@\n+        ideal.sync_kit(this);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":30,"deletions":77,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+address OptoRuntime::_load_unknown_inline                         = NULL;\n@@ -153,1 +154,0 @@\n-\n@@ -156,0 +156,1 @@\n+  gen(env, _load_unknown_inline            , load_unknown_inline_type     , load_unknown_inline             ,    0 , true,  false);\n@@ -1779,4 +1780,7 @@\n-JRT_LEAF(void, OptoRuntime::load_unknown_inline(flatArrayOopDesc* array, int index, instanceOopDesc* buffer))\n-{\n-  array->value_copy_from_index(index, buffer);\n-}\n+JRT_BLOCK_ENTRY(void, OptoRuntime::load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current))\n+  JRT_BLOCK;\n+  flatArrayHandle vah(current, array);\n+  oop buffer = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, THREAD);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(buffer);\n+  JRT_BLOCK_END;\n@@ -1787,4 +1791,1 @@\n-  const Type** fields = TypeTuple::fields(3);\n-  \/\/ We don't know the number of returned values and their\n-  \/\/ types. Assume all registers available to the return convention\n-  \/\/ are used.\n+  const Type** fields = TypeTuple::fields(2);\n@@ -1793,1 +1794,0 @@\n-  fields[TypeFunc::Parms+2] = TypeInstPtr::NOTNULL;\n@@ -1795,1 +1795,1 @@\n-  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n@@ -1798,2 +1798,4 @@\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n@@ -1814,3 +1816,0 @@\n-  \/\/ We don't know the number of returned values and their\n-  \/\/ types. Assume all registers available to the return convention\n-  \/\/ are used.\n@@ -1825,1 +1824,1 @@\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  static address _load_unknown_inline;\n@@ -211,0 +212,1 @@\n+  static address load_unknown_inline_Java()              { return _load_unknown_inline; }\n@@ -300,1 +302,1 @@\n-  static void load_unknown_inline(flatArrayOopDesc* array, int index, instanceOopDesc* buffer);\n+  static void load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1148,2 +1148,1 @@\n-    set_req_X(1, in(1)->as_InlineTypePtr()->get_is_init(), phase);\n-    return this;\n+    return new CmpINode(in(1)->as_InlineTypePtr()->get_is_init(), phase->intcon(0));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1099,2 +1099,3 @@\n-      StackValue* init_value = StackValue::create_stack_value(fr, reg_map, sv->is_init());\n-      if (init_value->get_obj().is_null()) {\n+      intptr_t init_value = StackValue::create_stack_value(fr, reg_map, sv->is_init())->get_int();\n+      jint is_init = (jint)*((jint*)&init_value);\n+      if (is_init == 0) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,2 +194,3 @@\n-      StackValue* is_init_value = StackValue::create_stack_value(fr, reg_map, ov->is_init());\n-      scalar_replaced &= is_init_value->get_obj().not_null();\n+      intptr_t is_init_value = StackValue::create_stack_value(fr, reg_map, ov->is_init())->get_int();\n+      jint is_init = (jint)*((jint*)&is_init_value);\n+      scalar_replaced &= (is_init != 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-        protected static final String LOAD_UNKNOWN_INLINE = \"(.*\" + CALL_LEAF + \".*load_unknown_inline.*\" + END;\n+        protected static final String LOAD_UNKNOWN_INLINE = START + \"CallStaticJava\" + MID + \"_load_unknown_inline\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1860,1 +1860,1 @@\n-        counts = {ALLOC_G, \"= 1\", LOAD_UNKNOWN_INLINE, \"= 1\"})\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n@@ -1881,1 +1881,1 @@\n-        counts = {ALLOC_G, \"= 1\", LOAD_UNKNOWN_INLINE, \"= 1\"})\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n@@ -1962,1 +1962,1 @@\n-        counts = {ALLOC_G, \"= 1\", LOAD_UNKNOWN_INLINE, \"= 1\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4123,0 +4123,2 @@\n+\/\/ TODO 8274972\n+\/*\n@@ -4144,0 +4146,1 @@\n+*\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n+        counts = {CALL, \"= 4\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n@@ -266,1 +266,1 @@\n-        counts = {CALL, \"= 6\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n+        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n@@ -296,2 +296,2 @@\n-        counts = {CALL, \"= 6\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\",\n-                  RANGE_CHECK_TRAP, \"= 1\", UNHANDLED_TRAP, \"= 1\", ALLOC_G, \"= 1\"})\n+        counts = {CALL, \"= 5\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\",\n+                  RANGE_CHECK_TRAP, \"= 1\"})\n@@ -299,2 +299,1 @@\n-        counts = {CALL, \"= 6\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\",\n-                  UNHANDLED_TRAP, \"= 1\", ALLOC_G, \"= 1\"})\n+        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2389,0 +2389,29 @@\n+\n+    public static primitive class Test87C0 {\n+        int x = rI;\n+    }\n+\n+    public static primitive class Test87C1 {\n+        Test87C0 field = Test87C0.default;\n+    }\n+\n+    public static primitive class Test87C2 {\n+        Test87C1 field = Test87C1.default;\n+    }\n+\n+    \/\/ Test merging .val and .ref in return\n+    @Test\n+    public Test87C1 test87(boolean b, Test87C2.val v1, Test87C2.ref v2) {\n+        if (b) {\n+            return v1.field;\n+        } else {\n+            return v2.field;\n+        }\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier(RunInfo info) {\n+        Test87C2 v = new Test87C2();\n+        Asserts.assertEQ(test87(true, v, v), v.field);\n+        Asserts.assertEQ(test87(false, v, v), v.field);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}