{"files":[{"patch":"@@ -3305,8 +3305,0 @@\n-  if (flags & LIR_OpArrayCopy::src_inlinetype_check) {\n-    arraycopy_inlinetype_check(src, tmp, stub, false, (flags & LIR_OpArrayCopy::src_null_check));\n-  }\n-\n-  if (flags & LIR_OpArrayCopy::dst_inlinetype_check) {\n-    arraycopy_inlinetype_check(dst, tmp, stub, true, (flags & LIR_OpArrayCopy::dst_null_check));\n-  }\n-\n@@ -3406,0 +3398,8 @@\n+  \/\/ Handle inline type arrays\n+  if (flags & LIR_OpArrayCopy::src_inlinetype_check) {\n+    arraycopy_inlinetype_check(src, tmp, stub, false, (flags & LIR_OpArrayCopy::src_null_check));\n+  }\n+  if (flags & LIR_OpArrayCopy::dst_inlinetype_check) {\n+    arraycopy_inlinetype_check(dst, tmp, stub, true, (flags & LIR_OpArrayCopy::dst_null_check));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2644,1 +2644,1 @@\n-    \/\/ Handle objArrays completely differently...\n+    \/\/ Handle objArrays (including non-flat, null-free inline type arrays) completely differently...\n@@ -2647,1 +2647,1 @@\n-    __ jcc(Assembler::equal, L_objArray);\n+    __ jcc(Assembler::greaterEqual, L_objArray);\n@@ -2657,0 +2657,4 @@\n+    \/\/ Check for flat inline type array\n+    __ testl(rax_lh, Klass::_lh_array_tag_vt_value_bit_inplace);\n+    __ jcc(Assembler::notZero, L_failed);\n+\n@@ -2666,2 +2670,4 @@\n-      __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift));\n-      __ jcc(Assembler::greaterEqual, L);\n+      __ movl(rklass_tmp, rax_lh);\n+      __ sarl(rklass_tmp, Klass::_lh_array_tag_shift);\n+      __ cmpl(rklass_tmp, Klass::_lh_array_tag_type_value);\n+      __ jcc(Assembler::equal, L);\n@@ -2769,0 +2775,1 @@\n+      \/\/ This check also fails for flat\/null-free arrays which are not supported.\n@@ -2772,0 +2779,13 @@\n+#ifdef ASSERT\n+      {\n+        BLOCK_COMMENT(\"assert not null-free array {\");\n+        Label L;\n+        __ movl(rklass_tmp, Address(rax, lh_offset));\n+        __ testl(rklass_tmp, Klass::_lh_null_free_bit_inplace);\n+        __ jcc(Assembler::zero, L);\n+        __ stop(\"unexpected null-free array\");\n+        __ bind(L);\n+        BLOCK_COMMENT(\"} assert not null-free array\");\n+      }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -273,2 +273,1 @@\n-    if (src_elem  == T_ARRAY ||\n-        (src_elem == T_INLINE_TYPE && ary_src->klass()->is_obj_array_klass())) {\n+    if (src_elem == T_ARRAY || (src_elem == T_INLINE_TYPE && ary_src->klass()->is_obj_array_klass())) {\n@@ -277,2 +276,1 @@\n-    if (dest_elem == T_ARRAY ||\n-        (dest_elem == T_INLINE_TYPE && ary_dest->klass()->is_obj_array_klass())) {\n+    if (dest_elem == T_ARRAY || (dest_elem == T_INLINE_TYPE && ary_dest->klass()->is_obj_array_klass())) {\n@@ -336,2 +334,1 @@\n-    if (elem == T_ARRAY ||\n-        (elem == T_INLINE_TYPE && ary_src->klass()->is_obj_array_klass())) {\n+    if (elem == T_ARRAY || (elem == T_INLINE_TYPE && ary_src->klass()->is_obj_array_klass())) {\n@@ -345,0 +342,1 @@\n+      \/\/ It's an object array copy but we can't emit the card marking that is needed\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3571,1 +3571,0 @@\n-  Node* tag = load_lh_array_tag(kls);\n@@ -3576,0 +3575,10 @@\n+\/\/ Check bit that determines if an array is null-free\n+Node* GraphKit::check_null_free_bit(Node* klass, bool null_free) {\n+  Node* lhp = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+  Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* bit = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));\n+  bit = _gvn.transform(new AndINode(bit, intcon(Klass::_lh_null_free_mask)));\n+  Node* cmp = _gvn.transform(new CmpINode(bit, intcon(0)));\n+  return _gvn.transform(new BoolNode(cmp, null_free ? BoolTest::ne : BoolTest::eq));\n+}\n+\n@@ -3579,6 +3588,1 @@\n-  Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));\n-  Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-  Node* null_free = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));\n-  null_free = _gvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));\n-  Node* cmp = _gvn.transform(new CmpINode(null_free, intcon(0)));\n-  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  return check_null_free_bit(kls, false);\n@@ -4248,7 +4252,1 @@\n-    Node* lhp = basic_plus_adr(klass_node, in_bytes(Klass::layout_helper_offset()));\n-    Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-    Node* null_free = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));\n-    null_free = _gvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));\n-    cmp = _gvn.transform(new CmpINode(null_free, intcon(0)));\n-    bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));\n-    iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+    iff = create_and_map_if(control(), check_null_free_bit(klass_node, true), PROB_FAIR, COUNT_UNKNOWN);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -858,0 +858,1 @@\n+  Node* check_null_free_bit(Node* klass, bool null_free);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -205,1 +206,2 @@\n-    FlatArray\n+    FlatArray,\n+    NonFlatArray\n@@ -229,0 +231,4 @@\n+  Node* generate_non_flatArray_guard(Node* kls, RegionNode* region) {\n+    assert(UseFlatArray, \"can never be flattened\");\n+    return generate_array_guard_common(kls, region, NonFlatArray);\n+  }\n@@ -3727,0 +3733,1 @@\n+      case NonFlatArray:   query = !Klass::layout_helper_is_flatArray(layout_con); break;\n@@ -3749,1 +3756,1 @@\n-      btest = kind == ObjectArray ? BoolTest::eq : BoolTest::ne;\n+      btest = (kind == ObjectArray) ? BoolTest::eq : BoolTest::ne;\n@@ -3758,1 +3765,2 @@\n-    case FlatArray: {\n+    case FlatArray:\n+    case NonFlatArray: {\n@@ -3761,1 +3769,1 @@\n-      btest = BoolTest::eq;\n+      btest = (kind == FlatArray) ? BoolTest::eq : BoolTest::ne;\n@@ -3919,0 +3927,2 @@\n+    \/\/ TODO 8251971: Optimize for the case when flat src\/dst are later found\n+    \/\/ to not contain oops (i.e., move this check to the macro expansion phase).\n@@ -3920,2 +3930,8 @@\n-    Node* not_objArray = !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing) ?\n-        generate_typeArray_guard(klass_node, bailout) : generate_non_objArray_guard(klass_node, bailout);\n+    const TypeAryPtr* orig_t = _gvn.type(original)->isa_aryptr();\n+    ciKlass* klass = _gvn.type(klass_node)->is_klassptr()->klass();\n+    bool exclude_flat = UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, false, BarrierSetC2::Parsing) &&\n+                        \/\/ Can src array be flat and contain oops?\n+                        (orig_t == NULL || (!orig_t->is_not_flat() && (!orig_t->is_flat() || orig_t->elem()->inline_klass()->contains_oops()))) &&\n+                        \/\/ Can dest array be flat and contain oops?\n+                        klass->can_be_inline_array_klass() && (!klass->is_flat_array_klass() || klass->as_flat_array_klass()->element_klass()->as_inline_klass()->contains_oops());\n+    Node* not_objArray = exclude_flat ? generate_non_objArray_guard(klass_node, bailout) : generate_typeArray_guard(klass_node, bailout);\n@@ -3953,21 +3969,0 @@\n-    if (UseFlatArray) {\n-      \/\/ Either both or neither new array klass and original array\n-      \/\/ klass must be flattened\n-      const TypeAryPtr* t_original = _gvn.type(original)->isa_aryptr();\n-      Node* is_flat = generate_flatArray_guard(klass_node, NULL);\n-      if (t_original == NULL || !t_original->is_not_flat()) {\n-        generate_flatArray_guard(original_kls, bailout);\n-      }\n-      if (is_flat != NULL) {\n-        RegionNode* r = new RegionNode(2);\n-        record_for_igvn(r);\n-        r->init_req(1, control());\n-        set_control(is_flat);\n-        if (t_original == NULL || !t_original->is_not_flat()) {\n-          generate_flatArray_guard(original_kls, r);\n-        }\n-        bailout->add_req(control());\n-        set_control(_gvn.transform(r));\n-      }\n-    }\n-\n@@ -3989,0 +3984,32 @@\n+    \/\/ Handle inline type arrays\n+    bool can_validate = !too_many_traps(Deoptimization::Reason_class_check);\n+    if (!stopped()) {\n+      orig_t = _gvn.type(original)->isa_aryptr();\n+      if (orig_t != NULL && orig_t->is_flat()) {\n+        \/\/ Src is flat, check that dest is flat as well\n+        if (exclude_flat) {\n+          \/\/ Dest can't be flat, bail out\n+          bailout->add_req(control());\n+          set_control(top());\n+        } else {\n+          generate_non_flatArray_guard(klass_node, bailout);\n+        }\n+      } else if (UseFlatArray && (orig_t == NULL || !orig_t->is_not_flat()) &&\n+                 \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check if validated).\n+                 ((!klass->is_flat_array_klass() && klass->can_be_inline_array_klass()) || !can_validate)) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n+        generate_flatArray_guard(original_kls, bailout);\n+        if (orig_t != NULL) {\n+          orig_t = orig_t->cast_to_not_flat();\n+          original = _gvn.transform(new CheckCastPPNode(control(), original, orig_t));\n+        }\n+      }\n+      if (!can_validate) {\n+        \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n+        \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat\/null-free.\n+        generate_fair_guard(check_null_free_bit(klass_node, true), bailout);\n+      }\n+    }\n+\n@@ -4011,1 +4038,1 @@\n-      if (!too_many_traps(Deoptimization::Reason_class_check)) {\n+      if (can_validate) {\n@@ -4651,3 +4678,4 @@\n-      if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing) &&\n-          UseFlatArray && obj_type->klass()->can_be_inline_array_klass() &&\n-          (!obj_type->isa_aryptr() || !obj_type->is_aryptr()->is_not_flat())) {\n+      const TypeAryPtr* ary_ptr = obj_type->isa_aryptr();\n+      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing) &&\n+          obj_type->klass()->can_be_inline_array_klass() &&\n+          (ary_ptr == NULL || (!ary_ptr->is_not_flat() && (!ary_ptr->is_flat() || ary_ptr->elem()->inline_klass()->contains_oops())))) {\n@@ -5077,2 +5105,1 @@\n-      can_emit_guards &&\n-      !src->is_top() && !dest->is_top()) {\n+      can_emit_guards && !src->is_top() && !dest->is_top()) {\n@@ -5121,8 +5148,1 @@\n-\n-      if (not_subtype_ctrl != top()) {\n-        PreserveJVMState pjvms(this);\n-        set_control(not_subtype_ctrl);\n-        uncommon_trap(Deoptimization::Reason_intrinsic,\n-                      Deoptimization::Action_make_not_entrant);\n-        assert(stopped(), \"Should be stopped\");\n-      }\n+      slow_region->add_req(not_subtype_ctrl);\n@@ -5137,10 +5157,23 @@\n-    if (top_dest != NULL && !top_dest->is_flat() && !top_dest->is_not_flat()) {\n-      generate_flatArray_guard(dest_klass, slow_region);\n-      top_dest = top_dest->cast_to_not_flat();\n-      dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));\n-    }\n-    if (top_src != NULL && !top_src->is_flat() && !top_src->is_not_flat()) {\n-      Node* src_klass = load_object_klass(src);\n-      generate_flatArray_guard(src_klass, slow_region);\n-      top_src = top_src->cast_to_not_flat();\n-      src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));\n+    \/\/ Handle flat inline type arrays (null-free arrays are handled by the subtype check above)\n+    if (!stopped() && UseFlatArray) {\n+      \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check). Handle flat src here.\n+      assert(top_dest == NULL || !top_dest->is_flat() || top_src->is_flat(), \"src array must be flat\");\n+      if (top_src != NULL && top_src->is_flat()) {\n+        \/\/ Src is flat, check that dest is flat as well\n+        if (top_dest != NULL && !top_dest->is_flat()) {\n+          generate_non_flatArray_guard(dest_klass, slow_region);\n+          \/\/ Since dest is flat and src <: dest, dest must have the same type as src.\n+          top_dest = TypeOopPtr::make_from_klass(top_src->klass())->isa_aryptr();\n+          assert(top_dest->is_flat(), \"dest must be flat\");\n+          dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));\n+        }\n+      } else if (top_src == NULL || !top_src->is_not_flat()) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n+        assert(top_dest == NULL || !top_dest->is_flat(), \"dest array must not be flat\");\n+        generate_flatArray_guard(load_object_klass(src), slow_region);\n+        if (top_src != NULL) {\n+          top_src = top_src->cast_to_not_flat();\n+          src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":84,"deletions":51,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -137,1 +137,2 @@\n-  Node* generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj, RegionNode* region);\n+  Node* generate_flat_array_guard(Node** ctrl, Node* mem, Node* obj, RegionNode* region);\n+  Node* generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-Node* PhaseMacroExpand::generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {\n+Node* PhaseMacroExpand::generate_flat_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {\n@@ -197,0 +197,12 @@\n+Node* PhaseMacroExpand::generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region) {\n+  Node* k_adr = basic_plus_adr(array, oopDesc::klass_offset_in_bytes());\n+  Node* klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+  Node* lhp = basic_plus_adr(klass_node, in_bytes(Klass::layout_helper_offset()));\n+  Node* layout_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* null_free = _igvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));\n+  null_free = _igvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));\n+  Node* cmp = _igvn.transform(new CmpINode(null_free, intcon(0)));\n+  Node* test = _igvn.transform(new BoolNode(cmp, BoolTest::ne));\n+  return generate_fair_guard(ctrl, test, region);\n+}\n+\n@@ -1161,2 +1173,7 @@\n-  assert(top_dest->klass()->is_flat_array_klass(), \"inconsistent\");\n-  int elem_size = ((ciFlatArrayKlass*)top_dest->klass())->element_byte_size();\n+#ifdef ASSERT\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bool needs_barriers = top_dest->elem()->inline_klass()->contains_oops() &&\n+                        bs->array_copy_requires_gc_barriers(dest_length != NULL, T_OBJECT, false, BarrierSetC2::Optimization);\n+  assert(!needs_barriers, \"Flat arracopy would require GC barriers\");\n+#endif\n+  int elem_size = top_dest->klass()->as_flat_array_klass()->element_byte_size();\n@@ -1204,0 +1221,1 @@\n+    const Type* src_type = _igvn.type(src);\n@@ -1205,0 +1223,1 @@\n+    const TypeAryPtr* top_src = src_type->isa_aryptr();\n@@ -1213,0 +1232,5 @@\n+    if (top_src != NULL && top_src->is_flat()) {\n+      \/\/ If src is flat, dest is guaranteed to be flat as well\n+      dest_elem = T_INLINE_TYPE;\n+      top_dest = top_src;\n+    }\n@@ -1219,0 +1243,1 @@\n+    Node* dest_length = NULL;\n@@ -1222,0 +1247,1 @@\n+      dest_length = alloc->in(AllocateNode::ALength);\n@@ -1223,2 +1249,0 @@\n-    assert(dest_elem != T_INLINE_TYPE || alloc != NULL, \"unsupported\");\n-    Node* dest_length = (alloc != NULL) ? alloc->in(AllocateNode::ALength) : NULL;\n@@ -1228,0 +1252,4 @@\n+      assert(dest_length != NULL, \"must be tightly coupled\");\n+      \/\/ Copy to a flat array modifies multiple memory slices. Conservatively insert a barrier\n+      \/\/ on all slices to prevent writes into the source from floating below the arraycopy.\n+      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n@@ -1243,1 +1271,0 @@\n-\n@@ -1274,1 +1301,1 @@\n-  if (src_elem == T_ARRAY) {\n+  if (src_elem == T_ARRAY || (src_elem == T_INLINE_TYPE && top_src->klass()->is_obj_array_klass())) {\n@@ -1276,7 +1303,0 @@\n-  } else if (src_elem == T_INLINE_TYPE && top_src->klass()->is_obj_array_klass()) {\n-    if (top_src->klass_is_exact()) {\n-      src_elem = T_OBJECT;\n-    } else {\n-      assert(!top_src->klass()->is_inlinetype(), \"klass should be exact\");\n-      src_elem = T_CONFLICT; \/\/ either flattened or not\n-    }\n@@ -1284,1 +1304,1 @@\n-  if (dest_elem == T_ARRAY) {\n+  if (dest_elem == T_ARRAY || (dest_elem == T_INLINE_TYPE && top_dest->klass()->is_obj_array_klass())) {\n@@ -1286,7 +1306,0 @@\n-  } else if (dest_elem == T_INLINE_TYPE && top_dest->klass()->is_obj_array_klass()) {\n-    if (top_dest->klass_is_exact()) {\n-      dest_elem = T_OBJECT;\n-    } else {\n-      assert(!top_dest->klass()->is_inlinetype(), \"klass should be exact\");\n-      dest_elem = T_CONFLICT; \/\/ either flattened or not\n-    }\n@@ -1295,3 +1308,1 @@\n-  if (ac->is_arraycopy_validated() &&\n-      dest_elem != T_CONFLICT &&\n-      src_elem == T_CONFLICT) {\n+  if (ac->is_arraycopy_validated() && dest_elem != T_CONFLICT && src_elem == T_CONFLICT) {\n@@ -1312,7 +1323,0 @@\n-    RegionNode* slow_region = new RegionNode(1);\n-    transform_later(slow_region);\n-\n-    if (UseFlatArray && (top_dest == NULL || !top_dest->is_not_flat())) {\n-      generate_flattened_array_guard(&ctrl, merge_mem, dest, slow_region);\n-    }\n-\n@@ -1326,3 +1330,1 @@\n-                                   false, ac->has_negative_length_guard(),\n-                                   slow_region);\n-\n+                                   false, ac->has_negative_length_guard());\n@@ -1341,1 +1343,3 @@\n-  if (src_elem != dest_elem || dest_elem == T_VOID) {\n+  if (src_elem != dest_elem || dest_elem == T_VOID ||\n+      (dest_elem == T_INLINE_TYPE && top_dest->elem()->inline_klass()->contains_oops() &&\n+       bs->array_copy_requires_gc_barriers(alloc != NULL, T_OBJECT, false, BarrierSetC2::Optimization))) {\n@@ -1369,5 +1373,0 @@\n-  if (dest_elem == T_INLINE_TYPE) {\n-    \/\/ copy modifies more than 1 slice\n-    insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n-  }\n-\n@@ -1417,6 +1416,11 @@\n-    if (dest_elem == T_OBJECT && !top_dest->is_flat() && !top_dest->is_not_flat()) {\n-      generate_flattened_array_guard(&ctrl, merge_mem, dest, slow_region);\n-    }\n-\n-    if (src_elem == T_OBJECT && !top_src->is_flat() && !top_src->is_not_flat()) {\n-      generate_flattened_array_guard(&ctrl, merge_mem, src, slow_region);\n+    \/\/ Handle inline type arrays\n+    if (!top_src->is_flat()) {\n+      if (UseFlatArray && !top_src->is_not_flat()) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        generate_flat_array_guard(&ctrl, merge_mem, src, slow_region);\n+      }\n+      \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n+      \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n+      generate_null_free_array_guard(&ctrl, dest, slow_region);\n+    } else {\n+      assert(top_dest->is_flat(), \"dest array must be flat\");\n@@ -1428,2 +1432,1 @@\n-\n-  Node* dest_length = alloc != NULL ? alloc->in(AllocateNode::ALength) : NULL;\n+  Node* dest_length = (alloc != NULL) ? alloc->in(AllocateNode::ALength) : NULL;\n@@ -1432,0 +1435,3 @@\n+    \/\/ Copy to a flat array modifies multiple memory slices. Conservatively insert a barrier\n+    \/\/ on all slices to prevent writes into the source from floating below the arraycopy.\n+    insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":55,"deletions":49,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+    protected static final String CLONE_INTRINSIC_SLOW_PATH = \"(.*call,static.*java.lang.Object::clone.*\" + END;\n@@ -231,0 +232,2 @@\n+    protected static final String CHECKCAST_ARRAYCOPY = \"(.*call_leaf_nofp,runtime  checkcast_arraycopy.*\" + END;\n+    protected static final String JLONG_ARRAYCOPY = \"(.*call_leaf_nofp,runtime  jlong_disjoint_arraycopy.*\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8252506\n+ * @summary Verify that arraycopy intrinsics properly handle flat inline type arrays with oop fields.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::test*\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::create*\n+ *                   -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopyWithOops\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::test*\n+ *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::create*\n+ *                   -Xbatch -XX:FlatArrayElementMaxSize=0\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopyWithOops\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.util.Arrays;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestArrayCopyWithOops {\n+    static final int LEN = 200;\n+\n+    static class MyObject {\n+        long val = Integer.MAX_VALUE;\n+    }\n+\n+    static inline class ManyOops {\n+        MyObject o1 = new MyObject();\n+        MyObject o2 = new MyObject();\n+        MyObject o3 = new MyObject();\n+        MyObject o4 = new MyObject();\n+\n+        long hash() {\n+            return o1.val + o2.val + o3.val + o4.val;\n+        }\n+    }\n+\n+    static ManyOops[] createArrayInline() {\n+        ManyOops[] array = new ManyOops[LEN];\n+        for (int i = 0; i < LEN; ++i) {\n+            array[i] = new ManyOops();\n+        }\n+        return array;\n+    }\n+\n+    static Object[] createArrayObject() {\n+        return createArrayInline();\n+    }\n+\n+    static Object createObject() {\n+        return createArrayInline();\n+    }\n+\n+    \/\/ System.arraycopy tests\n+\n+    static void test1(ManyOops[] dst) {\n+        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+    }\n+\n+    static void test2(Object[] dst) {\n+        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+    }\n+\n+    static void test3(ManyOops[] dst) {\n+        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+    }\n+\n+    static void test4(Object[] dst) {\n+        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+    }\n+\n+    \/\/ System.arraycopy tests (tightly coupled with allocation of dst array)\n+\n+    static Object[] test5() {\n+        ManyOops[] dst = new ManyOops[LEN];\n+        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+        return dst;\n+    }\n+\n+    static Object[] test6() {\n+        Object[] dst = new Object[LEN];\n+        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+        return dst;\n+    }\n+\n+    static Object[] test7() {\n+        ManyOops[] dst = new ManyOops[LEN];\n+        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+        return dst;\n+    }\n+\n+    static Object[] test8() {\n+        Object[] dst = new Object[LEN];\n+        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+        return dst;\n+    }\n+\n+    \/\/ Arrays.copyOf tests\n+\n+    static Object[] test9() {\n+        return Arrays.copyOf(createArrayInline(), LEN, ManyOops[].class);\n+    }\n+\n+    static Object[] test10() {\n+        return Arrays.copyOf(createArrayObject(), LEN, Object[].class);\n+    }\n+\n+    static Object[] test11() {\n+        return Arrays.copyOf(createArrayInline(), LEN, ManyOops[].class);\n+    }\n+\n+    static Object[] test12() {\n+        return Arrays.copyOf(createArrayObject(), LEN, Object[].class);\n+    }\n+\n+    \/\/ System.arraycopy test using generic_copy stub\n+\n+    static void test13(Object dst) {\n+        System.arraycopy(createObject(), 0, dst, 0, LEN);\n+    }\n+\n+    static void produceGarbage() {\n+        for (int i = 0; i < 100; ++i) {\n+            Object[] arrays = new Object[1024];\n+            for (int j = 0; j < arrays.length; j++) {\n+                arrays[i] = new int[1024];\n+            }\n+        }\n+        System.gc();\n+    }\n+\n+    public static void main(String[] args) {\n+        ManyOops[] dst1 = createArrayInline();\n+        ManyOops[] dst2 = createArrayInline();\n+        ManyOops[] dst3 = createArrayInline();\n+        ManyOops[] dst4 = createArrayInline();\n+        ManyOops[] dst13 = createArrayInline();\n+\n+        \/\/ Warmup runs to trigger compilation\n+        for (int i = 0; i < 50_000; ++i) {\n+            test1(dst1);\n+            test2(dst2);\n+            test3(dst3);\n+            test4(dst4);\n+            test5();\n+            test6();\n+            test7();\n+            test8();\n+            test9();\n+            test10();\n+            test11();\n+            test12();\n+            test13(dst13);\n+        }\n+\n+        \/\/ Trigger GC to make sure dst arrays are moved to old gen\n+        produceGarbage();\n+\n+        \/\/ Move data from flat src to flat dest\n+        test1(dst1);\n+        test2(dst2);\n+        test3(dst3);\n+        test4(dst4);\n+        Object[] dst5 = test5();\n+        Object[] dst6 = test6();\n+        Object[] dst7 = test7();\n+        Object[] dst8 = test8();\n+        Object[] dst9 = test9();\n+        Object[] dst10 = test10();\n+        Object[] dst11 = test11();\n+        Object[] dst12 = test12();\n+        test13(dst13);\n+\n+        \/\/ Trigger GC again to make sure that the now dead src arrays are collected.\n+        \/\/ MyObjects should be kept alive via oop references from the dst array.\n+        produceGarbage();\n+\n+        \/\/ Verify content\n+        long expected = 4L*Integer.MAX_VALUE;\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(dst1[i].hash(), expected);\n+            Asserts.assertEquals(dst2[i].hash(), expected);\n+            Asserts.assertEquals(dst3[i].hash(), expected);\n+            Asserts.assertEquals(dst4[i].hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst5[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst7[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst8[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst8[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst9[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst10[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst11[i]).hash(), expected);\n+            Asserts.assertEquals(((ManyOops)dst12[i]).hash(), expected);\n+            Asserts.assertEquals(dst13[i].hash(), expected);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -600,1 +600,2 @@\n-        MyValue1[] dst = new MyValue1[len];\n+        MyValue1[] dst1 = new MyValue1[len];\n+        Object[] dst2 = new Object[len];\n@@ -604,1 +605,1 @@\n-        test24(src, dst);\n+        test24(src, dst1);\n@@ -606,1 +607,5 @@\n-            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            Asserts.assertEQ(src[i].hash(), dst1[i].hash());\n+        }\n+        test24(src, dst2);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), ((MyValue1)dst2[i]).hash());\n@@ -845,2 +850,8 @@\n-        for (int i = 0; i < src.length; ++i) {\n-            Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());\n+        if (src instanceof MyInterface[] && dst instanceof MyInterface[]) {\n+            for (int i = 0; i < src.length; ++i) {\n+                Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());\n+            }\n+        } else {\n+            for (int i = 0; i < src.length; ++i) {\n+                Asserts.assertEQ(src[i], dst[i]);\n+            }\n@@ -898,1 +909,2 @@\n-        MyValue1[] dst = new MyValue1[len];\n+        MyValue1[] dst1 = new MyValue1[len];\n+        Object[] dst2 = new Object[len];\n@@ -902,2 +914,4 @@\n-        test35(src, dst, src.length);\n-        verify(src, dst);\n+        test35(src, dst1, src.length);\n+        verify(src, dst1);\n+        test35(src, dst2, src.length);\n+        verify(src, dst2);\n@@ -905,2 +919,2 @@\n-            test35(src, dst, src.length);\n-            verify(src, dst);\n+            test35(src, dst1, src.length);\n+            verify(src, dst1);\n@@ -1253,1 +1267,2 @@\n-        return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);\n+        Object[] res = Arrays.copyOf(va, va.length, MyValue1[].class);\n+        return (MyValue1[]) res;\n@@ -1272,1 +1287,2 @@\n-        return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);\n+        Object[] res = Arrays.copyOf(test52_va, 8, MyValue1[].class);\n+        return (MyValue1[]) res;\n@@ -1287,1 +1303,2 @@\n-        return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);\n+        Object[] res = Arrays.copyOf(va, va.length, MyValue1[].class);\n+        return (MyValue1[]) res;\n@@ -1336,1 +1353,2 @@\n-        return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);\n+        Object[] res = Arrays.copyOf(va, va.length, MyValue1[].class);\n+        return (MyValue1[]) res;\n@@ -1693,1 +1711,1 @@\n-        } catch (ArrayStoreException t) {\n+        } catch (ArrayStoreException e) {\n@@ -2450,0 +2468,519 @@\n+\n+    static final MyValue2[] val_src = new MyValue2[8];\n+    static final MyValue2[] val_dst = new MyValue2[8];\n+    static final Object[]   obj_src = new Object[8];\n+    static final Object[]   obj_null_src = new Object[8];\n+    static final Object[]   obj_dst = new Object[8];\n+\n+    static Object get_val_src() { return val_src; }\n+    static Object get_val_dst() { return val_dst; }\n+    static Class get_val_class() { return MyValue2[].class; }\n+    static Class get_int_class() { return Integer[].class; }\n+    static Object get_obj_src() { return obj_src; }\n+    static Object get_obj_null_src() { return obj_null_src; }\n+    static Object get_obj_dst() { return obj_dst; }\n+    static Class get_obj_class() { return Object[].class; }\n+\n+    static {\n+        for (int i = 0; i < 8; ++i) {\n+            val_src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            obj_src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            obj_null_src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        obj_null_src[0] = null;\n+    }\n+\n+    \/\/ Arraycopy with constant source and destination arrays\n+    @Test(valid = InlineTypeArrayFlattenOn, match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = INTRINSIC_SLOW_PATH)\n+    public void test102() {\n+        System.arraycopy(val_src, 0, obj_dst, 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test102_verifier(boolean warmup) {\n+        test102();\n+        verify(val_src, obj_dst);\n+    }\n+\n+    \/\/ Same as test102 but with MyValue2[] dst\n+    @Test(failOn = INTRINSIC_SLOW_PATH)\n+    public void test103() {\n+        System.arraycopy(val_src, 0, val_dst, 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test103_verifier(boolean warmup) {\n+        test103();\n+        verify(val_src, val_dst);\n+    }\n+\n+    \/\/ Same as test102 but with Object[] src\n+    @Test(failOn = INTRINSIC_SLOW_PATH)\n+    public void test104() {\n+        System.arraycopy(obj_src, 0, obj_dst, 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test104_verifier(boolean warmup) {\n+        test104();\n+        verify(obj_src, obj_dst);\n+    }\n+\n+    \/\/ Same as test103 but with Object[] src\n+    @Test(match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    public void test105() {\n+        System.arraycopy(obj_src, 0, val_dst, 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test105_verifier(boolean warmup) {\n+        test105();\n+        verify(obj_src, val_dst);\n+    }\n+\n+    \/\/ Same as test103 but with Object[] src containing null\n+    @Test(match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    public void test105_null() {\n+        System.arraycopy(obj_null_src, 0, val_dst, 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test105_null_verifier(boolean warmup) {\n+        try {\n+            test105_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Below tests are equal to test102-test105 but hide the src\/dst types until\n+    \/\/ after the arraycopy intrinsic is emitted (with incremental inlining).\n+\n+    @Test(valid = InlineTypeArrayFlattenOn, match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = INTRINSIC_SLOW_PATH)\n+    public void test106() {\n+        System.arraycopy(get_val_src(), 0, get_obj_dst(), 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test106_verifier(boolean warmup) {\n+        test106();\n+        verify(val_src, obj_dst);\n+    }\n+\n+    \/\/ TODO 8251971: Should be optimized but we are bailing out because\n+    \/\/ at parse time it looks as if src could be flat and dst could be not flat.\n+    @Test(valid = InlineTypeArrayFlattenOn)\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = INTRINSIC_SLOW_PATH)\n+    public void test107() {\n+        System.arraycopy(get_val_src(), 0, get_val_dst(), 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test107_verifier(boolean warmup) {\n+        test107();\n+        verify(val_src, val_dst);\n+    }\n+\n+    @Test(failOn = INTRINSIC_SLOW_PATH)\n+    public void test108() {\n+        System.arraycopy(get_obj_src(), 0, get_obj_dst(), 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test108_verifier(boolean warmup) {\n+        test108();\n+        verify(obj_src, obj_dst);\n+    }\n+\n+    @Test(match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    public void test109() {\n+        System.arraycopy(get_obj_src(), 0, get_val_dst(), 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test109_verifier(boolean warmup) {\n+        test109();\n+        verify(obj_src, val_dst);\n+    }\n+\n+    @Test(match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    public void test109_null() {\n+        System.arraycopy(get_obj_null_src(), 0, get_val_dst(), 0, 8);\n+    }\n+\n+    @DontCompile\n+    public void test109_null_verifier(boolean warmup) {\n+        try {\n+            test109_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Arrays.copyOf with constant source and destination arrays\n+    @Test(valid = InlineTypeArrayFlattenOn, match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP)\n+    public Object[] test110() {\n+        return Arrays.copyOf(val_src, 8, Object[].class);\n+    }\n+\n+    @DontCompile\n+    public void test110_verifier(boolean warmup) {\n+        Object[] res = test110();\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ Same as test110 but with MyValue2[] dst\n+    @Test(failOn = INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP)\n+    public Object[] test111() {\n+        return Arrays.copyOf(val_src, 8, MyValue2[].class);\n+    }\n+\n+    @DontCompile\n+    public void test111_verifier(boolean warmup) {\n+        Object[] res = test111();\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ Same as test110 but with Object[] src\n+    @Test(failOn = INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP)\n+    public Object[] test112() {\n+        return Arrays.copyOf(obj_src, 8, Object[].class);\n+    }\n+\n+    @DontCompile\n+    public void test112_verifier(boolean warmup) {\n+        Object[] res = test112();\n+        verify(obj_src, res);\n+    }\n+\n+    \/\/ Same as test111 but with Object[] src\n+    @Test(match = { INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP }, matchCount = { 1 })\n+    public Object[] test113() {\n+        return Arrays.copyOf(obj_src, 8, MyValue2[].class);\n+    }\n+\n+    @DontCompile\n+    public void test113_verifier(boolean warmup) {\n+        Object[] res = test113();\n+        verify(obj_src, res);\n+    }\n+\n+    \/\/ Same as test111 but with Object[] src containing null\n+    @Test(match = { INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP }, matchCount = { 1 })\n+    public Object[] test113_null() {\n+        return Arrays.copyOf(obj_null_src, 8, MyValue2[].class);\n+    }\n+\n+    @DontCompile\n+    public void test113_null_verifier(boolean warmup) {\n+        try {\n+            test113_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Below tests are equal to test110-test113 but hide the src\/dst types until\n+    \/\/ after the arraycopy intrinsic is emitted (with incremental inlining).\n+\n+    @Test(valid = InlineTypeArrayFlattenOn, match = { INTRINSIC_SLOW_PATH }, matchCount = { 1 })\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP)\n+    public Object[] test114() {\n+        return Arrays.copyOf((Object[])get_val_src(), 8, get_obj_class());\n+    }\n+\n+    @DontCompile\n+    public void test114_verifier(boolean warmup) {\n+        Object[] res = test114();\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ TODO 8251971: Should be optimized but we are bailing out because\n+    \/\/ at parse time it looks as if src could be flat and dst could be not flat\n+    @Test(valid = InlineTypeArrayFlattenOn)\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP)\n+    public Object[] test115() {\n+        return Arrays.copyOf((Object[])get_val_src(), 8, get_val_class());\n+    }\n+\n+    @DontCompile\n+    public void test115_verifier(boolean warmup) {\n+        Object[] res = test115();\n+        verify(val_src, res);\n+    }\n+\n+    @Test(failOn = INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP)\n+    public Object[] test116() {\n+        return Arrays.copyOf((Object[])get_obj_src(), 8, get_obj_class());\n+    }\n+\n+    @DontCompile\n+    public void test116_verifier(boolean warmup) {\n+        Object[] res = test116();\n+        verify(obj_src, res);\n+    }\n+\n+    @Test(match = { INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP }, matchCount = { 1 })\n+    public Object[] test117() {\n+        return Arrays.copyOf((Object[])get_obj_src(), 8, get_val_class());\n+    }\n+\n+    @DontCompile\n+    public void test117_verifier(boolean warmup) {\n+        Object[] res = test117();\n+        verify(obj_src, res);\n+    }\n+\n+    @Test(match = { INTRINSIC_SLOW_PATH + CLASS_CHECK_TRAP }, matchCount = { 1 })\n+    public Object[] test117_null() {\n+        return Arrays.copyOf((Object[])get_obj_null_src(), 8, get_val_class());\n+    }\n+\n+    @DontCompile\n+    public void test117_null_verifier(boolean warmup) {\n+        try {\n+            test117_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Some more Arrays.copyOf tests with only constant class\n+\n+    @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 1 }, failOn = INTRINSIC_SLOW_PATH)\n+    public Object[] test118(Object[] src) {\n+        return Arrays.copyOf(src, 8, MyValue2[].class);\n+    }\n+\n+    @DontCompile\n+    public void test118_verifier(boolean warmup) {\n+        Object[] res = test118(obj_src);\n+        verify(obj_src, res);\n+        res = test118(val_src);\n+        verify(val_src, res);\n+        try {\n+            test118(obj_null_src);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test119(Object[] src) {\n+        return Arrays.copyOf(src, 8, Object[].class);\n+    }\n+\n+    @DontCompile\n+    public void test119_verifier(boolean warmup) {\n+        Object[] res = test119(obj_src);\n+        verify(obj_src, res);\n+        res = test119(val_src);\n+        verify(val_src, res);\n+    }\n+\n+    @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 1 }, failOn = INTRINSIC_SLOW_PATH)\n+    public Object[] test120(Object[] src) {\n+        return Arrays.copyOf(src, 8, Integer[].class);\n+    }\n+\n+    @DontCompile\n+    public void test120_verifier(boolean warmup) {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test120(arr);\n+        verify(arr, res);\n+        try {\n+            test120(val_src);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public Object[] test121(Object[] src) {\n+        return Arrays.copyOf(src, 8, MyValue2[].class);\n+    }\n+\n+    @DontCompile\n+    public void test121_verifier(boolean warmup) {\n+        Object[] res = test121(obj_src);\n+        verify(obj_src, res);\n+        res = test121(val_src);\n+        verify(val_src, res);\n+        try {\n+            test121(obj_null_src);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public Object[] test122(Object[] src) {\n+        return Arrays.copyOf(src, 8, get_val_class());\n+    }\n+\n+    @DontCompile\n+    public void test122_verifier(boolean warmup) {\n+        Object[] res = test122(obj_src);\n+        verify(obj_src, res);\n+        res = test122(val_src);\n+        verify(val_src, res);\n+        try {\n+            test122(obj_null_src);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public Object[] test123(Object[] src) {\n+        return Arrays.copyOf(src, 8, Integer[].class);\n+    }\n+\n+    @DontCompile\n+    public void test123_verifier(boolean warmup) {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test123(arr);\n+        verify(arr, res);\n+        try {\n+            test123(val_src);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public Object[] test124(Object[] src) {\n+        return Arrays.copyOf(src, 8, get_int_class());\n+    }\n+\n+    @DontCompile\n+    public void test124_verifier(boolean warmup) {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test124(arr);\n+        verify(arr, res);\n+        try {\n+            test124(val_src);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public Object[] test125(Object[] src, Class klass) {\n+        return Arrays.copyOf(src, 8, klass);\n+    }\n+\n+    @DontCompile\n+    public void test125_verifier(boolean warmup) {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test125(arr, Integer[].class);\n+        verify((Object[])arr, res);\n+        res = test125(val_src, MyValue2[].class);\n+        verify(val_src, res);\n+        res = test125(obj_src, MyValue2[].class);\n+        verify(val_src, res);\n+        try {\n+            test125(obj_null_src, MyValue2[].class);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            test125(arr, MyValue2[].class);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            test125(val_src, MyValue1[].class);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Verify that clone from (flat) inline type array not containing oops is always optimized.\n+    @Test(valid = InlineTypeArrayFlattenOn, match = { JLONG_ARRAYCOPY }, matchCount = { 1 }, failOn = CHECKCAST_ARRAYCOPY + CLONE_INTRINSIC_SLOW_PATH)\n+    @Test(valid = InlineTypeArrayFlattenOff, failOn = CLONE_INTRINSIC_SLOW_PATH)\n+    public Object[] test126(MyValue2[] src) {\n+        return src.clone();\n+    }\n+\n+    @DontCompile\n+    public void test126_verifier(boolean warmup) {\n+        Object[] res = test126(val_src);\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ Verify correctness of generic_copy stub\n+    @Test\n+    public void test127(Object src, Object dst, int len) {\n+        System.arraycopy(src, 0, dst, 0, len);\n+    }\n+\n+    @DontCompile\n+    public void test127_verifier(boolean warmup) {\n+        test127(val_src, obj_dst, 8);\n+        verify(val_src, obj_dst);\n+        test127(val_src, val_dst, 8);\n+        verify(val_src, val_dst);\n+        test127(obj_src, val_dst, 8);\n+        verify(obj_src, val_dst);\n+        try {\n+            test127(obj_null_src, val_dst, 8);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Verify that copyOf with known source and unknown destination class is optimized\n+    @Test(valid = InlineTypeArrayFlattenOn, match = { JLONG_ARRAYCOPY }, matchCount = { 1 }, failOn = CHECKCAST_ARRAYCOPY)\n+    @Test(valid = InlineTypeArrayFlattenOff)\n+    public Object[] test128(MyValue2[] src, Class klass) {\n+        return Arrays.copyOf(src, 8, klass);\n+    }\n+\n+    @DontCompile\n+    public void test128_verifier(boolean warmup) {\n+        Object[] res = test128(val_src, MyValue2[].class);\n+        verify(val_src, res);\n+        res = test128(val_src, Object[].class);\n+        verify(val_src, res);\n+        try {\n+            test128(val_src, MyValue1[].class);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":552,"deletions":15,"binary":false,"changes":567,"status":"modified"}]}