{"files":[{"patch":"@@ -669,0 +669,1 @@\n+fd07cdb26fc70243ef23d688b545514f4ddf1c2b jdk-16+13\n","filename":".hgtags","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -302,0 +302,2 @@\n+  # Ignore the doclint warnings in the W3C DOM package\n+  $1_OPTIONS += -Xdoclint\/package:-org.w3c.*\n","filename":"make\/Docs.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,0 +246,1 @@\n+ALL_SYMBOLS_MODULES := $(JDK_MODULES)\n@@ -301,0 +302,1 @@\n+$(call SetupCopyDebuginfo,SYMBOLS)\n","filename":"make\/Images.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1342,1 +1342,1 @@\n-        var optString = input.build_id_data.ciBuildNumber;\n+        var ciBuildNumber = input.build_id_data.ciBuildNumber;\n@@ -1348,1 +1348,5 @@\n-                     \"--with-version-opt=\" + optString);\n+                      \"--with-version-opt=\" + ciBuildNumber);\n+        if (input.target_os == \"macosx\") {\n+            args = concat(args, \"--with-macosx-bundle-build-version=\"\n+                          + common.build_number + \".\" + ciBuildNumber);\n+        }\n","filename":"make\/conf\/jib-profiles.js","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  int _deopt_mh_handler_offset;\n@@ -81,0 +82,1 @@\n+  int deopt_mh_handler_offset() const { return _deopt_mh_handler_offset; }\n@@ -151,1 +153,5 @@\n-    _deopt_mh_handler_begin = (address) this;\n+    if (_meta->deopt_mh_handler_offset() != -1) {\n+      _deopt_mh_handler_begin = (address) _code + _meta->deopt_mh_handler_offset();\n+    } else {\n+      _deopt_mh_handler_begin = (address) this;\n+    }\n","filename":"src\/hotspot\/share\/aot\/aotCompiledMethod.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/java.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/java.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -303,1 +304,3 @@\n-    assert(_keep_alive > 0, \"Invalid keep alive increment count\");\n+    if (!Arguments::is_dumping_archive()) {\n+      assert(_keep_alive > 0, \"Invalid keep alive increment count\");\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/instanceKlass.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -117,40 +118,0 @@\n-ClassLoadInfo::ClassLoadInfo() {\n-  _protection_domain = Handle();\n-  _unsafe_anonymous_host = NULL;\n-  _cp_patches = NULL;\n-  _class_hidden_info._dynamic_nest_host = NULL;\n-  _class_hidden_info._class_data = Handle();\n-  _is_hidden = false;\n-  _is_strong_hidden = false;\n-  _can_access_vm_annotations = false;\n-}\n-\n-ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {\n-  _protection_domain = protection_domain;\n-  _unsafe_anonymous_host = NULL;\n-  _cp_patches = NULL;\n-  _class_hidden_info._dynamic_nest_host = NULL;\n-  _class_hidden_info._class_data = Handle();\n-  _is_hidden = false;\n-  _is_strong_hidden = false;\n-  _can_access_vm_annotations = false;\n-}\n-\n-ClassLoadInfo::ClassLoadInfo(Handle protection_domain,\n-                             const InstanceKlass* unsafe_anonymous_host,\n-                             GrowableArray<Handle>* cp_patches,\n-                             InstanceKlass* dynamic_nest_host,\n-                             Handle class_data,\n-                             bool is_hidden,\n-                             bool is_strong_hidden,\n-                             bool can_access_vm_annotations) {\n-  _protection_domain = protection_domain;\n-  _unsafe_anonymous_host = unsafe_anonymous_host;\n-  _cp_patches = cp_patches;\n-  _class_hidden_info._dynamic_nest_host = dynamic_nest_host;\n-  _class_hidden_info._class_data = class_data;\n-  _is_hidden = is_hidden;\n-  _is_strong_hidden = is_strong_hidden;\n-  _can_access_vm_annotations = can_access_vm_annotations;\n-}\n-\n@@ -2141,0 +2102,4 @@\n+\n+bool SystemDictionary::is_well_known_klass(Klass* k) {\n+  return is_well_known_klass(k->name());\n+}\n@@ -3045,0 +3010,13 @@\n+ClassLoaderData* SystemDictionary::class_loader_data(Handle class_loader) {\n+  return ClassLoaderData::class_loader_data(class_loader());\n+}\n+\n+bool SystemDictionary::is_wk_klass_loaded(InstanceKlass* klass) {\n+  return !(klass == NULL || !klass->is_loaded());\n+}\n+\n+bool SystemDictionary::is_nonpublic_Object_method(Method* m) {\n+  assert(m != NULL, \"Unexpected NULL Method*\");\n+  return !m->is_public() && m->method_holder() == SystemDictionary::Object_klass();\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":18,"deletions":40,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -31,4 +30,1 @@\n-#include \"oops\/symbol.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/handles.hpp\"\n@@ -36,48 +32,0 @@\n-#include \"utilities\/hashtable.hpp\"\n-\n-class ClassInstanceInfo : public StackObj {\n- private:\n-  InstanceKlass* _dynamic_nest_host;\n-  Handle _class_data;\n-\n- public:\n-  ClassInstanceInfo() {\n-    _dynamic_nest_host = NULL;\n-    _class_data = Handle();\n-  }\n-  ClassInstanceInfo(InstanceKlass* dynamic_nest_host, Handle class_data) {\n-    _dynamic_nest_host = dynamic_nest_host;\n-    _class_data = class_data;\n-  }\n-\n-  InstanceKlass* dynamic_nest_host() const { return _dynamic_nest_host; }\n-  Handle class_data() const { return _class_data; }\n-  friend class ClassLoadInfo;\n-};\n-\n-class ClassLoadInfo : public StackObj {\n- private:\n-  Handle                 _protection_domain;\n-  const InstanceKlass*   _unsafe_anonymous_host;\n-  GrowableArray<Handle>* _cp_patches;\n-  ClassInstanceInfo      _class_hidden_info;\n-  bool                   _is_hidden;\n-  bool                   _is_strong_hidden;\n-  bool                   _can_access_vm_annotations;\n-\n- public:\n-  ClassLoadInfo();\n-  ClassLoadInfo(Handle protection_domain);\n-  ClassLoadInfo(Handle protection_domain, const InstanceKlass* unsafe_anonymous_host,\n-                GrowableArray<Handle>* cp_patches, InstanceKlass* dynamic_nest_host,\n-                Handle class_data, bool is_hidden, bool is_strong_hidden,\n-                bool can_access_vm_annotations);\n-\n-  Handle protection_domain()             const { return _protection_domain; }\n-  const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }\n-  GrowableArray<Handle>* cp_patches()    const { return _cp_patches; }\n-  const ClassInstanceInfo* class_hidden_info_ptr() const { return &_class_hidden_info; }\n-  bool is_hidden()                       const { return _is_hidden; }\n-  bool is_strong_hidden()                const { return _is_strong_hidden; }\n-  bool can_access_vm_annotations()       const { return _can_access_vm_annotations; }\n-};\n@@ -126,0 +74,1 @@\n+class ClassLoadInfo;\n@@ -133,0 +82,1 @@\n+class PackageEntry;\n@@ -137,0 +87,2 @@\n+class Symbol;\n+class TableStatistics;\n@@ -459,3 +411,1 @@\n-  static bool is_well_known_klass(Klass* k) {\n-    return is_well_known_klass(k->name());\n-  }\n+  static bool is_well_known_klass(Klass* k);\n@@ -468,7 +418,2 @@\n-  static ClassLoaderData *class_loader_data(Handle class_loader) {\n-    return ClassLoaderData::class_loader_data(class_loader());\n-  }\n-\n-  static bool is_wk_klass_loaded(InstanceKlass* klass) {\n-    return !(klass == NULL || !klass->is_loaded());\n-  }\n+  static ClassLoaderData *class_loader_data(Handle class_loader);\n+  static bool is_wk_klass_loaded(InstanceKlass* klass);\n@@ -684,4 +629,1 @@\n-  static bool is_nonpublic_Object_method(Method* m) {\n-    assert(m != NULL, \"Unexpected NULL Method*\");\n-    return !m->is_public() && m->method_holder() == SystemDictionary::Object_klass();\n-  }\n+  static bool is_nonpublic_Object_method(Method* m);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":10,"deletions":68,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/java.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1149,10 +1149,0 @@\n-#ifdef ASSERT\n-      if( VerifyOptoOopOffsets ) {\n-        MemNode* mem  = n->as_Mem();\n-        \/\/ Check to see if address types have grounded out somehow.\n-        const TypeInstPtr *tp = mem->in(MemNode::Address)->bottom_type()->isa_instptr();\n-        ciInstanceKlass *k = tp->klass()->as_instance_klass();\n-        bool oop_offset_is_sane = k->contains_field_offset(tp->offset());\n-        assert( !tp || oop_offset_is_sane, \"\" );\n-      }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1391,0 +1391,4 @@\n+      case VERIFY_OOPS:\n+      case VERIFY_OOP_BITS:\n+      case VERIFY_OOP_MASK:\n+      case VERIFY_OOP_COUNT_ADDRESS:\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,0 +475,4 @@\n+  declare_constant(CodeInstaller::VERIFY_OOP_COUNT_ADDRESS)               \\\n+  declare_constant(CodeInstaller::VERIFY_OOPS)                            \\\n+  declare_constant(CodeInstaller::VERIFY_OOP_BITS)                        \\\n+  declare_constant(CodeInstaller::VERIFY_OOP_MASK)                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -483,1 +483,1 @@\n-  NEW_C_HEAP_ARRAY3(type, (size), memflags, CURRENT_PC, AllocFailStrategy::RETURN_NULL)\n+  NEW_C_HEAP_ARRAY2(type, (size), memflags, AllocFailStrategy::RETURN_NULL)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,0 +160,4 @@\n+  for (int i = 0; i < _symbols->length(); i++) {\n+    _symbols->at(i)->decrement_refcount();\n+  }\n+\n@@ -200,1 +204,4 @@\n-    _symbols->append((Symbol*)ref->obj());\n+    \/\/ Make sure the symbol won't be GC'ed while we are dumping the archive.\n+    Symbol* sym = (Symbol*)ref->obj();\n+    sym->increment_refcount();\n+    _symbols->append(sym);\n@@ -277,3 +284,7 @@\n-  int num_symbols = _symbols->length();\n-  for (i = 0; i < num_symbols; i++) {\n-    it->push(&_symbols->at(i));\n+  if (!is_relocating_pointers) {\n+    \/\/ Don't relocate _symbol, so we can safely call decrement_refcount on the\n+    \/\/ original symbols.\n+    int num_symbols = _symbols->length();\n+    for (i = 0; i < num_symbols; i++) {\n+      it->push(&_symbols->at(i));\n+    }\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -37,1 +38,0 @@\n-class DumpRegion;\n@@ -240,0 +240,4 @@\n+  static Symbol* get_relocated_symbol(Symbol* orig_symbol) {\n+    return (Symbol*)singleton()->get_dumped_addr((address)orig_symbol);\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-      SymbolTable::write_to_archive(false);\n+      SymbolTable::write_to_archive(symbols());\n@@ -273,1 +273,0 @@\n-      SymbolTable::metaspace_pointers_do(it);\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/reflectionUtils.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -371,1 +372,2 @@\n-static GrowableArrayCHeap<Handle, mtClassShared>* _extra_interned_strings = NULL;\n+static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = NULL;\n+static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = NULL;\n@@ -374,1 +376,2 @@\n-  _extra_interned_strings = new GrowableArrayCHeap<Handle, mtClassShared>(10000);\n+  _extra_interned_strings = new GrowableArrayCHeap<OopHandle, mtClassShared>(10000);\n+  _extra_symbols = new GrowableArrayCHeap<Symbol*, mtClassShared>(1000);\n@@ -393,1 +396,1 @@\n-      SymbolTable::new_permanent_symbol(utf8_buffer);\n+      _extra_symbols->append(SymbolTable::new_permanent_symbol(utf8_buffer));\n@@ -396,1 +399,1 @@\n-      oop s = StringTable::intern(utf8_buffer, THREAD);\n+      oop str = StringTable::intern(utf8_buffer, THREAD);\n@@ -405,1 +408,1 @@\n-          typeArrayOop body = java_lang_String::value(s);\n+          typeArrayOop body = java_lang_String::value(str);\n@@ -416,5 +419,3 @@\n-        \/\/ Interned strings are GC'ed if there are no references to it, so let's\n-        \/\/ add a reference to keep this string alive.\n-        assert(s != NULL, \"must succeed\");\n-        Handle h(THREAD, s);\n-        _extra_interned_strings->append(h);\n+        \/\/ Make sure this string is included in the dumped interned string table.\n+        assert(str != NULL, \"must succeed\");\n+        _extra_interned_strings->append(OopHandle(Universe::vm_global(), str));\n@@ -916,1 +917,4 @@\n-  void dump_symbols();\n+  void dump_shared_symbol_table(GrowableArray<Symbol*>* symbols) {\n+    log_info(cds)(\"Dumping symbol table ...\");\n+    SymbolTable::write_to_archive(symbols);\n+  }\n@@ -940,1 +944,11 @@\n-    SymbolTable::metaspace_pointers_do(it);\n+\n+    \/\/ The above code should find all the symbols that are referenced by the\n+    \/\/ archived classes. We just need to add the extra symbols which\n+    \/\/ may not be used by any of the archived classes -- these are usually\n+    \/\/ symbols that we anticipate to be used at run time, so we can store\n+    \/\/ them in the RO region, to be shared across multiple processes.\n+    if (_extra_symbols != NULL) {\n+      for (int i = 0; i < _extra_symbols->length(); i++) {\n+        it->push(_extra_symbols->adr_at(i));\n+      }\n+    }\n@@ -945,7 +959,0 @@\n-void VM_PopulateDumpSharedSpace::dump_symbols() {\n-  log_info(cds)(\"Dumping symbol table ...\");\n-\n-  NOT_PRODUCT(SymbolTable::verify());\n-  SymbolTable::write_to_archive();\n-}\n-\n@@ -1076,1 +1083,1 @@\n-  dump_symbols();\n+  dump_shared_symbol_table(builder.symbols());\n@@ -1225,5 +1232,13 @@\n-class LinkSharedClassesClosure : public KlassClosure {\n-  Thread* THREAD;\n-  bool    _made_progress;\n- public:\n-  LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}\n+static GrowableArray<ClassLoaderData*>* _loaded_cld = NULL;\n+\n+class CollectCLDClosure : public CLDClosure {\n+  void do_cld(ClassLoaderData* cld) {\n+    if (_loaded_cld == NULL) {\n+      _loaded_cld = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<ClassLoaderData*>(10, mtClassShared);\n+    }\n+    if (!cld->is_unloading()) {\n+      cld->inc_keep_alive();\n+      _loaded_cld->append(cld);\n+    }\n+  }\n+};\n@@ -1231,2 +1246,4 @@\n-  void reset()               { _made_progress = false; }\n-  bool made_progress() const { return _made_progress; }\n+bool MetaspaceShared::linking_required(InstanceKlass* ik) {\n+  \/\/ For dynamic CDS dump, only link classes loaded by the builtin class loaders.\n+  return DumpSharedSpaces ? true : !ik->is_shared_unregistered_class();\n+}\n@@ -1234,11 +1251,6 @@\n-  void do_klass(Klass* k) {\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      \/\/ For dynamic CDS dump, only link classes loaded by the builtin class loaders.\n-      bool do_linking = DumpSharedSpaces ? true : !ik->is_shared_unregistered_class();\n-      if (do_linking) {\n-        \/\/ Link the class to cause the bytecodes to be rewritten and the\n-        \/\/ cpcache to be created. Class verification is done according\n-        \/\/ to -Xverify setting.\n-        _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);\n-        guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n+bool MetaspaceShared::link_class_for_cds(InstanceKlass* ik, TRAPS) {\n+  \/\/ Link the class to cause the bytecodes to be rewritten and the\n+  \/\/ cpcache to be created. Class verification is done according\n+  \/\/ to -Xverify setting.\n+  bool res = MetaspaceShared::try_link_class(ik, THREAD);\n+  guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n@@ -1246,5 +1258,27 @@\n-        if (DumpSharedSpaces) {\n-          \/\/ The following function is used to resolve all Strings in the statically\n-          \/\/ dumped classes to archive all the Strings. The archive heap is not supported\n-          \/\/ for the dynamic archive.\n-          ik->constants()->resolve_class_constants(THREAD);\n+  if (DumpSharedSpaces) {\n+    \/\/ The following function is used to resolve all Strings in the statically\n+    \/\/ dumped classes to archive all the Strings. The archive heap is not supported\n+    \/\/ for the dynamic archive.\n+    ik->constants()->resolve_class_constants(THREAD);\n+  }\n+  return res;\n+}\n+\n+void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {\n+  \/\/ Collect all loaded ClassLoaderData.\n+  CollectCLDClosure collect_cld;\n+  {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_cld);\n+  }\n+\n+  while (true) {\n+    bool has_linked = false;\n+    for (int i = 0; i < _loaded_cld->length(); i++) {\n+      ClassLoaderData* cld = _loaded_cld->at(i);\n+      for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+        if (klass->is_instance_klass()) {\n+          InstanceKlass* ik = InstanceKlass::cast(klass);\n+          if (linking_required(ik)) {\n+            has_linked |= link_class_for_cds(ik, THREAD);\n+          }\n@@ -1254,0 +1288,6 @@\n+\n+    if (!has_linked) {\n+      break;\n+    }\n+    \/\/ Class linking includes verification which may load more classes.\n+    \/\/ Keep scanning until we have linked no more classes.\n@@ -1255,10 +1295,4 @@\n-};\n-void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {\n-  \/\/ We need to iterate because verification may cause additional classes\n-  \/\/ to be loaded.\n-  LinkSharedClassesClosure link_closure(THREAD);\n-  do {\n-    link_closure.reset();\n-    ClassLoaderDataGraph::unlocked_loaded_classes_do(&link_closure);\n-    guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n-  } while (link_closure.made_progress());\n+  for (int i = 0; i < _loaded_cld->length(); i++) {\n+    ClassLoaderData* cld = _loaded_cld->at(i);\n+    cld->dec_keep_alive();\n+  }\n@@ -1327,1 +1361,1 @@\n-    HeapShared::init_subgraph_entry_fields(THREAD);\n+    HeapShared::init_for_dumping(THREAD);\n@@ -1388,1 +1422,1 @@\n-  if (ik->init_state() < InstanceKlass::linked &&\n+  if (ik->is_loaded() && !ik->is_linked() &&\n@@ -1419,0 +1453,16 @@\n+  \/\/ Find all the interned strings that should be dumped.\n+  int i;\n+  for (i = 0; i < _global_klass_objects->length(); i++) {\n+    Klass* k = _global_klass_objects->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      ik->constants()->add_dumped_interned_strings();\n+    }\n+  }\n+  if (_extra_interned_strings != NULL) {\n+    for (i = 0; i < _extra_interned_strings->length(); i ++) {\n+      OopHandle string = _extra_interned_strings->at(i);\n+      HeapShared::add_to_dumped_interned_strings(string.resolve());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":105,"deletions":55,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-      oop p = rr->obj_at(i);\n+      oop obj = rr->obj_at(i);\n@@ -301,1 +301,1 @@\n-      if (p != NULL && i < ref_map_len) {\n+      if (obj != NULL && i < ref_map_len) {\n@@ -304,6 +304,7 @@\n-          oop op = StringTable::create_archived_string(p, THREAD);\n-          \/\/ If the String object is not archived (possibly too large),\n-          \/\/ NULL is returned. Also set it in the array, so we won't\n-          \/\/ have a 'bad' reference in the archived resolved_reference\n-          \/\/ array.\n-          rr->obj_at_put(i, op);\n+          oop archived_string = HeapShared::find_archived_heap_object(obj);\n+          \/\/ Update the reference to point to the archived copy\n+          \/\/ of this string.\n+          \/\/ If the string is too large to archive, NULL is\n+          \/\/ stored into rr. At run time, string_at_impl() will create and intern\n+          \/\/ the string.\n+          rr->obj_at_put(i, archived_string);\n@@ -341,0 +342,13 @@\n+\n+void ConstantPool::add_dumped_interned_strings() {\n+  objArrayOop rr = resolved_references();\n+  if (rr != NULL) {\n+    int rr_len = rr->length();\n+    for (int i = 0; i < rr_len; i++) {\n+      oop p = rr->obj_at(i);\n+      if (java_lang_String::is_instance(p)) {\n+        HeapShared::add_to_dumped_interned_strings(p);\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -752,0 +752,1 @@\n+  void add_dumped_interned_strings() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -80,0 +81,1 @@\n+#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"oops\/compressedOops.hpp\"\n@@ -32,1 +31,0 @@\n-#include \"oops\/oopHandle.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-class ScanClosure;\n-class FastScanClosure;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,3 +115,0 @@\n-  notproduct(bool, VerifyOptoOopOffsets, false,                             \\\n-          \"Check types of base addresses in field references\")              \\\n-                                                                            \\\n@@ -768,0 +765,1 @@\n+          constraint(LoopStripMiningIterConstraintFunc, AfterErgo)          \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,10 +66,0 @@\n-  \/\/ Check that runtime and architecture description agree on callee-saved-floats\n-  bool callee_saved_floats = false;\n-  for( OptoReg::Name i=OptoReg::Name(0); i<OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {\n-    \/\/ Is there a callee-saved float or double?\n-    if( register_save_policy[i] == 'E' \/* callee-saved *\/ &&\n-       (register_save_type[i] == Op_RegF || register_save_type[i] == Op_RegD) ) {\n-      callee_saved_floats = true;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -912,1 +912,1 @@\n-        if (cn->is_Catch()) {\n+        if (cn != NULL && cn->is_Catch()) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3140,9 +3140,0 @@\n-#ifdef ASSERT\n-static bool oop_offset_is_sane(const TypeInstPtr* tp) {\n-  ciInstanceKlass *k = tp->klass()->as_instance_klass();\n-  \/\/ Make sure the offset goes inside the instance layout.\n-  return k->contains_field_offset(tp->offset());\n-  \/\/ Note that OffsetBot and OffsetTop are very negative.\n-}\n-#endif\n-\n@@ -3272,0 +3263,2 @@\n+  case Op_StoreF:\n+  case Op_LoadF:\n@@ -3296,0 +3289,3 @@\n+  case Op_StoreD:\n+  case Op_LoadD:\n+  case Op_LoadD_unaligned:\n@@ -3337,10 +3333,0 @@\n-  case Op_StoreD:\n-  case Op_LoadD:\n-  case Op_LoadD_unaligned:\n-    frc.inc_double_count();\n-    goto handle_mem;\n-  case Op_StoreF:\n-  case Op_LoadF:\n-    frc.inc_float_count();\n-    goto handle_mem;\n-\n@@ -3408,10 +3394,1 @@\n-  case Op_LoadS: {\n-  handle_mem:\n-#ifdef ASSERT\n-    if( VerifyOptoOopOffsets ) {\n-      MemNode* mem  = n->as_Mem();\n-      \/\/ Check to see if address types have grounded out somehow.\n-      const TypeInstPtr *tp = mem->in(MemNode::Address)->bottom_type()->isa_instptr();\n-      assert( !tp || oop_offset_is_sane(tp), \"\" );\n-    }\n-#endif\n+  case Op_LoadS:\n@@ -3419,1 +3396,0 @@\n-  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1447,0 +1447,4 @@\n+#ifdef ASSERT\n+  void dump_real_LCA(Node* early, Node* wrong_lca);\n+  bool check_idom_chains_intersection(const Node* n, uint& idom_idx_new, uint& idom_idx_other, const Node_List* nodes_seen) const;\n+#endif\n@@ -1459,0 +1463,1 @@\n+  void dump_idom(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1605,1 +1605,4 @@\n-            if (!x->is_Load() && !x->is_DecodeNarrowPtr()) _igvn._worklist.yank(x);\n+            BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+            if (!x->is_Load() && !x->is_DecodeNarrowPtr() && !x->is_AddP() && !bs->is_gc_barrier_node(x)) {\n+              _igvn._worklist.yank(x);\n+            }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -508,0 +508,1 @@\n+    HeapWord* base = g1h->reserved().start();\n@@ -510,1 +511,1 @@\n-      return (jlong)(g1h->base() + start_region * HeapRegion::GrainBytes);\n+      return (jlong)(base + start_region * HeapRegion::GrainBytes);\n@@ -512,1 +513,1 @@\n-      return (jlong)g1h->base();\n+      return (jlong)base;\n@@ -534,0 +535,1 @@\n+    HeapWord* base = g1h->reserved().start();\n@@ -536,1 +538,1 @@\n-      return (jlong)(g1h->base() + (end_region + 1) * HeapRegion::GrainBytes - 1);\n+      return (jlong)(base + (end_region + 1) * HeapRegion::GrainBytes - 1);\n@@ -538,1 +540,1 @@\n-      return (jlong)g1h->base() + G1Arguments::heap_max_size_bytes();\n+      return (jlong)base + G1Arguments::heap_max_size_bytes();\n@@ -562,1 +564,1 @@\n-      return (jlong)(g1h->base() + start_region * HeapRegion::GrainBytes);\n+      return (jlong)(g1h->reserved().start() + start_region * HeapRegion::GrainBytes);\n@@ -588,1 +590,1 @@\n-      return (jlong)(g1h->base() + (end_region + 1) * HeapRegion::GrainBytes - 1);\n+      return (jlong)(g1h->reserved().start() + (end_region + 1) * HeapRegion::GrainBytes - 1);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/fieldDescriptor.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-  if (thread->is_ext_suspended() || thread->is_terminated()) {\n+  if (thread->is_terminated()) {\n@@ -894,26 +894,0 @@\n-  \/\/ Check for a thread that is suspended. Note that thread resume tries\n-  \/\/ to grab the Threads_lock which we own here, so a thread cannot be\n-  \/\/ resumed during safepoint synchronization.\n-\n-  \/\/ We check to see if this thread is suspended without locking to\n-  \/\/ avoid deadlocking with a third thread that is waiting for this\n-  \/\/ thread to be suspended. The third thread can notice the safepoint\n-  \/\/ that we're trying to start at the beginning of its SR_lock->wait()\n-  \/\/ call. If that happens, then the third thread will block on the\n-  \/\/ safepoint while still holding the underlying SR_lock. We won't be\n-  \/\/ able to get the SR_lock and we'll deadlock.\n-  \/\/\n-  \/\/ We don't need to grab the SR_lock here for two reasons:\n-  \/\/ 1) The suspend flags are both volatile and are set with an\n-  \/\/    Atomic::cmpxchg() call so we should see the suspended\n-  \/\/    state right away.\n-  \/\/ 2) We're being called from the safepoint polling loop; if\n-  \/\/    we don't see the suspended state on this iteration, then\n-  \/\/    we'll come around again.\n-  \/\/\n-  bool is_suspended = _thread->is_ext_suspended();\n-  if (is_suspended) {\n-    account_safe_thread();\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -314,0 +314,6 @@\n+Symbol* Signature::strip_envelope(const Symbol* signature) {\n+  assert(has_envelope(signature), \"precondition\");\n+  return SymbolTable::new_symbol((char*) signature->bytes() + 1,\n+                                 signature->utf8_length() - 2);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,5 +134,1 @@\n-  static Symbol* strip_envelope(const Symbol* signature) {\n-    assert(has_envelope(signature), \"precondition\");\n-    return SymbolTable::new_symbol((char*) signature->bytes() + 1,\n-                                   signature->utf8_length() - 2);\n-  }\n+  static Symbol* strip_envelope(const Symbol* signature);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3784,3 +3784,2 @@\n-     * A pure LoadLoad fence is not provided, since the addition of LoadStore\n-     * is almost always desired, and most current hardware instructions that\n-     * provide a LoadLoad barrier also provide a LoadStore barrier for free.\n+     * Provides a LoadLoad barrier followed by a LoadStore barrier.\n+     *\n@@ -3799,3 +3798,3 @@\n-     * A pure StoreStore fence is not provided, since the addition of LoadStore\n-     * is almost always desired, and most current hardware instructions that\n-     * provide a StoreStore barrier also provide a LoadStore barrier for free.\n+     * Provides a StoreStore barrier followed by a LoadStore barrier.\n+     *\n+     *\n@@ -3822,0 +3821,5 @@\n+     *\n+     * @implNote\n+     * This method is operationally equivalent to {@link #loadFence()}.\n+     *\n+     * @since 9\n@@ -3830,0 +3834,5 @@\n+     *\n+     * @implNote\n+     * This method is operationally equivalent to {@link #storeFence()}.\n+     *\n+     * @since 9\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -4070,1 +4070,1 @@\n-            ((c.flags() & PUBLIC) != 0) &&\n+            ((c.flags() & (PUBLIC | PROTECTED)) != 0) &&\n@@ -4079,1 +4079,1 @@\n-                    \/\/ classes must be public.\n+                    \/\/ classes must be public or protected.\n@@ -4082,1 +4082,1 @@\n-                        if ((owner.flags() & PUBLIC) == 0)\n+                        if ((owner.flags() & (PUBLIC | PROTECTED)) == 0)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2267,0 +2267,1 @@\n+        validateMethodType(name, type);\n@@ -2294,0 +2295,1 @@\n+        validateMethodType(name, m.type);\n@@ -2307,0 +2309,7 @@\n+    void validateMethodType(Name name, Type t) {\n+        if ((!t.hasTag(TypeTag.METHOD) && !t.hasTag(TypeTag.FORALL)) ||\n+            (name == names.init && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            throw badClassFile(\"method.descriptor.invalid\", name);\n+        }\n+    }\n+\n@@ -2535,0 +2544,3 @@\n+            if (c.owner.kind != MDL) {\n+                throw badClassFile(\"module.info.definition.expected\");\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-        if (token.pos == errorPos) {\n+        if (token.pos == errorPos && token.kind != EOF) {\n@@ -4183,0 +4183,2 @@\n+            else\n+                return List.nil();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2289,0 +2289,3 @@\n+compiler.misc.unexpected.const.pool.tag.at=\\\n+    unexpected constant pool tag: {0} at {1}\n+\n@@ -2332,0 +2335,3 @@\n+compiler.misc.module.info.definition.expected=\\\n+    module-info definition expected\n+\n@@ -2346,0 +2352,4 @@\n+# 0: name\n+compiler.misc.method.descriptor.invalid=\\\n+    method descriptor invalid for {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    Warn about missing explicit constructors in public classes in exported packages.\n+    Warn about missing explicit constructors in public and protected classes in exported packages.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,5 +396,0 @@\n-        if (WB.getBooleanVMFlag(\"VerifyOops\")) {\n-            \/\/ Should be enabled when JDK-8209961 is fixed\n-            return \"false\";\n-        }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+compiler.misc.unexpected.const.pool.tag.at              # bad class file\n@@ -79,0 +80,2 @@\n+compiler.misc.method.descriptor.invalid                 # bad class file\n+compiler.misc.module.info.definition.expected           # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}