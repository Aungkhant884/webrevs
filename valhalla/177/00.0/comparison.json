{"files":[{"patch":"@@ -668,0 +668,1 @@\n+fc8e62b399bd93d06e8d13dc3b384c450e853dcd jdk-16+12\n","filename":".hgtags","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3203,1 +3203,1 @@\n-          uintptr_t offset;\n+          uint64_t offset;\n@@ -3555,0 +3555,7 @@\n+    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+      __ load_klass(tmp, oop);\n+      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+      __ tstw(tmp, JVM_ACC_IS_BOX_CLASS);\n+      __ br(Assembler::NE, cont);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -78,0 +78,9 @@\n+  null_check_offset = offset();\n+\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    load_klass(hdr, obj);\n+    ldrw(hdr, Address(hdr, Klass::access_flags_offset()));\n+    tstw(hdr, JVM_ACC_IS_BOX_CLASS);\n+    br(Assembler::NE, slow_case);\n+  }\n+\n@@ -80,3 +89,1 @@\n-    null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n-  } else {\n-    null_check_offset = offset();\n+    biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -757,0 +757,7 @@\n+    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+      load_klass(tmp, obj_reg);\n+      ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+      tstw(tmp, JVM_ACC_IS_BOX_CLASS);\n+      br(Assembler::NE, slow_case);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-    uintptr_t offset;\n+    uint64_t offset;\n@@ -411,1 +411,1 @@\n-    uintptr_t offset;\n+    uint64_t offset;\n@@ -448,8 +448,8 @@\n-int MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                         Register obj_reg,\n-                                         Register swap_reg,\n-                                         Register tmp_reg,\n-                                         bool swap_reg_contains_mark,\n-                                         Label& done,\n-                                         Label* slow_case,\n-                                         BiasedLockingCounters* counters) {\n+void MacroAssembler::biased_locking_enter(Register lock_reg,\n+                                          Register obj_reg,\n+                                          Register swap_reg,\n+                                          Register tmp_reg,\n+                                          bool swap_reg_contains_mark,\n+                                          Label& done,\n+                                          Label* slow_case,\n+                                          BiasedLockingCounters* counters) {\n@@ -475,2 +475,0 @@\n-  int null_check_offset = -1;\n-    null_check_offset = offset();\n@@ -605,2 +603,0 @@\n-\n-  return null_check_offset;\n@@ -1552,1 +1548,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n@@ -2632,1 +2628,1 @@\n-      tty->print_cr(\" pc = 0x%016lx\", pc);\n+      tty->print_cr(\" pc = 0x%016\" PRIx64, pc);\n@@ -2638,31 +2634,31 @@\n-      tty->print_cr(\" r0 = 0x%016lx\", regs[0]);\n-      tty->print_cr(\" r1 = 0x%016lx\", regs[1]);\n-      tty->print_cr(\" r2 = 0x%016lx\", regs[2]);\n-      tty->print_cr(\" r3 = 0x%016lx\", regs[3]);\n-      tty->print_cr(\" r4 = 0x%016lx\", regs[4]);\n-      tty->print_cr(\" r5 = 0x%016lx\", regs[5]);\n-      tty->print_cr(\" r6 = 0x%016lx\", regs[6]);\n-      tty->print_cr(\" r7 = 0x%016lx\", regs[7]);\n-      tty->print_cr(\" r8 = 0x%016lx\", regs[8]);\n-      tty->print_cr(\" r9 = 0x%016lx\", regs[9]);\n-      tty->print_cr(\"r10 = 0x%016lx\", regs[10]);\n-      tty->print_cr(\"r11 = 0x%016lx\", regs[11]);\n-      tty->print_cr(\"r12 = 0x%016lx\", regs[12]);\n-      tty->print_cr(\"r13 = 0x%016lx\", regs[13]);\n-      tty->print_cr(\"r14 = 0x%016lx\", regs[14]);\n-      tty->print_cr(\"r15 = 0x%016lx\", regs[15]);\n-      tty->print_cr(\"r16 = 0x%016lx\", regs[16]);\n-      tty->print_cr(\"r17 = 0x%016lx\", regs[17]);\n-      tty->print_cr(\"r18 = 0x%016lx\", regs[18]);\n-      tty->print_cr(\"r19 = 0x%016lx\", regs[19]);\n-      tty->print_cr(\"r20 = 0x%016lx\", regs[20]);\n-      tty->print_cr(\"r21 = 0x%016lx\", regs[21]);\n-      tty->print_cr(\"r22 = 0x%016lx\", regs[22]);\n-      tty->print_cr(\"r23 = 0x%016lx\", regs[23]);\n-      tty->print_cr(\"r24 = 0x%016lx\", regs[24]);\n-      tty->print_cr(\"r25 = 0x%016lx\", regs[25]);\n-      tty->print_cr(\"r26 = 0x%016lx\", regs[26]);\n-      tty->print_cr(\"r27 = 0x%016lx\", regs[27]);\n-      tty->print_cr(\"r28 = 0x%016lx\", regs[28]);\n-      tty->print_cr(\"r30 = 0x%016lx\", regs[30]);\n-      tty->print_cr(\"r31 = 0x%016lx\", regs[31]);\n+      tty->print_cr(\" r0 = 0x%016\" PRIx64, regs[0]);\n+      tty->print_cr(\" r1 = 0x%016\" PRIx64, regs[1]);\n+      tty->print_cr(\" r2 = 0x%016\" PRIx64, regs[2]);\n+      tty->print_cr(\" r3 = 0x%016\" PRIx64, regs[3]);\n+      tty->print_cr(\" r4 = 0x%016\" PRIx64, regs[4]);\n+      tty->print_cr(\" r5 = 0x%016\" PRIx64, regs[5]);\n+      tty->print_cr(\" r6 = 0x%016\" PRIx64, regs[6]);\n+      tty->print_cr(\" r7 = 0x%016\" PRIx64, regs[7]);\n+      tty->print_cr(\" r8 = 0x%016\" PRIx64, regs[8]);\n+      tty->print_cr(\" r9 = 0x%016\" PRIx64, regs[9]);\n+      tty->print_cr(\"r10 = 0x%016\" PRIx64, regs[10]);\n+      tty->print_cr(\"r11 = 0x%016\" PRIx64, regs[11]);\n+      tty->print_cr(\"r12 = 0x%016\" PRIx64, regs[12]);\n+      tty->print_cr(\"r13 = 0x%016\" PRIx64, regs[13]);\n+      tty->print_cr(\"r14 = 0x%016\" PRIx64, regs[14]);\n+      tty->print_cr(\"r15 = 0x%016\" PRIx64, regs[15]);\n+      tty->print_cr(\"r16 = 0x%016\" PRIx64, regs[16]);\n+      tty->print_cr(\"r17 = 0x%016\" PRIx64, regs[17]);\n+      tty->print_cr(\"r18 = 0x%016\" PRIx64, regs[18]);\n+      tty->print_cr(\"r19 = 0x%016\" PRIx64, regs[19]);\n+      tty->print_cr(\"r20 = 0x%016\" PRIx64, regs[20]);\n+      tty->print_cr(\"r21 = 0x%016\" PRIx64, regs[21]);\n+      tty->print_cr(\"r22 = 0x%016\" PRIx64, regs[22]);\n+      tty->print_cr(\"r23 = 0x%016\" PRIx64, regs[23]);\n+      tty->print_cr(\"r24 = 0x%016\" PRIx64, regs[24]);\n+      tty->print_cr(\"r25 = 0x%016\" PRIx64, regs[25]);\n+      tty->print_cr(\"r26 = 0x%016\" PRIx64, regs[26]);\n+      tty->print_cr(\"r27 = 0x%016\" PRIx64, regs[27]);\n+      tty->print_cr(\"r28 = 0x%016\" PRIx64, regs[28]);\n+      tty->print_cr(\"r30 = 0x%016\" PRIx64, regs[30]);\n+      tty->print_cr(\"r31 = 0x%016\" PRIx64, regs[31]);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":43,"deletions":47,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -119,9 +119,5 @@\n-  \/\/ Returns offset of first potentially-faulting instruction for null\n-  \/\/ check info (currently consumed only by C1). If\n-  \/\/ swap_reg_contains_mark is true then returns -1 as it is assumed\n-  \/\/ the calling code has already passed any potential faults.\n-  int biased_locking_enter(Register lock_reg, Register obj_reg,\n-                           Register swap_reg, Register tmp_reg,\n-                           bool swap_reg_contains_mark,\n-                           Label& done, Label* slow_case = NULL,\n-                           BiasedLockingCounters* counters = NULL);\n+  void biased_locking_enter(Register lock_reg, Register obj_reg,\n+                            Register swap_reg, Register tmp_reg,\n+                            bool swap_reg_contains_mark,\n+                            Label& done, Label* slow_case = NULL,\n+                            BiasedLockingCounters* counters = NULL);\n@@ -501,4 +497,1 @@\n-  inline void mov(Register dst, address addr)\n-  {\n-    mov_immediate64(dst, (uint64_t)addr);\n-  }\n+  inline void mov(Register dst, address addr)             { mov_immediate64(dst, (uint64_t)addr); }\n@@ -506,4 +499,6 @@\n-  inline void mov(Register dst, uint64_t imm64)\n-  {\n-    mov_immediate64(dst, imm64);\n-  }\n+  inline void mov(Register dst, int imm64)                { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, long imm64)               { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, long long imm64)          { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, unsigned int imm64)       { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, unsigned long imm64)      { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, unsigned long long imm64) { mov_immediate64(dst, (uint64_t)imm64); }\n@@ -516,10 +511,0 @@\n-  inline void mov(Register dst, int64_t l)\n-  {\n-    mov(dst, (uint64_t)l);\n-  }\n-\n-  inline void mov(Register dst, int i)\n-  {\n-    mov(dst, (int64_t)i);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -90,2 +90,3 @@\n-          \"CPU Version: x for PowerX. Currently recognizes Power5 to \"      \\\n-          \"Power8. Default is 0. Newer CPUs will be recognized as Power8.\") \\\n+          \"Specify the PowerPC family version in use. If not provided, \"    \\\n+          \"HotSpot will determine it automatically. Host family version \"   \\\n+          \"is the maximum value allowed (instructions are not emulated).\")  \\\n@@ -118,0 +119,3 @@\n+  product(bool, UseByteReverseInstructions, false,                          \\\n+          \"Use byte reverse instructions.\")                                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -913,0 +913,7 @@\n+    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+      load_klass(tmp, object);\n+      lwz(tmp, in_bytes(Klass::access_flags_offset()), tmp);\n+      testbitdi(CCR0, R0, tmp, exact_log2(JVM_ACC_IS_BOX_CLASS));\n+      bne(CCR0, slow_case);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1003,0 +1003,6 @@\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    load_klass(Z_R1_scratch, object);\n+    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_BOX_CLASS));\n+    z_btrue(slow_case);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  const Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -55,0 +56,9 @@\n+  null_check_offset = offset();\n+\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    load_klass(hdr, obj, rklass_decode_tmp);\n+    movl(hdr, Address(hdr, Klass::access_flags_offset()));\n+    testl(hdr, JVM_ACC_IS_BOX_CLASS);\n+    jcc(Assembler::notZero, slow_case);\n+  }\n+\n@@ -57,4 +67,1 @@\n-    Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, rklass_decode_tmp, false, done, &slow_case);\n-  } else {\n-    null_check_offset = offset();\n+    biased_locking_enter(disp_hdr, obj, hdr, scratch, rklass_decode_tmp, false, done, &slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -473,0 +473,7 @@\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    load_klass(tmpReg, objReg, cx1Reg);\n+    movl(tmpReg, Address(tmpReg, Klass::access_flags_offset()));\n+    testl(tmpReg, JVM_ACC_IS_BOX_CLASS);\n+    jcc(Assembler::notZero, DONE_LABEL);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1333,0 +1333,1 @@\n+    const Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -1344,0 +1345,7 @@\n+    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+      load_klass(tmp_reg, obj_reg, rklass_decode_tmp);\n+      movl(tmp_reg, Address(tmp_reg, Klass::access_flags_offset()));\n+      testl(tmp_reg, JVM_ACC_IS_BOX_CLASS);\n+      jcc(Assembler::notZero, slow_case);\n+    }\n+\n@@ -1345,1 +1353,0 @@\n-      Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1089,9 +1089,9 @@\n-int MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                         Register obj_reg,\n-                                         Register swap_reg,\n-                                         Register tmp_reg,\n-                                         Register tmp_reg2,\n-                                         bool swap_reg_contains_mark,\n-                                         Label& done,\n-                                         Label* slow_case,\n-                                         BiasedLockingCounters* counters) {\n+void MacroAssembler::biased_locking_enter(Register lock_reg,\n+                                          Register obj_reg,\n+                                          Register swap_reg,\n+                                          Register tmp_reg,\n+                                          Register tmp_reg2,\n+                                          bool swap_reg_contains_mark,\n+                                          Label& done,\n+                                          Label* slow_case,\n+                                          BiasedLockingCounters* counters) {\n@@ -1116,2 +1116,0 @@\n-  int null_check_offset = -1;\n-    null_check_offset = offset();\n@@ -1135,3 +1133,0 @@\n-  if (swap_reg_contains_mark) {\n-    null_check_offset = offset();\n-  }\n@@ -1271,2 +1266,0 @@\n-\n-  return null_check_offset;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -716,9 +716,5 @@\n-  \/\/ Returns offset of first potentially-faulting instruction for null\n-  \/\/ check info (currently consumed only by C1). If\n-  \/\/ swap_reg_contains_mark is true then returns -1 as it is assumed\n-  \/\/ the calling code has already passed any potential faults.\n-  int biased_locking_enter(Register lock_reg, Register obj_reg,\n-                           Register swap_reg, Register tmp_reg,\n-                           Register tmp_reg2, bool swap_reg_contains_mark,\n-                           Label& done, Label* slow_case = NULL,\n-                           BiasedLockingCounters* counters = NULL);\n+  void biased_locking_enter(Register lock_reg, Register obj_reg,\n+                            Register swap_reg, Register tmp_reg,\n+                            Register tmp_reg2, bool swap_reg_contains_mark,\n+                            Label& done, Label* slow_case = NULL,\n+                            BiasedLockingCounters* counters = NULL);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-static const int stub_size = 1100;\n+static const int stub_size = 2000;\n@@ -57,0 +57,1 @@\n+  typedef void (*detect_virt_stub_t)(uint32_t, uint32_t*);\n@@ -59,0 +60,1 @@\n+static detect_virt_stub_t detect_virt_stub = NULL;\n@@ -571,0 +573,37 @@\n+  address generate_detect_virt() {\n+    StubCodeMark mark(this, \"VM_Version\", \"detect_virt_stub\");\n+#   define __ _masm->\n+\n+    address start = __ pc();\n+\n+    \/\/ Evacuate callee-saved registers\n+    __ push(rbp);\n+    __ push(rbx);\n+    __ push(rsi); \/\/ for Windows\n+\n+#ifdef _LP64\n+    __ mov(rax, c_rarg0); \/\/ CPUID leaf\n+    __ mov(rsi, c_rarg1); \/\/ register array address (eax, ebx, ecx, edx)\n+#else\n+    __ movptr(rax, Address(rsp, 16)); \/\/ CPUID leaf\n+    __ movptr(rsi, Address(rsp, 20)); \/\/ register array address\n+#endif\n+\n+    __ cpuid();\n+\n+    \/\/ Store result to register array\n+    __ movl(Address(rsi,  0), rax);\n+    __ movl(Address(rsi,  4), rbx);\n+    __ movl(Address(rsi,  8), rcx);\n+    __ movl(Address(rsi, 12), rdx);\n+\n+    \/\/ Epilogue\n+    __ pop(rsi);\n+    __ pop(rbx);\n+    __ pop(rbp);\n+    __ ret(0);\n+\n+#   undef __\n+\n+    return start;\n+  };\n@@ -1674,1 +1713,3 @@\n-    st->print_cr(\"HyperV virtualization detected\");\n+    st->print_cr(\"Hyper-V virtualization detected\");\n+  } else if (vrt == HyperVRole) {\n+    st->print_cr(\"Hyper-V role detected\");\n@@ -1678,46 +1719,0 @@\n-void VM_Version::check_virt_cpuid(uint32_t idx, uint32_t *regs) {\n-\/\/ TODO support 32 bit\n-#if defined(_LP64)\n-#if defined(_MSC_VER)\n-  \/\/ Allocate space for the code\n-  const int code_size = 100;\n-  ResourceMark rm;\n-  CodeBuffer cb(\"detect_virt\", code_size, 0);\n-  MacroAssembler* a = new MacroAssembler(&cb);\n-  address code = a->pc();\n-  void (*test)(uint32_t idx, uint32_t *regs) = (void(*)(uint32_t idx, uint32_t *regs))code;\n-\n-  a->movq(r9, rbx); \/\/ save nonvolatile register\n-\n-  \/\/ next line would not work on 32-bit\n-  a->movq(rax, c_rarg0 \/* rcx *\/);\n-  a->movq(r8, c_rarg1 \/* rdx *\/);\n-  a->cpuid();\n-  a->movl(Address(r8,  0), rax);\n-  a->movl(Address(r8,  4), rbx);\n-  a->movl(Address(r8,  8), rcx);\n-  a->movl(Address(r8, 12), rdx);\n-\n-  a->movq(rbx, r9); \/\/ restore nonvolatile register\n-  a->ret(0);\n-\n-  uint32_t *code_end = (uint32_t *)a->pc();\n-  a->flush();\n-\n-  \/\/ execute code\n-  (*test)(idx, regs);\n-#elif defined(__GNUC__)\n-  __asm__ volatile (\n-     \"        cpuid;\"\n-     \"        mov %%eax,(%1);\"\n-     \"        mov %%ebx,4(%1);\"\n-     \"        mov %%ecx,8(%1);\"\n-     \"        mov %%edx,12(%1);\"\n-     : \"+a\" (idx)\n-     : \"S\" (regs)\n-     : \"ebx\", \"ecx\", \"edx\", \"memory\" );\n-#endif\n-#endif\n-}\n-\n-\n@@ -1824,9 +1819,2 @@\n-#if defined(_LP64)\n-  uint32_t registers[4];\n-  char signature[13];\n-  uint32_t base;\n-  signature[12] = '\\0';\n-  memset((void*)registers, 0, 4*sizeof(uint32_t));\n-\n-  for (base = 0x40000000; base < 0x40010000; base += 0x100) {\n-    check_virt_cpuid(base, registers);\n+  uint32_t registers[4] = {0};\n+  char signature[13] = {0};\n@@ -1834,3 +1822,6 @@\n-    *(uint32_t *)(signature + 0) = registers[1];\n-    *(uint32_t *)(signature + 4) = registers[2];\n-    *(uint32_t *)(signature + 8) = registers[3];\n+  \/\/ Xen cpuid leaves can be found 0x100 aligned boundary starting\n+  \/\/ from 0x40000000 until 0x40010000.\n+  \/\/   https:\/\/lists.linuxfoundation.org\/pipermail\/virtualization\/2012-May\/019974.html\n+  for (int leaf = 0x40000000; leaf < 0x40010000; leaf += 0x100) {\n+    detect_virt_stub(leaf, registers);\n+    memcpy(signature, &registers[1], 12);\n@@ -1842,3 +1833,1 @@\n-    }\n-\n-    if (strncmp(\"Microsoft Hv\", signature, 12) == 0) {\n+    } else if (strncmp(\"Microsoft Hv\", signature, 12) == 0) {\n@@ -1846,3 +1835,13 @@\n-    }\n-\n-    if (strncmp(\"KVMKVMKVM\", signature, 9) == 0) {\n+#ifdef _WINDOWS\n+      \/\/ CPUID leaf 0x40000007 is available to the root partition only.\n+      \/\/ See Hypervisor Top Level Functional Specification section 2.4.8 for more details.\n+      \/\/   https:\/\/github.com\/MicrosoftDocs\/Virtualization-Documentation\/raw\/master\/tlfs\/Hypervisor%20Top%20Level%20Functional%20Specification%20v6.0b.pdf\n+      detect_virt_stub(0x40000007, registers);\n+      if ((registers[0] != 0x0) ||\n+          (registers[1] != 0x0) ||\n+          (registers[2] != 0x0) ||\n+          (registers[3] != 0x0)) {\n+        Abstract_VM_Version::_detected_virtualization = HyperVRole;\n+      }\n+#endif\n+    } else if (strncmp(\"KVMKVMKVM\", signature, 9) == 0) {\n@@ -1850,3 +1849,1 @@\n-    }\n-\n-    if (strncmp(\"XenVMMXenVMM\", signature, 12) == 0) {\n+    } else if (strncmp(\"XenVMMXenVMM\", signature, 12) == 0) {\n@@ -1856,1 +1853,0 @@\n-#endif\n@@ -1862,2 +1858,1 @@\n-\n-  stub_blob = BufferBlob::create(\"get_cpu_info_stub\", stub_size);\n+  stub_blob = BufferBlob::create(\"VM_Version stub\", stub_size);\n@@ -1865,1 +1860,1 @@\n-    vm_exit_during_initialization(\"Unable to allocate get_cpu_info_stub\");\n+    vm_exit_during_initialization(\"Unable to allocate stub for VM_Version\");\n@@ -1869,0 +1864,1 @@\n+\n@@ -1871,0 +1867,2 @@\n+  detect_virt_stub = CAST_TO_FN_PTR(detect_virt_stub_t,\n+                                     g.generate_detect_virt());\n@@ -1876,1 +1874,1 @@\n-  if (cpu_family() > 4) { \/\/ it supports CPUID\n+  if (VM_Version::supports_hv()) { \/\/ Supports hypervisor\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":72,"deletions":74,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -708,1 +708,0 @@\n-\n@@ -717,1 +716,0 @@\n-\n@@ -727,1 +725,7 @@\n-#endif\n+\n+\/\/ Called from debugger to get the interval with 'reg_num' during register allocation.\n+Interval* find_interval(int reg_num) {\n+  return Compilation::current()->allocator()->find_interval_at(reg_num);\n+}\n+\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  LinearScan* allocator()                          { return _allocator;      }\n@@ -155,0 +154,1 @@\n+  LinearScan* allocator()                        { return _allocator; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n@@ -534,1 +534,1 @@\n-  NOT_PRODUCT(void print_blocks();)\n+  DEBUG_ONLY(void print_blocks();)\n@@ -584,1 +584,1 @@\n-  NOT_PRODUCT(print_blocks());\n+  DEBUG_ONLY(print_blocks());\n@@ -1072,1 +1072,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n@@ -1129,2 +1129,0 @@\n-#endif\n-#ifdef ASSERT\n@@ -1207,1 +1205,1 @@\n-#endif\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+#else\n+  #define TIME_LINEAR_SCAN(timer_name)\n+#endif\n+\n+#ifdef ASSERT\n+\n@@ -54,4 +60,0 @@\n-\n-\n-  #define TIME_LINEAR_SCAN(timer_name)\n-\n@@ -795,1 +797,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n@@ -3204,1 +3206,41 @@\n-#endif \/\/PRODUCT\n+void LinearScan::print_reg_num(outputStream* out, int reg_num) {\n+  if (reg_num == -1) {\n+    out->print(\"[ANY]\");\n+    return;\n+  } else if (reg_num >= LIR_OprDesc::vreg_base) {\n+    out->print(\"[VREG %d]\", reg_num);\n+    return;\n+  }\n+\n+  LIR_Opr opr = LIR_OprFact::illegal();\n+\n+#ifdef X86\n+  int last_xmm_reg = pd_last_xmm_reg;\n+#ifdef _LP64\n+  if (UseAVX < 3) {\n+    last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map \/ 2) - 1;\n+  }\n+#endif\n+#endif\n+  if (reg_num >= pd_first_cpu_reg && reg_num <= pd_last_cpu_reg) {\n+    opr = LIR_OprFact::single_cpu(reg_num);\n+  } else if (reg_num >= pd_first_fpu_reg && reg_num <= pd_last_fpu_reg) {\n+    opr = LIR_OprFact::single_fpu(reg_num - pd_first_fpu_reg);\n+#ifdef X86\n+  } else if (reg_num >= pd_first_xmm_reg && reg_num <= last_xmm_reg) {\n+    opr = LIR_OprFact::single_xmm(reg_num - pd_first_xmm_reg);\n+#endif\n+  } else {\n+    assert(false, \"unknown register\");\n+  }\n+  opr->print(out);\n+}\n+\n+Interval* LinearScan::find_interval_at(int reg_num) const {\n+  if (reg_num < 0 || reg_num >= _intervals.length()) {\n+    return NULL;\n+  }\n+  return interval_at(reg_num);\n+}\n+\n+#endif \/\/ PRODUCT\n@@ -4559,1 +4601,1 @@\n-void Interval::print(outputStream* out) const {\n+void Interval::print_on(outputStream* out) const {\n@@ -4564,1 +4606,0 @@\n-  LIR_Opr opr = LIR_OprFact::illegal();\n@@ -4567,20 +4608,0 @@\n-    \/\/ need a temporary operand for fixed intervals because type() cannot be called\n-#ifdef X86\n-    int last_xmm_reg = pd_last_xmm_reg;\n-#ifdef _LP64\n-    if (UseAVX < 3) {\n-      last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map \/ 2) - 1;\n-    }\n-#endif\n-#endif\n-    if (assigned_reg() >= pd_first_cpu_reg && assigned_reg() <= pd_last_cpu_reg) {\n-      opr = LIR_OprFact::single_cpu(assigned_reg());\n-    } else if (assigned_reg() >= pd_first_fpu_reg && assigned_reg() <= pd_last_fpu_reg) {\n-      opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);\n-#ifdef X86\n-    } else if (assigned_reg() >= pd_first_xmm_reg && assigned_reg() <= last_xmm_reg) {\n-      opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);\n-#endif\n-    } else {\n-      ShouldNotReachHere();\n-    }\n@@ -4589,4 +4610,0 @@\n-    if (assigned_reg() != -1 &&\n-        (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {\n-      opr = LinearScan::calc_operand_for_interval(this);\n-    }\n@@ -4596,4 +4613,7 @@\n-  if (opr->is_valid()) {\n-    out->print(\"\\\"\");\n-    opr->print(out);\n-    out->print(\"\\\" \");\n+  if (reg_num() < LIR_OprDesc::vreg_base) {\n+    LinearScan::print_reg_num(out, assigned_reg());\n+  } else if (assigned_reg() != -1 && (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {\n+    LinearScan::calc_operand_for_interval(this)->print(out);\n+  } else {\n+    \/\/ Virtual register that has no assigned register yet.\n+    out->print(\"[ANY]\");\n@@ -4601,1 +4621,2 @@\n-  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n+\n+  out->print(\" %d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n@@ -4625,1 +4646,22 @@\n-#endif\n+\n+void Interval::print_parent() const {\n+  if (_split_parent != this) {\n+    _split_parent->print_on(tty);\n+  } else {\n+    tty->print_cr(\"Parent: this\");\n+  }\n+}\n+\n+void Interval::print_children() const {\n+  if (_split_children == NULL) {\n+    tty->print_cr(\"Children: []\");\n+  } else {\n+    tty->print_cr(\"Children:\");\n+    for (int i = 0; i < _split_children->length(); i++) {\n+      tty->print(\"%d: \", i);\n+      _split_children->at(i)->print_on(tty);\n+    }\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n+\n@@ -4730,1 +4772,1 @@\n-          interval_moved(cur, kind, state, handledState);\n+          DEBUG_ONLY(interval_moved(cur, kind, state, handledState);)\n@@ -4739,1 +4781,1 @@\n-          interval_moved(cur, kind, state, activeState);\n+          DEBUG_ONLY(interval_moved(cur, kind, state, activeState);)\n@@ -4748,1 +4790,1 @@\n-          interval_moved(cur, kind, state, inactiveState);\n+          DEBUG_ONLY(interval_moved(cur, kind, state, inactiveState);)\n@@ -4804,1 +4846,1 @@\n-        interval_moved(current(), current_kind(), unhandledState, activeState);\n+        DEBUG_ONLY(interval_moved(current(), current_kind(), unhandledState, activeState);)\n@@ -4814,0 +4856,1 @@\n+#ifdef ASSERT\n@@ -4815,1 +4858,0 @@\n-#ifndef PRODUCT\n@@ -4832,3 +4874,1 @@\n-#endif\n-\n-\n+#endif \/\/ ASSERT\n@@ -5308,1 +5348,0 @@\n-\n@@ -5370,1 +5409,0 @@\n-\n@@ -5384,2 +5422,10 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"      state of registers:\"));\n-  TRACE_LINEAR_SCAN(4, for (int i = _first_reg; i <= _last_reg; i++) tty->print_cr(\"      reg %d: use_pos: %d\", i, _use_pos[i]));\n+#ifdef ASSERT\n+  if (TraceLinearScanLevel >= 4) {\n+    tty->print_cr(\"      state of registers:\");\n+    for (int i = _first_reg; i <= _last_reg; i++) {\n+      tty->print(\"      reg %d (\", i);\n+      LinearScan::print_reg_num(i);\n+      tty->print_cr(\"): use_pos: %d\", _use_pos[i]);\n+    }\n+  }\n+#endif\n@@ -5397,2 +5443,10 @@\n-    TRACE_LINEAR_SCAN(4, tty->print(\"      hint registers %d, %d from interval \", hint_reg, hint_regHi); register_hint->print());\n-\n+#ifdef ASSERT\n+    if (TraceLinearScanLevel >= 4) {\n+      tty->print(\"      hint registers %d (\", hint_reg);\n+      LinearScan::print_reg_num(hint_reg);\n+      tty->print(\"), %d (\", hint_regHi);\n+      LinearScan::print_reg_num(hint_regHi);\n+      tty->print(\") from interval \");\n+      register_hint->print();\n+    }\n+#endif\n@@ -5453,2 +5507,9 @@\n-  TRACE_LINEAR_SCAN(2, tty->print_cr(\"selected register %d, %d\", reg, regHi));\n-\n+#ifdef ASSERT\n+  if (TraceLinearScanLevel >= 2) {\n+    tty->print(\"      selected registers %d (\", reg);\n+    LinearScan::print_reg_num(reg);\n+    tty->print(\"), %d (\", regHi);\n+    LinearScan::print_reg_num(regHi);\n+    tty->print_cr(\")\");\n+  }\n+#endif\n@@ -5542,1 +5603,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n@@ -5546,1 +5607,3 @@\n-      tty->print(\"      reg %d: use_pos: %d, block_pos: %d, intervals: \", i, _use_pos[i], _block_pos[i]);\n+      tty->print(\"      reg %d(\", i);\n+      LinearScan::print_reg_num(i);\n+      tty->print(\"): use_pos: %d, block_pos: %d, intervals: \", _use_pos[i], _block_pos[i]);\n@@ -5616,1 +5679,9 @@\n-    TRACE_LINEAR_SCAN(4, tty->print_cr(\"decided to use register %d, %d\", reg, regHi));\n+#ifdef ASSERT\n+    if (TraceLinearScanLevel >= 4) {\n+      tty->print(\"decided to use register %d (\", reg);\n+      LinearScan::print_reg_num(reg);\n+      tty->print(\"), %d (\", regHi);\n+      LinearScan::print_reg_num(regHi);\n+      tty->print_cr(\")\");\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":128,"deletions":57,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -5818,5 +5818,1 @@\n-    if (log_is_enabled(Info, class, load)) {\n-      ResourceMark rm;\n-      const char* module_name = (module_entry->name() == NULL) ? UNNAMED_MODULE : module_entry->name()->as_C_string();\n-      ik->print_class_load_logging(_loader_data, module_name, _stream);\n-    }\n+    ik->print_class_load_logging(_loader_data, module_entry, _stream);\n@@ -6347,38 +6343,0 @@\n-\n-#if INCLUDE_CDS\n-    if (DumpLoadedClassList != NULL && stream->source() != NULL && classlist_file->is_open()) {\n-      if (!ClassLoader::has_jrt_entry()) {\n-        warning(\"DumpLoadedClassList and CDS are not supported in exploded build\");\n-        DumpLoadedClassList = NULL;\n-      } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &&\n-                 !_is_hidden &&\n-                 _unsafe_anonymous_host == NULL) {\n-        \/\/ Only dump the classes that can be stored into CDS archive.\n-        \/\/ Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.\n-        oop class_loader = _loader_data->class_loader();\n-        ResourceMark rm(THREAD);\n-        bool skip = false;\n-        if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {\n-          \/\/ For the boot and platform class loaders, skip classes that are not found in the\n-          \/\/ java runtime image, such as those found in the --patch-module entries.\n-          \/\/ These classes can't be loaded from the archive during runtime.\n-          if (!stream->from_boot_loader_modules_image() && strncmp(stream->source(), \"jrt:\", 4) != 0) {\n-            skip = true;\n-          }\n-\n-          if (class_loader == NULL && ClassLoader::contains_append_entry(stream->source())) {\n-            \/\/ .. but don't skip the boot classes that are loaded from -Xbootclasspath\/a\n-            \/\/ as they can be loaded from the archive during runtime.\n-            skip = false;\n-          }\n-        }\n-        if (skip) {\n-          tty->print_cr(\"skip writing class %s from source %s to classlist file\",\n-            _class_name->as_C_string(), stream->source());\n-        } else {\n-          classlist_file->print_cr(\"%s\", _class_name->as_C_string());\n-          classlist_file->flush();\n-        }\n-      }\n-    }\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1549,9 +1549,0 @@\n-  if (DumpLoadedClassList != NULL && classlist_file->is_open()) {\n-    \/\/ Only dump the classes that can be stored into CDS archive\n-    if (SystemDictionaryShared::is_sharing_possible(loader_data)) {\n-      ResourceMark rm(THREAD);\n-      classlist_file->print_cr(\"%s\", ik->name()->as_C_string());\n-      classlist_file->flush();\n-    }\n-  }\n-\n@@ -2278,0 +2269,8 @@\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    for (int i = T_BOOLEAN; i < T_LONG + 1; i++) {\n+      assert(_box_klasses[i] != NULL, \"NULL box class\");\n+      _box_klasses[i]->set_is_box();\n+      _box_klasses[i]->set_prototype_header(markWord::prototype());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -346,1 +346,1 @@\n-  bool is_deopt_mh_entry(address pc) { return pc == deopt_mh_handler_begin(); }\n+  inline bool is_deopt_mh_entry(address pc);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1060,1 +1060,1 @@\n-  ClassLoaderDataGraph::purge();\n+  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n@@ -1613,0 +1613,1 @@\n+#ifdef ASSERT\n@@ -1623,0 +1624,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-void CodeInstaller::record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool return_oop, JVMCI_TRAPS) {\n+void CodeInstaller::record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n@@ -1059,1 +1059,1 @@\n-  record_scope(pc_offset, position, scope_mode, objectMapping, return_oop, JVMCI_CHECK);\n+  record_scope(pc_offset, position, scope_mode, objectMapping, is_mh_invoke, return_oop, JVMCI_CHECK);\n@@ -1082,1 +1082,1 @@\n-void CodeInstaller::record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray<ScopeValue*>* objects, bool return_oop, JVMCI_TRAPS) {\n+void CodeInstaller::record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray<ScopeValue*>* objects, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n@@ -1092,1 +1092,1 @@\n-    record_scope(pc_offset, caller_frame, scope_mode, objects, return_oop, JVMCI_CHECK);\n+    record_scope(pc_offset, caller_frame, scope_mode, objects, is_mh_invoke, return_oop, JVMCI_CHECK);\n@@ -1184,1 +1184,1 @@\n-  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, false, return_oop, false,\n+  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, is_mh_invoke, return_oop, false,\n@@ -1239,3 +1239,13 @@\n-    bool return_oop = hotspot_method.is_non_null() && jvmci_env()->asMethod(hotspot_method)->is_returning_oop();\n-\n-    record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, return_oop, JVMCI_CHECK);\n+    if (hotspot_method.is_non_null()) {\n+      Method *method = jvmci_env()->asMethod(hotspot_method);\n+      vmIntrinsics::ID iid = method->intrinsic_id();\n+      bool is_mh_invoke = false;\n+      if (jvmci_env()->get_site_Call_direct(site)) {\n+        is_mh_invoke = !method->is_static() && (iid == vmIntrinsics::_compiledLambdaForm ||\n+                (MethodHandles::is_signature_polymorphic(iid) && MethodHandles::is_signature_polymorphic_intrinsic(iid)));\n+      }\n+      bool return_oop = method->is_returning_oop();\n+      record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, is_mh_invoke, return_oop, JVMCI_CHECK);\n+    } else {\n+      record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, JVMCI_CHECK);\n+    }\n@@ -1352,0 +1362,3 @@\n+      case DEOPT_MH_HANDLER_ENTRY:\n+        _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n+        break;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -474,0 +474,1 @@\n+  declare_constant(CodeInstaller::DEOPT_MH_HANDLER_ENTRY)                 \\\n@@ -476,0 +477,5 @@\n+  declare_constant(vmIntrinsics::FIRST_MH_SIG_POLY)                       \\\n+  declare_constant(vmIntrinsics::LAST_MH_SIG_POLY)                        \\\n+  declare_constant(vmIntrinsics::_invokeGeneric)                          \\\n+  declare_constant(vmIntrinsics::_compiledLambdaForm)                     \\\n+                                                                          \\\n@@ -970,1 +976,0 @@\n-\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  LOG_TAG(primitivewrappers) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,86 +119,0 @@\n-char* DumpRegion::expand_top_to(char* newtop) {\n-  assert(is_allocatable(), \"must be initialized and not packed\");\n-  assert(newtop >= _top, \"must not grow backwards\");\n-  if (newtop > _end) {\n-    MetaspaceShared::report_out_of_space(_name, newtop - _top);\n-    ShouldNotReachHere();\n-  }\n-\n-  if (_rs == MetaspaceShared::shared_rs()) {\n-    uintx delta;\n-    if (DynamicDumpSharedSpaces) {\n-      delta = DynamicArchive::object_delta_uintx(newtop);\n-    } else {\n-      delta = MetaspaceShared::object_delta_uintx(newtop);\n-    }\n-    if (delta > MAX_SHARED_DELTA) {\n-      \/\/ This is just a sanity check and should not appear in any real world usage. This\n-      \/\/ happens only if you allocate more than 2GB of shared objects and would require\n-      \/\/ millions of shared classes.\n-      vm_exit_during_initialization(\"Out of memory in the CDS archive\",\n-                                    \"Please reduce the number of shared classes.\");\n-    }\n-  }\n-\n-  MetaspaceShared::commit_to(_rs, _vs, newtop);\n-  _top = newtop;\n-  return _top;\n-}\n-\n-char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {\n-  char* p = (char*)align_up(_top, alignment);\n-  char* newtop = p + align_up(num_bytes, alignment);\n-  expand_top_to(newtop);\n-  memset(p, 0, newtop - p);\n-  return p;\n-}\n-\n-void DumpRegion::append_intptr_t(intptr_t n, bool need_to_mark) {\n-  assert(is_aligned(_top, sizeof(intptr_t)), \"bad alignment\");\n-  intptr_t *p = (intptr_t*)_top;\n-  char* newtop = _top + sizeof(intptr_t);\n-  expand_top_to(newtop);\n-  *p = n;\n-  if (need_to_mark) {\n-    ArchivePtrMarker::mark_pointer(p);\n-  }\n-}\n-\n-void DumpRegion::print(size_t total_bytes) const {\n-  log_debug(cds)(\"%-3s space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used] at \" INTPTR_FORMAT,\n-                 _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()),\n-                 p2i(_base + MetaspaceShared::final_delta()));\n-}\n-\n-void DumpRegion::print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {\n-  log_error(cds)(\"[%-8s] \" PTR_FORMAT \" - \" PTR_FORMAT \" capacity =%9d, allocated =%9d\",\n-                 _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));\n-  if (strcmp(_name, failing_region) == 0) {\n-    log_error(cds)(\" required = %d\", int(needed_bytes));\n-  }\n-}\n-\n-void DumpRegion::init(ReservedSpace* rs, VirtualSpace* vs) {\n-  _rs = rs;\n-  _vs = vs;\n-  \/\/ Start with 0 committed bytes. The memory will be committed as needed by\n-  \/\/ MetaspaceShared::commit_to().\n-  if (!_vs->initialize(*_rs, 0)) {\n-    fatal(\"Unable to allocate memory for shared space\");\n-  }\n-  _base = _top = _rs->base();\n-  _end = _rs->end();\n-}\n-\n-void DumpRegion::pack(DumpRegion* next) {\n-  assert(!is_packed(), \"sanity\");\n-  _end = (char*)align_up(_top, MetaspaceShared::reserved_space_alignment());\n-  _is_packed = true;\n-  if (next != NULL) {\n-    next->_rs = _rs;\n-    next->_vs = _vs;\n-    next->_base = next->_top = this->_end;\n-    next->_end = _rs->end();\n-  }\n-}\n-\n@@ -990,24 +904,0 @@\n-void WriteClosure::do_oop(oop* o) {\n-  if (*o == NULL) {\n-    _dump_region->append_intptr_t(0);\n-  } else {\n-    assert(HeapShared::is_heap_object_archiving_allowed(),\n-           \"Archiving heap object is not allowed\");\n-    _dump_region->append_intptr_t(\n-      (intptr_t)CompressedOops::encode_not_null(*o));\n-  }\n-}\n-\n-void WriteClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    _dump_region->append_intptr_t(*(intptr_t*)start, true);\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n-  }\n-}\n-\n-\/\/ Populate the shared space.\n-\n@@ -1571,50 +1461,0 @@\n-void ReadClosure::do_ptr(void** p) {\n-  assert(*p == NULL, \"initializing previous initialized pointer.\");\n-  intptr_t obj = nextPtr();\n-  assert((intptr_t)obj >= 0 || (intptr_t)obj < -100,\n-         \"hit tag while initializing ptrs.\");\n-  *p = (void*)obj;\n-}\n-\n-void ReadClosure::do_u4(u4* p) {\n-  intptr_t obj = nextPtr();\n-  *p = (u4)(uintx(obj));\n-}\n-\n-void ReadClosure::do_bool(bool* p) {\n-  intptr_t obj = nextPtr();\n-  *p = (bool)(uintx(obj));\n-}\n-\n-void ReadClosure::do_tag(int tag) {\n-  int old_tag;\n-  old_tag = (int)(intptr_t)nextPtr();\n-  \/\/ do_int(&old_tag);\n-  assert(tag == old_tag, \"old tag doesn't match\");\n-  FileMapInfo::assert_mark(tag == old_tag);\n-}\n-\n-void ReadClosure::do_oop(oop *p) {\n-  narrowOop o = (narrowOop)nextPtr();\n-  if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {\n-    *p = NULL;\n-  } else {\n-    assert(HeapShared::is_heap_object_archiving_allowed(),\n-           \"Archived heap object is not allowed\");\n-    assert(HeapShared::open_archive_heap_region_mapped(),\n-           \"Open archive heap region is not mapped\");\n-    *p = HeapShared::decode_from_archive(o);\n-  }\n-}\n-\n-void ReadClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    *(intptr_t*)start = nextPtr();\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n-  }\n-}\n-\n@@ -2213,5 +2053,0 @@\n-\n-\n-\n-\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":0,"deletions":165,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -3785,1 +3785,1 @@\n-                                             const char* module_name,\n+                                             const ModuleEntry* module_entry,\n@@ -3787,0 +3787,2 @@\n+  log_to_classlist(cfs);\n+\n@@ -3801,0 +3803,1 @@\n+      const char* module_name = (module_entry->name() == NULL) ? UNNAMED_MODULE : module_entry->name()->as_C_string();\n@@ -4142,2 +4145,3 @@\n-      \/\/ Add to the deallocate list after unlinking\n-      loader_data->add_to_deallocate_list(pv_node);\n+      \/\/ Delete this node directly. Nothing is referring to it and we don't\n+      \/\/ want it to increase the counter for metadata to delete in CLDG.\n+      MetadataFactory::free_metadata(loader_data, pv_node);\n@@ -4376,4 +4380,48 @@\n-#define THROW_DVT_ERROR(s) \\\n-  Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \\\n-      \"ValueCapableClass class '%s' %s\", external_name(),(s)); \\\n-      return\n+void InstanceKlass::log_to_classlist(const ClassFileStream* stream) const {\n+#if INCLUDE_CDS\n+  if (DumpLoadedClassList && classlist_file->is_open()) {\n+    if (!ClassLoader::has_jrt_entry()) {\n+       warning(\"DumpLoadedClassList and CDS are not supported in exploded build\");\n+       DumpLoadedClassList = NULL;\n+       return;\n+    }\n+    ClassLoaderData* loader_data = class_loader_data();\n+    if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n+      return;\n+    }\n+    bool skip = false;\n+    if (is_shared()) {\n+      assert(stream == NULL, \"shared class with stream\");\n+    } else {\n+      assert(stream != NULL, \"non-shared class without stream\");\n+      \/\/ skip hidden class and unsafe anonymous class.\n+      if ( is_hidden() || unsafe_anonymous_host() != NULL) {\n+        return;\n+      }\n+      oop class_loader = loader_data->class_loader();\n+      if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {\n+        \/\/ For the boot and platform class loaders, skip classes that are not found in the\n+        \/\/ java runtime image, such as those found in the --patch-module entries.\n+        \/\/ These classes can't be loaded from the archive during runtime.\n+        if (!stream->from_boot_loader_modules_image() && strncmp(stream->source(), \"jrt:\", 4) != 0) {\n+          skip = true;\n+        }\n+\n+        if (class_loader == NULL && ClassLoader::contains_append_entry(stream->source())) {\n+          \/\/ .. but don't skip the boot classes that are loaded from -Xbootclasspath\/a\n+          \/\/ as they can be loaded from the archive during runtime.\n+          skip = false;\n+        }\n+      }\n+    }\n+    ResourceMark rm;\n+    if (skip) {\n+      tty->print_cr(\"skip writing class %s from source %s to classlist file\",\n+                    name()->as_C_string(), stream->source());\n+    } else {\n+      classlist_file->print_cr(\"%s\", name()->as_C_string());\n+      classlist_file->flush();\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS\n+}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":55,"deletions":7,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1497,0 +1497,2 @@\n+  \/\/ log class name to classlist\n+  void log_to_classlist(const ClassFileStream* cfs) const;\n@@ -1538,1 +1540,1 @@\n-                                const char* module_name,\n+                                const ModuleEntry* module_entry,\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -667,0 +667,2 @@\n+  bool is_box() const                   { return access_flags().is_box_class(); }\n+  void set_is_box()                     { _access_flags.set_is_box_class(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+\/\/    [0 ............ 0| 00]  inflating          inflation in progress\n@@ -104,3 +105,3 @@\n-\/\/  - INFLATING() is a distinguished markword value that is used when\n-\/\/    inflating an existing stack-lock into an ObjectMonitor. See below\n-\/\/    for is_being_inflated() and INFLATING().\n+\/\/  - INFLATING() is a distinguished markword value of all zeros that is\n+\/\/    used when inflating an existing stack-lock into an ObjectMonitor.\n+\/\/    See below for is_being_inflated() and INFLATING().\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n- public:\n-  enum {\n-    xxxunusedxxx\n-  };\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -911,2 +911,1 @@\n-        DUIterator_Fast jmax, j = pn->fast_outs(jmax);\n-        const Node *cn = pn->fast_out(j);\n+        const Node *cn = pn->unique_ctrl_out();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -519,1 +519,2 @@\n-  return _has_reserved = true;\n+  _has_reserved = true;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -584,4 +584,1 @@\n-    JavaThread* cur_thread = JavaThread::current();\n-    HandleMark hm(cur_thread);\n-\n-    Handle obj(cur_thread, JNIHandles::resolve_external_guard(jobj));\n+    oop obj = JNIHandles::resolve_external_guard(jobj);\n@@ -593,1 +590,1 @@\n-    if (!is_assignable(signature, ob_k, cur_thread)) {\n+    if (!is_assignable(signature, ob_k, VMThread::vm_thread())) {\n@@ -634,1 +631,1 @@\n-bool VM_GetOrSetLocal::doit_prologue() {\n+void VM_GetOrSetLocal::doit() {\n@@ -636,1 +633,3 @@\n-  NULL_CHECK(_jvf, false);\n+  if (_jvf == NULL) {\n+    return;\n+  };\n@@ -642,1 +641,6 @@\n-      return false;\n+      return;\n+    }\n+  } else {\n+    if (method->is_native()) {\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n@@ -644,12 +648,7 @@\n-    return true;\n-  }\n-\n-  if (method->is_native()) {\n-    _result = JVMTI_ERROR_OPAQUE_FRAME;\n-    return false;\n-  }\n-  if (!check_slot_type_no_lvt(_jvf)) {\n-    return false;\n-  }\n-  if (method->has_localvariable_table()) {\n-    return check_slot_type_lvt(_jvf);\n+    if (!check_slot_type_no_lvt(_jvf)) {\n+      return;\n+    }\n+    if (method->has_localvariable_table() &&\n+        !check_slot_type_lvt(_jvf)) {\n+      return;\n+    }\n@@ -658,3 +657,0 @@\n-  return true;\n-}\n-void VM_GetOrSetLocal::doit() {\n@@ -700,1 +696,1 @@\n-    Thread* current_thread = Thread::current();\n+    Thread* current_thread = VMThread::vm_thread();\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1772,25 +1772,0 @@\n-WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))\n-  Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?\n-                                           Mutex::_safepoint_check_always :\n-                                           Mutex::_safepoint_check_never;\n-  Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?\n-                                           Mutex::_no_safepoint_check_flag :\n-                                           Mutex::_safepoint_check_flag;\n-  MutexLocker ml(new Mutex(Mutex::leaf, \"SFPT_Test_lock\", true, sfpt_check_required),\n-                 sfpt_check_attempted);\n-WB_END\n-\n-WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))\n-  \/\/ Create a special lock violating condition in value\n-  Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?\n-                                           Mutex::_safepoint_check_always :\n-                                           Mutex::_safepoint_check_never;\n-  Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?\n-                                           Monitor::_safepoint_check_flag :\n-                                           Monitor::_no_safepoint_check_flag;\n-\n-  MutexLocker ml(new Mutex(Mutex::special, \"SpecialTest_lock\", allowVMBlock, sfpt_check_required), safepoint_check);\n-  \/\/ If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.\n-  ThreadBlockInVM tbivm(thread);\n-WB_END\n-\n@@ -2379,0 +2354,4 @@\n+WB_ENTRY(jboolean, WB_IsJVMTIIncluded(JNIEnv* env, jobject wb))\n+  return INCLUDE_JVMTI ? JNI_TRUE : JNI_FALSE;\n+WB_END\n+\n@@ -2561,2 +2540,0 @@\n-  {CC\"assertMatchingSafepointCalls\", CC\"(ZZ)V\",       (void*)&WB_AssertMatchingSafepointCalls },\n-  {CC\"assertSpecialLock\",  CC\"(ZZ)V\",                 (void*)&WB_AssertSpecialLock },\n@@ -2636,0 +2613,1 @@\n+  {CC\"isJVMTIIncluded\", CC\"()Z\",                      (void*)&WB_IsJVMTIIncluded},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -4229,0 +4229,5 @@\n+  if (FLAG_IS_CMDLINE(DiagnoseSyncOnPrimitiveWrappers)) {\n+    if (DiagnoseSyncOnPrimitiveWrappers == ObjectSynchronizer::LOG_WARNING && !log_is_enabled(Info, primitivewrappers)) {\n+      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(primitivewrappers));\n+    }\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -829,0 +829,10 @@\n+  diagnostic(intx, DiagnoseSyncOnPrimitiveWrappers, 0,                      \\\n+             \"Detect and take action upon identifying synchronization on \"  \\\n+             \"primitive wrappers. Modes: \"                                  \\\n+             \"0: off; \"                                                     \\\n+             \"1: exit with fatal error; \"                                   \\\n+             \"2: log message to stdout. Output file can be specified with \" \\\n+             \"   -Xlog:primitivewrappers. If JFR is running it will \"       \\\n+             \"   also generate JFR events.\")                                \\\n+             range(0, 2)                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -603,9 +603,0 @@\n-  \/\/ Needs to be done single threaded by the VMThread.  This walks\n-  \/\/ the thread stacks looking for references to metadata before\n-  \/\/ deciding to remove it from the metaspaces.\n-  if (ClassLoaderDataGraph::should_clean_metaspaces_and_reset()) {\n-    const char* name = \"cleanup live ClassLoaderData metaspaces\";\n-    TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n-    ClassLoaderDataGraph::walk_metadata_and_clean_metaspaces();\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -521,0 +521,5 @@\n+\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0 && obj->klass()->is_box()) {\n+    return false;\n+  }\n+\n@@ -571,0 +576,46 @@\n+\/\/ Handle notifications when synchronizing on primitive wrappers\n+void ObjectSynchronizer::handle_sync_on_primitive_wrapper(Handle obj, Thread* current) {\n+  assert(current->is_Java_thread(), \"must be for java object synchronization\");\n+  JavaThread* self = (JavaThread*) current;\n+\n+  frame last_frame = self->last_frame();\n+  if (last_frame.is_interpreted_frame()) {\n+    \/\/ adjust bcp to point back to monitorenter so that we print the correct line numbers\n+    last_frame.interpreter_frame_set_bcp(last_frame.interpreter_frame_bcp() - 1);\n+  }\n+\n+  if (DiagnoseSyncOnPrimitiveWrappers == FATAL_EXIT) {\n+    ResourceMark rm(self);\n+    stringStream ss;\n+    self->print_stack_on(&ss);\n+    char* base = (char*)strstr(ss.base(), \"at\");\n+    char* newline = (char*)strchr(ss.base(), '\\n');\n+    if (newline != NULL) {\n+      *newline = '\\0';\n+    }\n+    fatal(\"Synchronizing on object \" INTPTR_FORMAT \" of klass %s %s\", p2i(obj()), obj->klass()->external_name(), base);\n+  } else {\n+    assert(DiagnoseSyncOnPrimitiveWrappers == LOG_WARNING, \"invalid value for DiagnoseSyncOnPrimitiveWrappers\");\n+    ResourceMark rm(self);\n+    Log(primitivewrappers) pwlog;\n+\n+    pwlog.info(\"Synchronizing on object \" INTPTR_FORMAT \" of klass %s\", p2i(obj()), obj->klass()->external_name());\n+    if (self->has_last_Java_frame()) {\n+      LogStream info_stream(pwlog.info());\n+      self->print_stack_on(&info_stream);\n+    } else {\n+      pwlog.info(\"Cannot find the last Java frame\");\n+    }\n+\n+    EventSyncOnPrimitiveWrapper event;\n+    if (event.should_commit()) {\n+      event.set_boxClass(obj->klass());\n+      event.commit();\n+    }\n+  }\n+\n+  if (last_frame.is_interpreted_frame()) {\n+    last_frame.interpreter_frame_set_bcp(last_frame.interpreter_frame_bcp() + 1);\n+  }\n+}\n+\n@@ -579,0 +630,4 @@\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0 && obj->klass()->is_box()) {\n+    handle_sync_on_primitive_wrapper(obj, THREAD);\n+  }\n+\n@@ -728,0 +783,4 @@\n+  if (DiagnoseSyncOnPrimitiveWrappers != 0 && obj->klass()->is_box()) {\n+    handle_sync_on_primitive_wrapper(obj, THREAD);\n+  }\n+\n@@ -2357,0 +2416,2 @@\n+  GVars.stw_random = os::random();\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+  typedef enum {\n+    NOT_ENABLED    = 0,\n+    FATAL_EXIT     = 1,\n+    LOG_WARNING    = 2\n+  } SyncDiagnosticOption;\n+\n@@ -197,0 +203,2 @@\n+\n+  static void handle_sync_on_primitive_wrapper(Handle obj, Thread* current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -993,1 +993,1 @@\n-    fatal(\"Possible safepoint reached by thread that does not allow it\");\n+    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"runtime\/sweeper.hpp\"\n@@ -97,0 +96,4 @@\n+void VM_CleanClassLoaderDataMetaspaces::doit() {\n+  ClassLoaderDataGraph::walk_metadata_and_clean_metaspaces();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  template(CleanClassLoaderDataMetaspaces)        \\\n@@ -240,0 +241,7 @@\n+class VM_CleanClassLoaderDataMetaspaces : public VM_Operation {\n+ public:\n+  VM_CleanClassLoaderDataMetaspaces() {}\n+  VMOp_Type type() const                         { return VMOp_CleanClassLoaderDataMetaspaces; }\n+  void doit();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  JVM_ACC_IS_BOX_CLASS            = 0x08000000,     \/\/ True if klass is primitive wrapper\n@@ -157,0 +158,1 @@\n+  bool is_box_class            () const { return (_flags & JVM_ACC_IS_BOX_CLASS           ) != 0; }\n@@ -230,0 +232,1 @@\n+  void set_is_box_class()              { atomic_set_bits(JVM_ACC_IS_BOX_CLASS);            }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+    \/**\n+     * {@code ObjectStreamClass} has no fields for default serialization.\n+     *\/\n@@ -2547,1 +2550,3 @@\n-    \/\/ a LRA cache of record deserialization constructors\n+    \/**\n+     * A LRA cache of record deserialization constructors.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-     * @throws ReflectiveOperationException\n+     * @throws LambdaConversionException\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-     * @throws ReflectiveOperationException\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -940,0 +940,3 @@\n+    \/**\n+     * The BytecodeGenerationException.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,3 +113,1 @@\n-        StringBuilder sb = new StringBuilder();\n-        unparseSig(type, sb);\n-        return sb.toString();\n+        return type.descriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2216,0 +2216,2 @@\n+            private Set<Symbol> seenTypes = new HashSet<>();\n+\n@@ -2230,1 +2232,1 @@\n-                if ((c.flags_field & LOCKED) != 0) {\n+                if (!seenTypes.add(c)) {\n@@ -2234,1 +2236,0 @@\n-                    c.flags_field |= LOCKED;\n@@ -2252,1 +2253,1 @@\n-                    c.flags_field &= ~LOCKED;\n+                    seenTypes.remove(c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,0 +305,1 @@\n+    jdk\/dynalink \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+        map.put(\"vm.jvmti\", this::vmHasJVMTI);\n@@ -103,0 +104,1 @@\n+        map.put(\"vm.pageSize\", this::vmPageSize);\n@@ -345,0 +347,7 @@\n+    \/**\n+     * @return \"true\" if the VM is compiled with JVMTI\n+     *\/\n+    protected String vmHasJVMTI() {\n+        return \"\" + WB.isJVMTIIncluded();\n+    }\n+\n@@ -440,0 +449,7 @@\n+    \/**\n+     * @return System page size in bytes.\n+     *\/\n+    protected String vmPageSize() {\n+        return \"\" + WB.getVMPageSize();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -584,4 +584,0 @@\n-  \/\/ Safepoint Checking\n-  public native void assertMatchingSafepointCalls(boolean mutexSafepointValue, boolean attemptedNoSafepointValue);\n-  public native void assertSpecialLock(boolean allowVMBlock, boolean safepointCheck);\n-\n@@ -635,0 +631,2 @@\n+\n+  public native boolean isJVMTIIncluded();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}