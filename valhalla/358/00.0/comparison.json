{"files":[{"patch":"@@ -150,1 +150,1 @@\n-    stp(arg3, arg2, Address(pre(sp, 2 * wordSize)));\n+    stp(arg3, arg2, Address(pre(sp, -2 * wordSize)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,4 +358,0 @@\n-  if (jfa->saved_fp_address()) {\n-    update_map_with_saved_link(map, jfa->saved_fp_address());\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -324,2 +324,0 @@\n-\n-  str(zr, Address(rthread, JavaThread::saved_fp_address_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3449,1 +3449,0 @@\n-#endif \/\/ COMPILER2\n@@ -3459,0 +3458,4 @@\n+\n+  int _frame_complete;\n+  int _framesize;\n+  OopMapSet* _oop_maps;\n@@ -3469,1 +3472,8 @@\n-     _output_registers(output_registers) {}\n+     _output_registers(output_registers),\n+     _frame_complete(0),\n+     _framesize(0),\n+     _oop_maps(NULL) {\n+    assert(_output_registers.length() <= 1\n+           || (_output_registers.length() == 2 && !_output_registers.at(1)->is_valid()), \"no multi-reg returns\");\n+  }\n+\n@@ -3472,0 +3482,74 @@\n+  int spill_size_in_bytes() const {\n+    if (_output_registers.length() == 0) {\n+      return 0;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    if (reg->is_Register()) {\n+      return 8;\n+    } else if (reg->is_FloatRegister()) {\n+      bool use_sve = Matcher::supports_scalable_vector();\n+      if (use_sve) {\n+        return Matcher::scalable_vector_reg_size(T_BYTE);\n+      }\n+      return 16;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+    return 0;\n+  }\n+\n+  void spill_output_registers() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    MacroAssembler* masm = _masm;\n+    if (reg->is_Register()) {\n+      __ spill(reg->as_Register(), true, 0);\n+    } else if (reg->is_FloatRegister()) {\n+      bool use_sve = Matcher::supports_scalable_vector();\n+      if (use_sve) {\n+        __ spill_sve_vector(reg->as_FloatRegister(), 0, Matcher::scalable_vector_reg_size(T_BYTE));\n+      } else {\n+        __ spill(reg->as_FloatRegister(), __ Q, 0);\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  void fill_output_registers() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    MacroAssembler* masm = _masm;\n+    if (reg->is_Register()) {\n+      __ unspill(reg->as_Register(), true, 0);\n+    } else if (reg->is_FloatRegister()) {\n+      bool use_sve = Matcher::supports_scalable_vector();\n+      if (use_sve) {\n+        __ unspill_sve_vector(reg->as_FloatRegister(), 0, Matcher::scalable_vector_reg_size(T_BYTE));\n+      } else {\n+        __ unspill(reg->as_FloatRegister(), __ Q, 0);\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  int frame_complete() const {\n+    return _frame_complete;\n+  }\n+\n+  int framesize() const {\n+    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+  }\n+\n+  OopMapSet* oop_maps() const {\n+    return _oop_maps;\n+  }\n+\n@@ -3482,10 +3566,6 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n-  BufferBlob* _invoke_native_blob =\n-    BufferBlob::create(\"nep_invoker_blob\", native_invoker_code_size);\n-  if (_invoke_native_blob == NULL)\n-    return NULL; \/\/ allocation failure\n-\n-  CodeBuffer code(_invoke_native_blob);\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n+  int locs_size  = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n@@ -3496,1 +3576,7 @@\n-  return _invoke_native_blob;\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(\"nep_invoker_blob\",\n+                                  &code,\n+                                  g.frame_complete(),\n+                                  g.framesize(),\n+                                  g.oop_maps(), false);\n+  return stub;\n@@ -3505,0 +3591,13 @@\n+  enum layout {\n+    rbp_off,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  assert(_shadow_space_bytes == 0, \"not expecting shadow space on AArch64\");\n+  _framesize = align_up(framesize + (spill_size_in_bytes() >> LogBytesPerInt), 4);\n+  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+\n+  _oop_maps  = new OopMapSet();\n@@ -3507,1 +3606,1 @@\n-  __ set_last_Java_frame(sp, noreg, lr, rscratch1);\n+  address start = __ pc();\n@@ -3511,6 +3610,9 @@\n-  \/\/ Store a pointer to the previous R29 (RFP) saved on the stack as it\n-  \/\/ may contain an oop if PreserveFramePointer is off. This value is\n-  \/\/ retrieved later by frame::sender_for_entry_frame() when the stack\n-  \/\/ is walked.\n-  __ mov(rscratch1, sp);\n-  __ str(rscratch1, Address(rthread, JavaThread::saved_fp_address_offset()));\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((unsigned)_framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  _frame_complete = __ pc() - start;\n+\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  OopMap* map = new OopMap(_framesize, 0);\n+  _oop_maps->add_gc_map(the_pc - start, map);\n@@ -3523,2 +3625,0 @@\n-  assert(_shadow_space_bytes == 0, \"not expecting shadow space on AArch64\");\n-\n@@ -3570,13 +3670,1 @@\n-  RegSet spills;\n-  FloatRegSet fp_spills;\n-  for (int i = 0; i < _output_registers.length(); i++) {\n-    VMReg output = _output_registers.at(i);\n-    if (output->is_Register()) {\n-      spills += RegSet::of(output->as_Register());\n-    } else if (output->is_FloatRegister()) {\n-      fp_spills += FloatRegSet::of(output->as_FloatRegister());\n-    }\n-  }\n-\n-  __ push(spills, sp);\n-  __ push_fp(fp_spills, sp);\n+  spill_output_registers();\n@@ -3589,2 +3677,1 @@\n-  __ pop_fp(fp_spills, sp);\n-  __ pop(spills, sp);\n+  fill_output_registers();\n@@ -3600,2 +3687,1 @@\n-  __ push(spills, sp);\n-  __ push_fp(fp_spills, sp);\n+  spill_output_registers();\n@@ -3605,2 +3691,1 @@\n-  __ pop_fp(fp_spills, sp);\n-  __ pop(spills, sp);\n+  fill_output_registers();\n@@ -3616,0 +3701,1 @@\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":127,"deletions":41,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-define_pd_global(size_t, MetaspaceSize,                12*M );\n","filename":"src\/hotspot\/cpu\/x86\/c1_globals_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -352,4 +352,0 @@\n-  if (jfa->saved_rbp_address()) {\n-    update_map_with_saved_link(map, jfa->saved_rbp_address());\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2885,1 +2885,0 @@\n-  movptr(Address(java_thread, JavaThread::saved_rbp_address_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3007,1 +3007,2 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n+#ifdef COMPILER2\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n@@ -3014,0 +3015,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3427,1 +3427,0 @@\n-\n@@ -3676,0 +3675,1 @@\n+#ifdef COMPILER2\n@@ -3684,0 +3684,4 @@\n+\n+  int _frame_complete;\n+  int _framesize;\n+  OopMapSet* _oop_maps;\n@@ -3694,1 +3698,9 @@\n-     _output_registers(output_registers) {}\n+     _output_registers(output_registers),\n+     _frame_complete(0),\n+     _framesize(0),\n+     _oop_maps(NULL) {\n+    assert(_output_registers.length() <= 1\n+           || (_output_registers.length() == 2 && !_output_registers.at(1)->is_valid()), \"no multi-reg returns\");\n+\n+  }\n+\n@@ -3697,1 +3709,27 @@\n-  void spill_register(VMReg reg) {\n+  int spill_size_in_bytes() const {\n+    if (_output_registers.length() == 0) {\n+      return 0;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    if (reg->is_Register()) {\n+      return 8;\n+    } else if (reg->is_XMMRegister()) {\n+      if (UseAVX >= 3) {\n+        return 64;\n+      } else if (UseAVX >= 1) {\n+        return 32;\n+      } else {\n+        return 16;\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+    return 0;\n+  }\n+\n+  void spill_out_registers() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n@@ -3701,1 +3739,1 @@\n-      __ push(reg->as_Register());\n+      __ movptr(Address(rsp, 0), reg->as_Register());\n@@ -3704,1 +3742,0 @@\n-        __ subptr(rsp, 64); \/\/ bytes\n@@ -3707,1 +3744,0 @@\n-        __ subptr(rsp, 32);\n@@ -3710,1 +3746,0 @@\n-        __ subptr(rsp, 16);\n@@ -3718,1 +3753,5 @@\n-  void fill_register(VMReg reg) {\n+  void fill_out_registers() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n@@ -3722,1 +3761,1 @@\n-      __ pop(reg->as_Register());\n+      __ movptr(reg->as_Register(), Address(rsp, 0));\n@@ -3726,1 +3765,0 @@\n-        __ addptr(rsp, 64); \/\/ bytes\n@@ -3729,1 +3767,0 @@\n-        __ addptr(rsp, 32);\n@@ -3732,1 +3769,0 @@\n-        __ addptr(rsp, 16);\n@@ -3739,0 +3775,12 @@\n+  int frame_complete() const {\n+    return _frame_complete;\n+  }\n+\n+  int framesize() const {\n+    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+  }\n+\n+  OopMapSet* oop_maps() const {\n+    return _oop_maps;\n+  }\n+\n@@ -3747,9 +3795,6 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n-  BufferBlob* _invoke_native_blob = BufferBlob::create(\"nep_invoker_blob\", native_invoker_code_size);\n-  if (_invoke_native_blob == NULL)\n-    return NULL; \/\/ allocation failure\n-\n-  CodeBuffer code(_invoke_native_blob);\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n+  int locs_size  = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n@@ -3760,1 +3805,7 @@\n-  return _invoke_native_blob;\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(\"nep_invoker_blob\",\n+                                  &code,\n+                                  g.frame_complete(),\n+                                  g.framesize(),\n+                                  g.oop_maps(), false);\n+  return stub;\n@@ -3766,0 +3817,12 @@\n+  enum layout {\n+    rbp_off,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  _framesize = align_up(framesize + ((_shadow_space_bytes + spill_size_in_bytes()) >> LogBytesPerInt), 4);\n+  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+\n+  _oop_maps  = new OopMapSet();\n@@ -3767,4 +3830,1 @@\n-  __ enter();\n-  Address java_pc(r15_thread, JavaThread::last_Java_pc_offset());\n-  __ movptr(rscratch1, Address(rsp, 8)); \/\/ read return address from stack\n-  __ movptr(java_pc, rscratch1);\n+  address start = __ pc();\n@@ -3773,3 +3833,1 @@\n-  __ movptr(rscratch1, rsp);\n-  __ addptr(rscratch1, 16); \/\/ skip return and frame\n-  __ movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), rscratch1);\n+  __ enter();\n@@ -3777,1 +3835,2 @@\n-  __ movptr(Address(r15_thread, JavaThread::saved_rbp_address_offset()), rsp); \/\/ rsp points at saved RBP\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (_framesize-4) << LogBytesPerInt); \/\/ prolog\n@@ -3779,2 +3838,1 @@\n-    \/\/ State transition\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+  _frame_complete = __ pc() - start;\n@@ -3782,4 +3840,1 @@\n-  if (_shadow_space_bytes != 0) {\n-    \/\/ needed here for correct stack args offset on Windows\n-    __ subptr(rsp, _shadow_space_bytes);\n-  }\n+  address the_pc = __ pc();\n@@ -3787,1 +3842,3 @@\n-  __ call(RuntimeAddress(_call_target));\n+  __ set_last_Java_frame(rsp, rbp, (address)the_pc);\n+  OopMap* map = new OopMap(_framesize, 0);\n+  _oop_maps->add_gc_map(the_pc - start, map);\n@@ -3789,4 +3846,2 @@\n-  if (_shadow_space_bytes != 0) {\n-    \/\/ needed here for correct stack args offset on Windows\n-    __ addptr(rsp, _shadow_space_bytes);\n-  }\n+  \/\/ State transition\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n@@ -3794,4 +3849,1 @@\n-  assert(_output_registers.length() <= 1\n-    || (_output_registers.length() == 2 && !_output_registers.at(1)->is_valid()), \"no multi-reg returns\");\n-  bool need_spills = _output_registers.length() != 0;\n-  VMReg ret_reg = need_spills ? _output_registers.at(0) : VMRegImpl::Bad();\n+  __ call(RuntimeAddress(_call_target));\n@@ -3838,3 +3890,1 @@\n-  if (need_spills) {\n-    spill_register(ret_reg);\n-  }\n+  spill_out_registers();\n@@ -3850,3 +3900,1 @@\n-  if (need_spills) {\n-    fill_register(ret_reg);\n-  }\n+  fill_out_registers();\n@@ -3863,3 +3911,1 @@\n-  if (need_spills) {\n-    spill_register(ret_reg);\n-  }\n+  spill_out_registers();\n@@ -3874,3 +3920,1 @@\n-  if (need_spills) {\n-    fill_register(ret_reg);\n-  }\n+  fill_out_registers();\n@@ -3886,0 +3930,1 @@\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":102,"deletions":57,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    Klass* k = SystemDictionary::find(name, Handle(), Handle(), THREAD);\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(name, Handle(), Handle());\n@@ -310,2 +310,2 @@\n-    if (!HAS_PENDING_EXCEPTION && k != NULL) {\n-      oop obj = InstanceKlass::cast(k)->allocate_instance(THREAD);\n+    if (ik != NULL) {\n+      oop obj = ik->allocate_instance(THREAD);\n@@ -449,2 +449,1 @@\n-      kls = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader,\n-                                                                       CHECK_AND_CLEAR_(fail_type));\n+      kls = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, THREAD);\n@@ -452,2 +451,1 @@\n-      kls = SystemDictionary::find_instance_or_array_klass(sym, loader, domain,\n-                                                           CHECK_AND_CLEAR_(fail_type));\n+      kls = SystemDictionary::find_instance_or_array_klass(sym, loader, domain);\n@@ -986,1 +984,1 @@\n-                            const GrowableArrayView<BufferBlob*>& native_invokers) {\n+                            const GrowableArrayView<RuntimeStub*>& native_invokers) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-                       const GrowableArrayView<BufferBlob*>& native_invokers = GrowableArrayView<BufferBlob*>::EMPTY);\n+                       const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -813,2 +813,3 @@\n-      Klass* k = SystemDictionary::find(name, Handle(THREAD, holder->class_loader()),\n-                                        Handle(THREAD, holder->protection_domain()), THREAD);\n+      InstanceKlass* k = SystemDictionary::find_instance_klass(name,\n+                                                               Handle(THREAD, holder->class_loader()),\n+                                                               Handle(THREAD, holder->protection_domain()));\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5907,1 +5907,1 @@\n-        Klass* klass = SystemDictionary::find(klass_name,\n+        InstanceKlass* klass = SystemDictionary::find_instance_klass(klass_name,\n@@ -5909,1 +5909,1 @@\n-            Handle(THREAD, ik->protection_domain()), CHECK);\n+            Handle(THREAD, ik->protection_domain()));\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-#include \"memory\/memRegion.hpp\"\n-#include \"memory\/metaspace.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -952,4 +952,3 @@\n-Klass* SystemDictionary::find(Symbol* class_name,\n-                              Handle class_loader,\n-                              Handle protection_domain,\n-                              TRAPS) {\n+InstanceKlass* SystemDictionary::find_instance_klass(Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     Handle protection_domain) {\n@@ -960,2 +959,2 @@\n-  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());\n+  oop class_loader_oop = java_lang_ClassLoader::non_reflection_class_loader(class_loader());\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader_oop);\n@@ -971,2 +970,1 @@\n-  return dictionary->find(name_hash, class_name,\n-                          protection_domain);\n+  return dictionary->find(name_hash, class_name, protection_domain);\n@@ -979,2 +977,1 @@\n-                                                      Handle protection_domain,\n-                                                      TRAPS) {\n+                                                      Handle protection_domain) {\n@@ -994,1 +991,1 @@\n-      k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);\n+      k = SystemDictionary::find_instance_klass(ss.as_symbol(), class_loader, protection_domain);\n@@ -1000,1 +997,1 @@\n-    k = find(class_name, class_loader, protection_domain, THREAD);\n+    k = find_instance_klass(class_name, class_loader, protection_domain);\n@@ -1272,1 +1269,1 @@\n-    Klass* check = find(name, class_loader, protection_domain, CHECK_0);\n+    InstanceKlass* check = find_instance_klass(name, class_loader, protection_domain);\n@@ -1969,1 +1966,1 @@\n-                    Symbol* class_name, Handle class_loader, TRAPS) {\n+                    Symbol* class_name, Handle class_loader, Thread* THREAD) {\n@@ -1975,1 +1972,1 @@\n-                                              no_protection_domain, CHECK_NULL);\n+                                              no_protection_domain);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  static Klass* find(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n+  static InstanceKlass* find_instance_klass(Symbol* class_name, Handle class_loader, Handle protection_domain);\n@@ -156,2 +156,1 @@\n-                                             Handle protection_domain,\n-                                             TRAPS);\n+                                             Handle protection_domain);\n@@ -182,1 +181,1 @@\n-                                                           TRAPS);\n+                                                           Thread* THREAD);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-  const GrowableArrayView<BufferBlob*>& native_invokers\n+  const GrowableArrayView<RuntimeStub*>& native_invokers\n@@ -736,1 +736,1 @@\n-  const GrowableArrayView<BufferBlob*>& native_invokers\n+  const GrowableArrayView<RuntimeStub*>& native_invokers\n@@ -1085,1 +1085,1 @@\n-  for (BufferBlob** it = native_invokers_begin(); it < native_invokers_end(); it++) {\n+  for (RuntimeStub** it = native_invokers_begin(); it < native_invokers_end(); it++) {\n@@ -2724,1 +2724,1 @@\n-  for (BufferBlob** itt = native_invokers_begin(); itt < native_invokers_end(); itt++) {\n+  for (RuntimeStub** itt = native_invokers_begin(); itt < native_invokers_end(); itt++) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-          const GrowableArrayView<BufferBlob*>& native_invokers\n+          const GrowableArrayView<RuntimeStub*>& native_invokers\n@@ -370,1 +370,1 @@\n-                              const GrowableArrayView<BufferBlob*>& native_invokers = GrowableArrayView<BufferBlob*>::EMPTY\n+                              const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY\n@@ -420,2 +420,2 @@\n-  BufferBlob** native_invokers_begin() const         { return (BufferBlob**)(header_begin() + _native_invokers_offset) ; }\n-  BufferBlob** native_invokers_end  () const         { return (BufferBlob**)(header_begin() + _handler_table_offset); }\n+  RuntimeStub** native_invokers_begin() const     { return (RuntimeStub**)(header_begin() + _native_invokers_offset) ; }\n+  RuntimeStub** native_invokers_end  () const     { return (RuntimeStub**)(header_begin() + _handler_table_offset); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1009,1 +1009,2 @@\n-        MutexLocker mu(Threads_lock);\n+        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1029,1 +1030,2 @@\n-        MutexLocker mu(Threads_lock);\n+        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1115,1 +1117,2 @@\n-        MutexLocker mu(Threads_lock);\n+        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1135,1 +1138,2 @@\n-        MutexLocker mu(Threads_lock);\n+        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -862,1 +863,0 @@\n-      ParallelRefProcEnabled && (ParallelGCThreads > 1), \/\/ mt processing\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/metaspace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -550,1 +550,3 @@\n-      resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_NULL);\n+      resolved_klass = SystemDictionary::find_instance_klass(strippedsym,\n+                                                             class_loader,\n+                                                             protection_domain);\n@@ -556,4 +558,3 @@\n-        resolved_klass = SystemDictionary::find(strippedsym,\n-                                                class_loader,\n-                                                protection_domain,\n-                                                CHECK_NULL);\n+        resolved_klass = SystemDictionary::find_instance_klass(strippedsym,\n+                                                               class_loader,\n+                                                               protection_domain);\n@@ -567,1 +568,3 @@\n-      resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_NULL);\n+      resolved_klass = SystemDictionary::find_instance_klass(class_name,\n+                                                             class_loader,\n+                                                             protection_domain);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class ReservedHeapSpace;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-    Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);\n+    Klass* k = SystemDictionary::find_instance_klass(name, h_loader, h_prot);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  Klass* volatile* adr_impl = adr_implementor();\n+  InstanceKlass* volatile* adr_impl = adr_implementor();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1362,3 +1362,3 @@\n-Klass* InstanceKlass::implementor() const {\n-  Klass* volatile* k = adr_implementor();\n-  if (k == NULL) {\n+InstanceKlass* InstanceKlass::implementor() const {\n+  InstanceKlass* volatile* ik = adr_implementor();\n+  if (ik == NULL) {\n@@ -1368,2 +1368,2 @@\n-    Klass* kls = Atomic::load_acquire(k);\n-    if (kls != NULL && !kls->is_loader_alive()) {\n+    InstanceKlass* ikls = Atomic::load_acquire(ik);\n+    if (ikls != NULL && !ikls->is_loader_alive()) {\n@@ -1372,1 +1372,1 @@\n-      return kls;\n+      return ikls;\n@@ -1378,1 +1378,1 @@\n-void InstanceKlass::set_implementor(Klass* k) {\n+void InstanceKlass::set_implementor(InstanceKlass* ik) {\n@@ -1381,1 +1381,1 @@\n-  Klass* volatile* addr = adr_implementor();\n+  InstanceKlass* volatile* addr = adr_implementor();\n@@ -1384,1 +1384,1 @@\n-    Atomic::release_store(addr, k);\n+    Atomic::release_store(addr, ik);\n@@ -1389,2 +1389,2 @@\n-  Klass* k = implementor();\n-  if (k == NULL) {\n+  InstanceKlass* ik = implementor();\n+  if (ik == NULL) {\n@@ -1392,1 +1392,1 @@\n-  } else if (k != this) {\n+  } else if (ik != this) {\n@@ -1408,1 +1408,1 @@\n-void InstanceKlass::add_implementor(Klass* k) {\n+void InstanceKlass::add_implementor(InstanceKlass* ik) {\n@@ -1415,1 +1415,1 @@\n-  if (InstanceKlass::cast(k)->is_interface()) return;\n+  if (ik->is_interface()) return;\n@@ -1420,2 +1420,2 @@\n-  Klass* sk = k->super();\n-  if (sk != NULL && InstanceKlass::cast(sk)->implements_interface(this))\n+  InstanceKlass* super_ik = ik->java_super();\n+  if (super_ik != NULL && super_ik->implements_interface(this))\n@@ -1427,4 +1427,4 @@\n-  Klass* ik = implementor();\n-  if (ik == NULL) {\n-    set_implementor(k);\n-  } else if (ik != this && ik != k) {\n+  InstanceKlass* iklass = implementor();\n+  if (iklass == NULL) {\n+    set_implementor(ik);\n+  } else if (iklass != this && iklass != ik) {\n@@ -1438,1 +1438,1 @@\n-    InstanceKlass::cast(local_interfaces()->at(index))->add_implementor(k);\n+    local_interfaces()->at(index)->add_implementor(ik);\n@@ -1453,1 +1453,1 @@\n-    InstanceKlass* interf = InstanceKlass::cast(local_interfaces()->at(i));\n+    InstanceKlass* interf = local_interfaces()->at(i);\n@@ -2490,1 +2490,1 @@\n-      Klass* impl = Atomic::load_acquire(adr_implementor());\n+      InstanceKlass* impl = Atomic::load_acquire(adr_implementor());\n@@ -2492,3 +2492,3 @@\n-        \/\/ NULL this field, might be an unloaded klass or NULL\n-        Klass* volatile* klass = adr_implementor();\n-        if (Atomic::cmpxchg(klass, impl, (Klass*)NULL) == impl) {\n+        \/\/ NULL this field, might be an unloaded instance klass or NULL\n+        InstanceKlass* volatile* iklass = adr_implementor();\n+        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)NULL) == impl) {\n@@ -4472,0 +4472,21 @@\n+\n+\/\/ Make a step iterating over the class hierarchy under the root class.\n+\/\/ Skips subclasses if requested.\n+void ClassHierarchyIterator::next() {\n+  assert(_current != NULL, \"required\");\n+  if (_visit_subclasses && _current->subklass() != NULL) {\n+    _current = _current->subklass();\n+    return; \/\/ visit next subclass\n+  }\n+  _visit_subclasses = true; \/\/ reset\n+  while (_current->next_sibling() == NULL && _current != _root) {\n+    _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+  }\n+  if (_current == _root) {\n+    \/\/ Iteration is over (back at root after backtracking). Invalidate the iterator.\n+    _current = NULL;\n+    return;\n+  }\n+  _current = _current->next_sibling();\n+  return; \/\/ visit next sibling subclass\n+}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":47,"deletions":26,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-  \/\/   iterface. The possible values of the implementor fall into following\n+  \/\/   interface. The possible values of the implementor fall into following\n@@ -1142,2 +1142,2 @@\n-  Klass* implementor() const;\n-  void set_implementor(Klass* k);\n+  InstanceKlass* implementor() const;\n+  void set_implementor(InstanceKlass* ik);\n@@ -1145,1 +1145,1 @@\n-  void add_implementor(Klass* k);  \/\/ k is a new class that implements this interface\n+  void add_implementor(InstanceKlass* ik);  \/\/ ik is a new class that implements this interface\n@@ -1219,1 +1219,1 @@\n-  inline Klass* volatile* adr_implementor() const;\n+  inline InstanceKlass* volatile* adr_implementor() const;\n@@ -1570,0 +1570,37 @@\n+\/\/ Iterator over class hierarchy under a particular class. Implements depth-first pre-order traversal.\n+\/\/ Usage:\n+\/\/  for (ClassHierarchyIterator iter(root_klass); !iter.done(); iter.next()) {\n+\/\/    Klass* k = iter.klass();\n+\/\/    ...\n+\/\/  }\n+class ClassHierarchyIterator : public StackObj {\n+ private:\n+  InstanceKlass* _root;\n+  Klass*         _current;\n+  bool           _visit_subclasses;\n+\n+ public:\n+  ClassHierarchyIterator(InstanceKlass* root) : _root(root), _current(root), _visit_subclasses(true) {\n+    assert(!root->is_interface(), \"no subclasses\");\n+    assert(_root == _current, \"required\"); \/\/ initial state\n+  }\n+\n+  bool done() {\n+    return (_current == NULL);\n+  }\n+\n+  \/\/ Make a step iterating over the class hierarchy under the root class.\n+  \/\/ Skips subclasses if requested.\n+  void next();\n+\n+  Klass* klass() {\n+    assert(!done(), \"sanity\");\n+    return _current;\n+  }\n+\n+  \/\/ Skip subclasses of the current class.\n+  void skip_subclasses() {\n+    _visit_subclasses = false;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-inline Klass* volatile* InstanceKlass::adr_implementor() const {\n+inline InstanceKlass* volatile* InstanceKlass::adr_implementor() const {\n@@ -79,1 +79,1 @@\n-    return (Klass* volatile*)end_of_nonstatic_oop_maps();\n+    return (InstanceKlass* volatile*)end_of_nonstatic_oop_maps();\n@@ -105,1 +105,1 @@\n-    Klass* volatile* adr_impl = adr_implementor();\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n@@ -128,1 +128,1 @@\n-    Klass* volatile* adr_impl = adr_implementor();\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -927,1 +927,1 @@\n-    return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;\n+    return SystemDictionary::find_instance_klass(klass_name, loader, prot) != NULL;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,5 +193,0 @@\n-\n-  MergeMemNode* mem = phase->transform(MergeMemNode::make(in_mem))->as_MergeMem();\n-  phase->record_for_igvn(mem);\n-\n-\n@@ -203,0 +198,7 @@\n+  MergeMemNode* mem = phase->transform(MergeMemNode::make(in_mem))->as_MergeMem();\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  phase->record_for_igvn(mem);\n+  if (igvn != NULL) {\n+    igvn->_worklist.push(mem);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5284,1 +5284,1 @@\n-void Compile::add_native_invoker(BufferBlob* stub) {\n+void Compile::add_native_invoker(RuntimeStub* stub) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-  GrowableArray<BufferBlob*>    _native_invokers;\n+  GrowableArray<RuntimeStub*>   _native_invokers;\n@@ -976,1 +976,1 @@\n-  void add_native_invoker(BufferBlob* stub);\n+  void add_native_invoker(RuntimeStub* stub);\n@@ -978,1 +978,1 @@\n-  const GrowableArray<BufferBlob*>& native_invokers() const { return _native_invokers; }\n+  const GrowableArray<RuntimeStub*> native_invokers() const { return _native_invokers; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/metaspace.hpp\"\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2742,3 +2742,3 @@\n-    BufferBlob* invoker = SharedRuntime::make_native_invoker(call_addr,\n-                                                             nep->shadow_space(),\n-                                                             arg_regs, ret_regs);\n+    RuntimeStub* invoker = SharedRuntime::make_native_invoker(call_addr,\n+                                                              nep->shadow_space(),\n+                                                              arg_regs, ret_regs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -887,2 +887,0 @@\n-    \/\/ this test was canonicalized\n-    assert(this_bool->_test.is_less() && fail->_con, \"incorrect test\");\n@@ -925,1 +923,1 @@\n-      assert(false, \"unhandled hi_test: %d\", hi_test);\n+      assert(igvn->_worklist.member(in(1)) && in(1)->Value(igvn) != igvn->type(in(1)), \"unhandled hi_test: %d\", hi_test);\n@@ -928,0 +926,2 @@\n+    \/\/ this test was canonicalized\n+    assert(this_bool->_test.is_less() && fail->_con, \"incorrect test\");\n@@ -954,2 +954,0 @@\n-    \/\/ this test was canonicalized\n-    assert(this_bool->_test.is_less() && !fail->_con, \"incorrect test\");\n@@ -983,1 +981,1 @@\n-      assert(false, \"unhandled lo_test: %d\", lo_test);\n+      assert(igvn->_worklist.member(in(1)) && in(1)->Value(igvn) != igvn->type(in(1)), \"unhandled lo_test: %d\", lo_test);\n@@ -986,0 +984,2 @@\n+    \/\/ this test was canonicalized\n+    assert(this_bool->_test.is_less() && !fail->_con, \"incorrect test\");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -4421,1 +4422,1 @@\n-void TypeInstPtr::dump2( Dict &d, uint depth, outputStream *st ) const {\n+void TypeInstPtr::dump2(Dict &d, uint depth, outputStream* st) const {\n@@ -4427,2 +4428,10 @@\n-    \/\/ TO DO: Make CI print the hex address of the underlying oop.\n-      const_oop()->print_oop(st);\n+      ResourceMark rm;\n+      stringStream ss;\n+\n+      st->print(\" \");\n+      const_oop()->print_oop(&ss);\n+      \/\/ 'const_oop->print_oop()' may emit newlines('\\n') into ss.\n+      \/\/ suppress newlines from it so -XX:+Verbose -XX:+PrintIdeal dumps one-liner for each node.\n+      char* buf = ss.as_string(\/* c_heap= *\/false);\n+      StringUtils::replace_no_expand(buf, \"\\n\", \"\");\n+      st->print_raw(buf);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1096,2 +1096,1 @@\n-                                                              Handle(),\n-                                                              CHECK_NULL);\n+                                                              Handle());\n@@ -3006,2 +3005,0 @@\n-  \/\/ A nested ThreadsListHandle will grab the Threads_lock so create\n-  \/\/ tlh before we resolve throwable.\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\n-\n@@ -50,1 +48,1 @@\n-#include \"memory\/metaspaceShared.hpp\"\n+#include \"memory\/iterator.hpp\"\n@@ -54,1 +52,3 @@\n-#include \"memory\/iterator.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n@@ -57,1 +57,0 @@\n-#include \"memory\/oopFactory.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -933,1 +933,1 @@\n-  static InstanceKlass* find_cache_klass(Symbol* klass_name, TRAPS) {\n+  static InstanceKlass* find_cache_klass(Symbol* klass_name) {\n@@ -936,3 +936,2 @@\n-    Klass* k = SystemDictionary::find(klass_name, Handle(), Handle(), THREAD);\n-    guarantee(k != NULL, \"%s must be loaded\", klass_name_str);\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(klass_name, Handle(), Handle());\n+    guarantee(ik != NULL, \"%s must be loaded\", klass_name_str);\n@@ -952,1 +951,1 @@\n-    InstanceKlass* ik = BoxCacheBase<CacheType>::find_cache_klass(CacheType::symbol(), thread);\n+    InstanceKlass* ik = BoxCacheBase<CacheType>::find_cache_klass(CacheType::symbol());\n@@ -1008,1 +1007,1 @@\n-    InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol(), thread);\n+    InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1491,1 +1491,1 @@\n-  product_pd(size_t, MetaspaceSize,                                         \\\n+  product(size_t, MetaspaceSize, NOT_LP64(16 * M) LP64_ONLY(21 * M),        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,4 +554,6 @@\n-  static BufferBlob* make_native_invoker(address call_target,\n-                                         int shadow_space_bytes,\n-                                         const GrowableArray<VMReg>& input_registers,\n-                                         const GrowableArray<VMReg>& output_registers);\n+#ifdef COMPILER2\n+  static RuntimeStub* make_native_invoker(address call_target,\n+                                          int shadow_space_bytes,\n+                                          const GrowableArray<VMReg>& input_registers,\n+                                          const GrowableArray<VMReg>& output_registers);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -408,1 +408,1 @@\n-    k = SystemDictionary::find(name, class_loader, protection_domain, CHECK_NULL);\n+    k = SystemDictionary::find_instance_klass(name, class_loader, protection_domain);\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -486,0 +486,44 @@\n+\/\/ Is the target JavaThread protected by the calling Thread\n+\/\/ or by some other mechanism:\n+bool Thread::is_JavaThread_protected(const JavaThread* p) {\n+  \/\/ Do the simplest check first:\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    \/\/ The target is protected since JavaThreads cannot exit\n+    \/\/ while we're at a safepoint.\n+    return true;\n+  }\n+\n+  \/\/ Now make the simple checks based on who the caller is:\n+  Thread* current_thread = Thread::current();\n+  if (current_thread == p || Threads_lock->owner() == current_thread) {\n+    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+    \/\/ but we already have the current thread so check directly.\n+    return true;\n+  }\n+\n+  \/\/ Check the ThreadsLists associated with the calling thread (if any)\n+  \/\/ to see if one of them protects the target JavaThread:\n+  for (SafeThreadsListPtr* stlp = current_thread->_threads_list_ptr;\n+       stlp != NULL; stlp = stlp->previous()) {\n+    if (stlp->list()->includes(p)) {\n+      \/\/ The target JavaThread is protected by this ThreadsList:\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+\n+  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+  \/\/ we'll be able to figure out what protection mechanism is missing.\n+  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+         \" is not protected and not handshake safe.\", p2i(p));\n+\n+  \/\/ The target JavaThread is not protected so it is not safe to query:\n+  return false;\n+}\n+\n@@ -907,3 +951,1 @@\n-static const char* get_java_version(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+static const char* get_java_version(InstanceKlass* ik) {\n@@ -911,3 +953,3 @@\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_version_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n+  bool found = ik != NULL &&\n+               ik->find_local_field(vmSymbols::java_version_name(),\n+                                    vmSymbols::string_signature(), &fd);\n@@ -915,1 +957,1 @@\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n@@ -929,3 +971,1 @@\n-static const char* get_java_runtime_name(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+static const char* get_java_runtime_name(InstanceKlass* ik) {\n@@ -933,3 +973,3 @@\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_name_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n+  bool found = ik != NULL &&\n+               ik->find_local_field(vmSymbols::java_runtime_name_name(),\n+                                    vmSymbols::string_signature(), &fd);\n@@ -937,1 +977,1 @@\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n@@ -951,3 +991,1 @@\n-static const char* get_java_runtime_version(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+static const char* get_java_runtime_version(InstanceKlass* ik) {\n@@ -955,3 +993,3 @@\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_version_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n+  bool found = ik != NULL &&\n+               ik->find_local_field(vmSymbols::java_runtime_version_name(),\n+                                    vmSymbols::string_signature(), &fd);\n@@ -959,1 +997,1 @@\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n@@ -973,3 +1011,1 @@\n-static const char* get_java_runtime_vendor_version(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+static const char* get_java_runtime_vendor_version(InstanceKlass* ik) {\n@@ -977,3 +1013,3 @@\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_vendor_version_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n+  bool found = ik != NULL &&\n+               ik->find_local_field(vmSymbols::java_runtime_vendor_version_name(),\n+                                    vmSymbols::string_signature(), &fd);\n@@ -981,1 +1017,1 @@\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n@@ -995,3 +1031,1 @@\n-static const char* get_java_runtime_vendor_vm_bug_url(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+static const char* get_java_runtime_vendor_vm_bug_url(InstanceKlass* ik) {\n@@ -999,3 +1033,3 @@\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_vendor_vm_bug_url_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n+  bool found = ik != NULL &&\n+               ik->find_local_field(vmSymbols::java_runtime_vendor_vm_bug_url_name(),\n+                                    vmSymbols::string_signature(), &fd);\n@@ -1003,1 +1037,1 @@\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n@@ -2523,1 +2557,1 @@\n-\/\/ seen prior to having it's threadObj set (eg JNI attaching threads and\n+\/\/ seen prior to having its threadObj set (e.g., JNI attaching threads and\n@@ -2527,8 +2561,3 @@\n-#ifdef ASSERT\n-  \/\/ early safepoints can hit while current thread does not yet have TLS\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ Current JavaThreads are allowed to get their own name without\n-    \/\/ the Threads_lock.\n-    if (Thread::current() != this) {\n-      assert_locked_or_safepoint_or_handshake(Threads_lock, this);\n-    }\n+  if (Thread::is_JavaThread_protected(this)) {\n+    \/\/ The target JavaThread is protected so get_thread_name_string() is safe:\n+    return get_thread_name_string();\n@@ -2536,2 +2565,3 @@\n-#endif \/\/ ASSERT\n-  return get_thread_name_string();\n+\n+  \/\/ The target JavaThread is not protected so we return the default:\n+  return Thread::name();\n@@ -3026,5 +3056,7 @@\n-  JDK_Version::set_java_version(get_java_version(THREAD));\n-  JDK_Version::set_runtime_name(get_java_runtime_name(THREAD));\n-  JDK_Version::set_runtime_version(get_java_runtime_version(THREAD));\n-  JDK_Version::set_runtime_vendor_version(get_java_runtime_vendor_version(THREAD));\n-  JDK_Version::set_runtime_vendor_vm_bug_url(get_java_runtime_vendor_vm_bug_url(THREAD));\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(vmSymbols::java_lang_VersionProps(),\n+                                                            Handle(), Handle());\n+  JDK_Version::set_java_version(get_java_version(ik));\n+  JDK_Version::set_runtime_name(get_java_runtime_name(ik));\n+  JDK_Version::set_runtime_version(get_java_runtime_version(ik));\n+  JDK_Version::set_runtime_vendor_version(get_java_runtime_vendor_version(ik));\n+  JDK_Version::set_runtime_vendor_vm_bug_url(get_java_runtime_vendor_vm_bug_url(ik));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":83,"deletions":51,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -204,0 +204,4 @@\n+  \/\/ Is the target JavaThread protected by the calling Thread\n+  \/\/ or by some other mechanism:\n+  static bool is_JavaThread_protected(const JavaThread* p);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -326,2 +326,2 @@\n-    ex->print();                           \\\n-    ShouldNotReachHere();                  \\\n+    DEBUG_ONLY(ex->print();)               \\\n+    assert(false, \"CATCH\");                \\\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2071,1 +2071,7 @@\n-                        ret = new VarSymbol(sym.flags() & FINAL, sym.name, sym.type, translatedSym);\n+                        ret = new VarSymbol(sym.flags() & FINAL, sym.name, sym.type, translatedSym) {\n+                            @Override\n+                            public Symbol baseSymbol() {\n+                                \/\/keep mapping with original symbol\n+                                return sym;\n+                            }\n+                        };\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1220,1 +1220,1 @@\n-                Symbol translatedSym = lambdaTranslationMap.get(sym);\n+                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n@@ -3925,1 +3925,3 @@\n-                return make.Block(0L, stmtList.toList());\n+                JCBlock res = make.Block(0L, stmtList.toList());\n+                res.endpos = TreeInfo.endPos(tree);\n+                return res;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2905,0 +2905,1 @@\n+            t.endpos = token.endPos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1285,0 +1285,2 @@\n+        \/** Position of closing brace, optional. *\/\n+        public int endpos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,0 +433,3 @@\n+        } else if (tree.hasTag(SWITCH) &&\n+                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n+            return ((JCSwitch) tree).endpos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -770,1 +770,7 @@\n-            public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {\n+            public StringBuilder visitPrimitive(PrimitiveType t, Void p) {\n+                sb.append(t.getKind().toString().toLowerCase(Locale.ROOT));\n+                return sb;\n+            }\n+\n+            @Override\n+            public StringBuilder visitTypeVariable(TypeVariable t, Void p) {\n@@ -777,1 +783,1 @@\n-            public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {\n+            public StringBuilder visitWildcard(WildcardType t, Void p) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -232,0 +232,2 @@\n+            } catch (IllegalStateException e) {\n+                report(\"Invalid value for Signature attribute: \" + e.getMessage());\n@@ -503,1 +505,1 @@\n-            } catch (ConstantPoolException e) {\n+            } catch (ConstantPoolException | IllegalStateException e) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,2 +165,0 @@\n-runtime\/NMT\/CheckForProperDetailStackTrace.java 8261520 generic-all\n-containers\/docker\/TestJFRWithJMX.java 8256417 linux-5.4.17-2011.5.3.el8uek.x86_64\n@@ -197,0 +195,1 @@\n+resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}