{"files":[{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8287136\n- * @summary [lw4] Javac tolerates abstract value classes that violate constraints for qualifying to be value super classes\n- * @compile\/fail\/ref=AbstractValueClassConstraints.out -XDrawDiagnostics AbstractValueClassConstraints.java\n- *\/\n-\n-public class AbstractValueClassConstraints {\n-\n-    static abstract value class V1 {\n-        int f;  \/\/ Error, abstract value class may not declare an instance field.\n-    }\n-\n-    abstract value class V2 {\n-        \/\/ Error, an abstract value class may not have an enclosing instance.\n-    }\n-\n-    static abstract value class V3 {\n-        synchronized void foo() {\n-         \/\/ Error, abstract value class may not declare a synchronized instance method.\n-        }\n-    }\n-\n-    static abstract value class V4 {\n-        { int f = 42; } \/\/ Error, abstract value class may not declare an instance initializer.\n-    }\n-\n-    static abstract value class V5 {\n-        V5(int x) {}  \/\/ Error, abstract value class may not declare a non-trivial constructor.\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AbstractValueClassConstraints.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-AbstractValueClassConstraints.java:44:27: compiler.err.mod.not.allowed.here: synchronized\n-AbstractValueClassConstraints.java:35:27: compiler.err.super.field.not.allowed: f, (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V1)\n-AbstractValueClassConstraints.java:39:20: compiler.err.super.class.cannot.be.inner: (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V2)\n-AbstractValueClassConstraints.java:49:27: compiler.err.super.class.declares.init.block: (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V4)\n-AbstractValueClassConstraints.java:53:27: compiler.err.super.constructor.cannot.take.arguments: AbstractValueClassConstraints.V5(int), (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V5)\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AbstractValueClassConstraints.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * @test\n- * @bug 8292630\n- * @summary [lworld] javac is accepting annotation interface declarations with modifiers: identity and value\n- * @compile\/fail\/ref=AnnotationsConstraints.out -XDrawDiagnostics AnnotationsConstraints.java\n- *\/\n-\n-public class AnnotationsConstraints {\n-    \/\/ annotations can't have the `identity`\n-    identity @interface IA {}\n-    \/\/ nor the `value` modifiers\n-    value @interface VA {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnnotationsConstraints.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-AnnotationsConstraints.java:10:15: compiler.err.illegal.combination.of.modifiers: identity, annotation\n-AnnotationsConstraints.java:12:12: compiler.err.illegal.combination.of.modifiers: value, annotation\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnnotationsConstraints.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8279368\n- * @summary Add parser support for value classes\n- * @compile\/fail\/ref=CheckFeatureSourceLevel.out --release=13 -XDrawDiagnostics CheckFeatureSourceLevel.java\n- *\/\n-\n-public class CheckFeatureSourceLevel {\n-\n-    static value class Value {\n-        public int v = 42;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckFeatureSourceLevel.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckFeatureSourceLevel.java:10:12: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.value.classes), 13, 18\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckFeatureSourceLevel.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8279901\n- * @summary Javac should verify\/ensure that a Functional interface proclaims neither identity nor valueness\n- * @compile\/fail\/ref=FunctionalInterfaceTest.out -XDrawDiagnostics -XDdev FunctionalInterfaceTest.java\n- *\/\n-\n-public class FunctionalInterfaceTest {\n-\n-    @FunctionalInterface\n-    identity interface I { \/\/ Error\n-        void m();\n-    }\n-\n-    @FunctionalInterface\n-    interface J extends I  {} \/\/ Error.\n-\n-    @FunctionalInterface\n-    value interface K { \/\/ Error\n-        void m();\n-    }\n-\n-    identity interface L {\n-        void m();\n-    }\n-\n-    value interface M {\n-        void m();\n-    }\n-\n-    void foo() {\n-        var t = (L) () -> {}; \/\/ Error\n-        var u = (M) () -> {}; \/\/ Error\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FunctionalInterfaceTest.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-FunctionalInterfaceTest.java:10:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.I, (compiler.misc.identity.interface.nonfunctional))\n-FunctionalInterfaceTest.java:15:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.J, (compiler.misc.identity.interface.nonfunctional))\n-FunctionalInterfaceTest.java:18:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.K, (compiler.misc.value.interface.nonfunctional))\n-FunctionalInterfaceTest.java:32:21: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.L, (compiler.misc.identity.interface.nonfunctional))\n-FunctionalInterfaceTest.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.M, (compiler.misc.value.interface.nonfunctional))\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FunctionalInterfaceTest.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8279840\n- * @summary [lworld] Inconsistent treatment of repeated modifiers.\n- * @compile\/fail\/ref=ModifiersTest.out -XDrawDiagnostics -XDdev ModifiersTest.java\n- *\/\n-\n-public class ModifiersTest {\n-\n-    static static class StaticTest {\n-    }\n-\n-    native native class NativeTest {\n-    }\n-\n-    value value primitive class ValueTest {\n-    }\n-\n-    primitive primitive value class PrimitiveTest {\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ModifiersTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ModifiersTest.java:10:12: compiler.err.repeated.modifier\n-ModifiersTest.java:13:12: compiler.err.repeated.modifier\n-ModifiersTest.java:16:11: compiler.err.repeated.modifier\n-ModifiersTest.java:19:15: compiler.err.repeated.modifier\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ModifiersTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8287767\n- * @summary [lw4] Javac tolerates mutually incompatible super types.\n- * @compile\/fail\/ref=MutuallyIncompatibleSupers.out -XDrawDiagnostics -XDdev MutuallyIncompatibleSupers.java\n- *\/\n-\n-public class MutuallyIncompatibleSupers {\n-\n-    identity interface II {}\n-    value interface VI {}\n-\n-    static abstract class X implements II, VI {} \/\/ mutually incompatible supers.\n-\n-    interface GII extends II {} \/\/ OK.\n-    value interface BVI extends GII {} \/\/ Error\n-\n-    interface GVI extends VI {} \/\/ OK.\n-    identity interface BII extends GVI {} \/\/ Error\n-\n-    static value class BVC implements II {} \/\/ Error\n-    class BIC implements VI {} \/\/ Error\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/MutuallyIncompatibleSupers.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-MutuallyIncompatibleSupers.java:13:21: compiler.err.mutually.incompatible.supers: MutuallyIncompatibleSupers.X, MutuallyIncompatibleSupers.II, MutuallyIncompatibleSupers.VI\n-MutuallyIncompatibleSupers.java:16:11: compiler.err.value.type.has.identity.super.type: MutuallyIncompatibleSupers.BVI, MutuallyIncompatibleSupers.II\n-MutuallyIncompatibleSupers.java:19:14: compiler.err.identity.type.has.value.super.type: MutuallyIncompatibleSupers.BII, MutuallyIncompatibleSupers.VI\n-MutuallyIncompatibleSupers.java:21:18: compiler.err.value.type.has.identity.super.type: MutuallyIncompatibleSupers.BVC, MutuallyIncompatibleSupers.II\n-MutuallyIncompatibleSupers.java:22:5: compiler.err.identity.type.has.value.super.type: MutuallyIncompatibleSupers.BIC, MutuallyIncompatibleSupers.VI\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/MutuallyIncompatibleSupers.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8287763\n- * @summary [lw4] Javac does not implement the spec for non-trivial constructors in toto\n- * @compile\/fail\/ref=NontrivialConstructor.out -XDrawDiagnostics -XDdev NontrivialConstructor.java\n- *\/\n-\n-public class NontrivialConstructor {\n-\n-    abstract static value class I0 {\n-        public I0() { \/\/ trivial ctor.\n-        }\n-    }\n-\n-    abstract static value class I1 {\n-        private I1() {} \/\/ non-trivial, more restrictive access than the class.\n-    }\n-\n-    abstract static value class I2 {\n-        public I2(int x) {} \/\/ non-trivial ctor as it declares formal parameters.\n-    }\n-\n-    abstract static value class I3 {\n-        <T> I3() {} \/\/ non trivial as it declares type parameters.\n-    }\n-\n-\n-    abstract static value class I4 {\n-        I4() throws Exception {} \/\/ non-trivial as it throws\n-    }\n-\n-    abstract static value class I5 {\n-        I5() {\n-            System.out.println(\"\");\n-        } \/\/ non-trivial as it has a body.\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NontrivialConstructor.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-NontrivialConstructor.java:15:27: compiler.err.super.constructor.access.restricted: NontrivialConstructor.I1(), (compiler.misc.abstract.value.class: NontrivialConstructor.I1)\n-NontrivialConstructor.java:19:27: compiler.err.super.constructor.cannot.take.arguments: NontrivialConstructor.I2(int), (compiler.misc.abstract.value.class: NontrivialConstructor.I2)\n-NontrivialConstructor.java:23:27: compiler.err.super.constructor.cannot.be.generic: <T>NontrivialConstructor.I3(), (compiler.misc.abstract.value.class: NontrivialConstructor.I3)\n-NontrivialConstructor.java:28:27: compiler.err.super.constructor.cannot.throw: NontrivialConstructor.I4(), (compiler.misc.abstract.value.class: NontrivialConstructor.I4)\n-NontrivialConstructor.java:32:27: compiler.err.super.no.arg.constructor.must.be.empty: NontrivialConstructor.I5(), (compiler.misc.abstract.value.class: NontrivialConstructor.I5)\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NontrivialConstructor.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8279672 8292753\n- * @summary Implement semantic checks for value classes\n- * @compile\/fail\/ref=SemanticsViolationsTest.out -XDrawDiagnostics --should-stop=at=FLOW -XDdev SemanticsViolationsTest.java\n- *\/\n-\n-public class SemanticsViolationsTest {\n-\n-    \/\/ A value class is implicitly final, so cannot be extended.\n-    value class Base {}\n-    class Subclass extends Base {} \/\/ Error: Base is implicitly final, cannot be extended.\n-\n-\n-\n-    abstract value class AbsValue {}  \/\/ Error: value class inner\n-    value interface ValueInterface {} \/\/ Error: interface cannot modified with value.\n-\n-    \/\/ All instance fields are implicitly final, so must be assigned exactly\n-    \/\/ once by constructors or initializers, and cannot be assigned outside\n-    \/\/ of a constructor or initializer.\n-    value class Point {\n-\n-        int x = 10;\n-        int y;\n-        int z;\n-\n-        Point (int x, int y, int z) {\n-            this.x = x; \/\/ Error, final field 'x' is already assigned to.\n-            this.y = y; \/\/ OK.\n-            \/\/ Error, final z is unassigned.\n-        }\n-        void foo(Point p) {\n-            this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n-        }\n-    }\n-\n-\n-    \/\/ A value identity class is an oxymoron\n-    value identity class IdentityValue { \/\/ Error, bad modifier combination.\n-    }\n-    value class IdentityValue2 extends SemanticsViolationsTest { \/\/ Error, can't extend identity class\n-    }\n-    abstract static class AbstractWithState {\n-       int xx;\n-    }\n-    value class BrokenValue3 extends AbstractWithState { \/\/ Error, super class has state.\n-    }\n-    abstract static class AbstractWithoutState {\n-        static int ss;\n-    }\n-    value class GoodValue1 extends AbstractWithoutState {}\n-    value class GoodValue2 extends Object {} \/\/ allowed.\n-\n-    \/\/ No constructor makes a super constructor call. Instance creation will\n-    \/\/ occur without executing any superclass initialization code.\n-    value class BrokenValue4 {\n-        BrokenValue4() {\n-            super(); \/\/ Error, can't chain to super's ctor.\n-        }\n-    }\n-\n-    \/\/ No instance methods are declared synchronized.\n-    value class BrokenValue5 {\n-        synchronized void foo() {} \/\/ Error;\n-        synchronized static void soo() {} \/\/ OK.\n-        { synchronized(this) { \/* Error.*\/  } }\n-    }\n-\n-    \/\/ The class does not declare a finalize() method.\n-    value class BrokenValue6 {\n-        public void finalize() {} \/\/ Error\n-    }\n-\n-    \/\/ (Possibly) The constructor does not make use of this except to set\n-    \/\/ the fields in the constructor body, or perhaps after all fields are\n-    \/\/ definitely assigned.\n-    value class BrokenValue7 {\n-        int x;\n-        BrokenValue7() {\n-            foo(this); \/\/ Error.\n-            x = 10;\n-            foo(this); \/\/ Ok.\n-        }\n-        void foo(BrokenValue7 bv) {\n-        }\n-    }\n-\n-    value record BrokenValue8(int x, int y) {\n-        synchronized void foo() { } \/\/ Error;\n-        synchronized static void soo() {} \/\/ OK.\n-    }\n-\n-    \/\/ another set of test cases considering type variables and intersections\n-    interface I {}\n-\n-    value interface VI extends I {}\n-\n-    class C {}\n-\n-    value class VC<T extends VC> {\n-        void m(T t) {\n-            synchronized(t) {} \/\/ error\n-        }\n-\n-        void foo(Object o) {\n-            synchronized ((VC & I)o) {} \/\/ error\n-        }\n-\n-        void bar(Object o) {\n-            synchronized ((I & VI)o) {} \/\/ error\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-SemanticsViolationsTest.java:40:20: compiler.err.illegal.combination.of.modifiers: identity, value\n-SemanticsViolationsTest.java:12:28: compiler.err.cant.inherit.from.final: SemanticsViolationsTest.Base\n-SemanticsViolationsTest.java:65:27: compiler.err.mod.not.allowed.here: synchronized\n-SemanticsViolationsTest.java:90:27: compiler.err.mod.not.allowed.here: synchronized\n-SemanticsViolationsTest.java:12:5: compiler.err.identity.type.has.value.super.type: SemanticsViolationsTest.Subclass, SemanticsViolationsTest.Base\n-SemanticsViolationsTest.java:16:20: compiler.err.super.class.cannot.be.inner: (compiler.misc.abstract.value.class: SemanticsViolationsTest.AbsValue)\n-SemanticsViolationsTest.java:29:17: compiler.err.cant.assign.val.to.final.var: x\n-SemanticsViolationsTest.java:34:17: compiler.err.cant.assign.val.to.final.var: y\n-SemanticsViolationsTest.java:42:11: compiler.err.concrete.supertype.for.value.class: SemanticsViolationsTest.IdentityValue2, SemanticsViolationsTest\n-SemanticsViolationsTest.java:47:11: compiler.err.super.field.not.allowed: xx, (compiler.misc.superclass.of.value.class: SemanticsViolationsTest.BrokenValue3, SemanticsViolationsTest.AbstractWithState)\n-SemanticsViolationsTest.java:59:13: compiler.err.call.to.super.not.allowed.in.value.ctor\n-SemanticsViolationsTest.java:67:11: compiler.err.type.found.req: SemanticsViolationsTest.BrokenValue5, (compiler.misc.type.req.identity)\n-SemanticsViolationsTest.java:72:21: compiler.warn.has.been.deprecated.for.removal: finalize(), java.lang.Object\n-SemanticsViolationsTest.java:103:13: compiler.err.type.found.req: SemanticsViolationsTest.VC, (compiler.misc.type.req.identity)\n-SemanticsViolationsTest.java:107:13: compiler.err.type.found.req: SemanticsViolationsTest.VC, (compiler.misc.type.req.identity)\n-SemanticsViolationsTest.java:111:13: compiler.err.type.found.req: SemanticsViolationsTest.VI, (compiler.misc.type.req.identity)\n-SemanticsViolationsTest.java:32:9: compiler.err.var.might.not.have.been.initialized: z\n-SemanticsViolationsTest.java:81:17: compiler.err.this.exposed.prematurely\n-SemanticsViolationsTest.java:81:16: compiler.err.this.exposed.prematurely\n-18 errors\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.out","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8279368\n- * @summary Add parser support for declaration of value classes\n- * @compile Substring.java\n- *\/\n-\n-public value class Substring implements CharSequence {\n-    private String str;\n-    private int start;\n-    private int end;\n-\n-    public Substring(String str, int start, int end) {\n-        checkBounds(start, end, str.length());\n-        this.str = str;\n-        this.start = start;\n-        this.end = end;\n-    }\n-\n-    public int length() {\n-        return end - start;\n-    }\n-\n-    public char charAt(int i) {\n-        checkBounds(0, i, length());\n-        return str.charAt(start + i);\n-    }\n-\n-    public Substring subSequence(int s, int e) {\n-        checkBounds(s, e, length());\n-        return new Substring(str, start + s, start + e);\n-    }\n-\n-    public String toString() {\n-        return str.substring(start, end);\n-    }\n-\n-    private static void checkBounds(int start, int end, int length) {\n-        if (start < 0 || end < start || length < end)\n-            throw new IndexOutOfBoundsException();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/Substring.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8287770\n- * @summary [lw4] Javac tolerates synchronizing on an instance of a value interface\n- * @compile\/fail\/ref=SynchronizeOnValueInterfaceInstance.out -XDrawDiagnostics -XDdev SynchronizeOnValueInterfaceInstance.java\n- *\/\n-\n-public value interface SynchronizeOnValueInterfaceInstance {\n-\n-    default void foo(SynchronizeOnValueInterfaceInstance sovii) {\n-        synchronized (sovii) {} \/\/ Error\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SynchronizeOnValueInterfaceInstance.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-SynchronizeOnValueInterfaceInstance.java:11:9: compiler.err.type.found.req: SynchronizeOnValueInterfaceInstance, (compiler.misc.type.req.identity)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SynchronizeOnValueInterfaceInstance.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8279368\n- * @summary Test that value classes can be declared using annotations instead of modifiers\n- * @compile\/fail\/ref=ValueAnnotationTest.out -XDrawDiagnostics -XDdev ValueAnnotationTest.java\n- *\/\n-\n-public class ValueAnnotationTest {\n-    @__value__ public class X {}\n-    @java.lang.__value__  public class Y extends X {}\n-    public class Z extends Y {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueAnnotationTest.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ValueAnnotationTest.java:10:50: compiler.err.cant.inherit.from.final: ValueAnnotationTest.X\n-ValueAnnotationTest.java:11:28: compiler.err.cant.inherit.from.final: ValueAnnotationTest.Y\n-ValueAnnotationTest.java:10:34: compiler.err.concrete.supertype.for.value.class: ValueAnnotationTest.Y, ValueAnnotationTest.X\n-ValueAnnotationTest.java:11:12: compiler.err.identity.type.has.value.super.type: ValueAnnotationTest.Z, ValueAnnotationTest.Y\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueAnnotationTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -0,0 +1,504 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * ValueObjectCompilationTests\n+ *\n+ * @test\n+ * @bug 8287136 8292630 8279368 8287136 8287770 8279840 8279672 8292753 8287763 8279901 8287767\n+ * @summary Negative compilation tests, and positive compilation (smoke) tests for Value Objects\n+ * @library \/lib\/combo \/tools\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.util\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run testng ValueObjectCompilationTests\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+\n+import java.io.File;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.SourceVersion;\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+@Test\n+public class ValueObjectCompilationTests extends CompilationTestCase {\n+\n+    ToolBox tb = new ToolBox();\n+\n+    public ValueObjectCompilationTests() {\n+        setDefaultFilename(\"ValueObjectsTest.java\");\n+    }\n+\n+    public void testAbstractValueClassConstraints() {\n+        assertFail(\"compiler.err.super.field.not.allowed\",\n+                \"\"\"\n+                abstract value class V {\n+                    int f;  \/\/ Error, abstract value class may not declare an instance field.\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.class.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    abstract value class V {\n+                        \/\/ Error, an abstract value class cant be an inner class\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                abstract value class V {\n+                    synchronized void foo() {\n+                     \/\/ Error, abstract value class may not declare a synchronized instance method.\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.class.declares.init.block\",\n+                \"\"\"\n+                abstract value class V {\n+                    { int f = 42; } \/\/ Error, abstract value class may not declare an instance initializer.\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.constructor.cannot.take.arguments\",\n+                \"\"\"\n+                abstract value class V {\n+                    V(int x) {}  \/\/ Error, abstract value class may not declare a non-trivial constructor.\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testAnnotationsConstraints() {\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n+                \"\"\"\n+                identity @interface IA {}\n+                \"\"\");\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n+                \"\"\"\n+                value @interface IA {}\n+                \"\"\");\n+    }\n+\n+    public void testCheckFeatureSourceLevel() {\n+        setCompileOptions(new String[]{\"--release\", \"13\"});\n+        assertFail(\"compiler.err.feature.not.supported.in.source.plural\",\n+                \"\"\"\n+                value class V {\n+                    public int v = 42;\n+                }\n+                \"\"\");\n+        setCompileOptions(new String[]{});\n+    }\n+\n+    public void testSuperClassConstraints() {\n+        assertFail(\"compiler.err.super.field.not.allowed\",\n+                \"\"\"\n+                abstract class I { \/\/ identity class since it declares an instance field.\n+                    int f;\n+                }\n+                value class V extends I {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.super.class.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    abstract class I { \/* has identity since is an inner class *\/ }\n+                    static value class V extends I\n+                }\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.super.method.cannot.be.synchronized\",\n+                \"\"\"\n+                abstract class I { \/\/ has identity since it declared a synchronized instance method.\n+                    synchronized void foo() {}\n+                }\n+                value class V extends I {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.super.class.declares.init.block\",\n+                \"\"\"\n+                abstract class I { \/\/ has identity since it declares an instance initializer\n+                    { int f = 42; }\n+                }\n+                value class V extends I {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.super.constructor.cannot.take.arguments\",\n+                \"\"\"\n+                abstract class I { \/\/ has identity since it declares a non-trivial constructor\n+                    I(int x) {}\n+                }\n+                value class V extends I {}\n+                \"\"\");\n+    }\n+\n+    public void testSynchronizeOnValueInterfaceInstance() {\n+        assertFail(\"compiler.err.type.found.req\",\n+                \"\"\"\n+                value interface VI {\n+                    default void foo(VI vi) {\n+                        synchronized (vi) {} \/\/ Error\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testRepeatedModifiers() {\n+        String[] sources = new String[] {\n+                \"static static class StaticTest {}\",\n+                \"native native class NativeTest {}\",\n+                \"value value primitive class ValueTest {}\",\n+                \"primitive primitive value class PrimitiveTest {}\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.repeated.modifier\", source);\n+        }\n+    }\n+\n+    public void testParserTest() {\n+        assertOK(\n+                \"\"\"\n+                value class Substring implements CharSequence {\n+                    private String str;\n+                    private int start;\n+                    private int end;\n+\n+                    public Substring(String str, int start, int end) {\n+                        checkBounds(start, end, str.length());\n+                        this.str = str;\n+                        this.start = start;\n+                        this.end = end;\n+                    }\n+\n+                    public int length() {\n+                        return end - start;\n+                    }\n+\n+                    public char charAt(int i) {\n+                        checkBounds(0, i, length());\n+                        return str.charAt(start + i);\n+                    }\n+\n+                    public Substring subSequence(int s, int e) {\n+                        checkBounds(s, e, length());\n+                        return new Substring(str, start + s, start + e);\n+                    }\n+\n+                    public String toString() {\n+                        return str.substring(start, end);\n+                    }\n+\n+                    private static void checkBounds(int start, int end, int length) {\n+                        if (start < 0 || end < start || length < end)\n+                            throw new IndexOutOfBoundsException();\n+                    }\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testSemanticsViolations() {\n+        assertFail(\"compiler.err.cant.inherit.from.final\",\n+                \"\"\"\n+                value class Base {}\n+                class Subclass extends Base {}\n+                \"\"\");\n+        assertFail(\"compiler.err.super.class.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    abstract value class AbsValue {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+                \"\"\"\n+                value class Point {\n+                    int x = 10;\n+                    int y;\n+                    Point (int x, int y) {\n+                        this.x = x; \/\/ Error, final field 'x' is already assigned to.\n+                        this.y = y; \/\/ OK.\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+                \"\"\"\n+                value class Point {\n+                    int x;\n+                    int y;\n+                    Point (int x, int y) {\n+                        this.x = x;\n+                        this.y = y;\n+                    }\n+\n+                    void foo(Point p) {\n+                        this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.var.might.not.have.been.initialized\",\n+                \"\"\"\n+                value class Point {\n+                    int x;\n+                    int y;\n+                    Point (int x, int y) {\n+                        this.x = x;\n+                        \/\/ y hasn't been initialized\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n+                \"\"\"\n+                value identity class IdentityValue {}\n+                \"\"\");\n+        assertFail(\"compiler.err.call.to.super.not.allowed.in.value.ctor\",\n+                \"\"\"\n+                value class V {\n+                    V() {\n+                        super();\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                value class V {\n+                    synchronized void foo() {}\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                value class V {\n+                    synchronized static void soo() {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.type.found.req\",\n+                \"\"\"\n+                value class V {\n+                    { synchronized(this) {} }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                value record R() {\n+                    synchronized void foo() { } \/\/ Error;\n+                    synchronized static void soo() {} \/\/ OK.\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.this.exposed.prematurely\",\n+                \"\"\"\n+                value class V {\n+                    int x;\n+                    V() {\n+                        foo(this); \/\/ Error.\n+                        x = 10;\n+                        foo(this); \/\/ Ok.\n+                    }\n+                    void foo(V v) {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.type.found.req\",\n+                \"\"\"\n+                interface I {}\n+                value interface VI extends I {}\n+                class C {}\n+                value class VC<T extends VC> {\n+                    void m(T t) {\n+                        synchronized(t) {} \/\/ error\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.type.found.req\",\n+                \"\"\"\n+                interface I {}\n+                value interface VI extends I {}\n+                class C {}\n+                value class VC<T extends VC> {\n+                    void foo(Object o) {\n+                        synchronized ((VC & I)o) {} \/\/ error\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.type.found.req\",\n+                \"\"\"\n+                interface I {}\n+                value interface VI extends I {}\n+                class C {}\n+                value class VC<T extends VC> {\n+                    void bar(Object o) {\n+                        synchronized ((I & VI)o) {} \/\/ error\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testNontrivialConstructor() {\n+        assertOK(\n+                \"\"\"\n+                abstract value class V {\n+                    public V() { \/* trivial ctor *\/ }\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.super.constructor.access.restricted\",\n+                \"\"\"\n+                abstract value class V {\n+                    private V() {} \/\/ non-trivial, more restrictive access than the class.\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.constructor.cannot.take.arguments\",\n+                \"\"\"\n+                abstract value class V {\n+                    public V(int x) {} \/\/ non-trivial ctor as it declares formal parameters.\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.constructor.cannot.be.generic\",\n+                \"\"\"\n+                abstract value class V {\n+                    <T> V() {} \/\/ non trivial as it declares type parameters.\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.constructor.cannot.throw\",\n+                \"\"\"\n+                abstract value class V {\n+                    V() throws Exception {} \/\/ non-trivial as it throws\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.super.no.arg.constructor.must.be.empty\",\n+                \"\"\"\n+                abstract value class V {\n+                    V() {\n+                        System.out.println(\"\");\n+                    } \/\/ non-trivial as it has a body.\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testFunctionalInterface() {\n+        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n+                \"\"\"\n+                @FunctionalInterface\n+                identity interface I { \/\/ Error\n+                    void m();\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n+                \"\"\"\n+                @FunctionalInterface\n+                value interface K { \/\/ Error\n+                    void m();\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                identity interface L {\n+                    void m();\n+                }\n+                class Test {\n+                    void foo() {\n+                        var t = (L) () -> {}; \/\/ Error\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                value interface M {\n+                    void m();\n+                }\n+                class Test {\n+                    void foo() {\n+                        var u = (M) () -> {}; \/\/ Error\n+                    }\n+                }\n+                \"\"\");\n+        \/\/ currently failing but should be accepted\n+        \/*\n+        assertOK(\n+                \"\"\"\n+                identity interface I {\n+                    void m();\n+                }\n+\n+                @FunctionalInterface\n+                interface J extends I  {}\n+                \"\"\");\n+        *\/\n+    }\n+\n+    public void testMutuallyIncompatibleSupers() {\n+        assertFail(\"compiler.err.mutually.incompatible.supers\",\n+                \"\"\"\n+                identity interface II {}\n+                value interface VI {}\n+                abstract class X implements II, VI {}\n+                \"\"\");\n+        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n+                \"\"\"\n+                identity interface II {}\n+                interface GII extends II {} \/\/ OK.\n+                value interface BVI extends GII {} \/\/ Error\n+                \"\"\");\n+        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n+                \"\"\"\n+                value interface VI {}\n+                interface GVI extends VI {} \/\/ OK.\n+                identity interface BII extends GVI {} \/\/ Error\n+                \"\"\");\n+        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n+                \"\"\"\n+                identity interface II {}\n+                value class BVC implements II {} \/\/ Error\n+                \"\"\");\n+        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n+                \"\"\"\n+                value interface VI {}\n+                class BIC implements VI {} \/\/ Error\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":504,"deletions":0,"binary":false,"changes":504,"status":"added"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8287136\n- * @summary [lw4] Javac tolerates abstract value classes that violate constraints for qualifying to be value super classes\n- * @compile\/fail\/ref=ValueSuperClassConstraints.out -XDrawDiagnostics ValueSuperClassConstraints.java\n- *\/\n-\n-public class ValueSuperClassConstraints {\n-\n-    static abstract class I1 { \/\/ has identity since it declares an instance field.\n-        int f;\n-    }\n-\n-    static value class V1 extends I1 {} \/\/ Error.\n-\n-    abstract class I2 { \/\/ has identity since is an inner class\n-    }\n-\n-    static value class V2 extends I2 {} \/\/ Error.\n-\n-    static abstract class I3 { \/\/ has identity since it declared a synchronized instance method.\n-        synchronized void foo() {\n-        }\n-    }\n-\n-    static value class V3 extends I3 {} \/\/ Error.\n-\n-    static abstract class I4 { \/\/ has identity since it declares an instance initializer\n-        { int f = 42; }\n-    }\n-\n-    static value class V4 extends I4 {} \/\/ Error.\n-\n-    static abstract class I5 { \/\/ has identity since it declares a non-trivial constructor\n-        I5(int x) {}\n-    }\n-\n-    static value class V5 extends I5 {} \/\/ Error.\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueSuperClassConstraints.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-ValueSuperClassConstraints.java:39:18: compiler.err.super.field.not.allowed: f, (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V1, ValueSuperClassConstraints.I1)\n-ValueSuperClassConstraints.java:44:18: compiler.err.super.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V2, ValueSuperClassConstraints.I2)\n-ValueSuperClassConstraints.java:51:18: compiler.err.super.method.cannot.be.synchronized: foo(), ValueSuperClassConstraints.V3, ValueSuperClassConstraints.I3\n-ValueSuperClassConstraints.java:57:18: compiler.err.super.class.declares.init.block: (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V4, ValueSuperClassConstraints.I4)\n-ValueSuperClassConstraints.java:63:18: compiler.err.super.constructor.cannot.take.arguments: ValueSuperClassConstraints.I5(int), (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V5, ValueSuperClassConstraints.I5)\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueSuperClassConstraints.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/separate_compilation\/AbstractValueSuper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AbstractValueSuper.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/separate_compilation\/ConcreteValue.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConcreteValue.java","status":"renamed"}]}