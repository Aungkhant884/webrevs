{"files":[{"patch":"@@ -1762,11 +1762,0 @@\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n-\n-    __ mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n-    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-    __ bind(L_skip_barrier);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5954,0 +5954,11 @@\n+  if (C->clinit_barrier_on_entry()) {\n+    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n+\n+    Label L_skip_barrier;\n+\n+    mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n+    clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n+    far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n+    bind(L_skip_barrier);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -612,0 +612,2 @@\n+                            bool requires_clinit_barrier,\n+                            address& c2i_no_clinit_check_entry,\n@@ -618,0 +620,17 @@\n+  if (requires_clinit_barrier && VM_Version::supports_fast_class_init_checks()) {\n+    Label L_skip_barrier;\n+\n+    { \/\/ Bypass the barrier for non-static methods\n+      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n+      __ andsw(zr, rscratch1, JVM_ACC_STATIC);\n+      __ br(Assembler::EQ, L_skip_barrier); \/\/ non-static\n+    }\n+\n+    __ load_method_holder(rscratch2, rmethod);\n+    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n+    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n+\n+    __ bind(L_skip_barrier);\n+    c2i_no_clinit_check_entry = __ pc();\n+  }\n+\n@@ -1030,1 +1049,2 @@\n-  address c2i_unverified_entry = __ pc();\n+  address c2i_unverified_entry        = __ pc();\n+  address c2i_unverified_inline_entry = __ pc();\n@@ -1040,0 +1060,1 @@\n+  address c2i_no_clinit_check_entry = NULL;\n@@ -1042,1 +1063,3 @@\n-    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+    \/\/ No class init barrier needed because method is guaranteed to be non-static\n+    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, \/* requires_clinit_barrier = *\/ false, c2i_no_clinit_check_entry,\n+                    skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* requires_clinit_barrier = *\/ false);\n@@ -1047,24 +1070,4 @@\n-  address c2i_entry = __ pc();\n-\n-  \/\/ Class initialization barrier for static methods\n-  address c2i_no_clinit_check_entry = NULL;\n-  if (VM_Version::supports_fast_class_init_checks()) {\n-    Label L_skip_barrier;\n-\n-    { \/\/ Bypass the barrier for non-static methods\n-      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n-      __ andsw(zr, rscratch1, JVM_ACC_STATIC);\n-      __ br(Assembler::EQ, L_skip_barrier); \/\/ non-static\n-    }\n-\n-    __ load_method_holder(rscratch2, rmethod);\n-    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n-    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-\n-    __ bind(L_skip_barrier);\n-    c2i_no_clinit_check_entry = __ pc();\n-  }\n-\n-  gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);\n-\n-  address c2i_unverified_inline_entry = c2i_unverified_entry;\n+  address c2i_entry        = __ pc();\n+  address c2i_inline_entry = __ pc();\n+  gen_c2i_adapter(masm, sig_cc, regs_cc, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                  skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* requires_clinit_barrier = *\/ true);\n@@ -1073,1 +1076,0 @@\n-  address c2i_inline_entry = c2i_entry;\n@@ -1075,1 +1077,0 @@\n-    Label inline_entry_skip_fixup;\n@@ -1077,0 +1078,1 @@\n+    Label inline_entry_skip_fixup;\n@@ -1080,3 +1082,2 @@\n-    \/\/ TODO 8294013 Fix this and add tests\n-    c2i_no_clinit_check_entry = __ pc();\n-    gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+    gen_c2i_adapter(masm, sig, regs, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                    inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* requires_clinit_barrier = *\/ false);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":32,"deletions":31,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -49,0 +49,15 @@\n+  if (C->clinit_barrier_on_entry()) {\n+    assert(VM_Version::supports_fast_class_init_checks(), \"sanity\");\n+    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n+\n+    Label L_skip_barrier;\n+    Register klass = rscratch1;\n+\n+    mov_metadata(klass, C->method()->holder()->constant_encoding());\n+    clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+\n+    jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+\n+    bind(L_skip_barrier);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -796,0 +796,2 @@\n+                            bool requires_clinit_barrier,\n+                            address& c2i_no_clinit_check_entry,\n@@ -802,0 +804,21 @@\n+  if (requires_clinit_barrier && VM_Version::supports_fast_class_init_checks()) {\n+    Label L_skip_barrier;\n+    Register method = rbx;\n+\n+    { \/\/ Bypass the barrier for non-static methods\n+      Register flags = rscratch1;\n+      __ movl(flags, Address(method, Method::access_flags_offset()));\n+      __ testl(flags, JVM_ACC_STATIC);\n+      __ jcc(Assembler::zero, L_skip_barrier); \/\/ non-static\n+    }\n+\n+    Register klass = rscratch1;\n+    __ load_method_holder(klass, method);\n+    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+\n+    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+\n+    __ bind(L_skip_barrier);\n+    c2i_no_clinit_check_entry = __ pc();\n+  }\n+\n@@ -1254,1 +1277,2 @@\n-  address c2i_unverified_entry = __ pc();\n+  address c2i_unverified_entry        = __ pc();\n+  address c2i_unverified_inline_entry = __ pc();\n@@ -1264,0 +1288,1 @@\n+  address c2i_no_clinit_check_entry = NULL;\n@@ -1266,1 +1291,3 @@\n-    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+    \/\/ No class init barrier needed because method is guaranteed to be non-static\n+    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, \/* requires_clinit_barrier = *\/ false, c2i_no_clinit_check_entry,\n+                    skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* requires_clinit_barrier = *\/ false);\n@@ -1271,28 +1298,4 @@\n-  address c2i_entry = __ pc();\n-\n-  \/\/ Class initialization barrier for static methods\n-  address c2i_no_clinit_check_entry = NULL;\n-  if (VM_Version::supports_fast_class_init_checks()) {\n-    Label L_skip_barrier;\n-    Register method = rbx;\n-\n-    { \/\/ Bypass the barrier for non-static methods\n-      Register flags = rscratch1;\n-      __ movl(flags, Address(method, Method::access_flags_offset()));\n-      __ testl(flags, JVM_ACC_STATIC);\n-      __ jcc(Assembler::zero, L_skip_barrier); \/\/ non-static\n-    }\n-\n-    Register klass = rscratch1;\n-    __ load_method_holder(klass, method);\n-    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n-\n-    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n-\n-    __ bind(L_skip_barrier);\n-    c2i_no_clinit_check_entry = __ pc();\n-  }\n-\n-  gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);\n-\n-  address c2i_unverified_inline_entry = c2i_unverified_entry;\n+  address c2i_entry        = __ pc();\n+  address c2i_inline_entry = __ pc();\n+  gen_c2i_adapter(masm, sig_cc, regs_cc, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                  skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* requires_clinit_barrier = *\/ true);\n@@ -1301,1 +1304,0 @@\n-  address c2i_inline_entry = c2i_entry;\n@@ -1303,1 +1305,0 @@\n-    Label inline_entry_skip_fixup;\n@@ -1305,0 +1306,1 @@\n+    Label inline_entry_skip_fixup;\n@@ -1308,3 +1310,2 @@\n-    \/\/ TODO 8294013 Fix this and add tests\n-    c2i_no_clinit_check_entry = __ pc();\n-    gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);\n+    gen_c2i_adapter(masm, sig, regs, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                    inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* requires_clinit_barrier = *\/ false);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":36,"deletions":35,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -904,15 +904,0 @@\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(VM_Version::supports_fast_class_init_checks(), \"sanity\");\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n-    Register klass = rscratch1;\n-\n-    __ mov_metadata(klass, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n-\n-    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n-\n-    __ bind(L_skip_barrier);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,8 @@\n+    static value class MyValue {\n+        int x = 42;\n+\n+        void verify() {\n+            Asserts.assertEquals(x, 42);\n+        }\n+    }\n+\n@@ -71,0 +79,1 @@\n+\n@@ -88,3 +97,3 @@\n-            static              void staticM(Runnable action) { action.run(); }\n-            static synchronized void staticS(Runnable action) { action.run(); }\n-            static native       void staticN(Runnable action);\n+            static              void staticM(Runnable action, MyValue val) { action.run(); val.verify(); }\n+            static synchronized void staticS(Runnable action, MyValue val) { action.run(); val.verify(); }\n+            static native       void staticN(Runnable action, MyValue val);\n@@ -102,3 +111,3 @@\n-        static void testInvokeStatic(Runnable action)       { A.staticM(action); }\n-        static void testInvokeStaticSync(Runnable action)   { A.staticS(action); }\n-        static void testInvokeStaticNative(Runnable action) { A.staticN(action); }\n+        static void testInvokeStatic(Runnable action, MyValue val)       { A.staticM(action, val); }\n+        static void testInvokeStaticSync(Runnable action, MyValue val)   { A.staticS(action, val); }\n+        static void testInvokeStaticNative(Runnable action, MyValue val) { A.staticN(action, val); }\n@@ -106,4 +115,4 @@\n-        static int  testGetStatic(Runnable action)    { int v = A.staticF; action.run(); return v;   }\n-        static void testPutStatic(Runnable action)    { A.staticF = 1;     action.run(); }\n-        static A    testNewInstanceA(Runnable action) { A obj = new A();   action.run(); return obj; }\n-        static B    testNewInstanceB(Runnable action) { B obj = new B();   action.run(); return obj; }\n+        static int  testGetStatic(Runnable action, MyValue val)    { int v = A.staticF; action.run(); val.verify(); return v;   }\n+        static void testPutStatic(Runnable action, MyValue val)    { A.staticF = 1;     action.run(); val.verify(); }\n+        static A    testNewInstanceA(Runnable action, MyValue val) { A obj = new A();   action.run(); val.verify(); return obj; }\n+        static B    testNewInstanceB(Runnable action, MyValue val) { B obj = new B();   action.run(); val.verify(); return obj; }\n@@ -111,3 +120,3 @@\n-        static int  testGetField(A recv, Runnable action)      { int v = recv.f; action.run(); return v; }\n-        static void testPutField(A recv, Runnable action)      { recv.f = 1;     action.run(); }\n-        static void testInvokeVirtual(A recv, Runnable action) { recv.m();       action.run(); }\n+        static int  testGetField(A recv, Runnable action, MyValue val)      { int v = recv.f; action.run(); val.verify(); return v; }\n+        static void testPutField(A recv, Runnable action, MyValue val)      { recv.f = 1;     action.run(); val.verify(); }\n+        static void testInvokeVirtual(A recv, Runnable action, MyValue val) { recv.m();       action.run(); val.verify(); }\n@@ -115,3 +124,3 @@\n-        static native void testInvokeStaticJNI(Runnable action);\n-        static native void testInvokeStaticSyncJNI(Runnable action);\n-        static native void testInvokeStaticNativeJNI(Runnable action);\n+        static native void testInvokeStaticJNI(Runnable action, MyValue val);\n+        static native void testInvokeStaticSyncJNI(Runnable action, MyValue val);\n+        static native void testInvokeStaticNativeJNI(Runnable action, MyValue val);\n@@ -119,4 +128,4 @@\n-        static native int  testGetStaticJNI(Runnable action);\n-        static native void testPutStaticJNI(Runnable action);\n-        static native A    testNewInstanceAJNI(Runnable action);\n-        static native B    testNewInstanceBJNI(Runnable action);\n+        static native int  testGetStaticJNI(Runnable action, MyValue val);\n+        static native void testPutStaticJNI(Runnable action, MyValue val);\n+        static native A    testNewInstanceAJNI(Runnable action, MyValue val);\n+        static native B    testNewInstanceBJNI(Runnable action, MyValue val);\n@@ -124,3 +133,3 @@\n-        static native int  testGetFieldJNI(A recv, Runnable action);\n-        static native void testPutFieldJNI(A recv, Runnable action);\n-        static native void testInvokeVirtualJNI(A recv, Runnable action);\n+        static native int  testGetFieldJNI(A recv, Runnable action, MyValue val);\n+        static native void testPutFieldJNI(A recv, Runnable action, MyValue val);\n+        static native void testInvokeVirtualJNI(A recv, Runnable action, MyValue val);\n@@ -143,1 +152,1 @@\n-            A recv = testNewInstanceB(NON_BLOCKING.get());  \/\/ trigger B initialization\n+            A recv = testNewInstanceB(NON_BLOCKING.get(), new MyValue());  \/\/ trigger B initialization\n@@ -157,0 +166,1 @@\n+            MyValue val = new MyValue();\n@@ -158,11 +168,11 @@\n-                testInvokeStatic(      NON_BLOCKING_WARMUP);\n-                testInvokeStaticNative(NON_BLOCKING_WARMUP);\n-                testInvokeStaticSync(  NON_BLOCKING_WARMUP);\n-                testGetStatic(         NON_BLOCKING_WARMUP);\n-                testPutStatic(         NON_BLOCKING_WARMUP);\n-                testNewInstanceA(      NON_BLOCKING_WARMUP);\n-                testNewInstanceB(      NON_BLOCKING_WARMUP);\n-\n-                testGetField(new B(),      NON_BLOCKING_WARMUP);\n-                testPutField(new B(),      NON_BLOCKING_WARMUP);\n-                testInvokeVirtual(new B(), NON_BLOCKING_WARMUP);\n+                testInvokeStatic(      NON_BLOCKING_WARMUP, val);\n+                testInvokeStaticNative(NON_BLOCKING_WARMUP, val);\n+                testInvokeStaticSync(  NON_BLOCKING_WARMUP, val);\n+                testGetStatic(         NON_BLOCKING_WARMUP, val);\n+                testPutStatic(         NON_BLOCKING_WARMUP, val);\n+                testNewInstanceA(      NON_BLOCKING_WARMUP, val);\n+                testNewInstanceB(      NON_BLOCKING_WARMUP, val);\n+\n+                testGetField(new B(),      NON_BLOCKING_WARMUP, val);\n+                testPutField(new B(),      NON_BLOCKING_WARMUP, val);\n+                testInvokeVirtual(new B(), NON_BLOCKING_WARMUP, val);\n@@ -268,1 +278,1 @@\n-        void run(Runnable runnable);\n+        void run(Runnable runnable, MyValue val);\n@@ -272,1 +282,1 @@\n-        void run(T arg, Runnable runnable);\n+        void run(T arg, Runnable runnable, MyValue val);\n@@ -342,0 +352,1 @@\n+        MyValue val = new MyValue();\n@@ -345,1 +356,1 @@\n-                r.run(NON_BLOCKING.get());             \/\/ initializing thread\n+                r.run(NON_BLOCKING.get(), val);             \/\/ initializing thread\n@@ -351,1 +362,1 @@\n-                r.run(NON_BLOCKING.get()); \/\/ initializing thread\n+                r.run(NON_BLOCKING.get(), val); \/\/ initializing thread\n@@ -357,1 +368,1 @@\n-                TestCase0 test = action -> execute(NoClassDefFoundError.class, () -> r.run(action));\n+                TestCase0 test = (action, valarg) -> execute(NoClassDefFoundError.class, () -> r.run(action, valarg));\n@@ -359,1 +370,1 @@\n-                test.run(NON_BLOCKING.get()); \/\/ initializing thread\n+                test.run(NON_BLOCKING.get(), val); \/\/ initializing thread\n@@ -368,1 +379,1 @@\n-        r.run(NON_BLOCKING.get()); \/\/ initializing thread\n+        r.run(NON_BLOCKING.get(), new MyValue()); \/\/ initializing thread\n@@ -373,2 +384,2 @@\n-        r.run(recv, NON_BLOCKING.get());                  \/\/ initializing thread\n-        checkNotBlocked((action) -> r.run(recv, action)); \/\/ different thread\n+        r.run(recv, NON_BLOCKING.get(), new MyValue());                  \/\/ initializing thread\n+        checkNotBlocked((action, val) -> r.run(recv, action, val)); \/\/ different thread\n@@ -378,1 +389,1 @@\n-        r.run(NON_BLOCKING.get()); \/\/ initializing thread\n+        r.run(NON_BLOCKING.get(), new MyValue()); \/\/ initializing thread\n@@ -396,1 +407,1 @@\n-                r.run(BLOCKING.get());\n+                r.run(BLOCKING.get(), new MyValue());\n@@ -424,1 +435,1 @@\n-        final Thread thr = new Thread(() -> r.run(NON_BLOCKING.get()));\n+        final Thread thr = new Thread(() -> r.run(NON_BLOCKING.get(), new MyValue()));\n","filename":"test\/hotspot\/jtreg\/runtime\/clinit\/ClassInitBarrier.java","additions":59,"deletions":48,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        test_staticM_id = env->GetStaticMethodID(test_class_A, \"staticM\", \"(Ljava\/lang\/Runnable;)V\");\n+        test_staticM_id = env->GetStaticMethodID(test_class_A, \"staticM\", \"(Ljava\/lang\/Runnable;LClassInitBarrier$MyValue;)V\");\n@@ -60,1 +60,1 @@\n-        test_staticS_id = env->GetStaticMethodID(test_class_A, \"staticS\", \"(Ljava\/lang\/Runnable;)V\");\n+        test_staticS_id = env->GetStaticMethodID(test_class_A, \"staticS\", \"(Ljava\/lang\/Runnable;LClassInitBarrier$MyValue;)V\");\n@@ -63,1 +63,1 @@\n-        test_staticN_id = env->GetStaticMethodID(test_class_A, \"staticN\", \"(Ljava\/lang\/Runnable;)V\");\n+        test_staticN_id = env->GetStaticMethodID(test_class_A, \"staticN\", \"(Ljava\/lang\/Runnable;LClassInitBarrier$MyValue;)V\");\n@@ -82,2 +82,2 @@\n-    JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticJNI(JNIEnv* env, jclass cls, jobject action) {\n-        env->CallStaticVoidMethod(test_class_A, test_staticM_id, action);\n+    JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticJNI(JNIEnv* env, jclass cls, jobject action, jobject val) {\n+        env->CallStaticVoidMethod(test_class_A, test_staticM_id, action, val);\n@@ -86,2 +86,2 @@\n-    JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticSyncJNI(JNIEnv* env, jclass cls, jobject action) {\n-        env->CallStaticVoidMethod(test_class_A, test_staticS_id, action);\n+    JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticSyncJNI(JNIEnv* env, jclass cls, jobject action, jobject val) {\n+        env->CallStaticVoidMethod(test_class_A, test_staticS_id, action, val);\n@@ -90,2 +90,2 @@\n-    JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticNativeJNI(JNIEnv* env, jclass cls, jobject action) {\n-        env->CallStaticVoidMethod(test_class_A, test_staticN_id, action);\n+    JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticNativeJNI(JNIEnv* env, jclass cls, jobject action, jobject val) {\n+        env->CallStaticVoidMethod(test_class_A, test_staticN_id, action, val);\n","filename":"test\/hotspot\/jtreg\/runtime\/clinit\/libClassInitBarrier.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}