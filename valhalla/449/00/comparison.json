{"files":[{"patch":"@@ -195,0 +195,2 @@\n+        this.allowPrimitiveClasses = (!preview.isPreview(Feature.PRIMITIVE_CLASSES) || preview.isEnabled()) &&\n+                Feature.PRIMITIVE_CLASSES.allowedInSource(source);\n@@ -236,0 +238,4 @@\n+    \/** Switch: are primitive classes allowed in this source level?\n+     *\/\n+     boolean allowPrimitiveClasses;\n+\n@@ -2701,1 +2707,0 @@\n-        token = recastToken(token);\n@@ -2712,1 +2717,0 @@\n-        case PRIMITIVE:\n@@ -2802,0 +2806,4 @@\n+        if (isPrimitiveModifier()) {\n+            dc = token.comment(CommentStyle.JAVADOC);\n+            return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));\n+        }\n@@ -3280,1 +3288,0 @@\n-            token = recastToken(token);\n@@ -3290,1 +3297,0 @@\n-            case PRIMITIVE   : flag = Flags.PRIMITIVE_CLASS; break;\n@@ -3309,0 +3315,4 @@\n+                if (isPrimitiveModifier()) {\n+                    flag = Flags.PRIMITIVE_CLASS;\n+                    break;\n+                }\n@@ -3540,36 +3550,0 @@\n-    \/\/ Does the given token signal a primitive modifier ? If yes, suitably reclassify token.\n-    Token recastToken(Token token) {\n-        if (token.kind != IDENTIFIER || token.name() != names.primitive) {\n-            return token;\n-        }\n-        if (peekToken(t->t == PRIVATE ||\n-                         t == PROTECTED ||\n-                         t == PUBLIC ||\n-                         t == STATIC ||\n-                         t == TRANSIENT ||\n-                         t == FINAL ||\n-                         t == ABSTRACT ||\n-                         t == NATIVE ||\n-                         t == VOLATILE ||\n-                         t == SYNCHRONIZED ||\n-                         t == STRICTFP ||\n-                         t == MONKEYS_AT ||\n-                         t == DEFAULT ||\n-                         t == BYTE ||\n-                         t == SHORT ||\n-                         t == CHAR ||\n-                         t == INT ||\n-                         t == LONG ||\n-                         t == FLOAT ||\n-                         t == DOUBLE ||\n-                         t == BOOLEAN ||\n-                         t == CLASS ||\n-                         t == INTERFACE ||\n-                         t == ENUM ||\n-                         t == IDENTIFIER)) { \/\/ new value Comparable() {}\n-            checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-            return new Token(PRIMITIVE, token.pos, token.endPos, token.comments);\n-        }\n-        return token;\n-    }\n-\n@@ -3609,0 +3583,7 @@\n+        if (name == names.primitive) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK17;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK17));\n+            }\n+        }\n@@ -4499,0 +4480,16 @@\n+    protected boolean isPrimitiveModifier() {\n+        if (allowPrimitiveClasses && token.kind == IDENTIFIER && token.name() == names.primitive) {\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM: case IDENTIFIER: \/\/ new primitive Comparable() {}\n+                    checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":37,"deletions":40,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-        PRIMITIVE(), \/\/ a phantom token never returned by the scanner, but can result from a reclassification by the parser.\n@@ -250,2 +249,0 @@\n-            case PRIMITIVE:\n-                return \"primitive\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-        PRIMITIVE(TokenKind.PRIMITIVE, 0),\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+compiler.misc.feature.primitive.classes\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.feature.not.supported.in.source\n-\/\/ key: compiler.misc.feature.primitive.classes\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 13\n-\n-primitive final class ValuesNotSupported {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassNotSupported.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,1 +1,2 @@\n-CheckFeatureGate1.java:10:12: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.primitive.classes), 13, 17\n+CheckFeatureGate1.java:10:12: compiler.warn.restricted.type.not.allowed.preview: primitive, 17\n+CheckFeatureGate1.java:10:21: compiler.err.expected: token.identifier\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckFeatureGate1.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8267821\n+ * @summary Javac's handling of `primitive' modifier is unlike the handling of other restricted identifiers\n+ * @compile\/fail\/ref=PrimitiveAsTypeName.out --source 16 -XDrawDiagnostics PrimitiveAsTypeName.java\n+ *\/\n+\n+public class PrimitiveAsTypeName {\n+    public class primitive {\n+        primitive x;\n+        primitive foo(int l) {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PrimitiveAsTypeName.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+- compiler.warn.source.no.system.modules.path: 16\n+PrimitiveAsTypeName.java:9:18: compiler.warn.restricted.type.not.allowed.preview: primitive, 17\n+PrimitiveAsTypeName.java:10:9: compiler.warn.restricted.type.not.allowed.preview: primitive, 17\n+PrimitiveAsTypeName.java:11:9: compiler.warn.restricted.type.not.allowed.preview: primitive, 17\n+PrimitiveAsTypeName.java:11:31: compiler.err.missing.ret.stmt\n+1 error\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PrimitiveAsTypeName.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"}]}