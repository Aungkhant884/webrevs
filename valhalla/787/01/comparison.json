{"files":[{"patch":"@@ -524,1 +524,1 @@\n-                         vmClasses::PrimitiveObjectMethods_klass(),\n+                         vmClasses::ValueObjectMethods_klass(),\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  do_klass(PrimitiveObjectMethods_klass,                java_lang_runtime_PrimitiveObjectMethods              ) \\\n+  do_klass(ValueObjectMethods_klass,                    java_lang_runtime_ValueObjectMethods                  ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -783,1 +783,1 @@\n-  template(java_lang_runtime_PrimitiveObjectMethods,        \"java\/lang\/runtime\/PrimitiveObjectMethods\")           \\\n+  template(java_lang_runtime_ValueObjectMethods,            \"java\/lang\/runtime\/ValueObjectMethods\")               \\\n@@ -785,1 +785,1 @@\n-  template(primitiveObjectHashCode_name,                    \"primitiveObjectHashCode\")                            \\\n+  template(valueObjectHashCode_name,                        \"valueObjectHashCode\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-LatestMethodCache* Universe::_primitive_type_hash_code_cache = NULL;\n+LatestMethodCache* Universe::_value_object_hash_code_cache = NULL;\n@@ -240,1 +240,1 @@\n-  _primitive_type_hash_code_cache->metaspace_pointers_do(it);\n+  _value_object_hash_code_cache->metaspace_pointers_do(it);\n@@ -290,1 +290,1 @@\n-  _primitive_type_hash_code_cache->serialize(f);\n+  _value_object_hash_code_cache->serialize(f);\n@@ -806,1 +806,1 @@\n-  Universe::_primitive_type_hash_code_cache = new LatestMethodCache();\n+  Universe::_value_object_hash_code_cache = new LatestMethodCache();\n@@ -978,1 +978,1 @@\n-                          vmClasses::PrimitiveObjectMethods_klass(),\n+                          vmClasses::ValueObjectMethods_klass(),\n@@ -981,3 +981,3 @@\n-  initialize_known_method(_primitive_type_hash_code_cache,\n-                          vmClasses::PrimitiveObjectMethods_klass(),\n-                          vmSymbols::primitiveObjectHashCode_name()->as_C_string(),\n+  initialize_known_method(_value_object_hash_code_cache,\n+                          vmClasses::ValueObjectMethods_klass(),\n+                          vmSymbols::valueObjectHashCode_name()->as_C_string(),\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-  static LatestMethodCache* _is_substitutable_cache;   \/\/ PrimitiveObjectMethods.isSubstitutable() method\n-  static LatestMethodCache* _primitive_type_hash_code_cache;  \/\/ PrimitiveObjectMethods.primitiveObjectHashCode() method\n+  static LatestMethodCache* _is_substitutable_cache;   \/\/ ValueObjectMethods.isSubstitutable() method\n+  static LatestMethodCache* _value_object_hash_code_cache;  \/\/ ValueObjectMethods.valueObjectHashCode() method\n@@ -270,1 +270,1 @@\n-  static Method*      primitive_type_hash_code_method()  { return _primitive_type_hash_code_cache->get_method(); }\n+  static Method*      value_object_hash_code_method() { return _value_object_hash_code_cache->get_method(); }\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2223,1 +2223,1 @@\n-  \/\/ substitutability test. Delegate to PrimitiveObjectMethods::isSubstitutable().\n+  \/\/ substitutability test. Delegate to ValueObjectMethods::isSubstitutable().\n@@ -2238,1 +2238,1 @@\n-  ciMethod* subst_method = ciEnv::current()->PrimitiveObjectMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n+  ciMethod* subst_method = ciEnv::current()->ValueObjectMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n@@ -2248,1 +2248,1 @@\n-  \/\/ Test the return value of PrimitiveObjectMethods::isSubstitutable()\n+  \/\/ Test the return value of ValueObjectMethods::isSubstitutable()\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -626,1 +626,1 @@\n-      methodHandle method(THREAD, Universe::primitive_type_hash_code_method());\n+      methodHandle method(THREAD, Universe::value_object_hash_code_method());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-      \/\/ a full substitutability test is required, calling PrimitiveObjectMethods.isSubstitutable()\n+      \/\/ a full substitutability test is required, calling ValueObjectMethods.isSubstitutable()\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1117,1 +1117,1 @@\n-    vmClasses::PrimitiveObjectMethods_klass()->initialize(CHECK_NH);\n+    vmClasses::ValueObjectMethods_klass()->initialize(CHECK_NH);\n@@ -1120,1 +1120,1 @@\n-    Method* is_subst = vmClasses::PrimitiveObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    Method* is_subst = vmClasses::ValueObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,479 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.Objects;\n-import java.util.stream.Stream;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.value.PrimitiveClass;\n-import sun.invoke.util.Wrapper;\n-import sun.security.action.GetIntegerAction;\n-import sun.security.action.GetPropertyAction;\n-\n-import static java.lang.invoke.MethodHandles.constant;\n-import static java.lang.invoke.MethodHandles.countedLoop;\n-import static java.lang.invoke.MethodHandles.dropArguments;\n-import static java.lang.invoke.MethodHandles.filterArguments;\n-import static java.lang.invoke.MethodHandles.filterReturnValue;\n-import static java.lang.invoke.MethodHandles.guardWithTest;\n-import static java.lang.invoke.MethodHandles.permuteArguments;\n-import static java.lang.invoke.MethodType.methodType;\n-import static java.lang.runtime.ObjectMethods.primitiveEquals;\n-\n-\/**\n- * Implementation for Object::equals and Object::hashCode for primitive classes.\n- *\n- * PrimitiveObjectMethods::isSubstitutable and primitiveObjectHashCode are\n- * private entry points called by VM.\n- *\/\n-final class PrimitiveObjectMethods {\n-    private PrimitiveObjectMethods() {}\n-    private static final boolean VERBOSE =\n-        GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n-    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n-\n-    static class MethodHandleBuilder {\n-        static MethodHandle[] getters(Class<?> type) {\n-            return getters(type, null);\n-        }\n-\n-        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {\n-            \/\/ filter static fields\n-            Stream<MethodHandle> s = Arrays.stream(type.getDeclaredFields())\n-                .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-                .map(f -> {\n-                    try {\n-                        return JLIA.unreflectField(f, false);\n-                    } catch (IllegalAccessException e) {\n-                        throw newLinkageError(e);\n-                    }\n-                });\n-            if (comparator != null) {\n-                s = s.sorted(comparator);\n-            }\n-            return s.toArray(MethodHandle[]::new);\n-        }\n-\n-        static MethodHandle hashCodeForType(Class<?> type) {\n-            if (type.isPrimitive()) {\n-                int index = Wrapper.forPrimitiveType(type).ordinal();\n-                return HASHCODE[index];\n-            } else {\n-                return HASHCODE[Wrapper.OBJECT.ordinal()].asType(methodType(int.class, type));\n-            }\n-        }\n-\n-        static MethodHandle primitiveEquals(Class<?> primitiveType) {\n-            return primitiveEquals.get(primitiveType);\n-        }\n-\n-        \/*\n-         * Produces a MethodHandle that returns boolean if two instances\n-         * of the given reference type are substitutable.\n-         *\n-         * Two values of reference type are substitutable i== iff\n-         * 1. if o1 and o2 are both reference objects then o1 r== o2; or\n-         * 2. if o1 and o2 are both values then o1 v== o2\n-         *\n-         * At invocation time, it needs a dynamic check on the objects and\n-         * do the substitutability test if they are of a primitive type.\n-         *\/\n-        static MethodHandle referenceTypeEquals(Class<?> type) {\n-            return OBJECT_EQUALS.asType(methodType(boolean.class, type, type));\n-        }\n-\n-        static Class<?> fieldType(MethodHandle getter) {\n-            Class<?> ftype = getter.type().returnType();\n-            return ftype;\n-        }\n-\n-        \/*\n-         * Produces a MethodHandle that returns boolean if two value instances\n-         * of the given primitive class are substitutable.\n-         *\/\n-        static MethodHandle primitiveTypeEquals(Class<?> type) {\n-            assert PrimitiveClass.isPrimitiveValueType(type) ||\n-                    (type.isValue() && !PrimitiveClass.isPrimitiveClass(type));\n-            MethodType mt = methodType(boolean.class, type, type);\n-            MethodHandle[] getters = getters(type, TYPE_SORTER);\n-            MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n-            MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n-            MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n-            for (MethodHandle getter : getters) {\n-                Class<?> ftype = fieldType(getter);\n-                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n-                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n-                accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n-            }\n-            \/\/ if both arguments are null, return true;\n-            \/\/ otherwise return accumulator;\n-            return guardWithTest(IS_NULL.asType(mt),\n-                                 instanceTrue,\n-                                 guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n-                                               accumulator,\n-                                               instanceFalse));\n-        }\n-\n-        static MethodHandle primitiveTypeHashCode(Class<?> type) {\n-            assert PrimitiveClass.isPrimitiveValueType(type) ||\n-                    (type.isValue() && !PrimitiveClass.isPrimitiveClass(type));\n-            MethodHandle target = dropArguments(constant(int.class, SALT), 0, type);\n-            MethodHandle cls = dropArguments(constant(Class.class, type),0, type);\n-            MethodHandle classHashCode = filterReturnValue(cls, hashCodeForType(Class.class));\n-            MethodHandle combiner = filterArguments(HASH_COMBINER, 0, target, classHashCode);\n-            \/\/ int v = SALT * 31 + type.hashCode();\n-            MethodHandle init = permuteArguments(combiner, target.type(), 0, 0);\n-            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n-            MethodHandle iterations = dropArguments(constant(int.class, getters.length), 0, type);\n-            MethodHandle[] hashers = new MethodHandle[getters.length];\n-            for (int i=0; i < getters.length; i++) {\n-                MethodHandle getter = getters[i];\n-                Class<?> ftype = fieldType(getter);\n-\n-                \/\/ For primitive type or reference type, this calls Objects::hashCode.\n-                \/\/ If the instance is of primitive type and the hashCode method is not\n-                \/\/ overridden, VM will call primitiveObjectHashCode to compute the\n-                \/\/ hash code.\n-                MethodHandle hasher = hashCodeForType(ftype);\n-                hashers[i] = filterReturnValue(getter, hasher);\n-            }\n-\n-            \/\/ for (int i=0; i < getters.length; i++) {\n-            \/\/   v = computeHash(v, i, a);\n-            \/\/ }\n-            MethodHandle body = COMPUTE_HASH.bindTo(hashers)\n-                    .asType(methodType(int.class, int.class, int.class, type));\n-            return countedLoop(iterations, init, body);\n-        }\n-\n-        \/\/ ------ utility methods ------\n-        private static boolean eq(Object a, Object b)   {\n-            if (a == null && b == null) return true;\n-            if (a == null || b == null) return false;\n-            if (a.getClass() != b.getClass()) return false;\n-            return a.getClass().isValue() ? valueEq(a, b) : (a == b);\n-        }\n-\n-        \/*\n-         * Returns true if two values are substitutable.\n-         *\/\n-        private static boolean valueEq(Object a, Object b) {\n-            assert a != null && b != null && isSameValueClass(a, b);\n-            try {\n-                Class<?> type = a.getClass();\n-                if (PrimitiveClass.isPrimitiveClass(type)) {\n-                    type = PrimitiveClass.asValueType(type);\n-                }\n-                return (boolean) substitutableInvoker(type).invoke(type.cast(a), type.cast(b));\n-            } catch (Error|RuntimeException e) {\n-                throw e;\n-            } catch (Throwable e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-\n-        private static boolean isNull(Object a, Object b) {\n-            \/\/ avoid acmp that will call isSubstitutable\n-            if (a != null) return false;\n-            if (b != null) return false;\n-            return true;\n-        }\n-\n-        \/*\n-         * Returns true if the given objects are of the same primitive class.\n-         *\n-         * Two objects are of the same primitive class iff:\n-         * 1. a != null and b != null\n-         * 2. the declaring class of a and b is the same primitive class\n-         *\/\n-        private static boolean isSameValueClass(Object a, Object b) {\n-            if (a == null || b == null) return false;\n-\n-            return a.getClass().isValue() && a.getClass() == b.getClass();\n-        }\n-\n-        private static int hashCombiner(int accumulator, int value) {\n-            return accumulator * 31 + value;\n-        }\n-\n-        private static int computeHashCode(MethodHandle[] hashers, int v, int i, Object o) {\n-            try {\n-                int hc = (int)hashers[i].invoke(o);\n-                return hashCombiner(v, hc);\n-            } catch (Error|RuntimeException e) {\n-                throw e;\n-            } catch (Throwable e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-\n-        private static final MethodHandle FALSE = constant(boolean.class, false);\n-        private static final MethodHandle TRUE = constant(boolean.class, true);\n-        private static final MethodHandle OBJECT_EQUALS = findStatic(\"eq\", methodType(boolean.class, Object.class, Object.class));\n-        private static final MethodHandle IS_SAME_VALUE_CLASS =\n-            findStatic(\"isSameValueClass\", methodType(boolean.class, Object.class, Object.class));\n-        private static final MethodHandle IS_NULL =\n-            findStatic(\"isNull\", methodType(boolean.class, Object.class, Object.class));\n-        private static final MethodHandle HASH_COMBINER =\n-            findStatic(\"hashCombiner\", methodType(int.class, int.class, int.class));\n-        private static final MethodHandle COMPUTE_HASH =\n-            findStatic(\"computeHashCode\", methodType(int.class, MethodHandle[].class, int.class, int.class, Object.class));\n-        private static final MethodHandle[] HASHCODE = initHashCode();\n-\n-        private static MethodHandle[] initHashCode() {\n-            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n-            for (Wrapper wrapper : Wrapper.values()) {\n-                if (wrapper == Wrapper.VOID) continue;\n-                Class<?> cls = wrapper == Wrapper.OBJECT ? Objects.class : wrapper.wrapperType();\n-                mhs[wrapper.ordinal()] = findStatic(cls, \"hashCode\",\n-                                                    methodType(int.class, wrapper.primitiveType()));\n-            }\n-            return mhs;\n-        }\n-\n-        private static MethodHandle findStatic(String name, MethodType methodType) {\n-            return findStatic(MethodHandleBuilder.class, name, methodType);\n-        }\n-        private static MethodHandle findStatic(Class<?> cls, String name, MethodType methodType) {\n-            try {\n-                return JLIA.findStatic(cls, name, methodType);\n-            } catch (IllegalAccessException e) {\n-                throw newLinkageError(e);\n-            }\n-        }\n-\n-        \/**\n-         * A \"salt\" value used for this internal hashcode implementation that\n-         * needs to vary sufficiently from one run to the next so that\n-         * the default hashcode for value types will vary between JVM runs.\n-         *\/\n-        static final int SALT;\n-        static {\n-            long nt = System.nanoTime();\n-            int value = (int)((nt >>> 32) ^ nt);\n-            SALT = GetIntegerAction.privilegedGetProperty(\"value.bsm.salt\", value);\n-        }\n-    }\n-\n-    private static LinkageError newLinkageError(Throwable e) {\n-        return (LinkageError) new LinkageError().initCause(e);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the arguments are <em>substitutable<\/em> to each\n-     * other and {@code false} otherwise.\n-     * <em>Substitutability<\/em> means that they cannot be distinguished from\n-     * each other in any data-dependent way, meaning that it is safe to substitute\n-     * one for the other.\n-     *\n-     * <ul>\n-     * <li>If {@code a} and {@code b} are both {@code null}, this method returns\n-     *     {@code true}.\n-     * <li>If {@code a} and {@code b} are both value instances of the same class\n-     *     {@code V}, this method returns {@code true} if, for all fields {@code f}\n-     *      declared in {@code V}, {@code a.f} and {@code b.f} are substitutable.\n-     * <li>If {@code a} and {@code b} are both primitives of the same type,\n-     *     this method returns {@code a == b} with the following exception:\n-     *     <ul>\n-     *     <li> If {@code a} and {@code b} both represent {@code NaN},\n-     *          this method returns {@code true}, even though {@code NaN == NaN}\n-     *          has the value {@code false}.\n-     *     <li> If {@code a} is floating point positive zero while {@code b} is\n-     *          floating point negative zero, or vice versa, this method\n-     *          returns {@code false}, even though {@code +0.0 == -0.0} has\n-     *          the value {@code true}.\n-     *     <\/ul>\n-     * <li>If {@code a} and {@code b} are both instances of the same reference type,\n-     *     this method returns {@code a == b}.\n-     * <li>Otherwise this method returns {@code false}.\n-     * <\/ul>\n-     *\n-     * <p>For example,\n-     * <pre>{@code interface Number { ... }\n-     * \/\/ ordinary reference class\n-     * class IntNumber implements Number { ... }\n-     * \/\/ value class\n-     * value class IntValue implements Number {\n-     *     int i;\n-     *     :\n-     *     public static IntValue of(int i) {...}     \/\/ IntValue::of creates a new value instance\n-     * }\n-     * \/\/ value class with an Object field\n-     * value class RefValue {\n-     *     Object o;\n-     *     :\n-     * }\n-     *\n-     * var val1 = IntValue.of(10);\n-     * var val2 = IntValue.of(10);                    \/\/ val1 and val2 have the same value\n-     * var ref1 = new IntNumber(10);                  \/\/ ref1 and ref2 are two reference instances\n-     * var ref2 = new IntNumber(10);\n-     * assertTrue(isSubstitutable(val1, val2));       \/\/ val1 and val2 are both value instances of IntValue\n-     * assertFalse(isSubstitutable(ref1, ref2));      \/\/ ref1 and ref2 are two reference instances that are not substitutable\n-     * assertTrue(isSubstitutable(ref1, ref1));       \/\/ a reference instance is substitutable with itself\n-     *\n-     * var rval1 = RefValue.of(List.of(\"list\"));      \/\/ rval1.o and rval2.o both contain a list of one-single element \"list\"\n-     * var rval2 = RefValue.of(List.of(\"list\");\n-     * var rval3 = RefValue.of(rval1.o);\n-     *\n-     * assertFalse(isSubstitutable(rval1, rval2));    \/\/ rval1.o and rval2.o are two different List instances and hence not substitutable\n-     * assertTrue(isSubstitutable(rval1, rval3 ));    \/\/ rval1.o and rval3.o are the same reference instance\n-     * }<\/pre>\n-     *\n-     * @param a an object\n-     * @param b an object to be compared with {@code a} for substitutability\n-     * @return {@code true} if the arguments are substitutable to each other;\n-     *         {@code false} otherwise.\n-     * @param <T> type\n-     * @see Float#equals(Object)\n-     * @see Double#equals(Object)\n-     *\/\n-    private static <T> boolean isSubstitutable(T a, Object b) {\n-        if (VERBOSE) {\n-            System.out.println(\"substitutable \" + a + \" vs \" + b);\n-        }\n-\n-        \/\/ Called directly from the VM.\n-        \/\/\n-        \/\/ DO NOT use \"==\" or \"!=\" on args \"a\" and \"b\", with this code or any of\n-        \/\/ its callees. Could be inside of if_acmp<eq|ne> bytecode implementation.\n-\n-        if (a == null && b == null) return true;\n-        if (a == null || b == null) return false;\n-        if (a.getClass() != b.getClass()) return false;\n-\n-        try {\n-            Class<?> type = a.getClass();\n-            if (PrimitiveClass.isPrimitiveClass(type)) {\n-                type = PrimitiveClass.asValueType(type);\n-            }\n-            return (boolean) substitutableInvoker(type).invoke(a, b);\n-        } catch (Error|RuntimeException e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw e;\n-        } catch (Throwable e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Produces a method handle which tests if two arguments are\n-     * {@linkplain #isSubstitutable(Object, Object) substitutable}.\n-     *\n-     * <ul>\n-     * <li>If {@code T} is a non-floating point primitive type, this method\n-     *     returns a method handle testing the two arguments are the same value,\n-     *     i.e. {@code a == b}.\n-     * <li>If {@code T} is {@code float} or {@code double}, this method\n-     *     returns a method handle representing {@link Float#equals(Object)} or\n-     *     {@link Double#equals(Object)} respectively.\n-     * <li>If {@code T} is a reference type that is not {@code Object} and not an\n-     *     interface, this method returns a method handle testing\n-     *     the two arguments are the same reference, i.e. {@code a == b}.\n-     * <li>If {@code T} is a value type, this method returns\n-     *     a method handle that returns {@code true} if\n-     *     for all fields {@code f} declared in {@code T}, where {@code U} is\n-     *     the type of {@code f}, if {@code a.f} and {@code b.f} are substitutable\n-     *     with respect to {@code U}.\n-     * <li>If {@code T} is an interface or {@code Object}, and\n-     *     {@code a} and {@code b} are of the same value class {@code V},\n-     *     this method returns a method handle that returns {@code true} if\n-     *     {@code a} and {@code b} are substitutable with respect to {@code V}.\n-     * <\/ul>\n-     *\n-     * @param type class type\n-     * @param <T> type\n-     * @return a method handle for substitutability test\n-     *\/\n-    private static <T> MethodHandle substitutableInvoker(Class<T> type) {\n-        if (type.isPrimitive())\n-            return MethodHandleBuilder.primitiveEquals(type);\n-\n-        if (PrimitiveClass.isPrimitiveValueType(type) ||\n-                (type.isValue() && !PrimitiveClass.isPrimitiveClass(type))) {\n-            return SUBST_TEST_METHOD_HANDLES.get(type);\n-        }\n-        return MethodHandleBuilder.referenceTypeEquals(type);\n-    }\n-\n-    \/\/ store the method handle for value types in ClassValue\n-    private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {\n-        @Override protected MethodHandle computeValue(Class<?> type) {\n-            return MethodHandleBuilder.primitiveTypeEquals(type);\n-        }\n-    };\n-\n-    \/**\n-     * Invoke the bootstrap methods hashCode for the given primitive class object.\n-     * @param o the instance to hash.\n-     * @return the hash code of the given primitive class object.\n-     *\/\n-    private static int primitiveObjectHashCode(Object o) {\n-        Class<?> c = o.getClass();\n-        try {\n-            \/\/ Note: javac disallows user to call super.hashCode if user implemented\n-            \/\/ risk for recursion for experts crafting byte-code\n-            if (!c.isValue())\n-                throw new InternalError(\"must be value or primitive class: \" + c.getName());\n-            Class<?> type = PrimitiveClass.isPrimitiveClass(c) ? PrimitiveClass.asValueType(c) : c;\n-            return (int) HASHCODE_METHOD_HANDLES.get(type).invoke(o);\n-        } catch (Error|RuntimeException e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n-        @Override protected MethodHandle computeValue(Class<?> type) {\n-            return MethodHandleBuilder.primitiveTypeHashCode(type);\n-        }\n-    };\n-\n-    private static final Comparator<MethodHandle> TYPE_SORTER = (mh1, mh2) -> {\n-        \/\/ sort the getters with the return type\n-        Class<?> t1 = mh1.type().returnType();\n-        Class<?> t2 = mh2.type().returnType();\n-        if (t1.isPrimitive()) {\n-            if (!t2.isPrimitive()) {\n-                return 1;\n-            }\n-        } else {\n-            if (t2.isPrimitive()) {\n-                return -1;\n-            }\n-        }\n-        return -1;\n-    };\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/PrimitiveObjectMethods.java","additions":0,"deletions":479,"binary":false,"changes":479,"status":"deleted"},{"patch":"@@ -0,0 +1,494 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.value.PrimitiveClass;\n+import sun.invoke.util.Wrapper;\n+import sun.security.action.GetIntegerAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import static java.lang.invoke.MethodHandles.constant;\n+import static java.lang.invoke.MethodHandles.countedLoop;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.guardWithTest;\n+import static java.lang.invoke.MethodHandles.permuteArguments;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.runtime.ObjectMethods.primitiveEquals;\n+\n+\/**\n+ * Implementation for Object::equals and Object::hashCode for value objects.\n+ *\n+ * ValueObjectMethods::isSubstitutable and valueObjectHashCode are\n+ * private entry points called by VM.\n+ *\/\n+final class ValueObjectMethods {\n+    private ValueObjectMethods() {}\n+    private static final boolean VERBOSE =\n+        GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n+    static class MethodHandleBuilder {\n+        static MethodHandle[] getters(Class<?> type) {\n+            return getters(type, null);\n+        }\n+\n+        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {\n+            \/\/ filter static fields\n+            Stream<MethodHandle> s = Arrays.stream(type.getDeclaredFields())\n+                .filter(f -> !Modifier.isStatic(f.getModifiers()))\n+                .map(f -> {\n+                    try {\n+                        return JLIA.unreflectField(f, false);\n+                    } catch (IllegalAccessException e) {\n+                        throw newLinkageError(e);\n+                    }\n+                });\n+            if (comparator != null) {\n+                s = s.sorted(comparator);\n+            }\n+            return s.toArray(MethodHandle[]::new);\n+        }\n+\n+        static MethodHandle hashCodeForType(Class<?> type) {\n+            if (type.isPrimitive()) {\n+                int index = Wrapper.forPrimitiveType(type).ordinal();\n+                return HASHCODE[index];\n+            } else {\n+                return HASHCODE[Wrapper.OBJECT.ordinal()].asType(methodType(int.class, type));\n+            }\n+        }\n+\n+        static MethodHandle basicPrimitiveEquals(Class<?> type) {\n+            return primitiveEquals.get(type);\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two instances\n+         * of the given reference type are substitutable.\n+         *\n+         * Two values of reference type are substitutable i== iff\n+         * 1. if o1 and o2 are both reference objects then o1 r== o2; or\n+         * 2. if o1 and o2 are both values then o1 v== o2\n+         *\n+         * At invocation time, it needs a dynamic check on the objects and\n+         * do the substitutability test if they are of a value type.\n+         *\/\n+        static MethodHandle referenceTypeEquals(Class<?> type) {\n+            return OBJECT_EQUALS.asType(methodType(boolean.class, type, type));\n+        }\n+\n+        static Class<?> fieldType(MethodHandle getter) {\n+            Class<?> ftype = getter.type().returnType();\n+            return ftype;\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two value objects\n+         * of the given value class are substitutable.\n+         *\/\n+        static MethodHandle valueTypeEquals(Class<?> type) {\n+            assert isValueType(type);\n+            MethodType mt = methodType(boolean.class, type, type);\n+            MethodHandle[] getters = getters(type, TYPE_SORTER);\n+            MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n+            MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n+            MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n+            for (MethodHandle getter : getters) {\n+                Class<?> ftype = fieldType(getter);\n+                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n+                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n+                accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n+            }\n+            \/\/ if both arguments are null, return true;\n+            \/\/ otherwise return accumulator;\n+            return guardWithTest(IS_NULL.asType(mt),\n+                                 instanceTrue,\n+                                 guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n+                                               accumulator,\n+                                               instanceFalse));\n+        }\n+\n+        static MethodHandle valueTypeHashCode(Class<?> type) {\n+            assert isValueType(type);\n+            MethodHandle target = dropArguments(constant(int.class, SALT), 0, type);\n+            MethodHandle cls = dropArguments(constant(Class.class, type),0, type);\n+            MethodHandle classHashCode = filterReturnValue(cls, hashCodeForType(Class.class));\n+            MethodHandle combiner = filterArguments(HASH_COMBINER, 0, target, classHashCode);\n+            \/\/ int v = SALT * 31 + type.hashCode();\n+            MethodHandle init = permuteArguments(combiner, target.type(), 0, 0);\n+            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n+            MethodHandle iterations = dropArguments(constant(int.class, getters.length), 0, type);\n+            MethodHandle[] hashers = new MethodHandle[getters.length];\n+            for (int i=0; i < getters.length; i++) {\n+                MethodHandle getter = getters[i];\n+                Class<?> ftype = fieldType(getter);\n+\n+                \/\/ For basic primitive types or reference types, this calls Objects::hashCode.\n+                \/\/ If the instance is of value type and the hashCode method is not\n+                \/\/ overridden, VM will call valueObjectHashCode to compute the\n+                \/\/ hash code.\n+                MethodHandle hasher = hashCodeForType(ftype);\n+                hashers[i] = filterReturnValue(getter, hasher);\n+            }\n+\n+            \/\/ for (int i=0; i < getters.length; i++) {\n+            \/\/   v = computeHash(v, i, a);\n+            \/\/ }\n+            MethodHandle body = COMPUTE_HASH.bindTo(hashers)\n+                    .asType(methodType(int.class, int.class, int.class, type));\n+            return countedLoop(iterations, init, body);\n+        }\n+\n+        \/\/ ------ utility methods ------\n+        private static boolean eq(Object a, Object b)   {\n+            if (a == null && b == null) return true;\n+            if (a == null || b == null) return false;\n+            if (a.getClass() != b.getClass()) return false;\n+            return a.getClass().isValue() ? valueEquals(a, b) : (a == b);\n+        }\n+\n+        \/*\n+         * Returns true if two value objects are substitutable.\n+         *\/\n+        private static boolean valueEquals(Object a, Object b) {\n+            assert a != null && b != null && isSameValueClass(a, b);\n+            try {\n+                Class<?> type = a.getClass();\n+                if (PrimitiveClass.isPrimitiveClass(type)) {\n+                    type = PrimitiveClass.asValueType(type);\n+                }\n+                return (boolean) substitutableInvoker(type).invoke(type.cast(a), type.cast(b));\n+            } catch (Error|RuntimeException e) {\n+                throw e;\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        private static boolean isNull(Object a, Object b) {\n+            \/\/ avoid acmp that will call isSubstitutable\n+            if (a != null) return false;\n+            if (b != null) return false;\n+            return true;\n+        }\n+\n+        \/*\n+         * Returns true if the given objects are of the same value class.\n+         *\n+         * Two objects are of the same value class iff:\n+         * 1. a != null and b != null\n+         * 2. the declaring class of a and b is the same value class\n+         *\/\n+        private static boolean isSameValueClass(Object a, Object b) {\n+            if (a == null || b == null) return false;\n+\n+            return a.getClass().isValue() && a.getClass() == b.getClass();\n+        }\n+\n+        private static int hashCombiner(int accumulator, int value) {\n+            return accumulator * 31 + value;\n+        }\n+\n+        private static int computeHashCode(MethodHandle[] hashers, int v, int i, Object o) {\n+            try {\n+                int hc = (int)hashers[i].invoke(o);\n+                return hashCombiner(v, hc);\n+            } catch (Error|RuntimeException e) {\n+                throw e;\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        private static final MethodHandle FALSE = constant(boolean.class, false);\n+        private static final MethodHandle TRUE = constant(boolean.class, true);\n+        private static final MethodHandle OBJECT_EQUALS =\n+            findStatic(\"eq\", methodType(boolean.class, Object.class, Object.class));\n+        private static final MethodHandle IS_SAME_VALUE_CLASS =\n+            findStatic(\"isSameValueClass\", methodType(boolean.class, Object.class, Object.class));\n+        private static final MethodHandle IS_NULL =\n+            findStatic(\"isNull\", methodType(boolean.class, Object.class, Object.class));\n+        private static final MethodHandle HASH_COMBINER =\n+            findStatic(\"hashCombiner\", methodType(int.class, int.class, int.class));\n+        private static final MethodHandle COMPUTE_HASH =\n+            findStatic(\"computeHashCode\", methodType(int.class, MethodHandle[].class, int.class, int.class, Object.class));\n+        private static final MethodHandle[] HASHCODE = initHashCode();\n+\n+        private static MethodHandle[] initHashCode() {\n+            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n+            for (Wrapper wrapper : Wrapper.values()) {\n+                if (wrapper == Wrapper.VOID) continue;\n+                Class<?> cls = wrapper == Wrapper.OBJECT ? Objects.class : wrapper.wrapperType();\n+                mhs[wrapper.ordinal()] = findStatic(cls, \"hashCode\",\n+                                                    methodType(int.class, wrapper.primitiveType()));\n+            }\n+            return mhs;\n+        }\n+\n+        private static MethodHandle findStatic(String name, MethodType methodType) {\n+            return findStatic(MethodHandleBuilder.class, name, methodType);\n+        }\n+        private static MethodHandle findStatic(Class<?> cls, String name, MethodType methodType) {\n+            try {\n+                return JLIA.findStatic(cls, name, methodType);\n+            } catch (IllegalAccessException e) {\n+                throw newLinkageError(e);\n+            }\n+        }\n+\n+        \/**\n+         * A \"salt\" value used for this internal hashcode implementation that\n+         * needs to vary sufficiently from one run to the next so that\n+         * the default hashcode for value types will vary between JVM runs.\n+         *\/\n+        static final int SALT;\n+        static {\n+            long nt = System.nanoTime();\n+            int value = (int)((nt >>> 32) ^ nt);\n+            SALT = GetIntegerAction.privilegedGetProperty(\"value.bsm.salt\", value);\n+        }\n+    }\n+\n+    private static LinkageError newLinkageError(Throwable e) {\n+        return (LinkageError) new LinkageError().initCause(e);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the arguments are <em>substitutable<\/em> to each\n+     * other and {@code false} otherwise.\n+     * <em>Substitutability<\/em> means that they cannot be distinguished from\n+     * each other in any data-dependent way, meaning that it is safe to substitute\n+     * one for the other.\n+     *\n+     * <ul>\n+     * <li>If {@code a} and {@code b} are both {@code null}, this method returns\n+     *     {@code true}.\n+     * <li>If {@code a} and {@code b} are both instances of the same value class\n+     *     {@code V}, this method returns {@code true} if, for all fields {@code f}\n+     *      declared in {@code V}, {@code a.f} and {@code b.f} are substitutable.\n+     * <li>If {@code a} and {@code b} are both values of the same basic primitive type,\n+     *     this method returns {@code a == b} with the following exception:\n+     *     <ul>\n+     *     <li> If {@code a} and {@code b} both represent {@code NaN},\n+     *          this method returns {@code true}, even though {@code NaN == NaN}\n+     *          has the value {@code false}.\n+     *     <li> If {@code a} is floating point positive zero while {@code b} is\n+     *          floating point negative zero, or vice versa, this method\n+     *          returns {@code false}, even though {@code +0.0 == -0.0} has\n+     *          the value {@code true}.\n+     *     <\/ul>\n+     * <li>If {@code a} and {@code b} are both instances of the same reference type,\n+     *     this method returns {@code a == b}.\n+     * <li>Otherwise this method returns {@code false}.\n+     * <\/ul>\n+     *\n+     * <p>For example,\n+     * <pre>{@code interface Number { ... }\n+     * \/\/ ordinary reference class\n+     * class IntNumber implements Number { ... }\n+     * \/\/ value class\n+     * value class IntValue implements Number {\n+     *     int i;\n+     *     :\n+     *     public static IntValue of(int i) {...}     \/\/ IntValue::of creates a new value instance\n+     * }\n+     * \/\/ value class with an Object field\n+     * value class RefValue {\n+     *     Object o;\n+     *     :\n+     * }\n+     *\n+     * var val1 = IntValue.of(10);\n+     * var val2 = IntValue.of(10);                    \/\/ val1 and val2 have the same value\n+     * var ref1 = new IntNumber(10);                  \/\/ ref1 and ref2 are two reference instances\n+     * var ref2 = new IntNumber(10);\n+     * assertTrue(isSubstitutable(val1, val2));       \/\/ val1 and val2 are both value instances of IntValue\n+     * assertFalse(isSubstitutable(ref1, ref2));      \/\/ ref1 and ref2 are two reference instances that are not substitutable\n+     * assertTrue(isSubstitutable(ref1, ref1));       \/\/ a reference instance is substitutable with itself\n+     *\n+     * var rval1 = RefValue.of(List.of(\"list\"));      \/\/ rval1.o and rval2.o both contain a list of one-single element \"list\"\n+     * var rval2 = RefValue.of(List.of(\"list\");\n+     * var rval3 = RefValue.of(rval1.o);\n+     *\n+     * assertFalse(isSubstitutable(rval1, rval2));    \/\/ rval1.o and rval2.o are two different List instances and hence not substitutable\n+     * assertTrue(isSubstitutable(rval1, rval3 ));    \/\/ rval1.o and rval3.o are the same reference instance\n+     * }<\/pre>\n+     *\n+     * @param a an object\n+     * @param b an object to be compared with {@code a} for substitutability\n+     * @return {@code true} if the arguments are substitutable to each other;\n+     *         {@code false} otherwise.\n+     * @param <T> type\n+     * @see Float#equals(Object)\n+     * @see Double#equals(Object)\n+     *\/\n+    private static <T> boolean isSubstitutable(T a, Object b) {\n+        if (VERBOSE) {\n+            System.out.println(\"substitutable \" + a + \" vs \" + b);\n+        }\n+\n+        \/\/ Called directly from the VM.\n+        \/\/\n+        \/\/ DO NOT use \"==\" or \"!=\" on args \"a\" and \"b\", with this code or any of\n+        \/\/ its callees. Could be inside of if_acmp<eq|ne> bytecode implementation.\n+\n+        if (a == null && b == null) return true;\n+        if (a == null || b == null) return false;\n+        if (a.getClass() != b.getClass()) return false;\n+\n+        try {\n+            Class<?> type = a.getClass();\n+            if (PrimitiveClass.isPrimitiveClass(type)) {\n+                type = PrimitiveClass.asValueType(type);\n+            }\n+            return (boolean) substitutableInvoker(type).invoke(a, b);\n+        } catch (Error|RuntimeException e) {\n+            if (VERBOSE) e.printStackTrace();\n+            throw e;\n+        } catch (Throwable e) {\n+            if (VERBOSE) e.printStackTrace();\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Produces a method handle which tests if two arguments are\n+     * {@linkplain #isSubstitutable(Object, Object) substitutable}.\n+     *\n+     * <ul>\n+     * <li>If {@code T} is a non-floating point primitive type, this method\n+     *     returns a method handle testing the two arguments are the same value,\n+     *     i.e. {@code a == b}.\n+     * <li>If {@code T} is {@code float} or {@code double}, this method\n+     *     returns a method handle representing {@link Float#equals(Object)} or\n+     *     {@link Double#equals(Object)} respectively.\n+     * <li>If {@code T} is a reference type that is not {@code Object} and not an\n+     *     interface, this method returns a method handle testing\n+     *     the two arguments are the same reference, i.e. {@code a == b}.\n+     * <li>If {@code T} is a value type, this method returns\n+     *     a method handle that returns {@code true} if\n+     *     for all fields {@code f} declared in {@code T}, where {@code U} is\n+     *     the type of {@code f}, if {@code a.f} and {@code b.f} are substitutable\n+     *     with respect to {@code U}.\n+     * <li>If {@code T} is an interface or {@code Object}, and\n+     *     {@code a} and {@code b} are of the same value class {@code V},\n+     *     this method returns a method handle that returns {@code true} if\n+     *     {@code a} and {@code b} are substitutable with respect to {@code V}.\n+     * <\/ul>\n+     *\n+     * @param type class type\n+     * @param <T> type\n+     * @return a method handle for substitutability test\n+     *\/\n+    private static <T> MethodHandle substitutableInvoker(Class<T> type) {\n+        if (type.isPrimitive())\n+            return MethodHandleBuilder.basicPrimitiveEquals(type);\n+\n+        if (isValueType(type)) {\n+            return SUBST_TEST_METHOD_HANDLES.get(type);\n+        }\n+        return MethodHandleBuilder.referenceTypeEquals(type);\n+    }\n+\n+    \/\/ store the method handle for value types in ClassValue\n+    private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {\n+        @Override protected MethodHandle computeValue(Class<?> type) {\n+            return MethodHandleBuilder.valueTypeEquals(type);\n+        }\n+    };\n+\n+    \/**\n+     * Invoke the hashCode method for the given value object.\n+     * @param o the instance to hash.\n+     * @return the hash code of the given value object.\n+     *\/\n+    private static int valueObjectHashCode(Object o) {\n+        Class<?> c = o.getClass();\n+        try {\n+            \/\/ Note: javac disallows user to call super.hashCode if user implemented\n+            \/\/ risk for recursion for experts crafting byte-code\n+            if (!c.isValue())\n+                throw new InternalError(\"must be value or primitive class: \" + c.getName());\n+\n+            Class<?> type = PrimitiveClass.isPrimitiveClass(c) ? PrimitiveClass.asValueType(c) : c;\n+            return (int) HASHCODE_METHOD_HANDLES.get(type).invoke(o);\n+        } catch (Error|RuntimeException e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            if (VERBOSE) e.printStackTrace();\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the given type is a value type.\n+     *\n+     * If the given type represents a primitive class, this method returns\n+     * true if the given type is a primitive type.  If the given type\n+     * is a primitive class reference type, this method returns false.\n+     *\n+     * If the given type represents a basic primitive type, this method\n+     * returns false.\n+     *\/\n+    private static boolean isValueType(Class<?> type) {\n+        if (!type.isValue()) return false;\n+\n+        return !PrimitiveClass.isPrimitiveClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+    }\n+\n+    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n+        @Override protected MethodHandle computeValue(Class<?> type) {\n+            return MethodHandleBuilder.valueTypeHashCode(type);\n+        }\n+    };\n+\n+    private static final Comparator<MethodHandle> TYPE_SORTER = (mh1, mh2) -> {\n+        \/\/ sort the getters with the return type\n+        Class<?> t1 = mh1.type().returnType();\n+        Class<?> t2 = mh2.type().returnType();\n+        if (t1.isPrimitive()) {\n+            if (!t2.isPrimitive()) {\n+                return 1;\n+            }\n+        } else {\n+            if (t2.isPrimitive()) {\n+                return -1;\n+            }\n+        }\n+        return -1;\n+    };\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":494,"deletions":0,"binary":false,"changes":494,"status":"added"},{"patch":"@@ -168,1 +168,1 @@\n-        protected static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.runtime.PrimitiveObjectMethods::isSubstitutable\" + END;\n+        protected static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.runtime.ValueObjectMethods::isSubstitutable\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @summary Verify that call reresolution works for C2 compiled calls to java.lang.runtime.PrimitiveObjectMethods::isSubstitutable0.\n+ * @summary Verify that call reresolution works for C2 compiled calls to java.lang.runtime.ValueObjectMethods::isSubstitutable0.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIsSubstitutableReresolution.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-     * This verifies PrimitiveObjectMethods::isSubstitutable that does not\n+     * This verifies ValueObjectMethods::isSubstitutable that does not\n@@ -213,1 +213,1 @@\n-            Class<?> c = Class.forName(\"java.lang.runtime.PrimitiveObjectMethods\");\n+            Class<?> c = Class.forName(\"java.lang.runtime.ValueObjectMethods\");\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}