{"files":[{"patch":"@@ -1126,1 +1126,1 @@\n-      bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+      bool next_needs_patching = !next_field->holder()->is_initialized() ||\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -661,1 +661,1 @@\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n+          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n@@ -761,1 +761,1 @@\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n+          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2041,7 +2041,1 @@\n-          InlineTypeNode* vt2 = u->as_InlineType();\n-          for (uint i = 0; i < vt2->field_count(); ++i) {\n-            if (vt2->field_value(i) == vt && !vt2->field_is_flattened(i)) {\n-              \/\/ Use in non-flat field\n-              must_be_buffered = true;\n-            }\n-          }\n+          \/\/ InlineType uses don't need buffering because they are about to be replaced as well\n@@ -2050,1 +2044,1 @@\n-        } else if (u->Opcode() != Op_Return || !tf()->returns_inline_type_as_fields()) {\n+        } else {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+      if (val2->is_Phi()) {\n+        val2 = gvn->transform(val2);\n+      }\n@@ -879,1 +882,1 @@\n-  assert(!null_free || vt->is_allocated(&gvn), \"inline type should be allocated\");\n+  assert(vt->is_allocated(&gvn) || (null_free && !vk->is_initialized()), \"inline type should be allocated\");\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-  } else if (val->is_InlineType() && !field->is_null_free()) {\n+  } else if (val->is_InlineType() && !field->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1612,0 +1612,5 @@\n+    \/\/ Pass arguments via fields to avoid exzessive spilling leading to compilation bailouts\n+    static Test51Value test51_arg1;\n+    static MyValue1 test51_arg2;\n+    static Object test51_arg3;\n+\n@@ -1614,2 +1619,2 @@\n-    public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {\n-        return holder.test(holder, vt1, vt2);\n+    public long test51() {\n+        return test51_arg1.test(test51_arg1, test51_arg2, test51_arg3);\n@@ -1625,1 +1630,4 @@\n-        long result = test51(holder, vt, vt);\n+        test51_arg1 = holder;\n+        test51_arg2 = vt;\n+        test51_arg3 = vt;\n+        long result = test51();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}