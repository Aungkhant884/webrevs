{"files":[{"patch":"@@ -3363,0 +3363,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -1366,0 +1366,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1455,0 +1457,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1644,0 +1658,2 @@\n+  _restricted_field_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1674,0 +1690,1 @@\n+\n@@ -1706,0 +1723,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1715,0 +1734,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1749,0 +1770,9 @@\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1752,1 +1782,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1754,0 +1784,3 @@\n+    _restricted_field_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1756,3 +1789,2 @@\n-    \/\/ Remember how many oops we encountered and compute allocation type\n-    const FieldAllocationType atype = fac->update(is_static, type, type == T_INLINE_TYPE);\n-    field->set_allocation_type(atype);\n+    \/\/ \/\/ Remember how many oops we encountered\n+    fac->update(is_static, type, type == T_INLINE_TYPE);\n@@ -1801,3 +1833,2 @@\n-      \/\/ Remember how many oops we encountered and compute allocation type\n-      const FieldAllocationType atype = fac->update(false, type, false);\n-      field->set_allocation_type(atype);\n+      \/\/ Remember how many oops we encountered\n+      fac->update(false, type, false);\n@@ -1805,0 +1836,1 @@\n+      _restricted_field_info->append(0);\n@@ -1808,0 +1840,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1815,2 +1848,2 @@\n-    const FieldAllocationType atype = fac->update(true, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(true, type, false);\n@@ -1818,0 +1851,1 @@\n+    _restricted_field_info->append(vmSymbols::object_signature_enum);\n@@ -1820,0 +1854,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1828,2 +1865,2 @@\n-    const FieldAllocationType atype = fac->update(false, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(false, type, false);\n@@ -1831,0 +1868,1 @@\n+    _restricted_field_info->append(vmSymbols::byte_signature_enum);\n@@ -5789,0 +5827,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_erased_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _restricted_field_info->at(i);\n+    }\n+  }\n+\n@@ -5980,0 +6026,1 @@\n+  _restricted_field_info(NULL),\n@@ -6019,0 +6066,1 @@\n+  _has_restricted_fields(false),\n@@ -6592,0 +6640,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6594,1 +6643,0 @@\n-      \/\/ Pre-load inline class\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":61,"deletions":13,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -523,0 +523,23 @@\n+JRT_ENTRY(void, InterpreterRuntime::check_restricted_type(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  ConstantPoolCacheEntry* cp_entry = last_frame.cache_entry();\n+  int offset = cp_entry->f2_as_offset();\n+  InstanceKlass* holder = InstanceKlass::cast(cp_entry->f1_as_klass());\n+  fieldDescriptor fd;\n+  bool is_static = last_frame.bytecode().code() == Bytecodes::_putstatic;\n+  holder->find_field_from_offset(offset, is_static, &fd);\n+  Klass* field_klass = holder->get_inline_type_field_klass_or_null(fd.index());\n+  if (field_klass == NULL) {\n+    field_klass = SystemDictionary::resolve_or_fail(holder->field_signature(fd.index())->fundamental_name(THREAD),\n+        Handle(THREAD, holder->class_loader()),\n+        Handle(THREAD, holder->protection_domain()),\n+        true, CHECK);\n+    holder->set_inline_type_field_klass(fd.index(), field_klass);\n+  }\n+  assert(field_klass != NULL, \"Must have been set\");\n+  oop value = cast_to_oop(*last_frame.get_frame().interpreter_frame_tos_at(0));\n+  assert(value != NULL, \"Inline types cannot be NULL\");\n+  Klass* value_klass = value->klass();\n+  assert(value_klass->is_subtype_of(field_klass), \"Just checking\");\n+JRT_END\n+\n@@ -949,0 +972,1 @@\n+    info.has_restricted_type(),\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  static void check_restricted_type(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -173,0 +174,29 @@\n+inline u2* InstanceKlass::fields_erased_type() {\n+    assert(has_restricted_fields(), \"Should not be called otherwise\");\n+    if (is_inline_klass()) {\n+      return (u2*)((address)(InlineKlass::cast(this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n+    }\n+\n+    address adr_jf = adr_inline_type_field_klasses();\n+    if (adr_jf != NULL) {\n+      return (u2*)(adr_jf + this->java_fields_count() * sizeof(Klass*));\n+    }\n+\n+    address adr_fing = adr_fingerprint();\n+    if (adr_fing != NULL) {\n+      return (u2*)(adr_fingerprint() + sizeof(u8));\n+    }\n+\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (u2*)(adr_host + 1);\n+    }\n+\n+    Klass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (u2*)(adr_impl + 1);\n+    }\n+\n+    return (u2*)end_of_nonstatic_oop_maps();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2235,1 +2235,3 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_MASK\", FIELDINFO_TAG_MASK) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}