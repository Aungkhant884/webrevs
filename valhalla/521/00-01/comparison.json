{"files":[{"patch":"@@ -64,1 +64,0 @@\n-        UNIVERSAL_TVARS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,0 +415,5 @@\n+    \/**\n+     * Flag to indicate that the type variables is universal\n+     *\/\n+    public static final long UNIVERSAL = 1L<<61; \/\/ TypeVariableSymbols\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-            case UNIVERSAL_TVARS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1946,3 +1946,1 @@\n-        public boolean universal = false;\n-\n-        public boolean createdFromUniversalTypeVar = false;\n+        public TVFlavor flavor;\n@@ -1955,1 +1953,1 @@\n-        public TypeVar referenceProjection = null;\n+        public TypeVar projection = null;\n@@ -1957,5 +1955,5 @@\n-        \/** link back to universal type var when applicable, this field will have a value if this current\n-         *  type variable was derived form a type variable declaration using the .ref suffix, once the code\n-         *  is more mature we can fold fields referenceTypeVar and universalTypeVar\n-         *\/\n-        public TypeVar universalTypeVar = null;\n+        public enum TVFlavor {\n+            REFERENCE,\n+            UNIVERSAL,\n+            REFERENCE_FROM_UNIVERSAL\n+        }\n@@ -1964,1 +1962,1 @@\n-            this(name, owner, lower, false);\n+            this(name, owner, lower, TVFlavor.REFERENCE);\n@@ -1967,1 +1965,1 @@\n-        public TypeVar(Name name, Symbol owner, Type lower, boolean universal) {\n+        public TypeVar(Name name, Symbol owner, Type lower, TVFlavor flavor) {\n@@ -1970,1 +1968,1 @@\n-            tsym = new TypeVariableSymbol(0, name, this, owner);\n+            tsym = new TypeVariableSymbol(flavor == TVFlavor.UNIVERSAL ? UNIVERSAL : 0, name, this, owner);\n@@ -1973,1 +1971,1 @@\n-            this.universal = universal;\n+            this.flavor = flavor;\n@@ -1982,1 +1980,1 @@\n-            this(tsym, bound, lower, metadata, false);\n+            this(tsym, bound, lower, metadata, TVFlavor.REFERENCE);\n@@ -1986,1 +1984,1 @@\n-                       TypeMetadata metadata, boolean universal) {\n+                       TypeMetadata metadata, TVFlavor flavor) {\n@@ -1991,1 +1989,1 @@\n-            this.universal = universal;\n+            this.flavor = flavor;\n@@ -2053,2 +2051,6 @@\n-        public boolean isUniversal() {\n-            return universal;\n+        public TVFlavor getTVFlavor() {\n+            return flavor;\n+        }\n+\n+        public boolean hasUniversalFlavor() {\n+            return flavor == TVFlavor.UNIVERSAL;\n@@ -2060,3 +2062,3 @@\n-                    ((TypeVar)t).createdFromUniversalTypeVar &&\n-                    referenceProjection != null) {\n-                return referenceProjection;\n+                    ((TypeVar)t).flavor == TVFlavor.REFERENCE_FROM_UNIVERSAL &&\n+                    projection != null) {\n+                return projection;\n@@ -2067,4 +2069,6 @@\n-        public void createReferenceProjection() {\n-            referenceProjection = new TypeVar(tsym, _bound, lower, metadata, false);\n-            referenceProjection.createdFromUniversalTypeVar = true;\n-            referenceProjection.universalTypeVar = this;\n+        @Override\n+        public TypeVar referenceProjection() {\n+            if (projection == null) {\n+                projection = new TypeVar(tsym, _bound, lower, metadata, TVFlavor.REFERENCE_FROM_UNIVERSAL);\n+            }\n+            return projection;\n@@ -2091,2 +2095,1 @@\n-            this.universal = upper.hasTag(TYPEVAR) && ((TypeVar)upper).universal ||\n-                    lower.hasTag(TYPEVAR) && ((TypeVar)lower).universal;\n+            this.flavor = wildcard.bound != null ? wildcard.bound.flavor : TVFlavor.REFERENCE;\n@@ -2103,2 +2106,1 @@\n-            this.universal = upper.hasTag(TYPEVAR) && ((TypeVar)upper).universal ||\n-                    lower.hasTag(TYPEVAR) && ((TypeVar)lower).universal;\n+            this.flavor = wildcard.bound != null ? wildcard.bound.flavor : TVFlavor.REFERENCE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":31,"deletions":29,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n-        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n-                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -615,2 +614,2 @@\n-        if (allowUniversalTVars && (s.hasTag(TYPEVAR)) && ((TypeVar)s).isUniversal() &&\n-                (t.hasTag(BOT) || t.hasTag(TYPEVAR) && !((TypeVar)t).isUniversal())) {\n+        if (allowUniversalTVars && (s.hasTag(TYPEVAR)) && ((TypeVar)s).hasUniversalFlavor() &&\n+                (t.hasTag(BOT) || t.hasTag(TYPEVAR) && !((TypeVar)t).hasUniversalFlavor())) {\n@@ -1043,1 +1042,1 @@\n-            } else if (t.hasTag(TYPEVAR) && ((TypeVar)t).universal) {\n+            } else if (t.hasTag(TYPEVAR) && ((TypeVar)t).hasUniversalFlavor()) {\n@@ -1045,1 +1044,1 @@\n-            } else if (s.hasTag(TYPEVAR) && ((TypeVar)s).universal) {\n+            } else if (s.hasTag(TYPEVAR) && ((TypeVar)s).hasUniversalFlavor()) {\n@@ -1090,1 +1089,0 @@\n-                \/\/ we are seeing a case of a universal type variable being assigned to a non-universal one\n@@ -1188,1 +1186,1 @@\n-                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).universal) {\n+                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).hasUniversalFlavor()) {\n@@ -1709,1 +1707,1 @@\n-                    if (allowUniversalTVars && t.universal != other.universal && t.tsym == other.tsym)\n+                    if (allowUniversalTVars && t.hasUniversalFlavor() != other.hasUniversalFlavor() && t.tsym == other.tsym)\n@@ -3616,1 +3614,1 @@\n-                        t.createdFromUniversalTypeVar &&\n+                        t.flavor == TypeVar.TVFlavor.REFERENCE_FROM_UNIVERSAL &&\n@@ -3618,2 +3616,2 @@\n-                        ((TypeVar)from.head).referenceProjection != null &&\n-                        t.equalsIgnoreMetadata(((TypeVar)from.head).referenceProjection)) {\n+                        ((TypeVar)from.head).projection != null &&\n+                        t.equalsIgnoreMetadata(((TypeVar)from.head).projection)) {\n@@ -3771,3 +3769,3 @@\n-                TypeVar newTV = new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata(), t.universal);\n-                if (t.referenceProjection != null) {\n-                    newTV.createReferenceProjection();\n+                TypeVar newTV = new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata(), t.flavor);\n+                if (t.projection != null) {\n+                    newTV.referenceProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.function.Predicate;\n@@ -178,2 +177,1 @@\n-        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n-                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -822,4 +820,0 @@\n-        return attribTypes(trees, env, i -> false);\n-    }\n-\n-    List<Type> attribTypes(List<JCExpression> trees, Env<AttrContext> env, Predicate<JCExpression> valueOK) {\n@@ -827,1 +821,1 @@\n-        return chk.checkRefTypes(trees, types, valueOK);\n+        return chk.checkRefTypes(trees, types);\n@@ -2659,1 +2653,1 @@\n-            chk.checkRefTypes(tree.typeargs, typeargtypes, false);\n+            chk.checkRefTypes(tree.typeargs, typeargtypes);\n@@ -2669,1 +2663,1 @@\n-                boolean qualifierIsUniversal = allowUniversalTVars && qualifier.hasTag(TYPEVAR) && ((TypeVar)qualifier).universal;\n+                boolean qualifierIsUniversal = allowUniversalTVars && qualifier.hasTag(TYPEVAR) && ((TypeVar)qualifier).hasUniversalFlavor();\n@@ -4606,1 +4600,1 @@\n-                if (allowUniversalTVars && name == names.ref && ((TypeVar)site).universal) {\n+                if (allowUniversalTVars && name == names.ref && ((TypeVar)site).hasUniversalFlavor()) {\n@@ -4608,2 +4602,1 @@\n-                    if (siteTV.referenceProjection == null) {\n-                        siteTV.createReferenceProjection();\n+                    if (siteTV.projection == null) {\n@@ -4611,1 +4604,1 @@\n-                        tmpTVarSym.type = siteTV.referenceProjection;\n+                        tmpTVarSym.type = siteTV.referenceProjection();\n@@ -4614,1 +4607,1 @@\n-                    tmpTVarSym.type = siteTV.referenceProjection;\n+                    tmpTVarSym.type = siteTV.referenceProjection();\n@@ -5147,1 +5140,1 @@\n-        Set<JCExpression> valueOKSet = new HashSet<>();\n+        List<Type> actuals;\n@@ -5149,1 +5142,6 @@\n-        if (args != null && !args.isEmpty()) {\n+        if (!allowUniversalTVars || args == null || args.isEmpty()) {\n+            actuals = attribTypes(tree.arguments, env);\n+        } else {\n+            \/\/ we use argTypes2 to keep a pointer to the original list as we will use argTypes to iterate over it\n+            List<Type> argTypes, argTypes2;\n+            argTypes2 = argTypes = attribAnyTypes(args, env);\n@@ -5151,4 +5149,1 @@\n-                TypeVar tv = (TypeVar) t;\n-                if (tv.universal) {\n-                    valueOKSet.add(args.head);\n-                }\n+                argTypes.head = chk.checkRefType(args.head.pos(), argTypes.head, ((TypeVar) t).hasUniversalFlavor());\n@@ -5156,0 +5151,1 @@\n+                argTypes = argTypes.tail;\n@@ -5157,0 +5153,1 @@\n+            actuals = argTypes2;\n@@ -5159,5 +5156,0 @@\n-        \/\/ Attribute type parameters\n-        List<Type> actuals = !allowUniversalTVars ?\n-                attribTypes(tree.arguments, env) :\n-                attribTypes(tree.arguments, env, arg -> valueOKSet.contains(arg));\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -166,2 +166,1 @@\n-        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n-                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -910,1 +909,1 @@\n-    List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types, boolean valueOK) {\n+    List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types) {\n@@ -913,10 +912,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, valueOK);\n-            tl = tl.tail;\n-        }\n-        return types;\n-    }\n-\n-    List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types, Predicate<JCExpression> valueOK) {\n-        List<JCExpression> tl = trees;\n-        for (List<Type> l = types; l.nonEmpty(); l = l.tail) {\n-            l.head = checkRefType(tl.head.pos(), l.head, valueOK.test(tl.head));\n+            l.head = checkRefType(tl.head.pos(), l.head, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-            : new TypeVar(tree.name, env.info.scope.owner, syms.botType, tree.universal);\n+            : new TypeVar(tree.name, env.info.scope.owner, syms.botType, tree.universal ? TypeVar.TVFlavor.UNIVERSAL : TypeVar.TVFlavor.REFERENCE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,2 +341,1 @@\n-        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n-                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -1875,1 +1874,1 @@\n-                    sym.type.hasTag(TYPEVAR) && ((Type.TypeVar)sym.type).universal);\n+                    sym.type.hasTag(TYPEVAR) && ((Type.TypeVar)sym.type).hasUniversalFlavor());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -197,2 +197,1 @@\n-        this.allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n-                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n+        this.allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3926,5 +3926,1 @@\n-    variables of type universal type variable cannot be assigned null\n-\n-# 0: name (of method)\n-compiler.warn.method.should.not.be.invoked.on.universal.tvars=\\\n-    method {0} should not be invoked on universal type variables\n\\ No newline at end of file\n+    variables of type universal type variable cannot be assigned null\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-            TypeParameter(name, Types(types.getBounds(tvar)), List.nil(), tvar.universal).setPos(pos).setType(tvar);\n+            TypeParameter(name, Types(types.getBounds(tvar)), List.nil(), tvar.hasUniversalFlavor()).setPos(pos).setType(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+compiler.misc.feature.universal.tvars\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.warn.method.should.not.be.invoked.on.universal.tvars\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n-\n-primitive class Point {}\n-\n-class Test<__universal T> {\n-    void m(T t) throws Throwable {\n-        t.wait();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantInvokeWaitOnUniversal.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -26,3 +26,1 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:universal\n+\/\/ options: -Xlint:universal\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UniversalCantBeAssignedNull.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.feature.universal.tvars\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class C<__universal T> {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UniversalTVars.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -48,4 +48,1 @@\n-    private static String[] PREVIEW_OPTIONS = {\n-        \"--enable-preview\",\n-        \"-source\", Integer.toString(Runtime.version().feature())\n-    };\n+    private static String[] EMPTY_OPTIONS = {};\n@@ -53,3 +50,1 @@\n-    private static String[] PREVIEW_OPTIONS_WITH_LINT = {\n-        \"--enable-preview\",\n-        \"-source\", Integer.toString(Runtime.version().feature()),\n+    private static String[] LINT_OPTIONS = {\n@@ -64,1 +59,1 @@\n-        setCompileOptions(PREVIEW_OPTIONS_WITH_LINT);\n+        setCompileOptions(LINT_OPTIONS);\n@@ -90,1 +85,1 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n+        setCompileOptions(EMPTY_OPTIONS);\n@@ -120,1 +115,1 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n+        setCompileOptions(EMPTY_OPTIONS);\n@@ -250,1 +245,1 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n+        setCompileOptions(EMPTY_OPTIONS);\n@@ -271,1 +266,1 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n+        setCompileOptions(EMPTY_OPTIONS);\n@@ -305,1 +300,1 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n+        setCompileOptions(EMPTY_OPTIONS);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"}]}