{"files":[{"patch":"@@ -64,0 +64,1 @@\n+        UNIVERSAL_TVARS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -327,1 +327,6 @@\n-        PREVIEW(\"preview\");\n+        PREVIEW(\"preview\"),\n+\n+        \/**\n+         * Warn about use of universal type variables.\n+         *\/\n+        UNIVERSAL(\"universal\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+            case UNIVERSAL_TVARS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+        UNIVERSAL_TVARS(JDK18, Fragments.FeatureUniversalTvars, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1946,0 +1946,17 @@\n+        public boolean universal = false;\n+\n+        public boolean createdFromUniversalTypeVar = false;\n+\n+        \/** if this type variable is universal then it will also have a link to a pure reference\n+         *  type variable, it is important to know that a universal type variable and its\n+         *  corresponding referenceTypeVar share the same tsym. So if it is needed to double check if\n+         *  a type variable is universal or not, we need to check its type not the type of its tsym\n+         *\/\n+        public TypeVar referenceProjection = null;\n+\n+        \/** link back to universal type var when applicable, this field will have a value if this current\n+         *  type variable was derived form a type variable declaration using the .ref suffix, once the code\n+         *  is more mature we can fold fields referenceTypeVar and universalTypeVar\n+         *\/\n+        public TypeVar universalTypeVar = null;\n+\n@@ -1947,0 +1964,4 @@\n+            this(name, owner, lower, false);\n+        }\n+\n+        public TypeVar(Name name, Symbol owner, Type lower, boolean universal) {\n@@ -1952,0 +1973,1 @@\n+            this.universal = universal;\n@@ -1960,0 +1982,5 @@\n+            this(tsym, bound, lower, metadata, false);\n+        }\n+\n+        public TypeVar(TypeSymbol tsym, Type bound, Type lower,\n+                       TypeMetadata metadata, boolean universal) {\n@@ -1964,0 +1991,1 @@\n+            this.universal = universal;\n@@ -2024,0 +2052,20 @@\n+\n+        public boolean isUniversal() {\n+            return universal;\n+        }\n+\n+        @Override\n+        public Type withTypeVar(Type t) {\n+            if (t.hasTag(TYPEVAR) &&\n+                    ((TypeVar)t).createdFromUniversalTypeVar &&\n+                    referenceProjection != null) {\n+                return referenceProjection;\n+            }\n+            return this;\n+        }\n+\n+        public void createReferenceProjection() {\n+            referenceProjection = new TypeVar(tsym, _bound, lower, metadata, false);\n+            referenceProjection.createdFromUniversalTypeVar = true;\n+            referenceProjection.universalTypeVar = this;\n+        }\n@@ -2043,0 +2091,2 @@\n+            this.universal = upper.hasTag(TYPEVAR) && ((TypeVar)upper).universal ||\n+                    lower.hasTag(TYPEVAR) && ((TypeVar)lower).universal;\n@@ -2053,0 +2103,2 @@\n+            this.universal = upper.hasTag(TYPEVAR) && ((TypeVar)upper).universal ||\n+                    lower.hasTag(TYPEVAR) && ((TypeVar)lower).universal;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+    final boolean allowUniversalTVars;\n@@ -128,0 +129,1 @@\n+        Preview preview = Preview.instance(context);\n@@ -129,0 +131,2 @@\n+        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n+                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -611,0 +615,5 @@\n+        if (allowUniversalTVars && (s.hasTag(TYPEVAR)) && ((TypeVar)s).isUniversal() &&\n+                (t.hasTag(BOT) || t.hasTag(TYPEVAR) && !((TypeVar)t).isUniversal())) {\n+            warn.warn(LintCategory.UNIVERSAL);\n+            return true;\n+        }\n@@ -1017,0 +1026,26 @@\n+    @FunctionalInterface\n+    public interface SubtypeTestFlavor {\n+        boolean subtypeTest(Type t, Type s, Warner warn);\n+    }\n+\n+    public boolean isBoundedBy(Type t, Type s, SubtypeTestFlavor subtypeTestFlavor) {\n+        return isBoundedBy(t, s, noWarnings, subtypeTestFlavor);\n+    }\n+\n+    \/**\n+     * Is type t bounded by s?\n+     *\/\n+    public boolean isBoundedBy(Type t, Type s, Warner warn, SubtypeTestFlavor subtypeTestFlavor) {\n+        boolean result = subtypeTestFlavor.subtypeTest(t, s, warn);\n+        if (allowUniversalTVars && !result) {\n+            if (isPrimitiveClass(t)) {\n+                return isBoundedBy(t.referenceProjection(), s, warn, subtypeTestFlavor);\n+            } else if (t.hasTag(TYPEVAR) && ((TypeVar)t).universal) {\n+                return isBoundedBy(t.getUpperBound(), s, warn, subtypeTestFlavor);\n+            } else if (s.hasTag(TYPEVAR) && ((TypeVar)s).universal) {\n+                return isBoundedBy(t, s.getLowerBound(), warn, subtypeTestFlavor);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -1054,0 +1089,4 @@\n+            } else if (allowUniversalTVars && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+                \/\/ we are seeing a case of a universal type variable being assigned to a non-universal one\n+                warn.warn(LintCategory.UNIVERSAL);\n+                return true;\n@@ -1105,0 +1144,3 @@\n+        if (t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+            return true;\n+        }\n@@ -1146,0 +1188,3 @@\n+                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).universal) {\n+                         warnStack.head.warn(LintCategory.UNIVERSAL);\n+                     }\n@@ -1644,2 +1689,4 @@\n-                        || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &&\n-                            (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));\n+                        || ((t.isExtendsBound() || isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n+                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))) &&\n+                            (t.isSuperBound() || isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n+                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))));\n@@ -1658,0 +1705,10 @@\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar other = (TypeVar)s;\n+                    if (allowUniversalTVars && t.universal != other.universal && t.tsym == other.tsym)\n+                        return true;\n+                }\n+                return isSameType(t, s);\n+            }\n+\n@@ -2078,1 +2135,1 @@\n-        return !isSubtype(t, relaxBound(s));\n+        return !isBoundedBy(t, relaxBound(s), (t1, s1, w) -> isSubtype(t1, s1));\n@@ -3558,0 +3615,7 @@\n+                if (allowUniversalTVars &&\n+                        t.createdFromUniversalTypeVar &&\n+                        from.head.hasTag(TYPEVAR) &&\n+                        ((TypeVar)from.head).referenceProjection != null &&\n+                        t.equalsIgnoreMetadata(((TypeVar)from.head).referenceProjection)) {\n+                    return to.head.withTypeVar(t);\n+                }\n@@ -3707,1 +3771,5 @@\n-                return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());\n+                TypeVar newTV = new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata(), t.universal);\n+                if (t.referenceProjection != null) {\n+                    newTV.createReferenceProjection();\n+                }\n+                return newTV;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":72,"deletions":4,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Predicate;\n@@ -177,0 +178,2 @@\n+        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n+                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -225,0 +228,4 @@\n+    \/** Are universal tvars allowed?\n+     *\/\n+    private final boolean allowUniversalTVars;\n+\n@@ -815,0 +822,4 @@\n+        return attribTypes(trees, env, i -> false);\n+    }\n+\n+    List<Type> attribTypes(List<JCExpression> trees, Env<AttrContext> env, Predicate<JCExpression> valueOK) {\n@@ -816,1 +827,1 @@\n-        return chk.checkRefTypes(trees, types);\n+        return chk.checkRefTypes(trees, types, valueOK);\n@@ -2648,1 +2659,1 @@\n-            chk.checkRefTypes(tree.typeargs, typeargtypes);\n+            chk.checkRefTypes(tree.typeargs, typeargtypes, false);\n@@ -2658,1 +2669,2 @@\n-                if (qualifier.tsym.isPrimitiveClass() || superCallOnPrimitiveReceiver) {\n+                boolean qualifierIsUniversal = allowUniversalTVars && qualifier.hasTag(TYPEVAR) && ((TypeVar)qualifier).universal;\n+                if (qualifier.tsym.isPrimitiveClass() || qualifierIsUniversal || superCallOnPrimitiveReceiver) {\n@@ -2666,1 +2678,8 @@\n-                                log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                if (!qualifierIsUniversal) {\n+                                    log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                } else {\n+                                    \/* probably this will be a lint warning in the future, still under discussion\n+                                     * will comment it for now\n+                                     *\/\n+                                    \/\/log.warning(tree.pos(), Warnings.MethodShouldNotBeInvokedOnUniversalTvars(name));\n+                                }\n@@ -2674,1 +2693,8 @@\n-                                log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                if (!qualifierIsUniversal) {\n+                                    log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                } else {\n+                                    \/* probably this will be a lint warning in the future, still under discussion\n+                                     * will comment it for now\n+                                     *\/\n+                                    \/\/log.warning(tree.pos(), Warnings.MethodShouldNotBeInvokedOnUniversalTvars(name));\n+                                }\n@@ -3063,1 +3089,3 @@\n-                    chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    if (!allowUniversalTVars) {\n+                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    }\n@@ -4445,1 +4473,2 @@\n-        tree.sym = sym;\n+        tree.sym = (allowUniversalTVars && site.getTag() == TYPEVAR && tree.name == names.ref) ?\n+                sym.type.tsym : sym;\n@@ -4577,0 +4606,11 @@\n+                if (allowUniversalTVars && name == names.ref && ((TypeVar)site).universal) {\n+                    TypeVar siteTV = (TypeVar)site;\n+                    if (siteTV.referenceProjection == null) {\n+                        siteTV.createReferenceProjection();\n+                        TypeVariableSymbol tmpTVarSym = new TypeVariableSymbol(siteTV.tsym.flags(), siteTV.tsym.name, null, siteTV.tsym.owner);\n+                        tmpTVarSym.type = siteTV.referenceProjection;\n+                    }\n+                    TypeVariableSymbol tmpTVarSym = new TypeVariableSymbol(siteTV.tsym.flags(), siteTV.tsym.name, null, siteTV.tsym.owner);\n+                    tmpTVarSym.type = siteTV.referenceProjection;\n+                    return tmpTVarSym;\n+                }\n@@ -5107,0 +5147,11 @@\n+        Set<JCExpression> valueOKSet = new HashSet<>();\n+        List<JCExpression> args = tree.arguments;\n+        if (args != null && !args.isEmpty()) {\n+            for (Type t : ((ClassType) clazztype.tsym.type).typarams_field) {\n+                TypeVar tv = (TypeVar) t;\n+                if (tv.universal) {\n+                    valueOKSet.add(args.head);\n+                }\n+                args = args.tail;\n+            }\n+        }\n@@ -5109,1 +5160,3 @@\n-        List<Type> actuals = attribTypes(tree.arguments, env);\n+        List<Type> actuals = !allowUniversalTVars ?\n+                attribTypes(tree.arguments, env) :\n+                attribTypes(tree.arguments, env, arg -> valueOKSet.contains(arg));\n@@ -5293,1 +5346,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, allowUniversalTVars),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":62,"deletions":9,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.Function;\n@@ -165,0 +166,2 @@\n+        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n+                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -204,0 +207,4 @@\n+    \/** Are universal tvars allowed\n+     *\/\n+    private final boolean allowUniversalTVars;\n+\n@@ -269,0 +276,9 @@\n+    \/** Warn about operation with universal type variables.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnUniversalTVar(DiagnosticPosition pos, Warning warnKey) {\n+        if (lint.isEnabled(LintCategory.UNIVERSAL))\n+            log.warning(LintCategory.UNIVERSAL, pos, warnKey);\n+    }\n+\n@@ -607,3 +623,5 @@\n-            if (found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n+            if (!allowUniversalTVars) {\n+                if (found.hasTag(CLASS)) {\n+                    if (inferenceContext != infer.emptyContext)\n+                        checkParameterizationByPrimitiveClass(pos, found);\n+                }\n@@ -689,1 +707,1 @@\n-             return types.isSubtype(a, bound);\n+             return types.isBoundedBy(a, bound, (t, s, w) -> types.isSubtype(t, s));\n@@ -851,2 +869,2 @@\n-                                diags.fragment(Fragments.TypeReqRef),\n-                                t);\n+                    diags.fragment(Fragments.TypeReqRef),\n+                    t);\n@@ -892,1 +910,1 @@\n-    List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types) {\n+    List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types, boolean valueOK) {\n@@ -895,1 +913,10 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, false);\n+            l.head = checkRefType(tl.head.pos(), l.head, valueOK);\n+            tl = tl.tail;\n+        }\n+        return types;\n+    }\n+\n+    List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types, Predicate<JCExpression> valueOK) {\n+        List<JCExpression> tl = trees;\n+        for (List<Type> l = types; l.nonEmpty(); l = l.tail) {\n+            l.head = checkRefType(tl.head.pos(), l.head, valueOK.test(tl.head));\n@@ -932,1 +959,3 @@\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n+        if (!allowUniversalTVars) {\n+            parameterizationByPrimitiveClassChecker.visit(t, pos);\n+        }\n@@ -1129,1 +1158,1 @@\n-        if (varType.hasTag(CLASS)) {\n+        if (!allowUniversalTVars && varType.hasTag(CLASS)) {\n@@ -4202,0 +4231,3 @@\n+                case UNIVERSAL:\n+                    Check.this.warnUniversalTVar(pos(), Warnings.UniversalVariableCannotBeAssignedNull);\n+                    break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":42,"deletions":10,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-            : new TypeVar(tree.name, env.info.scope.owner, syms.botType);\n+            : new TypeVar(tree.name, env.info.scope.owner, syms.botType, tree.universal);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import static com.sun.tools.javac.code.TypeTag.TYPEVAR;\n@@ -213,0 +214,1 @@\n+    private final boolean allowUniversalTVars;\n@@ -338,0 +340,3 @@\n+        Preview preview = Preview.instance(context);\n+        allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n+                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -1852,1 +1857,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedFieldOfUniversalTVar(sym));\n@@ -1865,0 +1871,7 @@\n+        boolean isUninitializedFieldOfUniversalTVar(VarSymbol sym) {\n+            return allowUniversalTVars && sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                    sym.type.hasTag(TYPEVAR) && ((Type.TypeVar)sym.type).universal);\n+        }\n+\n@@ -1975,1 +1988,5 @@\n-                    log.error(pos, errkey);\n+                    if (isUninitializedFieldOfUniversalTVar(sym)) {\n+                        log.warning(pos, Warnings.VarMightNotHaveBeenInitialized(sym));\n+                    } else {\n+                        log.error(pos, errkey);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.comp.Attr.CheckMode;\n@@ -1171,1 +1170,1 @@\n-                return types.isSubtypeUnchecked(op1, op2, warn);\n+                return types.isBoundedBy(op1, op2, warn, (t, s, w) -> types.isSubtypeUnchecked(t, s, w));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1056,1 +1056,2 @@\n-                    types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :\n+                    types.isBoundedBy(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn,\n+                                (t, s, w) -> types.isSubtypeUnchecked(t, s, w)) :\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,0 +197,2 @@\n+        this.allowUniversalTVars = (!preview.isPreview(Feature.UNIVERSAL_TVARS) || preview.isEnabled()) &&\n+                Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -240,1 +242,1 @@\n-     boolean allowPrimitiveClasses;\n+    boolean allowPrimitiveClasses;\n@@ -246,0 +248,4 @@\n+    \/** Switch: are primitive classes allowed in this source level?\n+     *\/\n+    boolean allowUniversalTVars;\n+\n@@ -4707,0 +4713,6 @@\n+        boolean universal = false;\n+        if (allowUniversalTVars && token.kind == UNIVERSAL) {\n+            checkSourceLevel(Feature.UNIVERSAL_TVARS);\n+            universal = true;\n+            nextToken();\n+        }\n@@ -4717,1 +4729,3 @@\n-        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));\n+        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos, universal));\n+        \/\/ use the line below to make experiments setting all type variables as universal\n+        \/\/return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos, true));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+        UNIVERSAL(\"__universal\"),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1423,2 +1423,2 @@\n-compiler.err.var.not.initialized.in.default.constructor=\\\n-    variable {0} not initialized in the default constructor\n+compiler.warn.var.might.not.have.been.initialized=\\\n+    variable {0} might not have been initialized\n@@ -2998,0 +2998,3 @@\n+compiler.misc.feature.universal.tvars=\\\n+    universal type variables\n+\n@@ -3915,0 +3918,13 @@\n+\n+### universal type variables\n+\n+# 0: symbol\n+compiler.err.var.not.initialized.in.default.constructor=\\\n+    variable {0} not initialized in the default constructor\n+\n+compiler.warn.universal.variable.cannot.be.assigned.null=\\\n+    variables of type universal type variable cannot be assigned null\n+\n+# 0: name (of method)\n+compiler.warn.method.should.not.be.invoked.on.universal.tvars=\\\n+    method {0} should not be invoked on universal type variables\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -270,0 +270,3 @@\n+javac.opt.Xlint.desc.universal=\\\n+    Warn about potential heap pollution issues when using universal type variables.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2872,1 +2872,4 @@\n-        protected JCTypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annotations) {\n+        \/** is this an universal type variable?  *\/\n+        public boolean universal;\n+\n+        protected JCTypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annotations, boolean universal) {\n@@ -2876,0 +2879,1 @@\n+            this.universal = universal;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-        return M.at(t.pos).TypeParameter(t.name, bounds, annos);\n+        return M.at(t.pos).TypeParameter(t.name, bounds, annos, t.universal);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -587,1 +587,5 @@\n-        JCTypeParameter tree = new JCTypeParameter(name, bounds, annos);\n+        return TypeParameter(name, bounds, annos, false);\n+    }\n+\n+    public JCTypeParameter TypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annos, boolean universal) {\n+        JCTypeParameter tree = new JCTypeParameter(name, bounds, annos, universal);\n@@ -1077,1 +1081,1 @@\n-            TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);\n+            TypeParameter(name, Types(types.getBounds(tvar)), List.nil(), tvar.universal).setPos(pos).setType(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,0 +233,1 @@\n+        UNIVERSAL(TokenKind.UNIVERSAL, XDECL1 | XMODIFIER),  \/\/  __universal (Valhalla)\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.method.should.not.be.invoked.on.universal.tvars\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+primitive class Point {}\n+\n+class Test<__universal T> {\n+    void m(T t) throws Throwable {\n+        t.wait();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantInvokeWaitOnUniversal.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.universal.variable.cannot.be.assigned.null\n+\/\/ key: compiler.warn.var.might.not.have.been.initialized\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:universal\n+\n+class Box<__universal T> {\n+    T t;\n+    void m() { t = null; }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UniversalCantBeAssignedNull.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.universal.tvars\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class C<__universal T> {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UniversalTVars.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,446 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * UniversalTVarsCompilationTests\n+ *\n+ * @test\n+ * @summary Negative compilation tests, and positive compilation (smoke) tests for universal type variables\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ * @build JavacTestingAbstractProcessor\n+ * @run testng\/othervm UniversalTVarsCompilationTests\n+ *\/\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class UniversalTVarsCompilationTests extends CompilationTestCase {\n+    private static String[] PREVIEW_OPTIONS = {\n+        \"--enable-preview\",\n+        \"-source\", Integer.toString(Runtime.version().feature())\n+    };\n+\n+    private static String[] PREVIEW_OPTIONS_WITH_LINT = {\n+        \"--enable-preview\",\n+        \"-source\", Integer.toString(Runtime.version().feature()),\n+        \"-Xlint:universal\"\n+    };\n+\n+    public UniversalTVarsCompilationTests() {\n+        setDefaultFilename(\"Test.java\");\n+    }\n+\n+    public void testWarningNullAssigment() {\n+        setCompileOptions(PREVIEW_OPTIONS_WITH_LINT);\n+        assertOKWithWarning(\"compiler.warn.universal.variable.cannot.be.assigned.null\",\n+                \"\"\"\n+                class Box<__universal T> {\n+                    T t;\n+                    void m() { t = null; }\n+                }\n+                \"\"\"\n+        );\n+        assertOKWithWarning(\"compiler.warn.universal.variable.cannot.be.assigned.null\",\n+                \"\"\"\n+                class Box<__universal T> {\n+                    T m() { return null; }\n+                }\n+                \"\"\"\n+        );\n+        assertOKWithWarning(\"compiler.warn.universal.variable.cannot.be.assigned.null\",\n+                \"\"\"\n+                class C<__universal T> {\n+                    T.ref x = null;\n+                    T get() { return x; } \/\/ warning: possible null value conversion\n+                    T.ref getRef() { return x; } \/\/ OK\n+                }\n+                \"\"\"\n+        );\n+\n+        setCompileOptions(PREVIEW_OPTIONS);\n+        assertOKWithWarning(\"compiler.warn.var.might.not.have.been.initialized\",\n+                \"\"\"\n+                class Box<__universal T> {\n+                    T t;\n+                    void m() { t = null; }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                import java.io.*;\n+                class C<__universal T extends Reader> { T x = null; \/* ok *\/ }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                import java.io.*;\n+                class C<T extends Reader> { T x = null; \/* ok *\/ }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                import java.io.*;\n+                class C<__universal T extends Reader> { T.ref x = null; \/* ok *\/ }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testPosCompilations() {\n+        setCompileOptions(PREVIEW_OPTIONS);\n+        assertOK(\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class C<__universal T> {\n+                    C<Point> cp;\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                interface Shape {}\n+\n+                primitive class Point implements Shape {}\n+\n+                class Box<__universal T> {}\n+\n+                class Test {\n+                    void m(Box<Point> lp) {\n+                        \/* this invocation will provoke a subtype checking, basically a check testing if:\n+                         * `Box<Point> <: Box<? extends Shape>`, this should stress the new `isBoundedBy` relation,\n+                         * in particular it should check if `Point` is bounded by `Shape`, which is true as\n+                         * `Point.ref` isBoundedBy Shape\n+                         *\/\n+                        foo(lp);\n+                    }\n+\n+                    void foo(Box<? extends Shape> ls) {}\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                interface Shape {}\n+\n+                primitive class Point implements Shape {}\n+\n+                class Box<__universal T> {}\n+\n+                class Test {\n+                    void m(Box<Shape> lp) {\n+                        foo(lp);\n+                    }\n+\n+                    void foo(Box<? super Point> ls) {}\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                import java.io.*;\n+\n+                primitive class Point {}\n+\n+                class C<T> {\n+                    T x = null;\n+\n+                    void m() {\n+                        FileReader r = new C<FileReader>().x;\n+                        Point.ref p = new C<Point.ref>().x;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                import java.io.*;\n+\n+                primitive class Point {}\n+\n+                class C<__universal T> {\n+                    T.ref x = null;\n+\n+                    void m() {\n+                        FileReader r = new C<FileReader>().x;\n+                        Point.ref p = new C<Point.ref>().x;\n+                        Point.ref p2 = new C<Point>().x;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                class C<__universal T> {\n+                    T.ref x = null;\n+                    void set(T arg) { x = arg; \/* ok *\/ }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class MyList<__universal T> {\n+                    static <__universal E> MyList<E> of(E e1) {\n+                        return null;\n+                    }\n+                }\n+\n+                class Test {\n+                    void m() {\n+                        MyList.of(new Point());\n+                    }\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class MyCollection<__universal T> {}\n+\n+                class MyList<__universal T> extends MyCollection<T> {\n+                    static <__universal E> MyList<E> of(E e1) {\n+                        return null;\n+                    }\n+                }\n+\n+                class Test {\n+                    void m() {\n+                         MyCollection<Point.ref> mpc = MyList.of(new Point());\n+                    }\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testUniversalTVarFieldMustBeInit() {\n+        setCompileOptions(PREVIEW_OPTIONS);\n+        assertOKWithWarning(\"compiler.warn.var.might.not.have.been.initialized\",\n+                \"\"\"\n+                class Box<__universal T> {\n+                    T t;\n+                    Box() {}\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                class Box<__universal T> {\n+                    T.ref t;\n+                    Box() {}\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testForbiddenMethods() {\n+        setCompileOptions(PREVIEW_OPTIONS);\n+        assertFail(\"compiler.err.primitive.class.does.not.support\",\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class Test {\n+                    static <__universal Z> Z id(Z z) {\n+                        return z;\n+                    }\n+\n+                    static void main(String... args) throws Throwable {\n+                        Point p = new Point();\n+                        id(p).wait();\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        \/\/ this one will probably be a lint warning\n+        \/*\n+        assertOKWithWarning(\"compiler.warn.method.should.not.be.invoked.on.universal.tvars\",\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class Test<__universal T> {\n+                    void m(T t) throws Throwable {\n+                        t.wait();\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        *\/\n+    }\n+\n+    public void testPosCompilations2() {\n+        setCompileOptions(PREVIEW_OPTIONS);\n+        assertOK(\n+                \"\"\"\n+                interface MyComparable<__universal T> {\n+                    public int compareTo(T o);\n+                }\n+\n+                primitive class Int128 implements MyComparable<Int128> {\n+                    public int compareTo(Int128 i128) {\n+                        return 0;\n+                    }\n+                }\n+\n+                class Test {\n+                    <__universal Z extends MyComparable<Z>> void m(Z z) {}\n+                    void foo() {\n+                        Int128 i = new Int128();\n+                        m(i);\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                interface MyComparable<__universal T> {}\n+\n+                primitive class Int128 implements MyComparable<Int128> {\n+                    public int compareTo(Int128 i128) {\n+                        return 0;\n+                    }\n+                }\n+\n+                class Test {\n+                    <__universal Z extends MyComparable<Z>> void m(Z z) {}\n+                    void foo() {\n+                        Int128 i = new Int128();\n+                        m(i);\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                import java.util.*;\n+\n+                interface I {}\n+\n+                class Test {\n+                    <__universal T> T.ref bar() {\n+                        return null;\n+                    }\n+\n+                    void foo() {\n+                        List<? extends I> values = bar();\n+                    }\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                class Test<__universal T> {\n+                    T.ref t;\n+\n+                    void m() {\n+                        this.t = null;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                import java.util.*;\n+\n+                class Test {\n+                    Map<String, String> types = new HashMap<>();\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                class C1 {\n+                    <__universal T> void foo(T t) {}\n+                }\n+\n+                class C2 extends C1 {\n+                    <__universal T> void foo(T.ref t) { }\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                class C1 {\n+                    <__universal T> void foo(T.ref t) {}\n+                }\n+\n+                class C2 extends C1 {\n+                    <__universal T> void foo(T t) { }\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                    import java.util.function.*;\n+                    class Test<__universal T> {\n+                        T.ref field;\n+                        void foo(T t, Consumer<? super T> action) {\n+                            action.accept(field = t);\n+                        }\n+                    }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testUncheckedWarning() {\n+        \/* this one should generate unchecked warning\n+        interface MyList<__universal E> {}\n+\n+        class MyArrays {\n+            @SafeVarargs\n+            @SuppressWarnings(\"varargs\")\n+            public static <__universal T> MyList<T> asList(T... a) {\n+                return null;\n+            }\n+        }\n+\n+        class Test<__universal T> {\n+            MyList<T.ref> newList() {\n+                return MyArrays.asList(null, null);\n+            }\n+\n+            void foo() {\n+                MyList<T> list = newList(); \/\/ unchecked warning\n+            }\n+        }\n+        *\/\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":446,"deletions":0,"binary":false,"changes":446,"status":"added"}]}