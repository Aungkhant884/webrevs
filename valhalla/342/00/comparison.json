{"files":[{"patch":"@@ -991,0 +991,1 @@\n+  _scalarize_in_safepoints = false;\n@@ -1957,17 +1958,2 @@\n-  \/\/ Make inline types scalar in safepoints\n-  for (int i = _inline_type_nodes.length()-1; i >= 0; i--) {\n-    InlineTypeBaseNode* vt = _inline_type_nodes.at(i)->as_InlineTypeBase();\n-    vt->make_scalar_in_safepoints(&igvn);\n-  }\n-  if (remove) {\n-    \/\/ Remove inline type nodes\n-    while (_inline_type_nodes.length() > 0) {\n-      InlineTypeBaseNode* vt = _inline_type_nodes.pop()->as_InlineTypeBase();\n-      if (vt->outcnt() == 0) {\n-        igvn.remove_dead_node(vt);\n-      } else if (vt->is_InlineTypePtr()) {\n-        igvn.replace_node(vt, vt->get_oop());\n-      } else {\n-        igvn.replace_node(vt, igvn.C->top());\n-      }\n-    }\n+  if (_inline_type_nodes.length() == 0) {\n+    return;\n@@ -1975,2 +1961,1 @@\n-  \/\/ TODO only check once we are removing, right?\n-  \/\/ Make sure that the return value does not keep an unused allocation alive\n+  \/\/ Make sure that the return value does not keep an otherwise unused allocation alive\n@@ -1996,0 +1981,25 @@\n+  if (remove) {\n+    \/\/ Remove inline type nodes\n+    while (_inline_type_nodes.length() > 0) {\n+      InlineTypeBaseNode* vt = _inline_type_nodes.pop()->as_InlineTypeBase();\n+      if (vt->outcnt() == 0) {\n+        igvn.remove_dead_node(vt);\n+      } else if (vt->is_InlineTypePtr()) {\n+        igvn.replace_node(vt, vt->get_oop());\n+      } else {\n+#ifdef ASSERT\n+        for (DUIterator_Fast imax, i = vt->fast_outs(imax); i < imax; i++) {\n+          assert(vt->fast_out(i)->is_InlineTypeBase(), \"Unexpected inline type user\");\n+        }\n+#endif\n+        igvn.replace_node(vt, igvn.C->top());\n+      }\n+    }\n+  } else {\n+    \/\/ Give inline types a chance to be scalarized in safepoints\n+    \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info\n+    set_scalarize_in_safepoints(true);\n+    for (int i = _inline_type_nodes.length()-1; i >= 0; i--) {\n+      igvn._worklist.push(_inline_type_nodes.at(i));\n+    }\n+  }\n@@ -2630,4 +2640,2 @@\n-  if (_inline_type_nodes.length() > 0) {\n-    \/\/ Do this once all inlining is over to avoid getting inconsistent debug info\n-    process_inline_types(igvn);\n-  }\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n@@ -2740,5 +2748,2 @@\n-  if (_inline_type_nodes.length() > 0) {\n-    \/\/ Process inline type nodes again and remove them. From here\n-    \/\/ on we don't need to keep track of field values anymore.\n-    process_inline_types(igvn, \/* remove= *\/ true);\n-  }\n+  \/\/ Process inline type nodes again after loop opts\n+  process_inline_types(igvn);\n@@ -2756,0 +2761,4 @@\n+  \/\/ Process inline type nodes again and remove them. From here\n+  \/\/ on we don't need to keep track of field values anymore.\n+  process_inline_types(igvn, \/* remove= *\/ true);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  bool                  _scalarize_in_safepoints; \/\/ Scalarize inline types in safepoint debug info\n@@ -605,0 +606,2 @@\n+  bool          scalarize_in_safepoints() const { return _scalarize_in_safepoints; }\n+  void          set_scalarize_in_safepoints(bool z) { _scalarize_in_safepoints = z; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    if (value->is_InlineType()) {\n+    if (value->is_InlineTypeBase()) {\n@@ -244,2 +244,5 @@\n-    Node* vt = worklist.at(i);\n-    vt->as_InlineType()->make_scalar_in_safepoints(igvn);\n+    InlineTypeBaseNode* vt = worklist.at(i)->isa_InlineTypeBase();\n+    vt->make_scalar_in_safepoints(igvn);\n+  }\n+  if (outcnt() == 0) {\n+    igvn->remove_dead_node(this);\n@@ -247,1 +250,0 @@\n-  igvn->record_for_igvn(this);\n@@ -499,0 +501,8 @@\n+Node* InlineTypeBaseNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (phase->C->scalarize_in_safepoints() && can_reshape) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    make_scalar_in_safepoints(igvn);\n+  }\n+  return NULL;\n+}\n+\n@@ -864,1 +874,1 @@\n-  return NULL;\n+  return InlineTypeBaseNode::Ideal(phase, can_reshape);\n@@ -896,1 +906,1 @@\n-        igvn->record_for_igvn(alloc);\n+        igvn->_worklist.push(alloc);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -97,0 +97,2 @@\n+\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -638,1 +638,5 @@\n-        value = transform_later(new DecodeNNode(value, value->get_ptr_type()));\n+        if (value->is_EncodeP()) {\n+          value = value->in(1);\n+        } else {\n+          value = transform_later(new DecodeNNode(value, value->get_ptr_type()));\n+        }\n@@ -659,0 +663,1 @@\n+  Unique_Node_List worklist;\n@@ -667,0 +672,1 @@\n+    worklist.push(res);\n@@ -680,3 +686,3 @@\n-  if (can_eliminate && res != NULL) {\n-    for (DUIterator_Fast jmax, j = res->fast_outs(jmax);\n-                               j < jmax && can_eliminate; j++) {\n+  while (can_eliminate && worklist.size() > 0) {\n+    res = worklist.pop();\n+    for (DUIterator_Fast jmax, j = res->fast_outs(jmax); j < jmax && can_eliminate; j++) {\n@@ -733,0 +739,3 @@\n+      } else if (use->is_InlineTypePtr() && use->isa_InlineTypePtr()->get_oop() == res) {\n+        \/\/ Process users\n+        worklist.push(use);\n@@ -768,1 +777,1 @@\n-    } else if (alloc->_is_scalar_replaceable) {\n+    } else {\n@@ -954,4 +963,1 @@\n-      if (field_val->is_InlineType()) {\n-        \/\/ Keep track of inline types to scalarize them later\n-        value_worklist.push(field_val);\n-      } else if (UseCompressedOops && field_type->isa_narrowoop()) {\n+      if (UseCompressedOops && field_type->isa_narrowoop()) {\n@@ -962,1 +968,1 @@\n-        } else {\n+        } else if (!field_val->is_InlineTypeBase()) {\n@@ -966,0 +972,4 @@\n+      if (field_val->is_InlineTypeBase()) {\n+        \/\/ Keep track of inline types to scalarize them later\n+        value_worklist.push(field_val);\n+      }\n@@ -983,2 +993,2 @@\n-    Node* vt = value_worklist.at(i);\n-    vt->as_InlineType()->make_scalar_in_safepoints(&_igvn, allow_oop);\n+    InlineTypeBaseNode* vt = value_worklist.at(i)->as_InlineTypeBase();\n+    vt->make_scalar_in_safepoints(&_igvn, allow_oop);\n@@ -2260,1 +2270,2 @@\n-         (unc->peek_monitor_obj() == lock->obj_node()), \"wrong monitor\");\n+         (obj->is_InlineTypePtr() && obj->in(1) == unc->peek_monitor_obj()) ||\n+         (obj == unc->peek_monitor_obj()), \"wrong monitor\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3368,0 +3368,52 @@\n+\n+    \/\/ Test that non-flattened array does not block inline type scalarization\n+    @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE)\n+    @Warmup(50000)\n+    public void test146(boolean b) {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2[] array = { vt };\n+        if (b) {\n+            for (int i = 0; i < 10; ++i) {\n+                if (array != array) {\n+                    array = null;\n+                }\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test146_verifier(boolean warmup) {\n+        test146(true);\n+    }\n+\n+    \/\/ Test that non-flattened array does not block inline type scalarization\n+    @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE)\n+    @Warmup(50000)\n+    public int test147(boolean deopt) {\n+        \/\/ Both vt and array should be scalarized\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2[] array = new MyValue2[1];\n+\n+        \/\/ Delay scalarization to after loop opts\n+        boolean store = false;\n+        for (int i = 0; i < 5; ++i) {\n+            if (i == 1) {\n+                store = true;\n+            }\n+        }\n+        if (store) {\n+            array[0] = vt;\n+        }\n+\n+        if (deopt) {\n+            \/\/ Uncommon trap referencing array\n+            return array[0].x + 42;\n+        }\n+        return array[0].x;\n+    }\n+\n+    @DontCompile\n+    public void test147_verifier(boolean warmup) {\n+        int res = test147(!warmup);\n+        Asserts.assertEquals(res, MyValue2.createWithFieldsInline(rI, rD).x + (warmup ? 0 : 42));\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8260034 8260225 8260283 8261037\n+ * @bug 8260034 8260225 8260283 8261037 8261874\n@@ -28,1 +28,4 @@\n- * @run main\/othervm -Xbatch compiler.valhalla.inlinetypes.TestGenerated\n+ * @run main\/othervm -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestGenerated\n+ * @run main\/othervm -Xbatch -XX:FlatArrayElementMaxSize=0\n+ *                   compiler.valhalla.inlinetypes.TestGenerated\n@@ -125,0 +128,11 @@\n+    void test9(boolean b) {\n+        MyValue1[] array = { new MyValue1() };\n+        if (b) {\n+            for (int i = 0; i < 10; ++i) {\n+                if (array != array) {\n+                    array = null;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -140,0 +154,1 @@\n+            t.test9(true);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}