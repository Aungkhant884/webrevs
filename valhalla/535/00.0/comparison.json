{"files":[{"patch":"@@ -2150,1 +2150,1 @@\n-          if (cbuf) {\n+        if (is64) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"compiler\/compileTask.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1739,0 +1739,3 @@\n+  if (FLAG_IS_DEFAULT(UseCopySignIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseCopySignIntrinsic, true);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1563,0 +1563,9 @@\n+    case Op_CopySignD:\n+    case Op_CopySignF:\n+      if (UseAVX < 3 || !is_LP64)  {\n+        return false;\n+      }\n+      if (!VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1641,0 +1650,3 @@\n+      if (bt != T_INT && bt != T_LONG) {\n+        return false;\n+      } \/\/ fallthrough\n@@ -5788,1 +5800,1 @@\n-\/\/ --------------------------------- Signum ---------------------------\n+\/\/ --------------------------------- Signum\/CopySign ---------------------------\n@@ -5812,0 +5824,47 @@\n+\/\/ ---------------------------------------\n+\/\/ For copySign use 0xE4 as writemask for vpternlog\n+\/\/ Desired Truth Table: A -> xmm0 bit, B -> xmm1 bit, C -> xmm2 bit\n+\/\/ C (xmm2) is set to 0x7FFFFFFF\n+\/\/ Wherever xmm2 is 0, we want to pick from B (sign)\n+\/\/ Wherever xmm2 is 1, we want to pick from A (src)\n+\/\/\n+\/\/ A B C Result\n+\/\/ 0 0 0 0\n+\/\/ 0 0 1 0\n+\/\/ 0 1 0 1\n+\/\/ 0 1 1 0\n+\/\/ 1 0 0 0\n+\/\/ 1 0 1 1\n+\/\/ 1 1 0 1\n+\/\/ 1 1 1 1\n+\/\/\n+\/\/ Result going from high bit to low bit is 0x11100100 = 0xe4\n+\/\/ ---------------------------------------\n+\n+#ifdef _LP64\n+instruct copySignF_reg(regF dst, regF src, regF tmp1, rRegI tmp2) %{\n+  match(Set dst (CopySignF dst src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignF $dst, $src\\t! using $tmp1 and $tmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ movl($tmp2$$Register, 0x7FFFFFFF);\n+    __ movdl($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogd($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct copySignD_imm(regD dst, regD src, regD tmp1, rRegL tmp2, immD zero) %{\n+  match(Set dst (CopySignD dst (Binary src zero)));\n+  ins_cost(100);\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignD  $dst, $src\\t! using $tmp1 and $tmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ mov64($tmp2$$Register, 0x7FFFFFFFFFFFFFFF);\n+    __ movq($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogq($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2512,2 +2512,2 @@\n-    if (type == T_LONG || type == T_DOUBLE) {\n-      __ move(addr, result);\n+    if (is_reference_type(type)) {\n+      __ move_wide(addr, result);\n@@ -2515,1 +2515,1 @@\n-      access_load(IN_NATIVE, type, LIR_OprFact::address(addr), result);\n+      __ move(addr, result);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,3 +164,0 @@\n-  _num_instance_klasses(0),\n-  _num_obj_array_klasses(0),\n-  _num_type_array_klasses(0),\n@@ -225,8 +222,0 @@\n-      if (klass->is_instance_klass()) {\n-        _num_instance_klasses ++;\n-      } else if (klass->is_objArray_klass()) {\n-        _num_obj_array_klasses ++;\n-      } else {\n-        assert(klass->is_typeArray_klass(), \"sanity\");\n-        _num_type_array_klasses ++;\n-      }\n@@ -261,6 +250,0 @@\n-  log_info(cds)(\"Number of classes %d\", _num_instance_klasses + _num_obj_array_klasses + _num_type_array_klasses);\n-  log_info(cds)(\"    instance classes   = %5d\", _num_instance_klasses);\n-  log_info(cds)(\"    obj array classes  = %5d\", _num_obj_array_klasses);\n-  log_info(cds)(\"    type array classes = %5d\", _num_type_array_klasses);\n-  log_info(cds)(\"               symbols = %5d\", _symbols->length());\n-\n@@ -745,0 +728,10 @@\n+  int num_instance_klasses = 0;\n+  int num_boot_klasses = 0;\n+  int num_platform_klasses = 0;\n+  int num_app_klasses = 0;\n+  int num_hidden_klasses = 0;\n+  int num_unlinked_klasses = 0;\n+  int num_unregistered_klasses = 0;\n+  int num_obj_array_klasses = 0;\n+  int num_type_array_klasses = 0;\n+\n@@ -746,0 +739,3 @@\n+    const char* type;\n+    const char* unlinked = \"\";\n+    const char* hidden = \"\";\n@@ -751,0 +747,2 @@\n+      num_obj_array_klasses ++;\n+      type = \"array\";\n@@ -752,0 +750,2 @@\n+      num_type_array_klasses ++;\n+      type = \"array\";\n@@ -755,0 +755,1 @@\n+      num_instance_klasses ++;\n@@ -760,0 +761,24 @@\n+      if (ik->is_shared_boot_class()) {\n+        type = \"boot\";\n+        num_boot_klasses ++;\n+      } else if (ik->is_shared_platform_class()) {\n+        type = \"plat\";\n+        num_platform_klasses ++;\n+      } else if (ik->is_shared_app_class()) {\n+        type = \"app\";\n+        num_app_klasses ++;\n+      } else {\n+        assert(ik->is_shared_unregistered_class(), \"must be\");\n+        type = \"unreg\";\n+        num_unregistered_klasses ++;\n+      }\n+\n+      if (!ik->is_linked()) {\n+        num_unlinked_klasses ++;\n+        unlinked = \" ** unlinked\";\n+      }\n+\n+      if (ik->is_hidden()) {\n+        num_hidden_klasses ++;\n+        hidden = \" ** hidden\";\n+      }\n@@ -763,0 +788,1 @@\n+    }\n@@ -764,4 +790,3 @@\n-      if (log_is_enabled(Debug, cds, class)) {\n-        ResourceMark rm;\n-        log_debug(cds, class)(\"klasses[%4d] = \" PTR_FORMAT \" %s\", i, p2i(to_requested(ik)), ik->external_name());\n-      }\n+    if (log_is_enabled(Debug, cds, class)) {\n+      ResourceMark rm;\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s\", i, p2i(to_requested(k)), type, k->external_name(), hidden, unlinked);\n@@ -770,0 +795,12 @@\n+\n+  log_info(cds)(\"Number of classes %d\", num_instance_klasses + num_obj_array_klasses + num_type_array_klasses);\n+  log_info(cds)(\"    instance classes   = %5d\", num_instance_klasses);\n+  log_info(cds)(\"      boot             = %5d\", num_boot_klasses);\n+  log_info(cds)(\"      app              = %5d\", num_app_klasses);\n+  log_info(cds)(\"      platform         = %5d\", num_platform_klasses);\n+  log_info(cds)(\"      unregistered     = %5d\", num_unregistered_klasses);\n+  log_info(cds)(\"      (hidden)         = %5d\", num_hidden_klasses);\n+  log_info(cds)(\"      (unlinked)       = %5d\", num_unlinked_klasses);\n+  log_info(cds)(\"    obj array classes  = %5d\", num_obj_array_klasses);\n+  log_info(cds)(\"    type array classes = %5d\", num_type_array_klasses);\n+  log_info(cds)(\"               symbols = %5d\", _symbols->length());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":58,"deletions":21,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -213,3 +213,0 @@\n-  int _num_instance_klasses;\n-  int _num_obj_array_klasses;\n-  int _num_type_array_klasses;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1030,1 +1030,1 @@\n-                java_lang_ClassLoader::loader_data_raw(orig_obj) == NULL, \"must be\");\n+                java_lang_ClassLoader::loader_data(orig_obj) == NULL, \"must be\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/classListWriter.hpp\"\n@@ -80,0 +81,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -153,0 +155,3 @@\n+  static const int INITIAL_TABLE_SIZE = 1987;\n+  static const int MAX_TABLE_SIZE = 61333;\n+\n@@ -154,0 +159,23 @@\n+  ResizeableResourceHashtable<InstanceKlass*, bool,\n+                              ResourceObj::C_HEAP, mtClassShared> _dumped_classes;\n+\n+  void dump(InstanceKlass* ik) {\n+    bool created;\n+    _dumped_classes.put_if_absent(ik, &created);\n+    if (!created) {\n+      return;\n+    }\n+    if (_dumped_classes.maybe_grow(MAX_TABLE_SIZE)) {\n+      log_info(cds, hashtables)(\"Expanded _dumped_classes table to %d\", _dumped_classes.table_size());\n+    }\n+    if (ik->java_super()) {\n+      dump(ik->java_super());\n+    }\n+    Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+    int len = interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      dump(interfaces->at(i));\n+    }\n+    ClassListWriter::write_to_stream(ik, _stream);\n+  }\n+\n@@ -155,1 +183,5 @@\n-  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n+  DumpClassListCLDClosure(fileStream* f)\n+  : CLDClosure(), _dumped_classes(INITIAL_TABLE_SIZE) {\n+    _stream = f;\n+  }\n+\n@@ -159,4 +191,1 @@\n-        InstanceKlass* ik = InstanceKlass::cast(klass);\n-        if (ik->is_shareable()) {\n-          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n-        }\n+        dump(InstanceKlass::cast(klass));\n@@ -172,0 +201,1 @@\n+    MutexLocker lock2(ClassListFile_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -917,1 +917,1 @@\n-    int counter_life;\n+    int counter_life = method_data()->invocation_count();\n@@ -919,7 +919,4 @@\n-    \/\/ In tiered the MDO's life is measured directly, so just use the snapshotted counters\n-    counter_life = MAX2(method_data()->invocation_count(), method_data()->backedge_count());\n-\n-    \/\/ counter_life due to backedge_counter could be > method_life\n-    if (counter_life > method_life)\n-      counter_life = method_life;\n-    if (0 < counter_life && counter_life <= method_life) {\n+    if (method_life < counter_life) { \/\/ may happen because of the snapshot timing\n+      method_life = counter_life;\n+    }\n+    if (counter_life > 0) {\n@@ -928,0 +925,2 @@\n+    } else {\n+      count = 1;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1431,8 +1431,0 @@\n-int  java_lang_Class::oop_size(oop java_class) {\n-  assert(_oop_size_offset != 0, \"must be set\");\n-  int size = java_class->int_field(_oop_size_offset);\n-  assert(size > 0, \"Oop size must be greater than zero, not %d\", size);\n-  return size;\n-}\n-\n-\n@@ -1450,5 +1442,0 @@\n-int  java_lang_Class::static_oop_field_count_raw(oop java_class) {\n-  assert(_static_oop_field_count_offset != 0, \"must be set\");\n-  return java_class->int_field_raw(_static_oop_field_count_offset);\n-}\n-\n@@ -1581,10 +1568,0 @@\n-\n-Klass* java_lang_Class::as_Klass_raw(oop java_class) {\n-  \/\/%note memory_2\n-  assert(java_lang_Class::is_instance(java_class), \"must be a Class object\");\n-  Klass* k = ((Klass*)java_class->metadata_field_raw(_klass_offset));\n-  assert(k == NULL || k->is_klass(), \"type check\");\n-  return k;\n-}\n-\n-\n@@ -2749,0 +2726,45 @@\n+Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n+  \/\/ Call to JVM to fill in the stack trace and clear declaringClassObject to\n+  \/\/ not keep classes alive in the stack trace.\n+  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+  assert(throwable.not_null(), \"shouldn't be\");\n+\n+  JavaValue result(T_ARRAY);\n+  JavaCalls::call_virtual(&result, throwable,\n+                          vmClasses::Throwable_klass(),\n+                          vmSymbols::getStackTrace_name(),\n+                          vmSymbols::getStackTrace_signature(),\n+                          CHECK_NH);\n+  Handle stack_trace(THREAD, result.get_oop());\n+  assert(stack_trace->is_objArray(), \"Should be an array\");\n+\n+  \/\/ Throw ExceptionInInitializerError as the cause with this exception in\n+  \/\/ the message and stack trace.\n+\n+  \/\/ Now create the message with the original exception and thread name.\n+  Symbol* message = java_lang_Throwable::detail_message(throwable());\n+  ResourceMark rm(THREAD);\n+  stringStream st;\n+  st.print(\"Exception %s%s \", throwable()->klass()->name()->as_klass_external_name(),\n+             message == nullptr ? \"\" : \":\");\n+  if (message == NULL) {\n+    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n+  } else {\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+  }\n+\n+  Symbol* exception_name = vmSymbols::java_lang_ExceptionInInitializerError();\n+  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n+\n+  \/\/ If new_exception returns a different exception while creating the exception, return null.\n+  if (h_cause->klass()->name() != exception_name) {\n+    log_info(class, init)(\"Exception thrown while saving initialization exception %s\",\n+                          h_cause->klass()->external_name());\n+    return Handle();\n+  }\n+  java_lang_Throwable::set_stacktrace(h_cause(), stack_trace());\n+  \/\/ Clear backtrace because the stacktrace should be used instead.\n+  set_backtrace(h_cause(), NULL);\n+  return h_cause;\n+}\n+\n@@ -4345,1 +4367,1 @@\n-ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {\n+ClassLoaderData* java_lang_ClassLoader::loader_data(oop loader) {\n@@ -4348,1 +4370,1 @@\n-  return RawAccess<>::load_at(loader, _loader_data_offset);\n+  return HeapAccess<>::load_at(loader, _loader_data_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":47,"deletions":25,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -332,1 +332,0 @@\n-  static Klass* as_Klass_raw(oop java_class);\n@@ -384,1 +383,0 @@\n-  static int oop_size_raw(oop java_class);\n@@ -387,1 +385,0 @@\n-  static int static_oop_field_count_raw(oop java_class);\n@@ -582,0 +579,4 @@\n+\n+  \/\/ For recreating class initialization error exceptions.\n+  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n+\n@@ -1370,1 +1371,1 @@\n-  static ClassLoaderData* loader_data_raw(oop loader);\n+  static ClassLoaderData* loader_data(oop loader);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-inline int java_lang_Class::oop_size_raw(oop java_class) {\n+inline int java_lang_Class::oop_size(oop java_class) {\n@@ -284,1 +284,1 @@\n-  int size = java_class->int_field_raw(_oop_size_offset);\n+  int size = java_class->int_field(_oop_size_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1709,0 +1709,2 @@\n+\n+    InstanceKlass::clean_initialization_error_table();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -375,0 +375,1 @@\n+  template(getStackTrace_name,                        \"getStackTrace\")                            \\\n@@ -604,1 +605,3 @@\n-  template(reflect_method_signature,                  \"Ljava\/lang\/reflect\/Method;\")                                                    \\\n+  template(reflect_method_signature,                  \"Ljava\/lang\/reflect\/Method;\")                               \\\n+  template(getStackTrace_signature,                    \"()[Ljava\/lang\/StackTraceElement;\")                        \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,5 +97,0 @@\n-  \/\/ The dest for Young is used when the objects are aged enough to\n-  \/\/ need to be moved to the next space.\n-  _dest[G1HeapRegionAttr::Young] = G1HeapRegionAttr::Old;\n-  _dest[G1HeapRegionAttr::Old]   = G1HeapRegionAttr::Old;\n-\n@@ -359,0 +354,2 @@\n+  assert(region_attr.is_young() || region_attr.is_old(), \"must be either Young or Old\");\n+\n@@ -366,1 +363,2 @@\n-  return dest(region_attr);\n+  \/\/ young-to-old (promotion) or old-to-old; destination is old in both cases.\n+  return G1HeapRegionAttr::Old;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,4 +62,0 @@\n-  marking_stack()->initialize();\n-  _objarray_stack.initialize();\n-  _region_stack.initialize();\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-  claimed_stack_depth()->initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+  const TypeAryPtr* ary_ptr = src->get_ptr_type()->isa_aryptr();\n@@ -272,11 +273,5 @@\n-  if (ac->is_clone_array()) {\n-    const TypeAryPtr* ary_ptr = src->get_ptr_type()->isa_aryptr();\n-    BasicType bt;\n-    if (ary_ptr == NULL) {\n-      \/\/ ary_ptr can be null iff we are running with StressReflectiveCode\n-      \/\/ This code will be unreachable\n-      assert(StressReflectiveCode, \"Guard against surprises\");\n-      bt = T_LONG;\n-    } else if (ary_ptr->is_flat()) {\n-      \/\/ Clone flat inline type array\n-      bt = T_LONG;\n+  if (ac->is_clone_array() && ary_ptr != NULL) {\n+    BasicType bt = ary_ptr->elem()->array_element_basic_type();\n+    if (is_reference_type(bt) && (!ary_ptr->is_flat())) {\n+      \/\/ Clone object array\n+      bt = T_OBJECT;\n@@ -284,8 +279,2 @@\n-      bt = ary_ptr->elem()->array_element_basic_type();\n-      if (is_reference_type(bt)) {\n-        \/\/ Clone object array\n-        bt = T_OBJECT;\n-      } else {\n-        \/\/ Clone primitive array\n-        bt = T_LONG;\n-      }\n+      \/\/ Clone primitive array\n+      bt = T_LONG;\n@@ -339,1 +328,0 @@\n-  assert(ac->is_clone_inst(), \"Sanity check\");\n@@ -344,1 +332,1 @@\n-  Node* const base_offset = phase->longcon(arraycopy_payload_base_offset(false) >> LogBytesPerLong);\n+  Node* const base_offset = phase->longcon(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,11 +351,0 @@\n-\n-  \/\/ Clear LSB in symbol address; it can be set by CPSlot.\n-  static Symbol* load_symbol(Symbol** p) {\n-    return (Symbol*)(intptr_t(*p) & ~1);\n-  }\n-\n-  \/\/ Store symbol, adjusting new pointer if the original pointer was adjusted\n-  \/\/ (symbol references in constant pool slots have their LSB set to 1).\n-  static void store_symbol(Symbol** p, Symbol* sym) {\n-    *p = (Symbol*)(intptr_t(sym) | (intptr_t(*p) & 1));\n-  }\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -135,2 +135,2 @@\n-      \/\/ In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest\n-      \/\/ 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.\n+      \/\/ In some rare cases we store some flags in the lowest 2 bits of a\n+      \/\/ MetaspaceObj pointer. Unmask these when manipulating the pointer.\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2448,2 +2448,2 @@\n-      CPSlot entry = slot_at(i);\n-      guarantee(entry.get_symbol()->refcount() != 0, \"should have nonzero reference count\");\n+      Symbol* entry = symbol_at(i);\n+      guarantee(entry->refcount() != 0, \"should have nonzero reference count\");\n@@ -2451,2 +2451,2 @@\n-      CPSlot entry = slot_at(i);\n-      guarantee(entry.get_symbol()->refcount() != 0, \"should have nonzero reference count\");\n+      Symbol* entry = unresolved_string_at(i);\n+      guarantee(entry->refcount() != 0, \"should have nonzero reference count\");\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,16 +52,0 @@\n-class CPSlot {\n- friend class ConstantPool;\n-  intptr_t _ptr;\n-  enum TagBits  {_pseudo_bit = 1};\n- public:\n-\n-  CPSlot(intptr_t ptr): _ptr(ptr) {}\n-  CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}\n-\n-  intptr_t value()   { return _ptr; }\n-\n-  Symbol* get_symbol() {\n-    return (Symbol*)(_ptr & ~_pseudo_bit);\n-  }\n-};\n-\n@@ -155,7 +139,0 @@\n-  CPSlot slot_at(int which) const;\n-\n-  void slot_at_put(int which, CPSlot s) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    assert(s.value() != 0, \"Caught something\");\n-    *(intptr_t*)&base()[which] = s.value();\n-  }\n@@ -355,2 +332,6 @@\n-    release_tag_at_put(which, JVM_CONSTANT_String);\n-    slot_at_put(which, CPSlot(s));\n+    assert(s->refcount() != 0, \"should have nonzero refcount\");\n+    \/\/ Note that release_tag_at_put is not needed here because this is called only\n+    \/\/ when constructing a ConstantPool in a single thread, with no possibility\n+    \/\/ of concurrent access.\n+    tag_at_put(which, JVM_CONSTANT_String);\n+    *symbol_at_addr(which) = s;\n@@ -509,2 +490,1 @@\n-    Symbol* sym = slot_at(which).get_symbol();\n-    return sym;\n+    return *symbol_at_addr(which);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":7,"deletions":27,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -730,3 +730,1 @@\n-  if (Arguments::is_dumping_archive()) {\n-    SystemDictionaryShared::handle_class_unloading(this);\n-  }\n+  SystemDictionaryShared::handle_class_unloading(this);\n@@ -1127,0 +1125,48 @@\n+ResourceHashtable<const InstanceKlass*, OopHandle, 107, ResourceObj::C_HEAP, mtClass>\n+      _initialization_error_table;\n+\n+void InstanceKlass::add_initialization_error(JavaThread* current, Handle exception) {\n+  \/\/ Create the same exception with a message indicating the thread name,\n+  \/\/ and the StackTraceElements.\n+  \/\/ If the initialization error is OOM, this might not work, but if GC kicks in\n+  \/\/ this would be still be helpful.\n+  JavaThread* THREAD = current;\n+  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n+  if (HAS_PENDING_EXCEPTION || cause.is_null()) {\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  MutexLocker ml(THREAD, ClassInitError_lock);\n+  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n+  bool created = false;\n+  _initialization_error_table.put_if_absent(this, elem, &created);\n+  assert(created, \"Initialization is single threaded\");\n+  ResourceMark rm(THREAD);\n+  log_trace(class, init)(\"Initialization error added for class %s\", external_name());\n+}\n+\n+oop InstanceKlass::get_initialization_error(JavaThread* current) {\n+  MutexLocker ml(current, ClassInitError_lock);\n+  OopHandle* h = _initialization_error_table.get(this);\n+  return (h != nullptr) ? h->resolve() : nullptr;\n+}\n+\n+\/\/ Need to remove entries for unloaded classes.\n+void InstanceKlass::clean_initialization_error_table() {\n+  struct InitErrorTableCleaner {\n+    bool do_entry(const InstanceKlass* ik, OopHandle h) {\n+      if (!ik->is_loader_alive()) {\n+        h.release(Universe::vm_global());\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    }\n+  };\n+\n+  MutexLocker ml(ClassInitError_lock);\n+  InitErrorTableCleaner cleaner;\n+  _initialization_error_table.unlink(&cleaner);\n+}\n+\n@@ -1173,7 +1219,6 @@\n-      const char* desc = \"Could not initialize class \";\n-      const char* className = external_name();\n-      size_t msglen = strlen(desc) + strlen(className) + 1;\n-      char* message = NEW_RESOURCE_ARRAY(char, msglen);\n-      if (NULL == message) {\n-        \/\/ Out of memory: can't create detailed error message\n-          THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n@@ -1181,2 +1226,2 @@\n-        jio_snprintf(message, msglen, \"%s%s\", desc, className);\n-          THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n@@ -1213,0 +1258,1 @@\n+        add_initialization_error(THREAD, e);\n@@ -1277,3 +1323,1 @@\n-    {\n-      debug_only(vtable().verify(tty, true);)\n-    }\n+    debug_only(vtable().verify(tty, true);)\n@@ -1290,0 +1334,1 @@\n+      add_initialization_error(THREAD, e);\n@@ -2785,3 +2830,1 @@\n-  if (Arguments::is_dumping_archive()) {\n-    SystemDictionaryShared::handle_class_unloading(ik);\n-  }\n+  SystemDictionaryShared::handle_class_unloading(ik);\n@@ -3784,1 +3827,3 @@\n-  log_to_classlist();\n+  if (ClassListWriter::is_enabled()) {\n+    ClassListWriter::write(this, cfs);\n+  }\n@@ -4325,39 +4370,0 @@\n-bool InstanceKlass::is_shareable() const {\n-#if INCLUDE_CDS\n-  ClassLoaderData* loader_data = class_loader_data();\n-  if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n-    return false;\n-  }\n-\n-  if (is_hidden()) {\n-    return false;\n-  }\n-\n-  if (module()->is_patched()) {\n-    return false;\n-  }\n-\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n-void InstanceKlass::log_to_classlist() const {\n-#if INCLUDE_CDS\n-  ResourceMark rm;\n-  if (ClassListWriter::is_enabled()) {\n-    if (!ClassLoader::has_jrt_entry()) {\n-       warning(\"DumpLoadedClassList and CDS are not supported in exploded build\");\n-       DumpLoadedClassList = NULL;\n-       return;\n-    }\n-    if (is_shareable()) {\n-      ClassListWriter w;\n-      w.stream()->print_cr(\"%s\", name()->as_C_string());\n-      w.stream()->flush();\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":64,"deletions":58,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1336,0 +1336,1 @@\n+  static void clean_initialization_error_table();\n@@ -1347,0 +1348,3 @@\n+  void add_initialization_error(JavaThread* current, Handle exception);\n+  oop get_initialization_error(JavaThread* current);\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,1 +191,0 @@\n-Metadata* oopDesc::metadata_field_raw(int offset) const               { return RawAccess<>::load_at(as_oop(), offset); }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-  Metadata* metadata_field_raw(int offset) const;\n@@ -183,1 +182,0 @@\n-  jint int_field_raw(int offset) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-inline jint oopDesc::int_field_raw(int offset) const                { return RawAccess<>::load_at(as_oop(), offset);   }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-\/\/ to a field of a persistent variable (e.g., the _name filed in\n-\/\/ fieldDescriptor or _ptr in a CPSlot) is reference counted.\n+\/\/ to a field of a persistent variable (e.g., the _name field in\n+\/\/ fieldDescriptor or symbol in a constant pool) is reference counted.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -806,7 +806,0 @@\n-    \/\/ Virtual call involves a receiver null check which can be made implicit.\n-    if (is_virtual_late_inline()) {\n-      GraphKit kit(jvms);\n-      kit.null_check_receiver();\n-      jvms = kit.transfer_exceptions_into_jvms();\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -372,0 +372,1 @@\n+  bool arch_supports_vector_rotate(int opc, int num_elem, BasicType elem_bt, bool has_scalar_args = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -243,2 +243,7 @@\n-  assert( iff->is_If(), \"\" );\n-  assert(iff->Opcode() == Op_If || iff->Opcode() == Op_CountedLoopEnd || iff->Opcode() == Op_RangeCheck, \"Check this code when new subtype is added\");\n+  assert(iff->is_If(), \"must be\");\n+  assert(iff->Opcode() == Op_If ||\n+         iff->Opcode() == Op_CountedLoopEnd ||\n+         iff->Opcode() == Op_LongCountedLoopEnd ||\n+         iff->Opcode() == Op_RangeCheck,\n+        \"Check this code when new subtype is added\");\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -915,1 +915,3 @@\n-  _igvn.replace_node(_callprojs->fallthrough_ioproj, *io);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_ioproj, *io);\n+  }\n@@ -1188,2 +1190,8 @@\n-  *io = _callprojs->fallthrough_ioproj->clone();\n-  transform_later(*io);\n+  \/\/ When src is negative and arraycopy is before an infinite loop,_callprojs.fallthrough_ioproj\n+  \/\/ could be NULL. Skip clone and update NULL fallthrough_ioproj.\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    *io = _callprojs->fallthrough_ioproj->clone();\n+    transform_later(*io);\n+  } else {\n+    *io = NULL;\n+  }\n@@ -1504,1 +1512,3 @@\n-    _igvn.replace_node(_callprojs->fallthrough_ioproj, io);\n+    if (_callprojs->fallthrough_ioproj != NULL) {\n+      _igvn.replace_node(_callprojs->fallthrough_ioproj, io);\n+    }\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1001,1 +1001,1 @@\n-  CgroupInfo cg_infos[4];\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n@@ -2029,0 +2029,8 @@\n+WB_ENTRY(jboolean, WB_IsSharedInternedString(JNIEnv* env, jobject wb, jobject str))\n+  ResourceMark rm(THREAD);\n+  oop str_oop = JNIHandles::resolve(str);\n+  int length;\n+  jchar* chars = java_lang_String::as_unicode_string(str_oop, length, CHECK_(false));\n+  return StringTable::lookup_shared(chars, length) == str_oop;\n+WB_END\n+\n@@ -2033,2 +2041,2 @@\n-WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))\n-  return !HeapShared::closed_regions_mapped();\n+WB_ENTRY(jboolean, WB_AreSharedStringsMapped(JNIEnv* env))\n+  return HeapShared::closed_regions_mapped();\n@@ -2724,0 +2732,1 @@\n+  {CC\"isSharedInternedString\", CC\"(Ljava\/lang\/String;)Z\", (void*)&WB_IsSharedInternedString },\n@@ -2725,1 +2734,1 @@\n-  {CC\"areSharedStringsIgnored\",           CC\"()Z\",    (void*)&WB_AreSharedStringsIgnored },\n+  {CC\"areSharedStringsMapped\",            CC\"()Z\",    (void*)&WB_AreSharedStringsMapped },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-void chunkpool_init();\n@@ -107,1 +106,0 @@\n-  chunkpool_init();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -858,1 +858,1 @@\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {\n+  for (JavaThread* tp : ThreadsListHandle()) {\n@@ -919,1 +919,1 @@\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {\n+    for (JavaThread* tp : ThreadsListHandle()) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1308,1 +1308,1 @@\n-  Symbol* sym = load_symbol(p);\n+  Symbol* sym = *p;\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    boolean refersToImpl(T obj) {\n+        return refersTo0(obj);\n+    }\n+\n@@ -76,1 +80,1 @@\n-    native final boolean refersTo0(Object o);\n+    private native boolean refersTo0(Object o);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-        return refersTo0(obj);\n+        return refersToImpl(obj);\n@@ -370,0 +370,3 @@\n+     * This method exists only to avoid making refersTo0() virtual. Making\n+     * refersTo0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n@@ -371,0 +374,4 @@\n+    boolean refersToImpl(T obj) {\n+        return refersTo0(obj);\n+    }\n+\n@@ -372,1 +379,1 @@\n-    native boolean refersTo0(Object o);\n+    private native boolean refersTo0(Object o);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-     * Visits an AnnotatedTypeTree node.\n+     * Visits an {@code AnnotatedTypeTree} node.\n@@ -71,1 +71,1 @@\n-     * Visits an AnnotatedTree node.\n+     * Visits an {@code AnnotatedTree} node.\n@@ -79,1 +79,1 @@\n-     * Visits a MethodInvocationTree node.\n+     * Visits a {@code MethodInvocationTree} node.\n@@ -87,1 +87,1 @@\n-     * Visits an AssertTree node.\n+     * Visits an {@code AssertTree} node.\n@@ -95,1 +95,1 @@\n-     * Visits an AssignmentTree node.\n+     * Visits an {@code AssignmentTree} node.\n@@ -103,1 +103,1 @@\n-     * Visits a CompoundAssignmentTree node.\n+     * Visits a {@code CompoundAssignmentTree} node.\n@@ -111,1 +111,1 @@\n-     * Visits a BinaryTree node.\n+     * Visits a {@code BinaryTree} node.\n@@ -119,1 +119,1 @@\n-     * Visits a BlockTree node.\n+     * Visits a {@code BlockTree} node.\n@@ -127,1 +127,1 @@\n-     * Visits a BreakTree node.\n+     * Visits a {@code BreakTree} node.\n@@ -135,1 +135,1 @@\n-     * Visits a CaseTree node.\n+     * Visits a {@code CaseTree} node.\n@@ -143,1 +143,1 @@\n-     * Visits a CatchTree node.\n+     * Visits a {@code CatchTree} node.\n@@ -151,1 +151,1 @@\n-     * Visits a ClassTree node.\n+     * Visits a {@code ClassTree} node.\n@@ -159,1 +159,1 @@\n-     * Visits a ConditionalExpressionTree node.\n+     * Visits a {@code ConditionalExpressionTree} node.\n@@ -167,1 +167,1 @@\n-     * Visits a ContinueTree node.\n+     * Visits a {@code ContinueTree} node.\n@@ -175,1 +175,1 @@\n-     * Visits a DefaultValue node.\n+     * Visits a {@code DefaultValue} node.\n@@ -183,1 +183,1 @@\n-     * Visits a DoWhileTree node.\n+     * Visits a {@code DoWhileTree} node.\n@@ -191,1 +191,1 @@\n-     * Visits an ErroneousTree node.\n+     * Visits an {@code ErroneousTree} node.\n@@ -199,1 +199,1 @@\n-     * Visits an ExpressionStatementTree node.\n+     * Visits an {@code ExpressionStatementTree} node.\n@@ -207,1 +207,1 @@\n-     * Visits an EnhancedForLoopTree node.\n+     * Visits an {@code EnhancedForLoopTree} node.\n@@ -215,1 +215,1 @@\n-     * Visits a ForLoopTree node.\n+     * Visits a {@code ForLoopTree} node.\n@@ -223,1 +223,1 @@\n-     * Visits an IdentifierTree node.\n+     * Visits an {@code IdentifierTree} node.\n@@ -231,1 +231,1 @@\n-     * Visits an IfTree node.\n+     * Visits an {@code IfTree} node.\n@@ -239,1 +239,1 @@\n-     * Visits an ImportTree node.\n+     * Visits an {@code ImportTree} node.\n@@ -247,1 +247,1 @@\n-     * Visits an ArrayAccessTree node.\n+     * Visits an {@code ArrayAccessTree} node.\n@@ -255,1 +255,1 @@\n-     * Visits a LabeledStatementTree node.\n+     * Visits a {@code LabeledStatementTree} node.\n@@ -263,1 +263,1 @@\n-     * Visits a LiteralTree node.\n+     * Visits a {@code LiteralTree} node.\n@@ -271,1 +271,1 @@\n-     * Visits an BindingPattern node.\n+     * Visits a {@code BindingPatternTree} node.\n@@ -280,1 +280,1 @@\n-     * Visits a DefaultCaseLabelTree node.\n+     * Visits a {@code DefaultCaseLabelTree} node.\n@@ -290,1 +290,1 @@\n-     * Visits a MethodTree node.\n+     * Visits a {@code MethodTree} node.\n@@ -298,1 +298,1 @@\n-     * Visits a ModifiersTree node.\n+     * Visits a {@code ModifiersTree} node.\n@@ -306,1 +306,1 @@\n-     * Visits a NewArrayTree node.\n+     * Visits a {@code NewArrayTree} node.\n@@ -314,1 +314,1 @@\n-     * Visits a GuardPatternTree node.\n+     * Visits a {@code GuardPatternTree} node.\n@@ -324,1 +324,1 @@\n-     * Visits a ParenthesizedPatternTree node.\n+     * Visits a {@code ParenthesizedPatternTree} node.\n@@ -334,1 +334,1 @@\n-     * Visits a NewClassTree node.\n+     * Visits a {@code NewClassTree} node.\n@@ -342,1 +342,1 @@\n-     * Visits a LambdaExpressionTree node.\n+     * Visits a {@code LambdaExpressionTree} node.\n@@ -350,1 +350,1 @@\n-     * Visits a PackageTree node.\n+     * Visits a {@code PackageTree} node.\n@@ -358,1 +358,1 @@\n-     * Visits a ParenthesizedTree node.\n+     * Visits a {@code ParenthesizedTree} node.\n@@ -366,1 +366,1 @@\n-     * Visits a ReturnTree node.\n+     * Visits a {@code ReturnTree} node.\n@@ -374,1 +374,1 @@\n-     * Visits a MemberSelectTree node.\n+     * Visits a {@code MemberSelectTree} node.\n@@ -382,1 +382,1 @@\n-     * Visits a MemberReferenceTree node.\n+     * Visits a {@code MemberReferenceTree} node.\n@@ -390,1 +390,1 @@\n-     * Visits an EmptyStatementTree node.\n+     * Visits an {@code EmptyStatementTree} node.\n@@ -398,1 +398,1 @@\n-     * Visits a SwitchTree node.\n+     * Visits a {@code SwitchTree} node.\n@@ -406,1 +406,1 @@\n-     * Visits a SwitchExpressionTree node.\n+     * Visits a {@code SwitchExpressionTree} node.\n@@ -416,1 +416,1 @@\n-     * Visits a SynchronizedTree node.\n+     * Visits a {@code SynchronizedTree} node.\n@@ -424,1 +424,1 @@\n-     * Visits a ThrowTree node.\n+     * Visits a {@code ThrowTree} node.\n@@ -432,1 +432,1 @@\n-     * Visits a CompilationUnitTree node.\n+     * Visits a {@code CompilationUnitTree} node.\n@@ -440,1 +440,1 @@\n-     * Visits a TryTree node.\n+     * Visits a {@code TryTree} node.\n@@ -448,1 +448,1 @@\n-     * Visits a ParameterizedTypeTree node.\n+     * Visits a {@code ParameterizedTypeTree} node.\n@@ -456,1 +456,1 @@\n-     * Visits a UnionTypeTree node.\n+     * Visits a {@code UnionTypeTree} node.\n@@ -464,1 +464,1 @@\n-     * Visits an IntersectionTypeTree node.\n+     * Visits an {@code IntersectionTypeTree} node.\n@@ -472,1 +472,1 @@\n-     * Visits an ArrayTypeTree node.\n+     * Visits an {@code ArrayTypeTree} node.\n@@ -480,1 +480,1 @@\n-     * Visits a TypeCastTree node.\n+     * Visits a {@code TypeCastTree} node.\n@@ -488,1 +488,1 @@\n-     * Visits a PrimitiveTypeTree node.\n+     * Visits a {@code PrimitiveTypeTree} node.\n@@ -496,1 +496,1 @@\n-     * Visits a TypeParameterTree node.\n+     * Visits a {@code TypeParameterTree} node.\n@@ -504,1 +504,1 @@\n-     * Visits an InstanceOfTree node.\n+     * Visits an {@code InstanceOfTree} node.\n@@ -512,1 +512,1 @@\n-     * Visits a UnaryTree node.\n+     * Visits a {@code UnaryTree} node.\n@@ -520,1 +520,1 @@\n-     * Visits a VariableTree node.\n+     * Visits a {@code VariableTree} node.\n@@ -528,1 +528,1 @@\n-     * Visits a WhileLoopTree node.\n+     * Visits a {@code WhileLoopTree} node.\n@@ -536,1 +536,1 @@\n-     * Visits a WithFieldTree node.\n+     * Visits a {@code WithFieldTree} node.\n@@ -545,0 +545,1 @@\n+     * Visits a {@code WildcardTypeTree} node.\n@@ -552,1 +553,1 @@\n-     * Visits a ModuleTree node.\n+     * Visits a {@code ModuleTree} node.\n@@ -560,1 +561,1 @@\n-     * Visits an ExportsTree node.\n+     * Visits an {@code ExportsTree} node.\n@@ -568,1 +569,1 @@\n-     * Visits an OpensTree node.\n+     * Visits an {@code OpensTree} node.\n@@ -576,1 +577,1 @@\n-     * Visits a ProvidesTree node.\n+     * Visits a {@code ProvidesTree} node.\n@@ -584,1 +585,1 @@\n-     * Visits a RequiresTree node.\n+     * Visits a {@code RequiresTree} node.\n@@ -592,1 +593,1 @@\n-     * Visits a UsesTree node.\n+     * Visits a {@code UsesTree} node.\n@@ -600,1 +601,1 @@\n-     * Visits an unknown type of Tree node.\n+     * Visits an unknown type of {@code Tree} node.\n@@ -610,1 +611,1 @@\n-     * Visits a YieldTree node.\n+     * Visits a {@code YieldTree} node.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":69,"deletions":68,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2270,2 +2270,1 @@\n-            Type result = asType().getReceiverType();\n-            return (result == null) ? Type.noType : result;\n+            return asType().getReceiverType();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1794,1 +1794,3 @@\n-        public Type              getReceiverType()   { return recvtype; }\n+        public Type              getReceiverType()   {\n+            return (recvtype == null) ? Type.noType : recvtype;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2550,0 +2550,1 @@\n+            localEnv.info.constructorArgs = true;\n@@ -2551,0 +2552,1 @@\n+            localEnv.info.constructorArgs = false;\n@@ -4491,1 +4493,1 @@\n-                        sym.name == names._super)) {\n+                        sym.name == names._super && env.info.constructorArgs)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+    \/** are we analyzing the arguments for a constructor invocation?\n+     *\/\n+    boolean constructorArgs = false;\n+\n@@ -137,0 +141,1 @@\n+        info.constructorArgs = constructorArgs;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -556,2 +556,7 @@\n-                if (node.errs != null && node.errs.nonEmpty())\n-                    return getStartPos(node.errs.head);\n+                if (node.errs != null && node.errs.nonEmpty()) {\n+                    int pos = getStartPos(node.errs.head);\n+                    if (pos != Position.NOPOS) {\n+                        return pos;\n+                    }\n+                }\n+                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-serviceability\/sa\/TestJmapCore.java                           8268722,8268283   macosx-x64,linux-aarch64\n+serviceability\/sa\/TestJmapCore.java                           8268722,8268283,8270202   macosx-x64,linux-aarch64,linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+compiler\/codecache\/TestStressCodeBuffers.java 8272094 generic-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -609,1 +609,2 @@\n-  public native boolean areSharedStringsIgnored();\n+  public native boolean areSharedStringsMapped();\n+  public native boolean isSharedInternedString(String s);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}