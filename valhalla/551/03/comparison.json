{"files":[{"patch":"@@ -1843,1 +1843,2 @@\n-      } else if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n+      } else if (field->is_null_free() && field->type()->as_instance_klass()->is_initialized() &&\n+                 field->type()->as_inline_klass()->is_empty()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1652,1 +1652,1 @@\n-  if (!inline_type_field_access_prolog(x, info)) {\n+  if (!inline_type_field_access_prolog(x)) {\n@@ -2037,1 +2037,1 @@\n-bool LIRGenerator::inline_type_field_access_prolog(AccessField* x, CodeEmitInfo* info) {\n+bool LIRGenerator::inline_type_field_access_prolog(AccessField* x) {\n@@ -2047,6 +2047,6 @@\n-  \/\/ Deoptimize if we load from a static field with an unloaded type because we need\n-  \/\/ the default value if the field is null.\n-  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->is_loaded();\n-  assert(!could_be_null || !field->holder()->is_loaded(), \"inline type field should be loaded\");\n-  if (could_be_flat || could_be_null) {\n-    assert(x->needs_patching(), \"no deopt required\");\n+  \/\/ Deoptimize if we load from a static field with an uninitialized type because we\n+  \/\/ need to throw an exception if initialization of the type failed.\n+  bool not_initialized = x->is_static() && x->as_LoadField() != NULL &&\n+      !field->type()->as_instance_klass()->is_initialized();\n+  if (could_be_flat || not_initialized) {\n+    CodeEmitInfo* info = state_for(x, x->state_before());\n@@ -2091,1 +2091,1 @@\n-  if (!inline_type_field_access_prolog(x, info)) {\n+  if (!inline_type_field_access_prolog(x)) {\n@@ -2131,3 +2131,0 @@\n-    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n-    assert(inline_klass->is_loaded(), \"field klass must be loaded\");\n-\n@@ -2146,0 +2143,1 @@\n+    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  bool inline_type_field_access_prolog(AccessField* x, CodeEmitInfo* info);\n+  bool inline_type_field_access_prolog(AccessField* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,10 @@\n-    if (!field_type->is_loaded()) {\n+    if (field->is_static() && field->is_null_free() &&\n+        !field_type->as_instance_klass()->is_initialized()) {\n+      \/\/ Deoptimize if we load from a static field with an uninitialized inline type\n+      \/\/ because we need to throw an exception if initialization of the type failed.\n+      trap(str, field_type->as_klass(),\n+           Deoptimization::make_trap_request\n+           (Deoptimization::Reason_unloaded,\n+            Deoptimization::Action_reinterpret));\n+      return;\n+    } else if (!field_type->is_loaded()) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -243,2 +243,5 @@\n-        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n-            checkAnnotationsInClass(clazz, \"inner\");\n+        \/\/ TODO remove this once JDK-8273591 is fixed\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+                checkAnnotationsInClass(clazz, \"inner\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import compiler.lib.ir_framework.Run;\n-import compiler.lib.ir_framework.RunInfo;\n-import compiler.lib.ir_framework.Scenario;\n-import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n@@ -55,5 +52,3 @@\n-                new Scenario(2, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-XX:+PatchALot\"),\n-                new Scenario(3,\n-                             \"-XX:InlineFieldMaxFlatSize=0\",\n-                             \"-XX:+IgnoreUnrecognizedVMOptions\",\n-                             \"-XX:+PatchALot\")\n+                new Scenario(2, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+PatchALot\"),\n+                new Scenario(3, \"-XX:InlineFieldMaxFlatSize=0\",\n+                                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+PatchALot\")\n@@ -61,1 +56,4 @@\n-        final String[] CutoffFlags = {\"-XX:PerMethodRecompilationCutoff=-1\", \"-XX:PerBytecodeRecompilationCutoff=-1\"};\n+        final String[] flags = {\/\/ Prevent IR Test Framework from loading classes\n+                                \"-DIgnoreCompilerControls=true\",\n+                                \/\/ Some tests trigger frequent re-compilation. Don't mark them as non-compilable.\n+                                \"-XX:PerMethodRecompilationCutoff=-1\", \"-XX:PerBytecodeRecompilationCutoff=-1\"};\n@@ -63,1 +61,1 @@\n-           s.addFlags(CutoffFlags);\n+           s.addFlags(flags);\n@@ -65,1 +63,0 @@\n-\n@@ -886,0 +883,217 @@\n+\n+    static primitive class Test21ClassA {\n+        static Test21ClassB b;\n+        static Test21ClassC c;\n+    }\n+\n+    static primitive class Test21ClassB {\n+        static int x = Test21ClassA.c.x;\n+    }\n+\n+    static primitive class Test21ClassC {\n+        int x = 42;\n+    }\n+\n+    \/\/ Test access to static inline type field with unloaded type\n+    @Test\n+    public Object test21() {\n+        return new Test21ClassA();\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        Object ret = test21();\n+        Asserts.assertEQ(Test21ClassA.b.x, 0);\n+        Asserts.assertEQ(Test21ClassA.c.x, 0);\n+    }\n+\n+    static boolean test22FailInit = true;\n+\n+    static primitive class Test22ClassA {\n+        int x = 0;\n+        static Test22ClassB b;\n+    }\n+\n+    static primitive class Test22ClassB {\n+        int x = 0;\n+        static {\n+            if (test22FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that load from static field of uninitialized inline type throws an exception\n+    @Test\n+    public Object test22() {\n+        return Test22ClassA.b;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        \/\/ Trigger initialization error in Test22ClassB\n+        try {\n+            Test22ClassB b = new Test22ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test22();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test23FailInit = true;\n+\n+    static primitive class Test23ClassA {\n+        int x = 0;\n+        static Test23ClassB b;\n+    }\n+\n+    static primitive class Test23ClassB {\n+        static {\n+            if (test23FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test22 but with empty ClassB\n+    @Test\n+    public Object test23() {\n+        return Test23ClassA.b;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        \/\/ Trigger initialization error in Test23ClassB\n+        try {\n+            Test23ClassB b = new Test23ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test23();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test24FailInit = true;\n+\n+    static primitive class Test24ClassA {\n+        Test24ClassB b = Test24ClassB.default;\n+    }\n+\n+    static primitive class Test24ClassB {\n+        int x = 0;\n+        static {\n+            if (test24FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that access to non-static field of uninitialized inline type throws an exception\n+    @Test\n+    public Object test24() {\n+        return Test24ClassA.default.b.x;\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        \/\/ Trigger initialization error in Test24ClassB\n+        try {\n+            Test24ClassB b = new Test24ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test24();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test25FailInit = true;\n+\n+    static primitive class Test25ClassA {\n+        Test25ClassB b = Test25ClassB.default;\n+    }\n+\n+    static primitive class Test25ClassB {\n+        int x = 24;\n+        static {\n+            if (test25FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test24 but with field access outside of test method\n+    @Test\n+    public Test25ClassB test25() {\n+        return Test25ClassA.default.b;\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        \/\/ Trigger initialization error in Test25ClassB\n+        try {\n+            Test25ClassB b = new Test25ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        Test25ClassB res = test25();\n+        try {\n+            Asserts.assertEQ(res.x, 0);\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test26FailInit = true;\n+\n+    static primitive class Test26ClassA {\n+        Test26ClassB b = Test26ClassB.default;\n+    }\n+\n+    static primitive class Test26ClassB {\n+        static {\n+            if (test26FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test25 but with empty ClassB\n+    @Test\n+    public Object test26() {\n+        return Test26ClassA.default.b;\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        \/\/ Trigger initialization error in Test26ClassB\n+        try {\n+            Test26ClassB b = new Test26ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test26();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":226,"deletions":12,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xint runtime.valhalla.inlinetypes.CircularityTest\n+ * @run main runtime.valhalla.inlinetypes.CircularityTest\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CircularityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}