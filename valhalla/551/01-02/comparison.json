{"files":[{"patch":"@@ -1843,1 +1843,2 @@\n-      } else if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n+      } else if (field->is_null_free() && field->type()->as_instance_klass()->is_initialized() &&\n+                 field->type()->as_inline_klass()->is_empty()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2047,4 +2047,5 @@\n-  \/\/ Deoptimize if we load from a static field with an unloaded type because we need\n-  \/\/ the default value if the field is null.\n-  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->is_loaded();\n-  if (could_be_flat || could_be_null) {\n+  \/\/ Deoptimize if we load from a static field with an uninitialized type because we\n+  \/\/ need to throw an exception if initialization of the type failed.\n+  bool not_initialized = x->is_static() && x->as_LoadField() != NULL &&\n+      !field->type()->as_instance_klass()->is_initialized();\n+  if (could_be_flat || not_initialized) {\n@@ -2130,3 +2131,0 @@\n-    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n-    assert(inline_klass->is_loaded(), \"field klass must be loaded\");\n-\n@@ -2145,0 +2143,1 @@\n+    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -672,10 +672,9 @@\n-    if (!field_type->is_loaded()) {\n-      if (field->is_static() && field->is_null_free()) {\n-        \/\/ Deoptimize if we load from a static field with an unloaded\n-        \/\/ inline type because we need the default value if the field is null.\n-        trap(str, field_type->as_klass(),\n-             Deoptimization::make_trap_request\n-             (Deoptimization::Reason_unloaded,\n-              Deoptimization::Action_reinterpret));\n-        return;\n-      }\n+    if (field->is_static() && field->is_null_free() && !field_type->as_inline_klass()->is_initialized()) {\n+      \/\/ Deoptimize if we load from a static field with an uninitialized inline type\n+      \/\/ because we need to throw an exception if initialization of the type failed.\n+      trap(str, field_type->as_klass(),\n+           Deoptimization::make_trap_request\n+           (Deoptimization::Reason_unloaded,\n+            Deoptimization::Action_reinterpret));\n+      return;\n+    } else if (!field_type->is_loaded()) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -909,0 +909,191 @@\n+\n+    static boolean test22FailInit = true;\n+\n+    static primitive class Test22ClassA {\n+        int x = 0;\n+        static Test22ClassB b;\n+    }\n+\n+    static primitive class Test22ClassB {\n+        int x = 0;\n+        static {\n+            if (test22FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that load from static field of uninitialized inline type throws an exception\n+    @Test\n+    public Object test22() {\n+        return Test22ClassA.b;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        \/\/ Trigger initialization error in Test22ClassB\n+        try {\n+            Test22ClassB b = new Test22ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test22();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test23FailInit = true;\n+\n+    static primitive class Test23ClassA {\n+        int x = 0;\n+        static Test23ClassB b;\n+    }\n+\n+    static primitive class Test23ClassB {\n+        static {\n+            if (test23FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test22 but with empty ClassB\n+    @Test\n+    public Object test23() {\n+        return Test23ClassA.b;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        \/\/ Trigger initialization error in Test23ClassB\n+        try {\n+            Test23ClassB b = new Test23ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test23();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test24FailInit = true;\n+\n+    static primitive class Test24ClassA {\n+        Test24ClassB b = Test24ClassB.default;\n+    }\n+\n+    static primitive class Test24ClassB {\n+        int x = 0;\n+        static {\n+            if (test24FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that access to non-static field of uninitialized inline type throws an exception\n+    @Test\n+    public Object test24() {\n+        return Test24ClassA.default.b.x;\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        \/\/ Trigger initialization error in Test24ClassB\n+        try {\n+            Test24ClassB b = new Test24ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test24();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test25FailInit = true;\n+\n+    static primitive class Test25ClassA {\n+        Test25ClassB b = Test25ClassB.default;\n+    }\n+\n+    static primitive class Test25ClassB {\n+        int x = 24;\n+        static {\n+            if (test25FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test24 but with field access outside of test method\n+    @Test\n+    public Test25ClassB test25() {\n+        return Test25ClassA.default.b;\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        \/\/ Trigger initialization error in Test25ClassB\n+        try {\n+            Test25ClassB b = new Test25ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        Test25ClassB res = test25();\n+        try {\n+            Asserts.assertEQ(res.x, 0);\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static boolean test26FailInit = true;\n+\n+    static primitive class Test26ClassA {\n+        Test26ClassB b = Test26ClassB.default;\n+    }\n+\n+    static primitive class Test26ClassB {\n+        static {\n+            if (test26FailInit) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test25 but with empty ClassB\n+    @Test\n+    public Object test26() {\n+        return Test26ClassA.default.b;\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        \/\/ Trigger initialization error in Test26ClassB\n+        try {\n+            Test26ClassB b = new Test26ClassB();\n+            throw new RuntimeException(\"Should have thrown error during initialization\");\n+        } catch (ExceptionInInitializerError | NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test26();\n+            throw new RuntimeException(\"Should have thrown NoClassDefFoundError\");\n+        } catch (NoClassDefFoundError e) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xint runtime.valhalla.inlinetypes.CircularityTest\n+ * @run main runtime.valhalla.inlinetypes.CircularityTest\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CircularityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}