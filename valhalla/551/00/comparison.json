{"files":[{"patch":"@@ -1652,1 +1652,1 @@\n-  if (!inline_type_field_access_prolog(x, info)) {\n+  if (!inline_type_field_access_prolog(x)) {\n@@ -2037,1 +2037,1 @@\n-bool LIRGenerator::inline_type_field_access_prolog(AccessField* x, CodeEmitInfo* info) {\n+bool LIRGenerator::inline_type_field_access_prolog(AccessField* x) {\n@@ -2050,1 +2050,0 @@\n-  assert(!could_be_null || !field->holder()->is_loaded(), \"inline type field should be loaded\");\n@@ -2052,2 +2051,2 @@\n-    assert(x->needs_patching(), \"no deopt required\");\n-    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n+    CodeEmitInfo* info = state_for(x, x->state_before());\n+    CodeStub* stub = new DeoptimizeStub(info,\n@@ -2091,1 +2090,1 @@\n-  if (!inline_type_field_access_prolog(x, info)) {\n+  if (!inline_type_field_access_prolog(x)) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  bool inline_type_field_access_prolog(AccessField* x, CodeEmitInfo* info);\n+  bool inline_type_field_access_prolog(AccessField* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,0 +325,13 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciBytecodeStream::get_field_signature_index\n+\/\/\n+\/\/ Get the constant pool index of the signature of the field\n+\/\/ referenced by the current bytecode.  Used for generating\n+\/\/ deoptimization information.\n+int ciBytecodeStream::get_field_signature_index() {\n+  VM_ENTRY_MARK;\n+  ConstantPool* cpool = _holder->get_instanceKlass()->constants();\n+  int nt_index = cpool->name_and_type_ref_index_at(get_field_index());\n+  return cpool->signature_ref_index_at(nt_index);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+  int      get_field_signature_index();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -673,0 +673,6 @@\n+      if (field->is_static() && field->is_null_free()) {\n+        \/\/ Deoptimize if we load from a static field with an unloaded\n+        \/\/ inline type because we need the default value if the field is null.\n+        trap(str, field_type->as_klass(), str->get_field_signature_index());\n+        return;\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -243,2 +243,5 @@\n-        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n-            checkAnnotationsInClass(clazz, \"inner\");\n+        \/\/ TODO remove this once JDK-8273591 is fixed\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+                checkAnnotationsInClass(clazz, \"inner\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import compiler.lib.ir_framework.Run;\n-import compiler.lib.ir_framework.RunInfo;\n-import compiler.lib.ir_framework.Scenario;\n-import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n@@ -55,5 +52,3 @@\n-                new Scenario(2, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-XX:+PatchALot\"),\n-                new Scenario(3,\n-                             \"-XX:InlineFieldMaxFlatSize=0\",\n-                             \"-XX:+IgnoreUnrecognizedVMOptions\",\n-                             \"-XX:+PatchALot\")\n+                new Scenario(2, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+PatchALot\"),\n+                new Scenario(3, \"-XX:InlineFieldMaxFlatSize=0\",\n+                                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+PatchALot\")\n@@ -61,1 +56,4 @@\n-        final String[] CutoffFlags = {\"-XX:PerMethodRecompilationCutoff=-1\", \"-XX:PerBytecodeRecompilationCutoff=-1\"};\n+        final String[] flags = {\/\/ Prevent IR Test Framework from loading classes\n+                                \"-DIgnoreCompilerControls=true\",\n+                                \/\/ Some tests trigger frequent re-compilation. Don't mark them as non-compilable.\n+                                \"-XX:PerMethodRecompilationCutoff=-1\", \"-XX:PerBytecodeRecompilationCutoff=-1\"};\n@@ -63,1 +61,1 @@\n-           s.addFlags(CutoffFlags);\n+           s.addFlags(flags);\n@@ -65,1 +63,0 @@\n-\n@@ -886,0 +883,26 @@\n+\n+    static primitive class Test21ClassA {\n+        static Test21ClassB b;\n+        static Test21ClassC c;\n+    }\n+\n+    static primitive class Test21ClassB {\n+        static int x = Test21ClassA.c.x;\n+    }\n+\n+    static primitive class Test21ClassC {\n+        int x = 42;\n+    }\n+\n+    \/\/ Test access to static inline type field with unloaded type\n+    @Test\n+    public Object test21() {\n+        return new Test21ClassA();\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        Object ret = test21();\n+        Asserts.assertEQ(Test21ClassA.b.x, 0);\n+        Asserts.assertEQ(Test21ClassA.c.x, 0);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"}]}