{"files":[{"patch":"@@ -2264,0 +2264,5 @@\n+        if (isPrimitiveClass(t)) {\n+            \/\/ No man may be an island, but the bell tolls for a value.\n+            return t.tsym == sym ? t : null;\n+        }\n+\n@@ -2265,2 +2270,1 @@\n-            if (!isPrimitiveClass(t))\n-                return syms.objectType;\n+            return syms.objectType;\n@@ -2269,2 +2273,2 @@\n-            \/\/ IdentityObject is super interface of every concrete identity class other than jlO\n-            if (t.isPrimitiveClass() || t.tsym == syms.objectType.tsym)\n+            \/\/ IdentityObject is a super interface of every concrete identity class other than jlO\n+            if (t.tsym == syms.objectType.tsym)\n@@ -2276,0 +2280,3 @@\n+            }\n+            if (implicitIdentityType(t)) {\n+                return syms.identityObjectType;\n@@ -2278,1 +2285,1 @@\n-            if (t.isPrimitiveClass() || t.isReferenceProjection())\n+            if (t.isReferenceProjection())\n@@ -2280,1 +2287,1 @@\n-            if (t.hasTag(ARRAY) || t.tsym == syms.objectType.tsym || !t.hasTag(CLASS))\n+            if (t.hasTag(ARRAY) || t.tsym == syms.objectType.tsym)\n@@ -2300,4 +2307,0 @@\n-                \/\/ No man may be an island, but the bell tolls for a value.\n-                if (isPrimitiveClass(t))\n-                    return null;\n-\n@@ -2349,0 +2352,57 @@\n+        \/\/ where\n+        private boolean implicitIdentityType(Type t) {\n+            \/* An abstract class can be declared to implement either IdentityObject or PrimitiveObject;\n+             * or, if it declares a field, an instance initializer, a non-empty constructor, or\n+             * a synchronized method, it implicitly implements IdentityObject.\n+             *\/\n+            if (!t.tsym.isAbstract())\n+                return false;\n+\n+            for (; t != Type.noType; t = supertype(t)) {\n+\n+                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n+                    return false;\n+\n+                if  (t.tsym == syms.objectType.tsym)\n+                    return false;\n+\n+                if (!t.tsym.isAbstract()) {\n+                    return !t.tsym.isPrimitiveClass();\n+                }\n+\n+                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n+                    return true;\n+                }\n+\n+                \/\/ No instance fields and no arged constructors both mean inner classes cannot be inline supers.\n+                Type encl = t.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    return true;\n+                }\n+                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0) {\n+                                return true;\n+                            }\n+                            break;\n+                        case MTH:\n+                            if ((s.flags() & SYNCHRONIZED) != 0) {\n+                                return true;\n+                            } else if (s.isConstructor()) {\n+                                MethodSymbol m = (MethodSymbol)s;\n+                                if (m.getParameters().size() > 0) {\n+                                    return true;\n+                                } else {\n+                                    if ((m.flags() & (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {\n+                                        return true;\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":70,"deletions":10,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -5418,2 +5418,0 @@\n-                attribClassBody(env, c);\n-\n@@ -5428,0 +5426,2 @@\n+                attribClassBody(env, c);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-BinarySuperclassConstraints.java:14:15: compiler.err.primitive.class.must.not.implement.identity.object: BinarySuperclassConstraints.I0\n+BinarySuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.primitive.class: BinarySuperclassConstraints.I0, SuperclassCollections.BadSuper\n@@ -7,1 +7,1 @@\n-BinarySuperclassConstraints.java:46:15: compiler.err.encl.class.required: SuperclassCollections.InnerSuper\n+BinarySuperclassConstraints.java:46:15: compiler.err.super.class.cannot.be.inner: BinarySuperclassConstraints.I13, SuperclassCollections.InnerSuper\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/BinarySuperclassConstraints.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @summary Values may not extend an identity class\n+ * @summary Check that a concrete class is not allowed to be the super class of a primitive class\n@@ -9,2 +9,2 @@\n-    static class Nested {}\n-    static primitive class NestedValue extends Nested {}\n+    static class NestedConcrete {}\n+    static primitive class NestedPrimitive extends NestedConcrete {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckExtends.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckExtends.java:10:22: compiler.err.primitive.class.must.not.implement.identity.object: CheckExtends.NestedValue\n+CheckExtends.java:10:22: compiler.err.concrete.supertype.for.primitive.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckExtends.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    abstract class S implements I<String> {}\n+    static abstract class S implements I<String> {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ConflictingSuperInterfaceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Allow anonymous classes to be value types\n+ * @summary Allow anonymous classes to be primitive class types\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/IllegalByValueTest2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-IllegalByValueTest2.java:19:59: compiler.err.primitive.class.must.not.implement.identity.object: compiler.misc.anonymous.class: IllegalByValueTest2\n+IllegalByValueTest2.java:19:59: compiler.err.concrete.supertype.for.primitive.class: compiler.misc.anonymous.class: IllegalByValueTest2$1, IllegalByValueTest2\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/IllegalByValueTest2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8267910\n+ * @summary Javac fails to implicitly type abstract classes as implementing IdentityObject\n+ * @compile\/fail\/ref=ImplicitIdentityTypeTest.out -XDrawDiagnostics ImplicitIdentityTypeTest.java\n+ *\/\n+\n+\/* An abstract implicitly implements IdentityObject\n+        - if it declares a field,\n+        - an instance initializer,\n+        - a non-empty constructor,\n+        - a synchronized method,\n+        - has a concrete super,\n+        - is an inner class.\n+*\/\n+\n+public class ImplicitIdentityTypeTest {\n+\n+    static abstract class A {}  \/\/ Not an Identity class.\n+    static abstract class B { static { System.out.println(); } }  \/\/ Not an Identity class.\n+\n+\n+    \/\/ All abstract classes below are identity classes by implicit typing.\n+\n+    abstract class C {}  \/\/ inner class implicitly implements IdentityObject\n+    static abstract class D { int f; }  \/\/ instance field lends it identity.\n+    static abstract class E { { System.out.println(); } }  \/\/ initializer lends it identity.\n+    static abstract class F { F(){ System.out.println(); }}  \/\/ non-empty ctor.\n+    static abstract class G { synchronized void f() {} }  \/\/ synchronized method.\n+    static abstract class H extends ImplicitIdentityTypeTest {}  \/\/ concrete super.\n+\n+    void check() {\n+        IdentityObject i;\n+        A a = null;\n+        B b = null;\n+        C c = null;\n+        D d = null;\n+        E e = null;\n+        F f = null;\n+        G g = null;\n+        H h = null;\n+\n+        i = a; \/\/ Error.\n+        i = b; \/\/ Error.\n+\n+        \/\/ The following assignments are kosher.\n+        i = c; i = d; i = e; i = f; i = g; i = h;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ImplicitIdentityTypeTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ImplicitIdentityTypeTest.java:43:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ImplicitIdentityTypeTest.A, java.lang.IdentityObject)\n+ImplicitIdentityTypeTest.java:44:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ImplicitIdentityTypeTest.B, java.lang.IdentityObject)\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ImplicitIdentityTypeTest.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-SuperclassConstraints.java:14:15: compiler.err.primitive.class.must.not.implement.identity.object: SuperclassConstraints.I0\n+SuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.primitive.class: SuperclassConstraints.I0, SuperclassConstraints.BadSuper\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SuperclassConstraints.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}