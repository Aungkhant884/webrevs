{"files":[{"patch":"@@ -96,1 +96,1 @@\n-  assert(sig != NULL, \"must have scalarized signature\");\n+  assert(sig != nullptr, \"must have scalarized signature\");\n","filename":"src\/hotspot\/share\/asm\/macroAssembler_common.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-                   CodeStub* throw_imse_stub = NULL, LIR_Opr scratch_reg = LIR_OprFact::illegalOpr)\n+                   CodeStub* throw_imse_stub = nullptr, LIR_Opr scratch_reg = LIR_OprFact::illegalOpr)\n@@ -437,1 +437,1 @@\n-    if (_throw_imse_stub != NULL) {\n+    if (_throw_imse_stub != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  bool              has_pending_field_access()   { return _pending_field_access != NULL; }\n+  bool              has_pending_field_access()   { return _pending_field_access != nullptr; }\n@@ -234,1 +234,1 @@\n-  bool              has_pending_load_indexed()   { return _pending_load_indexed != NULL; }\n+  bool              has_pending_load_indexed()   { return _pending_load_indexed != nullptr; }\n@@ -299,1 +299,1 @@\n-  void copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before, ciField* encloding_field = NULL);\n+  void copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before, ciField* encloding_field = nullptr);\n@@ -396,1 +396,1 @@\n-    if (v != NULL && v->as_NewInlineTypeInstance() != NULL) {\n+    if (v != nullptr && v->as_NewInlineTypeInstance() != nullptr) {\n@@ -401,1 +401,1 @@\n-    if (v != NULL && v->as_NewInlineTypeInstance() != NULL &&\n+    if (v != nullptr && v->as_NewInlineTypeInstance() != nullptr &&\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-  if (x->delayed() != NULL) {\n+  if (x->delayed() != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = NULL, int offset = 0);\n+  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = nullptr, int offset = 0);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  void build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc = 0, bool needs_stack_repair = false, bool has_scalarized_args = false, Label* verified_inline_entry_label = NULL);\n+  void build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc = 0, bool needs_stack_repair = false, bool has_scalarized_args = false, Label* verified_inline_entry_label = nullptr);\n","filename":"src\/hotspot\/share\/c1\/c1_MacroAssembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-  if (md != NULL) {\n+  if (md != nullptr) {\n@@ -483,1 +483,1 @@\n-    assert(data != NULL && data->is_ArrayLoadStoreData(), \"incorrect profiling entry\");\n+    assert(data != nullptr && data->is_ArrayLoadStoreData(), \"incorrect profiling entry\");\n@@ -507,1 +507,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -590,2 +590,2 @@\n-    assert(instr->as_LoadIndexed() == NULL || !instr->as_LoadIndexed()->should_profile(), \"should not be optimized out\");\n-    assert(instr->as_StoreIndexed() == NULL, \"should not be optimized out\");\n+    assert(instr->as_LoadIndexed() == nullptr || !instr->as_LoadIndexed()->should_profile(), \"should not be optimized out\");\n+    assert(instr->as_StoreIndexed() == nullptr, \"should not be optimized out\");\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-      if (x->enclosing_field() != NULL) {\n+      if (x->enclosing_field() != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  virtual ciKlass* element_klass() { return NULL; }\n+  virtual ciKlass* element_klass() { return nullptr; }\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    _element_klass = NULL;\n+    _element_klass = nullptr;\n@@ -65,2 +65,2 @@\n-  if (_element_klass == NULL) {\n-    assert(dimension() > 1, \"_element_klass should not be NULL\");\n+  if (_element_klass == nullptr) {\n+    assert(dimension() > 1, \"_element_klass should not be nullptr\");\n@@ -77,1 +77,1 @@\n-  assert(element_klass()->is_loaded() && element_klass()->as_inline_klass()->exact_klass() != NULL, \"must have exact klass\");\n+  assert(element_klass()->is_loaded() && element_klass()->as_inline_klass()->exact_klass() != nullptr, \"must have exact klass\");\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  assert(super() == NULL || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n+  assert(super() == nullptr || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n@@ -36,2 +36,2 @@\n-  GrowableArray<ciField*>* fields = NULL;\n-  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(NULL, false \/* no flattening *\/);)\n+  GrowableArray<ciField*>* fields = nullptr;\n+  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(nullptr, false \/* no flattening *\/);)\n@@ -39,1 +39,1 @@\n-  _declared_nonstatic_fields = (fields != NULL) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n+  _declared_nonstatic_fields = (fields != nullptr) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  ciInlineKlass(Klass* h_k) : ciInstanceKlass(h_k), _declared_nonstatic_fields(NULL) {\n+  ciInlineKlass(Klass* h_k) : ciInstanceKlass(h_k), _declared_nonstatic_fields(nullptr) {\n@@ -64,1 +64,1 @@\n-    if (_declared_nonstatic_fields == NULL) {\n+    if (_declared_nonstatic_fields == nullptr) {\n@@ -72,1 +72,1 @@\n-    assert(_declared_nonstatic_fields != NULL, \"should be initialized\");\n+    assert(_declared_nonstatic_fields != nullptr, \"should be initialized\");\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  ciType* java_mirror_type(bool* is_val_mirror = NULL);\n+  ciType* java_mirror_type(bool* is_val_mirror = nullptr);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -661,1 +661,1 @@\n-  if (method_data() != NULL && method_data()->is_mature()) {\n+  if (method_data() != nullptr && method_data()->is_mature()) {\n@@ -663,1 +663,1 @@\n-    if (data != NULL && data->is_ArrayLoadStoreData()) {\n+    if (data != nullptr && data->is_ArrayLoadStoreData()) {\n@@ -677,1 +677,1 @@\n-  if (method_data() != NULL && method_data()->is_mature()) {\n+  if (method_data() != nullptr && method_data()->is_mature()) {\n@@ -679,1 +679,1 @@\n-    if (data != NULL && data->is_ACmpData()) {\n+    if (data != nullptr && data->is_ACmpData()) {\n@@ -1538,2 +1538,2 @@\n-  if (get_Method()->adapter() == NULL) {\n-    return NULL;\n+  if (get_Method()->adapter() == nullptr) {\n+    return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -395,1 +395,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-      \/\/ VM's interpreter will not load 'klass' if object is NULL.\n+      \/\/ VM's interpreter will not load 'klass' if object is nullptr.\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-      if (fund_name == NULL) {\n+      if (fund_name == nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-    assert(!ref.is_null(), \"Unexpected NULL\");\n+    assert(!ref.is_null(), \"Unexpected nullptr\");\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-      \/\/ TBD need error msg if fundamental_name() returns NULL?\n+      \/\/ TBD need error msg if fundamental_name() returns nullptr?\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-        assert(sig != NULL, \"sig should never be null\");\n+        assert(sig != nullptr, \"sig should never be null\");\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    if (_is_init == NULL) {\n+    if (_is_init == nullptr) {\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-                Node* ctl = NULL) :\n+                Node* ctl = nullptr) :\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n- * Find a class from a boot class loader. Returns NULL if class not found.\n+ * Find a class from a boot class loader. Returns nullptr if class not found.\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -541,2 +541,2 @@\n-    _name = NULL;\n-    _signature = NULL;\n+    _name = nullptr;\n+    _signature = nullptr;\n@@ -545,1 +545,1 @@\n-    _holder = NULL;\n+    _holder = nullptr;\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -139,2 +139,2 @@\n-    assert(oop == NULL || oop->is_flatArray(), \"sanity\");\n-    assert(oop == NULL || oop->klass()->is_flatArray_klass(), \"sanity\");\n+    assert(oop == nullptr || oop->is_flatArray(), \"sanity\");\n+    assert(oop == nullptr || oop->klass()->is_flatArray_klass(), \"sanity\");\n@@ -144,2 +144,2 @@\n-  assert(oop == NULL || oop->klass()->is_null_free_array_klass(), \"sanity\");\n-  assert(oop == NULL || oop->is_null_free_array(), \"sanity\");\n+  assert(oop == nullptr || oop->klass()->is_null_free_array_klass(), \"sanity\");\n+  assert(oop == nullptr || oop->is_null_free_array(), \"sanity\");\n@@ -159,1 +159,1 @@\n-  if (array != NULL && array->is_flatArray()) {\n+  if (array != nullptr && array->is_flatArray()) {\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  Klass* super_klass = NULL;\n+  Klass* super_klass = nullptr;\n@@ -107,1 +107,1 @@\n-  if (element_super != NULL) {\n+  if (element_super != nullptr) {\n@@ -110,1 +110,1 @@\n-    bool supers_exist = super_klass != NULL;\n+    bool supers_exist = super_klass != nullptr;\n@@ -116,1 +116,1 @@\n-      if (elem_super->array_klass_or_null() == NULL) {\n+      if (elem_super->array_klass_or_null() == nullptr) {\n@@ -123,1 +123,1 @@\n-      Klass* ek = NULL;\n+      Klass* ek = nullptr;\n@@ -144,1 +144,1 @@\n-  assert(module != NULL, \"No module entry for array\");\n+  assert(module != nullptr, \"No module entry for array\");\n@@ -330,1 +330,1 @@\n-       if (se == NULL) {\n+       if (se == nullptr) {\n@@ -351,1 +351,1 @@\n-  if (higher_dimension_acquire() == NULL) {\n+  if (higher_dimension_acquire() == nullptr) {\n@@ -359,1 +359,1 @@\n-      if (higher_dimension() == NULL) {\n+      if (higher_dimension() == nullptr) {\n@@ -384,2 +384,2 @@\n-  if (higher_dimension_acquire() == NULL) {\n-    return NULL;\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n@@ -402,1 +402,1 @@\n-  assert(element_klass() != NULL, \"FlatArrayKlass returned unexpected NULL bottom_klass\");\n+  assert(element_klass() != nullptr, \"FlatArrayKlass returned unexpected nullptr bottom_klass\");\n@@ -408,1 +408,1 @@\n-  assert(element_klass() != NULL, \"FlatArrayKlass returned unexpected NULL bottom_klass\");\n+  assert(element_klass() != nullptr, \"FlatArrayKlass returned unexpected nullptr bottom_klass\");\n@@ -418,1 +418,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -421,1 +421,1 @@\n-  int num_elem_supers = elem_supers == NULL ? 0 : elem_supers->length();\n+  int num_elem_supers = elem_supers == nullptr ? 0 : elem_supers->length();\n@@ -430,1 +430,1 @@\n-    assert(array_super != NULL, \"must already have been created\");\n+    assert(array_super != nullptr, \"must already have been created\");\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -62,6 +62,6 @@\n-  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n-  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n-  *((address*)adr_pack_handler()) = NULL;\n-  *((address*)adr_pack_handler_jobject()) = NULL;\n-  *((address*)adr_unpack_handler()) = NULL;\n-  assert(pack_handler() == NULL, \"pack handler not null\");\n+  *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n+  *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n+  *((address*)adr_pack_handler()) = nullptr;\n+  *((address*)adr_pack_handler_jobject()) = nullptr;\n+  *((address*)adr_unpack_handler()) = nullptr;\n+  assert(pack_handler() == nullptr, \"pack handler not null\");\n@@ -69,1 +69,1 @@\n-  *((address*)adr_value_array_klasses()) = NULL;\n+  *((address*)adr_value_array_klasses()) = nullptr;\n@@ -75,1 +75,1 @@\n-  assert(val != NULL, \"Sanity check\");\n+  assert(val != nullptr, \"Sanity check\");\n@@ -125,1 +125,1 @@\n-  oop res = NULL;\n+  oop res = nullptr;\n@@ -135,1 +135,1 @@\n-  assert(res != NULL, \"Must be set in one of two paths above\");\n+  assert(res != nullptr, \"Must be set in one of two paths above\");\n@@ -140,1 +140,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -175,1 +175,1 @@\n-  if (Atomic::load_acquire(adr_value_array_klasses()) == NULL) {\n+  if (Atomic::load_acquire(adr_value_array_klasses()) == nullptr) {\n@@ -183,1 +183,1 @@\n-      if (value_array_klasses() == NULL) {\n+      if (value_array_klasses() == nullptr) {\n@@ -203,2 +203,2 @@\n-  if (ak == NULL) {\n-    return NULL;\n+  if (ak == nullptr) {\n+    return nullptr;\n@@ -304,1 +304,1 @@\n-      assert(return_regs() == NULL, \"sanity\");\n+      assert(return_regs() == nullptr, \"sanity\");\n@@ -310,1 +310,1 @@\n-  if (extended_sig() != NULL) {\n+  if (extended_sig() != nullptr) {\n@@ -313,1 +313,1 @@\n-  if (return_regs() != NULL) {\n+  if (return_regs() != nullptr) {\n@@ -325,1 +325,1 @@\n-  if (pack_handler() != NULL) {\n+  if (pack_handler() != nullptr) {\n@@ -329,3 +329,3 @@\n-    *((address*)adr_pack_handler()) = NULL;\n-    *((address*)adr_pack_handler_jobject()) = NULL;\n-    *((address*)adr_unpack_handler()) = NULL;\n+    *((address*)adr_pack_handler()) = nullptr;\n+    *((address*)adr_pack_handler_jobject()) = nullptr;\n+    *((address*)adr_unpack_handler()) = nullptr;\n@@ -342,1 +342,1 @@\n-  return InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n+  return InlineTypeReturnedAsFields && (init || return_regs() != nullptr);\n@@ -358,1 +358,1 @@\n-      assert(v == NULL || oopDesc::is_oop(v), \"not an oop?\");\n+      assert(v == nullptr || oopDesc::is_oop(v), \"not an oop?\");\n@@ -380,1 +380,1 @@\n-  assert(regs != NULL, \"inconsistent\");\n+  assert(regs != nullptr, \"inconsistent\");\n@@ -502,1 +502,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -518,7 +518,7 @@\n-  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n-  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n-  *((address*)adr_pack_handler()) = NULL;\n-  *((address*)adr_pack_handler_jobject()) = NULL;\n-  *((address*)adr_unpack_handler()) = NULL;\n-  assert(pack_handler() == NULL, \"pack handler not null\");\n-  if (value_array_klasses() != NULL) {\n+  *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n+  *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n+  *((address*)adr_pack_handler()) = nullptr;\n+  *((address*)adr_pack_handler_jobject()) = nullptr;\n+  *((address*)adr_unpack_handler()) = nullptr;\n+  assert(pack_handler() == nullptr, \"pack handler not null\");\n+  if (value_array_klasses() != nullptr) {\n@@ -531,1 +531,1 @@\n-  if (value_array_klasses() != NULL) {\n+  if (value_array_klasses() != nullptr) {\n@@ -538,1 +538,1 @@\n-  if (value_array_klasses() != NULL) {\n+  if (value_array_klasses() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -64,1 +64,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -69,1 +69,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -74,1 +74,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -79,1 +79,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -84,1 +84,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -93,1 +93,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -98,1 +98,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -103,1 +103,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  if (adr_jf != NULL) {\n+  if (adr_jf != nullptr) {\n@@ -42,1 +42,1 @@\n-  if (adr_impl != NULL) {\n+  if (adr_impl != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, NULL if none present\n+  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, null if none present\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    if (adr_impl != NULL) {\n+    if (adr_impl != nullptr) {\n@@ -78,1 +78,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -86,1 +86,1 @@\n-  assert(k != NULL, \"Should always be set before being read\");\n+  assert(k != nullptr, \"Should always be set before being read\");\n@@ -95,1 +95,1 @@\n-  assert(k == NULL || k->is_inline_klass(), \"Must be an inline type\");\n+  assert(k == nullptr || k->is_inline_klass(), \"Must be an inline type\");\n@@ -102,2 +102,2 @@\n-  assert(k != NULL, \"Should not be set to NULL\");\n-  assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, \"Should not be set twice\");\n+  assert(k != nullptr, \"Should not be set to nullptr\");\n+  assert(((Klass**)adr_inline_type_field_klasses())[idx] == nullptr, \"Should not be set twice\");\n@@ -110,1 +110,1 @@\n-  ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;\n+  ((Klass**)adr_inline_type_field_klasses())[idx] = nullptr;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -714,1 +714,1 @@\n-    return (k == NULL) ? markWord::prototype() : k->prototype_header();\n+    return (k == nullptr) ? markWord::prototype() : k->prototype_header();\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-\/\/  to return a non-NULL for this case, but not confuse the static type bits for\n+\/\/  to return a non-nullptr for this case, but not confuse the static type bits for\n@@ -415,1 +415,1 @@\n-    return (EnableValhalla && _value < static_prototype_value_max) ? NULL :\n+    return (EnableValhalla && _value < static_prototype_value_max) ? nullptr :\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-    return is_ArrayLoadStoreData() ? (ArrayLoadStoreData*)this : NULL;\n+    return is_ArrayLoadStoreData() ? (ArrayLoadStoreData*)this : nullptr;\n@@ -470,1 +470,1 @@\n-    return is_ACmpData() ? (ACmpData*)this : NULL;\n+    return is_ACmpData() ? (ACmpData*)this : nullptr;\n@@ -1938,1 +1938,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -2011,1 +2011,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -575,8 +575,8 @@\n-    fallthrough_proj      = NULL;\n-    fallthrough_catchproj = NULL;\n-    fallthrough_memproj   = NULL;\n-    fallthrough_ioproj    = NULL;\n-    catchall_catchproj    = NULL;\n-    catchall_memproj      = NULL;\n-    catchall_ioproj       = NULL;\n-    exobj                 = NULL;\n+    fallthrough_proj      = nullptr;\n+    fallthrough_catchproj = nullptr;\n+    fallthrough_memproj   = nullptr;\n+    fallthrough_ioproj    = nullptr;\n+    catchall_catchproj    = nullptr;\n+    catchall_memproj      = nullptr;\n+    catchall_ioproj       = nullptr;\n+    exobj                 = nullptr;\n@@ -584,1 +584,1 @@\n-    resproj[0]            = NULL;\n+    resproj[0]            = nullptr;\n@@ -586,1 +586,1 @@\n-      resproj[i]          = NULL;\n+      resproj[i]          = nullptr;\n@@ -751,1 +751,1 @@\n-        method != NULL &&\n+        method != nullptr &&\n@@ -950,1 +950,1 @@\n-               InlineTypeNode* inline_type_node = NULL);\n+               InlineTypeNode* inline_type_node = nullptr);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-  bool is_flat_array_check(PhaseTransform* phase, Node** array = NULL);\n+  bool is_flat_array_check(PhaseTransform* phase, Node** array = nullptr);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1241,1 +1241,1 @@\n-    if (array != NULL) {\n+    if (array != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  phi->add_req(NULL);\n+  phi->add_req(nullptr);\n@@ -167,1 +167,1 @@\n-  phi->add_req(NULL);\n+  phi->add_req(nullptr);\n@@ -171,1 +171,1 @@\n-  phi->add_req(NULL);\n+  phi->add_req(nullptr);\n@@ -179,1 +179,1 @@\n-      val->as_Phi()->add_req(NULL);\n+      val->as_Phi()->add_req(nullptr);\n@@ -198,1 +198,1 @@\n-  assert(value != NULL, \"field value not found\");\n+  assert(value != nullptr, \"field value not found\");\n@@ -260,1 +260,1 @@\n-  assert(jvms != NULL, \"missing JVMS\");\n+  assert(jvms != nullptr, \"missing JVMS\");\n@@ -264,1 +264,1 @@\n-                                                                  NULL,\n+                                                                  nullptr,\n@@ -291,1 +291,1 @@\n-    if (debug != NULL && debug->uncast() == this) {\n+    if (debug != nullptr && debug->uncast() == this) {\n@@ -327,1 +327,1 @@\n-        if (debug != NULL && debug->uncast() == this) {\n+        if (debug != nullptr && debug->uncast() == this) {\n@@ -348,2 +348,2 @@\n-  const TypePtr* adr_type = NULL;\n-  bool is_array = ary_type != NULL;\n+  const TypePtr* adr_type = nullptr;\n+  bool is_array = ary_type != nullptr;\n@@ -357,1 +357,1 @@\n-    assert(field != NULL, \"field not found\");\n+    assert(field != nullptr, \"field not found\");\n@@ -411,1 +411,1 @@\n-    Node* value = NULL;\n+    Node* value = nullptr;\n@@ -422,1 +422,1 @@\n-      bool is_array = (oop_ptr->isa_aryptr() != NULL);\n+      bool is_array = (oop_ptr->isa_aryptr() != nullptr);\n@@ -429,1 +429,1 @@\n-        assert(field != NULL, \"field not found\");\n+        assert(field != nullptr, \"field not found\");\n@@ -432,1 +432,1 @@\n-        assert(con_type != NULL, \"type not found\");\n+        assert(con_type != nullptr, \"type not found\");\n@@ -468,1 +468,1 @@\n-  if (holder == NULL) {\n+  if (holder == nullptr) {\n@@ -491,1 +491,1 @@\n-      bool is_array = (kit->gvn().type(base)->isa_aryptr() != NULL);\n+      bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n@@ -553,1 +553,1 @@\n-    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, this);\n+    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true, this);\n@@ -559,1 +559,1 @@\n-    assert(alloc != NULL, \"must have an allocation node\");\n+    assert(alloc != nullptr, \"must have an allocation node\");\n@@ -597,1 +597,1 @@\n-  const Type* oop_type = (phase != NULL) ? phase->type(oop) : oop->bottom_type();\n+  const Type* oop_type = (phase != nullptr) ? phase->type(oop) : oop->bottom_type();\n@@ -610,1 +610,1 @@\n-    Node* field = NULL;\n+    Node* field = nullptr;\n@@ -628,1 +628,1 @@\n-    if (field != NULL) {\n+    if (field != nullptr) {\n@@ -662,1 +662,1 @@\n-        if (store != NULL) {\n+        if (store != nullptr) {\n@@ -707,1 +707,1 @@\n-    if (base != NULL && !phase->type(base)->maybe_null()) {\n+    if (base != nullptr && !phase->type(base)->maybe_null()) {\n@@ -723,1 +723,1 @@\n-        if (alloc != NULL && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n@@ -726,1 +726,1 @@\n-          if (res != NULL && res->is_CheckCastPP()) {\n+          if (res != nullptr && res->is_CheckCastPP()) {\n@@ -737,1 +737,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -741,1 +741,1 @@\n-  \/\/ Create a new InlineTypeNode with uninitialized values and NULL oop\n+  \/\/ Create a new InlineTypeNode with uninitialized values and nullptr oop\n@@ -828,1 +828,1 @@\n-  InlineTypeNode* vt = NULL;\n+  InlineTypeNode* vt = nullptr;\n@@ -853,1 +853,1 @@\n-      InlineTypeNode* null_vt = NULL;\n+      InlineTypeNode* null_vt = nullptr;\n@@ -879,1 +879,1 @@\n-\/\/           AllocateNode::Ideal_allocation(oop, &gvn) != NULL || vt->as_InlineType()->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n+\/\/           AllocateNode::Ideal_allocation(oop, &gvn) != nullptr || vt->as_InlineType()->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n@@ -917,1 +917,1 @@\n-  vt->initialize_fields(kit, multi, base_input, in, null_free, NULL, visited);\n+  vt->initialize_fields(kit, multi, base_input, in, null_free, nullptr, visited);\n@@ -933,1 +933,1 @@\n-    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, true);\n+    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n@@ -950,1 +950,1 @@\n-  Node* mark = kit->make_load(NULL, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  Node* mark = kit->make_load(nullptr, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n@@ -957,1 +957,1 @@\n-  assert(alloc != NULL, \"must have an allocation node\");\n+  assert(alloc != nullptr, \"must have an allocation node\");\n@@ -978,1 +978,1 @@\n-  return alloc != NULL && alloc->_larval;\n+  return alloc != nullptr && alloc->_larval;\n@@ -982,1 +982,1 @@\n-  if (vk == NULL) {\n+  if (vk == nullptr) {\n@@ -992,1 +992,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1005,2 +1005,2 @@\n-        if (base == NULL) {\n-          return NULL;\n+        if (base == nullptr) {\n+          return nullptr;\n@@ -1025,3 +1025,3 @@\n-      if (lbase == NULL || (lbase != base && base != NULL) || loffset != offset) {\n-        return NULL;\n-      } else if (base == NULL) {\n+      if (lbase == nullptr || (lbase != base && base != nullptr) || loffset != offset) {\n+        return nullptr;\n+      } else if (base == nullptr) {\n@@ -1031,2 +1031,2 @@\n-        if (vtptr == NULL || !vtptr->instance_klass()->equals(vk)) {\n-          return NULL;\n+        if (vtptr == nullptr || !vtptr->instance_klass()->equals(vk)) {\n+          return nullptr;\n@@ -1036,1 +1036,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1080,1 +1080,1 @@\n-  Node* is_init = NULL;\n+  Node* is_init = nullptr;\n@@ -1094,2 +1094,2 @@\n-    assert(null_check_region == NULL, \"already set\");\n-    if (is_init == NULL) {\n+    assert(null_check_region == nullptr, \"already set\");\n+    if (is_init == nullptr) {\n@@ -1112,1 +1112,1 @@\n-    Node* parm = NULL;\n+    Node* parm = nullptr;\n@@ -1129,1 +1129,1 @@\n-        if (null_check_region != NULL) {\n+        if (null_check_region != nullptr) {\n@@ -1133,1 +1133,1 @@\n-          \/\/ Holder is nullable, set field to NULL if holder is NULL to avoid loading from uninitialized memory\n+          \/\/ Holder is nullable, set field to nullptr if holder is nullptr to avoid loading from uninitialized memory\n@@ -1149,2 +1149,2 @@\n-    assert(parm != NULL, \"should never be null\");\n-    assert(field_value(i) == NULL, \"already set\");\n+    assert(parm != nullptr, \"should never be null\");\n+    assert(field_value(i) == nullptr, \"already set\");\n@@ -1174,1 +1174,1 @@\n-    if (alloc != NULL && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n@@ -1176,1 +1176,1 @@\n-      if (res == NULL || !res->is_CheckCastPP()) {\n+      if (res == nullptr || !res->is_CheckCastPP()) {\n@@ -1184,1 +1184,1 @@\n-        if (alloc_other != NULL && alloc_other->in(AllocateNode::InlineType) == this && !alloc_other->_is_scalar_replaceable) {\n+        if (alloc_other != nullptr && alloc_other->in(AllocateNode::InlineType) == this && !alloc_other->_is_scalar_replaceable) {\n@@ -1186,1 +1186,1 @@\n-          if (res_other != NULL && res_other->is_CheckCastPP() && res_other != res_dom &&\n+          if (res_other != nullptr && res_other->is_CheckCastPP() && res_other != res_dom &&\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":59,"deletions":59,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-         IsBuffered, \/\/ True if inline type is heap allocated (or NULL), false otherwise.\n-         IsInit,     \/\/ Needs to be checked for NULL before using the field values.\n+         IsBuffered, \/\/ True if inline type is heap allocated (or nullptr), false otherwise.\n+         IsInit,     \/\/ Needs to be checked for nullptr before using the field values.\n@@ -67,1 +67,1 @@\n-  Node* is_loaded(PhaseGVN* phase, ciInlineKlass* vk = NULL, Node* base = NULL, int holder_offset = 0);\n+  Node* is_loaded(PhaseGVN* phase, ciInlineKlass* vk = nullptr, Node* base = nullptr, int holder_offset = 0);\n@@ -87,1 +87,1 @@\n-  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = NULL, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n@@ -126,1 +126,1 @@\n-  void store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = NULL, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n+  void store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -710,1 +710,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1417,1 +1417,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -1421,1 +1421,1 @@\n-  assert(obj != NULL && addr->in(AddPNode::Base) == addr->in(AddPNode::Address), \"malformed AddP?\");\n+  assert(obj != nullptr && addr->in(AddPNode::Base) == addr->in(AddPNode::Address), \"malformed AddP?\");\n@@ -1438,1 +1438,1 @@\n-      assert(cast->Opcode() == Op_CastPP && cast->in(0) != NULL, \"inconsistent subgraph\");\n+      assert(cast->Opcode() == Op_CastPP && cast->in(0) != nullptr, \"inconsistent subgraph\");\n@@ -2055,1 +2055,1 @@\n-  const TypePtr* at = NULL;\n+  const TypePtr* at = nullptr;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-  if (entry_point() == NULL && idx == TypeFunc::Parms) {\n+  if (entry_point() == nullptr && idx == TypeFunc::Parms) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-      in(1) != NULL &&\n+      in(1) != nullptr &&\n@@ -205,1 +205,1 @@\n-      in(1)->in(1) != NULL &&\n+      in(1)->in(1) != nullptr &&\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-  void    do_if(BoolTest::mask btest, Node* c, bool new_path = false, Node** ctrl_taken = NULL);\n+  void    do_if(BoolTest::mask btest, Node* c, bool new_path = false, Node** ctrl_taken = nullptr);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-    ciKlass* array_type = NULL;\n-    ciKlass* element_type = NULL;\n+    ciKlass* array_type = nullptr;\n+    ciKlass* element_type = nullptr;\n@@ -65,1 +65,1 @@\n-    if (element_type != NULL || element_ptr != ProfileMaybeNull) {\n+    if (element_type != nullptr || element_ptr != ProfileMaybeNull) {\n@@ -138,1 +138,1 @@\n-        Node* call = NULL;\n+        Node* call = nullptr;\n@@ -149,1 +149,1 @@\n-                                   NULL, TypeRawPtr::BOTTOM,\n+                                   nullptr, TypeRawPtr::BOTTOM,\n@@ -180,1 +180,1 @@\n-  if (elemptr != NULL && elemptr->is_inlinetypeptr()) {\n+  if (elemptr != nullptr && elemptr->is_inlinetypeptr()) {\n@@ -193,1 +193,1 @@\n-  Node* cast_val = NULL;\n+  Node* cast_val = nullptr;\n@@ -236,1 +236,1 @@\n-      cast_val->as_InlineType()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      cast_val->as_InlineType()->store_flattened(this, ary, adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -246,1 +246,1 @@\n-      \/\/ Array might be flattened, emit runtime checks (for NULL, a simple inline_array_null_guard is sufficient).\n+      \/\/ Array might be flattened, emit runtime checks (for nullptr, a simple inline_array_null_guard is sufficient).\n@@ -272,1 +272,1 @@\n-        ciInlineKlass* vk = NULL;\n+        ciInlineKlass* vk = nullptr;\n@@ -279,1 +279,1 @@\n-        if (vk != NULL && !stopped()) {\n+        if (vk != nullptr && !stopped()) {\n@@ -294,1 +294,1 @@\n-          val->as_InlineType()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+          val->as_InlineType()->store_flattened(this, casted_ary, casted_adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -431,1 +431,1 @@\n-    if (too_many_traps_or_recompiles(reason) || array_type == NULL) {\n+    if (too_many_traps_or_recompiles(reason) || array_type == nullptr) {\n@@ -433,1 +433,1 @@\n-      array_type = NULL;\n+      array_type = nullptr;\n@@ -436,1 +436,1 @@\n-        ciKlass* element_type = NULL;\n+        ciKlass* element_type = nullptr;\n@@ -443,1 +443,1 @@\n-    if (array_type != NULL) {\n+    if (array_type != nullptr) {\n@@ -445,1 +445,1 @@\n-      Node* better_ary = NULL;\n+      Node* better_ary = nullptr;\n@@ -466,2 +466,2 @@\n-    ciKlass* array_type = NULL;\n-    ciKlass* element_type = NULL;\n+    ciKlass* array_type = nullptr;\n+    ciKlass* element_type = nullptr;\n@@ -472,1 +472,1 @@\n-    if (array_type != NULL) {\n+    if (array_type != nullptr) {\n@@ -485,1 +485,1 @@\n-    if (arytype->speculative() != NULL &&\n+    if (arytype->speculative() != nullptr &&\n@@ -491,2 +491,2 @@\n-      ciKlass* array_type = NULL;\n-      ciKlass* element_type = NULL;\n+      ciKlass* array_type = nullptr;\n+      ciKlass* element_type = nullptr;\n@@ -514,1 +514,1 @@\n-    if (arytype->speculative() != NULL &&\n+    if (arytype->speculative() != nullptr &&\n@@ -520,2 +520,2 @@\n-      ciKlass* array_type = NULL;\n-      ciKlass* element_type = NULL;\n+      ciKlass* array_type = nullptr;\n+      ciKlass* element_type = nullptr;\n@@ -1889,1 +1889,1 @@\n-        } else if (ctrl_taken != NULL) {\n+        } else if (ctrl_taken != nullptr) {\n@@ -1903,1 +1903,1 @@\n-  if (stopped() && ctrl_taken == NULL) {\n+  if (stopped() && ctrl_taken == nullptr) {\n@@ -1915,1 +1915,1 @@\n-  if (t->speculative() == NULL) {\n+  if (t->speculative() == nullptr) {\n@@ -1929,1 +1929,1 @@\n-  Node* cast = null_check_common(input, T_OBJECT, true, NULL,\n+  Node* cast = null_check_common(input, T_OBJECT, true, nullptr,\n@@ -1972,1 +1972,1 @@\n-    if (tinput->speculative_type() != NULL && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+    if (tinput->speculative_type() != nullptr && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n@@ -2038,2 +2038,2 @@\n-  ciKlass* left_type = NULL;\n-  ciKlass* right_type = NULL;\n+  ciKlass* left_type = nullptr;\n+  ciKlass* right_type = nullptr;\n@@ -2049,2 +2049,2 @@\n-      left_type = NULL;\n-      right_type = NULL;\n+      left_type = nullptr;\n+      right_type = nullptr;\n@@ -2106,2 +2106,2 @@\n-  if (tleft == NULL || !tleft->can_be_inline_type() ||\n-      tright == NULL || !tright->can_be_inline_type()) {\n+  if (tleft == nullptr || !tleft->can_be_inline_type() ||\n+      tright == nullptr || !tright->can_be_inline_type()) {\n@@ -2112,1 +2112,1 @@\n-  Node* eq_region = NULL;\n+  Node* eq_region = nullptr;\n@@ -2120,1 +2120,1 @@\n-    Node* is_not_equal = NULL;\n+    Node* is_not_equal = nullptr;\n@@ -2129,1 +2129,1 @@\n-    if (is_not_equal == NULL || is_not_equal->is_top()) {\n+    if (is_not_equal == nullptr || is_not_equal->is_top()) {\n@@ -2139,1 +2139,1 @@\n-    if (tleft->speculative_type() != NULL) {\n+    if (tleft->speculative_type() != nullptr) {\n@@ -2142,1 +2142,1 @@\n-    if (tright->speculative_type() != NULL) {\n+    if (tright->speculative_type() != nullptr) {\n@@ -2174,1 +2174,1 @@\n-  if (left_type != NULL && !left_type->is_inlinetype()) {\n+  if (left_type != nullptr && !left_type->is_inlinetype()) {\n@@ -2179,1 +2179,1 @@\n-  if (right_type != NULL && !right_type->is_inlinetype()) {\n+  if (right_type != nullptr && !right_type->is_inlinetype()) {\n@@ -2243,3 +2243,3 @@\n-  Node* eq_io_phi = NULL;\n-  Node* eq_mem_phi = NULL;\n-  if (eq_region != NULL) {\n+  Node* eq_io_phi = nullptr;\n+  Node* eq_mem_phi = nullptr;\n+  if (eq_region != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1444,1 +1444,1 @@\n-  assert(n != NULL, \"sanity\");\n+  assert(n != nullptr, \"sanity\");\n@@ -1718,2 +1718,2 @@\n-      } while (c != NULL && c->is_Region());\n-      if (c != NULL && c->is_CallStaticJava() && c->as_CallStaticJava()->uncommon_trap_request() != 0) {\n+      } while (c != nullptr && c->is_Region());\n+      if (c != nullptr && c->is_CallStaticJava() && c->as_CallStaticJava()->uncommon_trap_request() != 0) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -880,2 +880,2 @@\n-  Node* a = NULL;\n-  Node* b = NULL;\n+  Node* a = nullptr;\n+  Node* b = nullptr;\n@@ -912,2 +912,2 @@\n-  Node* a = NULL;\n-  Node* b = NULL;\n+  Node* a = nullptr;\n+  Node* b = nullptr;\n@@ -915,1 +915,1 @@\n-    \/\/ One operand is never NULL, emit constant false\n+    \/\/ One operand is never nullptr, emit constant false\n@@ -1230,1 +1230,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1411,1 +1411,1 @@\n-  return changed ? this : NULL;\n+  return changed ? this : nullptr;\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-  virtual const Type* sub(const Type*, const Type*) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type* sub(const Type*, const Type*) const { ShouldNotReachHere(); return nullptr; }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3876,1 +3876,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nullptrs down in the subarrays.\n@@ -3951,1 +3951,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nullptrs down in the subarrays.\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2146,1 +2146,1 @@\n-  assert(preload_classes != NULL, \"unexpected null preload_classes\");\n+  assert(preload_classes != nullptr, \"unexpected null preload_classes\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-    assert(_obj == NULL || !_obj->is_inline_type() || _obj->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n+    assert(_obj == nullptr || !_obj->is_inline_type() || _obj->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -779,1 +779,1 @@\n-      if (_f != NULL) {\n+      if (_f != nullptr) {\n@@ -793,1 +793,1 @@\n-        if (_f != NULL) {\n+        if (_f != nullptr) {\n@@ -970,1 +970,1 @@\n-  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f, NULL);\n+  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f, nullptr);\n@@ -992,1 +992,1 @@\n-  InterpreterFrameClosure blk(this, m->max_locals(), m->max_stack(), NULL, f);\n+  InterpreterFrameClosure blk(this, m->max_locals(), m->max_stack(), nullptr, f);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-    if (!ret && obj1 != NULL && obj2 != NULL && obj1->klass() == obj2->klass() && obj1->klass()->is_inline_klass()) {\n+    if (!ret && obj1 != nullptr && obj2 != nullptr && obj1->klass() == obj2->klass() && obj1->klass()->is_inline_klass()) {\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -950,1 +950,1 @@\n-    InlineKlass* vk = NULL;\n+    InlineKlass* vk = nullptr;\n@@ -955,1 +955,1 @@\n-      if (vk != NULL) {\n+      if (vk != nullptr) {\n@@ -987,1 +987,1 @@\n-    } else if (vk != NULL) {\n+    } else if (vk != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-  if (k != NULL && k->is_inline_klass()) {\n+  if (k != nullptr && k->is_inline_klass()) {\n@@ -517,1 +517,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1769,1 +1769,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1780,1 +1780,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -937,2 +937,2 @@\n-  PrintClassLayoutDCmd* dcmd = new PrintClassLayoutDCmd(NULL, false);\n-  if (dcmd != NULL) {\n+  PrintClassLayoutDCmd* dcmd = new PrintClassLayoutDCmd(nullptr, false);\n+  if (dcmd != nullptr) {\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1347,1 +1347,1 @@\n-\/\/ inlined_fields_id is not-NULL for inlined fields (to get synthetic field name IDs\n+\/\/ inlined_fields_id is not-nullptr for inlined fields (to get synthetic field name IDs\n@@ -1350,1 +1350,1 @@\n-  \/\/ inlined_fields_id != NULL means ik is a class of inlined field.\n+  \/\/ inlined_fields_id != nullptr means ik is a class of inlined field.\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-    return _array == NULL || _position == _array->end()._position;\n+    return _array == nullptr || _position == _array->end()._position;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-            anchorp = NULL;\n+            anchorp = nullptr;\n@@ -125,1 +125,1 @@\n-        if (anchorp != NULL) {\n+        if (anchorp != nullptr) {\n@@ -131,1 +131,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -153,1 +153,1 @@\n-    const char* matchp = string;  \/\/ NULL if failing\n+    const char* matchp = string;  \/\/ nullptr if failing\n@@ -171,1 +171,1 @@\n-        if (matchp != NULL) {\n+        if (matchp != nullptr) {\n@@ -204,1 +204,1 @@\n-      if (matchp != NULL) {\n+      if (matchp != nullptr) {\n@@ -207,1 +207,1 @@\n-          matchp = NULL;\n+          matchp = nullptr;\n@@ -282,1 +282,1 @@\n-  if (class_pattern_list == NULL || class_name == NULL || class_name[0] == '\\0')\n+  if (class_pattern_list == nullptr || class_name == nullptr || class_name[0] == '\\0')\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}