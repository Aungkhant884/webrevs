{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=valhalla\n@@ -7,5 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+error=author,committer,executable,symlink,whitespace\n@@ -21,7 +17,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n@@ -30,6 +19,0 @@\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1483,0 +1483,1 @@\n+        args = concat(args, \"--with-version-pre=\" + version_numbers.get(\"DEFAULT_PROMOTED_VERSION_PRE\"));\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=lworld4ea\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2256,0 +2256,1 @@\n+            case \"Preload\":\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -751,0 +751,1 @@\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libobjmonusage007 := $(NSK_JVMTI_AGENT_INCLUDES)\n@@ -1459,0 +1460,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage007 += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/constMethodFlags.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -273,0 +275,63 @@\n+void InterpreterMacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                                  Register t1, Register t2,\n+                                                  bool clear_fields, Label& alloc_failed) {\n+  MacroAssembler::allocate_instance(klass, new_obj, t1, t2, clear_fields, alloc_failed);\n+  {\n+    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0);\n+    \/\/ Trigger dtrace event for fastpath\n+    push(atos);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), new_obj);\n+    pop(atos);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n+                                                   Register field_index, Register field_offset,\n+                                                   Register temp, Register obj) {\n+  Label alloc_failed, empty_value, done;\n+  const Register src = field_offset;\n+  const Register alloc_temp = rscratch1;\n+  const Register dst_temp   = temp;\n+  assert_different_registers(obj, holder_klass, field_index, field_offset, dst_temp);\n+\n+  \/\/ Grab the inline field klass\n+  push(holder_klass);\n+  const Register field_klass = holder_klass;\n+  get_inline_type_field_klass(holder_klass, field_index, field_klass);\n+\n+  \/\/check for empty value klass\n+  test_klass_is_empty_inline_type(field_klass, dst_temp, empty_value);\n+\n+  \/\/ allocate buffer\n+  push(obj); \/\/ save holder\n+  allocate_instance(field_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n+\n+  \/\/ Have an oop instance buffer, copy into it\n+  data_for_oop(obj, dst_temp, field_klass);\n+  pop(alloc_temp);             \/\/ restore holder\n+  lea(src, Address(alloc_temp, field_offset));\n+  \/\/ call_VM_leaf, clobbers a few regs, save restore new obj\n+  push(obj);\n+  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, field_klass);\n+  pop(obj);\n+  pop(holder_klass);\n+  b(done);\n+\n+  bind(empty_value);\n+  get_empty_inline_type_oop(field_klass, dst_temp, obj);\n+  pop(holder_klass);\n+  b(done);\n+\n+  bind(alloc_failed);\n+  pop(obj);\n+  pop(holder_klass);\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+          obj, field_index, holder_klass);\n+\n+  bind(done);\n+\n+  \/\/ Ensure the stores to copy the inline field contents are visible\n+  \/\/ before any subsequent store that publishes this reference.\n+  membar(Assembler::StoreStore);\n+}\n+\n@@ -319,1 +384,2 @@\n-                                                  Label& ok_is_subtype) {\n+                                                  Label& ok_is_subtype,\n+                                                  bool profile) {\n@@ -325,1 +391,3 @@\n-  profile_typecheck(r2, Rsub_klass, r5); \/\/ blows r2, reloads r5\n+  if (profile) {\n+    profile_typecheck(r2, Rsub_klass, r5); \/\/ blows r2, reloads r5\n+  }\n@@ -331,1 +399,3 @@\n-  profile_typecheck_failed(r2); \/\/ blows r2\n+  if (profile) {\n+    profile_typecheck_failed(r2); \/\/ blows r2\n+  }\n@@ -692,0 +762,1 @@\n+\n@@ -711,0 +782,31 @@\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+    Label skip;\n+    test_oop_is_not_inline_type(r0, rscratch2, skip);\n+\n+    \/\/ Load fields from a buffered value with an inline class specific handler\n+    load_klass(rscratch1 \/*dst*\/, r0 \/*src*\/);\n+    ldr(rscratch1, Address(rscratch1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    ldr(rscratch1, Address(rscratch1, InlineKlass::unpack_handler_offset()));\n+    \/\/ Unpack handler can be null if inline type is not scalarizable in returns\n+    cbz(rscratch1, skip);\n+\n+    blr(rscratch1);\n+#ifdef ASSERT\n+    \/\/ TODO 8284443 Enable\n+    if (StressCallingConvention && false) {\n+      Label skip_stress;\n+      ldr(rscratch1, Address(rfp, frame::interpreter_frame_method_offset * wordSize));\n+      ldrw(rscratch1, Address(rscratch1, Method::flags_offset()));\n+      tstw(rscratch1, ConstMethodFlags::has_scalarized_return_flag());\n+      br(Assembler::EQ, skip_stress);\n+      load_klass(r0, r0);\n+      orr(r0, r0, 1);\n+      bind(skip_stress);\n+    }\n+#endif\n+    bind(skip);\n+    \/\/ Check above kills sender esp in rscratch2. Reload it.\n+    ldr(rscratch2, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+  }\n+\n@@ -770,0 +872,4 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        andr(swap_reg, swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+      }\n@@ -1144,1 +1250,1 @@\n-void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp) {\n+void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp, bool acmp) {\n@@ -1156,1 +1262,1 @@\n-    update_mdp_by_constant(mdp, in_bytes(BranchData::branch_data_size()));\n+    update_mdp_by_constant(mdp, acmp ? in_bytes(ACmpData::acmp_data_size()) : in_bytes(BranchData::branch_data_size()));\n@@ -1520,0 +1626,79 @@\n+void InterpreterMacroAssembler::profile_array(Register mdp,\n+                                              Register array,\n+                                              Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, array);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::array_offset())));\n+\n+    Label not_flat;\n+    test_non_flattened_array_oop(array, tmp, not_flat);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::flat_array_byte_constant());\n+\n+    bind(not_flat);\n+\n+    Label not_null_free;\n+    test_non_null_free_array_oop(array, tmp, not_null_free);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::null_free_array_byte_constant());\n+\n+    bind(not_null_free);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_element(Register mdp,\n+                                                Register element,\n+                                                Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, element);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::element_offset())));\n+\n+    \/\/ The method data pointer needs to be updated.\n+    update_mdp_by_constant(mdp, in_bytes(ArrayLoadStoreData::array_load_store_data_size()));\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_acmp(Register mdp,\n+                                             Register left,\n+                                             Register right,\n+                                             Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, left);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::left_offset())));\n+\n+    Label left_not_inline_type;\n+    test_oop_is_not_inline_type(left, tmp, left_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::left_inline_type_byte_constant());\n+    bind(left_not_inline_type);\n+\n+    mov(tmp, right);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::right_offset())));\n+\n+    Label right_not_inline_type;\n+    test_oop_is_not_inline_type(right, tmp, right_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::right_inline_type_byte_constant());\n+    bind(right_not_inline_type);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n@@ -1770,1 +1955,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n@@ -1816,1 +2001,1 @@\n-    Address mdo_ret_addr(mdp, -in_bytes(ReturnTypeEntry::size()));\n+    Address mdo_ret_addr(mdp, -in_bytes(SingleTypeEntry::size()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":192,"deletions":7,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -471,0 +472,5 @@\n+\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    __ store_inline_type_fields_to_buf(NULL, true);\n+  }\n+\n@@ -585,0 +591,1 @@\n+  case T_PRIMITIVE_OBJECT: \/\/ fall through (value types are handled with oops)\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+  case Bytecodes::_fast_qputfield:\n@@ -332,0 +333,1 @@\n+  __ andr(r3, r3, ~JVM_CONSTANT_QDescBit);\n@@ -747,4 +749,4 @@\n-    \/\/ ??? convention: move array into r3 for exception message\n-  __ mov(r3, array);\n-  __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n-  __ br(rscratch1);\n+  \/\/ ??? convention: move array into r3 for exception message\n+   __ mov(r3, array);\n+   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n+   __ br(rscratch1);\n@@ -810,5 +812,17 @@\n-  __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n-  do_oop_load(_masm,\n-              Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),\n-              r0,\n-              IS_ARRAY);\n+  __ profile_array(r2, r0, r4);\n+  if (UseFlatArray) {\n+    Label is_flat_array, done;\n+\n+    __ test_flattened_array_oop(r0, r8 \/*temp*\/, is_flat_array);\n+    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n+    do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);\n+\n+    __ b(done);\n+    __ bind(is_flat_array);\n+    __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), r0, r1);\n+    __ bind(done);\n+  } else {\n+    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n+    do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);\n+  }\n+  __ profile_element(r2, r0, r4);\n@@ -1101,1 +1115,1 @@\n-  Label is_null, ok_is_subtype, done;\n+  Label is_null, is_flat_array, ok_is_subtype, done;\n@@ -1108,2 +1122,4 @@\n-  Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));\n-\n+\n+  __ profile_array(r4, r3, r5);\n+  __ profile_element(r4, r0, r5);\n+\n@@ -1112,0 +1128,2 @@\n+  Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));\n+  \/\/ Be careful not to clobber r4 below\n@@ -1116,0 +1134,8 @@\n+  \/\/ Move array class to r5\n+  __ load_klass(r5, r3);\n+\n+  if (UseFlatArray) {\n+    __ ldrw(r6, Address(r5, Klass::layout_helper_offset()));\n+    __ test_flattened_array_layout(r6, is_flat_array);\n+  }\n+\n@@ -1118,4 +1144,3 @@\n-  \/\/ Move superklass into r0\n-  __ load_klass(r0, r3);\n-  __ ldr(r0, Address(r0,\n-                     ObjArrayKlass::element_klass_offset()));\n+\n+  \/\/ Move array element superklass into r0\n+  __ ldr(r0, Address(r5, ObjArrayKlass::element_klass_offset()));\n@@ -1126,1 +1151,3 @@\n-  __ gen_subtype_check(r1, ok_is_subtype);\n+\n+  \/\/ is \"r1 <: r0\" ? (value subclass <: array element superclass)\n+  __ gen_subtype_check(r1, ok_is_subtype, false);\n@@ -1143,1 +1170,12 @@\n-  __ profile_null_seen(r2);\n+  if (EnablePrimitiveClasses) {\n+    Label is_null_into_value_array_npe, store_null;\n+\n+    \/\/ No way to store null in flat null-free array\n+    __ test_null_free_array_oop(r3, r8, is_null_into_value_array_npe);\n+    __ b(store_null);\n+\n+    __ bind(is_null_into_value_array_npe);\n+    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+\n+    __ bind(store_null);\n+  }\n@@ -1147,0 +1185,41 @@\n+  __ b(done);\n+\n+  if (UseFlatArray) {\n+     Label is_type_ok;\n+    __ bind(is_flat_array); \/\/ Store non-null value to flat\n+\n+    \/\/ Simplistic type check...\n+    \/\/ r0 - value, r2 - index, r3 - array.\n+\n+    \/\/ Profile the not-null value's klass.\n+    \/\/ Load value class\n+     __ load_klass(r1, r0);\n+\n+    \/\/ Move element klass into r7\n+     __ ldr(r7, Address(r5, ArrayKlass::element_klass_offset()));\n+\n+    \/\/ flat value array needs exact type match\n+    \/\/ is \"r1 == r7\" (value subclass == array element superclass)\n+\n+     __ cmp(r7, r1);\n+     __ br(Assembler::EQ, is_type_ok);\n+\n+     __ b(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n+\n+     __ bind(is_type_ok);\n+    \/\/ r1: value's klass\n+    \/\/ r3: array\n+    \/\/ r5: array klass\n+    __ test_klass_is_empty_inline_type(r1, r7, done);\n+\n+    \/\/ calc dst for copy\n+    __ ldrw(r7, at_tos_p1()); \/\/ index\n+    __ data_for_value_array_index(r3, r5, r7, r7);\n+\n+    \/\/ ...and src for copy\n+    __ ldr(r6, at_tos());  \/\/ value\n+    __ data_for_oop(r6, r6, r1);\n+\n+    __ mov(r4, r1);  \/\/ Shuffle arguments to avoid conflict with c_rarg1\n+    __ access_value_copy(IN_HEAP, r6, r7, r4);\n+  }\n@@ -1951,2 +2030,1 @@\n-void TemplateTable::if_acmp(Condition cc)\n-{\n+void TemplateTable::if_acmp(Condition cc) {\n@@ -1955,1 +2033,1 @@\n-  Label not_taken;\n+  Label taken, not_taken;\n@@ -1957,0 +2035,38 @@\n+\n+  __ profile_acmp(r2, r1, r0, r4);\n+\n+  Register is_inline_type_mask = rscratch1;\n+  __ mov(is_inline_type_mask, markWord::inline_type_pattern);\n+\n+  if (EnableValhalla) {\n+    __ cmp(r1, r0);\n+    __ br(Assembler::EQ, (cc == equal) ? taken : not_taken);\n+\n+    \/\/ might be substitutable, test if either r0 or r1 is null\n+    __ andr(r2, r0, r1);\n+    __ cbz(r2, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ and both are values ?\n+    __ ldr(r2, Address(r1, oopDesc::mark_offset_in_bytes()));\n+    __ andr(r2, r2, is_inline_type_mask);\n+    __ ldr(r4, Address(r0, oopDesc::mark_offset_in_bytes()));\n+    __ andr(r4, r4, is_inline_type_mask);\n+    __ andr(r2, r2, r4);\n+    __ cmp(r2,  is_inline_type_mask);\n+    __ br(Assembler::NE, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ same value klass ?\n+    __ load_metadata(r2, r1);\n+    __ load_metadata(r4, r0);\n+    __ cmp(r2, r4);\n+    __ br(Assembler::NE, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ Know both are the same type, let's test for substitutability...\n+    if (cc == equal) {\n+      invoke_is_substitutable(r0, r1, taken, not_taken);\n+    } else {\n+      invoke_is_substitutable(r0, r1, not_taken, taken);\n+    }\n+    __ stop(\"Not reachable\");\n+  }\n+\n@@ -1959,0 +2075,1 @@\n+  __ bind(taken);\n@@ -1961,1 +2078,10 @@\n-  __ profile_not_taken_branch(r0);\n+  __ profile_not_taken_branch(r0, true);\n+}\n+\n+void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,\n+                                            Label& is_subst, Label& not_subst) {\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);\n+  \/\/ Restored... r0 answer, jmp to outcome...\n+  __ cbz(r0, not_subst);\n+  __ b(is_subst);\n@@ -1964,0 +2090,1 @@\n+\n@@ -2295,1 +2422,1 @@\n-                                          ConstantPoolCacheEntry::f2_offset())));\n+                                      ConstantPoolCacheEntry::f2_offset())));\n@@ -2298,1 +2425,1 @@\n-                                           ConstantPoolCacheEntry::flags_offset())));\n+                                         ConstantPoolCacheEntry::flags_offset())));\n@@ -2465,0 +2592,2 @@\n+  const Register klass = r5;\n+  const Register inline_klass = r7;\n@@ -2497,0 +2626,5 @@\n+  if (!is_static) {\n+    __ ldr(klass, Address(cache, in_bytes(ConstantPoolCache::base_offset() +\n+                                          ConstantPoolCacheEntry::f1_offset())));\n+  }\n+\n@@ -2499,2 +2633,1 @@\n-  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,\n-           ConstantPoolCacheEntry::tos_state_bits);\n+  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift, ConstantPoolCacheEntry::tos_state_bits);\n@@ -2535,4 +2668,70 @@\n-  do_oop_load(_masm, field, r0, IN_HEAP);\n-  __ push(atos);\n-  if (rc == may_rewrite) {\n-    patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+  if (!EnablePrimitiveClasses) {\n+    do_oop_load(_masm, field, r0, IN_HEAP);\n+    __ push(atos);\n+    if (rc == may_rewrite) {\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+    }\n+    __ b(Done);\n+  } else { \/\/ Valhalla\n+    if (is_static) {\n+      __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+      Label is_null_free_inline_type, uninitialized;\n+      \/\/ Issue below if the static field has not been initialized yet\n+      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_null_free_inline_type);\n+        \/\/ field is not a null free inline type\n+        __ push(atos);\n+        __ b(Done);\n+      \/\/ field is a null free inline type, must not return null even if uninitialized\n+      __ bind(is_null_free_inline_type);\n+        __ cbz(r0, uninitialized);\n+          __ push(atos);\n+          __ b(Done);\n+        __ bind(uninitialized);\n+          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+          Label slow_case, finish;\n+          __ ldrb(rscratch1, Address(cache, InstanceKlass::init_state_offset()));\n+          __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);\n+          __ br(Assembler::NE, slow_case);\n+          __ get_default_value_oop(klass, off \/* temp *\/, r0);\n+        __ b(finish);\n+        __ bind(slow_case);\n+          __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, raw_flags);\n+          __ bind(finish);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+          __ b(Done);\n+    } else {\n+      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_inline_type);\n+        \/\/ Non-inline field case\n+        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+        __ push(atos);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+        }\n+        __ b(Done);\n+      __ bind(is_inline_type);\n+        __ test_field_is_inlined(raw_flags, noreg \/* temp *\/, is_inlined);\n+         \/\/ field is not inlined\n+          __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+          __ cbnz(r0, nonnull);\n+            __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+            __ get_inline_type_field_klass(klass, raw_flags, inline_klass);\n+            __ get_default_value_oop(inline_klass, klass \/* temp *\/, r0);\n+          __ bind(nonnull);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+          __ b(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+          __ mov(r0, obj);\n+          __ read_inlined_field(klass, raw_flags, off, inline_klass \/* temp *\/, r0);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+      __ bind(rewrite_inline);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);\n+      }\n+      __ b(Done);\n+    }\n@@ -2540,1 +2739,0 @@\n-  __ b(Done);\n@@ -2710,0 +2908,1 @@\n+  const Register flags2 = r6;\n@@ -2711,0 +2910,1 @@\n+  const Register inline_klass = r5;\n@@ -2732,0 +2932,2 @@\n+  __ mov(flags2, flags);\n+\n@@ -2774,8 +2976,54 @@\n-    __ pop(atos);\n-    if (!is_static) pop_and_check_object(obj);\n-    \/\/ Store into the field\n-    do_oop_store(_masm, field, r0, IN_HEAP);\n-    if (rc == may_rewrite) {\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);\n-    }\n-    __ b(Done);\n+     if (!EnablePrimitiveClasses) {\n+      __ pop(atos);\n+      if (!is_static) pop_and_check_object(obj);\n+      \/\/ Store into the field\n+      do_oop_store(_masm, field, r0, IN_HEAP);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);\n+      }\n+      __ b(Done);\n+     } else { \/\/ Valhalla\n+      __ pop(atos);\n+      if (is_static) {\n+        Label is_inline_type;\n+         __ test_field_is_not_null_free_inline_type(flags2, noreg \/* temp *\/, is_inline_type);\n+         __ null_check(r0);\n+         __ bind(is_inline_type);\n+         do_oop_store(_masm, field, r0, IN_HEAP);\n+         __ b(Done);\n+      } else {\n+        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        __ test_field_is_null_free_inline_type(flags2, noreg \/*temp*\/, is_inline_type);\n+        \/\/ Not an inline type\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, r0, IN_HEAP);\n+        __ bind(rewrite_not_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, r19, true, byte_no);\n+        }\n+        __ b(Done);\n+        \/\/ Implementation of the inline type semantic\n+        __ bind(is_inline_type);\n+        __ null_check(r0);\n+        __ test_field_is_inlined(flags2, noreg \/*temp*\/, is_inlined);\n+        \/\/ field is not inlined\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, r0, IN_HEAP);\n+        __ b(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+        pop_and_check_object(obj);\n+        assert_different_registers(r0, inline_klass, obj, off);\n+        __ load_klass(inline_klass, r0);\n+        __ data_for_oop(r0, r0, inline_klass);\n+        __ add(obj, obj, off);\n+        __ access_value_copy(IN_HEAP, r0, obj, inline_klass);\n+        __ bind(rewrite_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_qputfield, bc, r19, true, byte_no);\n+        }\n+        __ b(Done);\n+      }\n+     }  \/\/ Valhalla\n@@ -2921,0 +3169,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -2947,0 +3196,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -3000,0 +3250,17 @@\n+  case Bytecodes::_fast_qputfield: \/\/fall through\n+   {\n+      Label is_inlined, done;\n+      __ null_check(r0);\n+      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n+      \/\/ field is not inlined\n+      do_oop_store(_masm, field, r0, IN_HEAP);\n+      __ b(done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+      __ load_klass(r4, r0);\n+      __ data_for_oop(r0, r0, r4);\n+      __ lea(rscratch1, field);\n+      __ access_value_copy(IN_HEAP, r0, rscratch1, r4);\n+      __ bind(done);\n+    }\n+    break;\n@@ -3097,0 +3364,26 @@\n+  case Bytecodes::_fast_qgetfield:\n+    {\n+      Register index = r4, klass = r5, inline_klass = r6, tmp = r7;\n+      Label is_inlined, nonnull, Done;\n+      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n+        \/\/ field is not inlined\n+        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+        __ cbnz(r0, nonnull);\n+          __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n+          __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n+                                             ConstantPoolCacheEntry::f1_offset())));\n+          __ get_inline_type_field_klass(klass, index, inline_klass);\n+          __ get_default_value_oop(inline_klass, tmp \/* temp *\/, r0);\n+        __ bind(nonnull);\n+        __ verify_oop(r0);\n+        __ b(Done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+        __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n+        __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n+                                           ConstantPoolCacheEntry::f1_offset())));\n+        __ read_inlined_field(klass, index, r1, tmp \/* temp *\/, r0);\n+        __ verify_oop(r0);\n+      __ bind(Done);\n+    }\n+    break;\n@@ -3524,0 +3817,1 @@\n+  Label is_not_value;\n@@ -3540,0 +3834,8 @@\n+  __ ldrb(rscratch1, Address(r4, InstanceKlass::kind_offset()));\n+  __ cmp(rscratch1, (u1)Klass::InlineKlassKind);\n+  __ br(Assembler::NE, is_not_value);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n+\n+  __ bind(is_not_value);\n+\n@@ -3546,57 +3848,2 @@\n-  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n-  __ ldrw(r3,\n-          Address(r4,\n-                  Klass::layout_helper_offset()));\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n-  __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);\n-\n-  \/\/ Allocate the instance:\n-  \/\/  If TLAB is enabled:\n-  \/\/    Try to allocate in the TLAB.\n-  \/\/    If fails, go to the slow path.\n-  \/\/    Initialize the allocation.\n-  \/\/    Exit.\n-  \/\/\n-  \/\/  Go to slow path.\n-\n-  if (UseTLAB) {\n-    __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);\n-\n-    if (ZeroTLAB) {\n-      \/\/ the fields have been already cleared\n-      __ b(initialize_header);\n-    }\n-\n-    \/\/ The object is initialized before the header.  If the object size is\n-    \/\/ zero, go directly to the header initialization.\n-    __ sub(r3, r3, sizeof(oopDesc));\n-    __ cbz(r3, initialize_header);\n-\n-    \/\/ Initialize object fields\n-    {\n-      __ add(r2, r0, sizeof(oopDesc));\n-      Label loop;\n-      __ bind(loop);\n-      __ str(zr, Address(__ post(r2, BytesPerLong)));\n-      __ sub(r3, r3, BytesPerLong);\n-      __ cbnz(r3, loop);\n-    }\n-\n-    \/\/ initialize object header only.\n-    __ bind(initialize_header);\n-    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n-    __ store_klass_gap(r0, zr);  \/\/ zero klass gap for compressed oops\n-    __ store_klass(r0, r4);      \/\/ store klass last\n-\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false);\n-      \/\/ Trigger dtrace event for fastpath\n-      __ push(atos); \/\/ save the return value\n-      __ call_VM_leaf(\n-           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), r0);\n-      __ pop(atos); \/\/ restore the return value\n-\n-    }\n-    __ b(done);\n-  }\n+  __ allocate_instance(r4, r0, r3, r1, true, slow_case);\n+  __ b(done);\n@@ -3617,0 +3864,29 @@\n+void TemplateTable::aconst_init() {\n+  transition(vtos, atos);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  __ get_constant_pool(c_rarg1);\n+  call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n+          c_rarg1, c_rarg2);\n+  __ verify_oop(r0);\n+  \/\/ Must prevent reordering of stores for object initialization with stores that publish the new object.\n+  __ membar(Assembler::StoreStore);\n+}\n+\n+void TemplateTable::withfield() {\n+  transition(vtos, atos);\n+  resolve_cache_and_index(f2_byte, c_rarg1 \/*cache*\/, c_rarg2 \/*index*\/, sizeof(u2));\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  \/\/ n.b. unlike x86 cache is now rcpool plus the indexed offset\n+  __ lea(c_rarg1, Address(c_rarg1, in_bytes(cp_base_offset)));\n+\n+  __ lea(c_rarg2, at_tos());\n+  call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), c_rarg1, c_rarg2);\n+  \/\/ new value type is returned in r1\n+  \/\/ stack adjustment is returned in r0\n+  __ verify_oop(r1);\n+  __ add(esp, esp, r0);\n+  __ mov(r0, r1);\n+}\n+\n@@ -3656,0 +3932,1 @@\n+  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -3687,0 +3964,3 @@\n+  __ b(done);\n+  __ bind(is_null);\n+\n@@ -3689,4 +3969,16 @@\n-    __ b(done);\n-    __ bind(is_null);\n-  } else {\n-    __ bind(is_null);   \/\/ same as 'done'\n+\n+  if (EnablePrimitiveClasses) {\n+    \/\/ Get cpool & tags index\n+    __ get_cpool_and_tags(r2, r3); \/\/ r2=cpool, r3=tags array\n+    __ get_unsigned_2_byte_index_at_bcp(r19, 1); \/\/ r19=index\n+     \/\/ See if bytecode has already been quicked\n+    __ add(rscratch1, r3, Array<u1>::base_offset_in_bytes());\n+    __ lea(r1, Address(rscratch1, r19));\n+    __ ldarb(r1, r1);\n+    \/\/ See if CP entry is a Q-descriptor\n+    __ andr (r1, r1, JVM_CONSTANT_QDescBit);\n+    __ cmp(r1, (u1) JVM_CONSTANT_QDescBit);\n+    __ br(Assembler::NE, done);\n+    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+  }\n+\n@@ -3710,0 +4002,1 @@\n+  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -3813,0 +4106,4 @@\n+  Label is_inline_type;\n+  __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+  __ test_markword_is_inline_type(rscratch1, is_inline_type);\n+\n@@ -3906,0 +4203,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -3916,0 +4218,12 @@\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  Label has_identity;\n+  __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+  __ mov(rscratch2, is_inline_type_mask);\n+  __ andr(rscratch1, rscratch1, rscratch2);\n+  __ cmp(rscratch1, rscratch2);\n+  __ br(Assembler::NE, has_identity);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n+  __ bind(has_identity);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":414,"deletions":100,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -1867,1 +1867,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n@@ -1908,1 +1908,1 @@\n-    profile_obj_type(ret, R28_mdx, -in_bytes(ReturnTypeEntry::size()), tmp1, tmp2);\n+    profile_obj_type(ret, R28_mdx, -in_bytes(SingleTypeEntry::size()), tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1776,1 +1776,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n@@ -1825,1 +1825,1 @@\n-    Address mdo_ret_addr(mdp, -in_bytes(ReturnTypeEntry::size()));\n+    Address mdo_ret_addr(mdp, -in_bytes(SingleTypeEntry::size()));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -119,0 +120,13 @@\n+void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr& tmp1, LIR_Opr& tmp2) {\n+  \/\/ We just need one 32-bit temp register for x86\/x64, to check whether both\n+  \/\/ oops have markWord::always_locked_pattern. See LIR_Assembler::emit_opSubstitutabilityCheck().\n+  \/\/ @temp = %r10d\n+  \/\/ mov $0x405, %r10d\n+  \/\/ and (%left), %r10d   \/* if need to check left *\/\n+  \/\/ and (%right), %r10d  \/* if need to check right *\/\n+  \/\/ cmp $0x405, $r10d\n+  \/\/ jne L_oops_not_equal\n+  tmp1 = new_register(T_INT);\n+  tmp2 = LIR_OprFact::illegalOpr;\n+}\n+\n@@ -314,0 +328,6 @@\n+  \/\/ Need a scratch register for inline types on x86\n+  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n+  if ((LockingMode == LM_LIGHTWEIGHT) ||\n+      (EnableValhalla && x->maybe_inlinetype())) {\n+    scratch = new_register(T_ADDRESS);\n+  }\n@@ -319,0 +339,6 @@\n+\n+  CodeStub* throw_imse_stub = x->maybe_inlinetype() ?\n+      new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id,\n+                              LIR_OprFact::illegalOpr, state_for(x))\n+    : nullptr;\n+\n@@ -322,3 +348,2 @@\n-  LIR_Opr tmp = LockingMode == LM_LIGHTWEIGHT ? new_register(T_ADDRESS) : LIR_OprFact::illegalOpr;\n-  monitor_enter(obj.result(), lock, syncTempOpr(), tmp,\n-                        x->monitor_no(), info_for_exception, info);\n+  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+                x->monitor_no(), info_for_exception, info, throw_imse_stub);\n@@ -1300,5 +1325,6 @@\n-                       FrameMap::rcx_oop_opr,\n-                       FrameMap::rdi_oop_opr,\n-                       FrameMap::rsi_oop_opr,\n-                       LIR_OprFact::illegalOpr,\n-                       FrameMap::rdx_metadata_opr, info);\n+               \/* allow_inline *\/ false,\n+               FrameMap::rcx_oop_opr,\n+               FrameMap::rdi_oop_opr,\n+               FrameMap::rsi_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::rdx_metadata_opr, info);\n@@ -1309,0 +1335,15 @@\n+void LIRGenerator::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n+  \/\/ Mapping to do_NewInstance (same code) but use state_before for reexecution.\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+  x->set_to_object_type();\n+  LIR_Opr reg = result_register_for(x->type());\n+  new_instance(reg, x->klass(), false,\n+               \/* allow_inline *\/ true,\n+               FrameMap::rcx_oop_opr,\n+               FrameMap::rdi_oop_opr,\n+               FrameMap::rsi_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::rdx_metadata_opr, info);\n+  LIR_Opr result = rlock_result(x);\n+  __ move(reg, result);\n+}\n@@ -1356,2 +1397,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);\n-  ciKlass* obj = (ciKlass*) ciObjArrayKlass::make(x->klass());\n+  ciKlass* obj = (ciKlass*) x->exact_type();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n@@ -1362,1 +1403,5 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n+  if (x->is_null_free()) {\n+    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_PRIMITIVE_OBJECT, klass_reg, slow_path);\n+  } else {\n+    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n+  }\n@@ -1441,0 +1486,4 @@\n+  if (x->is_null_free()) {\n+    __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));\n+  }\n+\n@@ -1459,1 +1508,1 @@\n-               x->profiled_method(), x->profiled_bci());\n+               x->profiled_method(), x->profiled_bci(), x->is_null_free());\n@@ -1510,1 +1559,1 @@\n-  } else if (tag == longTag || tag == floatTag || tag == doubleTag) {\n+  } else if (tag == longTag || tag == floatTag || tag == doubleTag || x->substitutability_check()) {\n@@ -1530,1 +1579,5 @@\n-  __ cmp(lir_cond(cond), left, right);\n+  if (x->substitutability_check()) {\n+    substitutability_check(x, *xin, *yin);\n+  } else {\n+    __ cmp(lir_cond(cond), left, right);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":67,"deletions":14,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/constMethodFlags.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -154,1 +156,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), \"can't move past ret type\");\n@@ -199,1 +201,1 @@\n-    Address mdo_ret_addr(mdp, -in_bytes(ReturnTypeEntry::size()));\n+    Address mdo_ret_addr(mdp, -in_bytes(SingleTypeEntry::size()));\n@@ -559,1 +561,2 @@\n-                                                  Label& ok_is_subtype) {\n+                                                  Label& ok_is_subtype,\n+                                                  bool profile) {\n@@ -567,1 +570,3 @@\n-  profile_typecheck(rcx, Rsub_klass, rdi); \/\/ blows rcx, reloads rdi\n+  if (profile) {\n+    profile_typecheck(rcx, Rsub_klass, rdi); \/\/ blows rcx, reloads rdi\n+  }\n@@ -573,1 +578,3 @@\n-  profile_typecheck_failed(rcx); \/\/ blows rcx\n+  if (profile) {\n+    profile_typecheck_failed(rcx); \/\/ blows rcx\n+  }\n@@ -1019,1 +1026,1 @@\n- \/\/ get method access flags\n+  \/\/ get method access flags\n@@ -1143,4 +1150,2 @@\n-  \/\/ remove activation\n-  \/\/ get sender sp\n-  movptr(rbx,\n-         Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    movptr(rbx,\n+               Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -1168,0 +1173,40 @@\n+\n+  \/\/ remove activation\n+  \/\/ get sender sp\n+  movptr(rbx,\n+         Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+    Label skip;\n+    test_oop_is_not_inline_type(rax, rscratch1, skip);\n+\n+#ifndef _LP64\n+    super_call_VM_leaf(StubRoutines::load_inline_type_fields_in_regs());\n+#else\n+    \/\/ Load fields from a buffered value with an inline class specific handler\n+    load_klass(rdi, rax, rscratch1);\n+    movptr(rdi, Address(rdi, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    movptr(rdi, Address(rdi, InlineKlass::unpack_handler_offset()));\n+    \/\/ Unpack handler can be null if inline type is not scalarizable in returns\n+    testptr(rdi, rdi);\n+    jcc(Assembler::zero, skip);\n+    call(rdi);\n+#endif\n+#ifdef ASSERT\n+    \/\/ TODO 8284443 Enable\n+    if (StressCallingConvention && false) {\n+      Label skip_stress;\n+      movptr(rscratch1, Address(rbp, frame::interpreter_frame_method_offset * wordSize));\n+      movl(rscratch1, Address(rscratch1, Method::flags_offset()));\n+      testl(rcx, ConstMethodFlags::has_scalarized_return_flag());\n+      jcc(Assembler::zero, skip_stress);\n+      load_klass(rax, rax, rscratch1);\n+      orptr(rax, 1);\n+      bind(skip_stress);\n+    }\n+#endif\n+    \/\/ call above kills the value in rbx. Reload it.\n+    movptr(rbx, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    bind(skip);\n+  }\n@@ -1188,0 +1233,106 @@\n+void InterpreterMacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                                  Register t1, Register t2,\n+                                                  bool clear_fields, Label& alloc_failed) {\n+  MacroAssembler::allocate_instance(klass, new_obj, t1, t2, clear_fields, alloc_failed);\n+  {\n+    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0, rscratch1);\n+    \/\/ Trigger dtrace event for fastpath\n+    push(atos);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), new_obj);\n+    pop(atos);\n+  }\n+}\n+\n+\n+void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n+                                                     Register field_index, Register field_offset,\n+                                                     Register obj) {\n+  Label alloc_failed, empty_value, done;\n+  const Register src = field_offset;\n+  const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);\n+  const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);\n+  assert_different_registers(obj, holder_klass, field_index, field_offset, dst_temp);\n+\n+  \/\/ Grap the inline field klass\n+  push(holder_klass);\n+  const Register field_klass = holder_klass;\n+  get_inline_type_field_klass(holder_klass, field_index, field_klass);\n+\n+  \/\/check for empty value klass\n+  test_klass_is_empty_inline_type(field_klass, dst_temp, empty_value);\n+\n+  \/\/ allocate buffer\n+  push(obj); \/\/ save holder\n+  allocate_instance(field_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n+\n+  \/\/ Have an oop instance buffer, copy into it\n+  data_for_oop(obj, dst_temp, field_klass);\n+  pop(alloc_temp);             \/\/ restore holder\n+  lea(src, Address(alloc_temp, field_offset));\n+  \/\/ call_VM_leaf, clobbers a few regs, save restore new obj\n+  push(obj);\n+  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, field_klass);\n+  pop(obj);\n+  pop(holder_klass);\n+  jmp(done);\n+\n+  bind(empty_value);\n+  get_empty_inline_type_oop(field_klass, dst_temp, obj);\n+  pop(holder_klass);\n+  jmp(done);\n+\n+  bind(alloc_failed);\n+  pop(obj);\n+  pop(holder_klass);\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+          obj, field_index, holder_klass);\n+\n+  bind(done);\n+}\n+\n+void InterpreterMacroAssembler::read_flattened_element(Register array, Register index,\n+                                                       Register t1, Register t2,\n+                                                       Register obj) {\n+  assert_different_registers(array, index, t1, t2);\n+  Label alloc_failed, empty_value, done;\n+  const Register array_klass = t2;\n+  const Register elem_klass = t1;\n+  const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);\n+  const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);\n+\n+  \/\/ load in array->klass()->element_klass()\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  load_klass(array_klass, array, tmp_load_klass);\n+  movptr(elem_klass, Address(array_klass, ArrayKlass::element_klass_offset()));\n+\n+  \/\/check for empty value klass\n+  test_klass_is_empty_inline_type(elem_klass, dst_temp, empty_value);\n+\n+  \/\/ calc source into \"array_klass\" and free up some regs\n+  const Register src = array_klass;\n+  push(index); \/\/ preserve index reg in case alloc_failed\n+  data_for_value_array_index(array, array_klass, index, src);\n+\n+  allocate_instance(elem_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n+  \/\/ Have an oop instance buffer, copy into it\n+  store_ptr(0, obj); \/\/ preserve obj (overwrite index, no longer needed)\n+  data_for_oop(obj, dst_temp, elem_klass);\n+  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, elem_klass);\n+  pop(obj);\n+  jmp(done);\n+\n+  bind(empty_value);\n+  get_empty_inline_type_oop(elem_klass, dst_temp, obj);\n+  jmp(done);\n+\n+  bind(alloc_failed);\n+  pop(index);\n+  if (array == c_rarg2) {\n+    mov(elem_klass, array);\n+    array = elem_klass;\n+  }\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), array, index);\n+\n+  bind(done);\n+}\n+\n@@ -1243,0 +1394,4 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        andptr(swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+      }\n@@ -1615,1 +1770,1 @@\n-void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp) {\n+void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp, bool acmp) {\n@@ -1627,1 +1782,1 @@\n-    update_mdp_by_constant(mdp, in_bytes(BranchData::branch_data_size()));\n+    update_mdp_by_constant(mdp, acmp ? in_bytes(ACmpData::acmp_data_size()): in_bytes(BranchData::branch_data_size()));\n@@ -2002,0 +2157,78 @@\n+void InterpreterMacroAssembler::profile_array(Register mdp,\n+                                              Register array,\n+                                              Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, array);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::array_offset())));\n+\n+    Label not_flat;\n+    test_non_flattened_array_oop(array, tmp, not_flat);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::flat_array_byte_constant());\n+\n+    bind(not_flat);\n+\n+    Label not_null_free;\n+    test_non_null_free_array_oop(array, tmp, not_null_free);\n+\n+    set_mdp_flag_at(mdp, ArrayLoadStoreData::null_free_array_byte_constant());\n+\n+    bind(not_null_free);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_element(Register mdp,\n+                                                Register element,\n+                                                Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, element);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ArrayLoadStoreData::element_offset())));\n+\n+    \/\/ The method data pointer needs to be updated.\n+    update_mdp_by_constant(mdp, in_bytes(ArrayLoadStoreData::array_load_store_data_size()));\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::profile_acmp(Register mdp,\n+                                             Register left,\n+                                             Register right,\n+                                             Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, left);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::left_offset())));\n+\n+    Label left_not_inline_type;\n+    test_oop_is_not_inline_type(left, tmp, left_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::left_inline_type_byte_constant());\n+    bind(left_not_inline_type);\n+\n+    mov(tmp, right);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::right_offset())));\n+\n+    Label right_not_inline_type;\n+    test_oop_is_not_inline_type(right, tmp, right_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::right_inline_type_byte_constant());\n+    bind(right_not_inline_type);\n+\n+    bind(profile_continue);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":245,"deletions":12,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/assembler.hpp\"\n@@ -39,0 +40,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include \"vmreg_x86.inline.hpp\"\n@@ -317,5 +320,9 @@\n-  \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n-  __ movptr(c_rarg0, result);\n-  Label is_long, is_float, is_double, exit;\n-  __ movl(c_rarg1, result_type);\n-  __ cmpl(c_rarg1, T_OBJECT);\n+  \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+  __ movptr(r13, result);\n+  Label is_long, is_float, is_double, check_prim, exit;\n+  __ movl(rbx, result_type);\n+  __ cmpl(rbx, T_OBJECT);\n+  __ jcc(Assembler::equal, check_prim);\n+  __ cmpl(rbx, T_PRIMITIVE_OBJECT);\n+  __ jcc(Assembler::equal, check_prim);\n+  __ cmpl(rbx, T_LONG);\n@@ -323,3 +330,1 @@\n-  __ cmpl(c_rarg1, T_LONG);\n-  __ jcc(Assembler::equal, is_long);\n-  __ cmpl(c_rarg1, T_FLOAT);\n+  __ cmpl(rbx, T_FLOAT);\n@@ -327,1 +332,1 @@\n-  __ cmpl(c_rarg1, T_DOUBLE);\n+  __ cmpl(rbx, T_DOUBLE);\n@@ -331,1 +336,1 @@\n-  __ movl(Address(c_rarg0, 0), rax);\n+  __ movl(Address(r13, 0), rax);\n@@ -395,0 +400,13 @@\n+  __ BIND(check_prim);\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ Check for scalarized return value\n+    __ testptr(rax, 1);\n+    __ jcc(Assembler::zero, is_long);\n+    \/\/ Load pack handler address\n+    __ andptr(rax, -2);\n+    __ movptr(rax, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    __ movptr(rbx, Address(rax, InlineKlass::pack_handler_jobject_offset()));\n+    \/\/ Call pack handler to initialize the buffer\n+    __ call(rbx);\n+    __ jmp(exit);\n+  }\n@@ -396,1 +414,1 @@\n-  __ movq(Address(c_rarg0, 0), rax);\n+  __ movq(Address(r13, 0), rax);\n@@ -400,1 +418,1 @@\n-  __ movflt(Address(c_rarg0, 0), xmm0);\n+  __ movflt(Address(r13, 0), xmm0);\n@@ -404,1 +422,1 @@\n-  __ movdbl(Address(c_rarg0, 0), xmm0);\n+  __ movdbl(Address(r13, 0), xmm0);\n@@ -3881,0 +3899,10 @@\n+  \/\/ Generate these first because they are called from other stubs\n+  if (InlineTypeReturnedAsFields) {\n+    StubRoutines::_load_inline_type_fields_in_regs =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs),\n+                                 \"load_inline_type_fields_in_regs\", false);\n+    StubRoutines::_store_inline_type_fields_to_buf =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf),\n+                                 \"store_inline_type_fields_to_buf\", true);\n+  }\n+\n@@ -3946,0 +3974,144 @@\n+\/\/ Call here from the interpreter or compiled code to either load\n+\/\/ multiple returned values from the inline type instance being\n+\/\/ returned to registers or to store returned values to a newly\n+\/\/ allocated inline type instance.\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n+address StubGenerator::generate_return_value_stub(address destination, const char* name, bool has_res) {\n+  \/\/ We need to save all registers the calling convention may use so\n+  \/\/ the runtime calls read or update those registers. This needs to\n+  \/\/ be in sync with SharedRuntime::java_return_convention().\n+  enum layout {\n+    pad_off = frame::arg_reg_save_area_bytes\/BytesPerInt, pad_off_2,\n+    rax_off, rax_off_2,\n+    j_rarg5_off, j_rarg5_2,\n+    j_rarg4_off, j_rarg4_2,\n+    j_rarg3_off, j_rarg3_2,\n+    j_rarg2_off, j_rarg2_2,\n+    j_rarg1_off, j_rarg1_2,\n+    j_rarg0_off, j_rarg0_2,\n+    j_farg0_off, j_farg0_2,\n+    j_farg1_off, j_farg1_2,\n+    j_farg2_off, j_farg2_2,\n+    j_farg3_off, j_farg3_2,\n+    j_farg4_off, j_farg4_2,\n+    j_farg5_off, j_farg5_2,\n+    j_farg6_off, j_farg6_2,\n+    j_farg7_off, j_farg7_2,\n+    rbp_off, rbp_off_2,\n+    return_off, return_off_2,\n+\n+    framesize\n+  };\n+\n+  CodeBuffer buffer(name, 1000, 512);\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+\n+  int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+  assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+  int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+  int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+  OopMapSet *oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+  map->set_callee_saved(VMRegImpl::stack2reg(rax_off), rax->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+  int start = __ offset();\n+\n+  __ subptr(rsp, frame_size_in_bytes - 8 \/* return address*\/);\n+\n+  __ movptr(Address(rsp, rbp_off * BytesPerInt), rbp);\n+  __ movdbl(Address(rsp, j_farg7_off * BytesPerInt), j_farg7);\n+  __ movdbl(Address(rsp, j_farg6_off * BytesPerInt), j_farg6);\n+  __ movdbl(Address(rsp, j_farg5_off * BytesPerInt), j_farg5);\n+  __ movdbl(Address(rsp, j_farg4_off * BytesPerInt), j_farg4);\n+  __ movdbl(Address(rsp, j_farg3_off * BytesPerInt), j_farg3);\n+  __ movdbl(Address(rsp, j_farg2_off * BytesPerInt), j_farg2);\n+  __ movdbl(Address(rsp, j_farg1_off * BytesPerInt), j_farg1);\n+  __ movdbl(Address(rsp, j_farg0_off * BytesPerInt), j_farg0);\n+\n+  __ movptr(Address(rsp, j_rarg0_off * BytesPerInt), j_rarg0);\n+  __ movptr(Address(rsp, j_rarg1_off * BytesPerInt), j_rarg1);\n+  __ movptr(Address(rsp, j_rarg2_off * BytesPerInt), j_rarg2);\n+  __ movptr(Address(rsp, j_rarg3_off * BytesPerInt), j_rarg3);\n+  __ movptr(Address(rsp, j_rarg4_off * BytesPerInt), j_rarg4);\n+  __ movptr(Address(rsp, j_rarg5_off * BytesPerInt), j_rarg5);\n+  __ movptr(Address(rsp, rax_off * BytesPerInt), rax);\n+\n+  int frame_complete = __ offset();\n+\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n+\n+  __ mov(c_rarg0, r15_thread);\n+  __ mov(c_rarg1, rax);\n+\n+  __ call(RuntimeAddress(destination));\n+\n+  \/\/ Set an oopmap for the call site.\n+\n+  oop_maps->add_gc_map( __ offset() - start, map);\n+\n+  \/\/ clear last_Java_sp\n+  __ reset_last_Java_frame(false);\n+\n+  __ movptr(rbp, Address(rsp, rbp_off * BytesPerInt));\n+  __ movdbl(j_farg7, Address(rsp, j_farg7_off * BytesPerInt));\n+  __ movdbl(j_farg6, Address(rsp, j_farg6_off * BytesPerInt));\n+  __ movdbl(j_farg5, Address(rsp, j_farg5_off * BytesPerInt));\n+  __ movdbl(j_farg4, Address(rsp, j_farg4_off * BytesPerInt));\n+  __ movdbl(j_farg3, Address(rsp, j_farg3_off * BytesPerInt));\n+  __ movdbl(j_farg2, Address(rsp, j_farg2_off * BytesPerInt));\n+  __ movdbl(j_farg1, Address(rsp, j_farg1_off * BytesPerInt));\n+  __ movdbl(j_farg0, Address(rsp, j_farg0_off * BytesPerInt));\n+\n+  __ movptr(j_rarg0, Address(rsp, j_rarg0_off * BytesPerInt));\n+  __ movptr(j_rarg1, Address(rsp, j_rarg1_off * BytesPerInt));\n+  __ movptr(j_rarg2, Address(rsp, j_rarg2_off * BytesPerInt));\n+  __ movptr(j_rarg3, Address(rsp, j_rarg3_off * BytesPerInt));\n+  __ movptr(j_rarg4, Address(rsp, j_rarg4_off * BytesPerInt));\n+  __ movptr(j_rarg5, Address(rsp, j_rarg5_off * BytesPerInt));\n+  __ movptr(rax, Address(rsp, rax_off * BytesPerInt));\n+\n+  __ addptr(rsp, frame_size_in_bytes-8);\n+\n+  \/\/ check for pending exceptions\n+  Label pending;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, pending);\n+\n+  if (has_res) {\n+    __ get_vm_result(rax, r15_thread);\n+  }\n+\n+  __ ret(0);\n+\n+  __ bind(pending);\n+\n+  __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ -------------\n+  \/\/ make sure all code is generated\n+  _masm->flush();\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, false);\n+  return stub->entry_point();\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":185,"deletions":13,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -551,0 +551,3 @@\n+  \/\/ interpreter or compiled code marshalling registers to\/from inline type instance\n+  address generate_return_value_stub(address destination, const char* name, bool has_res);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -65,1 +66,1 @@\n-int TemplateInterpreter::InterpreterCodeSize = JVMCI_ONLY(268) NOT_JVMCI(256) * 1024;\n+int TemplateInterpreter::InterpreterCodeSize = JVMCI_ONLY(280) NOT_JVMCI(268) * 1024;\n@@ -213,0 +214,4 @@\n+  if (state == atos && InlineTypeReturnedAsFields) {\n+    __ store_inline_type_fields_to_buf(NULL);\n+  }\n+\n@@ -360,0 +365,1 @@\n+  case T_PRIMITIVE_OBJECT: \/\/ fall through (inline types are handled with oops)\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -183,0 +184,1 @@\n+  case Bytecodes::_fast_qputfield:\n@@ -375,0 +377,1 @@\n+  __ andl(rdx, ~JVM_CONSTANT_QDescBit);\n@@ -824,9 +827,27 @@\n-  \/\/ rax: index\n-  \/\/ rdx: array\n-  index_check(rdx, rax); \/\/ kills rbx\n-  do_oop_load(_masm,\n-              Address(rdx, rax,\n-                      UseCompressedOops ? Address::times_4 : Address::times_ptr,\n-                      arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n-              rax,\n-              IS_ARRAY);\n+  Register array = rdx;\n+  Register index = rax;\n+\n+  index_check(array, index); \/\/ kills rbx\n+  __ profile_array(rbx, array, rcx);\n+  if (UseFlatArray) {\n+    Label is_flat_array, done;\n+    __ test_flattened_array_oop(array, rbx, is_flat_array);\n+    do_oop_load(_masm,\n+                Address(array, index,\n+                        UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+                        arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n+                rax,\n+                IS_ARRAY);\n+    __ jmp(done);\n+    __ bind(is_flat_array);\n+    __ read_flattened_element(array, index, rbx, rcx, rax);\n+    __ bind(done);\n+  } else {\n+    do_oop_load(_masm,\n+                Address(array, index,\n+                        UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+                        arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n+                rax,\n+                IS_ARRAY);\n+  }\n+  __ profile_element(rbx, rax, rcx);\n@@ -1118,1 +1139,1 @@\n-  Label is_null, ok_is_subtype, done;\n+  Label is_null, is_flat_array, ok_is_subtype, done;\n@@ -1130,0 +1151,4 @@\n+\n+  __ profile_array(rdi, rdx, rbx);\n+  __ profile_element(rdi, rax, rbx);\n+\n@@ -1133,0 +1158,7 @@\n+  \/\/ Move array class to rdi\n+  __ load_klass(rdi, rdx, rscratch1);\n+  if (UseFlatArray) {\n+    __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));\n+    __ test_flattened_array_layout(rbx, is_flat_array);\n+  }\n+\n@@ -1135,3 +1167,2 @@\n-  \/\/ Move superklass into rax\n-  __ load_klass(rax, rdx, rscratch1);\n-  __ movptr(rax, Address(rax,\n+  \/\/ Move array element superklass into rax\n+  __ movptr(rax, Address(rdi,\n@@ -1142,1 +1173,2 @@\n-  __ gen_subtype_check(rbx, ok_is_subtype);\n+  \/\/ is \"rbx <: rax\" ? (value subclass <: array element superclass)\n+  __ gen_subtype_check(rbx, ok_is_subtype, false);\n@@ -1160,1 +1192,2 @@\n-  __ profile_null_seen(rbx);\n+  if (EnablePrimitiveClasses) {\n+    Label is_null_into_value_array_npe, store_null;\n@@ -1162,0 +1195,9 @@\n+    \/\/ No way to store null in null-free array\n+    __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);\n+    __ jmp(store_null);\n+\n+    __ bind(is_null_into_value_array_npe);\n+    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+\n+    __ bind(store_null);\n+  }\n@@ -1164,0 +1206,7 @@\n+  __ jmp(done);\n+\n+  if (UseFlatArray) {\n+    Label is_type_ok;\n+    __ bind(is_flat_array); \/\/ Store non-null value to flat\n+\n+    \/\/ Simplistic type check...\n@@ -1165,0 +1214,27 @@\n+    \/\/ Profile the not-null value's klass.\n+    __ load_klass(rbx, rax, rscratch1);\n+    \/\/ Move element klass into rax\n+    __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));\n+    \/\/ flat value array needs exact type match\n+    \/\/ is \"rax == rbx\" (value subclass == array element superclass)\n+    __ cmpptr(rax, rbx);\n+    __ jccb(Assembler::equal, is_type_ok);\n+\n+    __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n+\n+    __ bind(is_type_ok);\n+    \/\/ rbx: value's klass\n+    \/\/ rdx: array\n+    \/\/ rdi: array klass\n+    __ test_klass_is_empty_inline_type(rbx, rax, done);\n+\n+    \/\/ calc dst for copy\n+    __ movl(rax, at_tos_p1()); \/\/ index\n+    __ data_for_value_array_index(rdx, rdi, rax, rax);\n+\n+    \/\/ ...and src for copy\n+    __ movptr(rcx, at_tos());  \/\/ value\n+    __ data_for_oop(rcx, rcx, rbx);\n+\n+    __ access_value_copy(IN_HEAP, rcx, rax, rbx);\n+  }\n@@ -2333,1 +2409,1 @@\n-  Label not_taken;\n+  Label taken, not_taken;\n@@ -2335,0 +2411,36 @@\n+\n+  __ profile_acmp(rbx, rdx, rax, rcx);\n+\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  if (EnableValhalla) {\n+    __ cmpoop(rdx, rax);\n+    __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);\n+\n+    \/\/ might be substitutable, test if either rax or rdx is null\n+    __ testptr(rax, rax);\n+    __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);\n+    __ testptr(rdx, rdx);\n+    __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ and both are values ?\n+    __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(rbx, is_inline_type_mask);\n+    __ cmpptr(rbx, is_inline_type_mask);\n+    __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ same value klass ?\n+    __ load_metadata(rbx, rdx);\n+    __ load_metadata(rcx, rax);\n+    __ cmpptr(rbx, rcx);\n+    __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ Know both are the same type, let's test for substitutability...\n+    if (cc == equal) {\n+      invoke_is_substitutable(rax, rdx, taken, not_taken);\n+    } else {\n+      invoke_is_substitutable(rax, rdx, not_taken, taken);\n+    }\n+    __ stop(\"Not reachable\");\n+  }\n+\n@@ -2337,0 +2449,1 @@\n+  __ bind(taken);\n@@ -2339,1 +2452,10 @@\n-  __ profile_not_taken_branch(rax);\n+  __ profile_not_taken_branch(rax, true);\n+}\n+\n+void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,\n+                                            Label& is_subst, Label& not_subst) {\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);\n+  \/\/ Restored...rax answer, jmp to outcome...\n+  __ testl(rax, rax);\n+  __ jcc(Assembler::zero, not_subst);\n+  __ jmp(is_subst);\n@@ -2609,1 +2731,2 @@\n-  __ remove_activation(state, rbcp);\n+\n+  __ remove_activation(state, rbcp, true, true, true);\n@@ -2875,0 +2998,1 @@\n+  const Register flags2 = rdx;\n@@ -2880,2 +3004,0 @@\n-  if (!is_static) pop_and_check_object(obj);\n-\n@@ -2884,1 +3006,9 @@\n-  Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;\n+  Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notInlineType;\n+\n+  if (!is_static) {\n+    __ movptr(rcx, Address(cache, index, Address::times_ptr,\n+                           in_bytes(ConstantPoolCache::base_offset() +\n+                                    ConstantPoolCacheEntry::f1_offset())));\n+  }\n+\n+  __ movl(flags2, flags);\n@@ -2894,0 +3024,1 @@\n+  if (!is_static) pop_and_check_object(obj);\n@@ -2903,0 +3034,1 @@\n+\n@@ -2905,1 +3037,1 @@\n-\n+   if (!is_static) pop_and_check_object(obj);\n@@ -2920,4 +3052,83 @@\n-  do_oop_load(_masm, field, rax);\n-  __ push(atos);\n-  if (!is_static && rc == may_rewrite) {\n-    patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+  if (!EnablePrimitiveClasses) {\n+    if (!is_static) pop_and_check_object(obj);\n+    do_oop_load(_masm, field, rax);\n+    __ push(atos);\n+    if (!is_static && rc == may_rewrite) {\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+    }\n+    __ jmp(Done);\n+  } else {\n+    if (is_static) {\n+      __ load_heap_oop(rax, field);\n+      Label is_null_free_inline_type, uninitialized;\n+      \/\/ Issue below if the static field has not been initialized yet\n+      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+        \/\/ field is not a null free inline type\n+        __ push(atos);\n+        __ jmp(Done);\n+      \/\/ field is a null free inline type, must not return null even if uninitialized\n+      __ bind(is_null_free_inline_type);\n+          __ testptr(rax, rax);\n+        __ jcc(Assembler::zero, uninitialized);\n+          __ push(atos);\n+          __ jmp(Done);\n+        __ bind(uninitialized);\n+          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+#ifdef _LP64\n+          Label slow_case, finish;\n+          __ movptr(rbx, Address(obj, java_lang_Class::klass_offset()));\n+          __ cmpb(Address(rbx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+          __ jcc(Assembler::notEqual, slow_case);\n+        __ get_default_value_oop(rbx, rscratch1, rax);\n+        __ jmp(finish);\n+        __ bind(slow_case);\n+#endif \/\/ LP64\n+          __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field),\n+                obj, flags2);\n+#ifdef _LP64\n+          __ bind(finish);\n+  #endif \/\/ _LP64\n+        __ verify_oop(rax);\n+        __ push(atos);\n+        __ jmp(Done);\n+    } else {\n+      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+      \/\/ field is not a null free inline type\n+      pop_and_check_object(obj);\n+      __ load_heap_oop(rax, field);\n+      __ push(atos);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+      }\n+      __ jmp(Done);\n+      __ bind(is_inline_type);\n+        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+          \/\/ field is not inlined\n+          __ movptr(rax, rcx);  \/\/ small dance required to preserve the klass_holder somewhere\n+          pop_and_check_object(obj);\n+          __ push(rax);\n+          __ load_heap_oop(rax, field);\n+          __ pop(rcx);\n+          __ testptr(rax, rax);\n+          __ jcc(Assembler::notZero, nonnull);\n+            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+            __ get_inline_type_field_klass(rcx, flags2, rbx);\n+            __ get_default_value_oop(rbx, rcx, rax);\n+          __ bind(nonnull);\n+          __ verify_oop(rax);\n+          __ push(atos);\n+          __ jmp(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+          pop_and_check_object(rax);\n+          __ read_inlined_field(rcx, flags2, rbx, rax);\n+          __ verify_oop(rax);\n+          __ push(atos);\n+      __ bind(rewrite_inline);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);\n+      }\n+        __ jmp(Done);\n+    }\n@@ -2925,1 +3136,0 @@\n-  __ jmp(Done);\n@@ -2928,0 +3138,3 @@\n+\n+  if (!is_static) pop_and_check_object(obj);\n+\n@@ -3027,0 +3240,22 @@\n+void TemplateTable::withfield() {\n+  transition(vtos, atos);\n+\n+  Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n+  Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n+\n+  resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));\n+\n+  Register cpentry = rbx;\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  __ lea(cpentry, Address(cache, index, Address::times_ptr,\n+                         in_bytes(cp_base_offset)));\n+  __ lea(rax, at_tos());\n+  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cpentry, rax);\n+  \/\/ new value type is returned in rbx\n+  \/\/ stack adjustment is returned in rax\n+  __ verify_oop(rbx);\n+  __ addptr(rsp, rax);\n+  __ movptr(rax, rbx);\n+}\n@@ -3122,0 +3357,1 @@\n+  const Register flags2 = rdx;\n@@ -3138,0 +3374,1 @@\n+  __ movl(flags2, flags);\n@@ -3140,1 +3377,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n@@ -3146,1 +3383,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n@@ -3152,1 +3389,1 @@\n-                                              Register obj, Register off, Register flags) {\n+                                              Register obj, Register off, Register flags, Register flags2) {\n@@ -3159,1 +3396,1 @@\n-        notLong, notFloat, notObj;\n+        notLong, notFloat, notObj, notInlineType;\n@@ -3202,6 +3439,53 @@\n-    __ pop(atos);\n-    if (!is_static) pop_and_check_object(obj);\n-    \/\/ Store into the field\n-    do_oop_store(_masm, field, rax);\n-    if (!is_static && rc == may_rewrite) {\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+    if (!EnablePrimitiveClasses) {\n+      __ pop(atos);\n+      if (!is_static) pop_and_check_object(obj);\n+      \/\/ Store into the field\n+      do_oop_store(_masm, field, rax);\n+      if (!is_static && rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+      }\n+      __ jmp(Done);\n+    } else {\n+      __ pop(atos);\n+      if (is_static) {\n+        Label is_inline_type;\n+        __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        __ null_check(rax);\n+        __ bind(is_inline_type);\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(Done);\n+      } else {\n+        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        \/\/ Not an inline type\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        __ bind(rewrite_not_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+        }\n+        __ jmp(Done);\n+        \/\/ Implementation of the inline type semantic\n+        __ bind(is_inline_type);\n+        __ null_check(rax);\n+        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+        \/\/ field is not inlined\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+        pop_and_check_object(obj);\n+        assert_different_registers(rax, rdx, obj, off);\n+        __ load_klass(rdx, rax, rscratch1);\n+        __ data_for_oop(rax, rax, rdx);\n+        __ addptr(obj, off);\n+        __ access_value_copy(IN_HEAP, rax, obj, rdx);\n+        __ bind(rewrite_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);\n+        }\n+        __ jmp(Done);\n+      }\n@@ -3209,1 +3493,0 @@\n-    __ jmp(Done);\n@@ -3348,0 +3631,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -3373,0 +3657,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/ fall through\n@@ -3412,0 +3697,4 @@\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rscratch2, rdx);  \/\/ saving flags for is_inlined test\n+  }\n+\n@@ -3425,1 +3714,4 @@\n-  fast_storefield_helper(field, rax);\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+  }\n+  fast_storefield_helper(field, rax, rdx);\n@@ -3431,1 +3723,4 @@\n-  fast_storefield_helper(field, rax);\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+  }\n+  fast_storefield_helper(field, rax, rdx);\n@@ -3436,1 +3731,1 @@\n-void TemplateTable::fast_storefield_helper(Address field, Register rax) {\n+void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {\n@@ -3440,0 +3735,17 @@\n+  case Bytecodes::_fast_qputfield:\n+    {\n+      Label is_inlined, done;\n+      __ null_check(rax);\n+      __ test_field_is_inlined(flags, rscratch1, is_inlined);\n+      \/\/ field is not inlined\n+      do_oop_store(_masm, field, rax);\n+      __ jmp(done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+      __ load_klass(rdx, rax, rscratch1);\n+      __ data_for_oop(rax, rax, rdx);\n+      __ lea(rcx, field);\n+      __ access_value_copy(IN_HEAP, rax, rcx, rdx);\n+      __ bind(done);\n+    }\n+    break;\n@@ -3441,1 +3753,3 @@\n-    do_oop_store(_masm, field, rax);\n+    {\n+      do_oop_store(_masm, field, rax);\n+    }\n@@ -3511,1 +3825,1 @@\n-  __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,\n+  __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,\n@@ -3518,1 +3832,1 @@\n-  Address field(rax, rbx, Address::times_1);\n+  Address field(rax, rdx, Address::times_1);\n@@ -3522,0 +3836,39 @@\n+  case Bytecodes::_fast_qgetfield:\n+    {\n+      Label is_inlined, nonnull, Done;\n+      __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,\n+                                   in_bytes(ConstantPoolCache::base_offset() +\n+                                            ConstantPoolCacheEntry::flags_offset())));\n+      __ test_field_is_inlined(rscratch1, rscratch2, is_inlined);\n+        \/\/ field is not inlined\n+        __ load_heap_oop(rax, field);\n+        __ testptr(rax, rax);\n+        __ jcc(Assembler::notZero, nonnull);\n+          __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n+                             in_bytes(ConstantPoolCache::base_offset() +\n+                                      ConstantPoolCacheEntry::flags_offset())));\n+          __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n+          __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n+                                       in_bytes(ConstantPoolCache::base_offset() +\n+                                                ConstantPoolCacheEntry::f1_offset())));\n+          __ get_inline_type_field_klass(rcx, rdx, rbx);\n+          __ get_default_value_oop(rbx, rcx, rax);\n+        __ bind(nonnull);\n+        __ verify_oop(rax);\n+        __ jmp(Done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+        __ push(rdx); \/\/ save offset\n+        __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n+                           in_bytes(ConstantPoolCache::base_offset() +\n+                                    ConstantPoolCacheEntry::flags_offset())));\n+        __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n+        __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n+                                     in_bytes(ConstantPoolCache::base_offset() +\n+                                              ConstantPoolCacheEntry::f1_offset())));\n+        __ pop(rbx); \/\/ restore offset\n+        __ read_inlined_field(rcx, rdx, rbx, rax);\n+      __ bind(Done);\n+      __ verify_oop(rax);\n+    }\n+    break;\n@@ -3987,2 +4340,1 @@\n-  Label slow_case_no_pop;\n-  Label initialize_header;\n+  Label is_not_value;\n@@ -3998,1 +4350,1 @@\n-  __ jcc(Assembler::notEqual, slow_case_no_pop);\n+  __ jcc(Assembler::notEqual, slow_case);\n@@ -4002,1 +4354,7 @@\n-  __ push(rcx);  \/\/ save the contexts of klass for initializing the header\n+\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), Klass::InlineKlassKind);\n+  __ jcc(Assembler::notEqual, is_not_value);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n+\n+  __ bind(is_not_value);\n@@ -4005,1 +4363,0 @@\n-  \/\/ make sure klass is fully initialized\n@@ -4009,14 +4366,2 @@\n-  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n-  __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n-  __ testl(rdx, Klass::_lh_instance_slow_path_bit);\n-  __ jcc(Assembler::notZero, slow_case);\n-\n-  \/\/ Allocate the instance:\n-  \/\/  If TLAB is enabled:\n-  \/\/    Try to allocate in the TLAB.\n-  \/\/    If fails, go to the slow path.\n-  \/\/    Initialize the allocation.\n-  \/\/    Exit.\n-  \/\/\n-  \/\/  Go to slow path.\n+  __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);\n+  __ jmp(done);\n@@ -4024,1 +4369,2 @@\n-  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n+  \/\/ slow case\n+  __ bind(slow_case);\n@@ -4026,7 +4372,2 @@\n-  if (UseTLAB) {\n-    NOT_LP64(__ get_thread(thread);)\n-    __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);\n-    if (ZeroTLAB) {\n-      \/\/ the fields have been already cleared\n-      __ jmp(initialize_header);\n-    }\n+  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n@@ -4034,4 +4375,4 @@\n-    \/\/ The object is initialized before the header.  If the object size is\n-    \/\/ zero, go directly to the header initialization.\n-    __ decrement(rdx, sizeof(oopDesc));\n-    __ jcc(Assembler::zero, initialize_header);\n+  __ get_constant_pool(rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n+   __ verify_oop(rax);\n@@ -4039,4 +4380,3 @@\n-    \/\/ Initialize topmost object field, divide rdx by 8, check if odd and\n-    \/\/ test if zero.\n-    __ xorl(rcx, rcx);    \/\/ use zero reg to clear memory (shorter code)\n-    __ shrl(rdx, LogBytesPerLong); \/\/ divide by 2*oopSize and set carry flag if odd\n+  \/\/ continue\n+  __ bind(done);\n+}\n@@ -4044,10 +4384,2 @@\n-    \/\/ rdx must have been multiple of 8\n-#ifdef ASSERT\n-    \/\/ make sure rdx was multiple of 8\n-    Label L;\n-    \/\/ Ignore partial flag stall after shrl() since it is debug VM\n-    __ jcc(Assembler::carryClear, L);\n-    __ stop(\"object size is not multiple of 2 - adjust this code\");\n-    __ bind(L);\n-    \/\/ rdx must be > 0, no extra check needed here\n-#endif\n+void TemplateTable::aconst_init() {\n+  transition(vtos, atos);\n@@ -4055,8 +4387,3 @@\n-    \/\/ initialize remaining object fields: rdx was a multiple of 8\n-    { Label loop;\n-    __ bind(loop);\n-    __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));\n-    __ decrement(rdx);\n-    __ jcc(Assembler::notZero, loop);\n-    }\n+  Label slow_case;\n+  Label done;\n+  Label is_value;\n@@ -4064,10 +4391,2 @@\n-    \/\/ initialize object header only.\n-    __ bind(initialize_header);\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n-              (intptr_t)markWord::prototype().value()); \/\/ header\n-    __ pop(rcx);   \/\/ get saved klass back in the register.\n-#ifdef _LP64\n-    __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n-    __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n-#endif\n-    __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n+  __ get_unsigned_2_byte_index_at_bcp(rdx, 1);\n+  __ get_cpool_and_tags(rcx, rax);\n@@ -4075,8 +4394,6 @@\n-    {\n-      SkipIfEqual skip_if(_masm, &DTraceAllocProbes, 0, rscratch1);\n-      \/\/ Trigger dtrace event for fastpath\n-      __ push(atos);\n-      __ call_VM_leaf(\n-           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), rax);\n-      __ pop(atos);\n-    }\n+  \/\/ Make sure the class we're about to instantiate has been resolved.\n+  \/\/ This is done before loading InstanceKlass to be consistent with the order\n+  \/\/ how Constant Pool is updated (see ConstantPool::klass_at_put)\n+  const int tags_offset = Array<u1>::base_offset_in_bytes();\n+  __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);\n+  __ jcc(Assembler::notEqual, slow_case);\n@@ -4084,2 +4401,18 @@\n-    __ jmp(done);\n-  }\n+  \/\/ get InstanceKlass\n+  __ load_resolved_klass_at_index(rcx, rcx, rdx);\n+\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), Klass::InlineKlassKind);\n+  __ jcc(Assembler::equal, is_value);\n+\n+  \/\/ in the future, aconst_init will just return null instead of throwing an exception\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));\n+\n+  __ bind(is_value);\n+\n+  \/\/ make sure klass is fully initialized\n+  __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+  __ jcc(Assembler::notEqual, slow_case);\n+\n+  \/\/ have a resolved InlineKlass in rcx, return the default value oop from it\n+  __ get_default_value_oop(rcx, rdx, rax);\n+  __ jmp(done);\n@@ -4087,4 +4420,1 @@\n-  \/\/ slow case\n-  __ pop(rcx);   \/\/ restore stack pointer to what it was when we came in.\n-  __ bind(slow_case_no_pop);\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n@@ -4095,3 +4425,4 @@\n-  __ get_constant_pool(rarg1);\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n-   __ verify_oop(rax);\n+  __ get_constant_pool(rarg1);\n+\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n+      rarg1, rarg2);\n@@ -4100,1 +4431,1 @@\n-  \/\/ continue\n+  __ verify_oop(rax);\n@@ -4139,4 +4470,5 @@\n-  __ cmpb(Address(rdx, rbx,\n-                  Address::times_1,\n-                  Array<u1>::base_offset_in_bytes()),\n-          JVM_CONSTANT_Class);\n+  __ movzbl(rdx, Address(rdx, rbx,\n+      Address::times_1,\n+      Array<u1>::base_offset_in_bytes()));\n+  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n+  __ cmpl(rdx, JVM_CONSTANT_Class);\n@@ -4180,0 +4512,3 @@\n+  __ jmp(done);\n+\n+  __ bind(is_null);\n@@ -4183,4 +4518,15 @@\n-    __ jmp(done);\n-    __ bind(is_null);\n-  } else {\n-    __ bind(is_null);   \/\/ same as 'done'\n+\n+  if (EnablePrimitiveClasses) {\n+    \/\/ Get cpool & tags index\n+    __ get_cpool_and_tags(rcx, rdx); \/\/ rcx=cpool, rdx=tags array\n+    __ get_unsigned_2_byte_index_at_bcp(rbx, 1); \/\/ rbx=index\n+    \/\/ See if CP entry is a Q-descriptor\n+    __ movzbl(rcx, Address(rdx, rbx,\n+        Address::times_1,\n+        Array<u1>::base_offset_in_bytes()));\n+    __ andl (rcx, JVM_CONSTANT_QDescBit);\n+    __ cmpl(rcx, JVM_CONSTANT_QDescBit);\n+    __ jcc(Assembler::notEqual, done);\n+    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+  }\n+\n@@ -4202,4 +4548,5 @@\n-  __ cmpb(Address(rdx, rbx,\n-                  Address::times_1,\n-                  Array<u1>::base_offset_in_bytes()),\n-          JVM_CONSTANT_Class);\n+  __ movzbl(rdx, Address(rdx, rbx,\n+        Address::times_1,\n+        Array<u1>::base_offset_in_bytes()));\n+  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n+  __ cmpl(rdx, JVM_CONSTANT_Class);\n@@ -4257,1 +4604,0 @@\n-\n@@ -4319,0 +4665,4 @@\n+  Label is_inline_type;\n+  __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+  __ test_markword_is_inline_type(rbx, is_inline_type);\n+\n@@ -4408,0 +4758,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -4416,0 +4771,11 @@\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  Label has_identity;\n+  __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+  __ andptr(rbx, is_inline_type_mask);\n+  __ cmpl(rbx, is_inline_type_mask);\n+  __ jcc(Assembler::notEqual, has_identity);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n+  __ bind(has_identity);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":504,"deletions":138,"binary":false,"changes":642,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+    void do_NewInlineTypeInstance(NewInlineTypeInstance* x) { \/* nothing to do *\/ };\n@@ -145,0 +146,1 @@\n+    void do_Deoptimize     (Deoptimize*      x) { \/* nothing to do *\/ };\n@@ -163,0 +165,1 @@\n+    void do_ProfileACmpTypes(ProfileACmpTypes*  x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -476,1 +476,5 @@\n-  if (k->local_interfaces()->length() != _interfaces->length()) {\n+  const int actual_num_interfaces = k->local_interfaces()->length();\n+  const int specified_num_interfaces = _interfaces->length(); \/\/ specified in classlist\n+  int expected_num_interfaces = actual_num_interfaces;\n+\n+  if (specified_num_interfaces != expected_num_interfaces) {\n@@ -480,1 +484,1 @@\n-          _interfaces->length(), k->local_interfaces()->length());\n+          specified_num_interfaces, expected_num_interfaces);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,0 +83,65 @@\n+inline void CDSMustMatchFlags::do_print(outputStream* st, bool v) {\n+  st->print(\"%s\", v ? \"true\" : \"false\");\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, intx v) {\n+  st->print(INTX_FORMAT, v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, uintx v) {\n+  st->print(UINTX_FORMAT, v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, double v) {\n+  st->print(\"%f\", v);\n+}\n+\n+void CDSMustMatchFlags::init() {\n+  Arguments::assert_is_dumping_archive();\n+  _max_name_width = 0;\n+\n+#define INIT_CDS_MUST_MATCH_FLAG(n) \\\n+  _v_##n = n; \\\n+  _max_name_width = MAX2(_max_name_width,strlen(#n));\n+  CDS_MUST_MATCH_FLAGS_DO(INIT_CDS_MUST_MATCH_FLAG);\n+#undef INIT_CDS_MUST_MATCH_FLAG\n+}\n+\n+bool CDSMustMatchFlags::runtime_check() const {\n+#define CHECK_CDS_MUST_MATCH_FLAG(n) \\\n+  if (_v_##n != n) { \\\n+    ResourceMark rm; \\\n+    stringStream ss; \\\n+    ss.print(\"VM option %s is different between dumptime (\", #n);  \\\n+    do_print(&ss, _v_ ## n); \\\n+    ss.print(\") and runtime (\"); \\\n+    do_print(&ss, n); \\\n+    ss.print(\")\"); \\\n+    log_info(cds)(\"%s\", ss.as_string()); \\\n+    return false; \\\n+  }\n+  CDS_MUST_MATCH_FLAGS_DO(CHECK_CDS_MUST_MATCH_FLAG);\n+#undef CHECK_CDS_MUST_MATCH_FLAG\n+\n+  return true;\n+}\n+\n+void CDSMustMatchFlags::print_info() const {\n+  LogTarget(Info, cds) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Recorded VM flags during dumptime:\");\n+    print(&ls);\n+  }\n+}\n+\n+void CDSMustMatchFlags::print(outputStream* st) const {\n+#define PRINT_CDS_MUST_MATCH_FLAG(n) \\\n+  st->print(\"- %-s \", #n);                   \\\n+  st->sp(int(_max_name_width - strlen(#n))); \\\n+  do_print(st, _v_##n);                      \\\n+  st->cr();\n+  CDS_MUST_MATCH_FLAGS_DO(PRINT_CDS_MUST_MATCH_FLAG);\n+#undef PRINT_CDS_MUST_MATCH_FLAG\n+}\n+\n@@ -248,0 +313,1 @@\n+  _must_match.init();\n@@ -309,0 +375,1 @@\n+  _must_match.print(st);\n@@ -1386,0 +1453,4 @@\n+  if (!header()->check_must_match_flags()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -182,0 +183,28 @@\n+#define CDS_MUST_MATCH_FLAGS_DO(f) \\\n+  f(EnableValhalla) \\\n+  f(FlatArrayElementMaxOops) \\\n+  f(FlatArrayElementMaxSize) \\\n+  f(InlineFieldMaxFlatSize) \\\n+  f(InlineTypePassFieldsAsArgs) \\\n+  f(InlineTypeReturnedAsFields)\n+\n+class CDSMustMatchFlags {\n+private:\n+  size_t _max_name_width;\n+#define DECLARE_CDS_MUST_MATCH_FLAG(n) \\\n+  decltype(n) _v_##n;\n+  CDS_MUST_MATCH_FLAGS_DO(DECLARE_CDS_MUST_MATCH_FLAG);\n+#undef DECLARE_CDS_MUST_MATCH_FLAG\n+\n+  inline static void do_print(outputStream* st, bool v);\n+  inline static void do_print(outputStream* st, intx v);\n+  inline static void do_print(outputStream* st, uintx v);\n+  inline static void do_print(outputStream* st, double v);\n+  void print_info() const;\n+\n+public:\n+  void init();\n+  bool runtime_check() const;\n+  void print(outputStream* st) const;\n+};\n+\n@@ -236,0 +265,1 @@\n+  CDSMustMatchFlags _must_match;        \/\/ These flags must be the same between dumptime and runtime\n@@ -321,0 +351,4 @@\n+  bool check_must_match_flags() const {\n+    return _must_match.runtime_check();\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -530,1 +531,3 @@\n-      (sym->char_at(1) == JVM_SIGNATURE_ARRAY || sym->char_at(1) == JVM_SIGNATURE_CLASS)) {\n+      (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||\n+       sym->char_at(1) == JVM_SIGNATURE_CLASS ||\n+       sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT )) {\n@@ -543,1 +546,2 @@\n-      return ciObjArrayKlass::make_impl(elem_klass);\n+      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+      return ciArrayKlass::make(elem_klass, null_free_array);\n@@ -569,0 +573,15 @@\n+  int i = 0;\n+  while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {\n+    i++;\n+  }\n+  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+    \/\/ An unloaded array class of inline types is an ObjArrayKlass, an\n+    \/\/ unloaded inline type class is an InstanceKlass. For consistency,\n+    \/\/ make the signature of the unloaded array of inline type use L\n+    \/\/ rather than Q.\n+    char* new_name = name_buffer(sym->utf8_length()+1);\n+    strncpy(new_name, (char*)sym->base(), sym->utf8_length());\n+    new_name[i] = JVM_SIGNATURE_CLASS;\n+    new_name[sym->utf8_length()] = '\\0';\n+    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));\n+  }\n@@ -655,0 +674,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::is_inline_klass\n+\/\/\n+\/\/ Check if the klass is an inline klass.\n+bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n+  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)\n+}\n+\n@@ -751,1 +778,5 @@\n-    return ciConstant(T_OBJECT, mirror);\n+    if (klass->is_loaded() && tag.is_Qdescriptor_klass()) {\n+      return ciConstant(T_OBJECT, klass->as_inline_klass()->val_mirror());\n+    } else {\n+      return ciConstant(T_OBJECT, mirror);\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -989,0 +990,1 @@\n+\n@@ -1035,27 +1037,79 @@\n-  \/\/ staticfield <klass> <name> <signature> <value>\n-  \/\/\n-  \/\/ Initialize a class and fill in the value for a static field.\n-  \/\/ This is useful when the compile was dependent on the value of\n-  \/\/ static fields but it's impossible to properly rerun the static\n-  \/\/ initializer.\n-  void process_staticfield(TRAPS) {\n-    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n-\n-    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n-        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n-      skip_remaining();\n-      return;\n-    }\n-\n-    assert(k->is_initialized(), \"must be\");\n-\n-    const char* field_name = parse_escaped_string();\n-    const char* field_signature = parse_string();\n-    fieldDescriptor fd;\n-    Symbol* name = SymbolTable::new_symbol(field_name);\n-    Symbol* sig = SymbolTable::new_symbol(field_signature);\n-    if (!k->find_local_field(name, sig, &fd) ||\n-        !fd.is_static() ||\n-        fd.has_initial_value()) {\n-      report_error(field_name);\n-      return;\n+  class InlineTypeFieldInitializer : public FieldClosure {\n+    oop _vt;\n+    CompileReplay* _replay;\n+  public:\n+    InlineTypeFieldInitializer(oop vt, CompileReplay* replay)\n+  : _vt(vt), _replay(replay) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      BasicType bt = fd->field_type();\n+      const char* string_value = bt != T_PRIMITIVE_OBJECT ? _replay->parse_escaped_string() : nullptr;\n+      switch (bt) {\n+      case T_BYTE: {\n+        int value = atoi(string_value);\n+        _vt->byte_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_BOOLEAN: {\n+        int value = atoi(string_value);\n+        _vt->bool_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_SHORT: {\n+        int value = atoi(string_value);\n+        _vt->short_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_CHAR: {\n+        int value = atoi(string_value);\n+        _vt->char_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_INT: {\n+        int value = atoi(string_value);\n+        _vt->int_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_LONG: {\n+        jlong value;\n+        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+          break;\n+        }\n+        _vt->long_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_FLOAT: {\n+        float value = atof(string_value);\n+        _vt->float_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        double value = atof(string_value);\n+        _vt->double_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_ARRAY:\n+      case T_OBJECT: {\n+        JavaThread* THREAD = JavaThread::current();\n+        bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n+        assert(res, \"should succeed for arrays & objects\");\n+        break;\n+      }\n+      case T_PRIMITIVE_OBJECT: {\n+        InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+        if (fd->is_inlined()) {\n+          int field_offset = fd->offset() - vk->first_field_offset();\n+          oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+          InlineTypeFieldInitializer init_fields(obj, _replay);\n+          vk->do_nonstatic_fields(&init_fields);\n+        } else {\n+          oop value = vk->allocate_instance(JavaThread::current());\n+          _vt->obj_field_put(fd->offset(), value);\n+        }\n+        break;\n+      }\n+      default: {\n+        fatal(\"Unhandled type: %s\", type2name(bt));\n+      }\n+      }\n@@ -1063,0 +1117,1 @@\n+  };\n@@ -1064,1 +1119,1 @@\n-    oop java_mirror = k->java_mirror();\n+  bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {\n@@ -1071,4 +1126,2 @@\n-        ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);\n-        if (kelem == nullptr) {\n-          return;\n-        }\n+        Klass* k = resolve_klass(field_signature, CHECK_(true));\n+        ArrayKlass* kelem = (ArrayKlass *)k;\n@@ -1084,1 +1137,1 @@\n-        value = kelem->multi_allocate(rank, dims, CHECK);\n+        value = kelem->multi_allocate(rank, dims, CHECK_(true));\n@@ -1087,1 +1140,1 @@\n-          value = oopFactory::new_byteArray(length, CHECK);\n+          value = oopFactory::new_byteArray(length, CHECK_(true));\n@@ -1089,1 +1142,1 @@\n-          value = oopFactory::new_boolArray(length, CHECK);\n+          value = oopFactory::new_boolArray(length, CHECK_(true));\n@@ -1091,1 +1144,1 @@\n-          value = oopFactory::new_charArray(length, CHECK);\n+          value = oopFactory::new_charArray(length, CHECK_(true));\n@@ -1093,1 +1146,1 @@\n-          value = oopFactory::new_shortArray(length, CHECK);\n+          value = oopFactory::new_shortArray(length, CHECK_(true));\n@@ -1095,1 +1148,1 @@\n-          value = oopFactory::new_floatArray(length, CHECK);\n+          value = oopFactory::new_floatArray(length, CHECK_(true));\n@@ -1097,1 +1150,1 @@\n-          value = oopFactory::new_doubleArray(length, CHECK);\n+          value = oopFactory::new_doubleArray(length, CHECK_(true));\n@@ -1099,1 +1152,1 @@\n-          value = oopFactory::new_intArray(length, CHECK);\n+          value = oopFactory::new_intArray(length, CHECK_(true));\n@@ -1101,1 +1154,1 @@\n-          value = oopFactory::new_longArray(length, CHECK);\n+          value = oopFactory::new_longArray(length, CHECK_(true));\n@@ -1104,3 +1157,8 @@\n-          parse_klass(CHECK); \/\/ eat up the array class name\n-          Klass* kelem = resolve_klass(field_signature + 1, CHECK);\n-          value = oopFactory::new_objArray(kelem, length, CHECK);\n+          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n+          parse_klass(CHECK_(true)); \/\/ eat up the array class name\n+          value = oopFactory::new_objArray(kelem, length, CHECK_(true));\n+        } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&\n+                   field_signature[1] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n+          parse_klass(CHECK_(true)); \/\/ eat up the array class name\n+          value = oopFactory::new_valueArray(kelem, length, CHECK_(true));\n@@ -1111,0 +1169,87 @@\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value());\n+      return true;\n+    } else if (field_signature[0] == 'L') {\n+      const char* instance = parse_escaped_string();\n+      Klass* k = resolve_klass(instance, CHECK_(true));\n+      oop value = InstanceKlass::cast(k)->allocate_instance(CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Initialize a class and fill in the value for a static field.\n+  \/\/ This is useful when the compile was dependent on the value of\n+  \/\/ static fields but it's impossible to properly rerun the static\n+  \/\/ initializer.\n+  void process_staticfield(TRAPS) {\n+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n+\n+    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n+        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n+        skip_remaining();\n+      return;\n+    }\n+\n+    assert(k->is_initialized(), \"must be\");\n+\n+    const char* field_name = parse_escaped_string();\n+    const char* field_signature = parse_string();\n+    fieldDescriptor fd;\n+    Symbol* name = SymbolTable::new_symbol(field_name);\n+    Symbol* sig = SymbolTable::new_symbol(field_signature);\n+    if (!k->find_local_field(name, sig, &fd) ||\n+        !fd.is_static() ||\n+        fd.has_initial_value()) {\n+      report_error(field_name);\n+      return;\n+    }\n+\n+    oop java_mirror = k->java_mirror();\n+    if (strcmp(field_signature, \"I\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->int_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"B\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->byte_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"C\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->char_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"S\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->short_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"Z\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->bool_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"J\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      jlong value;\n+      if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+        fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+        return;\n+      }\n+      java_mirror->long_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"F\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      float value = atof(string_value);\n+      java_mirror->float_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"D\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      double value = atof(string_value);\n+      java_mirror->double_field_put(fd.offset(), value);\n+    } else if (field_signature[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+      Klass* kelem = resolve_klass(field_signature, CHECK);\n+      InlineKlass* vk = InlineKlass::cast(kelem);\n+      oop value = vk->allocate_instance(CHECK);\n+      InlineTypeFieldInitializer init_fields(value, this);\n+      vk->do_nonstatic_fields(&init_fields);\n@@ -1113,37 +1258,2 @@\n-      const char* string_value = parse_escaped_string();\n-      if (strcmp(field_signature, \"I\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->int_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"B\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->byte_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"C\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->char_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"S\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->short_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Z\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->bool_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"J\") == 0) {\n-        jlong value;\n-        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n-          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n-          return;\n-        }\n-        java_mirror->long_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"F\") == 0) {\n-        float value = atof(string_value);\n-        java_mirror->float_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"D\") == 0) {\n-        double value = atof(string_value);\n-        java_mirror->double_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n-        Handle value = java_lang_String::create_from_str(string_value, CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value());\n-      } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n-        Klass* k = resolve_klass(string_value, CHECK);\n-        oop value = InstanceKlass::cast(k)->allocate_instance(CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value);\n-      } else {\n+      bool res = process_staticfield_reference(field_signature, java_mirror, &fd, CHECK);\n+      if (!res)  {\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":191,"deletions":81,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+\n+#include \"oops\/inlineKlass.hpp\"\n@@ -53,0 +55,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -86,0 +89,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -150,0 +154,2 @@\n+#define CONSTANT_CLASS_DESCRIPTORS        66\n+\n@@ -188,1 +194,1 @@\n-      case JVM_CONSTANT_Class : {\n+      case JVM_CONSTANT_Class: {\n@@ -509,1 +515,8 @@\n-        cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n+\n+        Symbol* const name = cp->symbol_at(class_index);\n+        const unsigned int name_len = name->utf8_length();\n+        if (name->is_Q_signature()) {\n+          cp->unresolved_qdescriptor_at_put(index, class_index, num_klasses++);\n+        } else {\n+          cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n+        }\n@@ -709,1 +722,2 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature,\n+          \/\/ or if it is an inline type, <vnew> with return.\n@@ -713,1 +727,2 @@\n-            if (name != vmSymbols::object_initializer_name()) {\n+            if (name != vmSymbols::object_initializer_name() &&\n+                name != vmSymbols::inline_factory_name()) {\n@@ -718,2 +733,7 @@\n-            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n-              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            } else if (!Signature::is_void_method(signature)) {\n+              \/\/ if return type is non-void then it must be an inline type\n+              if (name == vmSymbols::object_initializer_name() ||\n+                  !EnableValhalla || !supports_inline_types() ||\n+                  !signature->ends_with(JVM_SIGNATURE_ENDCLASS)) {\n+                throwIllegalSignature(\"Method\", name, signature, CHECK);\n+              }\n@@ -738,2 +758,13 @@\n-            if (ref_kind == JVM_REF_newInvokeSpecial) {\n-              if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) { \/\/ <vnew>\n+              \/\/ <vnew> factory methods must be non-void return and invokeStatic.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature() || ref_kind != JVM_REF_invokeStatic) {\n+                classfile_parse_error(\n+                  \"Bad factory method name at constant pool index %u in class file %s\",\n+                  name_ref_index, CHECK);\n+              }\n+            } else if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+              if (ref_kind == JVM_REF_newInvokeSpecial) {\n@@ -745,2 +776,10 @@\n-            } else {\n-              if (name == vmSymbols::object_initializer_name()) {\n+            } else { \/\/ <init>\n+              \/\/ The allowed invocation mode of <init> depends on its signature.\n+              \/\/ This test corresponds to verify_invoke_instructions in the verifier.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature()\n+                  && ref_kind == JVM_REF_newInvokeSpecial) {\n+                \/\/ OK, could be a constructor call\n+              } else {\n@@ -798,4 +837,31 @@\n-\/\/ Side-effects: populates the _local_interfaces field\n-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,\n-                                       const int itfs_len,\n-                                       ConstantPool* const cp,\n+static void check_identity_and_value_modifiers(ClassFileParser* current, const InstanceKlass* super_type, TRAPS) {\n+  assert(super_type != nullptr,\"Method doesn't support null super type\");\n+  if (super_type->carries_identity_modifier()) {\n+    if (current->carries_value_modifier()) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(\n+          THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_IncompatibleClassChangeError(),\n+          \"Value type %s has an identity type as supertype\",\n+          current->class_name()->as_klass_external_name());\n+        return;\n+      }\n+    current->set_carries_identity_modifier();\n+  }\n+  if (super_type->carries_value_modifier()) {\n+    if (current->carries_identity_modifier()) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_IncompatibleClassChangeError(),\n+        \"Identity type %s has a value type as supertype\",\n+        current->class_name()->as_klass_external_name());\n+      return;\n+    }\n+    current->set_carries_value_modifier();\n+  }\n+}\n+\n+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,\n+                                       int itfs_len,\n+                                       ConstantPool* cp,\n@@ -803,0 +869,7 @@\n+                                       \/\/ FIXME: lots of these functions\n+                                       \/\/ declare their parameters as const,\n+                                       \/\/ which adds only noise to the code.\n+                                       \/\/ Remove the spurious const modifiers.\n+                                       \/\/ Many are of the form \"const int x\"\n+                                       \/\/ or \"T* const x\".\n+                                       bool* const is_declared_atomic,\n@@ -810,0 +883,1 @@\n+\n@@ -812,3 +886,2 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n-\n-    int index;\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n+    int index = 0;\n@@ -817,1 +890,0 @@\n-      Klass* interf;\n@@ -822,32 +894,1 @@\n-      if (cp->tag_at(interface_index).is_klass()) {\n-        interf = cp->resolved_klass_at(interface_index);\n-      } else {\n-        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n-\n-        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n-        \/\/ But need to make sure it's not an array type.\n-        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n-                           \"Bad interface name in class file %s\", CHECK);\n-\n-        \/\/ Call resolve_super so class circularity is checked\n-        interf = SystemDictionary::resolve_super_or_fail(\n-                                                  _class_name,\n-                                                  unresolved_klass,\n-                                                  Handle(THREAD, _loader_data->class_loader()),\n-                                                  _protection_domain,\n-                                                  false,\n-                                                  CHECK);\n-      }\n-\n-      if (!interf->is_interface()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n-                          _class_name->as_klass_external_name(),\n-                          interf->external_name(),\n-                          interf->class_in_module_of_loader()));\n-      }\n-\n-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n-        *has_nonstatic_concrete_methods = true;\n-      }\n-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));\n+      _local_interface_indexes->at_put_grow(index, interface_index);\n@@ -865,2 +906,1 @@\n-      const InstanceKlass* const k = _local_interfaces->at(index);\n-      Symbol* interface_name = k->name();\n+      Symbol* interface_name = cp->klass_name_at(_local_interface_indexes->at(index));\n@@ -1348,0 +1388,1 @@\n+  STATIC_INLINE,        \/\/ inline type field\n@@ -1353,0 +1394,1 @@\n+  NONSTATIC_INLINE,\n@@ -1372,6 +1414,7 @@\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n+  NONSTATIC_OOP,       \/\/ T_PRIMITIVE_OBJECT = 14,\n+  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n+  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n+  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n+  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20,\n@@ -1392,6 +1435,7 @@\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n+  STATIC_OOP,          \/\/ T_PRIMITIVE_OBJECT = 14,\n+  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n+  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n+  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n+  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20\n@@ -1400,1 +1444,1 @@\n-static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {\n+static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {\n@@ -1404,0 +1448,3 @@\n+  if (is_inline_type) {\n+    result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;\n+  }\n@@ -1417,2 +1464,2 @@\n-  void update(bool is_static, BasicType type) {\n-    FieldAllocationType atype = basic_type_to_atype(is_static, type);\n+  void update(bool is_static, BasicType type, bool is_inline_type) {\n+    FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);\n@@ -1430,1 +1477,1 @@\n-                                   bool is_interface,\n+                                   AccessFlags class_access_flags,\n@@ -1445,0 +1492,1 @@\n+  bool is_inline_type = class_access_flags.is_value_class() && !class_access_flags.is_abstract();\n@@ -1452,1 +1500,5 @@\n-  const int total_fields = length + num_injected;\n+\n+  \/\/ two more slots are required for inline classes:\n+  \/\/ one for the static field with a reference to the pre-allocated default value\n+  \/\/ one for the field the JVM injects when detecting an empty inline class\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);\n@@ -1458,0 +1510,1 @@\n+  int instance_fields_count = 0;\n@@ -1463,0 +1516,4 @@\n+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;\n+\n+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    verify_legal_field_modifiers(flags, class_access_flags, CHECK);\n@@ -1464,2 +1521,0 @@\n-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n-    verify_legal_field_modifiers(flags, is_interface, CHECK);\n@@ -1482,0 +1537,1 @@\n+    if (!access_flags.is_static()) instance_fields_count++;\n@@ -1533,1 +1589,1 @@\n-    fac->update(is_static, type);\n+    fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n@@ -1581,1 +1637,1 @@\n-      fac->update(false, type);\n+      fac->update(false, type, false);\n@@ -1586,0 +1642,42 @@\n+  if (is_inline_type) {\n+    \/\/ Inject static \".default\" field\n+    FieldInfo::FieldFlags fflags(0);\n+    fflags.update_injected(true);\n+    AccessFlags aflags(JVM_ACC_STATIC);\n+    FieldInfo fi(aflags,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                 0,\n+                 fflags);\n+      fi.set_index(index);\n+      _temp_field_info->append(fi);\n+\n+    const BasicType type = Signature::basic_type(vmSymbols::object_signature());\n+    fac->update(true, type, false);\n+    index++;\n+  }\n+\n+  if (is_inline_type && instance_fields_count == 0) {\n+    \/\/ Inject \".empty\" dummy field\n+    _is_empty_inline_type = true;\n+\n+    FieldInfo::FieldFlags fflags(0);\n+    fflags.update_injected(true);\n+    AccessFlags aflags;\n+    FieldInfo fi(aflags,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n+                 0,\n+                 fflags);\n+    fi.set_index(index);\n+    _temp_field_info->append(fi);\n+\n+    const BasicType type = Signature::basic_type(vmSymbols::byte_signature());\n+    fac->update(false, type, false);\n+    index++;\n+  }\n+\n+  if (instance_fields_count > 0) {\n+    _has_nonstatic_fields = true;\n+  }\n+\n@@ -1869,0 +1967,5 @@\n+  const char* class_note = \"\";\n+  if (is_inline_type() && name == vmSymbols::object_initializer_name()) {\n+    class_note = \" (an inline class)\";\n+  }\n+\n@@ -1872,2 +1975,2 @@\n-      \"%s \\\"%s\\\" in class %s has illegal signature \\\"%s\\\"\", type,\n-      name->as_C_string(), _class_name->as_C_string(), sig->as_C_string());\n+      \"%s \\\"%s\\\" in class %s%s has illegal signature \\\"%s\\\"\", type,\n+      name->as_C_string(), _class_name->as_C_string(), class_note, sig->as_C_string());\n@@ -2175,0 +2278,2 @@\n+                                      bool is_value_class,\n+                                      bool is_abstract_class,\n@@ -2216,1 +2321,34 @@\n-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);\n+    verify_legal_method_modifiers(flags, access_flags() , name, CHECK_NULL);\n+  }\n+\n+  if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <vnew>, class file %s\", CHECK_NULL);\n+    } else if (!is_value_class) {\n+       classfile_parse_error(\"Identity class cannot have a method <vnew>, class file %s\", CHECK_NULL);\n+    } else if (signature->is_void_method_signature()) {\n+       classfile_parse_error(\"Factory method <vnew> must have a non-void return type, class file %s\", CHECK_NULL);\n+    } else { \/\/ also OK, a static factory, as long as the return value is good\n+      bool ok = false;\n+      SignatureStream ss((Symbol*) signature, true);\n+      while (!ss.at_return_type())  ss.next();\n+      if (ss.is_reference()) {\n+        Symbol* ret = ss.as_symbol();\n+        const Symbol* required = class_name();\n+        if (is_hidden()) {\n+          \/\/ The original class name for hidden classes changed.\n+          \/\/\/ So using the original name in the return type is no longer valid.\n+          required = vmSymbols::java_lang_Object();\n+        }\n+        ok = (ret == required);\n+      }\n+      if (!ok) {\n+        throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+      }\n+      \/\/ factory method, with a non-void return.  No other\n+      \/\/ definition of <vnew> is possible.\n+      \/\/\n+      \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+      \/\/ signature of any attempt to invoke <vnew>, and ensure that it\n+      \/\/ returns non-void.\n+    }\n@@ -2219,3 +2357,24 @@\n-  if (name == vmSymbols::object_initializer_name() && is_interface) {\n-    classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n-    return nullptr;\n+  if (name == vmSymbols::object_initializer_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n+    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n+      \/\/ OK, a constructor\n+    } else {\n+      \/\/ not OK, so throw the same error as in verify_legal_method_signature.\n+      throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+    }\n+    \/\/ A declared <init> method must always be a non-static\n+    \/\/ object constructor, with a void return.\n+    \/\/\n+    \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+    \/\/ signature of any attempt to invoke <init>, and ensure that it\n+    \/\/ returns void.\n+  }\n+\n+  if (EnableValhalla) {\n+    if (((flags & JVM_ACC_SYNCHRONIZED) == JVM_ACC_SYNCHRONIZED)\n+        && ((flags & JVM_ACC_STATIC) == 0 )\n+        && !carries_identity_modifier()) {\n+      classfile_parse_error(\"Invalid synchronized method in non-identity class %s\", THREAD);\n+        return nullptr;\n+    }\n@@ -2788,0 +2947,2 @@\n+                                    bool is_value_class,\n+                                    bool is_abstract_type,\n@@ -2812,0 +2973,2 @@\n+                                    is_value_class,\n+                                    is_abstract_type,\n@@ -3077,2 +3240,2 @@\n-    \/\/ Access flags\n-    jint flags;\n+\n+    jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n@@ -3081,3 +3244,4 @@\n-      flags = cfs->get_u2_fast() & (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-    } else {\n-      flags = cfs->get_u2_fast() & RECOGNIZED_INNER_CLASS_MODIFIERS;\n+      recognized_modifiers |= JVM_ACC_MODULE;\n+    }\n+    if (supports_inline_types()) {\n+      recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY;\n@@ -3085,0 +3249,4 @@\n+\n+    \/\/ Access flags\n+    jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+\n@@ -3089,1 +3257,13 @@\n-    verify_legal_class_modifiers(flags, CHECK_0);\n+\n+    if (EnableValhalla) {\n+      if (!supports_inline_types()) {\n+        const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+        const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+        if (!is_module && !is_interface) {\n+          flags |= JVM_ACC_IDENTITY;\n+        }\n+      }\n+    }\n+\n+    const char* name = inner_name_index == 0 ? \"unnamed\" : cp->symbol_at(inner_name_index)->as_utf8();\n+    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n@@ -3193,0 +3373,33 @@\n+u2 ClassFileParser::parse_classfile_preload_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const preload_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (preload_attribute_start != nullptr) {\n+    cfs->set_current(preload_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  const int size = length;\n+  Array<u2>* const preload_classes = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _preload_classes = preload_classes;\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 class_info_index = cfs->get_u2_fast();\n+      check_property(\n+        valid_klass_reference_at(class_info_index),\n+        \"Preload class_info_index %u has bad constant type in class file %s\",\n+        class_info_index, CHECK_0);\n+      preload_classes->at_put(index++, class_info_index);\n+    }\n+    assert(index == size, \"wrong size\");\n+  }\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3477,0 +3690,2 @@\n+  \/\/ Set _preload_classes attribute to default sentinel\n+  _preload_classes = Universe::the_empty_short_array();\n@@ -3483,0 +3698,1 @@\n+  bool parsed_preload_attribute = false;\n@@ -3508,0 +3724,2 @@\n+  const u1* preload_attribute_start = nullptr;\n+  u4  preload_attribute_length = 0;\n@@ -3734,0 +3952,9 @@\n+            if (EnableValhalla && tag == vmSymbols::tag_preload()) {\n+              if (parsed_preload_attribute) {\n+                classfile_parse_error(\"Multiple Preload attributes in class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_preload_attribute = true;\n+              preload_attribute_start = cfs->current();\n+              preload_attribute_length = attribute_length;\n+            }\n@@ -3814,0 +4041,12 @@\n+  if (parsed_preload_attribute) {\n+    const u2 num_classes = parse_classfile_preload_attribute(\n+                            cfs,\n+                            preload_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        preload_attribute_length == sizeof(num_classes) + sizeof(u2) * num_classes,\n+        \"Wrong Preload attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3879,0 +4118,1 @@\n+  this_klass->set_preload_classes(_preload_classes);\n@@ -3930,2 +4170,1 @@\n-                   \"Invalid superclass index %u in class file %s\",\n-                   super_class_index,\n+                   \"Invalid superclass index 0 in class file %s\",\n@@ -3940,1 +4179,0 @@\n-    bool is_array = false;\n@@ -3943,4 +4181,0 @@\n-      if (need_verify)\n-        is_array = super_klass->is_array_klass();\n-    } else if (need_verify) {\n-      is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -3949,0 +4183,1 @@\n+      bool is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -4072,0 +4307,19 @@\n+void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,\n+                                                const char* msg,\n+                                                const Symbol* name,\n+                                                const Symbol* sig) const {\n+\n+  ResourceMark rm(THREAD);\n+  if (name == nullptr || sig == nullptr) {\n+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"class: %s - %s\", _class_name->as_C_string(), msg);\n+  }\n+  else {\n+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"\\\"%s\\\" sig: \\\"%s\\\" class: %s - %s\", name->as_C_string(), sig->as_C_string(),\n+        _class_name->as_C_string(), msg);\n+  }\n+}\n+\n@@ -4106,0 +4360,5 @@\n+      if (ik->is_inline_klass()) {\n+        JavaThread *THREAD = JavaThread::current();\n+        throwInlineTypeLimitation(THREAD_AND_LOCATION, \"Inline Types do not support Cloneable\");\n+        return;\n+      }\n@@ -4146,0 +4405,6 @@\n+bool ClassFileParser::supports_inline_types() const {\n+  \/\/ Inline types are only supported by class file version 61.65535 and later\n+  return _major_version > JAVA_22_VERSION ||\n+         (_major_version == JAVA_22_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+}\n+\n@@ -4189,3 +4454,4 @@\n-  } else if (max_transitive_size == local_size) {\n-    \/\/ only local interfaces added, share local interface array\n-    return local_ifs;\n+    \/\/ The three lines below are commented to work around bug JDK-8245487\n+\/\/  } else if (max_transitive_size == local_size) {\n+\/\/    \/\/ only local interfaces added, share local interface array\n+\/\/    return local_ifs;\n@@ -4212,0 +4478,1 @@\n+\n@@ -4240,0 +4507,10 @@\n+    \/\/ The JVMS says that super classes for value types must not have the ACC_IDENTITY\n+    \/\/ flag set. But, java.lang.Object must still be allowed to be a direct super class\n+    \/\/ for a value classes.  So, it is treated as a special case for now.\n+    if (this_klass->access_flags().is_value_class() &&\n+        super_ik->name() != vmSymbols::java_lang_Object() &&\n+        super_ik->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super_ik, THREAD);\n+      return;\n+    }\n+\n@@ -4423,1 +4700,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n@@ -4425,0 +4702,4 @@\n+  const bool is_value_class = (flags & JVM_ACC_VALUE) != 0;\n+  const bool is_primitive_class = (flags & JVM_ACC_PRIMITIVE) != 0;\n+  const bool is_identity_class = (flags & JVM_ACC_IDENTITY) != 0;\n+  const bool is_inner_class = name != nullptr;\n@@ -4436,1 +4717,23 @@\n-  if (!_need_verify) { return; }\n+  if (is_value_class && !EnableValhalla) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla\",\n+        _class_name->as_C_string()\n+      );\n+    return;\n+  }\n+\n+  if (is_primitive_class && !EnablePrimitiveClasses) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Class modifier ACC_PRIMITIVE in class %s requires option -XX:+EnablePrimitiveClasses\",\n+        _class_name->as_C_string()\n+      );\n+    return;\n+  }\n+\n+  \/\/ if (!_need_verify) { return; }\n@@ -4448,2 +4751,6 @@\n-      (is_interface && major_gte_1_5 && (is_super || is_enum)) ||\n-      (!is_interface && major_gte_1_5 && is_annotation)) {\n+      (is_interface && major_gte_1_5 && ((is_super && (!EnableValhalla || !supports_inline_types())) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation) ||\n+      (is_value_class && is_enum) ||\n+      (is_identity_class && is_value_class) ||\n+      (EnableValhalla && supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n+      (EnablePrimitiveClasses && supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n@@ -4451,7 +4758,21 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Illegal class modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags\n-    );\n-    return;\n+    const char* class_note = \"\";\n+    if (is_value_class)  class_note = \" (a value class)\";\n+    if (is_primitive_class)  class_note = \" (a primitive class)\";\n+    if (is_value_class && is_identity_class) class_note = \" (a value and identity class)\";\n+    if (name == nullptr) { \/\/ Not an inner class\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in class %s%s: 0x%X\",\n+        _class_name->as_C_string(), class_note, flags\n+      );\n+      return;\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in declaration of inner class %s%s of class %s: 0x%X\",\n+        name, class_note, _class_name->as_C_string(), flags\n+      );\n+      return;\n+    }\n@@ -4523,2 +4844,2 @@\n-void ClassFileParser::verify_legal_field_modifiers(jint flags,\n-                                                   bool is_interface,\n+void ClassFileParser:: verify_legal_field_modifiers(jint flags,\n+                                                   AccessFlags class_access_flags,\n@@ -4538,0 +4859,5 @@\n+  const bool is_interface = class_access_flags.is_interface();\n+  const bool is_abstract = class_access_flags.is_abstract();\n+  const bool is_value_class = class_access_flags.is_value_class();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+\n@@ -4549,0 +4875,6 @@\n+    } else {\n+      if (is_value_class && !is_abstract && !is_static && !is_final) {\n+        is_illegal = true;\n+      } else if (is_abstract && !is_identity_class && !is_static) {\n+        is_illegal = true;\n+      }\n@@ -4564,1 +4896,1 @@\n-                                                    bool is_interface,\n+                                                    AccessFlags class_access_flags,\n@@ -4583,0 +4915,5 @@\n+  const bool is_factory      = (name == vmSymbols::inline_factory_name() && supports_inline_types());\n+  const bool is_interface    = class_access_flags.is_interface();\n+  const bool is_value_class  = class_access_flags.is_value_class();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+  const bool is_abstract_class = class_access_flags.is_abstract();\n@@ -4586,0 +4923,1 @@\n+  const char* class_note = \"\";\n@@ -4619,1 +4957,7 @@\n-      if (is_initializer) {\n+      if (is_factory) { \/\/ <vnew> factory method\n+        if (is_final || is_synchronized || is_native || !is_static ||\n+            is_abstract || is_bridge) {\n+          is_illegal = true;\n+          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n+        }\n+      } else if (is_initializer) {\n@@ -4625,4 +4969,9 @@\n-        if (is_abstract) {\n-          if ((is_final || is_native || is_private || is_static ||\n-              (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n-            is_illegal = true;\n+        if (!is_identity_class && is_synchronized && !is_static) {\n+          is_illegal = true;\n+          class_note = \" (not an identity class)\";\n+        } else {\n+          if (is_abstract) {\n+            if ((is_final || is_native || is_private || is_static ||\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n+              is_illegal = true;\n+            }\n@@ -4637,5 +4986,14 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Method %s in class %s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), flags);\n+    if (is_value_class && is_initializer) {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method <init> is not allowed in value class %s\",\n+        _class_name->as_C_string());\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+        name->as_C_string(), _class_name->as_C_string(),\n+        class_note, flags);\n+    }\n@@ -4799,1 +5157,12 @@\n-    case JVM_SIGNATURE_CLASS: {\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n+      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators (TODO: JDK-8270852).\n+      \/\/ For now, compare to class file version 51 so old verifier doesn't see Q signatures.\n+      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n+        classfile_parse_error(\"Class name contains illegal Q-signature \"\n+                              \"in descriptor in class file %s, requires option -XX:+EnablePrimitiveClasses\",\n+                              CHECK_0);\n+        return nullptr;\n+      }\n+      \/\/ fall through\n+    case JVM_SIGNATURE_CLASS:\n+    {\n@@ -4810,1 +5179,1 @@\n-        \/\/ Skip leading 'L' and ignore first appearance of ';'\n+        \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -4866,0 +5235,4 @@\n+    } else if ((_major_version >= CONSTANT_CLASS_DESCRIPTORS || _class_name->starts_with(\"jdk\/internal\/reflect\/\"))\n+                   && bytes[length - 1] == ';' ) {\n+      \/\/ Support for L...; and Q...; descriptors\n+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);\n@@ -4931,1 +5304,4 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()  ||\n+          (EnableValhalla && supports_inline_types() &&\n+          name == vmSymbols::inline_factory_name())) {\n@@ -4963,0 +5339,3 @@\n+  if ((!supports_inline_types() || !EnablePrimitiveClasses) && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n+    throwIllegalSignature(\"Field\", name, signature, CHECK);\n+  }\n@@ -4990,2 +5369,3 @@\n-  int sig_length = signature->utf8_length();\n-  if (name->utf8_length() > 0 &&\n+  if (!is_value_class()) {\n+    int sig_length = signature->utf8_length();\n+    if (name->utf8_length() > 0 &&\n@@ -4995,1 +5375,2 @@\n-    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+      throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    }\n@@ -5171,1 +5552,0 @@\n-\n@@ -5207,0 +5587,10 @@\n+  if (_field_info->_is_naturally_atomic && ik->is_inline_klass()) {\n+    ik->set_is_naturally_atomic();\n+  }\n+\n+  if (carries_identity_modifier()) {\n+    ik->set_carries_identity_modifier();\n+  } else if (carries_value_modifier()) {\n+    ik->set_carries_value_modifier();\n+  }\n+\n@@ -5208,1 +5598,1 @@\n-  ik->set_static_oop_field_count(_fac->count[STATIC_OOP]);\n+  ik->set_static_oop_field_count(_fac->count[STATIC_OOP] + _fac->count[STATIC_INLINE]);\n@@ -5213,0 +5603,3 @@\n+  if (ik->is_inline_klass()) {\n+    InlineKlass::cast(ik)->init_fixed_block();\n+  }\n@@ -5226,0 +5619,1 @@\n+  assert(nullptr == _preload_classes, \"invariant\");\n@@ -5263,0 +5657,3 @@\n+  if (_is_declared_atomic) {\n+    ik->set_is_declared_atomic();\n+  }\n@@ -5370,0 +5767,27 @@\n+  bool all_fields_empty = true;\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static()) {\n+      if (fs.field_descriptor().is_inline_type()) {\n+        Klass* k = _inline_type_field_klasses->at(fs.index());\n+        ik->set_inline_type_field_klass(fs.index(), k);\n+        if (!InlineKlass::cast(k)->is_empty_inline_type()) { all_fields_empty = false; }\n+      } else {\n+        all_fields_empty = false;\n+      }\n+    } else if (is_inline_type() && (fs.name() == vmSymbols::default_value_name())) {\n+      InlineKlass::cast(ik)->set_default_value_offset(ik->field_offset(fs.index()));\n+    }\n+  }\n+\n+  if (_is_empty_inline_type || (is_inline_type() && all_fields_empty)) {\n+    ik->set_is_empty_inline_type();\n+  }\n+\n+  if (is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(ik);\n+    vk->set_alignment(_alignment);\n+    vk->set_first_field_offset(_first_field_offset);\n+    vk->set_exact_size_in_bytes(_exact_size_in_bytes);\n+    InlineKlass::cast(ik)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -5461,0 +5885,1 @@\n+  _preload_classes(nullptr),\n@@ -5463,0 +5888,1 @@\n+  _local_interface_indexes(nullptr),\n@@ -5474,0 +5900,1 @@\n+  _inline_type_field_klasses(nullptr),\n@@ -5502,0 +5929,7 @@\n+  _has_inline_type_fields(false),\n+  _has_nonstatic_fields(false),\n+  _is_empty_inline_type(false),\n+  _is_naturally_atomic(false),\n+  _is_declared_atomic(false),\n+  _carries_value_modifier(false),\n+  _carries_identity_modifier(false),\n@@ -5552,0 +5986,1 @@\n+  _preload_classes = nullptr;\n@@ -5574,0 +6009,4 @@\n+  if (_inline_type_field_klasses != nullptr) {\n+     MetadataFactory::free_array<InlineKlass*>(_loader_data, _inline_type_field_klasses);\n+  }\n+\n@@ -5596,0 +6035,4 @@\n+  if (_preload_classes != nullptr && _preload_classes != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _preload_classes);\n+  }\n+\n@@ -5680,2 +6123,1 @@\n-  \/\/ Access flags\n-  jint flags;\n+  jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n@@ -5684,3 +6126,5 @@\n-    flags = stream->get_u2_fast() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-  } else {\n-    flags = stream->get_u2_fast() & JVM_RECOGNIZED_CLASS_MODIFIERS;\n+    recognized_modifiers |= JVM_ACC_MODULE;\n+  }\n+  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE supported version\n+  if (supports_inline_types()) {\n+    recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE;\n@@ -5689,0 +6133,3 @@\n+  \/\/ Access flags\n+  jint flags = stream->get_u2_fast() & recognized_modifiers;\n+\n@@ -5694,12 +6141,0 @@\n-  verify_legal_class_modifiers(flags, CHECK);\n-\n-  short bad_constant = class_bad_constant_seen();\n-  if (bad_constant != 0) {\n-    \/\/ Do not throw CFE until after the access_flags are checked because if\n-    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n-    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n-    return;\n-  }\n-\n-  _access_flags.set_flags(flags);\n-\n@@ -5717,0 +6152,32 @@\n+  bool is_java_lang_Object = class_name_in_cp == vmSymbols::java_lang_Object();\n+\n+  verify_legal_class_modifiers(flags, nullptr, is_java_lang_Object, CHECK);\n+\n+  if (EnableValhalla) {\n+    if(!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface && !is_java_lang_Object) {\n+        flags |= JVM_ACC_IDENTITY;\n+      }\n+    }\n+  }\n+\n+  _access_flags.set_flags(flags);\n+\n+  if (EnableValhalla) {\n+    if (_access_flags.is_identity_class()) set_carries_identity_modifier();\n+    if (_access_flags.is_value_class()) set_carries_value_modifier();\n+    if (carries_identity_modifier() && carries_value_modifier()) {\n+      classfile_parse_error(\"Class %s has both ACC_IDENTITY and ACC_VALUE modifiers\", THREAD);\n+    }\n+  }\n+\n+  short bad_constant = class_bad_constant_seen();\n+  if (bad_constant != 0) {\n+    \/\/ Do not throw CFE until after the access_flags are checked because if\n+    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n+    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n+    return;\n+  }\n+\n@@ -5794,0 +6261,1 @@\n+                   &_is_declared_atomic,\n@@ -5796,2 +6264,0 @@\n-  assert(_local_interfaces != nullptr, \"invariant\");\n-\n@@ -5801,1 +6267,1 @@\n-               _access_flags.is_interface(),\n+               _access_flags,\n@@ -5812,1 +6278,3 @@\n-                _access_flags.is_interface(),\n+                is_interface(),\n+                is_value_class(),\n+                is_abstract_class(),\n@@ -5892,2 +6360,2 @@\n-                   \"java.lang.Object cannot implement an interface in class file %s\",\n-                   CHECK);\n+        \"java.lang.Object cannot implement an interface in class file %s\",\n+        CHECK);\n@@ -5898,1 +6366,1 @@\n-    if (_access_flags.is_interface()) {\n+    if (is_interface()) {\n@@ -5920,0 +6388,9 @@\n+    if (_super_klass->is_interface()) {\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (EnableValhalla) {\n+      check_identity_and_value_modifiers(this, _super_klass, CHECK);\n+    }\n+\n@@ -5923,0 +6400,4 @@\n+    if (_super_klass->is_declared_atomic()) {\n+      _is_declared_atomic = true;\n+    }\n+  }\n@@ -5924,3 +6405,54 @@\n-    if (_super_klass->is_interface()) {\n-      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n-      return;\n+  if (*ForceNonTearable != '\\0') {\n+    \/\/ Allow a command line switch to force the same atomicity property:\n+    const char* class_name_str = _class_name->as_C_string();\n+    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+      _is_declared_atomic = true;\n+    }\n+  }\n+\n+  int itfs_len = _local_interface_indexes == nullptr ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n+  if (_local_interface_indexes != nullptr) {\n+    for (int i = 0; i < _local_interface_indexes->length(); i++) {\n+      u2 interface_index = _local_interface_indexes->at(i);\n+      Klass* interf;\n+      if (cp->tag_at(interface_index).is_klass()) {\n+        interf = cp->resolved_klass_at(interface_index);\n+      } else {\n+        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n+\n+        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n+        \/\/ But need to make sure it's not an array type.\n+        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                            \"Bad interface name in class file %s\", CHECK);\n+\n+        \/\/ Call resolve_super so class circularity is checked\n+        interf = SystemDictionary::resolve_super_or_fail(\n+                                                  _class_name,\n+                                                  unresolved_klass,\n+                                                  Handle(THREAD, _loader_data->class_loader()),\n+                                                  _protection_domain,\n+                                                  false,\n+                                                  CHECK);\n+      }\n+\n+      if (!interf->is_interface()) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n+                          _class_name->as_klass_external_name(),\n+                          interf->external_name(),\n+                          interf->class_in_module_of_loader()));\n+      }\n+\n+      if (EnableValhalla) {\n+        \/\/ Check modifiers and set carries_identity_modifier\/carries_value_modifier flags\n+        check_identity_and_value_modifiers(this, InstanceKlass::cast(interf), CHECK);\n+      }\n+\n+      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n+        _has_nonstatic_concrete_methods = true;\n+      }\n+      if (InstanceKlass::cast(interf)->is_declared_atomic()) {\n+        _is_declared_atomic = true;\n+      }\n+      _local_interfaces->at_put(i, InstanceKlass::cast(interf));\n@@ -5929,0 +6461,1 @@\n+  assert(_local_interfaces != nullptr, \"invariant\");\n@@ -5957,1 +6490,1 @@\n-  _itable_size = _access_flags.is_interface() ? 0 :\n+  _itable_size = is_interface() ? 0 :\n@@ -5963,0 +6496,29 @@\n+\n+  if (EnablePrimitiveClasses) {\n+    _inline_type_field_klasses = MetadataFactory::new_array<InlineKlass*>(_loader_data,\n+                                                   java_fields_count(),\n+                                                   nullptr,\n+                                                   CHECK);\n+    for (GrowableArrayIterator<FieldInfo> it = _temp_field_info->begin(); it != _temp_field_info->end(); ++it) {\n+      FieldInfo fieldinfo = *it;\n+      Symbol* sig = fieldinfo.signature(cp);\n+\n+      if (Signature::basic_type(sig) == T_PRIMITIVE_OBJECT && !fieldinfo.access_flags().is_static()) {\n+        \/\/ Pre-load inline class\n+        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(sig,\n+            Handle(THREAD, _loader_data->class_loader()),\n+            _protection_domain, true, CHECK);\n+        assert(klass != nullptr, \"Sanity check\");\n+        if (!klass->access_flags().is_value_class()) {\n+          assert(klass->is_instance_klass(), \"Sanity check\");\n+          ResourceMark rm(THREAD);\n+            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                      err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                      _class_name->as_C_string(),\n+                      InstanceKlass::cast(klass)->external_name()));\n+        }\n+        _inline_type_field_klasses->at_put(fieldinfo.index(), InlineKlass::cast(klass));\n+      }\n+    }\n+  }\n+\n@@ -5965,2 +6527,9 @@\n-                        _parsed_annotations->is_contended(), _field_info);\n-  lb.build_layout();\n+      _parsed_annotations->is_contended(), is_inline_type(),\n+      _field_info, _inline_type_field_klasses);\n+  lb.build_layout(CHECK);\n+  if (is_inline_type()) {\n+    _alignment = lb.get_alignment();\n+    _first_field_offset = lb.get_first_field_offset();\n+    _exact_size_in_bytes = lb.get_exact_size_in_byte();\n+  }\n+  _has_inline_type_fields = _field_info->_has_inline_fields;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":726,"deletions":157,"binary":false,"changes":883,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -56,1 +58,1 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.inline.hpp\"\n@@ -789,0 +791,2 @@\n+int java_lang_Class::_primary_mirror_offset;\n+int java_lang_Class::_secondary_mirror_offset;\n@@ -990,1 +994,10 @@\n-    if (k->is_typeArray_klass()) {\n+    if (k->is_flatArray_klass()) {\n+      Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n+      assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n+      }\n+    } else if (k->is_typeArray_klass()) {\n@@ -1001,0 +1014,5 @@\n+      oop comp_oop = element_klass->java_mirror();\n+      if (element_klass->is_inline_klass()) {\n+        InlineKlass* ik = InlineKlass::cast(element_klass);\n+        comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+      }\n@@ -1004,1 +1022,1 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1066,0 +1084,6 @@\n+\n+    if (k->is_inline_klass()) {\n+      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n+      set_primary_mirror(mirror(), mirror());\n+      set_secondary_mirror(mirror(), secondary_mirror);\n+    }\n@@ -1074,0 +1098,19 @@\n+\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n+\/\/ instance with the same value as the primary mirror\n+oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n+  assert(k->is_inline_klass(), \"primitive class\");\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n+  Handle secondary_mirror(THREAD, mirror_oop);\n+\n+  java_lang_Class::set_klass(secondary_mirror(), k);\n+  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n+\n+  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n+  set_class_loader(secondary_mirror(), class_loader(mirror()));\n+  \/\/ ## handle if java.base is not yet defined\n+  set_module(secondary_mirror(), module(mirror()));\n+  set_primary_mirror(secondary_mirror(), mirror());\n+  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n+  return secondary_mirror();\n+}\n@@ -1088,3 +1131,8 @@\n-  if (k->class_loader() != nullptr &&\n-      k->class_loader() != SystemDictionary::java_platform_loader() &&\n-      k->class_loader() != SystemDictionary::java_system_loader()) {\n+  \/\/ Inline classes encapsulate two mirror objects, a value mirror (primitive value mirror)\n+  \/\/ and a reference mirror (primitive class mirror), skip over scratch mirror allocation\n+  \/\/ for inline classes, they will not be part of shared archive and will be created while\n+  \/\/ restoring unshared fileds. Refer Klass::restore_unshareable_info() for more details.\n+  if (k->is_inline_klass() ||\n+      (k->class_loader() != nullptr &&\n+       k->class_loader() != SystemDictionary::java_platform_loader() &&\n+       k->class_loader() != SystemDictionary::java_system_loader())) {\n@@ -1199,0 +1247,20 @@\n+oop java_lang_Class::primary_mirror(oop java_class) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_primary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_primary_mirror_offset, mirror);\n+}\n+\n+oop java_lang_Class::secondary_mirror(oop java_class) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_secondary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n+}\n+\n@@ -1283,0 +1351,1 @@\n+  bool is_Q_descriptor = false;\n@@ -1288,0 +1357,1 @@\n+    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1294,1 +1364,3 @@\n-  if (is_instance)  st->print(\"L\");\n+  if (is_instance)  {\n+    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n+  }\n@@ -1315,2 +1387,7 @@\n-      const char* sigstr = k->signature_name();\n-      int         siglen = (int) strlen(sigstr);\n+      const char* sigstr;\n+      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n+        sigstr = InlineKlass::cast(k)->val_signature_name();\n+      } else {\n+        sigstr = k->signature_name();\n+      }\n+      int siglen = (int) strlen(sigstr);\n@@ -1404,0 +1481,2 @@\n+  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n+  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n@@ -2621,1 +2700,1 @@\n-      if (method->name() == vmSymbols::object_initializer_name() &&\n+      if (method->is_object_constructor() &&\n@@ -4208,1 +4287,1 @@\n-  return (flags(mname) & (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) > 0;\n+  return (flags(mname) & (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) > 0;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":90,"deletions":11,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -231,0 +231,3 @@\n+  static int _primary_mirror_offset;\n+  static int _secondary_mirror_offset;\n+\n@@ -244,0 +247,3 @@\n+  static void set_primary_mirror(oop java_class, oop comp_mirror);\n+  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n+\n@@ -258,0 +264,1 @@\n+  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -287,0 +294,3 @@\n+  static int component_mirror_offset()     { CHECK_INIT(_component_mirror_offset); }\n+  static int primary_mirror_offset()       { CHECK_INIT(_primary_mirror_offset); }\n+  static int secondary_mirror_offset()     { CHECK_INIT(_secondary_mirror_offset); }\n@@ -294,0 +304,5 @@\n+  static oop  primary_mirror(oop java_class);\n+  static oop  secondary_mirror(oop java_class);\n+  static bool is_primary_mirror(oop java_class);\n+  static bool is_secondary_mirror(oop java_class);\n+\n@@ -299,2 +314,0 @@\n-  static int component_mirror_offset() { return _component_mirror_offset; }\n-\n@@ -1283,1 +1296,1 @@\n-    MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ constructor\n+    MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ constructor\n@@ -1288,0 +1301,1 @@\n+    MN_FLATTENED             = 0x00400000, \/\/ flattened field\n@@ -1825,1 +1839,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -310,0 +310,18 @@\n+inline bool java_lang_Class::is_primary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == primary_mirror(java_class);\n+  } else {\n+    return true;\n+  }\n+}\n+\n+inline bool java_lang_Class::is_secondary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == secondary_mirror(java_class);\n+  } else {\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#define INLINE_TYPE_MAJOR_VERSION                       56\n@@ -279,1 +280,1 @@\n-    \/\/ We need to skip the following four for bootstraping\n+    \/\/ We need to skip the following four for bootstrapping\n@@ -498,0 +499,7 @@\n+    case WRONG_INLINE_TYPE:\n+      ss->print(\"Type \");\n+      _type.details(ss);\n+      ss->print(\" and type \");\n+      _expected.details(ss);\n+      ss->print(\" must be identical inline types.\");\n+      break;\n@@ -592,0 +600,8 @@\n+VerificationType reference_or_inline_type(InstanceKlass* klass) {\n+  if (klass->is_inline_klass()) {\n+    return VerificationType::inline_type(klass->name());\n+  } else {\n+    return VerificationType::reference_type(klass->name());\n+  }\n+}\n+\n@@ -595,1 +611,1 @@\n-  _this_type = VerificationType::reference_type(klass->name());\n+  _this_type = reference_or_inline_type(klass);\n@@ -1035,1 +1051,1 @@\n-          if (!atype.is_reference_array()) {\n+          if (!atype.is_nonscalar_array()) {\n@@ -1208,1 +1224,1 @@\n-          if (!atype.is_reference_array()) {\n+          if (!atype.is_nonscalar_array()) {\n@@ -1608,1 +1624,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1613,1 +1629,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1664,1 +1680,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1676,1 +1692,1 @@\n-          if (_method->name() == vmSymbols::object_initializer_name() &&\n+          if (_method->is_object_constructor() &&\n@@ -1696,0 +1712,11 @@\n+        case Bytecodes::_withfield :\n+          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n+            class_format_error(\n+              \"withfield not supported by this class file version (%d.%d), class %s\",\n+              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n+            return;\n+          }\n+          \/\/ pass FALSE, operand can't be an array type for withfield.\n+          verify_field_instructions(\n+            &bcs, &current_frame, cp, false, CHECK_VERIFY(this));\n+          no_control_flow = false; break;\n@@ -1699,4 +1726,0 @@\n-          verify_invoke_instructions(\n-            &bcs, code_length, &current_frame, (bci >= ex_min && bci < ex_max),\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n-          no_control_flow = false; break;\n@@ -1707,1 +1730,1 @@\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n+            &this_uninit, cp, &stackmap_table, CHECK_VERIFY(this));\n@@ -1725,0 +1748,22 @@\n+        case Bytecodes::_aconst_init :\n+        {\n+          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n+            class_format_error(\n+              \"aconst_init not supported by this class file version (%d.%d), class %s\",\n+              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n+            return;\n+          }\n+          index = bcs.get_index_u2();\n+          verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));\n+          VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));\n+          if (!ref_type.is_object()) {\n+            verify_error(ErrorContext::bad_type(bci,\n+                TypeOrigin::cp(index, ref_type)),\n+                \"Illegal aconst_init instruction\");\n+            return;\n+          }\n+          VerificationType inline_type =\n+            VerificationType::change_ref_to_inline_type(ref_type);\n+          current_frame.push_stack(inline_type, CHECK_VERIFY(this));\n+          no_control_flow = false; break;\n+        }\n@@ -1765,3 +1810,3 @@\n-        case Bytecodes::_monitorexit :\n-          current_frame.pop_stack(\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+        case Bytecodes::_monitorexit : {\n+          VerificationType ref = current_frame.pop_stack(\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1769,0 +1814,1 @@\n+        }\n@@ -2033,0 +2079,1 @@\n+\n@@ -2147,1 +2194,1 @@\n-            | (1 << JVM_CONSTANT_String)  | (1 << JVM_CONSTANT_Class)\n+            | (1 << JVM_CONSTANT_String) | (1 << JVM_CONSTANT_Class)\n@@ -2322,1 +2369,1 @@\n-    (!allow_arrays || !ref_class_type.is_array())) {\n+      (!allow_arrays || !ref_class_type.is_array())) {\n@@ -2329,0 +2376,1 @@\n+\n@@ -2358,0 +2406,11 @@\n+    case Bytecodes::_withfield: {\n+      for (int i = n - 1; i >= 0; i--) {\n+        current_frame->pop_stack(field_type[i], CHECK_VERIFY(this));\n+      }\n+      \/\/ Check that the receiver is a subtype of the referenced class.\n+      current_frame->pop_stack(target_class_type, CHECK_VERIFY(this));\n+      VerificationType target_inline_type =\n+        VerificationType::change_ref_to_inline_type(target_class_type);\n+      current_frame->push_stack(target_inline_type, CHECK_VERIFY(this));\n+      break;\n+    }\n@@ -2779,1 +2838,1 @@\n-    bool in_try_block, bool *this_uninit, VerificationType return_type,\n+    bool in_try_block, bool *this_uninit,\n@@ -2811,1 +2870,1 @@\n-  \/\/ Get referenced class type\n+  \/\/ Get referenced class\n@@ -2877,3 +2936,7 @@\n-    \/\/ Make sure <init> can only be invoked by invokespecial\n-    if (opcode != Bytecodes::_invokespecial ||\n-        method_name != vmSymbols::object_initializer_name()) {\n+    \/\/ Make sure:\n+    \/\/   <init> can only be invoked by invokespecial.\n+    \/\/   <vnew> can only be invoked by invokestatic.\n+    if (!((opcode == Bytecodes::_invokestatic &&\n+           method_name == vmSymbols::inline_factory_name()) ||\n+         (opcode == Bytecodes::_invokespecial &&\n+          method_name == vmSymbols::object_initializer_name()))) {\n@@ -2887,1 +2950,1 @@\n-                  current_class()->super()->name()))) {\n+                  current_class()->super()->name()))) { \/\/ super() can never be an inline_type.\n@@ -2972,3 +3035,1 @@\n-      \/\/ <init> method must have a void return type\n-      \/* Unreachable?  Class file parser verifies that methods with '<' have\n-       * void return *\/\n+      \/\/ an <init> method must have a void return type\n@@ -2987,0 +3048,7 @@\n+  } else { \/\/ no return type\n+    \/\/ <vnew> method may not have a void return type\n+    if (method_name == vmSymbols::inline_factory_name()) {\n+      verify_error(ErrorContext::bad_code(bci),\n+          \"Return type must be non-void in <vnew> static factory method\");\n+      return;\n+    }\n@@ -3034,1 +3102,2 @@\n-    \/\/ add one dimension to component with 'L' prepended and ';' postpended.\n+    char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_PRIMITIVE_OBJECT : JVM_SIGNATURE_CLASS;\n+    \/\/ add one dimension to component with 'L' or 'Q' prepended and ';' appended.\n@@ -3038,1 +3107,1 @@\n-                         JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);\n+                         JVM_SIGNATURE_ARRAY, Q_or_L, component_name);\n@@ -3080,1 +3149,1 @@\n-    index, VerificationType::reference_check(), CHECK_VERIFY(this));\n+    index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -3117,1 +3186,1 @@\n-    VerificationType::reference_check(), CHECK_VERIFY(this));\n+    VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":100,"deletions":31,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  do_klass(ValueObjectMethods_klass,                    java_lang_runtime_ValueObjectMethods                  ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  template(tag_preload,                               \"Preload\")                                  \\\n@@ -391,0 +392,1 @@\n+  template(inline_factory_name,                       \"<vnew>\")                                   \\\n@@ -532,0 +534,2 @@\n+  template(default_value_name,                        \".default\")                                 \\\n+  template(empty_marker_name,                         \".empty\")                                   \\\n@@ -608,0 +612,1 @@\n+  template(class_class_signature,                     \"(Ljava\/lang\/Class;)Ljava\/lang\/Class;\")     \\\n@@ -621,0 +626,1 @@\n+  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\") \\\n@@ -764,0 +770,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n@@ -790,0 +798,5 @@\n+  template(java_lang_runtime_ValueObjectMethods,            \"java\/lang\/runtime\/ValueObjectMethods\")               \\\n+  template(isSubstitutable_name,                            \"isSubstitutable\")                                    \\\n+  template(valueObjectHashCode_name,                        \"valueObjectHashCode\")                                \\\n+  template(jdk_internal_value_PrimitiveClass,               \"jdk\/internal\/value\/PrimitiveClass\")                  \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -519,1 +519,2 @@\n-    if (klass->is_array_klass()) {\n+    \/\/ CMH: Valhalla flat arrays can split this work up, but for now, doesn't\n+    if (klass->is_array_klass() && !klass->is_flatArray_klass()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  bool is_withfield() const                      { return java_code() == Bytecodes::_withfield; }\n@@ -266,1 +267,2 @@\n-                                                          is_putstatic(); }\n+                                                          is_putstatic()  ||\n+                                                          is_withfield(); }\n@@ -299,0 +301,9 @@\n+class Bytecode_aconst_init: public Bytecode {\n+ public:\n+  Bytecode_aconst_init(Method* method, address bcp): Bytecode(method, bcp) { verify(); }\n+  void verify() const { assert(java_code() == Bytecodes::_aconst_init, \"check aconst_init\"); }\n+\n+  \/\/ Returns index\n+  long index() const   { return get_index_u2(Bytecodes::_aconst_init); };\n+};\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -609,0 +609,1 @@\n+    case Bytecodes::_withfield:\n@@ -640,0 +641,1 @@\n+    case Bytecodes::_aconst_init:\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+    case Bytecodes::_withfield:\n@@ -1114,0 +1115,1 @@\n+    case Bytecodes::_checkcast:\n@@ -1134,0 +1136,1 @@\n+    case Bytecodes::_withfield:\n@@ -1174,1 +1177,7 @@\n-    os->print(\"\\\" is null\");\n+    address code_base = _method->constMethod()->code_base();\n+    Bytecodes::Code code = Bytecodes::java_code_at(_method, code_base + bci);\n+    if (code == Bytecodes::_aastore) {\n+      os->print(\"\\\" is null or is a null-free array and there's an attempt to store null in it\");\n+    } else {\n+      os->print(\"\\\" is null\");\n+    }\n@@ -1424,0 +1433,1 @@\n+    case Bytecodes::_withfield:\n@@ -1436,0 +1446,5 @@\n+    case Bytecodes::_checkcast: {\n+        int cp_index = Bytes::get_Java_u2(code_base + pos);\n+        ConstantPool* cp = _method->constants();\n+        os->print(\"Cannot cast to null-free type \\\"%s\\\"\", cp->klass_at_noresolve(cp_index)->as_C_string());\n+      } break;\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+         byte == Bytecodes::_withfield ||\n@@ -968,1 +969,2 @@\n-  bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic || byte == Bytecodes::_nofast_putfield);\n+  bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic ||\n+                    byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);\n@@ -974,0 +976,15 @@\n+\n+  if (byte == Bytecodes::_withfield && !resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode withfield cannot be used on identity class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n+  if (is_put && !is_static && byte != Bytecodes::_withfield && resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode putfield cannot be used on primitive class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n@@ -1005,0 +1022,2 @@\n+    \/\/ (3) by withfield when field is in a value type and the\n+    \/\/     selected class and current class are nest mates.\n@@ -1008,6 +1027,15 @@\n-        ResourceMark rm(THREAD);\n-        stringStream ss;\n-        ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n-                 is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n-                current_klass->external_name());\n-        THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        \/\/ If byte code is a withfield check if they are nestmates.\n+        bool are_nestmates = false;\n+        if (sel_klass->is_instance_klass() &&\n+            InstanceKlass::cast(sel_klass)->is_inline_klass() &&\n+            current_klass->is_instance_klass()) {\n+          are_nestmates = InstanceKlass::cast(current_klass)->has_nestmate_access_to(InstanceKlass::cast(sel_klass), THREAD);\n+        }\n+        if (!are_nestmates) {\n+          ResourceMark rm(THREAD);\n+          stringStream ss;\n+          ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n+                   is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n+                    current_klass->external_name());\n+          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        }\n@@ -1021,1 +1049,1 @@\n-                                                   !m->is_static_initializer());\n+                                                   !m->is_class_initializer());\n@@ -1024,1 +1052,1 @@\n-                                                     !m->is_object_initializer());\n+                                                     !m->is_object_constructor());\n@@ -1152,0 +1180,2 @@\n+  \/\/ Since this method is never inherited from a super, any appearance here under\n+  \/\/ the wrong class would be an error.\n@@ -1223,1 +1253,1 @@\n-      \/\/ check if the method is not <init>\n+      \/\/ check if the method is not <init>, which is never inherited\n@@ -1645,2 +1675,2 @@\n-                             const methodHandle& attached_method,\n-                             Bytecodes::Code byte, TRAPS) {\n+                                  const methodHandle& attached_method,\n+                                  Bytecodes::Code byte, bool check_null_and_abstract, TRAPS) {\n@@ -1651,0 +1681,1 @@\n+  Klass* recv_klass = recv.is_null() ? defc : recv->klass();\n@@ -1653,2 +1684,2 @@\n-      resolve_virtual_call(result, recv, recv->klass(), link_info,\n-                           \/*check_null_and_abstract=*\/true, CHECK);\n+      resolve_virtual_call(result, recv, recv_klass, link_info,\n+                           check_null_and_abstract, CHECK);\n@@ -1657,2 +1688,2 @@\n-      resolve_interface_call(result, recv, recv->klass(), link_info,\n-                             \/*check_null_and_abstract=*\/true, CHECK);\n+      resolve_interface_call(result, recv, recv_klass, link_info,\n+                             check_null_and_abstract, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":47,"deletions":16,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-    int  cp_index    = Bytes::get_Java_u2(p);\n+    int cp_index    = Bytes::get_Java_u2(p);\n@@ -217,1 +217,0 @@\n-\n@@ -435,1 +434,1 @@\n-                  if (!method->is_static_initializer()) {\n+                  if (!method->is_class_initializer()) {\n@@ -439,1 +438,1 @@\n-                  if (!method->is_object_initializer()) {\n+                  if (!method->is_object_constructor()) {\n@@ -451,0 +450,1 @@\n+      case Bytecodes::_withfield     : \/\/ fall through but may require more checks for correctness\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -101,0 +103,23 @@\n+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Symbol* name = nullptr;\n+  char *name_str = element_klass->name()->as_C_string();\n+  int len = element_klass->name()->utf8_length();\n+  char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);\n+  int idx = 0;\n+  new_str[idx++] = JVM_SIGNATURE_ARRAY;\n+  if (element_klass->is_instance_klass()) { \/\/ it could be an array or simple type\n+    if (qdesc) {\n+      new_str[idx++] = JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+    } else {\n+      new_str[idx++] = JVM_SIGNATURE_CLASS;\n+    }\n+  }\n+  memcpy(&new_str[idx], name_str, len * sizeof(char));\n+  idx += len;\n+  if (element_klass->is_instance_klass()) {\n+    new_str[idx++] = JVM_SIGNATURE_ENDCLASS;\n+  }\n+  new_str[idx++] = '\\0';\n+  return SymbolTable::new_symbol(new_str);\n+}\n@@ -138,0 +163,4 @@\n+oop ArrayKlass::component_mirror() const {\n+  return java_lang_Class::component_mirror(java_mirror());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,0 +45,7 @@\n+  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n+                                    \/\/ The element type must be registered for both object arrays\n+                                    \/\/ (incl. object arrays with value type elements) and value type\n+                                    \/\/ arrays containing flattened value types. However, the element\n+                                    \/\/ type must not be registered for arrays of primitive types.\n+                                    \/\/ TODO: Update the class hierarchy so that element klass appears\n+                                    \/\/ only in array that contain non-primitive types.\n@@ -51,0 +58,3 @@\n+  \/\/ Create array_name for element klass\n+  static Symbol* create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS);\n+\n@@ -52,0 +62,11 @@\n+  \/\/ Instance variables\n+  virtual Klass* element_klass() const      { return _element_klass; }\n+  virtual void set_element_klass(Klass* k)  { _element_klass = k; }\n+\n+  \/\/ Compiler\/Interpreter offset\n+  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ArrayKlass, _element_klass)); }\n+\n+  \/\/ Are loads and stores to this concrete array type atomic?\n+  \/\/ Note that Object[] is naturally atomic, but its subtypes may not be.\n+  virtual bool element_access_is_atomic() { return true; }\n+\n@@ -102,0 +123,2 @@\n+  oop component_mirror() const;\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  \/\/ For temporary use while constructing constant pool\n+  \/\/ For temporary use while constructing constant pool. Used during a retransform\/class redefinition as well.\n@@ -281,0 +281,9 @@\n+  void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {\n+      release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);\n+\n+      assert((name_index & 0xffff0000) == 0, \"must be\");\n+      assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n+      *int_at_addr(which) =\n+        build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -125,1 +125,3 @@\n-                                       bool is_volatile) {\n+                                       bool is_volatile,\n+                                       bool is_inlined,\n+                                       bool is_null_free_inline_type) {\n@@ -130,0 +132,1 @@\n+  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n@@ -132,1 +135,3 @@\n-                  ((is_final    ? 1 : 0) << is_final_shift),\n+                  ((is_final    ? 1 : 0) << is_final_shift) |\n+                  ((is_inlined  ? 1 : 0) << is_inlined_shift) |\n+                  ((is_null_free_inline_type ? 1 : 0) << is_null_free_inline_type_shift),\n@@ -290,0 +295,1 @@\n+      invoke_code = Bytecodes::_invokevirtual;\n@@ -305,1 +311,1 @@\n-    set_bytecode_2(Bytecodes::_invokevirtual);\n+    set_bytecode_2(invoke_code);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-\/\/ _flags     [tos|0|F=1|0|0|0|f|v|0 |0000|field_index] (for field entries)\n+\/\/ _flags     [tos|0|F=1|0|I|i|f|v|0 |0000|field_index] (for field entries)\n@@ -78,0 +78,2 @@\n+\/\/ I  flag true if field is a null free inline type (must never be null)\n+\/\/ i  flag true if field is inlined\n@@ -185,0 +187,1 @@\n+    is_null_free_inline_type_shift = 24,  \/\/ (I) is the field a null free inline type (must never be null)\n@@ -186,0 +189,1 @@\n+    is_inlined_shift           = 23,  \/\/ (i) is the field inlined?\n@@ -224,1 +228,3 @@\n-    bool            is_volatile                  \/\/ the field is volatile\n+    bool            is_volatile,                 \/\/ the field is volatile\n+    bool            is_inlined,                  \/\/ the field is inlined\n+    bool            is_null_free_inline_type     \/\/ the field is an inline type (must never be null)\n@@ -301,0 +307,1 @@\n+      case Bytecodes::_withfield       :    \/\/ fall through\n@@ -328,0 +335,1 @@\n+  int       f2_as_offset() const                 { assert(is_field_entry(),  \"\"); return (int)_f2; }\n@@ -333,0 +341,1 @@\n+  bool is_inlined() const                        { return (_flags & (1 << is_inlined_shift))        != 0; }\n@@ -342,0 +351,1 @@\n+  bool is_null_free_inline_type() const          { return (_flags & (1 << is_null_free_inline_type_shift)) != 0; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -610,2 +611,23 @@\n-  \/\/ as implemented in the classic virtual machine; return 0 if object is null\n-  return handle == nullptr ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;\n+  \/\/ as implemented in the classic virtual machine; return 0 if object is nullptr\n+  if (handle == nullptr) {\n+    return 0;\n+  }\n+  oop obj = JNIHandles::resolve_non_null(handle);\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+      JavaValue result(T_INT);\n+      JavaCallArguments args;\n+      Handle ho(THREAD, obj);\n+      args.push_oop(ho);\n+      methodHandle method(THREAD, Universe::value_object_hash_code_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in hashCode\", e, false);\n+        }\n+      }\n+      return result.get_jint();\n+  } else {\n+    return ObjectSynchronizer::FastHashCode(THREAD, obj);\n+  }\n@@ -663,0 +685,1 @@\n+       klass->is_inline_klass() ||\n@@ -1176,1 +1199,2 @@\n-    size = InstanceKlass::cast(klass)->local_interfaces()->length();\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    size = ik->local_interfaces()->length();\n@@ -1178,1 +1202,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n@@ -1189,1 +1213,2 @@\n-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n+      InstanceKlass* ik = InstanceKlass::cast(klass);\n+      Klass* k = ik->local_interfaces()->at(index);\n@@ -1224,0 +1249,13 @@\n+JVM_ENTRY(jboolean, JVM_IsIdentityClass(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (EnableValhalla) {\n+    return k->is_array_klass() || k->is_identity_class();\n+  } else {\n+    return k->is_interface() ? JNI_FALSE : JNI_TRUE;\n+  }\n+JVM_END\n+\n@@ -1839,0 +1877,2 @@\n+  bool is_ctor = (method->is_object_constructor() ||\n+                  method->is_static_vnew_factory());\n@@ -1840,1 +1880,1 @@\n-    return (method->is_initializer() && !method->is_static());\n+    return is_ctor;\n@@ -1842,1 +1882,3 @@\n-    return  (!method->is_initializer() && !method->is_overpass());\n+    return (!is_ctor &&\n+            !method->is_class_initializer() &&\n+            !method->is_overpass());\n@@ -1905,0 +1947,2 @@\n+        assert(method->is_object_constructor() ||\n+               method->is_static_vnew_factory(), \"must be\");\n@@ -2187,3 +2231,1 @@\n-  if (!m->is_initializer() || m->is_static()) {\n-    method = Reflection::new_method(m, true, CHECK_NULL);\n-  } else {\n+  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n@@ -2191,0 +2233,2 @@\n+  } else {\n+    method = Reflection::new_method(m, true, CHECK_NULL);\n@@ -2461,0 +2505,37 @@\n+\/\/ Arrays support \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == nullptr) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  return ArrayKlass::cast(k)->element_access_is_atomic();\n+JVM_END\n+\n+JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == nullptr) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vk = FlatArrayKlass::cast(k);\n+    if (!vk->element_access_is_atomic()) {\n+      \/**\n+       * Need to decide how to implement:\n+       *\n+       * 1) Change to objArrayOop layout, therefore oop->klass() differs so\n+       * then \"<atomic>[Qfoo;\" klass needs to subclass \"[Qfoo;\" to pass through\n+       * \"checkcast\" & \"instanceof\"\n+       *\n+       * 2) Use extra header in the flatArrayOop to flag atomicity required and\n+       * possibly per instance lock structure. Said info, could be placed in\n+       * \"trailer\" rather than disturb the current arrayOop\n+       *\/\n+      Unimplemented();\n+    }\n+  }\n+  return array;\n+JVM_END\n+\n@@ -2623,1 +2704,1 @@\n-  return method->name() == vmSymbols::object_initializer_name();\n+  return method->is_object_constructor();\n@@ -3461,0 +3542,4 @@\n+JVM_LEAF(jboolean, JVM_IsValhallaEnabled(void))\n+  return EnableValhalla ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n@@ -3542,1 +3627,1 @@\n-    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n+    objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3562,0 +3647,1 @@\n+  objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3563,1 +3649,0 @@\n-  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":98,"deletions":13,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -918,2 +919,1 @@\n-  write_u2(ik()->access_flags().get_flags() & JVM_RECOGNIZED_CLASS_MODIFIERS);\n-\n+  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY));\n@@ -932,0 +932,1 @@\n+\n@@ -1030,0 +1031,1 @@\n+      case Bytecodes::_withfield       :  \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -62,0 +63,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -68,0 +70,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -1883,0 +1886,87 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return nullptr;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return nullptr;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+class CollectOops : public BasicOopIterateClosure {\n+ public:\n+  GrowableArray<Handle>* array;\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < array->length(); i++) {\n+      result_array->obj_at_put(i, array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    \/\/ Value might be oop, but JLS can't see as Object, just iterate through it...\n+    if (oh != nullptr && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      array->append(oh);\n+    }\n+  }\n+\n+  void do_oop(oop* o) { add_oop(HeapAccess<>::oop_load(o)); }\n+  void do_oop(narrowOop* v) { add_oop(HeapAccess<>::oop_load(v)); }\n+};\n+\n+\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  GrowableArray<Handle>* array = new GrowableArray<Handle>(128);\n+  CollectOops collectOops;\n+  collectOops.array = array;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* array = new GrowableArray<Handle>(128);\n+  CollectOops collectOops;\n+  collectOops.array = array;\n+  StackFrameStream sfs(thread, false \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, nullptr, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\n@@ -2768,0 +2858,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  inline void append_path(const char* path) { _path->append_value(path); }\n@@ -298,1 +299,1 @@\n-  static int process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase);\n+  static int process_patch_mod_option(const char* patch_mod_tail);\n@@ -333,2 +334,2 @@\n-  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin);\n-  static jint finalize_vm_init_args(bool patch_mod_javabase);\n+  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin);\n+  static jint finalize_vm_init_args();\n@@ -488,1 +489,3 @@\n-  static void add_patch_mod_prefix(const char *module_name, const char *path, bool* patch_mod_javabase);\n+  static void add_patch_mod_prefix(const char *module_name, const char *path, bool allow_append);\n+  static bool patch_mod_javabase();\n+  static int finalize_patch_module();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -800,0 +800,18 @@\n+  notproduct(bool, PrintInlineLayout, false,                                \\\n+          \"Print field layout for each inline type\")                        \\\n+                                                                            \\\n+  notproduct(bool, PrintFlatArrayLayout, false,                             \\\n+          \"Print array layout for each inline type array\")                  \\\n+                                                                            \\\n+  product(intx, FlatArrayElementMaxSize, -1,                                \\\n+          \"Max size for flattening inline array elements, <0 no limit\")     \\\n+                                                                            \\\n+  product(intx, InlineFieldMaxFlatSize, 128,                                \\\n+          \"Max size for flattening inline type fields, <0 no limit\")        \\\n+                                                                            \\\n+  product(intx, FlatArrayElementMaxOops, 4,                                 \\\n+          \"Max nof embedded object references in an inline type to flatten, <0 no limit\")  \\\n+                                                                            \\\n+  product(bool, InlineArrayAtomicAccess, false,                             \\\n+          \"Atomic inline array accesses by-default, for all inline arrays\") \\\n+                                                                            \\\n@@ -1961,0 +1979,23 @@\n+  product(bool, EnableValhalla, true,                                       \\\n+          \"Enable experimental Valhalla features\")                          \\\n+                                                                            \\\n+  product(bool, EnablePrimitiveClasses, false,                              \\\n+          \"Enable experimental Valhalla primitive classes\")                 \\\n+                                                                            \\\n+  product_pd(bool, InlineTypePassFieldsAsArgs,                              \\\n+          \"Pass each inline type field as an argument at calls\")            \\\n+                                                                            \\\n+  product_pd(bool, InlineTypeReturnedAsFields,                              \\\n+          \"Return fields instead of an inline type reference\")              \\\n+                                                                            \\\n+  develop(bool, StressCallingConvention, false,                             \\\n+          \"Stress the scalarized calling convention.\")                      \\\n+                                                                            \\\n+  product(bool, UseArrayMarkWordCheck, NOT_LP64(false) LP64_ONLY(true),     \\\n+          \"Use bits in the mark word to check for flat\/null-free arrays\")   \\\n+                                                                            \\\n+  product(ccstrlist, ForceNonTearable, \"\", DIAGNOSTIC,                      \\\n+          \"List of inline classes which are forced to be atomic \"           \\\n+          \"(whitespace and commas separate names, \"                         \\\n+          \"and leading and trailing stars '*' are wildcards)\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+  VMRegImpl::set_regName();       \/\/ need this before generate_stubs (for printing oop maps).\n@@ -144,1 +145,0 @@\n-  VMRegImpl::set_regName();  \/\/ need this before generate_stubs (for printing oop maps).\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -55,0 +56,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -350,1 +352,5 @@\n-    return oopFactory::new_objArray(k, length, THREAD);\n+    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+      return oopFactory::new_valueArray(k, length, THREAD);\n+    } else {\n+      return oopFactory::new_objArray(k, length, THREAD);\n+    }\n@@ -391,1 +397,5 @@\n-  klass = klass->array_klass(dim, CHECK_NULL);\n+  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+    klass = InlineKlass::cast(klass)->value_array_klass(dim, CHECK_NULL);\n+  } else {\n+    klass = klass->array_klass(dim, CHECK_NULL);\n+  }\n@@ -768,3 +778,0 @@\n-  if (log_is_enabled(Debug, class, resolve)) {\n-    trace_class_resolution(nt);\n-  }\n@@ -776,2 +783,1 @@\n-  assert(!method()->is_initializer() ||\n-         (for_constant_pool_access && method()->is_static()),\n+  assert(!method()->name()->starts_with('<') || for_constant_pool_access,\n@@ -826,1 +832,3 @@\n-  assert(method()->is_initializer(), \"should call new_method instead\");\n+  assert(method()->is_object_constructor() ||\n+         method()->is_static_vnew_factory(),\n+         \"should call new_method instead\");\n@@ -879,1 +887,2 @@\n-  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n+  int modifiers = fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n+  java_lang_reflect_Field::set_modifiers(rh(), modifiers);\n@@ -994,2 +1003,4 @@\n-    \/\/ no need to resolve if method is private or <init>\n-    if (reflected_method->is_private() || reflected_method->name() == vmSymbols::object_initializer_name()) {\n+    \/\/ no need to resolve if method is private, <init> or <vnew>\n+    if (reflected_method->is_private() ||\n+        reflected_method->name() == vmSymbols::object_initializer_name() ||\n+        reflected_method->name() == vmSymbols::inline_factory_name()) {\n@@ -1150,0 +1161,2 @@\n+  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_inline_klass()) {\n+    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_PRIMITIVE_OBJECT;\n@@ -1177,1 +1190,0 @@\n-  assert(method->name() == vmSymbols::object_initializer_name(), \"invalid constructor\");\n@@ -1184,0 +1196,18 @@\n+\n+  \/\/ Special case for factory methods\n+  if (!method->signature()->is_void_method_signature()) {\n+    assert(klass->is_inline_klass(), \"inline classes must use factory methods\");\n+    assert(method->name() == vmSymbols::inline_factory_name(), \"wrong factory method name\");\n+    Handle no_receiver; \/\/ null instead of receiver\n+    BasicType rtype;\n+    if (klass->is_hidden()) {\n+      rtype = T_OBJECT;\n+    } else {\n+      rtype = T_PRIMITIVE_OBJECT;\n+    }\n+    return invoke(klass, method, no_receiver, override, ptypes, rtype, args, false, CHECK_NULL);\n+  }\n+\n+  \/\/ main branch of code creates a non-inline object:\n+  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n+  assert(method->name() == vmSymbols::object_initializer_name(), \"wrong constructor name\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -173,0 +173,3 @@\n+address StubRoutines::_load_inline_type_fields_in_regs = nullptr;\n+address StubRoutines::_store_inline_type_fields_to_buf = nullptr;\n+\n@@ -540,0 +543,1 @@\n+  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -264,0 +264,3 @@\n+  static address _load_inline_type_fields_in_regs;\n+  static address _store_inline_type_fields_to_buf;\n+\n@@ -480,0 +483,3 @@\n+\n+  static address load_inline_type_fields_in_regs() { return _load_inline_type_fields_in_regs; }\n+  static address store_inline_type_fields_to_buf() { return _store_inline_type_fields_to_buf; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -228,1 +230,1 @@\n-  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ObjArrayKlass*)                        \\\n+  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ArrayKlass*)                        \\\n@@ -1230,0 +1232,1 @@\n+           declare_type(FlatArrayKlass, ArrayKlass)                       \\\n@@ -1233,0 +1236,1 @@\n+        declare_type(InlineKlass, InstanceKlass)                          \\\n@@ -1608,0 +1612,1 @@\n+  declare_c2_type(MachVEPNode, MachIdealNode)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -716,2 +717,2 @@\n-     * with special names ({@value ConstantDescs#INIT_NAME} and {@value\n-     * ConstantDescs#CLASS_INIT_NAME}).\n+     * with special names ({@value ConstantDescs#INIT_NAME},\n+     * {@value ConstantDescs#VNEW_NAME} and {@value ConstantDescs#CLASS_INIT_NAME}).\n@@ -1641,0 +1642,1 @@\n+            assert PrimitiveClass.isPrimaryType(lookupClass);\n@@ -2821,0 +2823,2 @@\n+         *\n+         *\n@@ -2836,0 +2840,3 @@\n+            if (type.returnType() != void.class) {\n+                throw new NoSuchMethodException(\"Constructors must have void return type: \" + refc.getName());\n+            }\n@@ -3525,1 +3532,1 @@\n-            assert(ctor.isConstructor());\n+            assert(ctor.isObjectConstructor() || ctor.isStaticValueFactoryMethod());\n@@ -3528,1 +3535,10 @@\n-            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+            Class<?> defc = c.getDeclaringClass();\n+            if (ctor.isObjectConstructor()) {\n+                assert(ctor.getMethodType().returnType() == void.class);\n+                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n+            } else {\n+                \/\/ static init factory is a static method\n+                assert(ctor.isMethod() && ctor.getMethodType().returnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n+                assert(!MethodHandleNatives.isCallerSensitive(ctor));  \/\/ must not be caller-sensitive\n+                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n+            }\n@@ -3773,1 +3789,1 @@\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial) {\n+            if (isIllegalMethodName(refKind, name)) {\n@@ -3776,0 +3792,1 @@\n+\n@@ -3795,0 +3812,12 @@\n+        \/*\n+         * \"<init>\" can only be invoked via invokespecial\n+         * \"<vnew>\" factory can only invoked via invokestatic\n+         *\/\n+        boolean isIllegalMethodName(byte refKind, String name) {\n+            if (name.startsWith(\"<\")) {\n+                return MemberName.VALUE_FACTORY_NAME.equals(name) ? refKind != REF_invokeStatic\n+                                                                  : refKind != REF_newInvokeSpecial;\n+            }\n+            return false;\n+        }\n+\n@@ -3797,2 +3826,3 @@\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial)\n-                throw new NoSuchMethodException(\"illegal method name: \"+name);\n+            if (isIllegalMethodName(refKind, name)) {\n+                throw new NoSuchMethodException(\"illegal method name: \" + name + \" \" + refKind);\n+            }\n@@ -3902,1 +3932,1 @@\n-            if (!fullPrivilegeLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && PrimitiveClass.asPrimaryType(defc) != PrimitiveClass.asPrimaryType(refc)) {\n@@ -3910,1 +3940,1 @@\n-            if (m.isConstructor())\n+            if (m.isObjectConstructor())\n@@ -3989,1 +4019,1 @@\n-                               (defc == refc ||\n+                               (PrimitiveClass.asPrimaryType(defc) == PrimitiveClass.asPrimaryType(refc) ||\n@@ -3994,1 +4024,1 @@\n-                           (defc == refc ||\n+                           (PrimitiveClass.asPrimaryType(defc) == PrimitiveClass.asPrimaryType(refc) ||\n@@ -4071,1 +4101,0 @@\n-\n@@ -4220,1 +4249,1 @@\n-            assert(ctor.isConstructor());\n+            assert(ctor.isObjectConstructor());\n@@ -5126,1 +5155,1 @@\n-            if (value == null)\n+            if (!PrimitiveClass.isPrimitiveValueType(type) && value == null)\n@@ -5171,1 +5200,9 @@\n-        return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);\n+        if (type.isPrimitive()) {\n+            return zero(Wrapper.forPrimitiveType(type), type);\n+        } else if (PrimitiveClass.isPrimitiveValueType(type)) {\n+            \/\/ singleton default value\n+            Object value = UNSAFE.uninitializedDefaultValue(type);\n+            return identity(type).bindTo(value);\n+        } else {\n+            return zero(Wrapper.OBJECT, type);\n+        }\n@@ -5201,1 +5238,1 @@\n-        MethodType mtype = methodType(ptype, ptype);\n+        MethodType mtype = MethodType.methodType(ptype, ptype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":53,"deletions":16,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -508,1 +509,4 @@\n-             VarHandleShorts.FieldStaticReadOnly {\n+             VarHandleShorts.FieldStaticReadOnly,\n+             VarHandleValues.Array,\n+             VarHandleValues.FieldInstanceReadOnly,\n+             VarHandleValues.FieldStaticReadOnly {\n@@ -1679,0 +1683,6 @@\n+            \/\/ the field type (value) is mapped to the return type of MethodType\n+            \/\/ the receiver type is mapped to a parameter type of MethodType\n+            \/\/ So use the value type if it's a primitive class\n+            if (receiver != null && PrimitiveClass.isPrimitiveClass(receiver)) {\n+                receiver = PrimitiveClass.asValueType(receiver);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1857,0 +1857,2 @@\n+                case Opcodes.DEFAULT:\n+                case Opcodes.WITHFIELD:\n@@ -2469,0 +2471,1 @@\n+                case Opcodes.WITHFIELD:\n@@ -2475,3 +2478,1 @@\n-                        if (opcode < Opcodes.INVOKEVIRTUAL) {\n-                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n-                        } else {\n+                        if (opcode >= Opcodes.INVOKEVIRTUAL && opcode <= Opcodes.INVOKEINTERFACE) {\n@@ -2481,0 +2482,2 @@\n+                        } else {\n+                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n@@ -2515,0 +2518,1 @@\n+                case Opcodes.DEFAULT:\n@@ -3266,1 +3270,2 @@\n-                    if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n+                    char descType = methodDescriptor.charAt(currentMethodDescritorOffset);\n+                    if (descType == 'L' || descType == 'Q') {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -336,0 +336,1 @@\n+    int ACC_IDENTITY = 0x0020; \/\/ class\n@@ -340,0 +341,1 @@\n+    int ACC_VALUE = 0x0040; \/\/ class\n@@ -345,0 +347,1 @@\n+    int ACC_INLINE = 0x0100; \/\/ inline class\n@@ -347,0 +350,1 @@\n+    int ACC_PRIMITIVE = 0x0800; \/\/ class\n@@ -589,0 +593,2 @@\n+    int DEFAULT = 203; \/\/ visitTypeInsn\n+    int WITHFIELD = 204; \/\/ visitFieldInsn\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-                return internalize(\"L\" + c.getName() + \";\");\n+                return c.descriptorString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,0 +272,3 @@\n+        if (cl.isValue()) {\n+            throw new UnsupportedOperationException(\"newConstructorForExternalization does not support value classes\");\n+        }\n@@ -288,0 +291,3 @@\n+        if (cl.isValue()) {\n+            throw new UnsupportedOperationException(\"newConstructorForSerialization does not support value classes\");\n+        }\n@@ -347,0 +353,4 @@\n+        if (cl.isValue()) {\n+            throw new UnsupportedOperationException(\"newConstructorForSerialization does not support value classes\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.value.PrimitiveClass;\n+\n@@ -52,0 +54,1 @@\n+    private boolean    isStaticFactory;\n@@ -71,0 +74,1 @@\n+        boolean isStaticFactory = declaringClass.isValue();\n@@ -75,1 +79,1 @@\n-                     Void.TYPE,\n+                     isStaticFactory ? PrimitiveClass.asValueType(declaringClass) : Void.TYPE,\n@@ -78,0 +82,1 @@\n+                     isStaticFactory,\n@@ -90,0 +95,1 @@\n+                                       boolean isStaticFactory,\n@@ -100,0 +106,1 @@\n+        this.isStaticFactory = isStaticFactory;\n@@ -302,1 +309,1 @@\n-                asm.emitConstantPoolUTF8(getClassName(c, false));\n+                asm.emitConstantPoolUTF8(getClassName(c, true));\n@@ -392,1 +399,1 @@\n-        if (isConstructor) {\n+        if (isConstructor && !isStaticFactory) {\n@@ -582,1 +589,1 @@\n-        if (isConstructor) {\n+        if (isConstructor && !isStaticFactory) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorGenerator.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-\n@@ -275,0 +274,2 @@\n+    exports jdk.internal.value to  \/\/ Needed by Unsafe\n+        jdk.unsupported;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -248,0 +248,2 @@\n+        PRIMITIVE_CLASSES(JDK21, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n+        VALUE_CLASSES(JDK21, Fragments.FeatureValueClasses, DiagKind.PLURAL),\n@@ -306,0 +308,3 @@\n+            if (this == PRIMITIVE_CLASSES) {\n+                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -230,0 +231,4 @@\n+    \/** Are primitive classes allowed\n+     *\/\n+    private final boolean allowPrimitiveClasses;\n+\n@@ -632,0 +637,5 @@\n+        } else {\n+            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n+                if (inferenceContext != infer.emptyContext)\n+                    checkParameterizationByPrimitiveClass(pos, found);\n+            }\n@@ -762,0 +772,51 @@\n+    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+        for (Type st : types.closure(c.type)) {\n+            if (st == null || st.tsym == null || st.tsym.kind == ERR)\n+                continue;\n+            if  (st.tsym == syms.objectType.tsym || st.tsym == syms.recordType.tsym || st.isInterface())\n+                continue;\n+            if (!st.tsym.isAbstract()) {\n+                if (c != st.tsym) {\n+                    log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n+                }\n+                continue;\n+            }\n+            \/\/ dealing with an abstract value or value super class below.\n+            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n+            if ((st.tsym.flags() & HASINITBLOCK) != 0) {\n+                log.error(pos, Errors.AbstractValueClassDeclaresInitBlock(fragment));\n+            }\n+            Type encl = st.getEnclosingType();\n+            if (encl != null && encl.hasTag(CLASS)) {\n+                log.error(pos, Errors.AbstractValueClassCannotBeInner(fragment));\n+            }\n+            for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                case VAR:\n+                    if ((s.flags() & STATIC) == 0) {\n+                        log.error(pos, Errors.InstanceFieldNotAllowed(s, fragment));\n+                    }\n+                    break;\n+                case MTH:\n+                    if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                        log.error(pos, Errors.SuperClassMethodCannotBeSynchronized(s, c, st));\n+                    } else if (s.isInitOrVNew()) {\n+                        MethodSymbol m = (MethodSymbol)s;\n+                        if (m.getParameters().size() > 0) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorCannotTakeArguments(m, fragment));\n+                        } else if (m.getTypeParameters().size() > 0) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorCannotBeGeneric(m, fragment));\n+                        } else if (m.type.getThrownTypes().size() > 0) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorCannotThrow(m, fragment));\n+                        } else if (protection(m.flags()) > protection(m.owner.flags())) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorHasWeakerAccess(m, fragment));\n+                        } else if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n+                                log.error(pos, Errors.AbstractValueClassNoArgConstructorMustBeEmpty(m, fragment));\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -764,2 +825,2 @@\n-    Type checkConstructorRefType(DiagnosticPosition pos, Type t) {\n-        t = checkClassOrArrayType(pos, t);\n+    Type checkConstructorRefType(JCExpression expr, Type t) {\n+        t = checkClassOrArrayType(expr, t);\n@@ -768,1 +829,1 @@\n-                log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));\n+                log.error(expr, Errors.AbstractCantBeInstantiated(t.tsym));\n@@ -771,1 +832,1 @@\n-                log.error(pos, Errors.EnumCantBeInstantiated);\n+                log.error(expr, Errors.EnumCantBeInstantiated);\n@@ -774,1 +835,10 @@\n-                t = checkClassType(pos, t, true);\n+                \/\/ Projection types may not be mentioned in constructor references\n+                if (expr.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n+                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n+                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n+                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n+                        t = types.createErrorType(t);\n+                    }\n+                }\n+                t = checkClassType(expr, t, true);\n@@ -778,1 +848,1 @@\n-                log.error(pos, Errors.GenericArrayCreation);\n+                log.error(expr, Errors.GenericArrayCreation);\n@@ -809,0 +879,1 @@\n+     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -810,2 +881,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        if (t.isReference())\n+    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n+        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n@@ -819,0 +890,31 @@\n+    \/** Check that type is an identity type, i.e. not a primitive\/value type\n+     *  nor its reference projection. When not discernible statically,\n+     *  give it the benefit of doubt and defer to runtime.\n+     *\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    void checkIdentityType(DiagnosticPosition pos, Type t) {\n+        if (t.hasTag(TYPEVAR)) {\n+            t = types.skipTypeVars(t, false);\n+        }\n+        if (t.isIntersection()) {\n+            IntersectionClassType ict = (IntersectionClassType)t;\n+            for (Type component : ict.getExplicitComponents()) {\n+                checkIdentityType(pos, component);\n+            }\n+            return;\n+        }\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+            typeTagError(pos, diags.fragment(Fragments.TypeReqIdentity), t);\n+    }\n+\n+    \/** Check that type is a reference type, i.e. a class, interface or array type\n+     *  or a type variable.\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        return checkRefType(pos, t, true);\n+    }\n+\n@@ -827,1 +929,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head);\n+            l.head = checkRefType(tl.head.pos(), l.head, false);\n@@ -863,0 +965,49 @@\n+    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n+        parameterizationByPrimitiveClassChecker.visit(t, pos);\n+    }\n+\n+    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n+     *  being used as type arguments and issues error against those usages.\n+     *\/\n+    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n+            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n+\n+        @Override\n+        public Void visitType(Type t, DiagnosticPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n+            for (Type targ : t.allparams()) {\n+                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n+                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n+                }\n+                visit(targ, pos);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n+             return null;\n+        }\n+\n+        @Override\n+        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n+            return visit(t.elemtype, pos);\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n+            return visit(t.type, pos);\n+        }\n+    };\n+\n+\n+\n@@ -995,1 +1146,1 @@\n-                (s.isConstructor() ||\n+                (s.isInitOrVNew() ||\n@@ -1011,1 +1162,5 @@\n-        return types.upward(t, types.captures(t)).baseType();\n+        Type varType = types.upward(t, types.captures(t)).baseType();\n+        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n+            checkParameterizationByPrimitiveClass(pos, varType);\n+        }\n+        return varType;\n@@ -1034,0 +1189,1 @@\n+        \/\/ TODO - is enum so <init>\n@@ -1209,1 +1365,1 @@\n-            else\n+            else {\n@@ -1211,0 +1367,4 @@\n+                if (sym.owner.type.isValueClass() && (flags & STATIC) == 0) {\n+                    implicit |= FINAL;\n+                }\n+            }\n@@ -1213,1 +1373,1 @@\n-            if (sym.name == names.init) {\n+            if (names.isInitOrVNew(sym.name)) {\n@@ -1236,1 +1396,2 @@\n-                mask = RecordMethodFlags;\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        RecordMethodFlags & ~SYNCHRONIZED : RecordMethodFlags;\n@@ -1238,1 +1399,3 @@\n-                mask = MethodFlags;\n+                \/\/ value objects do not have an associated monitor\/lock\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        MethodFlags & ~SYNCHRONIZED : MethodFlags;\n@@ -1255,1 +1418,1 @@\n-                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? StaticLocalFlags : LocalClassFlags;\n+                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? ExtendedStaticLocalClassFlags : ExtendedLocalClassFlags;\n@@ -1275,2 +1438,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n@@ -1289,0 +1452,17 @@\n+\n+            \/\/ primitive classes are implicitly final value classes.\n+            if ((flags & PRIMITIVE_CLASS) != 0)\n+                implicit |= VALUE_CLASS | FINAL;\n+\n+            \/\/ concrete value classes are implicitly final\n+            if ((flags & (ABSTRACT | INTERFACE | VALUE_CLASS)) == VALUE_CLASS) {\n+                implicit |= FINAL;\n+                if ((flags & NON_SEALED) != 0) {\n+                    \/\/ cant declare a final value class non-sealed\n+                    log.error(pos,\n+                            Errors.ModNotAllowedHere(asFlagSet(NON_SEALED)));\n+                }\n+            }\n+\n+            \/\/ TYPs can't be declared synchronized\n+            mask &= ~SYNCHRONIZED;\n@@ -1317,1 +1497,5 @@\n-                               FINAL | NATIVE | SYNCHRONIZED)\n+                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                 &&\n+                 checkDisjoint(pos, flags,\n+                        IDENTITY_TYPE,\n+                        PRIMITIVE_CLASS | VALUE_CLASS)\n@@ -1327,1 +1511,1 @@\n-                 checkDisjoint(pos, flags,\n+                 checkDisjoint(pos, (flags | implicit), \/\/ complain against volatile & implcitly final entities too.\n@@ -1343,1 +1527,7 @@\n-                                ANNOTATION)) {\n+                                ANNOTATION)\n+                 && checkDisjoint(pos, flags,\n+                                IDENTITY_TYPE,\n+                                ANNOTATION)\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n+                                ANNOTATION) ) {\n@@ -1516,1 +1706,2 @@\n-                tree.selected.type.isParameterized()) {\n+                tree.selected.type.isParameterized() &&\n+                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n@@ -1520,0 +1711,2 @@\n+                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n+                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -1583,1 +1776,1 @@\n-                    env.enclMethod != null && env.enclMethod.name == names.init;\n+                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n@@ -2184,1 +2377,1 @@\n-                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n@@ -2340,0 +2533,39 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        if (allowPrimitiveClasses) {\n+            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+            try {\n+                tree.sym.flags_field |= LOCKED;\n+                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl field = (JCVariableDecl) l.head;\n+                        if (cyclePossible(field.sym)) {\n+                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                        }\n+                    }\n+                }\n+            } finally {\n+                tree.sym.flags_field &= ~LOCKED;\n+            }\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n+        }\n+\n@@ -2588,0 +2820,22 @@\n+\n+        boolean cIsValue = (c.tsym.flags() & VALUE_CLASS) != 0;\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        Type identitySuper = null, valueSuper = null;\n+        for (Type t : types.closure(c)) {\n+            if (t != c) {\n+                if ((t.tsym.flags() & IDENTITY_TYPE) != 0)\n+                    identitySuper = t;\n+                else if ((t.tsym.flags() & VALUE_CLASS) != 0)\n+                    valueSuper = t;\n+                if (cIsValue &&  identitySuper != null) {\n+                    log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, identitySuper));\n+                    break;\n+                } else if (cHasIdentity &&  valueSuper != null) {\n+                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, valueSuper));\n+                    break;\n+                } else if (identitySuper != null && valueSuper != null) {\n+                    log.error(pos, Errors.MutuallyIncompatibleSupers(c, identitySuper, valueSuper));\n+                    break;\n+                }\n+            }\n+        }\n@@ -2683,1 +2937,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -2742,1 +2996,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -3625,1 +3879,1 @@\n-                if (s.kind == MTH && !s.isConstructor())\n+                if (s.kind == MTH && !s.isInitOrVNew())\n@@ -3633,1 +3887,1 @@\n-                if (s.kind == MTH && s.isConstructor())\n+                if (s.kind == MTH && s.isInitOrVNew())\n@@ -3652,1 +3906,1 @@\n-                        (s.kind == MTH && !s.isConstructor() &&\n+                        (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -3654,1 +3908,1 @@\n-                        (s.kind == MTH && s.isConstructor())) {\n+                        (s.kind == MTH && s.isInitOrVNew())) {\n@@ -4974,1 +5228,1 @@\n-                    if (sym.isConstructor() &&\n+                    if (sym.isInitOrVNew() &&\n@@ -5002,1 +5256,1 @@\n-                        if (sym.isConstructor()) {\n+                        if (sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":286,"deletions":32,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     classig    ::= 'L' name [typeargs] ';'\n+ *     classig    ::= 'L' name [typeargs] ';' | 'Q' name [typeargs] ';'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1759,1 +1759,1 @@\n-                                ((JCMethodDecl) t).sym.name == names.init ||\n+                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags._flags\", Integer.class, \"u2\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags._flags\", Integer.class, \"u4\");\n@@ -305,0 +305,2 @@\n+    final int dataLayoutArrayLoadStoreDataTag = getConstant(\"DataLayout::array_load_store_data_tag\", Integer.class);\n+    final int dataLayoutACmpDataTag = getConstant(\"DataLayout::acmp_data_tag\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,784 @@\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #42 #11; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #10\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #11\n+    Field #13 #14; \/\/ #12\n+    class #15; \/\/ #13\n+    NameAndType #16 #17; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #15\n+    Utf8 \"rect\"; \/\/ #16\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #17\n+    String #19; \/\/ #18\n+    Utf8 \"\"; \/\/ #19\n+    Field #13 #21; \/\/ #20\n+    NameAndType #22 #23; \/\/ #21\n+    Utf8 \"name\"; \/\/ #22\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n+    Field #8 #25; \/\/ #24\n+    NameAndType #26 #27; \/\/ #25\n+    Utf8 \"p1\"; \/\/ #26\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #27\n+    Field #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #32 #33; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #31\n+    Utf8 \"x\"; \/\/ #32\n+    Utf8 \"I\"; \/\/ #33\n+    Utf8 \"Code\"; \/\/ #34\n+    Utf8 \"LineNumberTable\"; \/\/ #35\n+    Utf8 \"getP1X\"; \/\/ #36\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #37\n+    Utf8 \"getP1\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"NamedRectangleN.java\"; \/\/ #41\n+    Utf8 \"<vnew>\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012AB80007;\n+            0xB5000C2A1212B500;\n+            0x14B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #36; \/\/ name_index\n+      #37; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B4;\n+            0x001CAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  31;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #42 #11; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #10\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #11\n+    Field #13 #14; \/\/ #12\n+    class #15; \/\/ #13\n+    NameAndType #16 #17; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #15\n+    Utf8 \"rect\"; \/\/ #16\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #17\n+    String #19; \/\/ #18\n+    Utf8 \"\"; \/\/ #19\n+    Field #13 #21; \/\/ #20\n+    NameAndType #22 #23; \/\/ #21\n+    Utf8 \"name\"; \/\/ #22\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n+    Field #8 #25; \/\/ #24\n+    NameAndType #26 #27; \/\/ #25\n+    Utf8 \"p1\"; \/\/ #26\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #27\n+    Field #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #32 #33; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #31\n+    Utf8 \"x\"; \/\/ #32\n+    Utf8 \"I\"; \/\/ #33\n+    Utf8 \"Code\"; \/\/ #34\n+    Utf8 \"LineNumberTable\"; \/\/ #35\n+    Utf8 \"getP1X\"; \/\/ #36\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #37\n+    Utf8 \"getP1\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"NamedRectangleP.java\"; \/\/ #41\n+    Utf8 \"<vnew>\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012AB80007;\n+            0xB5000C2A1212B500;\n+            0x14B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #36; \/\/ name_index\n+      #37; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B4;\n+            0x001CAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  31;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleP\n+\n+class compiler\/valhalla\/inlinetypes\/PointN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x1\"; \/\/ #5                \/\/ field name changed from x to x1\n+    Utf8 \"I\"; \/\/ #6\n+    Field #1 #8; \/\/ #7\n+    NameAndType #9 #6; \/\/ #8\n+    Utf8 \"y\"; \/\/ #9\n+    InvokeDynamic 0s #11; \/\/ #10\n+    NameAndType #12 #13; \/\/ #11\n+    Utf8 \"toString\"; \/\/ #12\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/PointN;)Ljava\/lang\/String;\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"<vnew>\"; \/\/ #19\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"PointN.java\"; \/\/ #22\n+    Utf8 \"NestHost\"; \/\/ #23\n+    Utf8 \"BootstrapMethods\"; \/\/ #24\n+    MethodHandle 6b #26; \/\/ #25\n+    Method #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #29\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #30\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #31\n+    Utf8 \"InnerClasses\"; \/\/ #32\n+    class #34; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #34\n+    class #36; \/\/ #35\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #36\n+    Utf8 \"Lookup\"; \/\/ #37\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #12; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA000A0000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #19; \/\/ name_index\n+      #20; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B072A5FCC;\n+            0x00034B10072A5FCC;\n+            0x00074B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23) { \/\/ NestHost\n+      #14;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#24) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#32) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #33 #35 #37 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/PointN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #2\n+    Method #4 #5; \/\/ #3\n+    class #6; \/\/ #4\n+    NameAndType #7 #8; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #8\n+    Field #1 #10; \/\/ #9\n+    NameAndType #11 #12; \/\/ #10\n+    Utf8 \"p0\"; \/\/ #11\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Field #1 #14; \/\/ #13\n+    NameAndType #15 #12; \/\/ #14\n+    Utf8 \"p1\"; \/\/ #15\n+    InvokeDynamic 0s #17; \/\/ #16\n+    NameAndType #18 #19; \/\/ #17\n+    Utf8 \"toString\"; \/\/ #18\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleN;)Ljava\/lang\/String;\"; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #25\n+    Utf8 \"SourceFile\"; \/\/ #26\n+    Utf8 \"RectangleN.java\"; \/\/ #27\n+    Utf8 \"NestHost\"; \/\/ #28\n+    Utf8 \"BootstrapMethods\"; \/\/ #29\n+    MethodHandle 6b #31; \/\/ #30\n+    Method #32 #33; \/\/ #31\n+    class #34; \/\/ #32\n+    NameAndType #35 #36; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n+    Utf8 \"InnerClasses\"; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n+    Utf8 \"Lookup\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #15; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #18; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00100000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #25; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014BB800032A;\n+            0x5FCC00094BB80003;\n+            0x2A5FCC000D4B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                13  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#26) { \/\/ SourceFile\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28) { \/\/ NestHost\n+      #20;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#29) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #30; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#37) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #38 #40 #42 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #2\n+    Method #4 #5; \/\/ #3\n+    class #6; \/\/ #4\n+    NameAndType #7 #8; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #8\n+    Field #1 #10; \/\/ #9\n+    NameAndType #11 #12; \/\/ #10\n+    Utf8 \"p0\"; \/\/ #11\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #12\n+    Field #1 #14; \/\/ #13\n+    NameAndType #15 #12; \/\/ #14\n+    Utf8 \"p1\"; \/\/ #15\n+    InvokeDynamic 0s #17; \/\/ #16\n+    NameAndType #18 #19; \/\/ #17\n+    Utf8 \"toString\"; \/\/ #18\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleP;)Ljava\/lang\/String;\"; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #25\n+    Utf8 \"SourceFile\"; \/\/ #26\n+    Utf8 \"RectangleP.java\"; \/\/ #27\n+    Utf8 \"NestHost\"; \/\/ #28\n+    Utf8 \"BootstrapMethods\"; \/\/ #29\n+    MethodHandle 6b #31; \/\/ #30\n+    Method #32 #33; \/\/ #31\n+    class #34; \/\/ #32\n+    NameAndType #35 #36; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n+    Utf8 \"InnerClasses\"; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n+    Utf8 \"Lookup\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0012; \/\/ access  \/\/ Access flags have been modified to make field p1 private\n+      #15; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #18; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00100000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #25; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014BB800032A;\n+            0x5FCC00094BB80003;\n+            0x2A5FCC000D4B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                13  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#26) { \/\/ SourceFile\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28) { \/\/ NestHost\n+      #20;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#29) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #30; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#37) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #38 #40 #42 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleP\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":784,"deletions":0,"binary":false,"changes":784,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ GENERATED FROM THE FOLLOWING JAVA FILE:\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+primitive class MyValue5 {\n+    public int x = 42;\n+\n+    public MyValue5 withField(int x) {\n+        return __WithField(this.x, x);\n+    }\n+\n+    public static MyValue5.ref withField(MyValue5.ref val, int x) {\n+        return __WithField(val.x, x);\n+    }\n+}\n+*\/\n+\n+class compiler\/valhalla\/inlinetypes\/MyValue5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8\n+    Utf8 \"withField\"; \/\/ #9\n+    Utf8 \"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue5;I)Lcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #13\n+    Utf8 \"<vnew>\"; \/\/ #14\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #15\n+    Utf8 \"SourceFile\"; \/\/ #16\n+    Utf8 \"MyValue5.java\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0011; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index\n+      #13; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  11;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #14; \/\/ name_index\n+      #15; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#16) { \/\/ SourceFile\n+      #17;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue5\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue1\n+    version 66:0\n+{\n+    static Field cnt:I;\n+    final Field x:I;\n+    final Field vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+    final Field vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+        getstatic cnt:I;\n+        iconst_1;\n+        iadd;\n+        putstatic cnt:I;\n+\n+        aconst_init compiler\/valhalla\/inlinetypes\/MyValue1;\n+\n+        getstatic cnt:I;\n+        withfield x:I;\n+\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        withfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        withfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+        areturn;\n+    }\n+\n+    public Method hash:\"()I\" stack 2 {\n+        aload_0;\n+        getfield x:I;\n+\n+        aload_0;\n+        getfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n+        iadd;\n+\n+        aload_0;\n+        getfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n+        iadd;\n+\n+        ireturn;\n+    }\n+\n+    public Method testWithField:\"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield x:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue2\n+    version 66:0\n+{\n+    static Field cnt:I;\n+    final Field x:I;\n+\n+    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\" stack 2 {\n+        getstatic cnt:I;\n+        iconst_1;\n+        iadd;\n+        putstatic cnt:I;\n+\n+        aconst_init compiler\/valhalla\/inlinetypes\/MyValue2;\n+\n+        getstatic cnt:I;\n+        withfield x:I;\n+\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBufferingClasses.jasm","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,3812 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ ##################################### WARNING ########################################\n+\/\/ Generated file, don't modify manually. See TestMismatchHandling.java for instructions.\n+\/\/ ##################################### WARNING ########################################\n+\n+class MyValue1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue1\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    class #16; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"()V\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"StackMapTable\"; \/\/ #21\n+    Utf8 \"<vnew>\"; \/\/ #22\n+    Utf8 \"()LMyValue1;\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  28;\n+                9  29;\n+                19  31;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  24;\n+                4  25;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue1\n+class MyValue2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue2\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    class #16; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"()V\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"StackMapTable\"; \/\/ #21\n+    Utf8 \"<vnew>\"; \/\/ #22\n+    Utf8 \"()LMyValue2;\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  38;\n+                9  39;\n+                19  41;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  34;\n+                4  35;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue2\n+class MyValue3 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue3\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    class #16; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"()V\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"StackMapTable\"; \/\/ #21\n+    Utf8 \"<vnew>\"; \/\/ #22\n+    Utf8 \"()LMyValue3;\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  48;\n+                9  49;\n+                19  51;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  44;\n+                4  45;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue3\n+class MyValue4 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue4\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    Method #1 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"<vnew>\"; \/\/ #17\n+    Utf8 \"()LMyValue4;\"; \/\/ #18\n+    class #20; \/\/ #19\n+    Utf8 \"java\/lang\/Object\"; \/\/ #20\n+    Utf8 \"verify\"; \/\/ #21\n+    Utf8 \"()V\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"StackMapTable\"; \/\/ #25\n+    Utf8 \"make\"; \/\/ #26\n+    Utf8 \"SourceFile\"; \/\/ #27\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #28\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #19;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #21; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  58;\n+                9  59;\n+                19  61;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#25) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #26; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xB8000FB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  64;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  54;\n+                4  55;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#27) { \/\/ SourceFile\n+      #28;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue4\n+class MyValue5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue5\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    Method #1 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"<vnew>\"; \/\/ #17\n+    Utf8 \"()LMyValue5;\"; \/\/ #18\n+    class #20; \/\/ #19\n+    Utf8 \"java\/lang\/Object\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"Verifiable\"; \/\/ #22\n+    Utf8 \"verify\"; \/\/ #23\n+    Utf8 \"()V\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"StackMapTable\"; \/\/ #27\n+    Utf8 \"make\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #30\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #19;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #21;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  77;\n+                9  78;\n+                19  80;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#27) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #28; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xB8000FB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  83;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  72;\n+                4  73;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue5\n+class MyValue6 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue6\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    Method #1 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"<vnew>\"; \/\/ #17\n+    Utf8 \"()LMyValue6;\"; \/\/ #18\n+    class #20; \/\/ #19\n+    Utf8 \"java\/lang\/Object\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"Verifiable\"; \/\/ #22\n+    Utf8 \"verify\"; \/\/ #23\n+    Utf8 \"()V\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"StackMapTable\"; \/\/ #27\n+    Utf8 \"make\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #30\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #19;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #21;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  92;\n+                9  93;\n+                19  95;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#27) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #28; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xB8000FB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  98;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  87;\n+                4  88;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue6\n+class MyValue7 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"MyValue7\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #8\n+    String #10; \/\/ #9\n+    Utf8 \"Verification failed\"; \/\/ #10\n+    Method #7 #12; \/\/ #11\n+    NameAndType #13 #14; \/\/ #12\n+    Utf8 \"<init>\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #14\n+    class #16; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"()V\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"StackMapTable\"; \/\/ #21\n+    Utf8 \"<vnew>\"; \/\/ #22\n+    Utf8 \"()LMyValue7;\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40003102A9F00;\n+            0x0DBB0007591209B7;\n+            0x000BBFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  106;\n+                9  107;\n+                19  109;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  102;\n+                4  103;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue7\n+class Verifiable {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"Verifiable\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"verify\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class Verifiable\n+file \"B.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"A\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"B\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"Preload\"; \/\/ #20\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  119;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  122;\n+                4  123;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class B\n+class I3 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I3\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+    Utf8 \"Preload\"; \/\/ #9\n+    class #11; \/\/ #10\n+    Utf8 \"MyValue2\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#9) { \/\/ Preload\n+      [] { \/\/ classes\n+        #10;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class I3\n+class I4 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I4\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"I3\"; \/\/ #6\n+    Utf8 \"method\"; \/\/ #7\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+    Utf8 \"Preload\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"MyValue2\"; \/\/ #13\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ Preload\n+      [] { \/\/ classes\n+        #12;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class I4\n+class E {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"E\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I4\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"Preload\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  160;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  163;\n+                4  164;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class E\n+class G {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"G\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I2\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"I4\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"method\"; \/\/ #20\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #21\n+    Utf8 \"SourceFile\"; \/\/ #22\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #23\n+    Utf8 \"Preload\"; \/\/ #24\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+    #16;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  177;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #21; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  180;\n+                4  181;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#22) { \/\/ SourceFile\n+      #23;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#24) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class G\n+class J {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"J\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"Preload\"; \/\/ #20\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  197;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  199;\n+                4  200;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class J\n+class K {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"J\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"K\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"Preload\"; \/\/ #20\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  204;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  207;\n+                4  208;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class K\n+file \"L.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"K\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"L\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I5\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"Preload\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  212;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  215;\n+                4  216;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class L\n+class P {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"P\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"Preload\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  263;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  266;\n+                4  267;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class P\n+class Q {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"Q\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"Preload\"; \/\/ #20\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  271;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  273;\n+                4  274;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class Q\n+class R {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"Q\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"R\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"Preload\"; \/\/ #20\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  278;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  281;\n+                4  282;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class R\n+class S {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"R\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"S\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"Preload\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  286;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  289;\n+                4  290;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class S\n+class TestMismatchHandlingHelper {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"<vnew>\"; \/\/ #11\n+    Utf8 \"()LMyValue1;\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #17 #18; \/\/ #15\n+    Utf8 \"A\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #18\n+    Method #8 #20; \/\/ #19\n+    NameAndType #21 #6; \/\/ #20\n+    Utf8 \"verify\"; \/\/ #21\n+    Method #23 #15; \/\/ #22\n+    class #24; \/\/ #23\n+    Utf8 \"B\"; \/\/ #24\n+    Method #26 #15; \/\/ #25\n+    class #27; \/\/ #26\n+    Utf8 \"C\"; \/\/ #27\n+    Method #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #11 #32; \/\/ #30\n+    Utf8 \"MyValue2\"; \/\/ #31\n+    Utf8 \"()LMyValue2;\"; \/\/ #32\n+    InterfaceMethod #34 #35; \/\/ #33\n+    class #36; \/\/ #34\n+    NameAndType #17 #37; \/\/ #35\n+    Utf8 \"I1\"; \/\/ #36\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #37\n+    Method #29 #20; \/\/ #38\n+    InterfaceMethod #40 #35; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"I2\"; \/\/ #41\n+    Method #43 #35; \/\/ #42\n+    class #44; \/\/ #43\n+    Utf8 \"D\"; \/\/ #44\n+    InterfaceMethod #46 #35; \/\/ #45\n+    class #47; \/\/ #46\n+    Utf8 \"I3\"; \/\/ #47\n+    InterfaceMethod #49 #35; \/\/ #48\n+    class #50; \/\/ #49\n+    Utf8 \"I4\"; \/\/ #50\n+    Method #52 #35; \/\/ #51\n+    class #53; \/\/ #52\n+    Utf8 \"E\"; \/\/ #53\n+    Method #55 #56; \/\/ #54\n+    class #57; \/\/ #55\n+    NameAndType #11 #58; \/\/ #56\n+    Utf8 \"MyValue3\"; \/\/ #57\n+    Utf8 \"()LMyValue3;\"; \/\/ #58\n+    InterfaceMethod #60 #61; \/\/ #59\n+    class #62; \/\/ #60\n+    NameAndType #17 #63; \/\/ #61\n+    Utf8 \"I5\"; \/\/ #62\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #63\n+    Method #55 #20; \/\/ #64\n+    Method #66 #61; \/\/ #65\n+    class #67; \/\/ #66\n+    Utf8 \"H\"; \/\/ #67\n+    Method #69 #61; \/\/ #68\n+    class #70; \/\/ #69\n+    Utf8 \"J\"; \/\/ #70\n+    Method #72 #61; \/\/ #71\n+    class #73; \/\/ #72\n+    Utf8 \"K\"; \/\/ #73\n+    Method #75 #76; \/\/ #74\n+    class #77; \/\/ #75\n+    NameAndType #17 #78; \/\/ #76\n+    Utf8 \"M\"; \/\/ #77\n+    Utf8 \"(Z)LMyValue4;\"; \/\/ #78\n+    Field #80 #81; \/\/ #79\n+    class #82; \/\/ #80\n+    NameAndType #83 #84; \/\/ #81\n+    Utf8 \"MyValue4\"; \/\/ #82\n+    Utf8 \"x\"; \/\/ #83\n+    Utf8 \"I\"; \/\/ #84\n+    class #86; \/\/ #85\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #86\n+    String #88; \/\/ #87\n+    Utf8 \"Verification failed\"; \/\/ #88\n+    Method #85 #90; \/\/ #89\n+    NameAndType #5 #91; \/\/ #90\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #91\n+    Method #93 #94; \/\/ #92\n+    class #95; \/\/ #93\n+    NameAndType #17 #96; \/\/ #94\n+    Utf8 \"N\"; \/\/ #95\n+    Utf8 \"(Z)LMyValue5;\"; \/\/ #96\n+    InterfaceMethod #98 #20; \/\/ #97\n+    class #99; \/\/ #98\n+    Utf8 \"Verifiable\"; \/\/ #99\n+    Method #101 #35; \/\/ #100\n+    class #102; \/\/ #101\n+    Utf8 \"F\"; \/\/ #102\n+    Method #104 #35; \/\/ #103\n+    class #105; \/\/ #104\n+    Utf8 \"G\"; \/\/ #105\n+    Method #107 #61; \/\/ #106\n+    class #108; \/\/ #107\n+    Utf8 \"L\"; \/\/ #108\n+    Method #110 #111; \/\/ #109\n+    class #112; \/\/ #110\n+    NameAndType #17 #113; \/\/ #111\n+    Utf8 \"O\"; \/\/ #112\n+    Utf8 \"(Z)LMyValue6;\"; \/\/ #113\n+    Method #115 #20; \/\/ #114\n+    class #116; \/\/ #115\n+    Utf8 \"MyValue6\"; \/\/ #116\n+    Method #118 #119; \/\/ #117\n+    class #120; \/\/ #118\n+    NameAndType #11 #121; \/\/ #119\n+    Utf8 \"MyValue7\"; \/\/ #120\n+    Utf8 \"()LMyValue7;\"; \/\/ #121\n+    InterfaceMethod #123 #124; \/\/ #122\n+    class #125; \/\/ #123\n+    NameAndType #17 #126; \/\/ #124\n+    Utf8 \"I6\"; \/\/ #125\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #126\n+    Method #118 #20; \/\/ #127\n+    Method #129 #124; \/\/ #128\n+    class #130; \/\/ #129\n+    Utf8 \"P\"; \/\/ #130\n+    Method #132 #124; \/\/ #131\n+    class #133; \/\/ #132\n+    Utf8 \"Q\"; \/\/ #133\n+    Method #135 #124; \/\/ #134\n+    class #136; \/\/ #135\n+    Utf8 \"R\"; \/\/ #136\n+    class #138; \/\/ #137\n+    Utf8 \"TestMismatchHandlingHelper\"; \/\/ #138\n+    Utf8 \"Code\"; \/\/ #139\n+    Utf8 \"LineNumberTable\"; \/\/ #140\n+    Utf8 \"test1\"; \/\/ #141\n+    Utf8 \"(LA;LA;LA;LA;LA;LB;LB;LC;)V\"; \/\/ #142\n+    Utf8 \"test2\"; \/\/ #143\n+    Utf8 \"(LI1;LI1;LI1;LI1;LI1;LI1;LI2;LI2;LI2;LI2;LI2;LI2;LI3;LI3;LI3;LI3;LI3;LI3;LI4;LI4;LI4;LI4;LI4;LI4;LD;LE;)V\"; \/\/ #144\n+    Utf8 \"test3\"; \/\/ #145\n+    Utf8 \"(LI5;LI5;LI5;LJ;LJ;LJ;LJ;LJ;LH;LK;)V\"; \/\/ #146\n+    Utf8 \"test4\"; \/\/ #147\n+    Utf8 \"(LM;Z)V\"; \/\/ #148\n+    Utf8 \"StackMapTable\"; \/\/ #149\n+    Utf8 \"test5\"; \/\/ #150\n+    Utf8 \"(LN;Z)V\"; \/\/ #151\n+    Utf8 \"test6\"; \/\/ #152\n+    Utf8 \"(LF;LG;LL;)V\"; \/\/ #153\n+    Utf8 \"test7\"; \/\/ #154\n+    Utf8 \"(LO;Z)LVerifiable;\"; \/\/ #155\n+    Utf8 \"test7TriggerCalleeCompilation\"; \/\/ #156\n+    Utf8 \"(LO;)V\"; \/\/ #157\n+    Utf8 \"test8\"; \/\/ #158\n+    Utf8 \"(LI6;LI6;LI6;LQ;LQ;LQ;LQ;LQ;LP;LR;)V\"; \/\/ #159\n+    Utf8 \"SourceFile\"; \/\/ #160\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #161\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #137;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  294;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #141; \/\/ name_index\n+      #142; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          8; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB80007B6000DB6;\n+            0x00132BB80007B600;\n+            0x0DB600132CB80007;\n+            0xB6000DB600132DB8;\n+            0x0007B6000DB60013;\n+            0x1904B80007B6000D;\n+            0xB600131905B80007;\n+            0xB60016B600131906;\n+            0xB80007B60016B600;\n+            0x131907B80007B600;\n+            0x19B60013B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  300;\n+                10  301;\n+                20  302;\n+                30  303;\n+                40  304;\n+                51  306;\n+                62  307;\n+                73  308;\n+                84  309;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #143; \/\/ name_index\n+      #144; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          26; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB8001CB9002102;\n+            0x00B600262BB8001C;\n+            0xB900210200B60026;\n+            0x2CB8001CB9002102;\n+            0x00B600262DB8001C;\n+            0xB900210200B60026;\n+            0x1904B8001CB90021;\n+            0x0200B600261905B8;\n+            0x001CB900210200B6;\n+            0x00261906B8001CB9;\n+            0x00270200B6002619;\n+            0x07B8001CB9002702;\n+            0x00B600261908B800;\n+            0x1CB900270200B600;\n+            0x261909B8001CB900;\n+            0x270200B60026190A;\n+            0xB8001CB900270200;\n+            0xB60026190BB8001C;\n+            0xB900270200B60026;\n+            0x1918B8001CB6002A;\n+            0xB60026190CB8001C;\n+            0xB9002D0200B60026;\n+            0x190DB8001CB9002D;\n+            0x0200B60026190EB8;\n+            0x001CB9002D0200B6;\n+            0x0026190FB8001CB9;\n+            0x002D0200B6002619;\n+            0x10B8001CB9002D02;\n+            0x00B600261911B800;\n+            0x1CB9002D0200B600;\n+            0x261912B8001CB900;\n+            0x300200B600261913;\n+            0xB8001CB900300200;\n+            0xB600261914B8001C;\n+            0xB900300200B60026;\n+            0x1915B8001CB90030;\n+            0x0200B600261916B8;\n+            0x001CB900300200B6;\n+            0x00261917B8001CB9;\n+            0x00300200B6002619;\n+            0x19B8001CB60033B6;\n+            0x0026B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  318;\n+                12  319;\n+                24  320;\n+                36  321;\n+                48  322;\n+                61  323;\n+                74  324;\n+                87  325;\n+                100  326;\n+                113  327;\n+                126  328;\n+                139  329;\n+                152  330;\n+                163  332;\n+                176  333;\n+                189  334;\n+                202  335;\n+                215  336;\n+                228  337;\n+                241  338;\n+                254  339;\n+                267  340;\n+                280  341;\n+                293  342;\n+                306  343;\n+                319  344;\n+                330  345;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #145; \/\/ name_index\n+      #146; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          10; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB80036B9003B02;\n+            0x00B600402BB80036;\n+            0xB9003B0200B60040;\n+            0x2CB80036B9003B02;\n+            0x00B600401908B800;\n+            0x36B60041B600402D;\n+            0xB80036B60044B600;\n+            0x401904B80036B600;\n+            0x44B600401905B800;\n+            0x36B60044B6004019;\n+            0x06B80036B60044B6;\n+            0x00401907B80036B6;\n+            0x0044B600401909B8;\n+            0x0036B60047B60040;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  353;\n+                12  354;\n+                24  355;\n+                36  356;\n+                47  358;\n+                57  359;\n+                68  360;\n+                79  361;\n+                90  362;\n+                101  363;\n+                112  364;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #147; \/\/ name_index\n+      #148; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          3; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000C2A1BB600;\n+            0x4A57A7001A2A1BB6;\n+            0x004AB4004F102A9F;\n+            0x000DBB0055591257;\n+            0xB70059BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  369;\n+                4  370;\n+                13  372;\n+                26  373;\n+                36  376;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#149) { \/\/ StackMapTable\n+              [] { \/\/ \n+                13b; \/\/ same_frame\n+                22b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #150; \/\/ name_index\n+      #151; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB6005C4D1B9A;\n+            0x00092CB900610100;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  381;\n+                6  382;\n+                10  383;\n+                16  385;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#149) { \/\/ StackMapTable\n+              [] { \/\/ \n+                252b, 16, []z{O,98}; \/\/ append_frame 1\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #152; \/\/ name_index\n+      #153; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB8001CB6006457;\n+            0x2BB8001CB6006757;\n+            0x2CB80036B6006A57;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  389;\n+                8  390;\n+                16  391;\n+                24  392;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #154; \/\/ name_index\n+      #155; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB6006DB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  397;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #156; \/\/ name_index\n+      #157; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A04B6006D572A03;\n+            0xB6006DB60072B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  401;\n+                6  402;\n+                14  403;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #158; \/\/ name_index\n+      #159; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#139) { \/\/ Code\n+          2; \/\/ max_stack\n+          10; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB80075B9007A02;\n+            0x00B6007F2BB80075;\n+            0xB9007A0200B6007F;\n+            0x2CB80075B9007A02;\n+            0x00B6007F1908B800;\n+            0x75B60080B6007F2D;\n+            0xB80075B60083B600;\n+            0x7F1904B80075B600;\n+            0x83B6007F1905B800;\n+            0x75B60083B6007F19;\n+            0x06B80075B60083B6;\n+            0x007F1907B80075B6;\n+            0x0083B6007F1909B8;\n+            0x0075B60086B6007F;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#140) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  412;\n+                12  413;\n+                24  414;\n+                36  415;\n+                47  417;\n+                57  418;\n+                68  419;\n+                79  420;\n+                90  421;\n+                101  422;\n+                112  423;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#160) { \/\/ SourceFile\n+      #161;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class TestMismatchHandlingHelper\n+class A {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"A\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  112;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  114;\n+                4  115;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class A\n+class C {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"B\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"C\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  127;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  130;\n+                4  131;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class C\n+class I1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I1\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I1\n+class I2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I2\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"I1\"; \/\/ #6\n+    Utf8 \"method\"; \/\/ #7\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I2\n+file \"D.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"D\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I2\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  152;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  155;\n+                4  156;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class D\n+file \"F.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"F\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I2\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"I4\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"method\"; \/\/ #20\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #21\n+    Utf8 \"SourceFile\"; \/\/ #22\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+    #16;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  169;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #21; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  172;\n+                4  173;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#22) { \/\/ SourceFile\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class F\n+class H {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"H\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I5\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  189;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  192;\n+                4  193;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class H\n+class I5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I5\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I5\n+class M {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"M\"; \/\/ #10\n+    Utf8 \"val\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #17 #18; \/\/ #15\n+    Utf8 \"MyValue4\"; \/\/ #16\n+    Utf8 \"make\"; \/\/ #17\n+    Utf8 \"()LMyValue4;\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"method\"; \/\/ #21\n+    Utf8 \"(Z)LMyValue4;\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A03B500;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  220;\n+                4  221;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #21; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          4; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x0D4D033E1D100AA2;\n+            0x00132A59B4000704;\n+            0x60B50007840301A7;\n+            0xFFED2CB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  224;\n+                4  225;\n+                6  227;\n+                10  229;\n+                18  230;\n+                28  229;\n+                34  232;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+                253b, 5, []z{O,14; I}; \/\/ append_frame 2\n+                250b, 21; \/\/ chop_frame 1\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class M\n+file \"N.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue5\"; \/\/ #10\n+    Utf8 \"make\"; \/\/ #11\n+    Utf8 \"()LMyValue5;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"N\"; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(Z)LMyValue5;\"; \/\/ #18\n+    Utf8 \"StackMapTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  237;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x07B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  239;\n+                4  240;\n+                6  242;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#19) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class N\n+file \"O.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue6\"; \/\/ #10\n+    Utf8 \"make\"; \/\/ #11\n+    Utf8 \"()LMyValue6;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"O\"; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(Z)LMyValue6;\"; \/\/ #18\n+    Utf8 \"StackMapTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  247;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x07B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  249;\n+                4  250;\n+                6  252;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#19) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class O\n+class I6 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I6\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x01B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  259;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I6\n+class P {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"P\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  263;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  266;\n+                4  267;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class P\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandling.jcod","additions":3812,"deletions":0,"binary":false,"changes":3812,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler\/valhalla\/inlinetypes;\n+\n+public final primitive value class FooValue\n+    version 66:0\n+{\n+    public final Field x:I;\n+    public final Field y:I;\n+\n+    \/\/ escape with putstatic\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test1:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; putstatic TestWithfieldC1.foo_static:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape with putfield\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test2:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_1;\n+        aload_1; iconst_1; withfield FooValue.x:I; astore_1;\n+        aload_1; iconst_1; withfield FooValue.y:I; astore_1;\n+\n+        aload_0; aload_1; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_1; areturn;\n+    }\n+\n+    \/\/ escape with function call\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test3:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape and then branch backwards\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test4:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        iconst_1; istore_1;\n+\n+        loop: stack_frame_type append; locals_map class \"Qcompiler\/valhalla\/inlinetypes\/FooValue;\", int;\n+            \/\/ iterate two times\n+            iload_1; iconst_2; if_icmpgt end;\n+\n+            aload_0; iload_1; withfield x:I; astore_0;\n+            aload_0; iload_1; withfield y:I; astore_0;\n+\n+            aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+            iinc 1,1; goto loop;\n+\n+        end: stack_frame_type same;\n+            aload_0; areturn;\n+    }\n+\n+    \/\/ escape using a different local variable\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test5:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        aconst_init FooValue; astore_1;\n+        aload_0; astore_1;\n+\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_1; areturn;\n+    }\n+\n+    \/\/ escape using aastore\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test6:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 3 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        getstatic TestWithfieldC1.foo_static_arr:\"[Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+        iconst_0; aload_0; aastore;\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ Copying a value into different local slots -- disable withfield optimization\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test7:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        aconst_init FooValue; astore_1;\n+        aload_0; astore_1;\n+\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape by invoking non-static method\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test8:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokevirtual non_static_method:\"()V\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    @+compiler\/lib\/ir_framework\/DontInline{}\n+    private Method non_static_method:\"()V\" stack 1 {\n+        aload_0;\n+        invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+        return;\n+    }\n+\n+    \/\/ duplicate reference with local variables\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test9:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 3 {\n+        aconst_init FooValue; astore_1;\n+        aload_1; iconst_1; withfield x:I; astore_1;\n+        aload_1; iconst_1; withfield y:I; astore_1;\n+\n+        aload_1; astore_2;\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_2; iconst_3; withfield x:I; astore_2;\n+        aload_2; iconst_3; withfield y:I; astore_2;\n+\n+        aload_0; aload_2; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_1; areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1Classes.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ These classes are based on the following source.  The return type of factory\n+\/\/ method <vnew> in class HiddenPoint was changed to java.lang.Object because\n+\/\/ HiddenPoint will be defined as an inline hidden class.\n+\/\/\n+\/\/  inline class HiddenPoint {\n+\/\/      int x;\n+\/\/      int y;\n+\/\/\n+\/\/      HiddenPoint() {\n+\/\/          this.x = 0;\n+\/\/          this.y = 0;\n+\/\/      }\n+\/\/      public String getValue() {\n+\/\/          return \"x: \" + x + \", y: \" + y;\n+\/\/      }\n+\/\/  }\n+\n+class HiddenPoint {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [40] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"HiddenPoint\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1B\n+    NameAndType #5 #6; \/\/ #4     at 0x20\n+    Utf8 \"x\"; \/\/ #5     at 0x25\n+    Utf8 \"I\"; \/\/ #6     at 0x29\n+    Field #1 #8; \/\/ #7     at 0x2D\n+    NameAndType #9 #6; \/\/ #8     at 0x32\n+    Utf8 \"y\"; \/\/ #9     at 0x37\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x3B\n+    NameAndType #12 #13; \/\/ #11     at 0x40\n+    Utf8 \"makeConcatWithConstants\"; \/\/ #12     at 0x45\n+    Utf8 \"(II)Ljava\/lang\/String;\"; \/\/ #13     at 0x5F\n+    class #15; \/\/ #14     at 0x78\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15     at 0x7B\n+    Utf8 \"getValue\"; \/\/ #16     at 0x8E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #17     at 0x99\n+    Utf8 \"Code\"; \/\/ #18     at 0xB0\n+    Utf8 \"LineNumberTable\"; \/\/ #19     at 0xB7\n+    Utf8 \"<vnew>\"; \/\/ #20     at 0xC9\n+    Utf8 \"()Ljava\/lang\/Object;\"; \/\/ #21     at 0xD2\n+    Utf8 \"SourceFile\"; \/\/ #22     at 0xE4\n+    Utf8 \"HiddenPoint.java\"; \/\/ #23     at 0xF1\n+    Utf8 \"BootstrapMethods\"; \/\/ #24     at 0x0104\n+    MethodHandle 6b #26; \/\/ #25     at 0x0117\n+    Method #27 #28; \/\/ #26     at 0x011B\n+    class #29; \/\/ #27     at 0x0120\n+    NameAndType #12 #30; \/\/ #28     at 0x0123\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\"; \/\/ #29     at 0x0128\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #30     at 0x014F\n+    String #32; \/\/ #31     at 0x01EA\n+    Utf8 \"x: , y: \"; \/\/ #32     at 0x01ED\n+    Utf8 \"InnerClasses\"; \/\/ #33     at 0x01FA\n+    class #35; \/\/ #34     at 0x0209\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #35     at 0x020C\n+    class #37; \/\/ #36     at 0x0234\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #37     at 0x0237\n+    Utf8 \"Lookup\"; \/\/ #38     at 0x0258\n+    Utf8 \"Preload\"; \/\/ #39     at 0x0261\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_VALUE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0x0275\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x027D\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index       : y\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0287\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index       : getValue\n+      #17; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#18, 38) { \/\/ Code at 0x028F\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[14]{\n+            0x2AB400032AB40007;\n+            0xBA000A0000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#19, 6) { \/\/ LineNumberTable at 0x02AF\n+              [1] { \/\/ line_number_table\n+                0  10; \/\/  at 0x02BB\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x02BB\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index       : <vnew>\n+      #21; \/\/ descriptor_index : ()LHiddenPoint;\n+      [1] { \/\/ Attributes\n+        Attr(#18, 56) { \/\/ Code at 0x02C3\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#19, 18) { \/\/ LineNumberTable at 0x02E9\n+              [4] { \/\/ line_number_table\n+                0  5; \/\/  at 0x02F5\n+                4  6; \/\/  at 0x02F9\n+                11  7; \/\/  at 0x02FD\n+                18  8; \/\/  at 0x0301\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#22, 2) { \/\/ SourceFile at 0x0303\n+      #23;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#24, 8) { \/\/ BootstrapMethods at 0x030B\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [1] { \/\/ bootstrap_arguments\n+            #31; \/\/  at 0x0319\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#33, 10) { \/\/ InnerClasses at 0x0319\n+      [1] { \/\/ classes\n+        #34 #36 #38 25; \/\/  at 0x0329\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#39, 4) { \/\/ Preload at 0x0329\n+      0x00010001;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class HiddenPoint\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This class provides two static methods equivalent to this Java source code:\n+ * void createArray0() {\n+ *     Element0 array = new Element0[10][10]; \/\/ Element0 is expected to be an inline type\n+ * }\n+ * void createArray1() {\n+ *     Element1 array = new Element1[10][10]; \/\/ Element1 is expected to be a reference type\n+ * }\n+ *\/\n+\n+class MultiANewArrayTypeCheck {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"[[QElement0;\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"[[LElement1;\"; \/\/ #10\n+    class #12; \/\/ #11\n+    Utf8 \"MultiANewArrayTypeCheck\"; \/\/ #12\n+    Utf8 \"Code\"; \/\/ #13\n+    Utf8 \"LineNumberTable\"; \/\/ #14\n+    Utf8 \"createArray0\"; \/\/ #15\n+    Utf8 \"createArray1\"; \/\/ #16\n+    Utf8 \"SourceFile\"; \/\/ #17\n+    Utf8 \"MultiANewArrayTypeCheck.java\"; \/\/ #18\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #11;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x100A100AC5000702;\n+            0x4BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                9  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #16; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x100A100AC5000902;\n+            0x4BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                9  9;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#17) { \/\/ SourceFile\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MultiANewArrayTypeCheck\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTypeCheck.jcod","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/TestPrimitiveClass\n+    version 66:0\n+{\n+    final Field nullableField:   \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+    final Field nullfreeField:   \"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ flattened\n+    final Field nullField:       \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ src of null\n+    final Field nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ not flattened\n+    final Field nullBigField:    \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ src of null\n+\n+    public Method withNullableField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullableField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        areturn;\n+    }\n+\n+    public Method withNullfreeField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullfreeField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        areturn;\n+    }\n+\n+    public Method withNullfreeBigField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\";\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullabilityClasses.jasm","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClass version 66:0 {\n+\n+    Field field:\"Qruntime\/valhalla\/inlinetypes\/MyValue;\";\n+\n+    public Method \"<init>\":\"()V\"\n+      stack 1 locals 1\n+    {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public Method test:\"()V\" stack 2 locals 1 {\n+        aload_0;\n+        aconst_null;\n+        putfield Field field:\"Qruntime\/valhalla\/inlinetypes\/MyValue;\";\n+        return;\n+    }\n+}\n+\n+super public final class runtime\/valhalla\/inlinetypes\/MyValue version 66:0 {\n+    Field foo:I = 42;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClasses.jasm","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The test class is based in the Java source code below, but the constant\n+\/\/ pool entry #33 (used by the Preload attribute) has been modified to\n+\/\/ contain the name of a non-existing class.\n+\/\/\n+\/\/ public class ValuePreloadClient1 {\n+\/\/     PreloadValue0 value;\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         System.out.print(\"Success\");\n+\/\/     }\n+\/\/ }\n+\n+ class ValuePreloadClient1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/System\"; \/\/ #10\n+    Utf8 \"out\"; \/\/ #11\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"Success\"; \/\/ #14\n+    Method #16 #17; \/\/ #15\n+    class #18; \/\/ #16\n+    NameAndType #19 #20; \/\/ #17\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18\n+    Utf8 \"print\"; \/\/ #19\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"ValuePreloadClient1\"; \/\/ #22\n+    Utf8 \"value\"; \/\/ #23\n+    Utf8 \"LPreloadValue0;\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"main\"; \/\/ #27\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"ValuePreloadClient1.java\"; \/\/ #30\n+    Utf8 \"Preload\"; \/\/ #31\n+    class #33; \/\/ #32\n+    Utf8 \"PreloadValue1\"; \/\/ #33\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#31) { \/\/ Preload\n+      0x00010020;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class ValuePreloadClient1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadClient1.jcod","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldOwner\n+    version 66:0\n+{\n+    NestHost runtime\/valhalla\/inlinetypes\/WithFieldNestHost;\n+\n+    public final Field c:C;\n+    protected final Field l:J;\n+    final Field d:D;\n+    private final Field i:I;\n+\n+    public Method checkFields:\"(CJDI)V\" stack 4 {\n+        aload_0;\n+        getfield c:C;\n+        invokestatic java\/lang\/Character.valueOf:\"(C)Ljava\/lang\/Character;\";\n+        iload_1;\n+        invokestatic java\/lang\/Character.valueOf:\"(C)Ljava\/lang\/Character;\";\n+        ldc \"unexpected c value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield l:J;\n+        invokestatic java\/lang\/Long.valueOf:\"(J)Ljava\/lang\/Long;\";\n+        lload_2;\n+        invokestatic java\/lang\/Long.valueOf:\"(J)Ljava\/lang\/Long;\";\n+        ldc \"unexpected l value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield d:D;\n+        invokestatic java\/lang\/Double.valueOf:\"(D)Ljava\/lang\/Double;\";\n+        dload 4;\n+        invokestatic java\/lang\/Double.valueOf:\"(D)Ljava\/lang\/Double;\";\n+        ldc \"unexpected d value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield i:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload 6;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"unexpected i value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        return;\n+    }\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldNestmate\n+    version 66:0\n+{\n+    NestHost runtime\/valhalla\/inlinetypes\/WithFieldNestHost;\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldNestHost\n+    version 66:0\n+{\n+    NestMembers runtime\/valhalla\/inlinetypes\/WithFieldOwner, runtime\/valhalla\/inlinetypes\/WithFieldNestmate;\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldSamePackage\n+    version 66:0\n+{\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTestClasses.jasm","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldPoint\n+    version 66:0\n+{\n+\n+    private final Field x:I;\n+    private final Field y:I;\n+\n+    public static Method make:\"(II)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\"\n+        stack 4\n+    {\n+        aconst_init runtime\/valhalla\/inlinetypes\/WithFieldPoint;\n+        dup;\n+        iconst_0;\n+        iconst_0;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        iload_0;\n+        withfield x:I;\n+        dup;\n+        iload_0;\n+        iconst_0;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        iload_1;\n+        withfield y:I;\n+        dup;\n+        iload_0;\n+        iload_1;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        areturn;\n+    }\n+\n+    public Method getX:\"()I\" stack 1 {\n+        aload_0;\n+        getfield x:I;\n+        ireturn;\n+    }\n+\n+    public Method getY:\"()I\" stack 1 {\n+        aload_0;\n+        getfield y:I;\n+        ireturn;\n+    }\n+\n+    public Method withX:\"(I)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield x:I;\n+        areturn;\n+    }\n+\n+    public Method withY:\"(I)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield y:I;\n+        areturn;\n+    }\n+\n+    public Method checkFields:\"(II)V\" stack 3 {\n+        aload_0;\n+        getfield x:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload_1;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"invalid x value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield y:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload_2;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"invalid y value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        return;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/AllTypes\n+    version 66:0\n+{\n+\n+    public final Field z:Z;\n+    public final Field b:B;\n+    public final Field s:S;\n+    public final Field c:C;\n+    public final Field i:I;\n+    public final Field l:J;\n+    public final Field f:F;\n+    public final Field d:D;\n+    public final Field o:\"Ljava\/lang\/Object;\";\n+    public final Field p:\"Qruntime\/valhalla\/inlinetypes\/Point;\";\n+\n+    public Method set_z:\"(Z)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield z:Z;\n+        areturn;\n+    }\n+\n+    public Method set_b:\"(B)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield b:B;\n+        areturn;\n+    }\n+\n+    public Method set_s:\"(S)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield s:S;\n+        areturn;\n+    }\n+\n+    public Method set_c:\"(C)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield c:C;\n+        areturn;\n+    }\n+\n+    public Method set_i:\"(I)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield i:I;\n+        areturn;\n+    }\n+\n+    public Method set_l:\"(J)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 3 {\n+        aload_0;\n+        lload_1;\n+        withfield l:J;\n+        areturn;\n+    }\n+\n+    public Method set_f:\"(F)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        fload_1;\n+        withfield f:F;\n+        areturn;\n+    }\n+\n+    public Method set_d:\"(D)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 3 {\n+        aload_0;\n+        dload_1;\n+        withfield d:D;\n+        areturn;\n+    }\n+\n+    public Method set_o:\"(Ljava\/lang\/Object;)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        aload_1;\n+        withfield o:\"Ljava\/lang\/Object;\";\n+        areturn;\n+    }\n+\n+    public Method set_p:\"(Qruntime\/valhalla\/inlinetypes\/Point;)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        aload_1;\n+        withfield p:\"Qruntime\/valhalla\/inlinetypes\/Point;\";\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldTestClasses.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,581 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ These tests are based on this .java file.  Each test case changed an access\n+\/\/ flag to cause a ClassFormatError exception when loading the class.\n+\/*\n+public abstract value class AbstractV {\n+\n+    static int x = 3;\n+\n+    public static synchronized void meth() {\n+        System.out.println(\"hi\");\n+    }\n+}\n+*\/\n+\n+\/\/ Removed ACC_STATIC from field access flags.\n+class AbstractVField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVField\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVField.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0441; \/\/ access [ ACC_PUBLIC ACC_ABSTRACT ACC_VALUE ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0000; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVField\n+\n+\n+\/\/ Added ACC_FINAL to class access flags.\n+class AbstractVFinal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVFinal\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVFinal.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0451; \/\/ access [ ACC_FINAL ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVFinal\n+\n+\n+\/\/ Added ACC_INTERFACE to class access flags\n+class AbstractVintf {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVintf\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVintf.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0641; \/\/ access [ ACC_INTERFACE ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVintf\n+\n+\n+\/\/ Changed the access flags for synchronized method meth() to not be static.\n+class AbstractVMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVMethod\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVMethod.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0441; \/\/ access [ ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x016F\n+      0x0021; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVMethod\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCCFETests.jcod","additions":581,"deletions":0,"binary":false,"changes":581,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This is an abstract class that cannot be a super class for value classes\n+\/\/ because ACC_IDENTITY is set in its class access flags.\n+\/\/ It's based on the following source:\n+\/*\n+public abstract class NonPVSuper {\n+\n+    static int x = 3;\n+\n+    public static void meth() {\n+        System.out.println(\"hi\");\n+    }\n+}\n+*\/\n+class NonPVSuper {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"NonPVSuper\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"NonPVSuper.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0421; \/\/ access [ ACC_PUBLIC ACC_IDENTITY ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0009; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NonPVSuper\n+\n+\n+\/\/ Dot is a value class that tries to inherit from a super class (NonPVSuper)\n+\/\/ that has access flag ACC_IDENTITY set.\n+\/\/ Dot is based on the following source:\n+\/*\n+public value final class Dot extends NonPVSuper {\n+    int x = 3;\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+class Dot {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [18] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"Dot\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"NonPVSuper\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x35\n+    Utf8 \"()I\"; \/\/ #10     at 0x3C\n+    Utf8 \"Code\"; \/\/ #11     at 0x42\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x49\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x5B\n+    Utf8 \"()LDot;\"; \/\/ #14     at 0x64\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x6E\n+    Utf8 \"Dot.java\"; \/\/ #16     at 0x7B\n+    Utf8 \"Preload\"; \/\/ #17     at 0x86\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9A\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xA4\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xAC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xC3\n+              [1] { \/\/ line_number_table\n+                0  5; \/\/  at 0xCF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xCF\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <vnew>\n+      #14; \/\/ descriptor_index : ()LDot;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 41) { \/\/ Code at 0xD7\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B062A5FCC;\n+            0x00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 10) { \/\/ LineNumberTable at 0xF6\n+              [2] { \/\/ line_number_table\n+                0  1; \/\/  at 0x0102\n+                4  2; \/\/  at 0x0106\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0108\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#17, 4) { \/\/ Preload at 0x0110\n+      0x00010001;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class Dot\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCICCETests.jcod","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,588 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ These test classes contains variations of Q-type signature uses which should\n+ only work with +EnablePrimitiveClasses\n+\n+ The original source with all the illegal cases looks like this, then below\n+ are classes with a single aspect declared (for each line in the prototype\n+ class listed)\n+\n+ public class PrimitiveUsers {\n+    MyPrimitive p;\n+    public static void staticCheckQArg(MyPrimitive p) {}\n+    public static MyPrimitive staticCheckQReturn() { return MyPrimitive.default; }\n+    public void checkQArg(MyPrimitive p) {}\n+    public MyPrimitive checkQReturn() { return MyPrimitive.default; }\n+ }\n+*\/\n+\n+\/\/ Use Q-signature field...\n+\n+class PrimitiveUsersField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveUsersField\"; \/\/ #8\n+    Utf8 \"p\"; \/\/ #9\n+    Utf8 \"QMyPrimitive;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"PrimitiveUsersField.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersField\n+\n+\n+\/\/ Static method q-sig in arg\n+\n+class PrimitiveUsersStaticQArg {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveUsersStaticQArg\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"staticCheckQArg\"; \/\/ #11\n+    Utf8 \"(QMyPrimitive;)V\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"PrimitiveUsersStaticQArg.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersStaticQArg\n+\n+\/\/ Static method q-sig in return\n+\n+class PrimitiveUsersStaticQReturn {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"MyPrimitive\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"PrimitiveUsersStaticQReturn\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"staticCheckQReturn\"; \/\/ #13\n+    Utf8 \"()QMyPrimitive;\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"PrimitiveUsersStaticQReturn.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #9;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index\n+      #14; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xCB0007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersStaticQReturn\n+\n+\/\/ Method with q-sig in arg\n+\n+class PrimitiveUsersQArg {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveUsersQArg\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"checkQArg\"; \/\/ #11\n+    Utf8 \"(QMyPrimitive;)V\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"PrimitiveUsersQArg.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersQArg\n+\n+\/\/ Method with q-sig in return\n+\n+class PrimitiveUsersQReturn {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"MyPrimitive\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"PrimitiveUsersQReturn\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"checkQReturn\"; \/\/ #13\n+    Utf8 \"()QMyPrimitive;\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"PrimitiveUsersQReturn.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #9;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #13; \/\/ name_index\n+      #14; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB0007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersQReturn\n+\n+\n+\/\/ Legal primitive class MyPrimitive for enabled use cases\n+\n+class MyPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"MyPrimitive\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"(I)QMyPrimitive;\"; \/\/ #6\n+    Field #2 #8; \/\/ #7\n+    NameAndType #9 #10; \/\/ #8\n+    Utf8 \"id\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    class #12; \/\/ #11\n+    Utf8 \"java\/lang\/Object\"; \/\/ #12\n+    Utf8 \"()QMyPrimitive;\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"SourceFile\"; \/\/ #16\n+    Utf8 \"MyPrimitive.java\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #2;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #13; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x03B800014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00024C1A2B5FCC;\n+            0x00074C2BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#16) { \/\/ SourceFile\n+      #17;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyPrimitive\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/PrimitiveUsers.jcod","additions":588,"deletions":0,"binary":false,"changes":588,"status":"added"},{"patch":"@@ -0,0 +1,2696 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This file contains multiple illegal inline type classes that should cause\n+\/\/ ClassFormatError exceptions when attempted to be loaded.\n+\/\/\n+\/\/ Many of these test were originally generated from this Java file and then\n+\/\/ modified to cause ClassFormatError or ClassCircularityError exceptions.  The\n+\/\/ '(bad)' comments in most of the tests show where the modifications were made.\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_ABSTRACT set.\n+\/\/\n+class ValueAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueAbstract\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueAbstract;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueAbstract\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueAbstract;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueAbstract.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x0C30; \/\/ access [  ACC_PRIMITIVE ACC_ABSTRACT(bad) ACC_SUPER ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueAbstract\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_ENUM set.\n+\/\/\n+class ValueEnum {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueEnum\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueEnum;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueEnum\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueEnum;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueEnum.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x04850; \/\/ access [  ACC_VALUE ACC_PRIMITIVE ACC_ENUM(bad) ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueEnum\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that inline type fields must be final.\n+\/\/\n+class ValueFieldNotFinal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueFieldNotFinal\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueFieldNotFinal;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueFieldNotFinal\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueFieldNotFinal;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueFieldNotFinal.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0000; \/\/ access [ Field not ACC_FINAL(bad) ]\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueFieldNotFinal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_INTERFACE set.\n+\/\/\n+class ValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LValueInterface;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x3C\n+    Utf8 \"I\"; \/\/ #11     at 0x44\n+    Utf8 \"<init>\"; \/\/ #12     at 0x48\n+    Utf8 \"()V\"; \/\/ #13     at 0x51\n+    Utf8 \"Code\"; \/\/ #14     at 0x57\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5E\n+    Utf8 \"makeValueInterface\"; \/\/ #16     at 0x70\n+    Utf8 \"(I)LValueInterface;\"; \/\/ #17     at 0x80\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x91\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x9C\n+    Utf8 \"ValueInterface.java\"; \/\/ #20     at 0xA9\n+    NameAndType #12 #13; \/\/ #21     at 0xBA\n+    NameAndType #10 #11; \/\/ #22     at 0xBF\n+    Utf8 \"ValueInterface\"; \/\/ #23     at 0xC4\n+    NameAndType #16 #17; \/\/ #24     at 0xD0\n+    NameAndType #8 #9; \/\/ #25     at 0xD5\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xDA\n+  } \/\/ Constant Pool\n+\n+  0x0A30; \/\/ access [ ACC_PRIMITIVE ACC_INTERFACE(bad) ACC_SUPER ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF7\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xFF\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0141\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0149\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0167\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0173\n+                4  9; \/\/  at 0x0177\n+                10  10; \/\/  at 0x017B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x01AC\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueInterface\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that inline type instance methods cannot be synchronized.\n+\/\/\n+\/\/ final inline class ValueMethodSynch {\n+\/\/     final int int_v;\n+\/\/\n+\/\/     ValueMethodSynch() { int_v = 1; }\n+\/\/\n+\/\/     int getInt(int x) { return x; }\n+\/\/ }\n+\n+class ValueMethodSynch {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"getInt\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)I\"; \/\/ #10     at 0x39\n+    Utf8 \"Code\"; \/\/ #11     at 0x40\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x47\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x59\n+    Utf8 \"()I\"; \/\/ #14     at 0x64\n+    Utf8 \"equals\"; \/\/ #15     at 0x6A\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x73\n+    Utf8 \"toString\"; \/\/ #17     at 0x8B\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0x96\n+    Utf8 \"<init>\"; \/\/ #19     at 0xAD\n+    Utf8 \"()QValueMethodSynch;\"; \/\/ #20     at 0xB6\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xCD\n+    Utf8 \"ValueMethodSynch.java\"; \/\/ #22     at 0xDA\n+    Utf8 \"ValueMethodSynch\"; \/\/ #23     at 0xF2\n+    NameAndType #7 #8; \/\/ #24     at 0x0105\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010A\n+    MethodHandle 6b #31; \/\/ #26     at 0x011D\n+    NameAndType #13 #32; \/\/ #27     at 0x0121\n+    NameAndType #15 #33; \/\/ #28     at 0x0126\n+    NameAndType #17 #34; \/\/ #29     at 0x012B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0130\n+    Method #35 #36; \/\/ #31     at 0x0143\n+    Utf8 \"(QValueMethodSynch;)I\"; \/\/ #32     at 0x0148\n+    Utf8 \"(QValueMethodSynch;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x0160\n+    Utf8 \"(QValueMethodSynch;)Ljava\/lang\/String;\"; \/\/ #34     at 0x018A\n+    class #37; \/\/ #35     at 0x01B3\n+    NameAndType #38 #42; \/\/ #36     at 0x01B6\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01BB\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01E4\n+    class #44; \/\/ #39     at 0x01FA\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01FD\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x0206\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0215\n+    class #45; \/\/ #43     at 0x028B\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x028E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02B6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02E1\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02EB\n+      0x0020; \/\/ access [ ACC_SYNCHRONIZED(bad) ]\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 26) { \/\/ Code at 0x02F3\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[2]{\n+            0x1BAC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0307\n+              [1] { \/\/ LineNumberTable\n+                0  9; \/\/  at 0x0313\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0313\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031B\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0334\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0340\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x0348\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0362\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x036E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036E\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0376\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x038F\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039B\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A3\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C2\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03CE\n+                4  5; \/\/  at 0x03D2\n+                11  6; \/\/  at 0x03D6\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03D8\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E0\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F0\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F0\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class ValueMethodSynch\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Inline types Circ and Circ2 have fields of each other's type.  This should\n+\/\/ cause a ClassCircularityError exception when one of them is being loaded.\n+\/\/\n+\/\/ The inline types are based on these two Java classes:\n+\/\/\n+\/\/ final inline class Circ {\n+\/\/     static final Circ VT = makeCirc(0x01234567);\n+\/\/     final int int_v;\n+\/\/     final Circ2 v2;\n+\/\/     Circ() {\n+\/\/         int_v = 1;\n+\/\/         v2 = Circ2.default;\n+\/\/     }\n+\/\/     static Circ makeCirc(int x) {\n+\/\/         Circ v = Circ.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/----------------------------------------------------------------\n+\/\/ final inline class Circ2 {\n+\/\/     static final Circ2 VT = makeCirc2('\\u0123');\n+\/\/     final char char_v;\n+\/\/     final Circ vv;\n+\/\/     Circ2() {\n+\/\/         char_v = 'z';\n+\/\/         vv = Circ.default;\n+\/\/     }\n+\/\/     static Circ2 makeCirc2(char c) {\n+\/\/         Circ2 v = Circ2.default;\n+\/\/         v = __WithField(v.char_v, c);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+class Circ {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    class #36; \/\/ #3     at 0x12\n+    Field #1 #37; \/\/ #4     at 0x15\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1A\n+    InvokeDynamic 0s #41; \/\/ #6     at 0x1F\n+    InvokeDynamic 0s #42; \/\/ #7     at 0x24\n+    int 0x01234567; \/\/ #8     at 0x29\n+    Method #1 #43; \/\/ #9     at 0x2E\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCirc;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x49\n+    Utf8 \"I\"; \/\/ #15     at 0x51\n+    Utf8 \"v2\"; \/\/ #16     at 0x55\n+    Utf8 \"QCirc2;\"; \/\/ #17     at 0x5A\n+    Utf8 \"makeCirc\"; \/\/ #18     at 0x65\n+    Utf8 \"(I)QCirc;\"; \/\/ #19     at 0x6F\n+    Utf8 \"Code\"; \/\/ #20     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x82\n+    Utf8 \"hashCode\"; \/\/ #22     at 0x94\n+    Utf8 \"()I\"; \/\/ #23     at 0x9F\n+    Utf8 \"equals\"; \/\/ #24     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xAE\n+    Utf8 \"toString\"; \/\/ #26     at 0xC6\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xD1\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0xE8\n+    Utf8 \"()V\"; \/\/ #29     at 0xF3\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0xF9\n+    Utf8 \"()QCirc;\"; \/\/ #31     at 0x0102\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x010D\n+    Utf8 \"Circ.java\"; \/\/ #33     at 0x011A\n+    Utf8 \"Circ\"; \/\/ #34     at 0x0126\n+    NameAndType #14 #15; \/\/ #35     at 0x012D\n+    Utf8 \"Circ2\"; \/\/ #36     at 0x0132\n+    NameAndType #16 #17; \/\/ #37     at 0x013A\n+    Utf8 \"BootstrapMethods\"; \/\/ #38     at 0x013F\n+    MethodHandle 6b #46; \/\/ #39     at 0x0152\n+    NameAndType #22 #47; \/\/ #40     at 0x0156\n+    NameAndType #24 #48; \/\/ #41     at 0x015B\n+    NameAndType #26 #49; \/\/ #42     at 0x0160\n+    NameAndType #18 #19; \/\/ #43     at 0x0165\n+    NameAndType #12 #13; \/\/ #44     at 0x016A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x016F\n+    Method #50 #51; \/\/ #46     at 0x0182\n+    Utf8 \"(QCirc;)I\"; \/\/ #47     at 0x0187\n+    Utf8 \"(QCirc;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x0193\n+    Utf8 \"(QCirc;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01B1\n+    class #52; \/\/ #50     at 0x01CE\n+    NameAndType #53 #57; \/\/ #51     at 0x01D1\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x01D6\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x01FF\n+    class #59; \/\/ #54     at 0x0215\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0218\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x0221\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x0230\n+    class #60; \/\/ #58     at 0x02A6\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02A9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x02D1\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x02FC\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0304\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030C\n+      0x0010; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0316\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x031E\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x033D\n+              [3] { \/\/ LineNumberTable\n+                0  12; \/\/  at 0x0349\n+                4  13; \/\/  at 0x034D\n+                11  14; \/\/  at 0x0351\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0351\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x0359\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0372\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x037E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x037E\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x0386\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00060000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03A0\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03AC\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03AC\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03B4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00070000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03CD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03D9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03D9\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 33) { \/\/ Code at 0x03E1\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1208B80009B3000A;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03FC\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0408\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0408\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 58) { \/\/ Code at 0x0410\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[22]{\n+            0xCB00014B042A5FCC;\n+            0x00024BCB00032A5F;\n+            0xCC00044B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 18) { \/\/ LineNumberTable at 0x0438\n+              [4] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0444\n+                4  7; \/\/  at 0x0448\n+                11  8; \/\/  at 0x044C\n+                20  9; \/\/  at 0x0450\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x0452\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x045A\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x046A\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#38, 6) { \/\/ BootstrapMethods at 0x046A\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #39; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class Circ\n+\n+class Circ2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [60] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #33; \/\/ #1     at 0x0A\n+    Field #1 #34; \/\/ #2     at 0x0D\n+    class #35; \/\/ #3     at 0x12\n+    Field #1 #36; \/\/ #4     at 0x15\n+    InvokeDynamic 0s #39; \/\/ #5     at 0x1A\n+    InvokeDynamic 0s #40; \/\/ #6     at 0x1F\n+    InvokeDynamic 0s #41; \/\/ #7     at 0x24\n+    Method #1 #42; \/\/ #8     at 0x29\n+    Field #1 #43; \/\/ #9     at 0x2E\n+    class #44; \/\/ #10     at 0x33\n+    Utf8 \"VT\"; \/\/ #11     at 0x36\n+    Utf8 \"QCirc2;\"; \/\/ #12     at 0x3B\n+    Utf8 \"char_v\"; \/\/ #13     at 0x45\n+    Utf8 \"C\"; \/\/ #14     at 0x4E\n+    Utf8 \"vv\"; \/\/ #15     at 0x52\n+    Utf8 \"QCirc;\"; \/\/ #16     at 0x57\n+    Utf8 \"makeCirc2\"; \/\/ #17     at 0x60\n+    Utf8 \"(C)QCirc2;\"; \/\/ #18     at 0x6C\n+    Utf8 \"Code\"; \/\/ #19     at 0x79\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0x80\n+    Utf8 \"hashCode\"; \/\/ #21     at 0x92\n+    Utf8 \"()I\"; \/\/ #22     at 0x9D\n+    Utf8 \"equals\"; \/\/ #23     at 0xA3\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAC\n+    Utf8 \"toString\"; \/\/ #25     at 0xC4\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #26     at 0xCF\n+    Utf8 \"<clinit>\"; \/\/ #27     at 0xE6\n+    Utf8 \"()V\"; \/\/ #28     at 0xF1\n+    Utf8 \"<vnew>\"; \/\/ #29     at 0xF7\n+    Utf8 \"()QCirc2;\"; \/\/ #30     at 0x0100\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x010C\n+    Utf8 \"Circ2.java\"; \/\/ #32     at 0x0119\n+    Utf8 \"Circ2\"; \/\/ #33     at 0x0126\n+    NameAndType #13 #14; \/\/ #34     at 0x012E\n+    Utf8 \"Circ\"; \/\/ #35     at 0x0133\n+    NameAndType #15 #16; \/\/ #36     at 0x013A\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x013F\n+    MethodHandle 6b #45; \/\/ #38     at 0x0152\n+    NameAndType #21 #46; \/\/ #39     at 0x0156\n+    NameAndType #23 #47; \/\/ #40     at 0x015B\n+    NameAndType #25 #48; \/\/ #41     at 0x0160\n+    NameAndType #17 #18; \/\/ #42     at 0x0165\n+    NameAndType #11 #12; \/\/ #43     at 0x016A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #44     at 0x016F\n+    Method #49 #50; \/\/ #45     at 0x0182\n+    Utf8 \"(QCirc2;)I\"; \/\/ #46     at 0x0187\n+    Utf8 \"(QCirc2;Ljava\/lang\/Object;)Z\"; \/\/ #47     at 0x0194\n+    Utf8 \"(QCirc2;)Ljava\/lang\/String;\"; \/\/ #48     at 0x01B3\n+    class #51; \/\/ #49     at 0x01D1\n+    NameAndType #52 #56; \/\/ #50     at 0x01D4\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #51     at 0x01D9\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #52     at 0x0202\n+    class #58; \/\/ #53     at 0x0218\n+    Utf8 \"Lookup\"; \/\/ #54     at 0x021B\n+    Utf8 \"InnerClasses\"; \/\/ #55     at 0x0224\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #56     at 0x0233\n+    class #59; \/\/ #57     at 0x02A9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #58     at 0x02AC\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #59     at 0x02D4\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #10;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x02FF\n+      0x0018; \/\/ access\n+      #11; \/\/ name_cpx\n+      #12; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0307\n+      0x0010; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030F\n+      0x0010; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0319\n+      0x0008; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 45) { \/\/ Code at 0x0321\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 14) { \/\/ LineNumberTable at 0x0340\n+              [3] { \/\/ LineNumberTable\n+                0  12; \/\/  at 0x034C\n+                4  13; \/\/  at 0x0350\n+                11  14; \/\/  at 0x0354\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0354\n+      0x0011; \/\/ access\n+      #21; \/\/ name_cpx\n+      #22; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 31) { \/\/ Code at 0x035C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x0375\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0381\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0381\n+      0x0011; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 32) { \/\/ Code at 0x0389\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00060000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x03A3\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03AF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03AF\n+      0x0011; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 31) { \/\/ Code at 0x03B7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00070000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x03D0\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03DC\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03DC\n+      0x0008; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 34) { \/\/ Code at 0x03E4\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[10]{\n+            0x110123B80008B300;\n+            0x09B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x0400\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x040C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x040C\n+      0x0008; \/\/ access\n+      #29; \/\/ name_cpx\n+      #30; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 59) { \/\/ Code at 0x0414\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B107A2A5F;\n+            0xCC00024BCB00032A;\n+            0x5FCC00044B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 18) { \/\/ LineNumberTable at 0x043D\n+              [4] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0449\n+                4  7; \/\/  at 0x044D\n+                12  8; \/\/  at 0x0451\n+                21  9; \/\/  at 0x0455\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x0457\n+      #32;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#55, 10) { \/\/ InnerClasses at 0x045F\n+      [1] { \/\/ InnerClasses\n+        #53 #57 #54 25; \/\/  at 0x046F\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x046F\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class Circ2\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Inline types CircStaticA and CircStaticB have static fields of each other's\n+\/\/ type.  This should cause a ClassCircularityError exception when one of them\n+\/\/ is being loaded.\n+\/\/\n+\/\/ The inline types are based on these two Java classes:\n+\/\/\n+\/\/ final inline class CircStaticA {\n+\/\/     static final CircStaticA VT = makeCircStaticA(0x01234567);\n+\/\/     final int int_v;\n+\/\/     static final CircStaticB v2 = CircStaticB.default;\n+\/\/     CircStaticA() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static CircStaticA makeCircStaticA(int x) {\n+\/\/         CircStaticA v = CircStaticA.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/----------------------------------------------------------------\n+\/\/ final inline class CircStaticB {\n+\/\/     static final CircStaticB VT = makeCircStaticB(0x01234567);\n+\/\/     final int int_v;\n+\/\/     static final CircStaticA v2 = CircStaticA.default;\n+\/\/     CircStaticB() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static CircStaticB makeCircStaticB(int x) {\n+\/\/         CircStaticB v = CircStaticB.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+class CircStaticA {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #38; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #39; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1C\n+    int 0x01234567; \/\/ #6     at 0x21\n+    Method #1 #41; \/\/ #7     at 0x26\n+    Field #1 #42; \/\/ #8     at 0x2B\n+    class #43; \/\/ #9     at 0x30\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCircStaticA;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x50\n+    Utf8 \"I\"; \/\/ #15     at 0x58\n+    Utf8 \"v2\"; \/\/ #16     at 0x5C\n+    Utf8 \"QCircStaticB;\"; \/\/ #17     at 0x61\n+    Utf8 \"makeCircStaticA\"; \/\/ #18     at 0x71\n+    Utf8 \"(I)QCircStaticA;\"; \/\/ #19     at 0x83\n+    Utf8 \"Code\"; \/\/ #20     at 0x96\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x9D\n+    Utf8 \"hashCode\"; \/\/ #22     at 0xAF\n+    Utf8 \"()I\"; \/\/ #23     at 0xBA\n+    Utf8 \"equals\"; \/\/ #24     at 0xC0\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xC9\n+    Utf8 \"toString\"; \/\/ #26     at 0xE1\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xEC\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0x0103\n+    Utf8 \"()V\"; \/\/ #29     at 0x010E\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0x0114\n+    Utf8 \"()QCircStaticA;\"; \/\/ #31     at 0x011D\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x012F\n+    Utf8 \"CircStaticA.java\"; \/\/ #33     at 0x013C\n+    Utf8 \"CircStaticA\"; \/\/ #34     at 0x014F\n+    NameAndType #14 #15; \/\/ #35     at 0x015D\n+    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0162\n+    MethodHandle 6b #46; \/\/ #37     at 0x0175\n+    NameAndType #22 #47; \/\/ #38     at 0x0179\n+    NameAndType #24 #48; \/\/ #39     at 0x017E\n+    NameAndType #26 #49; \/\/ #40     at 0x0183\n+    NameAndType #18 #19; \/\/ #41     at 0x0188\n+    NameAndType #12 #13; \/\/ #42     at 0x018D\n+    Utf8 \"CircStaticB\"; \/\/ #43     at 0x0192\n+    NameAndType #16 #17; \/\/ #44     at 0x01A0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x01A5\n+    Method #50 #51; \/\/ #46     at 0x01B8\n+    Utf8 \"(QCircStaticA;)I\"; \/\/ #47     at 0x01BD\n+    Utf8 \"(QCircStaticA;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x01D0\n+    Utf8 \"(QCircStaticA;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01F5\n+    class #52; \/\/ #50     at 0x0219\n+    NameAndType #53 #57; \/\/ #51     at 0x021C\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x0221\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x024A\n+    class #59; \/\/ #54     at 0x0260\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0263\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x026C\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x027B\n+    class #60; \/\/ #58     at 0x02F1\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02F4\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x031C\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x0347\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x034F\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0357\n+      0x0018; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0361\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0369\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0388\n+              [3] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x0394\n+                4  12; \/\/  at 0x0398\n+                11  13; \/\/  at 0x039C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039C\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03A4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03BD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C9\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x03D1\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03EB\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F7\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03FF\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0418\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0424\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0424\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 43) { \/\/ Code at 0x042C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[15]{\n+            0x1206B80007B30008;\n+            0xCB0009B3000AB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 10) { \/\/ LineNumberTable at 0x044D\n+              [2] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0459\n+                8  4; \/\/  at 0x045D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x045D\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0465\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0484\n+              [3] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0490\n+                4  7; \/\/  at 0x0494\n+                11  8; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x049A\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x04A2\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x04B2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#36, 6) { \/\/ BootstrapMethods at 0x04B2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #37; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class CircStaticA\n+\n+class CircStaticB {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #38; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #39; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1C\n+    int 0x01234567; \/\/ #6     at 0x21\n+    Method #1 #41; \/\/ #7     at 0x26\n+    Field #1 #42; \/\/ #8     at 0x2B\n+    class #43; \/\/ #9     at 0x30\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCircStaticB;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x50\n+    Utf8 \"I\"; \/\/ #15     at 0x58\n+    Utf8 \"v2\"; \/\/ #16     at 0x5C\n+    Utf8 \"QCircStaticA;\"; \/\/ #17     at 0x61\n+    Utf8 \"makeCircStaticB\"; \/\/ #18     at 0x71\n+    Utf8 \"(I)QCircStaticB;\"; \/\/ #19     at 0x83\n+    Utf8 \"Code\"; \/\/ #20     at 0x96\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x9D\n+    Utf8 \"hashCode\"; \/\/ #22     at 0xAF\n+    Utf8 \"()I\"; \/\/ #23     at 0xBA\n+    Utf8 \"equals\"; \/\/ #24     at 0xC0\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xC9\n+    Utf8 \"toString\"; \/\/ #26     at 0xE1\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xEC\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0x0103\n+    Utf8 \"()V\"; \/\/ #29     at 0x010E\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0x0114\n+    Utf8 \"()QCircStaticB;\"; \/\/ #31     at 0x011D\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x012F\n+    Utf8 \"CircStaticB.java\"; \/\/ #33     at 0x013C\n+    Utf8 \"CircStaticB\"; \/\/ #34     at 0x014F\n+    NameAndType #14 #15; \/\/ #35     at 0x015D\n+    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0162\n+    MethodHandle 6b #46; \/\/ #37     at 0x0175\n+    NameAndType #22 #47; \/\/ #38     at 0x0179\n+    NameAndType #24 #48; \/\/ #39     at 0x017E\n+    NameAndType #26 #49; \/\/ #40     at 0x0183\n+    NameAndType #18 #19; \/\/ #41     at 0x0188\n+    NameAndType #12 #13; \/\/ #42     at 0x018D\n+    Utf8 \"CircStaticA\"; \/\/ #43     at 0x0192\n+    NameAndType #16 #17; \/\/ #44     at 0x01A0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x01A5\n+    Method #50 #51; \/\/ #46     at 0x01B8\n+    Utf8 \"(QCircStaticB;)I\"; \/\/ #47     at 0x01BD\n+    Utf8 \"(QCircStaticB;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x01D0\n+    Utf8 \"(QCircStaticB;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01F5\n+    class #52; \/\/ #50     at 0x0219\n+    NameAndType #53 #57; \/\/ #51     at 0x021C\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x0221\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x024A\n+    class #59; \/\/ #54     at 0x0260\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0263\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x026C\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x027B\n+    class #60; \/\/ #58     at 0x02F1\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02F4\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x031C\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x0347\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x034F\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0357\n+      0x0018; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0361\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0369\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0388\n+              [3] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x0394\n+                4  12; \/\/  at 0x0398\n+                11  13; \/\/  at 0x039C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039C\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03A4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03BD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C9\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x03D1\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03EB\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F7\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03FF\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0418\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0424\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0424\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 43) { \/\/ Code at 0x042C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[15]{\n+            0x1206B80007B30008;\n+            0xCB0009B3000AB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 10) { \/\/ LineNumberTable at 0x044D\n+              [2] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0459\n+                8  4; \/\/  at 0x045D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x045D\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0465\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0484\n+              [3] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0490\n+                4  7; \/\/  at 0x0494\n+                11  8; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x049A\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x04A2\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x04B2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#36, 6) { \/\/ BootstrapMethods at 0x04B2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #37; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class CircStaticB\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that an inline type cannot be Cloneable.\n+\/\/\n+\/\/ final inline class ValueCloneable implements Cloneable {\n+\/\/    final int field;\n+\/\/    private ValueCloneable() { field = 0; }\n+\/\/}\n+\n+class ValueCloneable {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #22; \/\/ #1     at 0x0A\n+    Field #1 #23; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #26; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #27; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #28; \/\/ #5     at 0x1C\n+    class #29; \/\/ #6     at 0x21\n+    class #30; \/\/ #7     at 0x24\n+    Utf8 \"field\"; \/\/ #8     at 0x27\n+    Utf8 \"I\"; \/\/ #9     at 0x2F\n+    Utf8 \"hashCode\"; \/\/ #10     at 0x33\n+    Utf8 \"()I\"; \/\/ #11     at 0x3E\n+    Utf8 \"Code\"; \/\/ #12     at 0x44\n+    Utf8 \"LineNumberTable\"; \/\/ #13     at 0x4B\n+    Utf8 \"equals\"; \/\/ #14     at 0x5D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #15     at 0x66\n+    Utf8 \"toString\"; \/\/ #16     at 0x7E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #17     at 0x89\n+    Utf8 \"<vnew>\"; \/\/ #18     at 0xA0\n+    Utf8 \"()QValueCloneable;\"; \/\/ #19     at 0xA9\n+    Utf8 \"SourceFile\"; \/\/ #20     at 0xBE\n+    Utf8 \"ValueCloneable.java\"; \/\/ #21     at 0xCB\n+    Utf8 \"ValueCloneable\"; \/\/ #22     at 0xE1\n+    NameAndType #8 #9; \/\/ #23     at 0xF2\n+    Utf8 \"BootstrapMethods\"; \/\/ #24     at 0xF7\n+    MethodHandle 6b #31; \/\/ #25     at 0x010A\n+    NameAndType #10 #32; \/\/ #26     at 0x010E\n+    NameAndType #14 #33; \/\/ #27     at 0x0113\n+    NameAndType #16 #34; \/\/ #28     at 0x0118\n+    Utf8 \"java\/lang\/Object\"; \/\/ #29     at 0x011D\n+    Utf8 \"java\/lang\/Cloneable\"; \/\/ #30     at 0x0130\n+    Method #35 #36; \/\/ #31     at 0x0146\n+    Utf8 \"(QValueCloneable;)I\"; \/\/ #32     at 0x014B\n+    Utf8 \"(QValueCloneable;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x0161\n+    Utf8 \"(QValueCloneable;)Ljava\/lang\/String;\"; \/\/ #34     at 0x0189\n+    class #37; \/\/ #35     at 0x01B0\n+    NameAndType #38 #42; \/\/ #36     at 0x01B3\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01B8\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01E1\n+    class #44; \/\/ #39     at 0x01F7\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01FA\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0212\n+    class #45; \/\/ #43     at 0x0288\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x028B\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02B3\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [1] { \/\/ Interfaces\n+    #7;\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02E0\n+      0x0010; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [4] { \/\/ methods\n+    { \/\/ Member at 0x02EA\n+      0x0011; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 31) { \/\/ Code at 0x02F2\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x030B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0317\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0317\n+      0x0011; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 32) { \/\/ Code at 0x031F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0339\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0345\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0345\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 31) { \/\/ Code at 0x034D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0366\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0372\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0372\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 37) { \/\/ Code at 0x037A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B032A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0399\n+              [1] { \/\/ LineNumberTable\n+                0  3; \/\/  at 0x03A5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#20, 2) { \/\/ SourceFile at 0x03A7\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03AF\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03BF\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#24, 6) { \/\/ BootstrapMethods at 0x03BF\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class ValueCloneable\n+\n+\n+\/\/ Test that a class with an old class file version cannot contain a Q signature.\n+class OldClassWithQSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [29] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"OldClassWithQSig\"; \/\/ #1     at 0x0A\n+    class #1; \/\/ #2     at 0x1A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #3     at 0x1D\n+    class #3; \/\/ #4     at 0x30\n+    Utf8 \"inlineclasses.scala\"; \/\/ #5     at 0x33\n+    Utf8 \"Lscala\/reflect\/ScalaSignature;\"; \/\/ #6     at 0x49\n+    Utf8 \"bytes\"; \/\/ #7     at 0x6A\n+    Utf8 \"i1QB\\t!AAC\\bI\\t\\tQ!!Q\\nEAQ!YQ\\\"T=J]2Lg.Z\\\"mCN(\\\"q*W;z}\\r1C\\n!\\tQQ\\\"D\\fa!B:dC2\\fB\\b\\f\\te.*fM\\t.F!\\tQ!#\\tJ;%Aj]&$h\\b3AA!)qba#\"; \/\/ #8     at 0x72\n+    Utf8 \"i\"; \/\/ #9     at 0x0128\n+    Utf8 \"I\"; \/\/ #10     at 0x012C\n+    Utf8 \"()I\"; \/\/ #11     at 0x0130\n+    NameAndType #9 #10; \/\/ #12     at 0x0136\n+    Field #2 #12; \/\/ #13     at 0x013B\n+    Utf8 \"this\"; \/\/ #14     at 0x0140\n+    Utf8 \"QOldClassWithQSig;\"; \/\/ #15     at 0x0147\n+    Utf8 \"<init>\"; \/\/ #16     at 0x0159\n+    Utf8 \"(I)V\"; \/\/ #17     at 0x0162\n+    Utf8 \"()V\"; \/\/ #18     at 0x0169\n+    NameAndType #16 #18; \/\/ #19     at 0x016F\n+    Method #4 #19; \/\/ #20     at 0x0174\n+    Utf8 \"Code\"; \/\/ #21     at 0x0179\n+    Utf8 \"LineNumberTable\"; \/\/ #22     at 0x0180\n+    Utf8 \"LocalVariableTable\"; \/\/ #23     at 0x0192\n+    Utf8 \"MethodParameters\"; \/\/ #24     at 0x01A7\n+    Utf8 \"SourceFile\"; \/\/ #25     at 0x01BA\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #26     at 0x01C7\n+    Utf8 \"ScalaInlineInfo\"; \/\/ #27     at 0x01E3\n+    Utf8 \"ScalaSig\"; \/\/ #28     at 0x01F5\n+  } \/\/ Constant Pool\n+\n+  0x0121; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x020A\n+      0x0012; \/\/ access\n+      #9; \/\/ name_index       : i\n+      #10; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0214\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : i\n+      #11; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#21, 47) { \/\/ Code at 0x021C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB4000DAC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#22, 6) { \/\/ LineNumberTable at 0x0233\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0x023F\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23, 12) { \/\/ LocalVariableTable at 0x023F\n+              [1] { \/\/ LocalVariableTable\n+                0 5 14 15 0; \/\/  at 0x0251\n+              }\n+            } \/\/ end LocalVariableTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0251\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index       : <init>\n+      #17; \/\/ descriptor_index : (I)V\n+      [2] { \/\/ Attributes\n+        Attr(#21, 70) { \/\/ Code at 0x0259\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[10]{\n+            0x2A1BB5000D2AB700;\n+            0x14B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#22, 14) { \/\/ LineNumberTable at 0x0275\n+              [3] { \/\/ line_number_table\n+                0  1; \/\/  at 0x0281\n+                5  3; \/\/  at 0x0285\n+                9  1; \/\/  at 0x0289\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23, 22) { \/\/ LocalVariableTable at 0x0289\n+              [2] { \/\/ LocalVariableTable\n+                0 10 14 15 0; \/\/  at 0x029B\n+                0 10 9 10 1; \/\/  at 0x02A5\n+              }\n+            } \/\/ end LocalVariableTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#24, 5) { \/\/ MethodParameters at 0x02A5\n+          [1]b { \/\/ MethodParameters\n+            #9  0x0010; \/\/  at 0x02B0\n+          }\n+        } \/\/ end MethodParameters\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#25, 2) { \/\/ SourceFile at 0x02B2\n+      #5;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#26, 11) { \/\/ RuntimeVisibleAnnotations at 0x02BA\n+      [1] { \/\/ annotations\n+        {  \/\/  annotation\n+          #6;\n+          [1] { \/\/ element_value_pairs\n+            {  \/\/  element value pair\n+              #7;\n+              {  \/\/  element_value\n+                's';\n+                #8;\n+              }  \/\/  element_value\n+            }  \/\/  element value pair\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27, 14) { \/\/ ScalaInlineInfo at 0x02CB\n+      0x0100000200100011;\n+      0x000009000B00;\n+    } \/\/ end ScalaInlineInfo\n+    ;\n+    Attr(#28, 3) { \/\/ ScalaSig at 0x02DF\n+      0x050200;\n+    } \/\/ end ScalaSig\n+  } \/\/ Attributes\n+} \/\/ end class OldClassWithQSig\n+\n+\n+\/\/ Test that a class with an old class file version cannot contain an array Q signature.\n+class OldClassWithQArraySig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"java\/lang\/Integer\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x50\n+    class #12; \/\/ #10     at 0x55\n+    NameAndType #13 #14; \/\/ #11     at 0x58\n+    Utf8 \"OldClassWithQArraySig\"; \/\/ #12     at 0x5D\n+    Utf8 \"ia\"; \/\/ #13     at 0x65\n+    Utf8 \"[Qjava\/lang\/Integer;\"; \/\/ #14     at 0x6A\n+    Utf8 \"Code\"; \/\/ #15     at 0x81\n+    Utf8 \"LineNumberTable\"; \/\/ #16     at 0x88\n+    Utf8 \"runIt\"; \/\/ #17     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0xA2\n+    Utf8 \"OldClassWithQArraySig.java\"; \/\/ #19     at 0xAF\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xC6\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : ia\n+      #14; \/\/ descriptor_index : [Qjava\/lang\/Integer;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD0\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#15, 29) { \/\/ Code at 0xD8\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#16, 6) { \/\/ LineNumberTable at 0xEF\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFB\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFB\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index       : runIt\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#15, 37) { \/\/ Code at 0x0103\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0x2A05BD0007B50009;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#16, 10) { \/\/ LineNumberTable at 0x011E\n+              [2] { \/\/ line_number_table\n+                0  6; \/\/  at 0x012A\n+                8  7; \/\/  at 0x012E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x0130\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class OldClassWithQArraySig\n+\n+\n+\/\/ This class has a super_cpx of zero.  This should cause a ClassFormatError\n+\/\/ exception when this class is loaded.\n+class SuperIsZero {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [15] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"SuperIsZero\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1A\n+    NameAndType #5 #6; \/\/ #4     at 0x1F\n+    Utf8 \"x\"; \/\/ #5     at 0x24\n+    Utf8 \"I\"; \/\/ #6     at 0x28\n+    class #8; \/\/ #7     at 0x2C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x2F\n+    Utf8 \"<init>\"; \/\/ #9     at 0x42\n+    Utf8 \"()QSuperIsZero;\"; \/\/ #10     at 0x4B\n+    Utf8 \"Code\"; \/\/ #11     at 0x5C\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x63\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x75\n+    Utf8 \"SuperIsZero.java\"; \/\/ #14     at 0x82\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #0;\/\/ super_cpx \/\/ !!! changed 7 to 0\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9E\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xA8\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <init>\n+      #10; \/\/ descriptor_index : ()QSuperIsZero;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0xB0\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B082A5FCC;\n+            0x00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0xCF\n+              [3] { \/\/ line_number_table\n+                0  4; \/\/  at 0xDB\n+                4  5; \/\/  at 0xDF\n+                11  6; \/\/  at 0xE3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0xE5\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SuperIsZero\n+\n+\n+\/\/ This class file tests that a ClassFormatError exception is thrown for an old\n+\/\/ class file (version 49) containing a Q signature.  This file is based on the\n+\/\/ following Java code, except the signature for method callDot() was changed\n+\/\/ to \"(QDot;)V\";.\n+\/*\n+public class QInOldClass {\n+\n+    public static void callDot(Dot d) {\n+        System.out.println(\"Hi Dot\");\n+    }\n+\n+}\n+*\/\n+class QInOldClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  49; \/\/ version\n+  [32] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"Hi Dot\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x83\n+    class #18; \/\/ #16     at 0x88\n+    NameAndType #19 #20; \/\/ #17     at 0x8B\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x90\n+    Utf8 \"println\"; \/\/ #19     at 0xA6\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xB0\n+    class #22; \/\/ #21     at 0xC8\n+    Utf8 \"QInOldClass\"; \/\/ #22     at 0xCB\n+    Utf8 \"Code\"; \/\/ #23     at 0xD6\n+    Utf8 \"LineNumberTable\"; \/\/ #24     at 0xDD\n+    Utf8 \"callDot\"; \/\/ #25     at 0xEF\n+    Utf8 \"(QDot;)V\"; \/\/ #26     at 0xF9\n+    Utf8 \"SourceFile\"; \/\/ #27     at 0x0104\n+    Utf8 \"QInOldClass.java\"; \/\/ #28     at 0x0111\n+    Utf8 \"Preload\"; \/\/ #29     at 0x0121\n+    class #31; \/\/ #30     at 0x012B\n+    Utf8 \"Dot\"; \/\/ #31     at 0x012E\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0140\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#23, 29) { \/\/ Code at 0x0148\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 6) { \/\/ LineNumberTable at 0x015F\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016B\n+      0x0009; \/\/ access\n+      #25; \/\/ name_index       : callDot\n+      #26; \/\/ descriptor_index : (LDot;)V\n+      [1] { \/\/ Attributes\n+        Attr(#23, 37) { \/\/ Code at 0x0173\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 10) { \/\/ LineNumberTable at 0x018E\n+              [2] { \/\/ line_number_table\n+                0  5; \/\/  at 0x019A\n+                8  6; \/\/  at 0x019E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#27, 2) { \/\/ SourceFile at 0x01A0\n+      #28;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#29, 4) { \/\/ Preload at 0x01A8\n+      0x0001001E;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class QInOldClass\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":2696,"deletions":0,"binary":false,"changes":2696,"status":"added"},{"patch":"@@ -0,0 +1,832 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ class ValueClassExtendingIdentityClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingIdentityClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"IdentityAbstract\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingIdentityClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingIdentityClass.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingIdentityClass\n+\n+class ValueClassExtendingAbstractClassWithField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingAbstractClassWithField\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"AbstractWithField\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingAbstractClassWithField;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingAbstractClassWithField.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingAbstractClassWithField\n+\n+class ValueClassExtendingAbstractClassWithSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingAbstractClassWithSynchMethod\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"AbstractWithSynchMethod\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingAbstractClassWithSynchMethod;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingAbstractClassWithSynchMethod.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingAbstractClassWithSynchMethod\n+\n+class ValueClassImplementingIdentityInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassImplementingIdentityInterface\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"IdentityInterface\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LValueClassImplementingIdentityInterface;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClassImplementingIdentityInterface.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassImplementingIdentityInterface\n+\n+class IdentityClassExtendingValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"ValueAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClassExtendingValueClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"IdentityClassExtendingValueClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class IdentityClassExtendingValueClass\n+\n+class IdentityClassImplementingValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClassImplementingValueInterface\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"ValueInterface\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"IdentityClassImplementingValueInterface.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #9;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class IdentityClassImplementingValueInterface\n+\n+class AbstractClassWithFieldExtendingValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"ValueAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldExtendingValueClass\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"AbstractClassWithFieldExtendingValueClass.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0420; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldExtendingValueClass\n+\n+class AbstractClassWithFieldImplementingValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldImplementingValueInterface\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"ValueInterface\"; \/\/ #10\n+    Utf8 \"i\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    Utf8 \"Code\"; \/\/ #13\n+    Utf8 \"LineNumberTable\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"AbstractClassWithFieldImplementingValueInterface.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0420; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #9;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldImplementingValueInterface\n+\n+class AbstractClassWithFieldWithNoIdentityModifier {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldWithNoIdentityModifier\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"AbstractClassWithFieldWithNoIdentityModifier.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0400; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldWithNoIdentityModifier\n+\n+class AbstractClassWithSynchMethodWithNoIdentityModifier {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithSynchMethodWithNoIdentityModifier\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"foo\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"AbstractClassWithSynchMethodWithNoIdentityModifier.java\"; \/\/ #13\n+  } \/\/ Constant Pool\n+\n+  0x0400; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0020; \/\/ access\n+      #11; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithSynchMethodWithNoIdentityModifier\n+\n+class AbstractClassWithBothModifiers {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithBothModifiers\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractClassWithBothModifiers.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0460; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithBothModifiers\n+\n+class ConcreteClassWithNoModifiers {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ConcreteClassWithNoModifiers\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ConcreteClassWithNoModifiers.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0000; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ConcreteClassWithNoModifiers\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/ClassesWithInvalidModifiers.jcod","additions":832,"deletions":0,"binary":false,"changes":832,"status":"added"},{"patch":"@@ -0,0 +1,2637 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ The test cases in this .jcod file are based on this .java file:\n+\/\/ public primitive final class Point extends AbstractClass {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private Point() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/ }\n+\n+\/\/ Primitive class with a super class that is not abstract.\n+class PrimitiveSuperNotAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperNotAbstract\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperNotAbstract;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperNotAbstract;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperNotAbstract;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"NotAbstract\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperNotAbstract;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperNotAbstract.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperNotAbstract\n+\n+\n+\n+\/\/ Primitive class with a super class that has instance fields.\n+class PrimitiveSuperHasNonStaticFields {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperHasNonStaticFields\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"HasNonStaticFields\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperHasNonStaticFields;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperHasNonStaticFields.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperHasNonStaticFields\n+\n+\n+\n+\/\/ primitive value class with a super class whose super class has a syncronized instance method.\n+class PrimitiveSuperHasSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperHasSynchMethod\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"ValidSuper\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperHasSynchMethod;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperHasSynchMethod.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperHasSynchMethod\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has arguments.\n+class PrimitiveSuperCtorHasArgs {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperCtorHasArgs\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorHasArgs\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperCtorHasArgs;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperCtorHasArgs.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperCtorHasArgs\n+\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has a non-empty\n+\/\/ method body.\n+class PrimitiveSuperCtorIsNotEmpty {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperCtorIsNotEmpty\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorIsNotEmpty\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperCtorIsNotEmpty;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperCtorIsNotEmpty.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperCtorIsNotEmpty\n+\n+\/\/ Again for value objects...\n+\n+\/\/ Value class with a super class that is not abstract.\n+class ValueSuperNotAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperNotAbstract\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperNotAbstract;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperNotAbstract;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperNotAbstract;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"NotAbstract\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperNotAbstract;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperNotAbstract.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperNotAbstract\n+\n+\n+\n+\/\/ Value class with a super class that has instance fields.\n+class ValueSuperHasNonStaticFields {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperHasNonStaticFields\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperHasNonStaticFields;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperHasNonStaticFields;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperHasNonStaticFields;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"HasNonStaticFields\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperHasNonStaticFields;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperHasNonStaticFields.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperHasNonStaticFields\n+\n+\n+\n+\/\/ primitive value class with a super class whose super class has a syncronized instance method.\n+class ValueSuperHasSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperHasSynchMethod\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperHasSynchMethod;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperHasSynchMethod;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperHasSynchMethod;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"ValidSuper\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperHasSynchMethod;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperHasSynchMethod.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperHasSynchMethod\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has arguments.\n+class ValueSuperCtorHasArgs {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperCtorHasArgs\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperCtorHasArgs;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperCtorHasArgs;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperCtorHasArgs;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorHasArgs\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperCtorHasArgs;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperCtorHasArgs.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperCtorHasArgs\n+\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has a non-empty\n+\/\/ method body.\n+class ValueSuperCtorIsNotEmpty {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperCtorIsNotEmpty\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorIsNotEmpty\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperCtorIsNotEmpty;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperCtorIsNotEmpty.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperCtorIsNotEmpty\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/InlineClassWithBadSupers.jcod","additions":2637,"deletions":0,"binary":false,"changes":2637,"status":"added"},{"patch":"@@ -0,0 +1,1608 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Many of the jcod classes in this file were derived from this Java inline type:\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ The changes for each test were made to the bytecodes for method makeValue(int x).\n+\/\/ Its bytecodes are:\n+\/\/\n+\/\/  static Value makeValue(int); descriptor: (I)LValue; flags: (0x0008) ACC_STATIC\n+\/\/    Code:\n+\/\/      stack=2, locals=2, args_size=1\n+\/\/         0: aconst_init   #3                  \/\/ class Value\n+\/\/         3: astore_1\n+\/\/         4: aload_1\n+\/\/         5: iload_0\n+\/\/         6: withfield     #2                  \/\/ Field int_v:I\n+\/\/         9: astore_1\n+\/\/        10: aload_1\n+\/\/        11: areturn\n+\n+\n+\/\/ The constant pool index of the aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 0x93.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class defValBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadCP;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadCP;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadCP.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadCP\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00934C2B1ACC00; \/\/ Changed CP index from 3 to 0x93 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54.  Since this class has a\n+\/\/ aconst_init opcode (0xCB), this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class defValBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 2.  Since this index now points to a Field\n+\/\/ entry instead of a Class entry, a VerifyError exception should get thrown.\n+\/\/\n+class defValWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValWrongCPType;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValWrongCPType;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValWrongCPType.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValWrongCPType\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00024C2B1ACC00; \/\/ Changed CP index from 3 to 2 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the cp index no longer points to a cp Class entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of the withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 0x82.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadCP\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadCP\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadCP;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadCP.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 0x82 for opcode 0xCC (withfield)\n+            0x824C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 5 in the Code array was changed to aload_1\n+\/\/ (0x2B).  This should cause a VerifyError because now the first operand on the\n+\/\/ stack for the withfield opcode (0xCC at bytecode position 6) does not match\n+\/\/ the type (int) of the field being assigned to.\n+\/\/\n+class wthFldBadFldVal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldVal\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldVal\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldVal;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldVal.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B2BCC00; \/\/ Changed opcode at bytecode 5 from iload_0 to aload_1\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldVal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 4 in the Code array was changed to iload_1\n+\/\/ (0x1A).  This should cause a VerifyError because the second operand on the stack\n+\/\/ for the withfield opcode (0xCC at bytecode position 6) must be a reference.\n+\/\/\n+class wthFldBadFldRef {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldRef\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldRef\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldRef;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldRef.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C1A1ACC00; \/\/ Changed opcode at bytecode 4 from aload_1 to iload_0\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldRef\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54 and the first opcode in the Code\n+\/\/ attribute was changed to a withfield (0xCC)..  Since withfield opcodes are not\n+\/\/ allowed in classes with major version 54, this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class wthFldBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LwthFldBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LwthFldBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"wthFldBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"wthFldBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCC00034C2B1ACC00; \/\/ Changed the first opcode to 0xCC (withfield) in order to\n+            0x024C2BB0;         \/\/ test withfield opcode with an illegal major version.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 1.  Since this index now points to a Method\n+\/\/ entry instead of a Field entry, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldWrongCPType\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldWrongCPType\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldWrongCPType;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldWrongCPType.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 1 for opcode 0xCC (withfield)\n+            0x014C2BB0;         \/\/ so that the cp index no longer points to a cp Field entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The cp entry for the aconst_init opcode was changed to a reference that\n+\/\/ is not an inline type.\n+\/\/ This should cause a VerifyError because the cp entry for opcode aconst_init\n+\/\/ must be an inline type.\n+\/\/\n+class defValueObj {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"makedefValueObj\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)QdefValueObj;\"; \/\/ #10     at 0x41\n+    Utf8 \"Code\"; \/\/ #11     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x5A\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x6C\n+    Utf8 \"()I\"; \/\/ #14     at 0x77\n+    Utf8 \"equals\"; \/\/ #15     at 0x7D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x86\n+    Utf8 \"toString\"; \/\/ #17     at 0x9E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0xA9\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0xC0\n+    Utf8 \"()QdefValueObj;\"; \/\/ #20     at 0xC9\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xDA\n+    Utf8 \"defValueObj.java\"; \/\/ #22     at 0xE7\n+    Utf8 \"defValueObj\"; \/\/ #23     at 0xF9\n+    NameAndType #7 #8; \/\/ #24     at 0x0106\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010B\n+    MethodHandle 6b #31; \/\/ #26     at 0x011E\n+    NameAndType #13 #32; \/\/ #27     at 0x0122\n+    NameAndType #15 #33; \/\/ #28     at 0x0127\n+    NameAndType #17 #34; \/\/ #29     at 0x012C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0131\n+    Method #35 #36; \/\/ #31     at 0x0144\n+    Utf8 \"(QdefValueObj;)I\"; \/\/ #32     at 0x0149\n+    Utf8 \"(QdefValueObj;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x015B\n+    Utf8 \"(QdefValueObj;)Ljava\/lang\/String;\"; \/\/ #34     at 0x017F\n+    class #37; \/\/ #35     at 0x01A2\n+    NameAndType #38 #42; \/\/ #36     at 0x01A5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01AA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01D3\n+    class #44; \/\/ #39     at 0x01E9\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01EC\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x01F5\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0204\n+    class #45; \/\/ #43     at 0x027A\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x027D\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02A5\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02D0\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02DA\n+      0x0008; \/\/ access\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x02E2\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00044C1A2B5FCC; \/\/ Changed aconst_init's cp index at byte 3 from 3 to 4.\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x0301\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x030D\n+                4  9; \/\/  at 0x0311\n+                11  10; \/\/  at 0x0315\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0315\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0336\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0342\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0342\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x034A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0364\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0370\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0370\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0378\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0391\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039D\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A5\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C4\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03D0\n+                4  5; \/\/  at 0x03D4\n+                11  6; \/\/  at 0x03D8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03DA\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E2\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class defValueObj\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ This class has a withfield opcode with a non-Q type operand.\n+class withfieldL {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldL\"; \/\/ #2     at 0x0D\n+    class #2; \/\/ #3     at 0x17\n+    Field #1 #5; \/\/ #4     at 0x1A\n+    NameAndType #6 #7; \/\/ #5     at 0x1F\n+    Utf8 \"x\"; \/\/ #6     at 0x24\n+    Utf8 \"I\"; \/\/ #7     at 0x28\n+    Field #1 #9; \/\/ #8     at 0x2C\n+    NameAndType #10 #7; \/\/ #9     at 0x31\n+    Utf8 \"y\"; \/\/ #10     at 0x36\n+    class #12; \/\/ #11     at 0x3A\n+    Utf8 \"QwithfieldL;\"; \/\/ #12     at 0x3D\n+    class #14; \/\/ #13     at 0x49\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14     at 0x4C\n+    Utf8 \"makePoint\"; \/\/ #15     at 0x5F\n+    Utf8 \"(II)QwithfieldL;\"; \/\/ #16     at 0x6B\n+    Utf8 \"Code\"; \/\/ #17     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x82\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0x94\n+    Utf8 \"()QwithfieldL;\"; \/\/ #20     at 0x9D\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xAB\n+    Utf8 \"X.java\"; \/\/ #22     at 0xB8\n+    Utf8 \"NestHost\"; \/\/ #23     at 0xC1\n+    class #25; \/\/ #24     at 0xCC\n+    Utf8 \"X\"; \/\/ #25     at 0xCF\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0xD3\n+    Utf8 \"Point\"; \/\/ #27     at 0xE2\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #13;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0xF4\n+      0x0010; \/\/ access\n+      #6; \/\/ name_index       : x\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0xFC\n+      0x0010; \/\/ access\n+      #10; \/\/ name_index       : y\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0106\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index       : makePoint\n+      #16; \/\/ descriptor_index : (II)QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x010E\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[26]{\n+            0xCB0001C000034D1A;\n+            0x2C5FCC00044D1B2C;\n+            0x5FCC00084D2CC000;\n+            0x0BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x013A\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0146\n+                7  5; \/\/  at 0x014A\n+                14  6; \/\/  at 0x014E\n+                21  7; \/\/  at 0x0152\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0152\n+      0x000A; \/\/ access\n+      #19; \/\/ name_index       : <vnew>\n+      #20; \/\/ descriptor_index : ()QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 55) { \/\/ Code at 0x015A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B032A5FCC;\n+            0x0008594BB400082A;\n+            0x5FCC00044B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0183\n+              [3] { \/\/ line_number_table\n+                0  9; \/\/  at 0x018F\n+                4  10; \/\/  at 0x0193\n+                21  11; \/\/  at 0x0197\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0199\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x01A1\n+      #24; \/\/ X at 0x01A9\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 10) { \/\/ InnerClasses at 0x01A9\n+      [1] { \/\/ classes\n+        #1 #24 #27 280; \/\/  at 0x01B9\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class withfieldL\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that a VerifyError exception is thrown when trying to pass a null\n+\/\/ when the formal parameter is an inline type.\n+\/\/\n+\/\/ \/\/ Java program emulating the jcod contents.\n+\/\/ public inline final class NoNullVT {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private NoNullVT() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/\n+\/\/     public boolean isSameNoNullVT(NoNullVT that) {\n+\/\/         return this.getX() == that.getX() && this.getY() == that.getY();\n+\/\/     }\n+\/\/\n+\/\/     public boolean equals(Object o) {\n+\/\/         if(o instanceof NoNullVT) {\n+\/\/             return ((NoNullVT)o).x == x &&  ((NoNullVT)o).y == y;\n+\/\/         } else {\n+\/\/             return false;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     public static NoNullVT createNoNullVT(int x, int y) {\n+\/\/         NoNullVT p = NoNullVT.default;\n+\/\/         p = __WithField(p.x, x);\n+\/\/         p = __WithField(p.y, y);\n+\/\/         return p;\n+\/\/     }\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         String str = null;\n+\/\/         NoNullVT a = createNoNullVT(3, 4);\n+\/\/         NoNullVT b = createNoNullVT(2, 4);\n+\/\/         boolean res = a.isSameNoNullVT(null); \/\/ Should throw VerifyError\n+\/\/     }\n+\/\/ }\n+\n+class NoNullVT {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [63] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #36; \/\/ #1     at 0x0A\n+    Field #1 #37; \/\/ #2     at 0x0D\n+    Field #1 #38; \/\/ #3     at 0x12\n+    Method #1 #39; \/\/ #4     at 0x17\n+    Method #1 #40; \/\/ #5     at 0x1C\n+    class #41; \/\/ #6     at 0x21\n+    Method #1 #42; \/\/ #7     at 0x24\n+    Method #1 #43; \/\/ #8     at 0x29\n+    InvokeDynamic 0s #46; \/\/ #9     at 0x2E\n+    InvokeDynamic 0s #47; \/\/ #10     at 0x33\n+    class #48; \/\/ #11     at 0x38\n+    Utf8 \"x\"; \/\/ #12     at 0x3B\n+    Utf8 \"I\"; \/\/ #13     at 0x3F\n+    Utf8 \"y\"; \/\/ #14     at 0x43\n+    Utf8 \"getX\"; \/\/ #15     at 0x47\n+    Utf8 \"()I\"; \/\/ #16     at 0x4E\n+    Utf8 \"Code\"; \/\/ #17     at 0x54\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x5B\n+    Utf8 \"getY\"; \/\/ #19     at 0x6D\n+    Utf8 \"isSameNoNullVT\"; \/\/ #20     at 0x74\n+    Utf8 \"(QNoNullVT;)Z\"; \/\/ #21     at 0x85\n+    Utf8 \"StackMapTable\"; \/\/ #22     at 0x95\n+    Utf8 \"equals\"; \/\/ #23     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAE\n+    Utf8 \"createNoNullVT\"; \/\/ #25     at 0xC6\n+    Utf8 \"(II)QNoNullVT;\"; \/\/ #26     at 0xD7\n+    Utf8 \"main\"; \/\/ #27     at 0xE8\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28     at 0xEF\n+    Utf8 \"hashCode\"; \/\/ #29     at 0x0108\n+    Utf8 \"toString\"; \/\/ #30     at 0x0113\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x011E\n+    Utf8 \"<vnew>\"; \/\/ #32     at 0x0135\n+    Utf8 \"()QNoNullVT;\"; \/\/ #33     at 0x013E\n+    Utf8 \"SourceFile\"; \/\/ #34     at 0x014D\n+    Utf8 \"NoNullVT.java\"; \/\/ #35     at 0x015A\n+    Utf8 \"NoNullVT\"; \/\/ #36     at 0x016A\n+    NameAndType #12 #13; \/\/ #37     at 0x0175\n+    NameAndType #14 #13; \/\/ #38     at 0x017A\n+    NameAndType #15 #16; \/\/ #39     at 0x017F\n+    NameAndType #19 #16; \/\/ #40     at 0x0184\n+    Utf8 \"QNoNullVT;\"; \/\/ #41     at 0x0189\n+    NameAndType #25 #26; \/\/ #42     at 0x0196\n+    NameAndType #20 #21; \/\/ #43     at 0x019B\n+    Utf8 \"BootstrapMethods\"; \/\/ #44     at 0x01A0\n+    MethodHandle 6b #49; \/\/ #45     at 0x01B3\n+    NameAndType #29 #50; \/\/ #46     at 0x01B7\n+    NameAndType #30 #51; \/\/ #47     at 0x01BC\n+    Utf8 \"java\/lang\/Object\"; \/\/ #48     at 0x01C1\n+    Method #52 #53; \/\/ #49     at 0x01D4\n+    Utf8 \"(QNoNullVT;)I\"; \/\/ #50     at 0x01D9\n+    Utf8 \"(QNoNullVT;)Ljava\/lang\/String;\"; \/\/ #51     at 0x01E9\n+    class #54; \/\/ #52     at 0x020A\n+    NameAndType #55 #59; \/\/ #53     at 0x020D\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #54     at 0x0212\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #55     at 0x023B\n+    class #61; \/\/ #56     at 0x0251\n+    Utf8 \"Lookup\"; \/\/ #57     at 0x0254\n+    Utf8 \"InnerClasses\"; \/\/ #58     at 0x025D\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #59     at 0x026C\n+    class #62; \/\/ #60     at 0x02E2\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #61     at 0x02E5\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #62     at 0x030D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0338\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [9] { \/\/ methods\n+    { \/\/ Member at 0x034A\n+      0x0001; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0352\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40002AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0369\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x0375\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0375\n+      0x0001; \/\/ access\n+      #19; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x037D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0394\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x03A0\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03A0\n+      0x0001; \/\/ access\n+      #20; \/\/ name_cpx\n+      #21; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 63) { \/\/ Code at 0x03A8\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[28]{\n+            0x2AB600042BB60004;\n+            0xA000122AB600052B;\n+            0xB60005A0000704A7;\n+            0x000403AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x03D6\n+              [1] { \/\/ LineNumberTable\n+                0  14; \/\/  at 0x03E2\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 5) { \/\/ StackMapTable at 0x03E2\n+              [2] { \/\/\n+                26b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03ED\n+      0x0001; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 87) { \/\/ Code at 0x03F5\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[43]{\n+            0x2BC100019900252B;\n+            0xC00006B400022AB4;\n+            0x0002A000152BC000;\n+            0x06B400032AB40003;\n+            0xA0000704A7000403;\n+            0xAC03AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0432\n+              [3] { \/\/ LineNumberTable\n+                0  18; \/\/  at 0x043E\n+                7  19; \/\/  at 0x0442\n+                41  21; \/\/  at 0x0446\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 6) { \/\/ StackMapTable at 0x0446\n+              [3] { \/\/\n+                39b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+                0b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0452\n+      0x0009; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x045A\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014D1A2C5FCC;\n+            0x00024D1B2C5FCC00;\n+            0x034D2CB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x0480\n+              [4] { \/\/ LineNumberTable\n+                0  26; \/\/  at 0x048C\n+                4  27; \/\/  at 0x0490\n+                11  28; \/\/  at 0x0494\n+                18  29; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0498\n+      0x0009; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x04A0\n+          2; \/\/ max_stack\n+          5; \/\/ max_locals\n+          Bytes[22]{\n+            0x014C0607B800074D;\n+            0x0507B800074E2C2B; \/\/ Change last nibble from C to B to load null\n+            0xB600083604B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 22) { \/\/ LineNumberTable at 0x04C8\n+              [5] { \/\/ LineNumberTable\n+                0  33; \/\/  at 0x04D4\n+                2  34; \/\/  at 0x04D8\n+                8  35; \/\/  at 0x04DC\n+                14  36; \/\/  at 0x04E0\n+                21  37; \/\/  at 0x04E4\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x04E4\n+      0x0011; \/\/ access\n+      #29; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x04EC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00090000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0505\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0511\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0511\n+      0x0011; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x0519\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0532\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x053E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x053E\n+      0x000A; \/\/ access\n+      #32; \/\/ name_cpx\n+      #33; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x0546\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00024B032A5FCC00;\n+            0x034B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x056C\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x0578\n+                4  6; \/\/  at 0x057C\n+                11  7; \/\/  at 0x0580\n+                18  8; \/\/  at 0x0584\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#34, 2) { \/\/ SourceFile at 0x0586\n+      #35;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#58, 10) { \/\/ InnerClasses at 0x058E\n+      [1] { \/\/ InnerClasses\n+        #56 #60 #57 25; \/\/  at 0x059E\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#44, 6) { \/\/ BootstrapMethods at 0x059E\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #45; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class NoNullVT\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":1608,"deletions":0,"binary":false,"changes":1608,"status":"added"},{"patch":"@@ -0,0 +1,1121 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* This jcod class is based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+ public class withfieldObject {\n+\n+     String y;\n+\n+     public withfieldObject() {\n+         try {\n+             y = \"abc\";  \/\/ Change this putfield to a withfield\n+         } catch (IncompatibleClassChangeError e) {\n+             y = \"cde\";\n+         }\n+     }\n+\n+     public String getfield() {\n+         return y;\n+     }\n+ }\n+*\/\n+\n+class withfieldObject {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [26] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    String #8; \/\/ #7     at 0x39\n+    Utf8 \"abc\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x42\n+    class #12; \/\/ #10     at 0x47\n+    NameAndType #13 #14; \/\/ #11     at 0x4A\n+    Utf8 \"withfieldObject\"; \/\/ #12     at 0x4F\n+    Utf8 \"y\"; \/\/ #13     at 0x60\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #14     at 0x64\n+    class #16; \/\/ #15     at 0x79\n+    Utf8 \"java\/lang\/IncompatibleClassChangeError\"; \/\/ #16     at 0x7C\n+    String #18; \/\/ #17     at 0xA5\n+    Utf8 \"cde\"; \/\/ #18     at 0xA8\n+    Utf8 \"Code\"; \/\/ #19     at 0xAE\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0xB5\n+    Utf8 \"StackMapTable\"; \/\/ #21     at 0xC7\n+    Utf8 \"getfield\"; \/\/ #22     at 0xD7\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #23     at 0xE2\n+    Utf8 \"SourceFile\"; \/\/ #24     at 0xF9\n+    Utf8 \"withfieldObject.java\"; \/\/ #25     at 0x0106\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x0126\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : y\n+      #14; \/\/ descriptor_index : Ljava\/lang\/String;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0130\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#19, 96) { \/\/ Code at 0x0138  \/\/ !!!! Changed 95 -> 96\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[22]{                \/\/ !!!! Changed from 21 -> 22\n+            0x2AB700012A1207CC;     \/\/ !!!! Changed last byte from B5 (putfield) to CC (withfield)\n+            0x000957A7000A4C2A;     \/\/ !!!! Inserted 0x57 (pop) to clear the stack.\n+            0x1211B50009B1;\n+          }\n+          [1] { \/\/ Traps\n+            4 11 14 15; \/\/  at 0x0165  \/\/ !!!! Changed 10 -> 11 and 13 -> 14\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#20, 26) { \/\/ LineNumberTable at 0x0167\n+              [6] { \/\/ line_number_table\n+                0  6; \/\/  at 0x0173\n+                4  8; \/\/  at 0x0177\n+                10  11; \/\/  at 0x017B\n+                13  9; \/\/  at 0x017F\n+                14  10; \/\/  at 0x0183\n+                20  12; \/\/  at 0x0187\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21, 16) { \/\/ StackMapTable at 0x0187\n+              [2] { \/\/\n+                255b, 14, [1]{7b,10}, [1]{7b,15}; \/\/ full_frame  \/\/ !!!! Changed 13 to 14\n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x019D\n+      0x0001; \/\/ access\n+      #22; \/\/ name_index       : getfield\n+      #23; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#19, 29) { \/\/ Code at 0x01A5\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40009B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x01BC\n+              [1] { \/\/ line_number_table\n+                0  15; \/\/  at 0x01C8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#24, 2) { \/\/ SourceFile at 0x01CA\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldObject\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   orignal jcod file, search for !!!!.\n+ public class putfieldObject {\n+     String y;\n+     public putfieldObject() {\n+         y = \"abc\";\n+     }\n+     public void withfieldFunc() {\n+         y = \"cde\";  \/\/ Change this putfield to a withfield\n+     }\n+     public String getfield() {\n+         return y;\n+     }\n+ }\n+*\/\n+class putfieldObject {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [24] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    String #8; \/\/ #7     at 0x39\n+    Utf8 \"abc\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x42\n+    class #12; \/\/ #10     at 0x47\n+    NameAndType #13 #14; \/\/ #11     at 0x4A\n+    Utf8 \"putfieldObject\"; \/\/ #12     at 0x4F\n+    Utf8 \"y\"; \/\/ #13     at 0x60\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #14     at 0x64\n+    String #16; \/\/ #15     at 0x79\n+    Utf8 \"cde\"; \/\/ #16     at 0x7C\n+    Utf8 \"Code\"; \/\/ #17     at 0x82\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x89\n+    Utf8 \"withfieldFunc\"; \/\/ #19     at 0x9B\n+    Utf8 \"getfield\"; \/\/ #20     at 0xAB\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #21     at 0xB6\n+    Utf8 \"SourceFile\"; \/\/ #22     at 0xCD\n+    Utf8 \"putfieldObject.java\"; \/\/ #23     at 0xDA\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xFA\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : y\n+      #14; \/\/ descriptor_index : Ljava\/lang\/String;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0104\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#17, 43) { \/\/ Code at 0x010C\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[11]{\n+            0x2AB700012A1207B5;\n+            0x0009B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0129\n+              [3] { \/\/ line_number_table\n+                0  6; \/\/  at 0x0135\n+                4  7; \/\/  at 0x0139\n+                10  8; \/\/  at 0x013D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x013D\n+      0x0001; \/\/ access\n+      #19; \/\/ name_index       : withfieldFunc\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#17, 35) { \/\/ Code at 0x0145\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2A120FCC0009B1;  \/\/ !!!! Change 0xB5 (putfield) to 0xCC (withfield)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 10) { \/\/ LineNumberTable at 0x015E\n+              [2] { \/\/ line_number_table\n+                0  11; \/\/  at 0x016A\n+                6  12; \/\/  at 0x016E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016E\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index       : getfield\n+      #21; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0176\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40009B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x018D\n+              [1] { \/\/ line_number_table\n+                0  15; \/\/  at 0x0199\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#22, 2) { \/\/ SourceFile at 0x019B\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class putfieldObject\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   original jcod file, search for !!!!.\n+public primitive final class putfieldPrimitive {\n+    int x;\n+\n+    public putfieldPrimitive(boolean odd) {\n+        if (odd) {\n+            x = 5;\n+        } else {\n+            x = 6;\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+\n+\/\/ If putfieldPrimitive.<vnew>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ Otherwise, it uses a putfield bytecode.\n+\n+class putfieldPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"putfieldPrimitive\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x3B\n+    Utf8 \"()I\"; \/\/ #10     at 0x42\n+    Utf8 \"Code\"; \/\/ #11     at 0x48\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x4F\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x61\n+    Utf8 \"(Z)QputfieldPrimitive;\"; \/\/ #14     at 0x6A\n+    Utf8 \"StackMapTable\"; \/\/ #15     at 0x75\n+    class #17; \/\/ #16     at 0x85\n+    Utf8 \"QputfieldPrimitive;\"; \/\/ #17     at 0x88\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0x90\n+    Utf8 \"putfieldPrimitive.java\"; \/\/ #19     at 0x9D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xB2\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xBC\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xC4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xDB\n+              [1] { \/\/ line_number_table\n+                0  13; \/\/  at 0xE7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xE7\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <vnew>\n+      #14; \/\/ descriptor_index : (Z)QputfieldPrimitive;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 84) { \/\/ Code at 0xEF  \/\/ !!! Change 83 -> 84\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[29]{             \/\/ !!!! Change 28 -> 29\n+            0xCB00014C1A99000D;\n+            0x082B5FCC00034CA7;\n+            0x000C10062B5FB500;  \/\/ !!!! Change goto target B -> C and 0xCC (withfield) to 0xB5 (putfield)\n+            0x032B4C2BB0;        \/\/ !!!! Inserted 0x2B (aload_1)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#12, 22) { \/\/ LineNumberTable at 0x011D\n+              [5] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0129\n+                4  5; \/\/  at 0x012D\n+                8  6; \/\/  at 0x0131\n+                18  8; \/\/  at 0x0135\n+                26  10; \/\/  at 0x0139\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#15, 9) { \/\/ StackMapTable at 0x0139\n+              [2] { \/\/\n+                252b, 18, [1]z{7b,16}; \/\/ append_frame 1\n+                8b; \/\/ same_frame    \/\/ !!!! change 7 -> 8\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x014A\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class putfieldPrimitive\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   original jcod file, search for !!!!.\n+public primitive final class withfieldPrimitive {\n+    int x;\n+\n+    public withfieldPrimitive(boolean odd) {\n+        if (odd) {\n+            x = 5;\n+        } else {\n+            x = 6;\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+\n+\/\/ This class is identical to putfieldPrimitive except for its name.  A new class\n+\/\/ was needed for a fresh constant pool resolution.\n+\/\/ If withfieldPrimitive.<vnew>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ Otherwise, it uses a putfield bytecode.\n+\n+class withfieldPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldPrimitive\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x3B\n+    Utf8 \"()I\"; \/\/ #10     at 0x42\n+    Utf8 \"Code\"; \/\/ #11     at 0x48\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x4F\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x61\n+    Utf8 \"(Z)QwithfieldPrimitive;\"; \/\/ #14     at 0x6A\n+    Utf8 \"StackMapTable\"; \/\/ #15     at 0x75\n+    class #17; \/\/ #16     at 0x85\n+    Utf8 \"QwithfieldPrimitive;\"; \/\/ #17     at 0x88\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0x90\n+    Utf8 \"withfieldPrimitive.java\"; \/\/ #19     at 0x9D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xB2\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xBC\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xC4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xDB\n+              [1] { \/\/ line_number_table\n+                0  13; \/\/  at 0xE7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xE7\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <vnew>\n+      #14; \/\/ descriptor_index : (Z)QwithfieldPrimitive;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 84) { \/\/ Code at 0xEF  \/\/ !!! Change 83 -> 84\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[29]{             \/\/ !!!! Change 28 -> 29\n+            0xCB00014C1A99000D;\n+            0x082B5FCC00034CA7;\n+            0x000C10062B5FB500;  \/\/ !!!! Change goto target B -> C and 0xCC (withfield) to 0xB5 (putfield)\n+            0x032B4C2BB0;        \/\/ !!!! Inserted 0x2B (aload_1)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#12, 22) { \/\/ LineNumberTable at 0x011D\n+              [5] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0129\n+                4  5; \/\/  at 0x012D\n+                8  6; \/\/  at 0x0131\n+                18  8; \/\/  at 0x0135\n+                26  10; \/\/  at 0x0139\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#15, 9) { \/\/ StackMapTable at 0x0139\n+              [2] { \/\/\n+                252b, 18, [1]z{7b,16}; \/\/ append_frame 1\n+                8b; \/\/ same_frame    \/\/ !!!! change 7 -> 8\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x014A\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldPrimitive\n+\n+\n+\n+\/* This jcod class is based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+public primitive final class withfieldNull {\n+    int x;\n+    public withfieldNull() {\n+        String s = null;\n+        x = 5;\n+    }\n+}\n+*\/\n+\/\/ This class tests a withfield bytecode with a stack operand that is null.\n+class withfieldNull {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [15] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldNull\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x19\n+    NameAndType #5 #6; \/\/ #4     at 0x1E\n+    Utf8 \"x\"; \/\/ #5     at 0x23\n+    Utf8 \"I\"; \/\/ #6     at 0x27\n+    class #8; \/\/ #7     at 0x2B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x2E\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x41\n+    Utf8 \"()QwithfieldNull;\"; \/\/ #10     at 0x4A\n+    Utf8 \"Code\"; \/\/ #11     at 0x5A\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x61\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x73\n+    Utf8 \"withfieldNull.java\"; \/\/ #14     at 0x80\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9B\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xA5\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <vnew>\n+      #10; \/\/ descriptor_index : ()QwithfieldNull;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 51) { \/\/ Code at 0xAD\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[15]{\n+            0xCB00014B014C0801; \/\/ !!!! Change 0x2A (aload_0) to 0x01 (aconst_null)\n+            0x5FCC00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 18) { \/\/ LineNumberTable at 0xCE\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0xDA\n+                4  5; \/\/  at 0xDE\n+                6  6; \/\/  at 0xE2\n+                13  7; \/\/  at 0xE6\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0xE8\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldNull\n+\n+\n+\n+\/* Thexe jcod classes are based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+\n+public class WrongPrimWF {\n+\n+    public primitive final class Dot { }\n+\n+    public primitive final class Loc { }\n+\n+    public primitive final class Both {\n+        Dot dot;\n+        Loc loc;\n+        Both(Dot d, Loc l) {\n+            dot = d;   \/\/ this d is changed to l to cause the VerifyError\n+            loc = l;\n+        }\n+    }\n+\n+    public WrongPrimWF() {\n+        Both b = new Both(new Dot(), new Loc());\n+    }\n+}\n+\n+*\/\n+\n+\/\/ Test that a withfield opcode, whose stack operand 'Loc' is a different primitive type\n+\/\/ than the primitive class in its constant pool field_res,f causes a VerifyError exception.\n+class WrongPrimWF$Dot {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1F\n+    NameAndType #5 #6; \/\/ #4     at 0x24\n+    Utf8 \"this$0\"; \/\/ #5     at 0x29\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x32\n+    class #8; \/\/ #7     at 0x42\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x45\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x58\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Dot;\"; \/\/ #10     at 0x61\n+    Utf8 \"Code\"; \/\/ #11     at 0x84\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x8B\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x9D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #14     at 0xAA\n+    Utf8 \"NestHost\"; \/\/ #15     at 0xBD\n+    class #17; \/\/ #16     at 0xC8\n+    Utf8 \"WrongPrimWF\"; \/\/ #17     at 0xCB\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xD9\n+    Utf8 \"Dot\"; \/\/ #19     at 0xE8\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xF8\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x0102\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <vnew>\n+      #10; \/\/ descriptor_index : (LWrongPrimWF;)QWrongPrimWF$Dot;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 37) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C2A2B5FCC;\n+            0x00034C2BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0129\n+              [1] { \/\/ line_number_table\n+                0  3; \/\/  at 0x0135\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0x0137\n+      #14;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#15, 2) { \/\/ NestHost at 0x013F\n+      #16; \/\/ WrongPrimWF at 0x0147\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0147\n+      [1] { \/\/ classes\n+        #1 #16 #19 273; \/\/  at 0x0157\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Dot\n+\n+\n+class WrongPrimWF$Loc {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1F\n+    NameAndType #5 #6; \/\/ #4     at 0x24\n+    Utf8 \"this$0\"; \/\/ #5     at 0x29\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x32\n+    class #8; \/\/ #7     at 0x42\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x45\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x58\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Loc;\"; \/\/ #10     at 0x61\n+    Utf8 \"Code\"; \/\/ #11     at 0x84\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x8B\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x9D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #14     at 0xAA\n+    Utf8 \"NestHost\"; \/\/ #15     at 0xBD\n+    class #17; \/\/ #16     at 0xC8\n+    Utf8 \"WrongPrimWF\"; \/\/ #17     at 0xCB\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xD9\n+    Utf8 \"Loc\"; \/\/ #19     at 0xE8\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xF8\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x0102\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <vnew>\n+      #10; \/\/ descriptor_index : (LWrongPrimWF;)QWrongPrimWF$Loc;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 37) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C2A2B5FCC;\n+            0x00034C2BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0129\n+              [1] { \/\/ line_number_table\n+                0  5; \/\/  at 0x0135\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0x0137\n+      #14;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#15, 2) { \/\/ NestHost at 0x013F\n+      #16; \/\/ WrongPrimWF at 0x0147\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0147\n+      [1] { \/\/ classes\n+        #1 #16 #19 273; \/\/  at 0x0157\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Loc\n+\n+\n+class WrongPrimWF$Both {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [34] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Both\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"this$0\"; \/\/ #5     at 0x2A\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x33\n+    Field #1 #8; \/\/ #7     at 0x43\n+    NameAndType #9 #10; \/\/ #8     at 0x48\n+    Utf8 \"dot\"; \/\/ #9     at 0x4D\n+    Utf8 \"QWrongPrimWF$Dot;\"; \/\/ #10     at 0x53\n+    Field #1 #12; \/\/ #11     at 0x67\n+    NameAndType #13 #14; \/\/ #12     at 0x6C\n+    Utf8 \"loc\"; \/\/ #13     at 0x71\n+    Utf8 \"QWrongPrimWF$Loc;\"; \/\/ #14     at 0x77\n+    class #16; \/\/ #15     at 0x8B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16     at 0x8E\n+    Utf8 \"<vnew>\"; \/\/ #17     at 0xA1\n+    Utf8 \"(LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\"; \/\/ #18     at 0xAA\n+    Utf8 \"Code\"; \/\/ #19     at 0xF0\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0xF7\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0x0109\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #22     at 0x0116\n+    Utf8 \"NestHost\"; \/\/ #23     at 0x0129\n+    class #25; \/\/ #24     at 0x0134\n+    Utf8 \"WrongPrimWF\"; \/\/ #25     at 0x0137\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0x0145\n+    Utf8 \"Both\"; \/\/ #27     at 0x0154\n+    class #29; \/\/ #28     at 0x015B\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #29     at 0x015E\n+    Utf8 \"Dot\"; \/\/ #30     at 0x0170\n+    class #32; \/\/ #31     at 0x0176\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #32     at 0x0179\n+    Utf8 \"Loc\"; \/\/ #33     at 0x018B\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ Fields\n+    {  \/\/ field at 0x019B\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index       : dot\n+      #10; \/\/ descriptor_index : QWrongPrimWF$Dot;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x01A3\n+      0x0010; \/\/ access\n+      #13; \/\/ name_index       : loc\n+      #14; \/\/ descriptor_index : QWrongPrimWF$Loc;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x01AB\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x01B5\n+      0x0008; \/\/ access\n+      #17; \/\/ name_index       : <vnew>\n+      #18; \/\/ descriptor_index : (LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\n+      [1] { \/\/ Attributes\n+        Attr(#19, 63) { \/\/ Code at 0x01BD\n+          2; \/\/ max_stack\n+          4; \/\/ max_locals\n+          Bytes[27]{\n+            0xCB00014E2A2D5FCC;\n+            0x00034E2C2D5FCC00; \/\/ !!!! change 2B (aload_1) to 2C (aload_2) to put Loc on the stack.\n+            0x074E2C2D5FCC000B; \/\/      this should cause a VerifyError because withfield is assigning\n+            0x4E2DB0;           \/\/      to a field of type Dot.\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 18) { \/\/ LineNumberTable at 0x01EA\n+              [4] { \/\/ line_number_table\n+                0  10; \/\/  at 0x01F6\n+                11  11; \/\/  at 0x01FA\n+                18  12; \/\/  at 0x01FE\n+                25  13; \/\/  at 0x0202\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0204\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x020C\n+      #24; \/\/ WrongPrimWF at 0x0214\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 26) { \/\/ InnerClasses at 0x0214\n+      [3] { \/\/ classes\n+        #1 #24 #27 273; \/\/  at 0x0224\n+        #28 #24 #30 273; \/\/  at 0x022C\n+        #31 #24 #33 273; \/\/  at 0x0234\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Both\n+\n+\n+class WrongPrimWF {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [34] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Method #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #33 #11; \/\/ #9     at 0x41\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #10     at 0x46\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Dot;\"; \/\/ #11     at 0x58\n+    Method #13 #14; \/\/ #12     at 0x7B\n+    class #15; \/\/ #13     at 0x80\n+    NameAndType #33 #16; \/\/ #14     at 0x83\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #15     at 0x88\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Loc;\"; \/\/ #16     at 0x9A\n+    Method #18 #19; \/\/ #17     at 0xBD\n+    class #20; \/\/ #18     at 0xC2\n+    NameAndType #33 #21; \/\/ #19     at 0xC5\n+    Utf8 \"WrongPrimWF$Both\"; \/\/ #20     at 0xCA\n+    Utf8 \"(LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\"; \/\/ #21     at 0xDD\n+    class #23; \/\/ #22     at 0x0123\n+    Utf8 \"WrongPrimWF\"; \/\/ #23     at 0x0126\n+    Utf8 \"Code\"; \/\/ #24     at 0x0134\n+    Utf8 \"LineNumberTable\"; \/\/ #25     at 0x013B\n+    Utf8 \"SourceFile\"; \/\/ #26     at 0x014D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #27     at 0x015A\n+    Utf8 \"NestMembers\"; \/\/ #28     at 0x016D\n+    Utf8 \"InnerClasses\"; \/\/ #29     at 0x017B\n+    Utf8 \"Dot\"; \/\/ #30     at 0x018A\n+    Utf8 \"Loc\"; \/\/ #31     at 0x0190\n+    Utf8 \"Both\"; \/\/ #32     at 0x0196\n+    Utf8 \"<vnew>\"; \/\/ #33\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x01A9\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#24, 50) { \/\/ Code at 0x01B1\n+          3; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[18]{\n+            0x2AB700012A2AB800;\n+            0x072AB8000CB80011;\n+            0x4CB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#25, 14) { \/\/ LineNumberTable at 0x01D5\n+              [3] { \/\/ line_number_table\n+                0  16; \/\/  at 0x01E1\n+                4  17; \/\/  at 0x01E5\n+                17  18; \/\/  at 0x01E9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#26, 2) { \/\/ SourceFile at 0x01EB\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28, 8) { \/\/ NestMembers at 0x01F3\n+      [3] { \/\/ classes\n+        #18; \/\/ WrongPrimWF$Both at 0x01FD\n+        #13; \/\/ WrongPrimWF$Loc at 0x01FF\n+        #8; \/\/ WrongPrimWF$Dot at 0x0201\n+      }\n+    } \/\/ end NestMembers\n+    ;\n+    Attr(#29, 26) { \/\/ InnerClasses at 0x0201\n+      [3] { \/\/ classes\n+        #8 #22 #30 273; \/\/  at 0x0211\n+        #13 #22 #31 273; \/\/  at 0x0219\n+        #18 #22 #32 273; \/\/  at 0x0221\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/withfieldTests\/withfieldTests.jcod","additions":1121,"deletions":0,"binary":false,"changes":1121,"status":"added"},{"patch":"@@ -710,0 +710,4 @@\n+com\/sun\/jdi\/cds\/CDSBreakpointTest.java                          8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java                      8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java                        8304168 generic-all\n+\n@@ -765,0 +769,6 @@\n+jdk\/classfile\/SwapTest.java                                     8308778 generic-all\n+jdk\/classfile\/LowAdaptTest.java                                 8308778 generic-all\n+jdk\/classfile\/BuilderBlockTest.java                             8308778 generic-all\n+jdk\/classfile\/BuilderTryCatchTest.java                          8308778 generic-all\n+jdk\/classfile\/PrimitiveClassConstantTest.java                   8310649 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.experimental.bytecode.BytePoolHelper;\n+import jdk.experimental.bytecode.ClassBuilder;\n+import jdk.experimental.bytecode.CodeBuilder;\n@@ -29,0 +32,1 @@\n+import jdk.experimental.bytecode.MethodBuilder;\n@@ -31,0 +35,2 @@\n+import jdk.experimental.bytecode.TypeHelper;\n+import jdk.experimental.bytecode.TypeTag;\n@@ -36,0 +42,1 @@\n+import java.util.Iterator;\n@@ -43,0 +50,2 @@\n+import jdk.internal.value.PrimitiveClass;\n+\n@@ -49,0 +58,4 @@\n+    static String generateClassNameFromLookupClass(MethodHandles.Lookup l) {\n+        return l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+    }\n+\n@@ -50,1 +63,1 @@\n-        String className = l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+        String className = generateClassNameFromLookupClass(l);\n@@ -151,0 +164,211 @@\n+\n+\n+    \/\/ loadCode(MethodHandles.Lookup, String, MethodType, Consumer<? super MethodHandleCodeBuilder<?>>) et al...\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return loadCode(lookup, className, methodName, type, builder);\n+    }\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String descriptor = type.toMethodDescriptorString();\n+        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,\n+                    clazz -> {\n+                        try {\n+                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));\n+                        } catch (ReflectiveOperationException ex) {\n+                            throw new IllegalStateException(ex);\n+                        }\n+                    },\n+                    builder);\n+    }\n+\n+    \/\/ Helper method to load code built with \"buildCode()\"\n+    public static MethodHandle loadCodeBytes(MethodHandles.Lookup lookup, String methodName, MethodType type, byte[] byteCode) {\n+        try {\n+            Class<?> clazz = lookup.defineClass(byteCode);\n+            return lookup.findStatic(clazz, methodName, type);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Failed to loadCodeBytes \\\"\" + methodName + \"\\\"\", t);\n+        }\n+    }\n+\n+\n+    private static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(\n+            MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {\n+        try {\n+            byte[] byteArray = buildCode(lookup, className, methodName, type, builderFunc, builder);\n+            Class<?> clazz = lookup.defineClass(byteArray);\n+            return resFunc.apply(clazz);\n+        } catch (Throwable e) {\n+             throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static byte[] buildCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return buildCode(lookup, className, methodName, type.toMethodDescriptorString(), MethodHandleCodeBuilder::new, builder);\n+    }\n+\n+    public static <C extends CodeBuilder<Class<?>, String, byte[], ?>> byte[] buildCode(\n+        MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Consumer<? super C> builder) {\n+\n+                return new IsolatedMethodBuilder(className, lookup)\n+                    .withSuperclass(Object.class)\n+                    .withMajorVersion(66)\n+                    .withMinorVersion(0)\n+                    .withFlags(Flag.ACC_PUBLIC, Flag.ACC_IDENTITY)\n+                    .withMethod(methodName, type, M ->\n+                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n+                            .withCode(builderFunc, builder)).build();\n+\n+    }\n+\n+    private static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {\n+\n+        private static final Class<?> THIS_CLASS = new Object() { }.getClass();\n+\n+        private IsolatedMethodBuilder(String clazz, MethodHandles.Lookup lookup) {\n+            super(new IsolatedMethodPoolHelper(clazz),\n+                  new IsolatedMethodTypeHelper(lookup));\n+            withThisClass(THIS_CLASS);\n+        }\n+\n+        public Class<?> thisClass() {\n+            return THIS_CLASS;\n+        }\n+\n+        static String classToInternalName(Class<?> c) {\n+            if (c.isArray()) {\n+                return c.descriptorString();\n+            }\n+            return c.getName().replace('.', '\/');\n+        }\n+\n+        private static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {\n+\n+            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+            MethodHandles.Lookup lookup;\n+\n+            private IsolatedMethodTypeHelper(MethodHandles.Lookup lookup) {\n+                this.lookup = lookup;\n+            }\n+\n+            @Override\n+            public String elemtype(String s) {\n+                return basicTypeHelper.elemtype(s);\n+            }\n+\n+            @Override\n+            public String arrayOf(String s) {\n+                return basicTypeHelper.arrayOf(s);\n+            }\n+\n+            @Override\n+            public Iterator<String> parameterTypes(String s) {\n+                return basicTypeHelper.parameterTypes(s);\n+            }\n+\n+            @Override\n+            public String fromTag(TypeTag tag) {\n+                return basicTypeHelper.fromTag(tag);\n+            }\n+\n+            @Override\n+            public String returnType(String s) {\n+                return basicTypeHelper.returnType(s);\n+            }\n+\n+            @Override\n+            public String type(Class<?> aClass) {\n+                return aClass.descriptorString();\n+            }\n+\n+            @Override\n+            public boolean isInlineClass(String desc) {\n+                Class<?> aClass = symbol(desc);\n+                return aClass != null && PrimitiveClass.isPrimitiveValueType(aClass);\n+            }\n+\n+            @Override\n+            public Class<?> symbol(String desc) {\n+                try {\n+                    if (desc.startsWith(\"[\")) {\n+                        return Class.forName(desc.replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                    } else {\n+                        Class<?> c = Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        return basicTypeHelper.isInlineClass(desc) ? PrimitiveClass.asValueType(c) : PrimitiveClass.asPrimaryType(c);\n+                    }\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            @Override\n+            public TypeTag tag(String s) {\n+                return basicTypeHelper.tag(s);\n+            }\n+\n+            @Override\n+            public Class<?> symbolFrom(String s) {\n+                return symbol(s);\n+            }\n+\n+            @Override\n+            public String commonSupertype(String t1, String t2) {\n+                return basicTypeHelper.commonSupertype(t1, t2);\n+            }\n+\n+            @Override\n+            public String nullType() {\n+                return basicTypeHelper.nullType();\n+            }\n+        }\n+\n+        private static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {\n+            final String clazz;\n+\n+            private IsolatedMethodPoolHelper(String clazz) {\n+                super(c -> from(c, clazz), s->s);\n+                this.clazz = clazz;\n+            }\n+\n+            static String from(Class<?> c, String clazz) {\n+                return c == THIS_CLASS ? clazz.replace('.', '\/')\n+                                       : classToInternalName(c);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] build() {\n+            return super.build();\n+        }\n+    }\n+\n+    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {\n+\n+        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+\n+        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {\n+            super(methodBuilder);\n+        }\n+\n+        TypeTag getTagType(String s) {\n+            return basicTypeHelper.tag(s);\n+        }\n+\n+        public T ifcmp(String s, CondKind cond, CharSequence label) {\n+            return super.ifcmp(getTagType(s), cond, label);\n+        }\n+\n+        public T return_(String s) {\n+            return super.return_(getTagType(s));\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":226,"deletions":2,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -154,0 +154,14 @@\n+  private native Object[] getObjectsViaKlassOopMaps0(Object thing);\n+  public Object[] getObjectsViaKlassOopMaps(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaKlassOopMaps0(thing);\n+  }\n+\n+  private native Object[] getObjectsViaOopIterator0(Object thing);\n+  public Object[] getObjectsViaOopIterator(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaOopIterator0(thing);\n+  }\n+\n+  public native Object[] getObjectsViaFrameOopIterator(int depth);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}