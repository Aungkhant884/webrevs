{"files":[{"patch":"@@ -2806,0 +2806,13 @@\n+    if (oldval != NULL && oldval->is_InlineType()) {\n+      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      oldval = oldval->as_InlineType()->buffer(this)->get_oop();\n+    }\n+    if (newval != NULL && newval->is_InlineType()) {\n+      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      newval = newval->as_InlineType()->buffer(this)->get_oop();\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1196,0 +1196,219 @@\n+\n+    \/\/ compareAndSet to flattened field in object\n+    @Test\n+    public boolean test63(MyValue1 oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.default;\n+\n+        boolean res = test63(test31_vt, vt);\n+        \/\/ Checks are disabled for non-flattened field because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertTrue(res);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+\n+        res = test63(MyValue1.default, MyValue1.default);\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertFalse(res);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in array\n+    @Test\n+    public boolean test64(MyValue1[] arr, MyValue1 oldVal, Object newVal) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.compareAndSetValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        boolean res = test64(arr, arr[1], vt);\n+        \/\/ Checks are disabled for non-flattened array because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertTrue(res);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+\n+        res = test64(arr, MyValue1.default, MyValue1.default);\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertFalse(res);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object with unknown container\n+    @Test\n+    public boolean test65(Object o, Object oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetValue(o, TEST31_VT_OFFSET, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(o, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.default;\n+\n+        boolean res = test65(this, test31_vt, vt);\n+        Asserts.assertTrue(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test65(this, MyValue1.default, MyValue1.default);\n+        Asserts.assertFalse(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public boolean test66(Object oldVal, Object newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.default;\n+\n+        boolean res = test66(test31_vt, vt);\n+        Asserts.assertTrue(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test66(MyValue1.default, MyValue1.default);\n+        Asserts.assertFalse(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object\n+    @Test\n+    public Object test67(MyValue1 oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.default;\n+        test31_vt = oldVal;\n+\n+        Object res = test67(test31_vt, vt);\n+        \/\/ Checks are disabled for non-flattened field because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertEQ(res, oldVal);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+\n+        res = test67(MyValue1.default, MyValue1.default);\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertEQ(res, vt);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in array\n+    @Test\n+    public Object test68(MyValue1[] arr, MyValue1 oldVal, Object newVal) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.compareAndExchangeValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        Object res = test68(arr, arr[1], vt);\n+        \/\/ Checks are disabled for non-flattened array because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertEQ(res, MyValue1.default);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+\n+        res = test68(arr, MyValue1.default, MyValue1.default);\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertEQ(res, vt);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object with unknown container\n+    @Test\n+    public Object test69(Object o, Object oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeValue(o, TEST31_VT_OFFSET, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(o, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.default;\n+        test31_vt = oldVal;\n+\n+        Object res = test69(this, test31_vt, vt);\n+        Asserts.assertEQ(res, oldVal);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test69(this, MyValue1.default, MyValue1.default);\n+        Asserts.assertEQ(res, vt);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public Object test70(Object oldVal, Object newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, MyValue1.class.asValueType(), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.default;\n+        test31_vt = oldVal;\n+\n+        Object res = test70(test31_vt, vt);\n+        Asserts.assertEQ(res, oldVal);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test70(MyValue1.default, MyValue1.default);\n+        Asserts.assertEQ(res, vt);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"modified"}]}