{"files":[{"patch":"@@ -1936,1 +1936,1 @@\n-void Compile::process_inline_types(PhaseIterGVN &igvn, bool post_ea) {\n+void Compile::process_inline_types(PhaseIterGVN &igvn, bool remove) {\n@@ -1942,4 +1942,2 @@\n-  \/\/ Remove InlineTypePtr nodes only after EA to give scalar replacement a chance\n-  \/\/ to remove buffer allocations. InlineType nodes are kept until loop opts and\n-  \/\/ removed via InlineTypeNode::remove_redundant_allocations.\n-  if (post_ea) {\n+  if (remove) {\n+    \/\/ Remove inline type nodes\n@@ -1948,1 +1946,3 @@\n-      if (vt->is_InlineTypePtr()) {\n+      if (vt->outcnt() == 0) {\n+        igvn.remove_dead_node(vt);\n+      } else if (vt->is_InlineTypePtr()) {\n@@ -1950,0 +1950,2 @@\n+      } else {\n+        igvn.replace_node(vt, igvn.C->top());\n@@ -1953,0 +1955,1 @@\n+  \/\/ TODO only check once we are removing, right?\n@@ -2573,5 +2576,0 @@\n-  if (_inline_type_nodes->length() > 0) {\n-    \/\/ Process inline types again now that EA might have simplified the graph\n-    process_inline_types(igvn, \/* post_ea= *\/ true);\n-  }\n-\n@@ -2662,0 +2660,6 @@\n+  if (_inline_type_nodes->length() > 0) {\n+    \/\/ Process inline type nodes again and remove them. From here\n+    \/\/ on we don't need to keep track of field values anymore.\n+    process_inline_types(igvn, \/* remove= *\/ true);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-  void process_inline_types(PhaseIterGVN &igvn, bool post_ea = false);\n+  void process_inline_types(PhaseIterGVN &igvn, bool remove = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -863,1 +863,0 @@\n-\/\/ Then unlink the inline type node and remove it.\n@@ -901,1 +900,1 @@\n-      \/\/ Unlink and recursively process inline type users\n+      \/\/ Recursively process inline type users\n@@ -903,1 +902,0 @@\n-      int nb = out->replace_edge(this, igvn->C->top());\n@@ -905,1 +903,0 @@\n-      --i; imax -= nb;\n@@ -911,6 +908,0 @@\n-    } else {\n-#ifdef ASSERT\n-      \/\/ The inline type should not have any other users at this time\n-      out->dump();\n-      assert(false, \"unexpected user of inline type\");\n-#endif\n@@ -919,1 +910,0 @@\n-  igvn->remove_dead_node(this);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1621,1 +1621,0 @@\n-    return; \/\/ n is now dead\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -242,9 +242,0 @@\n-  \/\/ Inline types should not be split through Phis but each value input\n-  \/\/ needs to be merged individually. At this point, inline types should\n-  \/\/ only be used by AllocateNodes. Try to remove redundant allocations\n-  \/\/ and unlink the now dead inline type node.\n-  if (n->is_InlineType()) {\n-    n->as_InlineType()->remove_redundant_allocations(&_igvn, this);\n-    return true; \/\/ n is now dead\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3413,0 +3413,120 @@\n+\n+    \/\/ Test inline type that can only be scalarized after loop opts\n+    @Test(failOn = ALLOC + LOAD + STORE)\n+    @Warmup(10000)\n+    public long test126(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @DontCompile\n+    public void test126_verifier(boolean warmup) {\n+        long res = test126(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!warmup) {\n+            res = test126(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test126 but with interface type\n+    @Test(failOn = ALLOC + LOAD + STORE)\n+    @Warmup(10000)\n+    public long test127(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @DontCompile\n+    public void test127_verifier(boolean warmup) {\n+        long res = test127(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!warmup) {\n+            res = test127(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after CCP\n+    @Test(failOn = ALLOC + LOAD + STORE)\n+    @Warmup(10000)\n+    public long test128(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @DontCompile\n+    public void test128_verifier(boolean warmup) {\n+        long res = test128(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!warmup) {\n+            res = test128(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test128 but with interface type\n+    @Test(failOn = ALLOC + LOAD + STORE)\n+    @Warmup(10000)\n+    public long test129(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 0; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @DontCompile\n+    public void test129_verifier(boolean warmup) {\n+        long res = test129(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!warmup) {\n+            res = test129(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"}]}