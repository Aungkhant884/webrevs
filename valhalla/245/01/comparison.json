{"files":[{"patch":"@@ -120,1 +120,1 @@\n-  assert(!p->mark().has_bias_pattern(),\n+  assert(!UseBiasedLocking || !p->mark().has_bias_pattern(),\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  assert(!header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n+  assert(!UseBiasedLocking || !header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    } else if (has_bias_pattern()) {  \/\/ last bits = 101\n+    } else if (UseBiasedLocking && has_bias_pattern()) {  \/\/ last bits = 101\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,0 +293,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -296,0 +297,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -302,0 +304,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -308,0 +311,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -312,0 +316,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -317,0 +322,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -321,0 +327,1 @@\n+    ShouldNotReachHere(); \/\/ Valhalla: unused\n@@ -329,1 +336,1 @@\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n@@ -334,1 +341,4 @@\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+\n+  \/\/ is unlocked and not an inline type (which cannot be involved in locking, displacement or inflation)\n+  \/\/ i.e. test both lock bits and the inline type bit together\n+  bool is_neutral()  const { return (mask_bits(value(), inline_type_mask_in_place) == unlocked_value); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-         prototype_header.has_bias_pattern() ||\n+         (UseBiasedLocking && prototype_header.has_bias_pattern()) ||\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -971,2 +971,4 @@\n-    \/\/ Revoke any biases before querying the mark word\n-    BiasedLocking::revoke_at_safepoint(hobj);\n+    if (UseBiasedLocking) {\n+      \/\/ Revoke any biases before querying the mark word\n+      BiasedLocking::revoke_at_safepoint(hobj);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -735,0 +735,1 @@\n+  assert(UseBiasedLocking, \"biased locking not enabled\");\n@@ -758,0 +759,1 @@\n+  assert(UseBiasedLocking, \"biased locking not enabled\");\n@@ -861,0 +863,1 @@\n+  assert(UseBiasedLocking, \"biased locking not enabled\");\n@@ -877,0 +880,1 @@\n+  assert(UseBiasedLocking, \"biased locking not enabled\");\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -835,1 +835,1 @@\n-          \"(Deprecated) Enable biased locking in JVM\")                      \\\n+          \"(Deprecated) Enable biased locking in JVM (completely disabled by Valhalla)\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-  assert(!mark.has_bias_pattern(), \"should not see bias pattern here\");\n+  assert(!UseBiasedLocking || !mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -679,0 +679,1 @@\n+         !UseBiasedLocking ||\n@@ -807,0 +808,1 @@\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -808,1 +810,0 @@\n-  assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -1110,1 +1111,1 @@\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n+    assert(!UseBiasedLocking || !mark.has_bias_pattern(), \"invariant\");\n@@ -1866,1 +1867,1 @@\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n+    assert(!UseBiasedLocking || !mark.has_bias_pattern(), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), \"object must be null or locked, and unbiased\");\n+          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && (!UseBiasedLocking || !monitor->owner()->has_bias_pattern())), \"object must be null or locked, and unbiased\");\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,117 @@\n+\n+static void assert_unlocked_state(markWord mark) {\n+  EXPECT_FALSE(mark.has_displaced_mark_helper());\n+  EXPECT_FALSE(mark.has_locker());\n+  EXPECT_FALSE(mark.has_monitor());\n+  EXPECT_FALSE(mark.is_being_inflated());\n+  EXPECT_FALSE(mark.is_locked());\n+  EXPECT_TRUE(mark.is_unlocked());\n+}\n+\n+static void assert_copy_set_hash(markWord mark) {\n+  const intptr_t hash = 4711;\n+  EXPECT_TRUE(mark.has_no_hash());\n+  markWord copy = mark.copy_set_hash(hash);\n+  EXPECT_EQ(hash, copy.hash());\n+  EXPECT_FALSE(copy.has_no_hash());\n+}\n+\n+static void assert_type(markWord mark) {\n+  EXPECT_FALSE(mark.is_flat_array());\n+  EXPECT_FALSE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_larval_state());\n+  EXPECT_FALSE(mark.is_nullfree_array());\n+}\n+\n+TEST_VM(markWord, prototype) {\n+  markWord mark = markWord::prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_type(mark);\n+}\n+\n+static void assert_inline_type(markWord mark) {\n+  EXPECT_FALSE(mark.is_flat_array());\n+  EXPECT_TRUE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_nullfree_array());\n+}\n+\n+TEST_VM(markWord, inline_type_prototype) {\n+  markWord mark = markWord::inline_type_prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_FALSE(mark.is_neutral());\n+\n+  assert_inline_type(mark);\n+  EXPECT_FALSE(mark.is_larval_state());\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  markWord larval = mark.enter_larval_state();\n+  EXPECT_TRUE(larval.is_larval_state());\n+  assert_inline_type(larval);\n+  mark = larval.exit_larval_state();\n+  EXPECT_FALSE(mark.is_larval_state());\n+  assert_inline_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+}\n+\n+#if _LP64\n+\n+static void assert_flat_array_type(markWord mark) {\n+  EXPECT_TRUE(mark.is_flat_array());\n+  EXPECT_FALSE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_larval_state());\n+  EXPECT_TRUE(mark.is_nullfree_array());\n+}\n+\n+TEST_VM(markWord, flat_array_prototype) {\n+  markWord mark = markWord::flat_array_prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_flat_array_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_flat_array_type(mark);\n+}\n+\n+static void assert_nullfree_array_type(markWord mark) {\n+  EXPECT_FALSE(mark.is_flat_array());\n+  EXPECT_FALSE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_larval_state());\n+  EXPECT_TRUE(mark.is_nullfree_array());\n+}\n+\n+TEST_VM(markWord, nullfree_array_prototype) {\n+  markWord mark = markWord::nullfree_array_prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_nullfree_array_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_nullfree_array_type(mark);\n+}\n+#endif \/\/ _LP64\n+\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"modified"}]}