{"files":[{"patch":"@@ -3364,0 +3364,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -1374,0 +1374,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1469,0 +1471,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1660,0 +1674,2 @@\n+  _restricted_field_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1690,0 +1706,1 @@\n+\n@@ -1722,0 +1739,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1731,0 +1750,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1765,0 +1786,9 @@\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1768,1 +1798,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1770,0 +1800,3 @@\n+    _restricted_field_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1819,0 +1852,1 @@\n+      _restricted_field_info->append(0);\n@@ -1822,0 +1856,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1829,0 +1864,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1831,0 +1867,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1833,0 +1870,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1841,0 +1881,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1843,0 +1884,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5872,0 +5914,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_erased_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _restricted_field_info->at(i);\n+    }\n+  }\n+\n@@ -6070,0 +6120,1 @@\n+  _restricted_field_info(NULL),\n@@ -6109,0 +6160,1 @@\n+  _has_restricted_fields(false),\n@@ -6687,0 +6739,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6689,1 +6742,0 @@\n-      \/\/ Pre-load inline class\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":55,"deletions":3,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+                                       bool has_restricted_type,\n@@ -149,1 +150,2 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_inline_type ? 1 : 0) << is_inline_type_shift) |\n+                  ((has_restricted_type ? 1 : 0) << has_restricted_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-\/\/ _flags     [tos|0|F=1|0|I|i|f|v|0 |0000|field_index] (for field entries)\n+\/\/ _flags     [tos|0|F=1|R|I|i|f|v|0 |0000|field_index] (for field entries)\n@@ -188,0 +188,1 @@\n+    has_restricted_type_shift  = 25,  \/\/ (R) does the field have a restricted type?\n@@ -233,0 +234,1 @@\n+    bool            has_restricted_type,         \/\/ field has a restricted type\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2263,0 +2263,3 @@\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}