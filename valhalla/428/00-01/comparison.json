{"files":[{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.misc.Unsafe;\n+\n+\/**\n+ * @test TestBufferAtomicAccess\n+ * @key randomness\n+ * @summary Detect atomic access violations on inline type buffer writes due to missing barriers.\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestBufferAtomicAccess\n+ * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestBufferAtomicAccess\n+ * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n+ *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestBufferAtomicAccess\n+ * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n+ *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestBufferAtomicAccess\n+ *\/\n+\n+primitive class MyValue {\n+    int x;\n+    int y;\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long X_OFFSET;\n+    private static final long Y_OFFSET;\n+    static {\n+        try {\n+            Field xField = MyValue.class.getDeclaredField(\"x\");\n+            X_OFFSET = U.objectFieldOffset(xField);\n+            Field yField = MyValue.class.getDeclaredField(\"y\");\n+            Y_OFFSET = U.objectFieldOffset(yField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    MyValue(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    MyValue incrementAndCheck() {\n+        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n+        return new MyValue(x + 1, y + 1);\n+    }\n+\n+    MyValue incrementAndCheckUnsafe() {\n+        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n+        MyValue vt = U.makePrivateBuffer(this);\n+        U.putInt(vt, X_OFFSET, x + 1);\n+        U.putInt(vt, Y_OFFSET, y + 1);\n+        return U.finishPrivateBuffer(vt);\n+    }\n+}\n+\n+public class TestBufferAtomicAccess {\n+\n+    static MyValue vtField1;\n+    MyValue vtField2;\n+    MyValue[] vtField3 = new MyValue[1];\n+\n+    static final MethodHandle incrementAndCheck_mh;\n+\n+    static {\n+        try {\n+            Class<?> clazz = MyValue.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(MyValue.class);\n+            incrementAndCheck_mh = lookup.findVirtual(clazz, \"incrementAndCheck\", mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    static class Runner extends Thread {\n+        TestBufferAtomicAccess test;\n+\n+        public Runner(TestBufferAtomicAccess test) {\n+            this.test = test;\n+        }\n+\n+        public void run() {\n+            for (int i = 0; i < 1_000_000; ++i) {\n+                test.vtField1 = test.vtField1.incrementAndCheck();\n+                test.vtField2 = test.vtField2.incrementAndCheck();\n+                test.vtField3[0] = test.vtField3[0].incrementAndCheck();\n+\n+                test.vtField1 = test.vtField1.incrementAndCheckUnsafe();\n+                test.vtField2 = test.vtField2.incrementAndCheckUnsafe();\n+                test.vtField3[0] = test.vtField3[0].incrementAndCheckUnsafe();\n+\n+                try {\n+                    test.vtField1 = (MyValue)incrementAndCheck_mh.invokeExact(test.vtField1);\n+                    test.vtField2 = (MyValue)incrementAndCheck_mh.invokeExact(test.vtField2);\n+                    test.vtField3[0] = (MyValue)incrementAndCheck_mh.invokeExact(test.vtField3[0]);\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(\"Invoke failed\", t);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create threads that concurrently update some inline type (array) fields\n+        \/\/ and check the fields of the inline types for consistency to detect access\n+        \/\/ atomicity violations.\n+        TestBufferAtomicAccess test = new TestBufferAtomicAccess();\n+        Thread runner = null;\n+        for (int i = 0; i < 10; ++i) {\n+            runner = new Runner(test);\n+            runner.start();\n+        }\n+        runner.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferAtomicAccess.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @test TestBufferTearingC1\n+ * @test TestBufferAtomicAccessC1\n@@ -33,1 +33,1 @@\n- *                   compiler.valhalla.inlinetypes.TestBufferTearingC1\n+ *                   compiler.valhalla.inlinetypes.TestBufferAtomicAccessC1\n@@ -54,1 +54,1 @@\n-public class TestBufferTearingC1 {\n+public class TestBufferAtomicAccessC1 {\n@@ -102,1 +102,1 @@\n-            threads[i] = new Thread(TestBufferTearingC1::checkMissingBarrier);\n+            threads[i] = new Thread(TestBufferAtomicAccessC1::checkMissingBarrier);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferAtomicAccessC1.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearingC1.java","status":"renamed"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-import java.lang.invoke.*;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.internal.misc.Unsafe;\n-\n-\/**\n- * @test TestBufferTearing\n- * @key randomness\n- * @summary Detect tearing on inline type buffer writes due to missing barriers.\n- * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n- * @modules java.base\/jdk.internal.misc\n- * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:InlineFieldMaxFlatSize=0 -XX:FlatArrayElementMaxSize=0\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- *\/\n-\n-primitive class MyValue {\n-    int x;\n-    int y;\n-\n-    private static final Unsafe U = Unsafe.getUnsafe();\n-    private static final long X_OFFSET;\n-    private static final long Y_OFFSET;\n-    static {\n-        try {\n-            Field xField = MyValue.class.getDeclaredField(\"x\");\n-            X_OFFSET = U.objectFieldOffset(xField);\n-            Field yField = MyValue.class.getDeclaredField(\"y\");\n-            Y_OFFSET = U.objectFieldOffset(yField);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    MyValue(int x, int y) {\n-        this.x = x;\n-        this.y = y;\n-    }\n-\n-    MyValue incrementAndCheck() {\n-        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n-        return new MyValue(x + 1, y + 1);\n-    }\n-\n-    MyValue incrementAndCheckUnsafe() {\n-        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n-        MyValue vt = U.makePrivateBuffer(this);\n-        U.putInt(vt, X_OFFSET, x + 1);\n-        U.putInt(vt, Y_OFFSET, y + 1);\n-        return U.finishPrivateBuffer(vt);\n-    }\n-}\n-\n-public class TestBufferTearing {\n-\n-    static MyValue vtField1;\n-    MyValue vtField2;\n-    MyValue[] vtField3 = new MyValue[1];\n-\n-    static final MethodHandle incrementAndCheck_mh;\n-\n-    static {\n-        try {\n-            Class<?> clazz = MyValue.class;\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(MyValue.class);\n-            incrementAndCheck_mh = lookup.findVirtual(clazz, \"incrementAndCheck\", mt);\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Method handle lookup failed\");\n-        }\n-    }\n-\n-    static class Runner extends Thread {\n-        TestBufferTearing test;\n-\n-        public Runner(TestBufferTearing test) {\n-            this.test = test;\n-        }\n-\n-        public void run() {\n-            for (int i = 0; i < 1_000_000; ++i) {\n-                test.vtField1 = test.vtField1.incrementAndCheck();\n-                test.vtField2 = test.vtField2.incrementAndCheck();\n-                test.vtField3[0] = test.vtField3[0].incrementAndCheck();\n-\n-                test.vtField1 = test.vtField1.incrementAndCheckUnsafe();\n-                test.vtField2 = test.vtField2.incrementAndCheckUnsafe();\n-                test.vtField3[0] = test.vtField3[0].incrementAndCheckUnsafe();\n-\n-                try {\n-                    test.vtField1 = (MyValue)incrementAndCheck_mh.invokeExact(test.vtField1);\n-                    test.vtField2 = (MyValue)incrementAndCheck_mh.invokeExact(test.vtField2);\n-                    test.vtField3[0] = (MyValue)incrementAndCheck_mh.invokeExact(test.vtField3[0]);\n-                } catch (Throwable t) {\n-                    throw new RuntimeException(\"Invoke failed\", t);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Create threads that concurrently update some inline type (array) fields\n-        \/\/ and check the fields of the inline types for consistency to detect tearing.\n-        TestBufferTearing test = new TestBufferTearing();\n-        Thread runner = null;\n-        for (int i = 0; i < 10; ++i) {\n-            runner = new Runner(test);\n-            runner.start();\n-        }\n-        runner.join();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearing.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"}]}