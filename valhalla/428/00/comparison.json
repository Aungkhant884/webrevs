{"files":[{"patch":"@@ -6606,1 +6606,1 @@\n-  if (_class_name == vmSymbols::java_lang_NonTearable() && _loader_data->class_loader() == NULL) {\n+  if (_class_name == vmSymbols::java_lang_AtomicAccess() && _loader_data->class_loader() == NULL) {\n@@ -6608,1 +6608,1 @@\n-    \/\/ It propagates by inheritance, as if testing \"instanceof NonTearable\".\n+    \/\/ It propagates by inheritance, as if testing \"instanceof AtomicAccess\".\n@@ -6610,1 +6610,1 @@\n-  } else if (*ForceNonTearable != '\\0') {\n+  } else if (*ForceAtomicAccess != '\\0') {\n@@ -6613,1 +6613,1 @@\n-    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+    if (StringUtils::class_list_match(ForceAtomicAccess, class_name_str)) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  template(java_lang_NonTearable,                     \"java\/lang\/NonTearable\")                    \\\n+  template(java_lang_AtomicAccess,                    \"java\/lang\/AtomicAccess\")                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-    _misc_is_declared_atomic                  = 1 << 19, \/\/ implements jl.NonTearable\n+    _misc_is_declared_atomic                  = 1 << 19, \/\/ implements j.l.AtomicAccess\n@@ -449,2 +449,2 @@\n-  \/\/ Query if this class implements jl.NonTearable or was\n-  \/\/ mentioned in the JVM option ForceNonTearable.\n+  \/\/ Query if this class implements j.l.AtomicAccess or was\n+  \/\/ mentioned in the JVM option ForceAtomicAccess.\n@@ -453,1 +453,1 @@\n-  \/\/ It inherits from supers along with NonTearable.\n+  \/\/ It inherits from supers along with AtomicAccess.\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2080,2 +2080,2 @@\n-  product(ccstrlist, ForceNonTearable, \"\", DIAGNOSTIC,                      \\\n-          \"List of inline classes which are forced to be atomic \"           \\\n+  product(ccstrlist, ForceAtomicAccess, \"\", DIAGNOSTIC,                     \\\n+          \"List of inline classes which are forced to be atomic access \"    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * A primitive class implements the {@code AtomicAccess} interface to\n+ * request that the JVM take extra care to avoid non-atomic operations\n+ * when loading or storing any value of the class to a field or array\n+ * element.  Normally, only naturally atomic fields and fields declared\n+ * {@code volatile} are always atomic, but a class that implements\n+ * this marker interface will always be accessed atomically, even when\n+ * they are stored in array elements or in non-{@code volatile}\n+ * fields, and even when multiple threads perform racing writes.\n+ *\n+ * <p> A primitive instance of multiple components can experience both\n+ * transient and persistent access atomicity failures.\n+ *\n+ * <p> Transient failures usually arise from write-read conflicts:\n+ * when one thread writes the components one-by-one, and another\n+ * thread reads the components one-by-one. In doing so, reader\n+ * observes the intermediate state of the primitive instance.\n+ * This failure is transient, since \"after\" (in memory model sense)\n+ * the writer finishes its writes, the instance is observed in full\n+ * by any subsequent observer.\n+ *\n+ * <p> Permanent failures usually arise from write-write conflicts:\n+ * when two threads compete to write the components, and one thread\n+ * writes some components while another thread writes other\n+ * components. This failure is permanent: as every subsequent observer\n+ * will read a hybrid composed of field values from both racing writes.\n+ *\n+ * Both these effects can be described as if the Java memory model\n+ * break up primitive class instance reads and writes into reads and\n+ * writes of their various fields, as it does with longs and doubles\n+ * (JLS 17.7).\n+ *\n+ * <p> In extreme cases, the hybrid observed under non-atomic access\n+ * might be a value which is impossible to construct by normal means.\n+ * If data integrity or security depends on proper construction,\n+ * the class should be declared as implementing {@code AtomicAccess}.\n+ *\n+ * <p> Note this atomicity guarantee only relates to the <i>individual\n+ * accesses<\/i>, not the compound operations over the values. The\n+ * read-modify-write operation over {@code AtomicAccess} would still\n+ * be non-atomic, unless specifically written with appropriate\n+ * synchronization.\n+ *\n+ * @author  John Rose\n+ * @since   (valhalla)\n+ *\/\n+public interface AtomicAccess {\n+    \/\/ TO DO: Finalize name.\n+    \/\/ TO DO: Decide whether and how to restrict this type to\n+    \/\/ primitive classes only, or if not, whether to document its\n+    \/\/ non-effect on identity classes.\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AtomicAccess.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * A primitive class implements the {@code NonTearable} interface to\n- * request that the JVM take extra care to avoid structure tearing\n- * when loading or storing any value of the class to a field or array\n- * element.  Normally, only fields declared {@code volatile} are\n- * protected against structure tearing, but a class that implements\n- * this marker interface will never have its values torn, even when\n- * they are stored in array elements or in non-{@code volatile}\n- * fields, and even when multiple threads perform racing writes.\n- *\n- * <p> An primitive instance of multiple components is said to be \"torn\"\n- * when two racing threads compete to write those components, and one\n- * thread writes some components while another thread writes other\n- * components, so a subsequent observer will read a hybrid composed,\n- * as if \"out of thin air\", of field values from both racing writes.\n- * Tearing can also occur when the effects of two non-racing writes\n- * are observed by a racing read.  In general, structure tearing\n- * requires a read and two writes (initialization counting as a write)\n- * of a multi-component value, with a race between any two of the\n- * accesses.  The effect can also be described as if the Java memory\n- * model break up primitive classinstance reads and writes into reads and\n- * writes of their various fields, as it does with longs and doubles\n- * (JLS 17.7).\n- *\n- * <p> In extreme cases, the hybrid observed after structure tearing\n- * might be a value which is impossible to construct by normal means.\n- * If data integrity or security depends on proper construction,\n- * the class should be declared as implementing {@code NonTearable}.\n- *\n- * @author  John Rose\n- * @since   (valhalla)\n- *\/\n-public interface NonTearable {\n-    \/\/ TO DO: Finalize name.\n-    \/\/ TO DO: Decide whether and how to restrict this type to\n-    \/\/ primitive classes only, or if not, whether to document its\n-    \/\/ non-effect on identity classes.\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NonTearable.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.FlattenableSemanticTest\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=* runtime.valhalla.inlinetypes.FlattenableSemanticTest\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.FlattenableSemanticTest\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=* runtime.valhalla.inlinetypes.FlattenableSemanticTest\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlattenableSemanticTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=* runtime.valhalla.inlinetypes.InlineTypeArray\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- *                   -Xbootclasspath\/a:. -XX:ForceNonTearable=*\n+ *                   -Xbootclasspath\/a:. -XX:ForceAtomicAccess=*\n@@ -53,1 +53,1 @@\n-    private static final boolean VM_FLAG_FORCENONTEARABLE = WHITE_BOX.getStringVMFlag(\"ForceNonTearable\").equals(\"*\");\n+    private static final boolean VM_FLAG_FORCEATOMICACCESS = WHITE_BOX.getStringVMFlag(\"ForceAtomicAccess\").equals(\"*\");\n@@ -309,1 +309,1 @@\n-        if (!VM_FLAG_FORCENONTEARABLE) {\n+        if (!VM_FLAG_FORCEATOMICACCESS) {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeDensity.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n- *                   -XX:ForceNonTearable=*\n+ *                   -XX:ForceAtomicAccess=*\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.Optional;\n+\n+import jdk.internal.misc.Unsafe;\n+import sun.hotspot.WhiteBox;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test ValueAtomicAccess\n+ * @summary Test atomicity of inline fields and array elements\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile ValueAtomicAccess.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=\n+ *                   -DSTEP_COUNT=10000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueAtomicAccess\n+ * @run main\/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=*\n+ *                   -DSTEP_COUNT=10000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueAtomicAccess\n+ * @run main\/othervm -Xbatch -DSTEP_COUNT=10000000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueAtomicAccess\n+ * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=\n+ *                   -DTEAR_MODE=fieldonly -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueAtomicAccess\n+ * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=\n+ *                   -DTEAR_MODE=arrayonly -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueAtomicAccess\n+ * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceAtomicAccess=*\n+ *                   -DTEAR_MODE=both -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n+ *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *                                   runtime.valhalla.inlinetypes.ValueAtomicAccess\n+ *\/\n+public class ValueAtomicAccess {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    private static final boolean ALWAYS_ATOMIC = WHITE_BOX.getStringVMFlag(\"ForceAtomicAccess\").contains(\"*\");\n+    private static final String TEAR_MODE = System.getProperty(\"TEAR_MODE\", \"both\");\n+    private static final boolean TEAR_FIELD = !TEAR_MODE.equals(\"arrayonly\");\n+    private static final boolean TEAR_ARRAY = !TEAR_MODE.equals(\"fieldonly\");\n+    private static final int STEP_COUNT = Integer.getInteger(\"STEP_COUNT\", 100_000);\n+    private static final boolean TFIELD_FLAT, TARRAY_FLAT;\n+    private static final boolean AAFIELD_FLAT, AAARRAY_FLAT;\n+    static {\n+        try {\n+            Field TPB_field = TPointBox.class.getDeclaredField(\"field\");\n+            Field TPB_array = TPointBox.class.getDeclaredField(\"array\");\n+            Field AAPB_field = AAPointBox.class.getDeclaredField(\"field\");\n+            Field AAPB_array = AAPointBox.class.getDeclaredField(\"array\");\n+            TFIELD_FLAT = UNSAFE.isFlattened(TPB_field);\n+            TARRAY_FLAT = UNSAFE.isFlattenedArray(TPB_array.getType());\n+            AAFIELD_FLAT = UNSAFE.isFlattened(AAPB_field);\n+            AAARRAY_FLAT = UNSAFE.isFlattenedArray(AAPB_array.getType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+    private static final String SETTINGS =\n+        String.format(\"USE_COMPILER=%s ALWAYS_ATOMIC=%s TEAR_MODE=%s STEP_COUNT=%s FLAT TF\/TA=%s\/%s AAF\/AAA=%s\/%s\",\n+                      USE_COMPILER, ALWAYS_ATOMIC, TEAR_MODE, STEP_COUNT,\n+                      TFIELD_FLAT, TARRAY_FLAT, AAFIELD_FLAT, AAARRAY_FLAT);\n+    private static final String NOTE_TORN_POINT = \"Note: torn point\";\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(SETTINGS);\n+        ValueAtomicAccess valueTearing = new ValueAtomicAccess();\n+        valueTearing.run();\n+        \/\/ Extra representation check:\n+        assert(!AAFIELD_FLAT) : \"AA field must be indirect not flat\";\n+        assert(!AAARRAY_FLAT) : \"AA array must be indirect not flat\";\n+        if (ALWAYS_ATOMIC) {\n+            assert(!TFIELD_FLAT) : \"field must be indirect not flat\";\n+            assert(!TARRAY_FLAT) : \"array must be indirect not flat\";\n+        }\n+    }\n+\n+    \/\/ A normally non-atomic inline value.\n+    static primitive class TPoint {\n+        TPoint(long x, long y) { this.x = x; this.y = y; }\n+        final long x, y;\n+        public String toString() { return String.format(\"(%d,%d)\", x, y); }\n+    }\n+\n+    static class TooTearable extends AssertionError {\n+        final Object badPoint;\n+        TooTearable(String msg, Object badPoint) {\n+            super(msg);\n+            this.badPoint = badPoint;\n+        }\n+    }\n+\n+    interface PointBox {\n+        void step();    \/\/ mutate inline value state\n+        void check();   \/\/ check sanity of inline value state\n+    }\n+\n+    class TPointBox implements PointBox {\n+        TPoint field;\n+        TPoint[] array = new TPoint[1];\n+        \/\/ Step the points forward by incrementing their components\n+        \/\/ \"simultaneously\".  A racing thread will catch flaws in the\n+        \/\/ simultaneity.\n+        TPoint step(TPoint p) {\n+            return new TPoint(p.x + 1, p.y + 1);\n+        }\n+        public @Override\n+        void step() {\n+            if (TEAR_FIELD) {\n+                field = step(field);\n+            }\n+            if (TEAR_ARRAY) {\n+                array[0] = step(array[0]);\n+            }\n+            check();\n+        }\n+        \/\/ Invariant:  The components of each point are \"always\" equal.\n+        \/\/ As long as simultaneity is preserved, this is true.\n+        public @Override\n+        void check() {\n+            if (TEAR_FIELD) {\n+                check(field, \"field\");\n+            }\n+            if (TEAR_ARRAY) {\n+                check(array[0], \"array element\");\n+            }\n+        }\n+        void check(TPoint p, String where) {\n+            if (p.x == p.y)  return;\n+            String msg = String.format(\"%s %s in %s; settings = %s\",\n+                                       NOTE_TORN_POINT,\n+                                       p, where, SETTINGS);\n+            throw new TooTearable(msg, p);\n+        }\n+        public String toString() {\n+            return String.format(\"TPB[%s, {%s}]\", field, array[0]);\n+        }\n+    }\n+\n+    \/\/ Add an indirection, as an extra test.\n+    interface AA extends AtomicAccess { }\n+\n+    \/\/ A hardened, always atomic version of TPoint.\n+    static primitive class AAPoint implements AA {\n+        AAPoint(long x, long y) { this.x = x; this.y = y; }\n+        final long x, y;\n+        public String toString() { return String.format(\"(%d,%d)\", x, y); }\n+    }\n+\n+    class AAPointBox implements PointBox {\n+        AAPoint field;\n+        AAPoint[] array = new AAPoint[1];\n+        \/\/ Step the points forward by incrementing their components\n+        \/\/ \"simultaneously\".  A racing thread will catch flaws in the\n+        \/\/ simultaneity.\n+        AAPoint step(AAPoint p) {\n+            return new AAPoint(p.x + 1, p.y + 1);\n+        }\n+        public @Override\n+        void step() {\n+            field = step(field);\n+            array[0] = step(array[0]);\n+            check();\n+        }\n+        \/\/ Invariant:  The components of each point are \"always\" equal.\n+        public @Override\n+        void check() {\n+            check(field, \"field\");\n+            check(array[0], \"array element\");\n+        }\n+        void check(AAPoint p, String where) {\n+            if (p.x == p.y)  return;\n+            String msg = String.format(\"%s *AlwaysAtomic* %s in %s; settings = %s\",\n+                                       NOTE_TORN_POINT,\n+                                       p, where, SETTINGS);\n+            throw new TooTearable(msg, p);\n+        }\n+        public String toString() {\n+            return String.format(\"AAPB[%s, {%s}]\", field, array[0]);\n+        }\n+    }\n+\n+    class AsyncObserver extends Thread {\n+        volatile boolean done;\n+        long observationCount;\n+        final PointBox pointBox;\n+        volatile Object badPointObserved;\n+        AsyncObserver(PointBox pointBox) {\n+            this.pointBox = pointBox;\n+        }\n+        public void run() {\n+            try {\n+                while (!done) {\n+                    observationCount++;\n+                    pointBox.check();\n+                }\n+            } catch (TooTearable ex) {\n+                done = true;\n+                badPointObserved = ex.badPoint;\n+                System.out.println(ex);\n+                if (ALWAYS_ATOMIC || ex.badPoint instanceof AtomicAccess) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void run() throws Exception {\n+        System.out.println(\"Test for access atomicity of AAPoint, which must not be broken...\");\n+        run(new AAPointBox(), false);\n+        System.out.println(\"Test for access atomicity of TPoint, which \"+\n+                           (ALWAYS_ATOMIC ? \"must not\" : \"is allowed to\")+\n+                           \" be broken...\");\n+        run(new TPointBox(), ALWAYS_ATOMIC ? false : true);\n+    }\n+    public void run(PointBox pointBox, boolean nonAtomic) throws Exception {\n+        var observer = new AsyncObserver(pointBox);\n+        observer.start();\n+        for (int i = 0; i < STEP_COUNT; i++) {\n+            pointBox.step();\n+            if (observer.done)  break;\n+        }\n+        observer.done = true;\n+        observer.join();\n+        var obCount = observer.observationCount;\n+        var badPoint = observer.badPointObserved;\n+        System.out.println(String.format(\"finished after %d observations at %s; %s\",\n+                                         obCount, pointBox,\n+                                         (badPoint == null\n+                                          ? \"no access atomicity problems observed\"\n+                                          : \"bad point = \" + badPoint)));\n+        if (nonAtomic && badPoint == null) {\n+            var complain = String.format(\"%s NOT observed after %d observations\",\n+                                         NOTE_TORN_POINT, obCount);\n+            System.out.println(\"?????? \"+complain);\n+            if (STEP_COUNT >= 3_000_000) {\n+                \/\/ If it's a small count, OK, but if it's big the test is broken.\n+                throw new AssertionError(complain + \", but it should have been\");\n+            }\n+        }\n+        if (!nonAtomic && badPoint != null) {\n+            throw new AssertionError(\"should not reach here; other thread must throw\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueAtomicAccess.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package runtime.valhalla.inlinetypes;\n-\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Supplier;\n-import java.util.Optional;\n-\n-import jdk.internal.misc.Unsafe;\n-import sun.hotspot.WhiteBox;\n-import static jdk.test.lib.Asserts.*;\n-\n-\/*\n- * @test ValueTearing\n- * @summary Test tearing of inline fields and array elements\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @compile ValueTearing.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=\n- *                   -DSTEP_COUNT=10000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n- *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n- *                                   runtime.valhalla.inlinetypes.ValueTearing\n- * @run main\/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*\n- *                   -DSTEP_COUNT=10000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n- *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n- *                                   runtime.valhalla.inlinetypes.ValueTearing\n- * @run main\/othervm -Xbatch -DSTEP_COUNT=10000000 -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n- *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                                   runtime.valhalla.inlinetypes.ValueTearing\n- * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=\n- *                   -DTEAR_MODE=fieldonly -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n- *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n- *                                   runtime.valhalla.inlinetypes.ValueTearing\n- * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=\n- *                   -DTEAR_MODE=arrayonly -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n- *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n- *                                   runtime.valhalla.inlinetypes.ValueTearing\n- * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*\n- *                   -DTEAR_MODE=both -XX:InlineFieldMaxFlatSize=128 -XX:FlatArrayElementMaxSize=-1\n- *                   -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n- *                                   runtime.valhalla.inlinetypes.ValueTearing\n- *\/\n-public class ValueTearing {\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n-    private static final boolean ALWAYS_ATOMIC = WHITE_BOX.getStringVMFlag(\"ForceNonTearable\").contains(\"*\");\n-    private static final String TEAR_MODE = System.getProperty(\"TEAR_MODE\", \"both\");\n-    private static final boolean TEAR_FIELD = !TEAR_MODE.equals(\"arrayonly\");\n-    private static final boolean TEAR_ARRAY = !TEAR_MODE.equals(\"fieldonly\");\n-    private static final int STEP_COUNT = Integer.getInteger(\"STEP_COUNT\", 100_000);\n-    private static final boolean TFIELD_FLAT, TARRAY_FLAT;\n-    private static final boolean NTFIELD_FLAT, NTARRAY_FLAT;\n-    static {\n-        try {\n-            Field TPB_field = TPointBox.class.getDeclaredField(\"field\");\n-            Field TPB_array = TPointBox.class.getDeclaredField(\"array\");\n-            Field NTPB_field = NTPointBox.class.getDeclaredField(\"field\");\n-            Field NTPB_array = NTPointBox.class.getDeclaredField(\"array\");\n-            TFIELD_FLAT = UNSAFE.isFlattened(TPB_field);\n-            TARRAY_FLAT = UNSAFE.isFlattenedArray(TPB_array.getType());\n-            NTFIELD_FLAT = UNSAFE.isFlattened(NTPB_field);\n-            NTARRAY_FLAT = UNSAFE.isFlattenedArray(NTPB_array.getType());\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-    private static final String SETTINGS =\n-        String.format(\"USE_COMPILER=%s ALWAYS_ATOMIC=%s TEAR_MODE=%s STEP_COUNT=%s FLAT TF\/TA=%s\/%s NTF\/NTA=%s\/%s\",\n-                      USE_COMPILER, ALWAYS_ATOMIC, TEAR_MODE, STEP_COUNT,\n-                      TFIELD_FLAT, TARRAY_FLAT, NTFIELD_FLAT, NTARRAY_FLAT);\n-    private static final String NOTE_TORN_POINT = \"Note: torn point\";\n-\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(SETTINGS);\n-        ValueTearing valueTearing = new ValueTearing();\n-        valueTearing.run();\n-        \/\/ Extra representation check:\n-        assert(!NTFIELD_FLAT) : \"NT field must be indirect not flat\";\n-        assert(!NTARRAY_FLAT) : \"NT array must be indirect not flat\";\n-        if (ALWAYS_ATOMIC) {\n-            assert(!TFIELD_FLAT) : \"field must be indirect not flat\";\n-            assert(!TARRAY_FLAT) : \"array must be indirect not flat\";\n-        }\n-    }\n-\n-    \/\/ A normally tearable inline value.\n-    static primitive class TPoint {\n-        TPoint(long x, long y) { this.x = x; this.y = y; }\n-        final long x, y;\n-        public String toString() { return String.format(\"(%d,%d)\", x, y); }\n-    }\n-\n-    static class TooTearable extends AssertionError {\n-        final Object badPoint;\n-        TooTearable(String msg, Object badPoint) {\n-            super(msg);\n-            this.badPoint = badPoint;\n-        }\n-    }\n-\n-    interface PointBox {\n-        void step();    \/\/ mutate inline value state\n-        void check();   \/\/ check sanity of inline value state\n-    }\n-\n-    class TPointBox implements PointBox {\n-        TPoint field;\n-        TPoint[] array = new TPoint[1];\n-        \/\/ Step the points forward by incrementing their components\n-        \/\/ \"simultaneously\".  A racing thread will catch flaws in the\n-        \/\/ simultaneity.\n-        TPoint step(TPoint p) {\n-            return new TPoint(p.x + 1, p.y + 1);\n-        }\n-        public @Override\n-        void step() {\n-            if (TEAR_FIELD) {\n-                field = step(field);\n-            }\n-            if (TEAR_ARRAY) {\n-                array[0] = step(array[0]);\n-            }\n-            check();\n-        }\n-        \/\/ Invariant:  The components of each point are \"always\" equal.\n-        \/\/ As long as simultaneity is preserved, this is true.\n-        public @Override\n-        void check() {\n-            if (TEAR_FIELD) {\n-                check(field, \"field\");\n-            }\n-            if (TEAR_ARRAY) {\n-                check(array[0], \"array element\");\n-            }\n-        }\n-        void check(TPoint p, String where) {\n-            if (p.x == p.y)  return;\n-            String msg = String.format(\"%s %s in %s; settings = %s\",\n-                                       NOTE_TORN_POINT,\n-                                       p, where, SETTINGS);\n-            throw new TooTearable(msg, p);\n-        }\n-        public String toString() {\n-            return String.format(\"TPB[%s, {%s}]\", field, array[0]);\n-        }\n-    }\n-\n-    \/\/ Add an indirection, as an extra test.\n-    interface NT extends NonTearable { }\n-\n-    \/\/ A hardened, non-tearable version of TPoint.\n-    static primitive class NTPoint implements NT {\n-        NTPoint(long x, long y) { this.x = x; this.y = y; }\n-        final long x, y;\n-        public String toString() { return String.format(\"(%d,%d)\", x, y); }\n-    }\n-\n-    class NTPointBox implements PointBox {\n-        NTPoint field;\n-        NTPoint[] array = new NTPoint[1];\n-        \/\/ Step the points forward by incrementing their components\n-        \/\/ \"simultaneously\".  A racing thread will catch flaws in the\n-        \/\/ simultaneity.\n-        NTPoint step(NTPoint p) {\n-            return new NTPoint(p.x + 1, p.y + 1);\n-        }\n-        public @Override\n-        void step() {\n-            field = step(field);\n-            array[0] = step(array[0]);\n-            check();\n-        }\n-        \/\/ Invariant:  The components of each point are \"always\" equal.\n-        public @Override\n-        void check() {\n-            check(field, \"field\");\n-            check(array[0], \"array element\");\n-        }\n-        void check(NTPoint p, String where) {\n-            if (p.x == p.y)  return;\n-            String msg = String.format(\"%s *NonTearable* %s in %s; settings = %s\",\n-                                       NOTE_TORN_POINT,\n-                                       p, where, SETTINGS);\n-            throw new TooTearable(msg, p);\n-        }\n-        public String toString() {\n-            return String.format(\"NTPB[%s, {%s}]\", field, array[0]);\n-        }\n-    }\n-\n-    class AsyncObserver extends Thread {\n-        volatile boolean done;\n-        long observationCount;\n-        final PointBox pointBox;\n-        volatile Object badPointObserved;\n-        AsyncObserver(PointBox pointBox) {\n-            this.pointBox = pointBox;\n-        }\n-        public void run() {\n-            try {\n-                while (!done) {\n-                    observationCount++;\n-                    pointBox.check();\n-                }\n-            } catch (TooTearable ex) {\n-                done = true;\n-                badPointObserved = ex.badPoint;\n-                System.out.println(ex);\n-                if (ALWAYS_ATOMIC || ex.badPoint instanceof NonTearable) {\n-                    throw ex;\n-                }\n-            }\n-        }\n-    }\n-\n-    public void run() throws Exception {\n-        System.out.println(\"Test for tearing of NTPoint, which must not happen...\");\n-        run(new NTPointBox(), false);\n-        System.out.println(\"Test for tearing of TPoint, which \"+\n-                           (ALWAYS_ATOMIC ? \"must not\" : \"is allowed to\")+\n-                           \" happen...\");\n-        run(new TPointBox(), ALWAYS_ATOMIC ? false : true);\n-    }\n-    public void run(PointBox pointBox, boolean canTear) throws Exception {\n-        var observer = new AsyncObserver(pointBox);\n-        observer.start();\n-        for (int i = 0; i < STEP_COUNT; i++) {\n-            pointBox.step();\n-            if (observer.done)  break;\n-        }\n-        observer.done = true;\n-        observer.join();\n-        var obCount = observer.observationCount;\n-        var badPoint = observer.badPointObserved;\n-        System.out.println(String.format(\"finished after %d observations at %s; %s\",\n-                                         obCount, pointBox,\n-                                         (badPoint == null\n-                                          ? \"no tearing observed\"\n-                                          : \"bad point = \" + badPoint)));\n-        if (canTear && badPoint == null) {\n-            var complain = String.format(\"%s NOT observed after %d observations\",\n-                                         NOTE_TORN_POINT, obCount);\n-            System.out.println(\"?????? \"+complain);\n-            if (STEP_COUNT >= 3_000_000) {\n-                \/\/ If it's a small count, OK, but if it's big the test is broken.\n-                throw new AssertionError(complain + \", but it should have been\");\n-            }\n-        }\n-        if (!canTear && badPoint != null) {\n-            throw new AssertionError(\"should not reach here; other thread must throw\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueTearing.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"}]}