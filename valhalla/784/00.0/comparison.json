{"files":[{"patch":"@@ -556,1 +556,1 @@\n-    [ \"linux-x64\", \"macosx-x64\", \"windows-x64\", \"linux-aarch64\"]\n+    [ \"linux-x64\", \"macosx-aarch64\", \"macosx-x64\", \"windows-x64\", \"linux-aarch64\"]\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1691,0 +1691,11 @@\n+\/\/ Method entry for java.lang.Thread.currentThread\n+address TemplateInterpreterGenerator::generate_currentThread() {\n+  address entry_point = __ pc();\n+\n+  __ ldr(r0, Address(rthread, JavaThread::vthread_offset()));\n+  __ resolve_oop_handle(r0, rscratch1, rscratch2);\n+  __ ret(lr);\n+\n+  return entry_point;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -871,1 +871,1 @@\n-void HeapShared::resolve_classes(JavaThread* THREAD) {\n+void HeapShared::resolve_classes(JavaThread* current) {\n@@ -876,3 +876,3 @@\n-  resolve_classes_for_subgraphs(closed_archive_subgraph_entry_fields,   THREAD);\n-  resolve_classes_for_subgraphs(open_archive_subgraph_entry_fields,     THREAD);\n-  resolve_classes_for_subgraphs(fmg_open_archive_subgraph_entry_fields, THREAD);\n+  resolve_classes_for_subgraphs(current, closed_archive_subgraph_entry_fields);\n+  resolve_classes_for_subgraphs(current, open_archive_subgraph_entry_fields);\n+  resolve_classes_for_subgraphs(current, fmg_open_archive_subgraph_entry_fields);\n@@ -881,2 +881,1 @@\n-void HeapShared::resolve_classes_for_subgraphs(ArchivableStaticFieldInfo fields[],\n-                                               JavaThread* THREAD) {\n+void HeapShared::resolve_classes_for_subgraphs(JavaThread* current, ArchivableStaticFieldInfo fields[]) {\n@@ -888,1 +887,1 @@\n-    resolve_classes_for_subgraph_of(k, THREAD);\n+    resolve_classes_for_subgraph_of(current, k);\n@@ -892,1 +891,2 @@\n-void HeapShared::resolve_classes_for_subgraph_of(Klass* k, JavaThread* THREAD) {\n+void HeapShared::resolve_classes_for_subgraph_of(JavaThread* current, Klass* k) {\n+  JavaThread* THREAD = current;\n@@ -904,1 +904,2 @@\n-void HeapShared::initialize_from_archived_subgraph(Klass* k, JavaThread* THREAD) {\n+void HeapShared::initialize_from_archived_subgraph(JavaThread* current, Klass* k) {\n+  JavaThread* THREAD = current;\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1211,11 +1211,6 @@\n-  VM_ENTRY_MARK;\n-  {\n-    ExceptionMark em(THREAD);\n-    methodHandle m(THREAD, get_Method());\n-    bool has_unloaded = Method::has_unloaded_classes_in_signature(m, thread);\n-    if( HAS_PENDING_EXCEPTION ) {\n-      CLEAR_PENDING_EXCEPTION;\n-      return true;     \/\/ Declare that we may have unloaded classes\n-    }\n-    return has_unloaded;\n-  }\n+  \/\/ ciSignature is resolved against some accessing class and\n+  \/\/ signature classes aren't required to be local. As a benefit,\n+  \/\/ it makes signature classes visible through loader constraints.\n+  \/\/ So, encountering an unloaded class signals it is absent both in\n+  \/\/ the callee (local) and caller contexts.\n+  return signature()->has_unloaded_classes();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciStreams.hpp\"\n@@ -49,4 +50,1 @@\n-  int count = 0;\n-  Symbol* sh = symbol->get_symbol();\n-  SignatureStream ss(sh);\n-  for (; ; ss.next()) {\n+  for (SignatureStream ss(symbol->get_symbol()); !ss.is_done(); ss.next()) {\n@@ -55,4 +53,2 @@\n-    ciType* type;\n-    if (!ss.is_reference()) {\n-      type = ciType::make(ss.type());\n-    } else {\n+    ciType* type = NULL;\n+    if (ss.is_reference()) {\n@@ -61,0 +57,2 @@\n+    } else {\n+      type = ciType::make(ss.type());\n@@ -65,4 +63,6 @@\n-      break;\n-    }\n-    if (type->is_inlinetype() && ss.has_Q_descriptor()) {\n-      type = env->make_null_free_wrapper(type);\n+    } else {\n+      if (type->is_inlinetype() && ss.has_Q_descriptor()) {\n+        type = env->make_null_free_wrapper(type);\n+      }\n+      _types.append(type);\n+      size += type->size();\n@@ -70,2 +70,0 @@\n-    _types.append(type);\n-    size += type->size();\n@@ -117,0 +115,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciSignature::has_unloaded_classes\n+\/\/\n+\/\/ Reports if there are any unloaded classes present in the signature.\n+\/\/ Each ciSignature when instantiated is resolved against some accessing class\n+\/\/ and the resolved classes aren't required to be local, but can be revealed\n+\/\/ through loader constraints.\n+bool ciSignature::has_unloaded_classes() {\n+  for (ciSignatureStream str(this); !str.is_done(); str.next()) {\n+    if (!str.type()->is_loaded()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+  bool has_unloaded_classes();\n+\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);\n@@ -100,1 +99,0 @@\n-static GetNextEntry_t    GetNextEntry       = NULL;\n@@ -340,12 +338,0 @@\n-\/\/ invoke function for each entry in the zip file\n-void ClassPathZipEntry::contents_do(void f(const char* name, void* context), void* context) {\n-  JavaThread* thread = JavaThread::current();\n-  HandleMark  handle_mark(thread);\n-  ThreadToNativeFromVM ttn(thread);\n-  for (int n = 0; ; n++) {\n-    jzentry * ze = ((*GetNextEntry)(_zip, n));\n-    if (ze == NULL) break;\n-    (*f)(ze->name, context);\n-  }\n-}\n-\n@@ -957,1 +943,0 @@\n-  GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(_zip_handle, \"ZIP_GetNextEntry\", path));\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2014,5 +2014,6 @@\n-        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false) {\n-      \/\/ Pick some initial length\n-      int init_length = MaxJavaStackTraceDepth \/ 2;\n-      _methods = new GrowableArray<Method*>(init_length);\n-      _bcis = new GrowableArray<int>(init_length);\n+        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+        _methods(nullptr), _bcis(nullptr) {\n+    }\n+    ~GetStackTraceClosure() {\n+      delete _methods;\n+      delete _bcis;\n@@ -2055,0 +2056,5 @@\n+      \/\/ Pick minimum length that will cover most cases\n+      int init_length = 64;\n+      _methods = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n+      _bcis = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(init_length, mtInternal);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -209,1 +209,3 @@\n-   do_name(     isInfinite_name,                                 \"isInfinite\")                                          \\\n+   do_name(     isInfinite_name,                                  \"isInfinite\")                                         \\\n+  do_intrinsic(_floatIsFinite,            java_lang_Float,        isFinite_name,      float_bool_signature,      F_S)   \\\n+   do_name(     isFinite_name,                                    \"isFinite\")                                           \\\n@@ -211,0 +213,1 @@\n+  do_intrinsic(_doubleIsFinite,           java_lang_Double,       isFinite_name,      double_bool_signature,     F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-    _consts_offset           = data_offset();\n+    _consts_offset           = content_offset()      + code_buffer->total_offset_of(code_buffer->consts());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -436,2 +436,0 @@\n-  assert((region_size & RegionSizeOffsetMask) == 0,\n-         \"region size not a multiple of RegionSize\");\n@@ -474,1 +472,4 @@\n-  const size_t count = (region_size + RegionSizeOffsetMask) >> Log2RegionSize;\n+  assert((region_size & RegionSizeOffsetMask) == 0,\n+         \"region size not a multiple of RegionSize\");\n+\n+  const size_t count = region_size >> Log2RegionSize;\n@@ -2409,1 +2410,0 @@\n-  uint _active_workers;\n@@ -2415,2 +2415,1 @@\n-      _terminator(active_workers, ParCompactionManager::region_task_queues()),\n-      _active_workers(active_workers) {\n+      _terminator(active_workers, ParCompactionManager::region_task_queues()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const { return false; }\n+  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode, Unique_Node_List& dead_nodes) const { return false; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  void notify_allocation();\n+  void notify_allocation(JavaThread* thread);\n@@ -63,1 +63,1 @@\n-  void notify_allocation_dtrace_sampler();\n+  void notify_allocation_dtrace_sampler(JavaThread* thread);\n@@ -87,1 +87,1 @@\n-      notify_allocation();\n+      notify_allocation(_thread);\n@@ -238,1 +238,1 @@\n-void MemAllocator::Allocation::notify_allocation_dtrace_sampler() {\n+void MemAllocator::Allocation::notify_allocation_dtrace_sampler(JavaThread* thread) {\n@@ -244,1 +244,1 @@\n-      SharedRuntime::dtrace_object_alloc(Thread::current(), obj(), word_size);\n+      SharedRuntime::dtrace_object_alloc(thread, obj(), word_size);\n@@ -249,1 +249,1 @@\n-void MemAllocator::Allocation::notify_allocation() {\n+void MemAllocator::Allocation::notify_allocation(JavaThread* thread) {\n@@ -252,1 +252,1 @@\n-  notify_allocation_dtrace_sampler();\n+  notify_allocation_dtrace_sampler(thread);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1083,1 +1083,2 @@\n-             n->in(0) != NULL) {\n+             n->in(0) != NULL &&\n+             n->outcnt() == 2) {\n@@ -1121,1 +1122,1 @@\n-bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {\n+bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode, Unique_Node_List& dead_nodes) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const;\n+  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode, Unique_Node_List& dead_nodes) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-#ifdef AMD64\n+#if defined(AMD64) || defined(AARCH64)\n@@ -437,1 +437,1 @@\n-#ifdef AMD64\n+#if defined(AMD64) || defined(AARCH64)\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1807,14 +1807,0 @@\n-bool Method::has_unloaded_classes_in_signature(const methodHandle& m, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  for(ResolvingSignatureStream ss(m()); !ss.is_done(); ss.next()) {\n-    if (ss.type() == T_OBJECT) {\n-      \/\/ Do not use ss.is_reference() here, since we don't care about\n-      \/\/ unloaded array component types.\n-      Klass* klass = ss.as_klass_if_loaded(THREAD);\n-      assert(!HAS_PENDING_EXCEPTION, \"as_klass_if_loaded contract\");\n-      if (klass == NULL) return true;\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -2400,0 +2386,2 @@\n+  } else if (!os::is_readable_range(m, m + 1)) {\n+    return false;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1024,3 +1024,0 @@\n-  \/\/ Return if true if not all classes references in signature, including return type, has been loaded\n-  static bool has_unloaded_classes_in_signature(const methodHandle& m, TRAPS);\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -545,0 +545,3 @@\n+  case vmIntrinsics::_floatIsFinite:\n+    if (!Matcher::match_rule_supported(Op_IsFiniteF)) return false;\n+    break;\n@@ -548,0 +551,3 @@\n+  case vmIntrinsics::_doubleIsFinite:\n+    if (!Matcher::match_rule_supported(Op_IsFiniteD)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1765,0 +1765,1 @@\n+  init_req( ValidLengthTest    , topnode);\n@@ -1801,48 +1802,0 @@\n-\/\/=============================================================================\n-Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if (in(0) && in(0)->is_top())  return NULL;\n-\n-  const Type* type = phase->type(Ideal_length());\n-  if (type->isa_int() && type->is_int()->_hi < 0) {\n-    if (can_reshape) {\n-      PhaseIterGVN *igvn = phase->is_IterGVN();\n-      \/\/ Unreachable fall through path (negative array length),\n-      \/\/ the allocation can only throw so disconnect it.\n-      Node* proj = proj_out_or_null(TypeFunc::Control);\n-      Node* catchproj = NULL;\n-      if (proj != NULL) {\n-        for (DUIterator_Fast imax, i = proj->fast_outs(imax); i < imax; i++) {\n-          Node *cn = proj->fast_out(i);\n-          if (cn->is_Catch()) {\n-            catchproj = cn->as_Multi()->proj_out_or_null(CatchProjNode::fall_through_index);\n-            break;\n-          }\n-        }\n-      }\n-      if (catchproj != NULL && catchproj->outcnt() > 0 &&\n-          (catchproj->outcnt() > 1 ||\n-           catchproj->unique_out()->Opcode() != Op_Halt)) {\n-        assert(catchproj->is_CatchProj(), \"must be a CatchProjNode\");\n-        Node* nproj = catchproj->clone();\n-        igvn->register_new_node_with_optimizer(nproj);\n-\n-        Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );\n-        frame = phase->transform(frame);\n-        \/\/ Halt & Catch Fire\n-        Node* halt = new HaltNode(nproj, frame, \"unexpected negative array length\");\n-        igvn->add_input_to(phase->C->root(), halt);\n-        phase->transform(halt);\n-\n-        igvn->replace_node(catchproj, phase->C->top());\n-        return this;\n-      }\n-    } else {\n-      \/\/ Can't correct it during regular GVN so register for IGVN\n-      phase->C->record_for_igvn(this);\n-    }\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -911,1 +911,2 @@\n-    InlineType,                   \/\/ InlineTypeNode if this is an inline type allocation\n+    ValidLengthTest,\n+    InlineType,                       \/\/ InlineTypeNode if this is an inline type allocation\n@@ -923,0 +924,1 @@\n+    fields[ValidLengthTest] = TypeInt::BOOL;\n@@ -1022,5 +1024,3 @@\n-  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,\n-                    Node* size, Node* klass_node, Node* initial_test,\n-                    Node* count_val,\n-                    Node* default_value, Node* raw_default_value\n-                    )\n+  AllocateArrayNode(Compile* C, const TypeFunc* atype, Node* ctrl, Node* mem, Node* abio, Node* size, Node* klass_node,\n+                    Node* initial_test, Node* count_val, Node* valid_length_test,\n+                    Node* default_value, Node* raw_default_value)\n@@ -1032,0 +1032,1 @@\n+    set_req(AllocateNode::ValidLengthTest, valid_length_test);\n@@ -1036,1 +1037,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2852,0 +2852,11 @@\n+      } else if (call->is_AllocateArray()) {\n+        Node* klass_node = call->in(AllocateNode::KlassNode);\n+        Node* length = call->in(AllocateNode::ALength);\n+        const Type* length_type = phase->type(length);\n+        const Type* klass_type = phase->type(klass_node);\n+        Node* valid_length_test = call->in(AllocateNode::ValidLengthTest);\n+        const Type* valid_length_test_t = phase->type(valid_length_test);\n+        if (length_type == Type::TOP || klass_type == Type::TOP || valid_length_test_t == Type::TOP ||\n+            valid_length_test_t->is_int()->is_con(0)) {\n+          f[CatchProjNode::fall_through_index] = Type::TOP;\n+        }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+macro(IsFiniteF)\n@@ -252,0 +253,1 @@\n+macro(IsFiniteD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3578,1 +3578,1 @@\n-void Compile::final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &frc) {\n+void Compile::final_graph_reshaping_impl(Node *n, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes) {\n@@ -3629,1 +3629,1 @@\n-  bool gc_handled = BarrierSet::barrier_set()->barrier_set_c2()->final_graph_reshaping(this, n, nop);\n+  bool gc_handled = BarrierSet::barrier_set()->barrier_set_c2()->final_graph_reshaping(this, n, nop, dead_nodes);\n@@ -3631,1 +3631,1 @@\n-    final_graph_reshaping_main_switch(n, frc, nop);\n+    final_graph_reshaping_main_switch(n, frc, nop, dead_nodes);\n@@ -3640,1 +3640,1 @@\n-void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop) {\n+void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop, Unique_Node_List& dead_nodes) {\n@@ -4277,3 +4277,1 @@\n-      ResourceMark rm;\n-      Unique_Node_List wq;\n-      wq.push(n->in(MemBarNode::Precedent));\n+      dead_nodes.push(n->in(MemBarNode::Precedent));\n@@ -4281,12 +4279,0 @@\n-      while (wq.size() > 0) {\n-        Node* m = wq.pop();\n-        if (m->outcnt() == 0 && m != top()) {\n-          for (uint j = 0; j < m->req(); j++) {\n-            Node* in = m->in(j);\n-            if (in != NULL) {\n-              wq.push(in);\n-            }\n-          }\n-          m->disconnect_inputs(this);\n-        }\n-      }\n@@ -4372,1 +4358,1 @@\n-void Compile::final_graph_reshaping_walk( Node_Stack &nstack, Node *root, Final_Reshape_Counts &frc ) {\n+void Compile::final_graph_reshaping_walk(Node_Stack& nstack, Node* root, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes) {\n@@ -4398,1 +4384,1 @@\n-      final_graph_reshaping_impl( n, frc );\n+      final_graph_reshaping_impl(n, frc, dead_nodes);\n@@ -4498,1 +4484,2 @@\n-  final_graph_reshaping_walk(nstack, root(), frc);\n+  Unique_Node_List dead_nodes;\n+  final_graph_reshaping_walk(nstack, root(), frc, dead_nodes);\n@@ -4511,1 +4498,1 @@\n-          CallNode *call = n->in(0)->in(0)->as_Call();\n+          CallNode* call = n->in(0)->in(0)->as_Call();\n@@ -4520,1 +4507,1 @@\n-            Node *arg0 = call->in(TypeFunc::Parms);\n+            Node* arg0 = call->in(TypeFunc::Parms);\n@@ -4525,4 +4512,3 @@\n-          } else if (call->entry_point() == OptoRuntime::new_array_Java() &&\n-                     call->req() > TypeFunc::Parms+1 &&\n-                     call->is_CallStaticJava()) {\n-            \/\/ Check for negative array length. In such case, the optimizer has\n+          } else if (call->entry_point() == OptoRuntime::new_array_Java() ||\n+                     call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n+            \/\/ Check for illegal array length. In such case, the optimizer has\n@@ -4531,3 +4517,6 @@\n-            Node *arg1 = call->in(TypeFunc::Parms+1);\n-            if (arg1->is_Type() &&\n-                arg1->as_Type()->type()->join(TypeInt::POS)->empty()) {\n+            assert(call->is_CallStaticJava(), \"static call expected\");\n+            assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n+            uint valid_length_test_input = call->req() - 1;\n+            Node* valid_length_test = call->in(valid_length_test_input);\n+            call->del_req(valid_length_test_input);\n+            if (valid_length_test->find_int_con(1) == 0) {\n@@ -4536,0 +4525,3 @@\n+            dead_nodes.push(valid_length_test);\n+            assert(n->outcnt() == required_outcnt, \"malformed control flow\");\n+            continue;\n@@ -4544,0 +4536,10 @@\n+    } else if (n->is_PCTable() && n->in(0) && n->in(0)->in(0) && n->in(0)->in(0)->is_Call()) {\n+      CallNode* call = n->in(0)->in(0)->as_Call();\n+      if (call->entry_point() == OptoRuntime::new_array_Java() ||\n+          call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n+        assert(call->is_CallStaticJava(), \"static call expected\");\n+        assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n+        uint valid_length_test_input = call->req() - 1;\n+        dead_nodes.push(call->in(valid_length_test_input));\n+        call->del_req(valid_length_test_input); \/\/ valid length test useless now\n+      }\n@@ -4562,0 +4564,13 @@\n+  while (dead_nodes.size() > 0) {\n+    Node* m = dead_nodes.pop();\n+    if (m->outcnt() == 0 && m != top()) {\n+      for (uint j = 0; j < m->req(); j++) {\n+        Node* in = m->in(j);\n+        if (in != NULL) {\n+          dead_nodes.push(in);\n+        }\n+      }\n+      m->disconnect_inputs(this);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":46,"deletions":31,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1151,3 +1151,3 @@\n-  void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &frc);\n-  void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop);\n-  void final_graph_reshaping_walk( Node_Stack &nstack, Node *root, Final_Reshape_Counts &frc );\n+  void final_graph_reshaping_impl(Node *n, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes);\n+  void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop, Unique_Node_List& dead_nodes);\n+  void final_graph_reshaping_walk(Node_Stack& nstack, Node* root, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2727,1 +2727,3 @@\n-  Node* norm = _gvn.transform( new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci) );\n+  Node* norm = new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci);\n+  _gvn.set_type_bottom(norm);\n+  C->record_for_igvn(norm);\n@@ -4278,0 +4280,8 @@\n+  Node* valid_length_test = _gvn.intcon(1);\n+  if (ary_type->isa_aryptr()) {\n+    BasicType bt = ary_type->isa_aryptr()->elem()->array_element_basic_type();\n+    jint max = TypeAryPtr::max_array_length(bt);\n+    Node* valid_length_cmp  = _gvn.transform(new CmpUNode(length, intcon(max)));\n+    valid_length_test = _gvn.transform(new BoolNode(valid_length_cmp, BoolTest::le));\n+  }\n+\n@@ -4284,1 +4294,1 @@\n-                            length,\n+                            length, valid_length_test,\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -529,0 +529,1 @@\n+  case vmIntrinsics::_floatIsFinite:\n@@ -530,0 +531,1 @@\n+  case vmIntrinsics::_doubleIsFinite:\n@@ -4880,0 +4882,3 @@\n+  case vmIntrinsics::_floatIsFinite:\n+    result = new IsFiniteFNode(arg);\n+    break;\n@@ -4883,0 +4888,3 @@\n+  case vmIntrinsics::_doubleIsFinite:\n+    result = new IsFiniteDNode(arg);\n+    break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -785,5 +785,0 @@\n-#ifdef ASSERT\n-  \/\/ Tell whether the body contains nodes marked as reductions.\n-  bool has_reduction_nodes() const;\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2215,1 +2215,7 @@\n-      if (use->is_If() || use->is_CMove() || C->is_predicate_opaq(use) || use->Opcode() == Op_Opaque4) {\n+      \/\/\n+      \/\/ If the use is an AllocateArray through its ValidLengthTest input,\n+      \/\/ make sure the Bool\/Cmp input is cloned down to avoid a Phi between\n+      \/\/ the AllocateArray node and its ValidLengthTest input that could cause\n+      \/\/ split if to break.\n+      if (use->is_If() || use->is_CMove() || C->is_predicate_opaq(use) || use->Opcode() == Op_Opaque4 ||\n+          (use->Opcode() == Op_AllocateArray && use->in(AllocateNode::ValidLengthTest) == old)) {\n@@ -2591,3 +2597,4 @@\n-      if (iff->in(1)->is_Phi()) {\n-        Node *b = clone_iff(iff->in(1)->as_Phi());\n-        _igvn.replace_input_of(iff, 1, b);\n+      uint input = iff->Opcode() == Op_AllocateArray ? AllocateNode::ValidLengthTest : 1;\n+      if (iff->in(input)->is_Phi()) {\n+        Node *b = clone_iff(iff->in(input)->as_Phi());\n+        _igvn.replace_input_of(iff, input, b);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1338,1 +1338,2 @@\n-            address slow_call_address  \/\/ Address of slow call\n+            address slow_call_address,  \/\/ Address of slow call\n+            Node* valid_length_test \/\/ whether length is valid or not\n@@ -1527,0 +1528,6 @@\n+  \/\/ For array allocations, copy the valid length check to the call node so Compile::final_graph_reshaping() can verify\n+  \/\/ that the call has the expected number of CatchProj nodes (in case the allocation always fails and the fallthrough\n+  \/\/ path dies).\n+  if (valid_length_test != NULL) {\n+    call->add_req(valid_length_test);\n+  }\n@@ -1769,1 +1776,1 @@\n-                                          static_cast<int (*)(Thread*, oopDesc*)>(SharedRuntime::dtrace_object_alloc)),\n+                                          static_cast<int (*)(JavaThread*, oopDesc*)>(SharedRuntime::dtrace_object_alloc)),\n@@ -2014,1 +2021,1 @@\n-                         OptoRuntime::new_instance_Java());\n+                         OptoRuntime::new_instance_Java(), NULL);\n@@ -2019,0 +2026,1 @@\n+  Node* valid_length_test = alloc->in(AllocateNode::ValidLengthTest);\n@@ -2033,1 +2041,1 @@\n-                         slow_call_address);\n+                         slow_call_address, valid_length_test);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -94,2 +94,2 @@\n-                              address slow_call_address);\n-  void yank_initalize_node(InitializeNode* node);\n+                              address slow_call_address,\n+                              Node* valid_length_test);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1515,1 +1515,6 @@\n-Node *LoadNode::split_through_phi(PhaseGVN *phase) {\n+Node* LoadNode::split_through_phi(PhaseGVN* phase) {\n+  if (req() > 3) {\n+    assert(is_LoadVector() && Opcode() != Op_LoadVector, \"load has too many inputs\");\n+    \/\/ LoadVector subclasses such as LoadVectorMasked have extra inputs that the logic below doesn't take into account\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -479,2 +479,3 @@\n-      if (md_count == md->trap_count_limit())\n-        md_count += md->overflow_trap_count();\n+      if (md_count >= md->trap_count_limit()) {\n+        md_count = md->trap_count_limit() + md->overflow_trap_count();\n+      }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1665,0 +1665,10 @@\n+    \/\/ If the ValidLengthTest input changes then the fallthrough path out of the AllocateArray may have become dead.\n+    \/\/ CatchNode::Value() is responsible for killing that path. The CatchNode has to be explicitly enqueued for igvn\n+    \/\/ to guarantee the change is not missed.\n+    if (use_op == Op_AllocateArray && n == use->in(AllocateNode::ValidLengthTest)) {\n+      Node* p = use->as_AllocateArray()->proj_out_or_null(TypeFunc::Control);\n+      if (p != NULL) {\n+        add_users_to_worklist0(p);\n+      }\n+    }\n+\n@@ -1896,0 +1906,1 @@\n+\/\/ Same is true if the type of a ValidLengthTest input to an AllocateArrayNode changes.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1, \"unexpected node type\");\n-              Node *use_c = use->is_If() ? use->in(0) : get_ctrl(use);\n+              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1 || use->is_AllocateArray(), \"unexpected node type\");\n+              Node *use_c = (use->is_If() || use->is_AllocateArray()) ? use->in(0) : get_ctrl(use);\n@@ -170,2 +170,3 @@\n-                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1, \"unexpected node type\");\n-                assert(u->in(1) == bol, \"\");\n+                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1 || u->is_AllocateArray(), \"unexpected node type\");\n+                assert(u->is_AllocateArray() || u->in(1) == bol, \"\");\n+                assert(!u->is_AllocateArray() || u->in(AllocateNode::ValidLengthTest) == bol, \"wrong input to AllocateArray\");\n@@ -173,1 +174,1 @@\n-                Node *u_ctrl = u->is_If() ? u->in(0) : get_ctrl(u);\n+                Node *u_ctrl = (u->is_If() || u->is_AllocateArray()) ? u->in(0) : get_ctrl(u);\n@@ -177,1 +178,1 @@\n-                _igvn.replace_input_of(u, 1, x);\n+                _igvn.replace_input_of(u, u->is_AllocateArray() ? AllocateNode::ValidLengthTest : 1, x);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3620,1 +3620,1 @@\n-  HeapShared::initialize_from_archived_subgraph(k, THREAD);\n+  HeapShared::initialize_from_archived_subgraph(THREAD, k);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3171,0 +3171,6 @@\n+\n+  \/\/ Zero runs without compilers. Do not let compiler selection code\n+  \/\/ to force it into Serial GC, let the GC ergonomics decide.\n+  if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {\n+    FLAG_SET_ERGO(NeverActAsServerClassMachine, false);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1002,8 +1002,4 @@\n-\n-jlong SharedRuntime::get_java_tid(Thread* thread) {\n-  if (thread != NULL && thread->is_Java_thread()) {\n-    Thread* current = Thread::current();\n-    guarantee(current != thread || JavaThread::cast(thread)->is_oop_safe(),\n-              \"current cannot touch oops after its GC barrier is detached.\");\n-    oop obj = JavaThread::cast(thread)->threadObj();\n-    return (obj == NULL) ? 0 : java_lang_Thread::thread_id(obj);\n+jlong SharedRuntime::get_java_tid(JavaThread* thread) {\n+  assert(thread != NULL, \"No thread\");\n+  if (thread == NULL) {\n+    return 0;\n@@ -1011,1 +1007,4 @@\n-  return 0;\n+  guarantee(Thread::current() != thread || thread->is_oop_safe(),\n+            \"current cannot touch oops after its GC barrier is detached.\");\n+  oop obj = thread->threadObj();\n+  return (obj == NULL) ? 0 : java_lang_Thread::thread_id(obj);\n@@ -1020,1 +1019,1 @@\n-  return dtrace_object_alloc(Thread::current(), o, o->size());\n+  return dtrace_object_alloc(JavaThread::current(), o, o->size());\n@@ -1023,1 +1022,1 @@\n-int SharedRuntime::dtrace_object_alloc(Thread* thread, oopDesc* o) {\n+int SharedRuntime::dtrace_object_alloc(JavaThread* thread, oopDesc* o) {\n@@ -1027,1 +1026,1 @@\n-int SharedRuntime::dtrace_object_alloc(Thread* thread, oopDesc* o, size_t size) {\n+int SharedRuntime::dtrace_object_alloc(JavaThread* thread, oopDesc* o, size_t size) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -281,2 +281,2 @@\n-  static int dtrace_object_alloc(Thread* thread, oopDesc* o);\n-  static int dtrace_object_alloc(Thread* thread, oopDesc* o, size_t size);\n+  static int dtrace_object_alloc(JavaThread* thread, oopDesc* o);\n+  static int dtrace_object_alloc(JavaThread* thread, oopDesc* o, size_t size);\n@@ -288,1 +288,1 @@\n-  static jlong get_java_tid(Thread* thread);\n+  static jlong get_java_tid(JavaThread* thread);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {\n+int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, JavaThread* thr) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1851,0 +1851,2 @@\n+  declare_c2_type(IsFiniteFNode, Node)                                    \\\n+  declare_c2_type(IsFiniteDNode, Node)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,0 +242,11 @@\n+const char* type2name(BasicType t) {\n+  if (t < ARRAY_SIZE(type2name_tab)) {\n+    return type2name_tab[t];\n+  } else if (t == T_ILLEGAL) {\n+    return \"*illegal*\";\n+  } else {\n+    fatal(\"invalid type %d\", t);\n+    return \"invalid type\";\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -800,4 +800,1 @@\n-inline const char* type2name(BasicType t) {\n-  assert((uint)t < T_CONFLICT + 1, \"invalid type\");\n-  return type2name_tab[t];\n-}\n+const char* type2name(BasicType t);\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n-     * See <a href=\"https:\/\/openjdk.java.net\/jeps\/421\">JEP 421<\/a> for\n+     * See <a href=\"https:\/\/openjdk.org\/jeps\/421\">JEP 421<\/a> for\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-                                         Class<?>[] checkedExceptions,\n@@ -82,1 +81,0 @@\n-                                         checkedExceptions,\n@@ -93,1 +91,0 @@\n-                                                   Class<?>[] checkedExceptions,\n@@ -101,1 +98,0 @@\n-                                              checkedExceptions,\n@@ -113,1 +109,0 @@\n-                                     Class<?>[] checkedExceptions,\n@@ -122,1 +117,0 @@\n-                     checkedExceptions,\n@@ -136,1 +130,0 @@\n-                                       Class<?>[] checkedExceptions,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorGenerator.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -123,7 +123,8 @@\n-serviceability\/sa\/ClhsdbCDSCore.java 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbPmap.java#core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbPstack.java#core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/TestJmapCore.java 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/TestJmapCoreMetaspace.java 8269982,8267433 macosx-aarch64,macosx-x64\n+serviceability\/sa\/ClhsdbCDSCore.java 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPmap.java#core 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPstack.java#core 8294316,8267433 macosx-x64\n+serviceability\/sa\/TestJmapCore.java 8294316,8267433 macosx-x64\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8294316,8267433 macosx-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"}]}