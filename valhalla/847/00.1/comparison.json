{"files":[{"patch":"@@ -113,1 +113,1 @@\n-    -XDenableValueTypes \\\n+    -XDenableValueTypes -XDenablePrimitiveClasses \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1182,0 +1182,8 @@\n+    \/\/ Skip scalarization for vector value objects (concrete vectors and payloads).\n+    load_klass(rdi, rax, rscratch1);\n+    movptr(rscratch1, rax);\n+    super_call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::skip_value_scalarization), rdi);\n+    testptr(rax, rax);\n+    movptr(rax, rscratch1);\n+    jcc(Assembler::notZero, skip);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -423,2 +423,2 @@\n-      int  field_off = field->offset_in_bytes();\n-      if (field_off == field_offset)\n+      int curr_field_offset = field->offset_in_bytes();\n+      if (curr_field_offset == field_offset)\n@@ -426,1 +426,1 @@\n-      if (field_off > field_offset)\n+      if (curr_field_offset > field_offset)\n@@ -429,0 +429,10 @@\n+      if (field->secondary_fields_count() > 1) {\n+        for (int j = 0; j < field->secondary_fields_count(); j++) {\n+          ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_fields()->at(j);\n+          int sec_field_offset = sec_field->offset_in_bytes();\n+          if (sec_field_offset == field_offset)\n+            return sec_field;\n+          if (sec_field_offset > field_offset)\n+            return NULL;\n+        }\n+      }\n@@ -535,0 +545,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -553,0 +564,7 @@\n+    if (fs.is_multifield()) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n+      ciMultiField* multifield_base = static_cast<ciMultiField*>(fields->last());\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      multifield_base->secondary_fields()->append(new (arena) ciField(&fd));\n+      continue;\n+    }\n@@ -569,1 +587,7 @@\n-        ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        ciField* field = NULL;\n+        if (flattened_field->is_multifield_base()) {\n+          field = new (arena) ciMultiField(flattened_field, this, offset, is_final);\n+          static_cast<ciMultiField*>(field)->add_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n+        } else {\n+          field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        }\n@@ -573,1 +597,8 @@\n-      ciField* field = new (arena) ciField(&fd);\n+      ciField* field = NULL;\n+      if (fs.is_multifield_base()) {\n+        field = new (arena) ciMultiField(&fd);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, fd.secondary_fields_count(fd.index()), 0, NULL);\n+        static_cast<ciMultiField*>(field)->add_secondary_fields(sec_fields);\n+      } else {\n+        field = new (arena) ciField(&fd);\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  friend class ciMultiField;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1022,0 +1022,1 @@\n+    _jdk_internal_vm_annotation_MultiField,\n@@ -1028,0 +1029,1 @@\n+  jbyte _multifield_arg;\n@@ -1054,0 +1056,3 @@\n+  void set_multifield_arg(jbyte arg) { _multifield_arg = arg; }\n+  jbyte multifield_arg() const { return _multifield_arg; }\n+\n@@ -1055,0 +1060,1 @@\n+  bool is_multifield_base() const { return has_annotation(_jdk_internal_vm_annotation_MultiField); }\n@@ -1194,0 +1200,3 @@\n+    b_tag_val = 'B',\n+    b_con_off = 7,\n+    b_size = 9,\n@@ -1240,0 +1249,9 @@\n+    } else if (AnnotationCollector::_jdk_internal_vm_annotation_MultiField == id) {\n+      \/\/ TODO: change those assertion into a conditional statement to process the value\n+      assert(count == 1, \"MultiField annotation must have at least one argument\");  \/\/ Is it true?\n+      assert(member == vmSymbols::value_name(), \"Must be\");\n+      assert(b_tag_val == *(abase + tag_off), \"Must be a byte value\");\n+      int arg_index = Bytes::get_Java_u2((address)abase + b_con_off);\n+      int multifield_arg = cp->int_at(arg_index);\n+      assert(((jbyte)multifield_arg) == multifield_arg, \"Must be\");\n+      coll->set_multifield_arg(multifield_arg);\n@@ -1559,3 +1577,9 @@\n-  u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                              u2,\n-                                              total_fields * (FieldInfo::field_slots + 1));\n+\n+  GrowableArray<FieldInfo>* temp_fieldinfo = new GrowableArray<FieldInfo>(total_fields);\n+  GrowableArray<u2>* temp_generic_signature = new GrowableArray<u2>(total_fields);\n+  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0); \/\/ could be allocated lazily\n+  FieldInfo fi;\n+  FieldInfo* f = &fi;\n+  GrowableArray<AnnotationArray*>* fields_annotations = NULL;\n+  GrowableArray<AnnotationArray*>* fields_type_annotations = NULL;\n+\n@@ -1565,1 +1589,2 @@\n-  int num_generic_signature = 0;\n+  int inj_multifields = 0;\n+  int field_index = -1;\n@@ -1568,0 +1593,1 @@\n+    field_index++;\n@@ -1612,4 +1638,2 @@\n-        if (_fields_annotations == NULL) {\n-          _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, length, NULL,\n-                                             CHECK);\n+        if (fields_annotations == NULL) {\n+          fields_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1617,1 +1641,2 @@\n-        _fields_annotations->at_put(n, parsed_annotations.field_annotations());\n+\n+        fields_annotations->at_put_grow(field_index, parsed_annotations.field_annotations(), NULL);\n@@ -1621,6 +1646,2 @@\n-        if (_fields_type_annotations == NULL) {\n-          _fields_type_annotations =\n-            MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n-                                                         length,\n-                                                         NULL,\n-                                                         CHECK);\n+        if (fields_type_annotations == NULL) {\n+          fields_type_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1628,1 +1649,1 @@\n-        _fields_type_annotations->at_put(n, parsed_annotations.field_type_annotations());\n+        fields_type_annotations->at_put_grow(field_index, parsed_annotations.field_type_annotations(), NULL);\n@@ -1637,1 +1658,1 @@\n-        fa[generic_signature_slot] = generic_signature_index;\n+        temp_generic_signature->append(generic_signature_index);\n@@ -1639,1 +1660,0 @@\n-        num_generic_signature ++;\n@@ -1643,2 +1663,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, n);\n-    field->initialize(access_flags.as_short(),\n+    f->initialize(access_flags.as_short(),\n@@ -1648,0 +1667,3 @@\n+    int base_idx = temp_fieldinfo->append(fi);\n+    assert(base_idx == field_index, \"Must be\");\n+    FieldInfo* const field = temp_fieldinfo->adr_at(field_index);\n@@ -1660,0 +1682,33 @@\n+\n+    if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {\n+      field->set_multifield_base(true);\n+      char* base_name = cp->symbol_at(name_index)->as_C_string();\n+      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {\n+        field_index++;\n+        stringStream st;\n+        st.print(\"%s\", base_name);\n+        st.print(\"#\");\n+        st.print(\"%d\", i);\n+        Symbol* inj_name = SymbolTable::new_symbol(st.as_string());\n+        MultiFieldInfo mfi(inj_name, base_idx, i);\n+        int mfi_idx = temp_multifield_info->append(mfi);\n+        f->initialize(access_flags.as_short(),\n+                      mfi_idx,\n+                      signature_index,\n+                      constantvalue_index);\n+        int inj_idx = temp_fieldinfo->append(fi);\n+        assert(inj_idx == field_index, \"Must be\");\n+        FieldInfo* const field = temp_fieldinfo->adr_at(inj_idx);\n+        const BasicType type = cp->basic_type_for_signature_at(signature_index);\n+        \/\/ Update FieldAllocationCount for this kind of field\n+        fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n+        field->set_multifield(true);\n+        if (fields_annotations != NULL && fields_annotations->at(base_idx) != NULL) {\n+          fields_annotations->at_put_grow(field_index, fields_annotations->at(base_idx));\n+        }\n+        if (fields_type_annotations != NULL && fields_type_annotations->at(base_idx) != NULL) {\n+          fields_type_annotations->at_put_grow(field_index, fields_type_annotations->at(base_idx));\n+        }\n+        inj_multifields++;\n+      }\n+    }\n@@ -1662,1 +1717,2 @@\n-  int index = length;\n+  *java_fields_count_ptr = *java_fields_count_ptr + inj_multifields;\n+  int index = length + inj_multifields;\n@@ -1671,1 +1727,1 @@\n-          const FieldInfo* const f = FieldInfo::from_field_array(fa, i);\n+          const FieldInfo* const f = temp_fieldinfo->adr_at(i);\n@@ -1680,1 +1736,0 @@\n-          \/\/ These will be removed from the field array at the end\n@@ -1686,2 +1741,1 @@\n-      FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n+      f->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n@@ -1691,0 +1745,3 @@\n+      field_index++;\n+      int inj_idx = temp_fieldinfo->append(fi);\n+      assert(inj_idx == field_index, \"Must be\");\n@@ -1701,2 +1758,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n+    f->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n@@ -1706,0 +1762,3 @@\n+    field_index++;\n+    int inj_idx = temp_fieldinfo->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1713,2 +1772,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL,\n+    f->initialize(JVM_ACC_FIELD_INTERNAL,\n@@ -1718,0 +1776,3 @@\n+    field_index++;\n+    int inj_idx = temp_fieldinfo->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1728,0 +1789,2 @@\n+  assert(index == field_index + 1, \"Must be\");\n+  assert(temp_fieldinfo->length() == field_index + 1, \"Must be\");\n@@ -1731,1 +1794,1 @@\n-                                   index * FieldInfo::field_slots + num_generic_signature,\n+                                   temp_fieldinfo->length() * FieldInfo::field_slots + temp_generic_signature->length(),\n@@ -1739,2 +1802,5 @@\n-    for (; i < index * FieldInfo::field_slots; i++) {\n-      _fields->at_put(i, fa[i]);\n+    for (i = 0; i < index; i++) {\n+      u2* adr = (u2*)temp_fieldinfo->adr_at(i);\n+      for (int j = 0; j < FieldInfo::field_slots; j++) {\n+        _fields->at_put(i * FieldInfo::field_slots + j, adr[j]);\n+      }\n@@ -1742,3 +1808,3 @@\n-    for (int j = total_fields * FieldInfo::field_slots;\n-         j < generic_signature_slot; j++) {\n-      _fields->at_put(i++, fa[j]);\n+    i = index * FieldInfo::field_slots;\n+    for (int j = 0; j < temp_generic_signature->length(); j++) {\n+      _fields->at_put(i++, temp_generic_signature->at(j));\n@@ -1746,0 +1812,1 @@\n+\n@@ -1749,0 +1816,25 @@\n+  if (temp_multifield_info->length() > 0) {\n+    _multifield_info = MetadataFactory::new_array<MultiFieldInfo>(_loader_data, temp_multifield_info->length(), CHECK);\n+    for (int i = 0; i < temp_multifield_info->length(); i++) {\n+      _multifield_info->at_put(i, temp_multifield_info->at(i));\n+    }\n+  }\n+\n+  if (fields_annotations != NULL) {\n+    _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, temp_fieldinfo->length(), NULL,\n+                                             CHECK);\n+    for (int i = 0; i < fields_annotations->length(); i++) {\n+      _fields_annotations->at_put(i, fields_annotations->at(i));\n+    }\n+  }\n+\n+  if (fields_type_annotations != NULL) {\n+     _fields_type_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, temp_fieldinfo->length(), NULL,\n+                                             CHECK);\n+    for (int i = 0; i < fields_type_annotations->length(); i++) {\n+      _fields_type_annotations->at_put(i, fields_type_annotations->at(i));\n+    }\n+  }\n+\n@@ -1760,1 +1852,1 @@\n-      for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+      for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n@@ -2135,0 +2227,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_MultiField_signature): {\n+      if (_location != _in_field) break;  \/\/ only allow for fields\n+      if (!privileged)            break;  \/\/ honor privileges\n+      return _jdk_internal_vm_annotation_MultiField;\n+    }\n@@ -3311,0 +3408,1 @@\n+    const Symbol* outer_class_name = NULL;\n@@ -3312,1 +3410,1 @@\n-      const Symbol* const outer_class_name = cp->klass_name_at(outer_class_info_index);\n+      outer_class_name = cp->klass_name_at(outer_class_info_index);\n@@ -3356,1 +3454,1 @@\n-    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n+    verify_legal_class_modifiers(flags, name, outer_class_name, false, CHECK_0);\n@@ -4200,0 +4298,1 @@\n+  this_klass->set_multifield_info(_multifield_info);\n@@ -4784,0 +4883,17 @@\n+\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n+\/\/ an explict JVM flag EnablePrimitiveClasses.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const {\n+  if (outer_class &&\n+      inner_class &&\n+      (vmSymbols::jdk_internal_vm_vector_VectorSupport() == outer_class ||\n+       vmSymbols::jdk_internal_vm_vector_VectorPayloadMF() == outer_class)) {\n+    if (strstr(inner_class, \"VectorPayloadMF64\")  ||\n+        strstr(inner_class, \"VectorPayloadMF128\") ||\n+        strstr(inner_class, \"VectorPayloadMF256\") ||\n+        strstr(inner_class, \"VectorPayloadMF512\")) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -4786,1 +4902,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, const Symbol* outer_class, bool is_Object, TRAPS) const {\n@@ -4814,1 +4930,1 @@\n-  if (is_primitive_class && !EnablePrimitiveClasses) {\n+  if (is_primitive_class && !is_jdk_internal_class(outer_class, name) && !EnablePrimitiveClasses) {\n@@ -5705,0 +5821,1 @@\n+  assert(NULL == _multifield_info, \"invariant\");\n@@ -5850,1 +5967,1 @@\n-  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -5984,0 +6101,1 @@\n+  _multifield_info(NULL),\n@@ -6070,0 +6188,1 @@\n+  _multifield_info = NULL;\n@@ -6083,0 +6202,4 @@\n+  if (_multifield_info != NULL) {\n+    MetadataFactory::free_array<MultiFieldInfo>(_loader_data, _multifield_info);\n+  }\n+\n@@ -6228,1 +6351,0 @@\n-  verify_legal_class_modifiers(flags, NULL, is_java_lang_Object, CHECK);\n@@ -6329,0 +6451,3 @@\n+  const Symbol* super_klass_name = _super_class_index ? cp->klass_name_at(_super_class_index) : NULL;\n+  verify_legal_class_modifiers(flags, _class_name->as_C_string(), super_klass_name, is_java_lang_Object, CHECK);\n+\n@@ -6424,0 +6549,12 @@\n+bool ClassFileParser::is_jdk_internal_class(const Klass* cls) {\n+  while(cls) {\n+    const Symbol* cls_name = cls->name();\n+    if(cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayload() ||\n+       cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayloadMF()) {\n+      return true;\n+    }\n+    cls = cls->super();\n+   }\n+   return false;\n+}\n+\n@@ -6571,1 +6708,1 @@\n-  if (EnablePrimitiveClasses) {\n+  if (EnablePrimitiveClasses || is_jdk_internal_class(_super_klass)) {\n@@ -6576,1 +6713,1 @@\n-    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n@@ -6599,1 +6736,1 @@\n-      _field_info, _inline_type_field_klasses);\n+      _field_info, _inline_type_field_klasses, _multifield_info);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":182,"deletions":45,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -501,1 +502,1 @@\n-  void verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, const char* name, const Symbol* out_class, bool is_Object, TRAPS) const;\n@@ -521,0 +522,3 @@\n+  bool is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const;\n+  bool is_jdk_internal_class(const Klass* cls);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5086,1 +5086,5 @@\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  \/\/FIXME: VectorPayload class no longer holds the Object payload.\n+  \/\/Multi-field based payloads have been moved to leaf level\n+  \/\/concrete classes. Offset recorded here is used for object\n+  \/\/re-construction during de-opt.\n+  \/\/ VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1271,1 +1271,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-  jint int_at(int which) {\n+  jint int_at(int which) const {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -240,0 +241,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -334,1 +336,1 @@\n-  return InlineTypePassFieldsAsArgs;\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypePassFieldsAsArgs;\n@@ -339,1 +341,1 @@\n-  return InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,0 +167,8 @@\n+  FieldInfo* MultiFieldInfo::base_field_info(InstanceKlass* ik) {\n+    return ik->field(_base_index);\n+  }\n+\n+  void MultiFieldInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_name);\n+  }\n+\n@@ -544,0 +552,1 @@\n+  _multifield_info(NULL),\n@@ -749,0 +758,4 @@\n+  if (_multifield_info != NULL && !_multifield_info->is_shared()) {\n+    MetadataFactory::free_array<MultiFieldInfo>(loader_data, _multifield_info);\n+  }\n+\n@@ -2640,0 +2653,3 @@\n+  if(_multifield_info != NULL) {\n+    it->push(&_multifield_info);\n+  }\n@@ -2690,1 +2706,1 @@\n-    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -136,0 +136,16 @@\n+class MultiFieldInfo : public MetaspaceObj {\n+ private:\n+  Symbol* _name;\n+  u2 _base_index;\n+  jbyte _multifield_index;\n+ public:\n+  MultiFieldInfo() : _name(NULL), _base_index(0), _multifield_index(-1) {}\n+  MultiFieldInfo(Symbol* name, u2 base, jbyte index) : _name(name), _base_index(base), _multifield_index(index) {}\n+  Symbol* name() const { return _name; }\n+  u2 base_index() const { return _base_index; }\n+  jbyte multifield_index() const { return _multifield_index; }\n+  FieldInfo* base_field_info(InstanceKlass* ik);\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  MetaspaceObj::Type type() const { return MultiFieldInfoType; }\n+};\n+\n@@ -226,0 +242,3 @@\n+  \/\/ Array containing meta-data generated for multifields\n+  Array<MultiFieldInfo>* _multifield_info;\n+\n@@ -449,0 +468,1 @@\n+  friend class MultiFieldInfo;\n@@ -454,1 +474,1 @@\n-  Symbol* field_name        (int index) const { return field(index)->name(constants()); }\n+  Symbol* field_name        (int index) const { return field(index)->name(multifield_info(), constants()); }\n@@ -469,0 +489,11 @@\n+  Array<MultiFieldInfo>* multifield_info() const { return _multifield_info; }\n+\n+  MultiFieldInfo multifield_info(int i) const {\n+    guarantee(_multifield_info != NULL, \"Just checking\");\n+    return _multifield_info->at(i);\n+  }\n+  void set_multifield_info(Array<MultiFieldInfo>* array) {\n+    assert(_multifield_info == NULL, \"Must be initialized only once\");\n+    _multifield_info = array;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -793,1 +793,3 @@\n-    if (vt != NULL) {\n+    \/\/ Upfront buffering for VectorBox may cause problems in sweeping allocation\n+    \/\/ graph pallets if boxes are removed during unbox-box optimization.\n+    if (vt != NULL && !result->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2558,1 +2558,1 @@\n-    progress = merge_through_phi(this, phase->is_IterGVN());\n+    progress = merge_through_phi(this, phase);\n@@ -2592,1 +2592,1 @@\n-      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+      } else if (def->is_InlineType()) { \/\/ leaf\n@@ -2609,1 +2609,2 @@\n-Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseGVN *phase) {\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -2652,3 +2653,7 @@\n-  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n-  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n-  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n+  const Type*        ptype = cached_vbox->field_value(0)->bottom_type();\n+\n+  Node* new_payload_phi = clone_through_phi(root_phi, ptype, InlineTypeNode::get_Values_idx(), igvn);\n+  Node* new_vector_phi = clone_through_phi(new_payload_phi, vtype, InlineTypeNode::get_Values_idx(), igvn);\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, InlineTypeNode::get_Oop_idx(), igvn);\n+\n+  return VectorBoxNode::make_box_node(*igvn, phase->C, new_vbox_phi, new_vector_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2744,10 +2744,0 @@\n-  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n-  if (EnableVectorSupport && has_vbox_nodes()) {\n-    TracePhase tp(\"\", &timers[_t_vector]);\n-    PhaseVector pv(igvn);\n-    pv.optimize_vector_boxes();\n-\n-    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n-  }\n-  assert(!has_vbox_nodes(), \"sanity\");\n-\n@@ -2771,0 +2761,13 @@\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n+\n+  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n+  if (EnableVectorSupport && has_vbox_nodes()) {\n+    TracePhase tp(\"\", &timers[_t_vector]);\n+    PhaseVector pv(igvn);\n+    pv.optimize_vector_boxes();\n+\n+    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n+  }\n+  assert(!has_vbox_nodes(), \"sanity\");\n+\n@@ -2775,3 +2778,0 @@\n-  \/\/ Process inline type nodes now that all inlining is over\n-  process_inline_types(igvn);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1070,1 +1070,1 @@\n-      int      size  = field->type()->size();\n+      int size = InlineTypeNode::stack_size_for_field(field);\n@@ -1112,1 +1112,1 @@\n-    int      size  = field->type()->size();\n+    int size = InlineTypeNode::stack_size_for_field(field);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,37 @@\n+#include \"opto\/vectornode.hpp\"\n+\n+int  InlineTypeNode::stack_size_for_field(ciField* field) {\n+  return field->is_multifield_base()\n+             ? (InlineTypeNode::is_multifield_scalarized(field)\n+                    ? field->type()->elem_word_count()\n+                    : 1)\n+             : field->type()->size();\n+}\n+\n+bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n+  int field_count = field->secondary_fields_count();\n+  BasicType bt = field->type()->basic_type();\n+  if (field_count > 1 &&\n+      (!Matcher::match_rule_supported_vector(Op_LoadVector, field_count, bt) ||\n+       !Matcher::match_rule_supported_vector(Op_StoreVector, field_count, bt) ||\n+       !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), field_count, bt))) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void InlineTypeNode::expand_input_edges(ciInlineKlass* vk) {\n+  \/\/ We generally perform three operations on multi-field bundle, load its contents into vector,\n+  \/\/ store the contents of vector to multi-field bundle or broadcast a value into a vector equivalent\n+  \/\/ in size to a multi-field bundle. If any of these operations are not supported by target platform\n+  \/\/ scalarize the multi-fields into individual fields.\n+  for (int i = 0; i < vk->nof_declared_nonstatic_fields(); i++) {\n+    ciField* field = vk->declared_nonstatic_field_at(i);\n+    if (is_multifield_scalarized(field)) {\n+      int field_count = field->secondary_fields_count();\n+      while(--field_count) {\n+        add_req(NULL);\n+      }\n+    }\n+  }\n+}\n@@ -82,0 +119,4 @@\n+      if (vt->is_multifield_base(i) &&\n+          Matcher::vector_size_supported(type->basic_type(), vt->secondary_fields_count(i))) {\n+        t = TypeVect::make(t, vt->secondary_fields_count(i));\n+      }\n@@ -241,0 +282,15 @@\n+int InlineTypeNode::secondary_fields_count(uint index) const {\n+  assert(is_multifield_base(index), \"non-multifield field at index\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->secondary_fields_count();\n+}\n+\n+bool InlineTypeNode::is_multifield(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield();\n+}\n+\n+bool InlineTypeNode::is_multifield_base(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield_base();\n+}\n+\n@@ -275,0 +331,4 @@\n+\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(get_oop(), igvn);\n+  sfpt->add_req(igvn->intcon(alloc && alloc->_larval ? 1 : 0));\n+\n@@ -410,1 +470,1 @@\n-    int offset = holder_offset + field_offset(i);\n+    int offset = holder_offset + field_offset(i);\n@@ -439,0 +499,6 @@\n+        BasicType bt = con_type->basic_type();\n+        int vec_len = field->secondary_fields_count();\n+        if (field->is_multifield_base() &&\n+          Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+          value = kit->gvn().transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field->type()), false));\n+        }\n@@ -441,0 +507,1 @@\n+        BasicType bt = type2field[ft->basic_type()];\n@@ -443,1 +510,0 @@\n-        BasicType bt = type2field[ft->basic_type()];\n@@ -446,1 +512,7 @@\n-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+        int bundle_size = ft->bundle_size();\n+        bool load_bundle = bundle_size > 1 ? Matcher::match_rule_supported_vector(Op_LoadVector, bundle_size, bt): false;\n+        if (load_bundle) {\n+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, bundle_size, bt));\n+        } else {\n+          value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+        }\n@@ -477,0 +549,1 @@\n+  int field_idx = 0;\n@@ -478,1 +551,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -481,0 +553,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -485,1 +558,3 @@\n-      \/\/ Store field value to memory\n+      int vec_len = ft->bundle_size();\n+      BasicType bt = type2field[ft->basic_type()];\n+      const Type* val_type = Type::get_const_type(ft);\n@@ -488,4 +563,8 @@\n-      BasicType bt = type2field[ft->basic_type()];\n-      const Type* val_type = Type::get_const_type(ft);\n-      bool is_array = (kit->gvn().type(base)->isa_aryptr() != NULL);\n-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+      if (value->bottom_type()->isa_vect()) {\n+        assert(value->bottom_type()->is_vect()->length() == (uint)vec_len, \"\");\n+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));\n+        kit->set_memory(store, adr_type);\n+      } else {\n+        bool is_array = (kit->gvn().type(base)->isa_aryptr() != NULL);\n+        kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+      }\n@@ -598,0 +677,1 @@\n+  \/\/ Primitive objects are always null free.\n@@ -684,0 +764,2 @@\n+  \/\/ An InlineTypeNode in larval state is up for updation and\n+  \/\/ should not be replaced by precomputed default oops.\n@@ -693,1 +775,1 @@\n-  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {\n+  if (oop->isa_InlineType() && !oop->isa_VectorBox() && !phase->type(oop)->maybe_null()) {\n@@ -754,0 +836,11 @@\n+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type) {\n+  BasicType bt = field_type->basic_type();\n+  Node* value = gvn.zerocon(field_type->basic_type());\n+  int vec_len = field_type->bundle_size();\n+  if (is_java_primitive(bt) &&\n+      Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n+  }\n+  return value;\n+}\n+\n@@ -768,1 +861,1 @@\n-    Node* value = gvn.zerocon(ft->basic_type());\n+    Node* value = default_value(gvn, ft);\n@@ -805,1 +898,2 @@\n-    if (!gvn->type(value)->is_zero_type()) {\n+    if (!gvn->type(value)->is_zero_type() &&\n+        !VectorNode::is_all_zeros_vector(value)) {\n@@ -1111,1 +1205,1 @@\n-    ciType* type = field_type(i);\n+    ciType* type = field_type(i);\n@@ -1119,1 +1213,21 @@\n-      if (multi->is_Start()) {\n+      if (type->bundle_size() > 1) {\n+        Node* not_null_oop =  NULL;\n+        ciInlineKlass* ik = inline_klass();\n+        if (multi->is_Call()) {\n+          if (in) {\n+            not_null_oop = multi->as_Call()->in(base_input);\n+          } else {\n+            not_null_oop =  multi->as_Call()->proj_out(TypeFunc::Parms);\n+          }\n+          assert(not_null_oop->bottom_type()->isa_instptr(), \"\");\n+          GrowableArray<ciType*> visited;\n+          visited.push(ik);\n+          load(kit, not_null_oop, not_null_oop, ik, visited, \/* holder_offset *\/ 0);\n+          parm = field_value(i);\n+        } else if (multi->is_Start()) {\n+          assert(in, \"return from start?\");\n+          parm = default_value(gvn, type);\n+        } else {\n+          assert(false, \"unhandled case\");\n+        }\n+      } else if (multi->is_Start()) {\n@@ -1147,1 +1261,1 @@\n-      base_input += type->size();\n+      base_input += (type->size() \/ type->bundle_size());\n@@ -1215,1 +1329,1 @@\n-    Node* value = gvn.zerocon(ft->basic_type());\n+    Node* value = default_value(gvn, ft);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":130,"deletions":16,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -41,0 +42,1 @@\n+    expand_input_edges(vk);\n@@ -53,2 +55,1 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+  void expand_input_edges(ciInlineKlass * vk);\n@@ -80,0 +81,3 @@\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+\n@@ -93,0 +97,4 @@\n+  static int stack_size_for_field(ciField* field);\n+\n+  static bool is_multifield_scalarized(ciField* field);\n+\n@@ -96,0 +104,2 @@\n+  static Node* default_value(PhaseGVN& gvn, ciType* field_type);\n+\n@@ -110,0 +120,4 @@\n+  \/\/ Get indices for inputs.\n+  static int   get_Oop_idx()    { return InlineTypeNode::Oop; }\n+  static int   get_Values_idx() { return InlineTypeNode::Values; }\n+\n@@ -111,2 +125,4 @@\n-  uint          field_count() const { return req() - Values; }\n-  Node*         field_value(uint index) const;\n+  virtual uint  field_count() const { return req() - Values; }\n+  virtual Node* field_value(uint index) const;\n+  uint          field_index(int offset) const;\n+\n@@ -114,2 +130,3 @@\n-  void      set_field_value(uint index, Node* value);\n-  void      set_field_value_by_offset(int offset, Node* value);\n+  void          set_field_value(uint index, Node* value);\n+\n+  void          set_field_value_by_offset(int offset, Node* value);\n@@ -117,1 +134,3 @@\n-  uint          field_index(int offset) const;\n+  bool          is_multifield(uint index) const;\n+  bool          is_multifield_base(uint index) const;\n+  int           secondary_fields_count(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2280,1 +2280,1 @@\n- }\n+  }\n@@ -2320,0 +2320,2 @@\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(base, &_gvn);\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n@@ -2329,1 +2331,4 @@\n-        if (field != NULL) {\n+        \/\/ Skip over direct field access for VectorPayloadMF* class instancs since\n+        \/\/ multifield is loaded into vector, alternatively we can create a lane\n+        \/\/ extraction logic.\n+        if (field != NULL && !VectorSupport::is_vector_payload_mf(vk->get_InlineKlass())) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+class VectorBoxNode;\n@@ -722,0 +723,1 @@\n+        DEFINE_CLASS_ID(VectorBox, InlineType, 0)\n@@ -956,0 +958,1 @@\n+  DEFINE_CLASS_QUERY(VectorBox)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+      ScopeValue* is_larval = NULL;\n@@ -819,0 +820,6 @@\n+\n+        Node* larval_node = sfpt->in(first_ind++);\n+        assert(larval_node != NULL && larval_node->is_Con(), \"is_larval node not found\");\n+\n+        const TypeInt* larval_type = larval_node->bottom_type()->is_int();\n+        is_larval = new ConstantIntValue(larval_type->get_con());\n@@ -821,1 +828,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init);\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init, is_larval);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -919,1 +919,5 @@\n-    if (tf()->returns_inline_type_as_fields()) {\n+    if (res->isa_InlineType() && VectorSupport::skip_value_scalarization(res->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+      InlineTypeNode* vt = res->as_InlineType();\n+      assert(vt->get_is_buffered(), \"\");\n+      ret->add_req(vt->get_oop());\n+    } else if (tf()->returns_inline_type_as_fields()) {\n@@ -1132,1 +1136,1 @@\n-  \/\/ record exit from a method if compiled while Dtrace is turned on.\n+  \/\/ record exit from a method if compiled while Dtrace is returned on.\n@@ -2351,1 +2355,8 @@\n-      if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n+      if (VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+        \/\/ Buffer the vector return types, for regular inline object caller expects\n+        \/\/ scalarized fields to be passed back.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(1);\n+        value = value->as_InlineType()->buffer(this);\n+      } else if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -342,1 +343,1 @@\n-  int holder_depth = field->type()->size();\n+  int holder_depth = field->type()->size() \/ field->type()->bundle_size();\n@@ -359,1 +360,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = 1 + field->type()->size() \/ field->type()->bundle_size();\n@@ -368,1 +369,13 @@\n-  new_vt->set_field_value_by_offset(field->offset(), val);\n+\n+  BasicType bt = field->type()->basic_type();\n+  int vec_len = field->secondary_fields_count();\n+  bool scalarize_fields = !is_java_primitive(bt) || !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  if (scalarize_fields) {\n+    for(int i = 0; i < vec_len; i++) {\n+      new_vt->set_field_value_by_offset(field->offset() + i * type2aelembytes(bt), val);\n+    }\n+  } else {\n+    val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n+    new_vt->set_field_value_by_offset(field->offset(), val);\n+  }\n+\n@@ -372,1 +385,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = InlineTypeNode::stack_size_for_field(field);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,2 +34,5 @@\n-#ifdef ASSERT\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n+}\n+\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n@@ -39,0 +42,5 @@\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+#ifdef ASSERT\n@@ -62,8 +70,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -159,1 +159,1 @@\n-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);\n+  Node* vbox = VectorBoxNode::make_box_node(gvn(), C, ret, vector, vbox_type, vt);\n@@ -172,0 +172,4 @@\n+  \/\/ TODO[valhalla] Limiting support to only vectors cases untill mask and shuffle becomes inline types.\n+  if (!is_vector(vbox_type->instance_klass())) {\n+    return NULL;\n+  }\n@@ -793,0 +797,3 @@\n+  if (shuffle_vec == NULL) {\n+    return false;\n+  }\n@@ -856,0 +863,5 @@\n+  bool is_shuffle = is_vector_shuffle(vbox_klass);\n+  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n+  if (is_mask || is_shuffle) {\n+    return false;\n+  }\n@@ -997,0 +1009,5 @@\n+  bool is_shuffle = is_vector_shuffle(vbox_klass);\n+  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n+  if (is_mask || is_shuffle) {\n+    return false;\n+  }\n@@ -1785,0 +1802,2 @@\n+\n+\n@@ -1790,1 +1809,4 @@\n-\n+  \/\/ TODO[valhalla] Limiting support to only vectors cases untill mask and shuffle becomes inline types.\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    return false;\n+  }\n@@ -1972,1 +1994,2 @@\n-  if (is_masked_op && mask == NULL) {\n+  \/\/ TODO[valhalla] Preveting intrinsification untill mask becomes inline type.\n+  if (true || is_masked_op && mask == NULL) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1668,1 +1669,1 @@\n-class VectorBoxNode : public Node {\n+class VectorBoxNode : public InlineTypeNode {\n@@ -1670,12 +1671,31 @@\n-  const TypeInstPtr* const _box_type;\n-  const TypeVect*    const _vec_type;\n- public:\n-  enum {\n-     Box   = 1,\n-     Value = 2\n-  };\n-  VectorBoxNode(Compile* C, Node* box, Node* val,\n-                const TypeInstPtr* box_type, const TypeVect* vt)\n-    : Node(NULL, box, val), _box_type(box_type), _vec_type(vt) {\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n+  const TypeInstPtr* _box_type;\n+  const TypeVect*    _vec_type;\n+\n+ public:\n+  void set_box_type(const TypeInstPtr* box_type) { _box_type = box_type; }\n+  void set_vec_type(const TypeVect* vec_type) { _vec_type = vec_type; }\n+\n+  VectorBoxNode(Compile* C, ciInlineKlass* vk, Node* oop, const TypeInstPtr* box_type, const TypeVect* vt, bool null_free) :\n+    InlineTypeNode(vk, oop, null_free) {\n+      init_flags(Flag_is_macro);\n+      init_class_id(Class_VectorBox);\n+      set_vec_type(vt);\n+      set_box_type(box_type);\n+      C->add_macro_node(this);\n+  }\n+\n+  static VectorBoxNode* make_box_node(PhaseGVN& gvn, Compile* C, Node* box, Node* val,\n+                                      const TypeInstPtr* box_type, const TypeVect* vt) {\n+    ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+    ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+\n+    Node* payload_oop = payload->is_initialized() ? default_oop(gvn, payload) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+    Node* payload_value = InlineTypeNode::make_uninitialized(gvn, payload, true);\n+    payload_value->as_InlineType()->set_field_value(0, val);\n+    payload_value = gvn.transform(payload_value);\n+\n+    VectorBoxNode* box_node = new VectorBoxNode(C, vk, box, box_type, vt, false);\n+    box_node->set_field_value(0, payload_value);\n+    box_node->set_is_init(gvn);\n+\n+    return box_node;\n@@ -1687,0 +1707,5 @@\n+  Node*  get_vec() {\n+    assert(field_value(0)->is_InlineType(), \"\");\n+    return field_value(0)->as_InlineType()->field_value(0);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2346,0 +2346,4 @@\n+bool Arguments::enable_valhalla(const char* prop_value) {\n+  return strstr(\"jdk.incubator.vector\", prop_value);\n+}\n+\n@@ -2453,0 +2457,3 @@\n+      if (enable_valhalla(tail)) {\n+        EnablePrimitiveClasses = true;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -429,0 +429,2 @@\n+  static bool enable_valhalla(const char* prop_value);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1146,0 +1146,2 @@\n+        } else if (EnableVectorSupport && VectorSupport::is_vector_payload_mf(ik)) {\n+          obj = VectorSupport::allocate_vector_payload(ik, fr, reg_map, sv, THREAD);\n@@ -1546,1 +1548,1 @@\n-    if (EnableVectorSupport && VectorSupport::is_vector(k)) {\n+    if (EnableVectorSupport && (VectorSupport::is_vector(k) || VectorSupport::is_vector_payload_mf(k))) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-  guarantee(f->name_index() != 0 && f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n+  \/\/ assert to be extended to allow multifield names\n+  guarantee(\/*f->name_index() != 0 &&*\/ f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -640,0 +641,3 @@\n+JRT_LEAF(jint, SharedRuntime::skip_value_scalarization(InlineKlass* klass))\n+  return (jint)VectorSupport::skip_value_scalarization(klass);\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+  static int skip_value_scalarization(InlineKlass* klass);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,2 @@\n+import jdk.internal.vm.annotation.MultiField;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -31,0 +34,1 @@\n+\n@@ -32,0 +36,1 @@\n+import java.lang.reflect.*;\n@@ -151,1 +156,1 @@\n-    public static class VectorSpecies<E> {}\n+    public static class VectorSpecies<E> { }\n@@ -156,10 +161,2 @@\n-    public static class VectorPayload {\n-        private final Object payload; \/\/ array of primitives\n-\n-        public VectorPayload(Object payload) {\n-            this.payload = payload;\n-        }\n-\n-        protected final Object getPayload() {\n-            return VectorSupport.maybeRebox(this).payload;\n-        }\n+    public abstract static class VectorPayload {\n+        protected abstract Object getPayload();\n@@ -168,8 +165,1 @@\n-    \/**\n-     * @hidden\n-     *\/\n-    public static class Vector<E> extends VectorPayload {\n-        public Vector(Object payload) {\n-            super(payload);\n-        }\n-    }\n+    public static abstract class Vector<E> extends VectorPayload { }\n@@ -181,0 +171,5 @@\n+        private final Object payload; \/\/ array of primitives\n+\n+        protected final Object getPayload() {\n+            return VectorSupport.maybeRebox(this).payload;\n+        }\n@@ -182,1 +177,1 @@\n-            super(payload);\n+            this.payload = payload;\n@@ -185,0 +180,1 @@\n+\n@@ -189,0 +185,5 @@\n+        private final Object payload; \/\/ array of primitives\n+\n+        protected final Object getPayload() {\n+            return VectorSupport.maybeRebox(this).payload;\n+        }\n@@ -190,1 +191,60 @@\n-            super(payload);\n+            this.payload = payload;\n+        }\n+    }\n+\n+    public abstract static class VectorPayloadMF {\n+        public abstract long multiFieldOffset();\n+\n+        @ForceInline\n+        private static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n+            if (elemType == byte.class) {\n+                switch(length) {\n+                    case  8: return new VectorPayloadMF64B();\n+                    case 16: return new VectorPayloadMF128B();\n+                    case 32: return new VectorPayloadMF256B();\n+                    case 64: return new VectorPayloadMF512B();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == short.class) {\n+                switch(length) {\n+                    case  4: return new VectorPayloadMF64S();\n+                    case  8: return new VectorPayloadMF128S();\n+                    case 16: return new VectorPayloadMF256S();\n+                    case 32: return new VectorPayloadMF512S();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == int.class) {\n+                switch(length) {\n+                    case  2: return new VectorPayloadMF64I();\n+                    case  4: return new VectorPayloadMF128I();\n+                    case  8: return new VectorPayloadMF256I();\n+                    case 16: return new VectorPayloadMF512I();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == long.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF64L();\n+                    case  2: return new VectorPayloadMF128L();\n+                    case  4: return new VectorPayloadMF256L();\n+                    case  8: return new VectorPayloadMF512L();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == float.class) {\n+                switch(length) {\n+                    case  2: return new VectorPayloadMF64F();\n+                    case  4: return new VectorPayloadMF128F();\n+                    case  8: return new VectorPayloadMF256F();\n+                    case 16: return new VectorPayloadMF512F();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else {\n+                assert elemType == double.class;\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF64D();\n+                    case  2: return new VectorPayloadMF128D();\n+                    case  4: return new VectorPayloadMF256D();\n+                    case  8: return new VectorPayloadMF512D();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            }\n+            return null;\n@@ -192,0 +252,156 @@\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstance(Class<?> elemType, int length) {\n+            return newInstanceFactory(elemType, length);\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(byte.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putByte(obj, start_offset + i * Byte.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(short.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putShort(obj, start_offset + i * Short.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(int.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putInt(obj, start_offset + i * Integer.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(long.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putLong(obj, start_offset + i * Long.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(float.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putFloat(obj, start_offset + i * Float.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(double.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putDouble(obj, start_offset + i * Double.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public int length(int elemSize) {\n+            try {\n+                var field = this.getClass().getDeclaredField(\"mfield\");\n+                var msanno = field.getAnnotationsByType(MultiField.class);\n+\n+                Objects.nonNull(msanno);\n+\n+                assert msanno.length == 1;\n+                return msanno[0].value() \/ elemSize;\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1;\n+        }\n+\n+        public static long multiFieldOffset(Class<? extends VectorPayloadMF> cls) {\n+            try {\n+                var field = cls.getDeclaredField(\"mfield\");\n+                return Unsafe.getUnsafe().objectFieldOffset(field);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1L;\n+        }\n+    }\n+\n+    public primitive static class VectorPayloadMF64B extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128B extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256B extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512B extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64S extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128S extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n@@ -194,0 +410,161 @@\n+    public primitive static class VectorPayloadMF256S extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512S extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64I extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128I extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256I extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512I extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64L extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128L extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256L extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512L extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64F extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128F extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256F extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512F extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64D extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128D extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256D extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512D extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":398,"deletions":21,"binary":false,"changes":419,"status":"modified"}]}