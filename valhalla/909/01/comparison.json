{"files":[{"patch":"@@ -1870,1 +1870,1 @@\n-      sec_offset += type2aelembytes(as_BasicType(load->type()));\n+      sec_offset += type2aelembytes(inner_field->type()->basic_type());\n@@ -2200,4 +2200,8 @@\n-          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n-          Value replacement = append(load);\n-          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n-          append(store);\n+          for (int i = 0, sec_offset = 0; i < field->secondary_fields_count(); i++) {\n+            ciField* temp = i > 0 ? static_cast<ciMultiField*>(field)->secondary_field_at(i-1) : field;\n+            LoadField* load = new LoadField(obj, offset + sec_offset, temp, false, state_before, false);\n+            sec_offset += type2aelembytes(as_BasicType(load->type()));\n+            Value replacement = append(load);\n+            StoreField* store = new StoreField(new_instance, offset + sec_offset, temp, replacement, false, state_before, false);\n+            append(store);\n+          }\n@@ -2221,2 +2225,6 @@\n-    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n-    append(store);\n+    int sec_field_size = type2aelembytes(field_type);\n+    for (int i = 0; i < field_modify->secondary_fields_count(); i++) {\n+      ciField* temp = i > 0 ? static_cast<ciMultiField*>(field_modify)->secondary_field_at(i-1) : field_modify;\n+      StoreField* store = new StoreField(new_instance, offset_modify + i * sec_field_size, temp, val, false, state_before, needs_patching);\n+      append(store);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+  _is_multifield = false;\n+  _is_multifield_base = false;\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,0 +212,9 @@\n+  void set_secondary_fields(GrowableArray<ciField*>* fields) {\n+     Arena* arena = CURRENT_ENV->arena();\n+     _secondary_fields = new (arena) GrowableArray<ciField*>(arena, fields->length(), 0, nullptr);\n+     for (int i = 0; i < fields->length(); i++) {\n+       ciField* field = fields->at(i);\n+       _secondary_fields->append(new (arena) ciField(field, field->holder(), field->offset_in_bytes(), field->is_final()));\n+     }\n+  }\n+\n@@ -213,0 +222,1 @@\n+\n@@ -214,0 +224,1 @@\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -537,0 +537,37 @@\n+\n+\/\/ Generic routine to handle synthetic field population for both static\n+\/\/ and non-static base multifields.\n+ciField* ciInstanceKlass::populate_synthetic_multifields(ciField* field) {\n+  ASSERT_IN_VM;\n+  if (!field->is_multifield_base()) {\n+    return field;\n+  }\n+  int sec_fields_count = 0;\n+  ciMultiField* mfield = static_cast<ciMultiField*>(field);\n+  Arena* arena = CURRENT_ENV->arena();\n+  InstanceKlass* k = get_instanceKlass();\n+\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.offset() == field->offset_in_bytes()) {\n+      assert(mfield == field, \"Duplicate multifield for a given offset\");\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.is_multifield_base(), \"\");\n+      mfield = new (arena) ciMultiField(&fd);\n+      sec_fields_count = fd.secondary_fields_count(fd.index()) - 1;\n+      mfield->add_secondary_fields(new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, NULL));\n+      if (sec_fields_count == 0) {\n+        break;\n+      }\n+    } else if (sec_fields_count && fs.is_multifield()) {\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      mfield->secondary_fields()->append(new (arena) ciField(&fd));\n+      sec_fields_count--;\n+      if (sec_fields_count == 0) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  return mfield;\n+}\n+\n@@ -561,0 +598,1 @@\n+  int sec_fields_count = 0;\n@@ -564,1 +602,2 @@\n-      assert(fields->last()->is_multifield_base(), \"\");\n+      assert(sec_fields_count && fields->last()->is_multifield_base(), \"\");\n+      sec_fields_count--;\n@@ -570,0 +609,1 @@\n+    assert(!sec_fields_count, \"\");\n@@ -589,1 +629,1 @@\n-          static_cast<ciMultiField*>(field)->add_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n+          static_cast<ciMultiField*>(field)->set_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n@@ -599,1 +639,2 @@\n-        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, fd.secondary_fields_count(fd.index()), 0, NULL);\n+        sec_fields_count = fd.secondary_fields_count(fd.index());\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, NULL);\n@@ -601,0 +642,1 @@\n+        sec_fields_count--;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+  ciField* populate_synthetic_multifields(ciField* field);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,0 +324,3 @@\n+  if (f && f->is_multifield_base()) {\n+    GUARDED_VM_ENTRY(f = _holder->populate_synthetic_multifields(f);)\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1643,0 +1643,1 @@\n+        aflags.set_flags(flags);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1131,3 +1131,8 @@\n-  if (k->class_loader() != nullptr &&\n-      k->class_loader() != SystemDictionary::java_platform_loader() &&\n-      k->class_loader() != SystemDictionary::java_system_loader()) {\n+  \/\/ Inline classes encapsulate two mirror objects, a value mirror (primitive value mirror)\n+  \/\/ and a reference mirror (primitive class mirror), skip over scratch mirror allocation\n+  \/\/ for inline classes, they will not be part of shared archive and will be created while\n+  \/\/ restoring unshared fileds. Refer Klass::restore_unshareable_info() for more details.\n+  if (k->is_inline_klass() ||\n+      (k->class_loader() != nullptr &&\n+       k->class_loader() != SystemDictionary::java_platform_loader() &&\n+       k->class_loader() != SystemDictionary::java_system_loader())) {\n@@ -4966,24 +4971,0 @@\n-int vector_VectorPayload::_payload_offset;\n-\n-#define VECTORPAYLOAD_FIELDS_DO(macro) \\\n-  macro(_payload_offset, k, \"payload\", object_signature, false)\n-\n-void vector_VectorPayload::compute_offsets() {\n-  InstanceKlass* k = vmClasses::vector_VectorPayload_klass();\n-  \/\/FIXME: VectorPayload class no longer holds the Object payload.\n-  \/\/Multi-field based payloads have been moved to leaf level\n-  \/\/concrete classes. Offset recorded here is used for object\n-  \/\/re-construction during de-opt.\n-  \/\/ VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void vector_VectorPayload::serialize_offsets(SerializeClosure* f) {\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-void vector_VectorPayload::set_payload(oop o, oop val) {\n-  o->obj_field_put(_payload_offset, val);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":27,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1749,2 +1749,0 @@\n- private:\n-  static int _payload_offset;\n@@ -1752,5 +1750,0 @@\n-  static void set_payload(oop o, oop val);\n-\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n@@ -1758,0 +1751,2 @@\n+  static void compute_offsets() { }\n+  static void serialize_offsets(SerializeClosure* f) { }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -512,1 +512,2 @@\n-      if (base->is_Con() && !is_array && !mismatched && ft->bundle_size() == 1) {\n+      ciField* field = holder->get_field_by_offset(offset, false);\n+      if (base->is_Con() && !is_array && !mismatched && !field->is_multifield_base()) {\n@@ -516,1 +517,0 @@\n-        ciField* field = holder->get_field_by_offset(offset, false);\n@@ -530,1 +530,0 @@\n-        ciField* field = holder->get_field_by_offset(offset, false);\n@@ -856,1 +855,1 @@\n-Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type) {\n+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type, ciInlineKlass* klass, int index) {\n@@ -858,1 +857,0 @@\n-  Node* value = gvn.zerocon(field_type->basic_type());\n@@ -860,1 +858,4 @@\n-  if (is_java_primitive(bt) &&\n+  Node* value = gvn.zerocon(field_type->basic_type());\n+  int is_multifield_base = klass->declared_nonstatic_field_at(index)->is_multifield_base();\n+  if (is_multifield_base &&\n+      is_java_primitive(bt) &&\n@@ -881,1 +882,1 @@\n-    Node* value = default_value(gvn, ft);\n+    Node* value = default_value(gvn, ft, vk, i);\n@@ -1248,1 +1249,1 @@\n-          parm = default_value(gvn, type);\n+          parm = default_value(gvn, type, ik, i);\n@@ -1348,1 +1349,1 @@\n-    Node* value = default_value(gvn, ft);\n+    Node* value = default_value(gvn, ft, vk, i);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  static Node* default_value(PhaseGVN& gvn, ciType* field_type);\n+  static Node* default_value(PhaseGVN& gvn, ciType* field_type, ciInlineKlass* klass, int index);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2364,1 +2364,1 @@\n-        \/\/ Skip over direct field access for VectorPayloadMF* class instancs since\n+        \/\/ Skip over direct field access for VectorPayloadMF* class instances since\n@@ -2366,1 +2366,3 @@\n-        \/\/ extraction logic.\n+        \/\/ extraction logic. Given that unsafe put operations over vector payloads are part\n+        \/\/ of fallback implementation, for the time being suboptimality should not be major\n+        \/\/ concern.\n@@ -2655,1 +2657,1 @@\n-  if (!vt->is_allocated(&_gvn)) {\n+  if (!vt->is_allocated(&_gvn) || VectorSupport::is_vector_payload_mf(vt->inline_klass()->get_InlineKlass())) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1246,1 +1246,6 @@\n-  if (base != nullptr && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+  if (base != nullptr && base->is_InlineType() &&\n+      \/\/ Multifields are loaded into vectors and lane level loads needs\n+      \/\/ an explicit extraction operation.\n+      (bottom_type()->isa_vect() ||\n+       !VectorSupport::is_vector_payload_mf(base->as_InlineType()->inline_klass()->get_InlineKlass())) &&\n+      offset > oopDesc::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -929,2 +929,5 @@\n-      assert(vt->get_is_buffered() && vt->get_is_buffered()->get_int() == 1, \"\");\n-      ret->add_req(vt->get_oop());\n+      \/\/ Prevent returning uninitialized VBA, this will make associated box useless and\n+      \/\/ will be swept by dead code eliminator. Once VBA is expanded and initialized during\n+      \/\/ PhaseVector box users will be tied to newly allocated and initialized objects.\n+      assert(vt->get_is_buffered(), \"\");\n+      ret->add_req(vt->get_is_buffered()->get_int() ? vt->get_oop() : res);\n@@ -2374,2 +2377,9 @@\n-    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n-        return_type->is_inlinetypeptr()) {\n+    \/\/ Buffer vector return values, for regular inline object caller\n+    \/\/ expects scalarized fields to be passed back.\n+    bool is_vector_value = value->is_InlineType() &&\n+                           VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass()->get_InlineKlass());\n+    \/\/ Defer returning VectorBoxAllocation node, they will be expanded and initialized\n+    \/\/ during box expansion and will replace all uses of box.\n+    bool skip_scalarization = is_vector_value && Compile::current()->inlining_incrementally();\n+    if (!is_vector_value && ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n+        return_type->is_inlinetypeptr())) {\n@@ -2380,8 +2390,1 @@\n-      if (VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass()->get_InlineKlass())) {\n-        \/\/ Buffer the vector return types, for regular inline object caller expects\n-        \/\/ scalarized fields to be passed back.\n-        PreserveReexecuteState preexecs(this);\n-        jvms()->set_should_reexecute(true);\n-        inc_sp(1);\n-        value = value->as_InlineType()->buffer(this);\n-      } else if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n+      if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n@@ -2396,1 +2399,2 @@\n-    } else if (value->is_InlineType()) {\n+    } else if (skip_scalarization ||\n+               (value->Opcode() != Op_VectorBox && value->is_InlineType())) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2440,0 +2440,4 @@\n+            if (tboth->is_inlinetypeptr()) {\n+              assert(tboth->exact_klass(true)->is_inlinetype(), \"\");\n+              ccast = InlineTypeNode::make_from_oop(this, ccast, tboth->exact_klass(true)->as_inline_klass());\n+            }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -372,1 +372,2 @@\n-  bool scalarize_fields = !is_java_primitive(bt) || !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  bool scalarize_fields = !field->is_multifield_base() || !is_java_primitive(bt) ||\n+                          !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-  Node* alloc_oop  = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, vector);\n+  Node* alloc_oop  = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1722,0 +1722,1 @@\n+    box_node->set_is_buffered(gvn, false);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}