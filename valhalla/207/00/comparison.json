{"files":[{"patch":"@@ -5344,1 +5344,1 @@\n-bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, VMReg from, VMRegPair* regs_to,\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, VMReg from, int& from_index, VMRegPair* regs_to,\n@@ -5422,0 +5422,1 @@\n+  from_index--;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1662,1 +1662,1 @@\n-  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, VMReg from, VMRegPair* regs_to, int& to_index,\n+  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, VMReg from, int& from_index, VMRegPair* regs_to, int& to_index,\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  bool done = false;\n+  bool done = (args_passed_to == 0);\n@@ -212,2 +212,0 @@\n-        assert(0 <= from_index && from_index < args_passed, \"index out of bounds\");\n-        assert(0 <= to_index && to_index < args_passed_to, \"index out of bounds\");\n@@ -224,11 +222,15 @@\n-        } else if (is_packing || !receiver_only || (from_index == 0 && bt == T_VOID)) {\n-          if (is_packing) {\n-            VMReg reg_to = regs_to[to_index].first();\n-            done &= pack_inline_helper(sig_cc, sig_index, vtarg_index, reg_to, regs, args_passed, from_index,\n-                                       reg_state, ret_off, extra_stack_offset);\n-            vtarg_index ++;\n-            to_index ++;\n-            continue; \/\/ from_index already adjusted\n-          } else {\n-            VMReg from_reg = regs[from_index].first();\n-            done &= unpack_inline_helper(sig_cc, sig_index, from_reg, regs_to, to_index, reg_state, ret_off, extra_stack_offset);\n+          from_index += step;\n+        } else if (is_packing) {\n+          VMReg reg_to = regs_to[to_index].first();\n+          done &= pack_inline_helper(sig_cc, sig_index, vtarg_index, reg_to, regs, args_passed, from_index,\n+                                     reg_state, ret_off, extra_stack_offset);\n+          vtarg_index++;\n+          to_index++;\n+        } else if (!receiver_only || (from_index == 0 && bt == T_VOID)) {\n+          VMReg from_reg = regs[from_index].first();\n+          done &= unpack_inline_helper(sig_cc, sig_index, from_reg, from_index, regs_to, to_index, reg_state, ret_off, extra_stack_offset);\n+          if (from_index == -1 && sig_index != 0) {\n+            \/\/ This can happen when we are confusing an empty inline type argument which is\n+            \/\/ not counted in the scalarized signature for the receiver. Just ignore it.\n+            assert(receiver_only, \"sanity\");\n+            from_index = 0;\n@@ -236,2 +238,0 @@\n-        } else {\n-          continue;\n@@ -239,1 +239,0 @@\n-        from_index += step;\n","filename":"src\/hotspot\/share\/asm\/macroAssembler_common.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -94,2 +94,4 @@\n-bool ciInlineKlass::is_empty() const {\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->is_empty_inline_type();)\n+bool ciInlineKlass::is_empty() {\n+  \/\/ Do not use InlineKlass::is_empty_inline_type here because it does\n+  \/\/ not recursively account for flattened fields of empty inline types.\n+  return nof_nonstatic_fields() == 0;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  bool is_empty() const;\n+  bool is_empty();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n@@ -379,1 +379,1 @@\n-  return InlineTypePassFieldsAsArgs && is_scalarizable() && !is_empty_inline_type();\n+  return InlineTypePassFieldsAsArgs && is_scalarizable();\n@@ -384,1 +384,1 @@\n-  return InlineTypeReturnedAsFields && is_scalarizable() && !is_empty_inline_type() && (init || return_regs() != NULL);\n+  return InlineTypeReturnedAsFields && is_scalarizable() && (init || return_regs() != NULL);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-      if (method()->has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null()) {\n+      if (method()->has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null() && t->inline_klass()->can_be_passed_as_fields()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1815,1 +1815,1 @@\n-    if (call->method()->has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null()) {\n+    if (call->method()->has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null() && t->inline_klass()->can_be_passed_as_fields()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-void InlineTypeBaseNode::make_scalar_in_safepoints(PhaseIterGVN* igvn) {\n+void InlineTypeBaseNode::make_scalar_in_safepoints(PhaseIterGVN* igvn, bool allow_oop) {\n@@ -233,1 +233,1 @@\n-      if (is_allocated(igvn) && get_oop()->is_Con()) {\n+      if (allow_oop && is_allocated(igvn) && get_oop()->is_Con()) {\n@@ -276,2 +276,6 @@\n-      \/\/ Recursively load the flattened inline type field\n-      value = InlineTypeNode::make_from_flattened(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators);\n+      if (ft->as_inline_klass()->is_empty()) {\n+        value = InlineTypeNode::make_default(kit->gvn(), ft->as_inline_klass());\n+      } else {\n+        \/\/ Recursively load the flattened inline type field\n+        value = InlineTypeNode::make_from_flattened(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators);\n+      }\n@@ -513,1 +517,1 @@\n-        value = InlineTypeNode::make_default(gvn, field_klass);\n+        value = make_default(gvn, field_klass);\n@@ -541,1 +545,3 @@\n-\n+  if (vk->is_empty()) {\n+    return make_default(gvn, vk);\n+  }\n@@ -580,1 +586,1 @@\n-    assert(init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineTypePtr ||\n+    assert(vt->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineTypePtr ||\n@@ -602,2 +608,2 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n-  vt->initialize_fields(kit, multi, sig, base_input, 0, in);\n+  InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk);\n+  vt->initialize_fields(kit, multi, sig, base_input, in);\n@@ -662,4 +668,6 @@\n-        \/\/ Check inline type field load recursively\n-        base = vt->is_loaded(phase, vk, base, offset - vt->inline_klass()->first_field_offset());\n-        if (base == NULL) {\n-          return NULL;\n+        if (!vt->inline_klass()->is_empty()) {\n+          \/\/ Check inline type field load recursively\n+          base = vt->is_loaded(phase, vk, base, offset - vt->inline_klass()->first_field_offset());\n+          if (base == NULL) {\n+            return NULL;\n+          }\n@@ -708,1 +716,1 @@\n-void InlineTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature& sig, uint& base_input, int base_offset) {\n+void InlineTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature& sig, uint& base_input) {\n@@ -710,3 +718,3 @@\n-    int sig_offset = (*sig)._offset;\n-    uint idx = field_index(sig_offset - base_offset);\n-    Node* arg = field_value(idx);\n+    int offset = field_offset(i);\n+    ciType* type = field_type(i);\n+    Node* arg = field_value(i);\n@@ -714,1 +722,1 @@\n-    if (field_is_flattened(idx)) {\n+    if (field_is_flattened(i)) {\n@@ -717,1 +725,1 @@\n-      vt->pass_fields(kit, n, sig, base_input, sig_offset - vt->inline_klass()->first_field_offset());\n+      vt->pass_fields(kit, n, sig, base_input);\n@@ -742,1 +750,1 @@\n-void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature& sig, uint& base_input, int base_offset, bool in) {\n+void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature& sig, uint& base_input, bool in) {\n@@ -744,5 +752,2 @@\n-  for (uint i = 0; i < field_count(); i++) {\n-    int sig_offset = (*sig)._offset;\n-    uint idx = field_index(sig_offset - base_offset);\n-    ciType* type = field_type(idx);\n-\n+  for (uint i = 0; i < field_count(); ++i) {\n+    ciType* type = field_type(i);\n@@ -750,1 +755,1 @@\n-    if (field_is_flattened(idx)) {\n+    if (field_is_flattened(i)) {\n@@ -752,2 +757,2 @@\n-      InlineTypeNode* vt = InlineTypeNode::make_uninitialized(gvn, type->as_inline_klass());\n-      vt->initialize_fields(kit, multi, sig, base_input, sig_offset - type->as_inline_klass()->first_field_offset(), in);\n+      InlineTypeNode* vt = make_uninitialized(gvn, type->as_inline_klass());\n+      vt->initialize_fields(kit, multi, sig, base_input, in);\n@@ -767,1 +772,1 @@\n-          parm = InlineTypeNode::make_from_oop(kit, parm, type->as_inline_klass());\n+          parm = make_from_oop(kit, parm, type->as_inline_klass());\n@@ -772,2 +777,0 @@\n-      base_input += type2size[type->basic_type()];\n-      \/\/ Skip reserved arguments\n@@ -775,0 +778,2 @@\n+      base_input += type2size[bt];\n+      \/\/ Skip reserved arguments\n@@ -780,1 +785,2 @@\n-    set_field_value(idx, parm);\n+    assert(field_value(i) == NULL, \"already set\");\n+    set_field_value(i, parm);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":38,"deletions":32,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  void make_scalar_in_safepoints(PhaseIterGVN* igvn);\n+  void make_scalar_in_safepoints(PhaseIterGVN* igvn, bool allow_oop = true);\n@@ -142,1 +142,1 @@\n-  void pass_fields(GraphKit* kit, Node* n, ExtendedSignature& sig, uint& base_input, int base_offset = 0);\n+  void pass_fields(GraphKit* kit, Node* n, ExtendedSignature& sig, uint& base_input);\n@@ -144,1 +144,1 @@\n-  void initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature& sig, uint& base_input, int base_offset, bool in);\n+  void initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature& sig, uint& base_input, bool in);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -617,2 +617,0 @@\n-    \/\/ Each inline type field has its own memory slice\n-    adr_type = adr_type->with_field_offset(field_offset);\n@@ -629,0 +627,2 @@\n+      \/\/ Each inline type field has its own memory slice\n+      adr_type = adr_type->with_field_offset(field_offset);\n@@ -972,1 +972,4 @@\n-  \/\/ Scalarize inline types that were added to the safepoint\n+  \/\/ Scalarize inline types that were added to the safepoint.\n+  \/\/ Don't allow linking a constant oop (if available) for flat array elements\n+  \/\/ because Deoptimization::reassign_flat_array_elements needs field values.\n+  bool allow_oop = (klass == NULL) || !klass->is_flat_array_klass();\n@@ -975,1 +978,1 @@\n-    vt->as_InlineType()->make_scalar_in_safepoints(&_igvn);\n+    vt->as_InlineType()->make_scalar_in_safepoints(&_igvn, allow_oop);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -866,1 +866,1 @@\n-  uint j = 0;\n+  uint i = 0;\n@@ -868,1 +868,1 @@\n-  for (uint i = 0; i < (uint)arg_size; i++) {\n+  for (uint j = 0; i < (uint)arg_size; i++) {\n@@ -893,2 +893,2 @@\n-  for (; j < map->req(); j++) {\n-    map->init_req(j, top());\n+  for (; i < map->req(); i++) {\n+    map->init_req(i, top());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -298,0 +298,4 @@\n+      if (elemtype->inline_klass()->is_empty()) {\n+        \/\/ Ignore empty inline stores, array is already initialized.\n+        return;\n+      }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1268,1 +1268,4 @@\n-\n+  if (svIndex >= sv->field_size()) {\n+    \/\/ No fields left to re-assign.\n+    return svIndex;\n+  }\n@@ -1390,1 +1393,1 @@\n-void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, TRAPS) {\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS) {\n@@ -1393,3 +1396,0 @@\n-  if (vk->is_empty_inline_type()) {\n-    return; \/\/ No fields to re-assign\n-  }\n@@ -1402,1 +1402,1 @@\n-    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, false \/* skip_internal *\/, offset, CHECK);\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, skip_internal, offset, CHECK);\n@@ -1430,1 +1430,1 @@\n-      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, CHECK);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, skip_internal, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static void reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, TRAPS);\n+  static void reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3016,0 +3016,92 @@\n+\n+    \/\/ Empty inline type array access\n+    @Test(failOn = ALLOC + ALLOCA + LOAD + STORE)\n+    public MyValueEmpty test130(MyValueEmpty[] array) {\n+        array[0] = new MyValueEmpty();\n+        return array[1];\n+    }\n+\n+    @DontCompile\n+    public void test130_verifier(boolean warmup) {\n+        MyValueEmpty[] array = new MyValueEmpty[2];\n+        MyValueEmpty empty = test130(array);\n+        Asserts.assertEquals(array[0], MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    static inline class EmptyContainer {\n+        MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    \/\/ TODO disabled until JDK-8253893 is fixed\n+\/*\n+    \/\/ Empty inline type container array access\n+    @Test(failOn = ALLOC + ALLOCA + LOAD + STORE)\n+    public MyValueEmpty test131(EmptyContainer[] array) {\n+        array[0] = new EmptyContainer();\n+        return array[1].empty;\n+    }\n+\n+    @DontCompile\n+    public void test131_verifier(boolean warmup) {\n+        EmptyContainer[] array = new EmptyContainer[2];\n+        MyValueEmpty empty = test131(array);\n+        Asserts.assertEquals(array[0], EmptyContainer.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+*\/\n+\n+    \/\/ Empty inline type array access with unknown array type\n+    @Test()\n+    public Object test132(Object[] array) {\n+        array[0] = new MyValueEmpty();\n+        return array[1];\n+    }\n+\n+    @DontCompile\n+    public void test132_verifier(boolean warmup) {\n+        Object[] array = new MyValueEmpty[2];\n+        Object empty = test132(array);\n+        Asserts.assertEquals(array[0], MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        array = new Object[2];\n+        empty = test132(array);\n+        Asserts.assertEquals(array[0], MyValueEmpty.default);\n+        Asserts.assertEquals(empty, null);\n+    }\n+\n+    \/\/ TODO disabled until JDK-8253893 is fixed\n+\/*\n+    \/\/ Empty inline type container array access with unknown array type\n+    @Test()\n+    public Object test133(Object[] array) {\n+        array[0] = new EmptyContainer();\n+        return array[1];\n+    }\n+\n+    @DontCompile\n+    public void test133_verifier(boolean warmup) {\n+        Object[] array = new EmptyContainer[2];\n+        Object empty = test133(array);\n+        Asserts.assertEquals(array[0], EmptyContainer.default);\n+        Asserts.assertEquals(empty, EmptyContainer.default);\n+        array = new Object[2];\n+        empty = test133(array);\n+        Asserts.assertEquals(array[0], EmptyContainer.default);\n+        Asserts.assertEquals(empty, null);\n+    }\n+*\/\n+\n+    \/\/ Non-escaping empty inline type array access\n+    @Test(failOn = ALLOC + ALLOCA + LOAD + STORE)\n+    public static MyValueEmpty test134(MyValueEmpty val) {\n+        MyValueEmpty[] array = new MyValueEmpty[1];\n+        array[0] = val;\n+        return array[0];\n+    }\n+\n+    @DontCompile\n+    public void test134_verifier(boolean warmup) {\n+        MyValueEmpty empty = test134(MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-        test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class, MyValue3Inline.class, MyValue4.class, Test27Value1.class, Test27Value2.class, Test27Value3.class, Test37Value.class);\n+        test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class, MyValue3Inline.class, MyValue4.class,\n+                 Test27Value1.class, Test27Value2.class, Test27Value3.class, Test37Value.class, EmptyContainer.class, MixedContainer.class);\n@@ -917,0 +918,120 @@\n+\n+    \/\/ More empty inline type tests with containers\n+\n+    static inline class EmptyContainer {\n+        private MyValueEmpty empty;\n+\n+        EmptyContainer(MyValueEmpty empty) {\n+            this.empty = empty;\n+        }\n+\n+        @ForceInline\n+        MyValueEmpty getInline() { return empty; }\n+\n+        @DontInline\n+        MyValueEmpty getNoInline() { return empty; }\n+    }\n+\n+    static inline class MixedContainer {\n+        public int val;\n+        private EmptyContainer empty;\n+\n+        MixedContainer(int val, EmptyContainer empty) {\n+            this.val = val;\n+            this.empty = empty;\n+        }\n+\n+        @ForceInline\n+        EmptyContainer getInline() { return empty; }\n+\n+        @DontInline\n+        EmptyContainer getNoInline() { return empty; }\n+    }\n+\n+    \/\/ Empty inline type return\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public MyValueEmpty test42() {\n+        EmptyContainer c = new EmptyContainer(MyValueEmpty.default);\n+        return c.getInline();\n+    }\n+\n+    @DontCompile\n+    public void test42_verifier(boolean warmup) {\n+        MyValueEmpty empty = test42();\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Empty inline type container return\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public EmptyContainer test43(EmptyContainer c) {\n+        return c;\n+    }\n+\n+    @DontCompile\n+    public void test43_verifier(boolean warmup) {\n+        EmptyContainer c = test43(EmptyContainer. default);\n+        Asserts.assertEquals(c, EmptyContainer.default);\n+    }\n+\n+    \/\/ Empty inline type container (mixed) return\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public MixedContainer test44() {\n+        MixedContainer c = new MixedContainer(rI, EmptyContainer.default);\n+        c = new MixedContainer(rI, c.getInline());\n+        return c;\n+    }\n+\n+    @DontCompile\n+    public void test44_verifier(boolean warmup) {\n+        MixedContainer c = test44();\n+        Asserts.assertEquals(c, new MixedContainer(rI, EmptyContainer.default));\n+    }\n+\n+    \/\/ Empty inline type container argument\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public EmptyContainer test45(EmptyContainer c) {\n+        return new EmptyContainer(c.getInline());\n+    }\n+\n+    @DontCompile\n+    public void test45_verifier(boolean warmup) {\n+        EmptyContainer empty = test45(EmptyContainer.default);\n+        Asserts.assertEquals(empty, EmptyContainer.default);\n+    }\n+\n+    \/\/ Empty inline type container and mixed container arguments\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public MyValueEmpty test46(EmptyContainer c1, MixedContainer c2, MyValueEmpty empty) {\n+        c2 = new MixedContainer(c2.val, c1);\n+        return c2.getNoInline().getNoInline();\n+    }\n+\n+    @DontCompile\n+    public void test46_verifier(boolean warmup) {\n+        MyValueEmpty empty = test46(EmptyContainer.default, MixedContainer.default, MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ No receiver and only empty argument\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public static MyValueEmpty test47(MyValueEmpty empty) {\n+        return empty;\n+    }\n+\n+    @DontCompile\n+    public void test47_verifier(boolean warmup) {\n+        MyValueEmpty empty = test47(MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ No receiver and only empty container argument\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public static MyValueEmpty test48(EmptyContainer empty) {\n+        return empty.getNoInline();\n+    }\n+\n+    @DontCompile\n+    public void test48_verifier(boolean warmup) {\n+        MyValueEmpty empty = test48(EmptyContainer.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":122,"deletions":1,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -186,33 +186,33 @@\n-    \/\/ static inline class EmptyType { }\n-    \/\/ static inline class EmptyContainer {\n-    \/\/     int i = 0;\n-    \/\/     EmptyType et = new EmptyType();\n-    \/\/ }\n-    \/\/ static inline class Container {\n-    \/\/     EmptyContainer container0 = new EmptyContainer();\n-    \/\/     EmptyContainer container1 = new EmptyContainer();\n-    \/\/ }\n-\n-    \/\/ @Test(compLevel=C1)\n-    \/\/ public EmptyType test6() {\n-    \/\/     Container c = new Container();\n-    \/\/     return c.container1.et;\n-    \/\/ }\n-\n-    \/\/ @DontCompile\n-    \/\/ public void test6_verifier(boolean warmup) {\n-    \/\/     EmptyType et = test6();\n-    \/\/     Asserts.assertEQ(et, EmptyType.default);\n-    \/\/ }\n-\n-    \/\/ @Test(compLevel=C1)\n-    \/\/ public EmptyType test7() {\n-    \/\/     Container[] ca = new Container[10];\n-    \/\/     return ca[3].container0.et;\n-    \/\/ }\n-\n-    \/\/ @DontCompile\n-    \/\/ public void test7_verifier(boolean warmup) {\n-    \/\/     EmptyType et = test7();\n-    \/\/     Asserts.assertEQ(et, EmptyType.default);\n-    \/\/ }\n+    static inline class EmptyType { }\n+    static inline class EmptyContainer {\n+        int i = 0;\n+        EmptyType et = new EmptyType();\n+    }\n+    static inline class Container {\n+        EmptyContainer container0 = new EmptyContainer();\n+        EmptyContainer container1 = new EmptyContainer();\n+    }\n+\n+    @Test(compLevel=C1)\n+    public EmptyType test6() {\n+        Container c = new Container();\n+        return c.container1.et;\n+    }\n+\n+    @DontCompile\n+    public void test6_verifier(boolean warmup) {\n+        EmptyType et = test6();\n+        Asserts.assertEQ(et, EmptyType.default);\n+    }\n+\n+    @Test(compLevel=C1)\n+    public EmptyType test7() {\n+        Container[] ca = new Container[10];\n+        return ca[3].container0.et;\n+    }\n+\n+    @DontCompile\n+    public void test7_verifier(boolean warmup) {\n+        EmptyType et = test7();\n+        Asserts.assertEQ(et, EmptyType.default);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -3293,0 +3293,9 @@\n+    static inline class EmptyContainer {\n+        private MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    static inline class MixedContainer {\n+        public int val = rI;\n+        private EmptyContainer empty = EmptyContainer.default;\n+    }\n+\n@@ -3296,1 +3305,4 @@\n-        MyValueEmpty[] arr = new MyValueEmpty[]{MyValueEmpty.default};\n+        MyValueEmpty[]   array1 = new MyValueEmpty[]{MyValueEmpty.default};\n+\/\/ TODO disabled until JDK-8253893 is fixed\n+\/\/        EmptyContainer[] array2 = new EmptyContainer[]{EmptyContainer.default};\n+\/\/        MixedContainer[] array3 = new MixedContainer[]{MixedContainer.default};\n@@ -3301,1 +3313,4 @@\n-        Asserts.assertEquals(arr[0], MyValueEmpty.default);\n+        Asserts.assertEquals(array1[0], MyValueEmpty.default);\n+\/\/ TODO disabled until JDK-8253893 is fixed\n+\/\/        Asserts.assertEquals(array2[0], EmptyContainer.default);\n+\/\/        Asserts.assertEquals(array3[0], MixedContainer.default);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}