{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/resolvedIndyEntry.hpp\"\n@@ -305,1 +306,1 @@\n-         \" last_sp != nullptr\");\n+         \" last_sp isn't null\");\n@@ -1158,0 +1159,2 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-              const int m = (1 << (BitsPerInt - s0c)) - 1;\n+              const int m = checked_cast<int>(right_n_bits(BitsPerInt - s0c));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  int secondary_fields_count() { return type()->bundle_size(); } const\n+  int secondary_fields_count() { return type()->bundle_size(); }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  assert(super() == NULL || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n+  assert(super() == nullptr || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n@@ -37,2 +37,2 @@\n-  GrowableArray<ciField*>* fields = NULL;\n-  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(NULL, false \/* no flattening *\/);)\n+  GrowableArray<ciField*>* fields = nullptr;\n+  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(nullptr, false \/* no flattening *\/);)\n@@ -40,1 +40,1 @@\n-  _declared_nonstatic_fields = (fields != NULL) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n+  _declared_nonstatic_fields = (fields != nullptr) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  ciInlineKlass(Klass* h_k) : ciInstanceKlass(h_k), _declared_nonstatic_fields(NULL) {\n+  ciInlineKlass(Klass* h_k) : ciInstanceKlass(h_k), _declared_nonstatic_fields(nullptr) {\n@@ -65,1 +65,1 @@\n-    if (_declared_nonstatic_fields == NULL) {\n+    if (_declared_nonstatic_fields == nullptr) {\n@@ -73,1 +73,1 @@\n-    assert(_declared_nonstatic_fields != NULL, \"should be initialized\");\n+    assert(_declared_nonstatic_fields != nullptr, \"should be initialized\");\n@@ -89,1 +89,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -152,1 +152,3 @@\n-#define CONSTANT_CLASS_DESCRIPTORS        65\n+#define JAVA_22_VERSION                   66\n+\n+#define CONSTANT_CLASS_DESCRIPTORS        66\n@@ -2940,1 +2942,1 @@\n-  m->compute_from_signature(cp->symbol_at(signature_index));\n+  m->constMethod()->compute_from_signature(cp->symbol_at(signature_index), access_flags.is_static());\n@@ -4513,2 +4515,2 @@\n-  return _major_version > JAVA_21_VERSION ||\n-         (_major_version == JAVA_21_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+  return _major_version > JAVA_22_VERSION ||\n+         (_major_version == JAVA_22_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n@@ -5463,1 +5465,1 @@\n-  const char* const bytes = (const char* const)signature->bytes();\n+  const char* const bytes = (const char*)signature->bytes();\n@@ -6245,1 +6247,1 @@\n-  assert(cp_size == (const u2)cp->length(), \"invariant\");\n+  assert(cp_size == (u2)cp->length(), \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-    mirror()->byte_field_put(fd->offset(), fd->int_initial_value());\n+    mirror()->byte_field_put(fd->offset(), (jbyte)(fd->int_initial_value()));\n@@ -827,1 +827,1 @@\n-    mirror()->bool_field_put(fd->offset(), fd->int_initial_value());\n+    mirror()->bool_field_put(fd->offset(), (jboolean)(fd->int_initial_value()));\n@@ -830,1 +830,1 @@\n-    mirror()->char_field_put(fd->offset(), fd->int_initial_value());\n+    mirror()->char_field_put(fd->offset(), (jchar)(fd->int_initial_value()));\n@@ -833,1 +833,1 @@\n-    mirror()->short_field_put(fd->offset(), fd->int_initial_value());\n+    mirror()->short_field_put(fd->offset(), (jshort)(fd->int_initial_value()));\n@@ -2843,1 +2843,5 @@\n-  Symbol* message = java_lang_Throwable::detail_message(throwable());\n+  const char *message = nullptr;\n+  oop detailed_message = java_lang_Throwable::message(throwable());\n+  if (detailed_message != nullptr) {\n+    message = java_lang_String::as_utf8_string(detailed_message);\n+  }\n@@ -2851,1 +2855,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message, current->name());\n@@ -2859,1 +2863,1 @@\n-    log_info(class, init)(\"Exception thrown while saving initialization exception %s\",\n+    log_info(class, init)(\"Exception %s thrown while saving initialization exception\",\n@@ -3704,15 +3708,0 @@\n-int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;\n-\n-#define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \\\n-  macro(_base_offset, k, \"base\", object_signature, false)\n-\n-void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {\n-  InstanceKlass* k = vmClasses::reflect_UnsafeStaticFieldAccessorImpl_klass();\n-  UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {\n-  UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n@@ -4715,1 +4704,2 @@\n-\/\/ the generated bytecodes for reflection.\n+\/\/ the generated bytecodes for serialization constructor returned\n+\/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n@@ -5285,1 +5275,0 @@\n-  f(reflect_UnsafeStaticFieldAccessorImpl) \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -37,0 +39,1 @@\n+class SerializeClosure;\n@@ -900,14 +903,0 @@\n-\/\/ Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects\n-class reflect_UnsafeStaticFieldAccessorImpl {\n- private:\n-  static int _base_offset;\n-  static void compute_offsets();\n-\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  static int base_offset() { CHECK_INIT(_base_offset); }\n-\n-  \/\/ Debugging\n-  friend class JavaClasses;\n-};\n@@ -1511,1 +1500,2 @@\n-  \/\/ the generated bytecodes for reflection.\n+  \/\/ the generated bytecodes for serialization constructor returned\n+  \/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/\/ by the VM, suhch as java.lang.Object and java.lang.String. These\n+\/\/ by the VM, such as java.lang.Object and java.lang.String. These\n@@ -108,2 +108,0 @@\n-  do_klass(reflect_MagicAccessorImpl_klass,             reflect_MagicAccessorImpl                             ) \\\n-  do_klass(reflect_ConstructorAccessorImpl_klass,       reflect_ConstructorAccessorImpl                       ) \\\n@@ -113,2 +111,2 @@\n-  do_klass(reflect_UnsafeStaticFieldAccessorImpl_klass, reflect_UnsafeStaticFieldAccessorImpl                 ) \\\n-  do_klass(reflect_NativeConstructorAccessorImpl_klass, reflect_NativeConstructorAccessorImpl                 ) \\\n+  do_klass(reflect_DirectConstructorHandleAccessor_NativeAccessor_klass, reflect_DirectConstructorHandleAccessor_NativeAccessor) \\\n+  do_klass(reflect_SerializationConstructorAccessorImpl_klass,           reflect_SerializationConstructorAccessorImpl ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+class SerializeClosure;\n+\n@@ -157,0 +159,2 @@\n+  template(java_lang_ScopedValue,                     \"java\/lang\/ScopedValue\")                    \\\n+  template(java_lang_ScopedValue_Carrier,             \"java\/lang\/ScopedValue$Carrier\")            \\\n@@ -196,2 +200,0 @@\n-  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n-  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n@@ -348,2 +350,0 @@\n-  template(reflect_MagicAccessorImpl,                 \"jdk\/internal\/reflect\/MagicAccessorImpl\")       \\\n-  template(reflect_ConstructorAccessorImpl,           \"jdk\/internal\/reflect\/ConstructorAccessorImpl\") \\\n@@ -355,1 +355,2 @@\n-  template(reflect_NativeConstructorAccessorImpl,     \"jdk\/internal\/reflect\/NativeConstructorAccessorImpl\")\\\n+  template(reflect_DirectConstructorHandleAccessor_NativeAccessor,   \"jdk\/internal\/reflect\/DirectConstructorHandleAccessor$NativeAccessor\") \\\n+  template(reflect_SerializationConstructorAccessorImpl,             \"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\") \\\n@@ -384,1 +385,0 @@\n-  template(reflect_UnsafeStaticFieldAccessorImpl,     \"jdk\/internal\/reflect\/UnsafeStaticFieldAccessorImpl\")\\\n@@ -836,1 +836,0 @@\n-  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n@@ -842,1 +841,1 @@\n-  template(decodeAndThrowThrowable_signature,          \"(JZ)V\")                                                   \\\n+  template(decodeAndThrowThrowable_signature,          \"(IJZ)V\")                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stackValue.hpp\"\n@@ -83,0 +84,14 @@\n+ScopeValue* DebugInfoReadStream::read_object_merge_value() {\n+  int id = read_int();\n+#ifdef ASSERT\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n+  for (int i = _obj_pool->length() - 1; i >= 0; i--) {\n+    assert(_obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n+  }\n+#endif\n+  ObjectMergeValue* result = new ObjectMergeValue(id);\n+  _obj_pool->push(result);\n+  result->read_object(this);\n+  return result;\n+}\n+\n@@ -101,1 +116,2 @@\n-                          AUTO_BOX_OBJECT_CODE = 7, MARKER_CODE = 8 };\n+                          AUTO_BOX_OBJECT_CODE = 7, MARKER_CODE = 8,\n+                          OBJECT_MERGE_CODE = 9 };\n@@ -113,0 +129,1 @@\n+   case OBJECT_MERGE_CODE:    result = stream->read_object_merge_value();                break;\n@@ -152,0 +169,1 @@\n+  _is_root = stream->read_bool();\n@@ -171,0 +189,1 @@\n+    stream->write_bool(_is_root);\n@@ -172,1 +191,1 @@\n-    if (_is_init == NULL) {\n+    if (_is_init == nullptr) {\n@@ -177,1 +196,1 @@\n-    if (_is_larval == NULL) {\n+    if (_is_larval == nullptr) {\n@@ -190,1 +209,1 @@\n-  st->print(\"%s[%d]\", is_auto_box() ? \"box_obj\" : \"obj\", _id);\n+  st->print(\"%s[%d]\", is_auto_box() ? \"box_obj\" : is_object_merge() ? \"merge_obj\" : \"obj\", _id);\n@@ -195,6 +214,28 @@\n-  if (_field_values.length() > 0) {\n-    _field_values.at(0)->print_on(st);\n-  }\n-  for (int i = 1; i < _field_values.length(); i++) {\n-    st->print(\", \");\n-    _field_values.at(i)->print_on(st);\n+  if (is_object_merge()) {\n+    ObjectMergeValue* omv = (ObjectMergeValue*)this;\n+    st->print(\"selector=\\\"\");\n+    omv->selector()->print_on(st);\n+    st->print(\"\\\"\");\n+    ScopeValue* merge_pointer = omv->merge_pointer();\n+    if (!(merge_pointer->is_object() && merge_pointer->as_ObjectValue()->value()() == nullptr) &&\n+        !(merge_pointer->is_constant_oop() && merge_pointer->as_ConstantOopReadValue()->value()() == nullptr)) {\n+      st->print(\", merge_pointer=\\\"\");\n+      merge_pointer->print_on(st);\n+      st->print(\"\\\"\");\n+    }\n+    GrowableArray<ScopeValue*>* possible_objects = omv->possible_objects();\n+    st->print(\", candidate_objs=[%d\", possible_objects->at(0)->as_ObjectValue()->id());\n+    int ncandidates = possible_objects->length();\n+    for (int i = 1; i < ncandidates; i++) {\n+      st->print(\", %d\", possible_objects->at(i)->as_ObjectValue()->id());\n+    }\n+    st->print(\"]\");\n+  } else {\n+    st->print(\"\\n        Fields: \");\n+    if (_field_values.length() > 0) {\n+      _field_values.at(0)->print_on(st);\n+    }\n+    for (int i = 1; i < _field_values.length(); i++) {\n+      st->print(\", \");\n+      _field_values.at(i)->print_on(st);\n+    }\n@@ -205,0 +246,63 @@\n+\n+\/\/ ObjectMergeValue\n+\n+\/\/ Returns the ObjectValue that should be used for the local that this\n+\/\/ ObjectMergeValue represents. ObjectMergeValue represents allocation\n+\/\/ merges in C2. This method will select which path the allocation merge\n+\/\/ took during execution of the Trap that triggered the rematerialization\n+\/\/ of the object.\n+ObjectValue* ObjectMergeValue::select(frame& fr, RegisterMap& reg_map) {\n+  StackValue* sv_selector = StackValue::create_stack_value(&fr, &reg_map, _selector);\n+  jint selector = sv_selector->get_int();\n+\n+  \/\/ If the selector is '-1' it means that execution followed the path\n+  \/\/ where no scalar replacement happened.\n+  \/\/ Otherwise, it is the index in _possible_objects array that holds\n+  \/\/ the description of the scalar replaced object.\n+  if (selector == -1) {\n+    StackValue* sv_merge_pointer = StackValue::create_stack_value(&fr, &reg_map, _merge_pointer);\n+    _selected = new ObjectValue(id());\n+\n+    \/\/ Retrieve the pointer to the real object and use it as if we had\n+    \/\/ allocated it during the deoptimization\n+    _selected->set_value(sv_merge_pointer->get_obj()());\n+\n+    \/\/ No need to rematerialize\n+    return nullptr;\n+  } else {\n+    assert(selector < _possible_objects.length(), \"sanity\");\n+    _selected = (ObjectValue*) _possible_objects.at(selector);\n+    return _selected;\n+  }\n+}\n+\n+void ObjectMergeValue::read_object(DebugInfoReadStream* stream) {\n+  _selector = read_from(stream);\n+  _merge_pointer = read_from(stream);\n+  int ncandidates = stream->read_int();\n+  for (int i = 0; i < ncandidates; i++) {\n+    ScopeValue* result = read_from(stream);\n+    assert(result->is_object(), \"Candidate is not an object!\");\n+    ObjectValue* obj = result->as_ObjectValue();\n+    _possible_objects.append(obj);\n+  }\n+}\n+\n+void ObjectMergeValue::write_on(DebugInfoWriteStream* stream) {\n+  if (is_visited()) {\n+    stream->write_int(OBJECT_ID_CODE);\n+    stream->write_int(_id);\n+  } else {\n+    set_visited(true);\n+    stream->write_int(OBJECT_MERGE_CODE);\n+    stream->write_int(_id);\n+    _selector->write_on(stream);\n+    _merge_pointer->write_on(stream);\n+    int ncandidates = _possible_objects.length();\n+    stream->write_int(ncandidates);\n+    for (int i = 0; i < ncandidates; i++) {\n+      _possible_objects.at(i)->as_ObjectValue()->write_on(stream);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":114,"deletions":10,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class ObjectMergeValue;\n@@ -53,0 +54,1 @@\n+  virtual bool is_object_merge() const { return false; }\n@@ -76,0 +78,5 @@\n+  ObjectMergeValue* as_ObjectMergeValue() {\n+    assert(is_object_merge(), \"must be\");\n+    return (ObjectMergeValue*)this;\n+  }\n+\n@@ -131,0 +138,4 @@\n+  bool                       _is_root;   \/\/ Will be true if this object is referred to\n+                                         \/\/ as a local\/expression\/monitor in the JVMs.\n+                                         \/\/ Otherwise false, meaning it's just a candidate\n+                                         \/\/ in an object allocation merge.\n@@ -139,1 +150,2 @@\n-     , _visited(false) {\n+     , _visited(false)\n+     , _is_root(true) {\n@@ -147,1 +159,1 @@\n-     , _is_init(nullptr)\n+     , _is_init(new MarkerValue())\n@@ -150,1 +162,2 @@\n-     , _visited(false) {}\n+     , _visited(false)\n+     , _is_root(true) {}\n@@ -153,14 +166,17 @@\n-  bool                        is_object() const         { return true; }\n-  int                         id() const                { return _id; }\n-  ScopeValue*                 klass() const             { return _klass; }\n-  ScopeValue*                 is_init() const           { return _is_init; }\n-  ScopeValue*                 is_larval() const         { return _is_larval; }\n-  GrowableArray<ScopeValue*>* field_values()            { return &_field_values; }\n-  ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }\n-  int                         field_size()              { return _field_values.length(); }\n-  Handle                      value() const             { return _value; }\n-  bool                        is_visited() const        { return _visited; }\n-  bool                        maybe_null() const        { return !_is_init->is_marker(); }\n-\n-  void                        set_value(oop value);\n-  void                        set_visited(bool visited) { _visited = visited; }\n+  bool                        is_object() const           { return true; }\n+  int                         id() const                  { return _id; }\n+  virtual ScopeValue*         klass() const               { return _klass; }\n+  virtual ScopeValue*         is_init() const             { return _is_init; }\n+  virtual ScopeValue*         is_larval() const           { return _is_larval; }\n+  virtual GrowableArray<ScopeValue*>* field_values()      { return &_field_values; }\n+  virtual ScopeValue*         field_at(int i) const       { return _field_values.at(i); }\n+  virtual int                 field_size()                { return _field_values.length(); }\n+  virtual Handle              value() const               { return _value; }\n+  bool                        is_visited() const          { return _visited; }\n+  bool                        is_root() const             { return _is_root; }\n+  bool                        maybe_null() const          { return !_is_init->is_marker(); }\n+\n+  void                        set_id(int id)              { _id = id; }\n+  virtual void                set_value(oop value);\n+  void                        set_visited(bool visited)   { _visited = visited; }\n+  void                        set_root(bool root)         { _is_root = root; }\n@@ -177,0 +193,59 @@\n+\/\/ An ObjectMergeValue describes objects that were inputs to a Phi in C2 and at\n+\/\/ least one of them was scalar replaced.\n+\/\/ '_selector' is an integer value that will be '-1' if during the execution of\n+\/\/ the C2 compiled code the path taken was that of the Phi input that was NOT\n+\/\/ scalar replaced. In that case '_merge_pointer' is a pointer to an already\n+\/\/ allocated object. If '_selector' is not '-1' then it should be the index of\n+\/\/ an object in '_possible_objects'. That object is an ObjectValue describing an\n+\/\/ object that was scalar replaced.\n+\n+class ObjectMergeValue: public ObjectValue {\n+protected:\n+  ScopeValue*                _selector;\n+  ScopeValue*                _merge_pointer;\n+  GrowableArray<ScopeValue*> _possible_objects;\n+\n+  \/\/ This holds the ObjectValue that should be used in place of this\n+  \/\/ ObjectMergeValue. I.e., it's the ScopeValue from _possible_objects that was\n+  \/\/ selected by 'select()' or is a on-the-fly created ScopeValue representing\n+  \/\/ the _merge_pointer if _selector is -1.\n+  \/\/\n+  \/\/ We need to keep this reference around because there will be entries in\n+  \/\/ ScopeDesc that reference this ObjectMergeValue directly. After\n+  \/\/ rematerialization ObjectMergeValue will be just a wrapper for the\n+  \/\/ Objectvalue pointed by _selected.\n+  ObjectValue*               _selected;\n+public:\n+  ObjectMergeValue(int id, ScopeValue* merge_pointer, ScopeValue* selector)\n+     : ObjectValue(id)\n+     , _selector(selector)\n+     , _merge_pointer(merge_pointer)\n+     , _possible_objects()\n+     , _selected(nullptr) {}\n+\n+  ObjectMergeValue(int id)\n+     : ObjectValue(id)\n+     , _selector(nullptr)\n+     , _merge_pointer(nullptr)\n+     , _possible_objects()\n+     , _selected(nullptr) {}\n+\n+  bool                        is_object_merge() const         { return true; }\n+  ScopeValue*                 selector() const                { return _selector; }\n+  ScopeValue*                 merge_pointer() const           { return _merge_pointer; }\n+  GrowableArray<ScopeValue*>* possible_objects()              { return &_possible_objects; }\n+  ObjectValue*                select(frame& fr, RegisterMap& reg_map) ;\n+\n+  ScopeValue*                 klass() const                   { ShouldNotReachHere(); return nullptr; }\n+  GrowableArray<ScopeValue*>* field_values()                  { ShouldNotReachHere(); return nullptr; }\n+  ScopeValue*                 field_at(int i) const           { ShouldNotReachHere(); return nullptr; }\n+  int                         field_size()                    { ShouldNotReachHere(); return -1; }\n+\n+  Handle                      value() const                   { assert(_selected != nullptr, \"Should call select() first.\"); return _selected->value(); }\n+  void                        set_value(oop value)            { assert(_selected != nullptr, \"Should call select() first.\"); _selected->set_value(value); }\n+\n+  \/\/ Serialization of debugging information\n+  void read_object(DebugInfoReadStream* stream);\n+  void write_on(DebugInfoWriteStream* stream);\n+};\n+\n@@ -328,0 +403,1 @@\n+  ScopeValue* read_object_merge_value();\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":93,"deletions":17,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+    address _enclosing_obj;\n@@ -112,1 +113,0 @@\n-    void* _user_data;\n@@ -117,1 +117,1 @@\n-    Ref(Writability w) : _writability(w), _next(nullptr), _user_data(nullptr) {}\n+    Ref(Writability w) : _writability(w), _enclosing_obj(nullptr), _next(nullptr) {}\n@@ -135,1 +135,7 @@\n-    void update(address new_loc) const;\n+    \/\/ See comments in ArchiveBuilder::remember_embedded_pointer_in_enclosing_obj()\n+    address enclosing_obj() const {\n+      return _enclosing_obj;\n+    }\n+    void set_enclosing_obj(address obj) {\n+      _enclosing_obj = obj;\n+    }\n@@ -138,2 +144,0 @@\n-    void set_user_data(void* data)  { _user_data = data; }\n-    void* user_data()               { return _user_data; }\n@@ -256,0 +260,3 @@\n+  \/\/\n+  \/\/ When we are visting d, the _enclosing_ref is c,\n+  \/\/ When we are visting c, the _enclosing_ref is b, ... and so on.\n@@ -270,20 +277,0 @@\n-  \/\/ enclosing_ref() is used to compute the offset of a field in a C++ class. For example\n-  \/\/ class Foo { intx scala; Bar* ptr; }\n-  \/\/    Foo *f = 0x100;\n-  \/\/ when the f->ptr field is iterated with do_ref() on 64-bit platforms, we will have\n-  \/\/    do_ref(Ref* r) {\n-  \/\/       r->addr() == 0x108;                \/\/ == &f->ptr;\n-  \/\/       enclosing_ref()->obj() == 0x100;   \/\/ == foo\n-  \/\/ So we know that we are iterating upon a field at offset 8 of the object at 0x100.\n-  \/\/\n-  \/\/ Note that if we have stack overflow, do_pending_ref(r) will be called first and\n-  \/\/ do_ref(r) will be called later, for the same r. In this case, enclosing_ref() is valid only\n-  \/\/ when do_pending_ref(r) is called, and will return null when do_ref(r) is called.\n-  Ref* enclosing_ref() const {\n-    return _enclosing_ref;\n-  }\n-\n-  \/\/ This is called when a reference is placed in _pending_refs. Override this\n-  \/\/ function if you're using enclosing_ref(). See notes above.\n-  virtual void do_pending_ref(Ref* ref) {}\n-\n@@ -296,0 +283,2 @@\n+    \/\/ We cannot make stack allocation because the Ref may need to be saved in\n+    \/\/ _pending_refs to avoid overflowing the C call stack\n@@ -313,2 +302,2 @@\n-  \/\/ Hashtable*             h  = ...;  it->push(&h);     => Hashtable is not a subclass of MetaspaceObj\n-  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a6);    => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ MemoryPool*            p  = ...;  it->push(&p);     => MemoryPool is not a subclass of MetaspaceObj\n+  \/\/ Array<MemoryPool*>*    a6 = ...;  it->push(&a6);    => MemoryPool is not a subclass of MetaspaceObj\n@@ -338,16 +327,0 @@\n-\n-#if 0\n-  \/\/ Enable this block if you're changing the push(...) methods, to test for types that should be\n-  \/\/ disallowed. Each of the following \"push\" calls should result in a compile-time error.\n-  void test_disallowed_types(MetaspaceClosure* it) {\n-    Hashtable<bool, mtInternal>* h  = nullptr;\n-    it->push(&h);\n-\n-    Array<Hashtable<bool, mtInternal>*>* a6 = nullptr;\n-    it->push(&a6);\n-\n-    Array<int*>* a7 = nullptr;\n-    it->push(&a7);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":16,"deletions":43,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -262,3 +262,1 @@\n-  int invokedynamic_bootstrap_ref_index_at(int indy_index) const {\n-    return cache()->resolved_indy_entry_at(decode_invokedynamic_index(indy_index))->constant_pool_index();\n-  }\n+  inline u2 invokedynamic_bootstrap_ref_index_at(int indy_index) const;\n@@ -519,1 +517,1 @@\n-  int method_handle_klass_index_at(int which) {\n+  u2 method_handle_klass_index_at(int which) {\n@@ -528,1 +526,1 @@\n-  int bootstrap_name_and_type_ref_index_at(int which) {\n+  u2 bootstrap_name_and_type_ref_index_at(int which) {\n@@ -532,1 +530,1 @@\n-  int bootstrap_methods_attribute_index(int which) {\n+  u2 bootstrap_methods_attribute_index(int which) {\n@@ -601,1 +599,1 @@\n-  int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {\n+  u2 operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {\n@@ -605,1 +603,1 @@\n-  int operand_argument_count_at(int bsms_attribute_index) {\n+  u2 operand_argument_count_at(int bsms_attribute_index) {\n@@ -607,1 +605,1 @@\n-    int argc = operands()->at(offset + _indy_argc_offset);\n+    u2 argc = operands()->at(offset + _indy_argc_offset);\n@@ -610,1 +608,1 @@\n-  int operand_argument_index_at(int bsms_attribute_index, int j) {\n+  u2 operand_argument_index_at(int bsms_attribute_index, int j) {\n@@ -632,1 +630,1 @@\n-  int bootstrap_method_ref_index_at(int which) {\n+  u2 bootstrap_method_ref_index_at(int which) {\n@@ -637,1 +635,1 @@\n-  int bootstrap_argument_count_at(int which) {\n+  u2 bootstrap_argument_count_at(int which) {\n@@ -640,1 +638,1 @@\n-    int argc = operands()->at(op_base + _indy_argc_offset);\n+    u2 argc = operands()->at(op_base + _indy_argc_offset);\n@@ -646,1 +644,1 @@\n-  int bootstrap_argument_index_at(int which, int j) {\n+  u2 bootstrap_argument_index_at(int which, int j) {\n@@ -680,2 +678,2 @@\n-  int klass_ref_index_at(int which, Bytecodes::Code code);\n-  int name_and_type_ref_index_at(int which, Bytecodes::Code code);\n+  u2 klass_ref_index_at(int which, Bytecodes::Code code);\n+  u2 name_and_type_ref_index_at(int which, Bytecodes::Code code);\n@@ -690,2 +688,2 @@\n-  int name_ref_index_at(int which_nt);            \/\/ ==  low-order jshort of name_and_type_at(which_nt)\n-  int signature_ref_index_at(int which_nt);       \/\/ == high-order jshort of name_and_type_at(which_nt)\n+  u2 name_ref_index_at(int which_nt);            \/\/ ==  low-order jshort of name_and_type_at(which_nt)\n+  u2 signature_ref_index_at(int which_nt);       \/\/ == high-order jshort of name_and_type_at(which_nt)\n@@ -798,2 +796,2 @@\n-  int       uncached_klass_ref_index_at(int cp_index);\n-  int       uncached_name_and_type_ref_index_at(int cp_index);\n+  u2 uncached_klass_ref_index_at(int cp_index);\n+  u2 uncached_name_and_type_ref_index_at(int cp_index);\n@@ -934,9 +932,3 @@\n-  ResolvedIndyEntry* resolved_indy_entry_at(int index) {\n-    return cache()->resolved_indy_entry_at(index);\n-  }\n-  int resolved_indy_entries_length() {\n-    return cache()->resolved_indy_entries_length();\n-  }\n-  oop resolved_reference_from_indy(int index) {\n-    return resolved_references()->obj_at(cache()->resolved_indy_entry_at(index)->resolved_references_index());\n-  }\n+  inline ResolvedIndyEntry* resolved_indy_entry_at(int index);\n+  inline int resolved_indy_entries_length() const;\n+  inline oop resolved_reference_from_indy(int index) const;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  u2 jfc = r.next_uint();\n+  int jfc = r.next_uint();\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-  fi._name_index = next_uint();\n-  fi._signature_index = next_uint();\n+  fi._name_index = checked_cast<u2>(next_uint());\n+  fi._signature_index = checked_cast<u2>(next_uint());\n@@ -125,1 +125,1 @@\n-    fi._initializer_index = next_uint();\n+    fi._initializer_index = checked_cast<u2>(next_uint());\n@@ -130,1 +130,1 @@\n-    fi._generic_signature_index = next_uint();\n+    fi._generic_signature_index = checked_cast<u2>(next_uint());\n@@ -135,1 +135,1 @@\n-    fi._contention_group = next_uint();\n+    fi._contention_group = checked_cast<u2>(next_uint());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  int name_index() const {\n+  u2 name_index() const {\n@@ -176,1 +176,1 @@\n-  int signature_index() const {\n+  u2 signature_index() const {\n@@ -182,1 +182,1 @@\n-  int generic_signature_index() const {\n+  u2 generic_signature_index() const {\n@@ -190,1 +190,1 @@\n-  int initval_index() const {\n+  u2 initval_index() const {\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -63,6 +64,6 @@\n-  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n-  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n-  *((address*)adr_pack_handler()) = NULL;\n-  *((address*)adr_pack_handler_jobject()) = NULL;\n-  *((address*)adr_unpack_handler()) = NULL;\n-  assert(pack_handler() == NULL, \"pack handler not null\");\n+  *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n+  *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n+  *((address*)adr_pack_handler()) = nullptr;\n+  *((address*)adr_pack_handler_jobject()) = nullptr;\n+  *((address*)adr_unpack_handler()) = nullptr;\n+  assert(pack_handler() == nullptr, \"pack handler not null\");\n@@ -70,1 +71,1 @@\n-  *((address*)adr_value_array_klasses()) = NULL;\n+  *((address*)adr_value_array_klasses()) = nullptr;\n@@ -76,1 +77,1 @@\n-  assert(val != NULL, \"Sanity check\");\n+  assert(val != nullptr, \"Sanity check\");\n@@ -126,1 +127,1 @@\n-  oop res = NULL;\n+  oop res = nullptr;\n@@ -136,1 +137,1 @@\n-  assert(res != NULL, \"Must be set in one of two paths above\");\n+  assert(res != nullptr, \"Must be set in one of two paths above\");\n@@ -141,1 +142,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -176,1 +177,1 @@\n-  if (Atomic::load_acquire(adr_value_array_klasses()) == NULL) {\n+  if (Atomic::load_acquire(adr_value_array_klasses()) == nullptr) {\n@@ -184,1 +185,1 @@\n-      if (value_array_klasses() == NULL) {\n+      if (value_array_klasses() == nullptr) {\n@@ -204,2 +205,2 @@\n-  if (ak == NULL) {\n-    return NULL;\n+  if (ak == nullptr) {\n+    return nullptr;\n@@ -306,1 +307,1 @@\n-      assert(return_regs() == NULL, \"sanity\");\n+      assert(return_regs() == nullptr, \"sanity\");\n@@ -312,1 +313,1 @@\n-  if (extended_sig() != NULL) {\n+  if (extended_sig() != nullptr) {\n@@ -315,1 +316,1 @@\n-  if (return_regs() != NULL) {\n+  if (return_regs() != nullptr) {\n@@ -327,1 +328,1 @@\n-  if (pack_handler() != NULL) {\n+  if (pack_handler() != nullptr) {\n@@ -331,3 +332,3 @@\n-    *((address*)adr_pack_handler()) = NULL;\n-    *((address*)adr_pack_handler_jobject()) = NULL;\n-    *((address*)adr_unpack_handler()) = NULL;\n+    *((address*)adr_pack_handler()) = nullptr;\n+    *((address*)adr_pack_handler_jobject()) = nullptr;\n+    *((address*)adr_unpack_handler()) = nullptr;\n@@ -339,1 +340,2 @@\n-  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypePassFieldsAsArgs;\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&\n+         InlineTypePassFieldsAsArgs;\n@@ -344,1 +346,3 @@\n-  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&\n+         InlineTypeReturnedAsFields &&\n+         (init || return_regs() != nullptr);\n@@ -360,1 +364,1 @@\n-      assert(v == NULL || oopDesc::is_oop(v), \"not an oop?\");\n+      assert(v == nullptr || oopDesc::is_oop(v), \"not an oop?\");\n@@ -382,1 +386,1 @@\n-  assert(regs != NULL, \"inconsistent\");\n+  assert(regs != nullptr, \"inconsistent\");\n@@ -504,1 +508,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -520,7 +524,7 @@\n-  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n-  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n-  *((address*)adr_pack_handler()) = NULL;\n-  *((address*)adr_pack_handler_jobject()) = NULL;\n-  *((address*)adr_unpack_handler()) = NULL;\n-  assert(pack_handler() == NULL, \"pack handler not null\");\n-  if (value_array_klasses() != NULL) {\n+  *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n+  *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n+  *((address*)adr_pack_handler()) = nullptr;\n+  *((address*)adr_pack_handler_jobject()) = nullptr;\n+  *((address*)adr_unpack_handler()) = nullptr;\n+  assert(pack_handler() == nullptr, \"pack handler not null\");\n+  if (value_array_klasses() != nullptr) {\n@@ -533,1 +537,1 @@\n-  if (value_array_klasses() != NULL) {\n+  if (value_array_klasses() != nullptr) {\n@@ -539,3 +543,3 @@\n-  \/\/ We are no longer bookkeeping pointer to InlineKlassFixedBlock during serialization, hence re-initializing\n-  \/\/ fixed block address since InstanceKlass::size() already take into account its size, thus it will anyways\n-  \/\/ be part of shared archive.\n+  \/\/ We are no longer bookkeeping pointer to fixed block during serialization, hence reinitializing\n+  \/\/ fixed block address since its size was already accounted by InstanceKlass::size() and it will\n+  \/\/ anyways be part of shared archive.\n@@ -544,1 +548,1 @@\n-  if (value_array_klasses() != NULL) {\n+  if (value_array_klasses() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -64,1 +64,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -69,1 +69,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -74,1 +74,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -79,1 +79,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -84,1 +84,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -93,1 +93,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -98,1 +98,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n@@ -103,1 +103,1 @@\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -86,0 +87,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -1126,2 +1128,2 @@\n-ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>\n-      _initialization_error_table;\n+using InitializationErrorTable = ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n+static InitializationErrorTable* _initialization_error_table;\n@@ -1132,4 +1134,1 @@\n-  \/\/ If the initialization error is OOM, this might not work, but if GC kicks in\n-  \/\/ this would be still be helpful.\n-  JavaThread* THREAD = current;\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -1138,2 +1137,14 @@\n-    log_trace(class, init)(\"Initialization error is null for class %s\", external_name());\n-    return;\n+    log_trace(class, init)(\"Unable to create the desired initialization error for class %s\", external_name());\n+\n+    \/\/ We failed to create the new exception, most likely due to either out-of-memory or\n+    \/\/ a stackoverflow error. If the original exception was either of those then we save\n+    \/\/ the shared, pre-allocated, stackless, instance of that exception.\n+    if (exception->klass() == vmClasses::StackOverflowError_klass()) {\n+      log_debug(class, init)(\"Using shared StackOverflowError as initialization error for class %s\", external_name());\n+      init_error = Handle(current, Universe::class_init_stack_overflow_error());\n+    } else if (exception->klass() == vmClasses::OutOfMemoryError_klass()) {\n+      log_debug(class, init)(\"Using shared OutOfMemoryError as initialization error for class %s\", external_name());\n+      init_error = Handle(current, Universe::class_init_out_of_memory_error());\n+    } else {\n+      return;\n+    }\n@@ -1142,1 +1153,1 @@\n-  MutexLocker ml(THREAD, ClassInitError_lock);\n+  MutexLocker ml(current, ClassInitError_lock);\n@@ -1145,1 +1156,4 @@\n-  _initialization_error_table.put_if_absent(this, elem, &created);\n+  if (_initialization_error_table == nullptr) {\n+    _initialization_error_table = new (mtClass) InitializationErrorTable();\n+  }\n+  _initialization_error_table->put_if_absent(this, elem, &created);\n@@ -1152,1 +1166,4 @@\n-  OopHandle* h = _initialization_error_table.get(this);\n+  if (_initialization_error_table == nullptr) {\n+    return nullptr;\n+  }\n+  OopHandle* h = _initialization_error_table->get(this);\n@@ -1171,1 +1188,3 @@\n-  _initialization_error_table.unlink(&cleaner);\n+  if (_initialization_error_table != nullptr) {\n+    _initialization_error_table->unlink(&cleaner);\n+  }\n@@ -2729,1 +2748,3 @@\n-    int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())\n+    int itable_offset_in_words = (int)(start_of_itable() - (intptr_t*)this);\n+\n+    int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words)\n@@ -3074,0 +3095,25 @@\n+\/\/ The constant pool is on stack if any of the methods are executing or\n+\/\/ referenced by handles.\n+bool InstanceKlass::on_stack() const {\n+  return _constants->on_stack();\n+}\n+\n+Symbol* InstanceKlass::source_file_name() const               { return _constants->source_file_name(); }\n+u2 InstanceKlass::source_file_name_index() const              { return _constants->source_file_name_index(); }\n+void InstanceKlass::set_source_file_name_index(u2 sourcefile_index) { _constants->set_source_file_name_index(sourcefile_index); }\n+\n+\/\/ minor and major version numbers of class file\n+u2 InstanceKlass::minor_version() const                 { return _constants->minor_version(); }\n+void InstanceKlass::set_minor_version(u2 minor_version) { _constants->set_minor_version(minor_version); }\n+u2 InstanceKlass::major_version() const                 { return _constants->major_version(); }\n+void InstanceKlass::set_major_version(u2 major_version) { _constants->set_major_version(major_version); }\n+\n+InstanceKlass* InstanceKlass::get_klass_version(int version) {\n+  for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n+    if (ik->constants()->version() == version) {\n+      return ik;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -3092,0 +3138,4 @@\n+Symbol* InstanceKlass::generic_signature() const                   { return _constants->generic_signature(); }\n+u2 InstanceKlass::generic_signature_index() const                  { return _constants->generic_signature_index(); }\n+void InstanceKlass::set_generic_signature_index(u2 sig_index)      { _constants->set_generic_signature_index(sig_index); }\n+\n@@ -4003,0 +4053,1 @@\n+\n@@ -4007,0 +4058,8 @@\n+  print_class_load_helper(loader_data, module_entry, cfs);\n+  print_class_load_cause_logging();\n+}\n+\n+void InstanceKlass::print_class_load_helper(ClassLoaderData* loader_data,\n+                                             const ModuleEntry* module_entry,\n+                                             const ClassFileStream* cfs) const {\n+\n@@ -4093,0 +4152,60 @@\n+void InstanceKlass::print_class_load_cause_logging() const {\n+  bool log_cause_native = log_is_enabled(Info, class, load, cause, native);\n+  if (log_cause_native || log_is_enabled(Info, class, load, cause)) {\n+    JavaThread* current = JavaThread::current();\n+    ResourceMark rm(current);\n+    const char* name = external_name();\n+\n+    if (LogClassLoadingCauseFor == nullptr ||\n+        (strcmp(\"*\", LogClassLoadingCauseFor) != 0 &&\n+         strstr(name, LogClassLoadingCauseFor) == nullptr)) {\n+        return;\n+    }\n+\n+    \/\/ Log Java stack first\n+    {\n+      LogMessage(class, load, cause) msg;\n+      NonInterleavingLogStream info_stream{LogLevelType::Info, msg};\n+\n+      info_stream.print_cr(\"Java stack when loading %s:\", name);\n+      current->print_stack_on(&info_stream);\n+    }\n+\n+    \/\/ Log native stack second\n+    if (log_cause_native) {\n+      \/\/ Log to string first so that lines can be indented\n+      stringStream stack_stream;\n+      char buf[O_BUFLEN];\n+      address lastpc = nullptr;\n+      if (os::platform_print_native_stack(&stack_stream, nullptr, buf, O_BUFLEN, lastpc)) {\n+        \/\/ We have printed the native stack in platform-specific code,\n+        \/\/ so nothing else to do in this case.\n+      } else {\n+        frame f = os::current_frame();\n+        VMError::print_native_stack(&stack_stream, f, current, true \/*print_source_info *\/,\n+                                    -1 \/* max stack_stream *\/, buf, O_BUFLEN);\n+      }\n+\n+      LogMessage(class, load, cause, native) msg;\n+      NonInterleavingLogStream info_stream{LogLevelType::Info, msg};\n+      info_stream.print_cr(\"Native stack when loading %s:\", name);\n+\n+      \/\/ Print each native stack line to the log\n+      int size = (int) stack_stream.size();\n+      char* stack = stack_stream.as_string();\n+      char* stack_end = stack + size;\n+      char* line_start = stack;\n+      for (char* p = stack; p < stack_end; p++) {\n+        if (*p == '\\n') {\n+          *p = '\\0';\n+          info_stream.print_cr(\"\\t%s\", line_start);\n+          line_start = p + 1;\n+        }\n+      }\n+      if (line_start < stack_end) {\n+        info_stream.print_cr(\"\\t%s\", line_start);\n+      }\n+    }\n+  }\n+}\n+\n@@ -4577,0 +4696,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":133,"deletions":13,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/constantPool.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -39,0 +39,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -44,0 +45,1 @@\n+class ConstantPool;\n@@ -46,0 +48,1 @@\n+class Monitor;\n@@ -120,1 +123,1 @@\n-  static const int size_in_words() {\n+  static int size_in_words() {\n@@ -300,1 +303,1 @@\n-  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, NULL if none present\n+  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, null if none present\n@@ -724,3 +727,3 @@\n-  Symbol* source_file_name() const               { return _constants->source_file_name(); }\n-  u2 source_file_name_index() const              { return _constants->source_file_name_index(); }\n-  void set_source_file_name_index(u2 sourcefile_index) { _constants->set_source_file_name_index(sourcefile_index); }\n+  Symbol* source_file_name() const;\n+  u2 source_file_name_index() const;\n+  void set_source_file_name_index(u2 sourcefile_index);\n@@ -729,4 +732,4 @@\n-  u2 minor_version() const                 { return _constants->minor_version(); }\n-  void set_minor_version(u2 minor_version) { _constants->set_minor_version(minor_version); }\n-  u2 major_version() const                 { return _constants->major_version(); }\n-  void set_major_version(u2 major_version) { _constants->set_major_version(major_version); }\n+  u2 minor_version() const;\n+  void set_minor_version(u2 minor_version);\n+  u2 major_version() const;\n+  void set_major_version(u2 major_version);\n@@ -769,8 +772,1 @@\n-  InstanceKlass* get_klass_version(int version) {\n-    for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n-      if (ik->constants()->version() == version) {\n-        return ik;\n-      }\n-    }\n-    return nullptr;\n-  }\n+  InstanceKlass* get_klass_version(int version);\n@@ -852,3 +848,3 @@\n-  Symbol* generic_signature() const                   { return _constants->generic_signature(); }\n-  u2 generic_signature_index() const                  { return _constants->generic_signature_index(); }\n-  void set_generic_signature_index(u2 sig_index)      { _constants->set_generic_signature_index(sig_index); }\n+  Symbol* generic_signature() const;\n+  u2 generic_signature_index() const;\n+  void set_generic_signature_index(u2 sig_index);\n@@ -1031,1 +1027,0 @@\n-  inline int itable_offset_in_words() const;\n@@ -1090,3 +1085,1 @@\n-  \/\/ The constant pool is on stack if any of the methods are executing or\n-  \/\/ referenced by handles.\n-  bool on_stack() const { return _constants->on_stack(); }\n+  virtual bool on_stack() const;\n@@ -1266,0 +1259,5 @@\n+ private:\n+  void print_class_load_cause_logging() const;\n+  void print_class_load_helper(ClassLoaderData* loader_data,\n+                               const ModuleEntry* module_entry,\n+                               const ClassFileStream* cfs) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -44,2 +41,0 @@\n-inline int InstanceKlass::itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }\n-\n@@ -74,1 +69,1 @@\n-    if (adr_impl != NULL) {\n+    if (adr_impl != nullptr) {\n@@ -80,1 +75,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -88,1 +83,1 @@\n-  assert(k != NULL, \"Should always be set before being read\");\n+  assert(k != nullptr, \"Should always be set before being read\");\n@@ -97,1 +92,1 @@\n-  assert(k == NULL || k->is_inline_klass(), \"Must be an inline type\");\n+  assert(k == nullptr || k->is_inline_klass(), \"Must be an inline type\");\n@@ -104,2 +99,2 @@\n-  assert(k != NULL, \"Should not be set to NULL\");\n-  assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, \"Should not be set twice\");\n+  assert(k != nullptr, \"Should not be set to nullptr\");\n+  assert(((Klass**)adr_inline_type_field_klasses())[idx] == nullptr, \"Should not be set twice\");\n@@ -112,1 +107,1 @@\n-  ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;\n+  ((Klass**)adr_inline_type_field_klasses())[idx] = nullptr;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  return bcp - code_base();\n+  return int(bcp - code_base());\n@@ -361,1 +361,1 @@\n-    bci = bcp - code_base();\n+    bci = int(bcp - code_base());\n@@ -665,13 +665,0 @@\n-\/\/ Derive size of parameters, return type, and fingerprint,\n-\/\/ all in one pass, which is run at load time.\n-\/\/ We need the first two, and might as well grab the third.\n-void Method::compute_from_signature(Symbol* sig) {\n-  \/\/ At this point, since we are scanning the signature,\n-  \/\/ we might as well compute the whole fingerprint.\n-  Fingerprinter fp(sig, is_static());\n-  set_size_of_parameters(fp.size_of_parameters());\n-  set_num_stack_arg_slots(fp.num_stack_arg_slots());\n-  constMethod()->set_result_type(fp.return_type());\n-  constMethod()->set_fingerprint(fp.fingerprint());\n-}\n-\n@@ -1285,1 +1272,5 @@\n-  if (InlineTypeReturnedAsFields && returns_inline_type(THREAD) && returns_inline_type(THREAD)->can_be_returned_as_fields()) {\n+  if (InlineTypeReturnedAsFields &&\n+      returns_inline_type(THREAD) &&\n+      !has_scalarized_return() &&\n+      returns_inline_type(THREAD)->can_be_returned_as_fields()) {\n+    assert(!constMethod()->is_shared(), \"Cannot update shared const objects\");\n@@ -1551,1 +1542,1 @@\n-  m->compute_from_signature(signature);\n+  m->constMethod()->compute_from_signature(signature, must_be_static);\n@@ -1835,1 +1826,1 @@\n-      for (int i = 0; i < length; i++) {\n+      for (u2 i = 0; i < length; i++) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -784,0 +784,4 @@\n+    if (call->is_CallStaticJava() && call->as_CallStaticJava()->is_boxing_method()) {\n+      result = kit.must_be_not_null(result, false);\n+    }\n+\n@@ -819,1 +823,1 @@\n-          AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop, &kit.gvn());\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop);\n@@ -1172,1 +1176,1 @@\n-    arg = InlineTypeNode::make_from_oop(&kit, arg, t->as_inline_klass(), !kit.gvn().type(arg)->maybe_null());\n+    arg = InlineTypeNode::make_from_oop(&kit, arg, sig_type->inline_klass(), !kit.gvn().type(arg)->maybe_null());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -832,1 +832,1 @@\n-bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -1181,0 +1181,6 @@\n+\/\/----------------------------is_uncommon_trap----------------------------\n+\/\/ Returns true if this is an uncommon trap.\n+bool CallStaticJavaNode::is_uncommon_trap() const {\n+  return (_name != nullptr && !strcmp(_name, \"uncommon_trap\"));\n+}\n+\n@@ -1184,4 +1190,1 @@\n-  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n-    return extract_uncommon_trap_request(this);\n-  }\n-  return 0;\n+  return is_uncommon_trap() ? extract_uncommon_trap_request(this) : 0;\n@@ -1688,6 +1691,1 @@\n-SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,\n-#ifdef ASSERT\n-                                                     Node* alloc,\n-#endif\n-                                                     uint first_index,\n-                                                     uint n_fields) :\n+SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields) :\n@@ -1696,4 +1694,2 @@\n-  _n_fields(n_fields)\n-#ifdef ASSERT\n-  , _alloc(alloc)\n-#endif\n+  _n_fields(n_fields),\n+  _alloc(alloc)\n@@ -1702,2 +1698,1 @@\n-  if (alloc != nullptr && !alloc->is_Allocate()\n-      && !(alloc->Opcode() == Op_VectorBox)) {\n+  if (alloc != nullptr && !alloc->is_Allocate() && !(alloc->Opcode() == Op_VectorBox)) {\n@@ -1749,2 +1744,21 @@\n-  st->print(\" # fields@[%d..%d]\", first_index(),\n-             first_index() + n_fields() - 1);\n+  st->print(\" # fields@[%d..%d]\", first_index(), first_index() + n_fields() - 1);\n+}\n+#endif\n+\n+\/\/==============  SafePointScalarMergeNode  ==============\n+\n+SafePointScalarMergeNode::SafePointScalarMergeNode(const TypeOopPtr* tp, int merge_pointer_idx) :\n+  TypeNode(tp, 1), \/\/ 1 control input -- seems required.  Get from root.\n+  _merge_pointer_idx(merge_pointer_idx)\n+{\n+  init_class_id(Class_SafePointScalarMerge);\n+}\n+\n+\/\/ Do not allow value-numbering for SafePointScalarMerge node.\n+uint SafePointScalarMergeNode::hash() const { return NO_HASH; }\n+bool SafePointScalarMergeNode::cmp( const Node &n ) const {\n+  return (&n == this); \/\/ Always fail except on self\n+}\n+\n+uint SafePointScalarMergeNode::ideal_reg() const {\n+  return 0; \/\/ No matching to machine instruction\n@@ -1753,0 +1767,29 @@\n+const RegMask &SafePointScalarMergeNode::in_RegMask(uint idx) const {\n+  return *(Compile::current()->matcher()->idealreg2debugmask[in(idx)->ideal_reg()]);\n+}\n+\n+const RegMask &SafePointScalarMergeNode::out_RegMask() const {\n+  return RegMask::Empty;\n+}\n+\n+uint SafePointScalarMergeNode::match_edge(uint idx) const {\n+  return 0;\n+}\n+\n+SafePointScalarMergeNode*\n+SafePointScalarMergeNode::clone(Dict* sosn_map, bool& new_node) const {\n+  void* cached = (*sosn_map)[(void*)this];\n+  if (cached != nullptr) {\n+    new_node = false;\n+    return (SafePointScalarMergeNode*)cached;\n+  }\n+  new_node = true;\n+  SafePointScalarMergeNode* res = (SafePointScalarMergeNode*)Node::clone();\n+  sosn_map->Insert((void*)this, (void*)res);\n+  return res;\n+}\n+\n+#ifndef PRODUCT\n+void SafePointScalarMergeNode::dump_spec(outputStream *st) const {\n+  st->print(\" # merge_pointer_idx=%d, scalarized_objects=%d\", _merge_pointer_idx, req()-1);\n+}\n@@ -1822,1 +1865,1 @@\n-Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {\n+Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseValues* phase, bool allow_new_nodes) {\n@@ -2438,1 +2481,1 @@\n-bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":64,"deletions":21,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1100,3 +1100,2 @@\n-  Arena *a = Thread::current()->resource_area();\n-  Node_Array node_map = new Node_Array(a);\n-  Node_Stack stack(a, C->live_nodes() >> 4);\n+  Node_Array node_map;\n+  Node_Stack stack(C->live_nodes() >> 4);\n@@ -1485,1 +1484,1 @@\n-Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {\n+Node* PhiNode::unique_input(PhaseValues* phase, bool uncast) {\n@@ -1550,0 +1549,6 @@\n+\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase() && !Matcher::match_rule_supported(Op_Conv2B)) {\n+    return nullptr;\n+  }\n+\n@@ -1592,3 +1597,4 @@\n-  Node *n = new Conv2BNode(cmp->in(1));\n-  if( flipped )\n-    n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(cmp->in(1));\n+  if (flipped) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n@@ -1823,2 +1829,2 @@\n-      if (PhaseIdealLoop::find_parse_predicate(r->in(i)) != nullptr) {\n-        return nullptr;            \/\/ don't split loop entry path\n+      if (Node::may_be_loop_entry(r->in(i))) {\n+        return nullptr; \/\/ don't split loop entry path\n@@ -1961,20 +1967,23 @@\n-    if (rc != nullptr &&\n-        rc->is_Proj()) {\n-      if (worklist.member(rc)) {\n-        delay = true;\n-      } else if (rc->in(0) != nullptr &&\n-                 rc->in(0)->is_If()) {\n-        if (worklist.member(rc->in(0))) {\n-          delay = true;\n-        } else if (rc->in(0)->in(1) != nullptr &&\n-                   rc->in(0)->in(1)->is_Bool()) {\n-          if (worklist.member(rc->in(0)->in(1))) {\n-            delay = true;\n-          } else if (rc->in(0)->in(1)->in(1) != nullptr &&\n-                     rc->in(0)->in(1)->in(1)->is_Cmp()) {\n-            if (worklist.member(rc->in(0)->in(1)->in(1))) {\n-              delay = true;\n-            }\n-          }\n-        }\n-      }\n+\n+    if (rc == nullptr || !rc->is_Proj()) { continue; }\n+    if (worklist.member(rc)) {\n+      delay = true;\n+      break;\n+    }\n+\n+    if (rc->in(0) == nullptr || !rc->in(0)->is_If()) { continue; }\n+    if (worklist.member(rc->in(0))) {\n+      delay = true;\n+      break;\n+    }\n+\n+    if (rc->in(0)->in(1) == nullptr || !rc->in(0)->in(1)->is_Bool()) { continue; }\n+    if (worklist.member(rc->in(0)->in(1))) {\n+      delay = true;\n+      break;\n+    }\n+\n+    if (rc->in(0)->in(1)->in(1) == nullptr || !rc->in(0)->in(1)->in(1)->is_Cmp()) { continue; }\n+    if (worklist.member(rc->in(0)->in(1)->in(1))) {\n+      delay = true;\n+      break;\n@@ -1983,0 +1992,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":39,"deletions":29,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -221,2 +221,2 @@\n-  Node* unique_input(PhaseTransform *phase, bool uncast);\n-  Node* unique_input(PhaseTransform *phase) {\n+  Node* unique_input(PhaseValues* phase, bool uncast);\n+  Node* unique_input(PhaseValues* phase) {\n@@ -241,4 +241,4 @@\n-  const int inst_mem_id() const { return _inst_mem_id; }\n-  const int inst_id()     const { return _inst_id; }\n-  const int inst_index()  const { return _inst_index; }\n-  const int inst_offset() const { return _inst_offset; }\n+  int inst_mem_id() const { return _inst_mem_id; }\n+  int inst_id()     const { return _inst_id; }\n+  int inst_index()  const { return _inst_index; }\n+  int inst_offset() const { return _inst_offset; }\n@@ -438,1 +438,1 @@\n-  bool is_flat_array_check(PhaseTransform* phase, Node** array = NULL);\n+  bool is_flat_array_check(PhaseTransform* phase, Node** array = nullptr);\n@@ -459,0 +459,20 @@\n+\/\/ Special node that denotes a Parse Predicate added during parsing. A Parse Predicate serves as placeholder to later\n+\/\/ create Runtime Predicates above it. They all share the same uncommon trap. The Parse Predicate will follow the\n+\/\/ Runtime Predicates. Together they form a Regular Predicate Block. There are three kinds of Parse Predicates:\n+\/\/ Loop Parse Predicate, Profiled Loop Parse Predicate (both used by Loop Predication), and Loop Limit Check Parse\n+\/\/ Predicate (used for integer overflow checks when creating a counted loop).\n+\/\/ More information about predicates can be found in loopPredicate.cpp.\n+class ParsePredicateNode : public IfNode {\n+  Deoptimization::DeoptReason _deopt_reason;\n+ public:\n+  ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason);\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  Deoptimization::DeoptReason deopt_reason() const {\n+    return _deopt_reason;\n+  }\n+\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const;)\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist) {\n@@ -437,1 +437,2 @@\n-      worklist->push(n->unique_out());\n+      assert(useful.member(n->unique_out()), \"do not push a useless node\");\n+      worklist.push(n->unique_out());\n@@ -440,1 +441,1 @@\n-      worklist->push(n);\n+      worklist.push(n);\n@@ -534,0 +535,6 @@\n+  if (do_reduce_allocation_merges() != ReduceAllocationMerges && PrintOpto) {\n+    \/\/ Recompiling without reducing allocation merges\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without reduce allocation merges **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -566,1 +573,0 @@\n-  ttyLocker ttyl;\n@@ -571,6 +577,6 @@\n-  if (xtty != nullptr) {\n-    xtty->head(\"ideal compile_id='%d'%s compile_phase='%s'\",\n-               compile_id(),\n-               is_osr_compilation() ? \" compile_kind='osr'\" : \"\",\n-               phase_name);\n-  }\n+\n+  \/\/ Node dumping can cause a safepoint, which can break the tty lock.\n+  \/\/ Buffer all node dumps, so that all safepoints happen before we lock.\n+  ResourceMark rm;\n+  stringStream ss;\n+\n@@ -578,1 +584,1 @@\n-    tty->print_cr(\"AFTER: %s\", phase_name);\n+    ss.print_cr(\"AFTER: %s\", phase_name);\n@@ -580,1 +586,1 @@\n-    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\");\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\", &ss);\n@@ -583,1 +589,1 @@\n-    _output->print_scheduling();\n+    _output->print_scheduling(&ss);\n@@ -586,0 +592,3 @@\n+  \/\/ Check that the lock is not broken by a safepoint.\n+  NoSafepointVerifier nsv;\n+  ttyLocker ttyl;\n@@ -587,0 +596,5 @@\n+    xtty->head(\"ideal compile_id='%d'%s compile_phase='%s'\",\n+               compile_id(),\n+               is_osr_compilation() ? \" compile_kind='osr'\" : \"\",\n+               phase_name);\n+    xtty->print(\"%s\", ss.as_string()); \/\/ print to tty would use xml escape encoding\n@@ -588,0 +602,2 @@\n+  } else {\n+    tty->print(\"%s\", ss.as_string());\n@@ -641,1 +657,1 @@\n-                  _dead_node_list(comp_arena()),\n+                  _unique(0),\n@@ -643,2 +659,4 @@\n-                  _node_arena(mtCompiler),\n-                  _old_arena(mtCompiler),\n+                  _dead_node_list(comp_arena()),\n+                  _node_arena_one(mtCompiler),\n+                  _node_arena_two(mtCompiler),\n+                  _node_arena(&_node_arena_one),\n@@ -648,1 +666,3 @@\n-                  _for_igvn(nullptr),\n+                  _igvn_worklist(nullptr),\n+                  _types(nullptr),\n+                  _node_hash(nullptr),\n@@ -671,7 +691,0 @@\n-  if (CITimeVerbose) {\n-    tty->print(\" \");\n-    target->holder()->name()->print();\n-    tty->print(\".\");\n-    target->print_short_name();\n-    tty->print(\"  \");\n-  }\n@@ -695,0 +708,1 @@\n+#endif\n@@ -699,1 +713,0 @@\n-#endif\n@@ -721,3 +734,0 @@\n-  \/\/ Node list that Iterative GVN will start with\n-  Unique_Node_List for_igvn(comp_arena());\n-  set_for_igvn(&for_igvn);\n@@ -728,1 +738,4 @@\n-  PhaseGVN gvn(node_arena(), estimated_size);\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _types = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash = new (comp_arena()) NodeHash(comp_arena(), estimated_size);\n+  PhaseGVN gvn;\n@@ -780,6 +793,4 @@\n-      if (!failure_reason_is(C2Compiler::retry_class_loading_during_parsing())) {\n-        assert(failure_reason() != nullptr, \"expect reason for parse failure\");\n-        stringStream ss;\n-        ss.print(\"method parse failed: %s\", failure_reason());\n-        record_method_not_compilable(ss.as_string());\n-      }\n+      assert(failure_reason() != nullptr, \"expect reason for parse failure\");\n+      stringStream ss;\n+      ss.print(\"method parse failed: %s\", failure_reason());\n+      record_method_not_compilable(ss.as_string());\n@@ -816,1 +827,1 @@\n-      PhaseRemoveUseless pru(initial_gvn(), &for_igvn);\n+      PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -840,1 +851,1 @@\n-    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && RepeatCompilation)) {\n+    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && directive->RepeatCompilationOption)) {\n@@ -937,1 +948,1 @@\n-    _dead_node_list(comp_arena()),\n+    _unique(0),\n@@ -939,2 +950,4 @@\n-    _node_arena(mtCompiler),\n-    _old_arena(mtCompiler),\n+    _dead_node_list(comp_arena()),\n+    _node_arena_one(mtCompiler),\n+    _node_arena_two(mtCompiler),\n+    _node_arena(&_node_arena_one),\n@@ -944,1 +957,3 @@\n-    _for_igvn(nullptr),\n+    _igvn_worklist(nullptr),\n+    _types(nullptr),\n+    _node_hash(nullptr),\n@@ -976,0 +991,3 @@\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _types = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash = new (comp_arena()) NodeHash(comp_arena(), 255);\n@@ -977,4 +995,1 @@\n-    \/\/ The following is a dummy for the sake of GraphKit::gen_stub\n-    Unique_Node_List for_igvn(comp_arena());\n-    set_for_igvn(&for_igvn);  \/\/ not used, but some GraphKit guys push on this\n-    PhaseGVN gvn(Thread::current()->resource_area(),255);\n+    PhaseGVN gvn;\n@@ -2413,1 +2428,1 @@\n-          if (Verbose) {\n+          if (PrintOpto && Verbose) {\n@@ -2440,1 +2455,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -2471,3 +2486,1 @@\n-    assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n-    for_igvn()->clear();\n-    gvn->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2536,1 +2549,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -2540,1 +2553,1 @@\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2583,2 +2596,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2601,1 +2613,2 @@\n-  assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n+\n+  igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2605,2 +2618,0 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n@@ -2631,2 +2642,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2756,4 +2766,1 @@\n-    initial_gvn()->replace_with(&igvn);\n-    Unique_Node_List* old_worklist = for_igvn();\n-    old_worklist->clear();\n-    Unique_Node_List new_worklist(C->comp_arena());\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2762,1 +2769,1 @@\n-      PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &new_worklist);\n+      PhaseRenumberLive prl(initial_gvn(), *igvn_worklist());\n@@ -2764,3 +2771,1 @@\n-    Unique_Node_List* save_for_igvn = for_igvn();\n-    set_for_igvn(&new_worklist);\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2768,1 +2773,0 @@\n-    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2796,1 +2800,0 @@\n-      if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);\n@@ -2800,0 +2803,1 @@\n+    print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);\n@@ -2821,2 +2825,4 @@\n-\n-        if (failing())  return;\n+\n+      ConnectionGraph::verify_ram_nodes(this, root());\n+      if (failing())  return;\n+\n@@ -2880,1 +2886,1 @@\n-    igvn = ccp;\n+    igvn.reset_from_igvn(&ccp);\n@@ -2949,0 +2955,4 @@\n+ \/\/ We will never use the NodeHash table any more. Clear it so that final_graph_reshaping does not have\n+ \/\/ to remove hashes to unlock nodes for modifications.\n+ C->node_hash()->clear();\n+\n@@ -3478,0 +3488,1 @@\n+    print_method(PHASE_FINAL_CODE, 1); \/\/ Compile::_output is not null here\n@@ -3480,2 +3491,0 @@\n-  print_method(PHASE_FINAL_CODE, 1);\n-\n@@ -4852,1 +4861,1 @@\n-    _phase_name(name), _dolog(CITimeVerbose)\n+    _compile(nullptr), _log(nullptr), _phase_name(name), _dolog(CITimeVerbose)\n@@ -4855,5 +4864,2 @@\n-    C = Compile::current();\n-    _log = C->log();\n-  } else {\n-    C = nullptr;\n-    _log = nullptr;\n+    _compile = Compile::current();\n+    _log = _compile->log();\n@@ -4862,1 +4868,1 @@\n-    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, C->unique(), C->live_nodes());\n+    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n@@ -4869,8 +4875,0 @@\n-\n-  C = Compile::current();\n-  if (_dolog) {\n-    _log = C->log();\n-  } else {\n-    _log = nullptr;\n-  }\n-\n@@ -4880,1 +4878,1 @@\n-                  _phase_name, C->unique(), C->live_nodes(), C->count_live_nodes_by_graph_walk());\n+                  _phase_name, _compile->unique(), _compile->live_nodes(), _compile->count_live_nodes_by_graph_walk());\n@@ -4889,1 +4887,1 @@\n-    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, C->unique(), C->live_nodes());\n+    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n@@ -5539,2 +5537,2 @@\n-void NodeCloneInfo::dump() const {\n-  tty->print(\" {%d:%d} \", idx(), gen());\n+void NodeCloneInfo::dump_on(outputStream* st) const {\n+  st->print(\" {%d:%d} \", idx(), gen());\n@@ -5587,1 +5585,1 @@\n-void CloneMap::dump(node_idx_t key) const {\n+void CloneMap::dump(node_idx_t key, outputStream* st) const {\n@@ -5591,1 +5589,1 @@\n-    ni.dump();\n+    ni.dump_on(st);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":93,"deletions":95,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _worklist_size = _gvn.C->for_igvn()->size();\n+    _worklist_size = _gvn.C->igvn_worklist()->size();\n@@ -1229,1 +1229,1 @@\n-  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array, &_gvn);\n+  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array);\n@@ -1265,2 +1265,2 @@\n-extern int explicit_null_checks_inserted,\n-           explicit_null_checks_elided;\n+extern uint explicit_null_checks_inserted,\n+            explicit_null_checks_elided;\n@@ -1953,2 +1953,6 @@\n-    if (call->method()->return_type()->is_inlinetype()) {\n-      ret = InlineTypeNode::make_from_oop(this, ret, call->method()->return_type()->as_inline_klass(), call->method()->signature()->returns_null_free_inline_type());\n+    ciType* t = call->method()->return_type();\n+    if (t->is_klass()) {\n+      const Type* type = TypeOopPtr::make_from_klass(t->as_klass());\n+      if (type->is_inlinetypeptr()) {\n+        ret = InlineTypeNode::make_from_oop(this, ret, type->inline_klass(), type->inline_klass()->is_null_free());\n+      }\n@@ -3035,0 +3039,1 @@\n+      assert(!(*casted_receiver)->is_top(), \"that path should be unreachable\");\n@@ -3861,3 +3866,3 @@\n-  const TypeKlassPtr* inst_klass = _gvn.type(klass_node)->isa_klassptr();\n-  if (!StressReflectiveCode && inst_klass != nullptr) {\n-    bool xklass = inst_klass->klass_is_exact();\n+  const TypeKlassPtr* klass_t = _gvn.type(klass_node)->isa_klassptr();\n+  if (!StressReflectiveCode && klass_t != nullptr) {\n+    bool xklass = klass_t->klass_is_exact();\n@@ -3865,1 +3870,1 @@\n-    const TypeAryPtr* ary_type = inst_klass->as_instance_type()->isa_aryptr();\n+    const TypeAryPtr* ary_type = klass_t->as_instance_type()->isa_aryptr();\n@@ -3871,1 +3876,1 @@\n-    if (!can_be_flattened && (xklass || inst_klass->isa_aryklassptr())) {\n+    if (!can_be_flattened && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n@@ -3873,1 +3878,1 @@\n-      if (inst_klass->is_flat()) {\n+      if (klass_t->is_flat()) {\n@@ -3875,1 +3880,1 @@\n-      } else if (inst_klass->isa_aryklassptr()) {\n+      } else if (klass_t->isa_aryklassptr()) {\n@@ -3882,1 +3887,1 @@\n-        lhelper = inst_klass->is_instklassptr()->exact_klass()->layout_helper();\n+        lhelper = klass_t->is_instklassptr()->exact_klass()->layout_helper();\n@@ -4004,1 +4009,1 @@\n-    assert(AllocateNode::Ideal_allocation(rawoop, &_gvn) == alloc,\n+    assert(AllocateNode::Ideal_allocation(rawoop) == alloc,\n@@ -4006,1 +4011,1 @@\n-    assert(AllocateNode::Ideal_allocation(javaoop, &_gvn) == alloc,\n+    assert(AllocateNode::Ideal_allocation(javaoop) == alloc,\n@@ -4009,1 +4014,1 @@\n-      assert(AllocateArrayNode::Ideal_array_allocation(rawoop, &_gvn) == alloc->as_AllocateArray(),\n+      assert(AllocateArrayNode::Ideal_array_allocation(rawoop) == alloc->as_AllocateArray(),\n@@ -4011,1 +4016,1 @@\n-      assert(AllocateArrayNode::Ideal_array_allocation(javaoop, &_gvn) == alloc->as_AllocateArray(),\n+      assert(AllocateArrayNode::Ideal_array_allocation(javaoop) == alloc->as_AllocateArray(),\n@@ -4357,1 +4362,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase) {\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr) {\n@@ -4384,1 +4389,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase,\n@@ -4388,1 +4393,1 @@\n-  return Ideal_allocation(base, phase);\n+  return Ideal_allocation(base);\n@@ -4435,6 +4440,7 @@\n-  Node* cont    = _gvn.intcon(1);\n-  Node* opq     = _gvn.transform(new Opaque1Node(C, cont));\n-  Node* bol     = _gvn.transform(new Conv2BNode(opq));\n-  IfNode* iff   = create_and_map_if(control(), bol, PROB_MAX, COUNT_UNKNOWN);\n-  Node* iffalse = _gvn.transform(new IfFalseNode(iff));\n-  C->add_parse_predicate_opaq(opq);\n+  Node* cont = _gvn.intcon(1);\n+  Node* opaq = _gvn.transform(new Opaque1Node(C, cont));\n+  C->add_parse_predicate_opaq(opaq);\n+  Node* bol = _gvn.transform(new Conv2BNode(opaq));\n+  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), bol, reason);\n+  _gvn.set_type(parse_predicate, parse_predicate->Value(&_gvn));\n+  Node* if_false = _gvn.transform(new IfFalseNode(parse_predicate));\n@@ -4443,1 +4449,1 @@\n-    set_control(iffalse);\n+    set_control(if_false);\n@@ -4447,2 +4453,2 @@\n-  Node* iftrue = _gvn.transform(new IfTrueNode(iff));\n-  set_control(iftrue);\n+  Node* if_true = _gvn.transform(new IfTrueNode(parse_predicate));\n+  set_control(if_true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#if 0\n@@ -95,0 +96,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-  phi->add_req(NULL);\n+  phi->add_req(nullptr);\n@@ -209,1 +209,1 @@\n-  phi->add_req(NULL);\n+  phi->add_req(nullptr);\n@@ -213,1 +213,1 @@\n-  phi->add_req(NULL);\n+  phi->add_req(nullptr);\n@@ -221,1 +221,1 @@\n-      val->as_Phi()->add_req(NULL);\n+      val->as_Phi()->add_req(nullptr);\n@@ -240,1 +240,1 @@\n-  assert(value != NULL, \"field value not found\");\n+  assert(value != nullptr, \"field value not found\");\n@@ -334,1 +334,1 @@\n-  assert(jvms != NULL, \"missing JVMS\");\n+  assert(jvms != nullptr, \"missing JVMS\");\n@@ -337,3 +337,1 @@\n-#ifdef ASSERT\n-                                                                  NULL,\n-#endif\n+                                                                  nullptr,\n@@ -350,1 +348,1 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(get_oop(), igvn);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(get_oop());\n@@ -379,1 +377,1 @@\n-    if (debug != NULL && debug->uncast() == this) {\n+    if (debug != nullptr && debug->uncast() == this) {\n@@ -415,1 +413,1 @@\n-        if (debug != NULL && debug->uncast() == this) {\n+        if (debug != nullptr && debug->uncast() == this) {\n@@ -436,2 +434,2 @@\n-  const TypePtr* adr_type = NULL;\n-  bool is_array = ary_type != NULL;\n+  const TypePtr* adr_type = nullptr;\n+  bool is_array = ary_type != nullptr;\n@@ -445,1 +443,1 @@\n-    assert(field != NULL, \"field not found\");\n+    assert(field != nullptr, \"field not found\");\n@@ -498,1 +496,1 @@\n-    Node* value = NULL;\n+    Node* value = nullptr;\n@@ -510,1 +508,1 @@\n-      bool is_array = (oop_ptr->isa_aryptr() != NULL);\n+      bool is_array = (oop_ptr->isa_aryptr() != nullptr);\n@@ -517,1 +515,1 @@\n-        assert(field != NULL, \"field not found\");\n+        assert(field != nullptr, \"field not found\");\n@@ -520,1 +518,1 @@\n-        assert(con_type != NULL, \"type not found\");\n+        assert(con_type != nullptr, \"type not found\");\n@@ -561,1 +559,1 @@\n-  if (holder == NULL) {\n+  if (holder == nullptr) {\n@@ -653,1 +651,1 @@\n-    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, this);\n+    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true, this);\n@@ -658,2 +656,2 @@\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit->gvn());\n-    assert(alloc != NULL, \"must have an allocation node\");\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+    assert(alloc != nullptr, \"must have an allocation node\");\n@@ -697,2 +695,1 @@\n-  const Type* oop_type = (phase != NULL) ? phase->type(oop) : oop->bottom_type();\n-  \/\/ Primitive objects are always null free.\n+  const Type* oop_type = (phase != nullptr) ? phase->type(oop) : oop->bottom_type();\n@@ -711,1 +708,1 @@\n-    Node* field = NULL;\n+    Node* field = nullptr;\n@@ -729,1 +726,1 @@\n-    if (field != NULL) {\n+    if (field != nullptr) {\n@@ -763,1 +760,1 @@\n-        if (store != NULL) {\n+        if (store != nullptr) {\n@@ -808,1 +805,1 @@\n-    if (base != NULL && !phase->type(base)->maybe_null()) {\n+    if (base != nullptr && !phase->type(base)->maybe_null()) {\n@@ -824,1 +821,1 @@\n-        if (alloc != NULL && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n@@ -827,1 +824,1 @@\n-          if (res != NULL && res->is_CheckCastPP()) {\n+          if (res != nullptr && res->is_CheckCastPP()) {\n@@ -838,1 +835,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -842,1 +839,1 @@\n-  \/\/ Create a new InlineTypeNode with uninitialized values and NULL oop\n+  \/\/ Create a new InlineTypeNode with uninitialized values and nullptr oop\n@@ -943,1 +940,1 @@\n-  InlineTypeNode* vt = NULL;\n+  InlineTypeNode* vt = nullptr;\n@@ -968,1 +965,1 @@\n-      InlineTypeNode* null_vt = NULL;\n+      InlineTypeNode* null_vt = nullptr;\n@@ -994,1 +991,1 @@\n-\/\/           AllocateNode::Ideal_allocation(oop, &gvn) != NULL || vt->as_InlineType()->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n+\/\/           AllocateNode::Ideal_allocation(oop, &gvn) != nullptr || vt->as_InlineType()->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n@@ -1032,1 +1029,1 @@\n-  vt->initialize_fields(kit, multi, base_input, in, null_free, NULL, visited);\n+  vt->initialize_fields(kit, multi, base_input, in, null_free, nullptr, visited);\n@@ -1048,2 +1045,2 @@\n-    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, true);\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit->gvn());\n+    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n@@ -1065,1 +1062,1 @@\n-  Node* mark = kit->make_load(NULL, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  Node* mark = kit->make_load(nullptr, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n@@ -1071,2 +1068,2 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(obj, &kit->gvn());\n-  assert(alloc != NULL, \"must have an allocation node\");\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(obj);\n+  assert(alloc != nullptr, \"must have an allocation node\");\n@@ -1092,2 +1089,2 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(oop, gvn);\n-  return alloc != NULL && alloc->_larval;\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(oop);\n+  return alloc != nullptr && alloc->_larval;\n@@ -1097,1 +1094,1 @@\n-  if (vk == NULL) {\n+  if (vk == nullptr) {\n@@ -1107,1 +1104,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1120,2 +1117,2 @@\n-        if (base == NULL) {\n-          return NULL;\n+        if (base == nullptr) {\n+          return nullptr;\n@@ -1140,3 +1137,3 @@\n-      if (lbase == NULL || (lbase != base && base != NULL) || loffset != offset) {\n-        return NULL;\n-      } else if (base == NULL) {\n+      if (lbase == nullptr || (lbase != base && base != nullptr) || loffset != offset) {\n+        return nullptr;\n+      } else if (base == nullptr) {\n@@ -1146,2 +1143,2 @@\n-        if (vtptr == NULL || !vtptr->instance_klass()->equals(vk)) {\n-          return NULL;\n+        if (vtptr == nullptr || !vtptr->instance_klass()->equals(vk)) {\n+          return nullptr;\n@@ -1151,1 +1148,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1195,1 +1192,1 @@\n-  Node* is_init = NULL;\n+  Node* is_init = nullptr;\n@@ -1209,2 +1206,2 @@\n-    assert(null_check_region == NULL, \"already set\");\n-    if (is_init == NULL) {\n+    assert(null_check_region == nullptr, \"already set\");\n+    if (is_init == nullptr) {\n@@ -1226,1 +1223,1 @@\n-    Node* parm = NULL;\n+    Node* parm = nullptr;\n@@ -1263,1 +1260,1 @@\n-        if (null_check_region != NULL) {\n+        if (null_check_region != nullptr) {\n@@ -1267,1 +1264,1 @@\n-          \/\/ Holder is nullable, set field to NULL if holder is NULL to avoid loading from uninitialized memory\n+          \/\/ Holder is nullable, set field to nullptr if holder is nullptr to avoid loading from uninitialized memory\n@@ -1283,2 +1280,2 @@\n-    assert(parm != NULL, \"should never be null\");\n-    assert(field_value(i) == NULL, \"already set\");\n+    assert(parm != nullptr, \"should never be null\");\n+    assert(field_value(i) == nullptr, \"already set\");\n@@ -1308,1 +1305,1 @@\n-    if (alloc != NULL && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n@@ -1310,1 +1307,1 @@\n-      if (res == NULL || !res->is_CheckCastPP()) {\n+      if (res == nullptr || !res->is_CheckCastPP()) {\n@@ -1318,1 +1315,1 @@\n-        if (alloc_other != NULL && alloc_other->in(AllocateNode::InlineType) == this && !alloc_other->_is_scalar_replaceable) {\n+        if (alloc_other != nullptr && alloc_other->in(AllocateNode::InlineType) == this && !alloc_other->_is_scalar_replaceable) {\n@@ -1320,1 +1317,1 @@\n-          if (res_other != NULL && res_other->is_CheckCastPP() && res_other != res_dom &&\n+          if (res_other != nullptr && res_other->is_CheckCastPP() && res_other != res_dom &&\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":63,"deletions":66,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-         IsBuffered, \/\/ True if inline type is heap allocated (or NULL), false otherwise.\n-         IsInit,     \/\/ Needs to be checked for NULL before using the field values.\n+         IsBuffered, \/\/ True if inline type is heap allocated (or nullptr), false otherwise.\n+         IsInit,     \/\/ Needs to be checked for nullptr before using the field values.\n@@ -68,1 +68,1 @@\n-  Node* is_loaded(PhaseGVN* phase, ciInlineKlass* vk = NULL, Node* base = NULL, int holder_offset = 0);\n+  Node* is_loaded(PhaseGVN* phase, ciInlineKlass* vk = nullptr, Node* base = nullptr, int holder_offset = 0);\n@@ -91,1 +91,1 @@\n-  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = NULL, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n@@ -145,1 +145,1 @@\n-  void store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = NULL, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n+  void store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+  case vmIntrinsics::_jvm_commit:               return inline_native_jvm_commit();\n@@ -711,0 +712,2 @@\n+  case vmIntrinsics::_VectorShuffleIota:\n+    return inline_vector_shuffle_iota();\n@@ -713,0 +716,2 @@\n+  case vmIntrinsics::_VectorShuffleToVector:\n+    return inline_vector_shuffle_to_vector();\n@@ -2351,2 +2356,2 @@\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(base, &_gvn);\n-      if (alloc != NULL) {\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+      if (alloc != nullptr) {\n@@ -2661,1 +2666,1 @@\n-  if (AllocateNode::Ideal_allocation(vt->get_oop(), &_gvn) == nullptr) {\n+  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n@@ -3229,0 +3234,130 @@\n+\/\/------------------------inline_native_jvm_commit------------------\n+bool LibraryCallKit::inline_native_jvm_commit() {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory and i_o state.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+  Node* input_io_state = i_o();\n+\n+  \/\/ TLS.\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  \/\/ Jfr java buffer.\n+  Node* java_buffer_offset = _gvn.transform(new AddPNode(top(), tls_ptr, _gvn.transform(MakeConX(in_bytes(JAVA_BUFFER_OFFSET_JFR)))));\n+  Node* java_buffer = _gvn.transform(new LoadPNode(control(), input_memory_state, java_buffer_offset, TypePtr::BOTTOM, TypeRawPtr::NOTNULL, MemNode::unordered));\n+  Node* java_buffer_pos_offset = _gvn.transform(new AddPNode(top(), java_buffer, _gvn.transform(MakeConX(in_bytes(JFR_BUFFER_POS_OFFSET)))));\n+\n+  \/\/ Load the current value of the notified field in the JfrThreadLocal.\n+  Node* notified_offset = basic_plus_adr(top(), tls_ptr, in_bytes(NOTIFY_OFFSET_JFR));\n+  Node* notified = make_load(control(), notified_offset, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n+  \/\/ Test for notification.\n+  Node* notified_cmp = _gvn.transform(new CmpINode(notified, _gvn.intcon(1)));\n+  Node* test_notified = _gvn.transform(new BoolNode(notified_cmp, BoolTest::eq));\n+  IfNode* iff_notified = create_and_map_if(control(), test_notified, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ True branch, is notified.\n+  Node* is_notified = _gvn.transform(new IfTrueNode(iff_notified));\n+  set_control(is_notified);\n+\n+  \/\/ Reset notified state.\n+  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ Iff notified, the return address of the commit method is the current position of the backing java buffer. This is used to reset the event writer.\n+  Node* current_pos_X = _gvn.transform(new LoadXNode(control(), input_memory_state, java_buffer_pos_offset, TypeRawPtr::NOTNULL, TypeX_X, MemNode::unordered));\n+  \/\/ Convert the machine-word to a long.\n+  Node* current_pos = _gvn.transform(ConvX2L(current_pos_X));\n+\n+  \/\/ False branch, not notified.\n+  Node* not_notified = _gvn.transform(new IfFalseNode(iff_notified));\n+  set_control(not_notified);\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ Arg is the next position as a long.\n+  Node* arg = argument(0);\n+  \/\/ Convert long to machine-word.\n+  Node* next_pos_X = _gvn.transform(ConvL2X(arg));\n+\n+  \/\/ Store the next_position to the underlying jfr java buffer.\n+  Node* commit_memory;\n+#ifdef _LP64\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, Compile::AliasIdxRaw, MemNode::release);\n+#else\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, Compile::AliasIdxRaw, MemNode::release);\n+#endif\n+\n+  \/\/ Now load the flags from off the java buffer and decide if the buffer is a lease. If so, it needs to be returned post-commit.\n+  Node* java_buffer_flags_offset = _gvn.transform(new AddPNode(top(), java_buffer, _gvn.transform(MakeConX(in_bytes(JFR_BUFFER_FLAGS_OFFSET)))));\n+  Node* flags = make_load(control(), java_buffer_flags_offset, TypeInt::UBYTE, T_BYTE, MemNode::unordered);\n+  Node* lease_constant = _gvn.transform(_gvn.intcon(4));\n+\n+  \/\/ And flags with lease constant.\n+  Node* lease = _gvn.transform(new AndINode(flags, lease_constant));\n+\n+  \/\/ Branch on lease to conditionalize returning the leased java buffer.\n+  Node* lease_cmp = _gvn.transform(new CmpINode(lease, lease_constant));\n+  Node* test_lease = _gvn.transform(new BoolNode(lease_cmp, BoolTest::eq));\n+  IfNode* iff_lease = create_and_map_if(control(), test_lease, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, not a lease.\n+  Node* not_lease = _gvn.transform(new IfFalseNode(iff_lease));\n+\n+  \/\/ True branch, is lease.\n+  Node* is_lease = _gvn.transform(new IfTrueNode(iff_lease));\n+  set_control(is_lease);\n+\n+  \/\/ Make a runtime call, which can safepoint, to return the leased buffer. This updates both the JfrThreadLocal and the Java event writer oop.\n+  Node* call_return_lease = make_runtime_call(RC_NO_LEAF,\n+                                              OptoRuntime::void_void_Type(),\n+                                              StubRoutines::jfr_return_lease(),\n+                                              \"return_lease\", TypePtr::BOTTOM);\n+  Node* call_return_lease_control = _gvn.transform(new ProjNode(call_return_lease, TypeFunc::Control));\n+\n+  RegionNode* lease_compare_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(lease_compare_rgn);\n+  PhiNode* lease_compare_mem = new PhiNode(lease_compare_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(lease_compare_mem);\n+  PhiNode* lease_compare_io = new PhiNode(lease_compare_rgn, Type::ABIO);\n+  record_for_igvn(lease_compare_io);\n+  PhiNode* lease_result_value = new PhiNode(lease_compare_rgn, TypeLong::LONG);\n+  record_for_igvn(lease_result_value);\n+\n+  \/\/ Update control and phi nodes.\n+  lease_compare_rgn->init_req(_true_path, call_return_lease_control);\n+  lease_compare_rgn->init_req(_false_path, not_lease);\n+\n+  lease_compare_mem->init_req(_true_path, _gvn.transform(reset_memory()));\n+  lease_compare_mem->init_req(_false_path, commit_memory);\n+\n+  lease_compare_io->init_req(_true_path, i_o());\n+  lease_compare_io->init_req(_false_path, input_io_state);\n+\n+  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_false_path, arg); \/\/ if not lease, return new updated position.\n+\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  PhiNode* result_io = new PhiNode(result_rgn, Type::ABIO);\n+  PhiNode* result_value = new PhiNode(result_rgn, TypeLong::LONG);\n+\n+  \/\/ Update control and phi nodes.\n+  result_rgn->init_req(_true_path, is_notified);\n+  result_rgn->init_req(_false_path, _gvn.transform(lease_compare_rgn));\n+\n+  result_mem->init_req(_true_path, notified_reset_memory);\n+  result_mem->init_req(_false_path, _gvn.transform(lease_compare_mem));\n+\n+  result_io->init_req(_true_path, input_io_state);\n+  result_io->init_req(_false_path, _gvn.transform(lease_compare_io));\n+\n+  result_value->init_req(_true_path, current_pos);\n+  result_value->init_req(_false_path, _gvn.transform(lease_result_value));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+  set_i_o(_gvn.transform(result_io));\n+  set_result(result_rgn, result_value);\n+  return true;\n+}\n+\n@@ -3701,1 +3836,1 @@\n-  const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);\n+  const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n@@ -4286,0 +4421,1 @@\n+    null_check_receiver();\n@@ -4320,1 +4456,1 @@\n-      slow_call = generate_method_call(vmIntrinsics::_allocateUninitializedArray, false, false);\n+      slow_call = generate_method_call(vmIntrinsics::_allocateUninitializedArray, false, false, true);\n@@ -4322,1 +4458,1 @@\n-      slow_call = generate_method_call_static(vmIntrinsics::_newArray);\n+      slow_call = generate_method_call_static(vmIntrinsics::_newArray, true);\n@@ -4345,1 +4481,1 @@\n-      AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj, &_gvn);\n+      AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj);\n@@ -4611,1 +4747,1 @@\n-LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {\n+LibraryCallKit::generate_method_call(vmIntrinsicID method_id, bool is_virtual, bool is_static, bool res_not_null) {\n@@ -4620,0 +4756,8 @@\n+  if (res_not_null) {\n+    assert(tf->return_type() == T_OBJECT, \"\");\n+    const TypeTuple* range = tf->range_cc();\n+    const Type** fields = TypeTuple::fields(range->cnt());\n+    fields[TypeFunc::Parms] = range->field_at(TypeFunc::Parms)->filter_speculative(TypePtr::NOTNULL);\n+    const TypeTuple* new_range = TypeTuple::make(range->cnt(), fields);\n+    tf = TypeFunc::make(tf->domain_cc(), new_range);\n+  }\n@@ -4626,1 +4770,1 @@\n-    null_check_receiver();\n+    assert(!gvn().type(argument(0))->maybe_null(), \"should not be null\");\n@@ -4642,1 +4786,1 @@\n-    null_check_receiver();\n+    assert(!gvn().type(argument(0))->maybe_null(), \"should not be null\");\n@@ -4774,1 +4918,1 @@\n-    CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);\n+    CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static, false);\n@@ -5117,1 +5261,1 @@\n-    alloc = AllocateNode::Ideal_allocation(alloc_obj, &_gvn);\n+    alloc = AllocateNode::Ideal_allocation(alloc_obj);\n@@ -5325,1 +5469,1 @@\n-      CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);\n+      CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual, false, true);\n@@ -5865,1 +6009,1 @@\n-  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr, &_gvn);\n+  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":158,"deletions":14,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -201,7 +201,3 @@\n-  CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,\n-                                     bool is_virtual = false, bool is_static = false);\n-  CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {\n-    return generate_method_call(method_id, false, true);\n-  }\n-  CallJavaNode* generate_method_call_virtual(vmIntrinsics::ID method_id) {\n-    return generate_method_call(method_id, true, false);\n+  CallJavaNode* generate_method_call(vmIntrinsicID method_id, bool is_virtual, bool is_static, bool res_not_null);\n+  CallJavaNode* generate_method_call_static(vmIntrinsicID method_id, bool res_not_null) {\n+    return generate_method_call(method_id, false, true, res_not_null);\n@@ -280,0 +276,1 @@\n+  bool inline_native_jvm_commit();\n@@ -373,0 +370,2 @@\n+  bool inline_vector_shuffle_to_vector();\n+  bool inline_vector_shuffle_iota();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -560,2 +560,2 @@\n-Node* LoadNode::find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n-  ArrayCopyNode* ac = find_array_copy_clone(phase, ld_alloc, mem);\n+Node* LoadNode::find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n+  ArrayCopyNode* ac = find_array_copy_clone(ld_alloc, mem);\n@@ -616,1 +616,1 @@\n-ArrayCopyNode* MemNode::find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const {\n+ArrayCopyNode* MemNode::find_array_copy_clone(Node* ld_alloc, Node* mem) const {\n@@ -637,1 +637,1 @@\n-        AllocateNode* alloc = AllocateNode::Ideal_allocation(ac->in(ArrayCopyNode::Dest), phase);\n+        AllocateNode* alloc = AllocateNode::Ideal_allocation(ac->in(ArrayCopyNode::Dest));\n@@ -660,1 +660,1 @@\n-Node* MemNode::find_previous_store(PhaseTransform* phase) {\n+Node* MemNode::find_previous_store(PhaseValues* phase) {\n@@ -665,1 +665,1 @@\n-  AllocateNode* alloc  = AllocateNode::Ideal_allocation(base, phase);\n+  AllocateNode* alloc  = AllocateNode::Ideal_allocation(base);\n@@ -713,1 +713,1 @@\n-                                  AllocateNode::Ideal_allocation(st_base, phase),\n+                                  AllocateNode::Ideal_allocation(st_base),\n@@ -1063,1 +1063,1 @@\n-Node* MemNode::can_see_stored_value(Node* st, PhaseTransform* phase) const {\n+Node* MemNode::can_see_stored_value(Node* st, PhaseValues* phase) const {\n@@ -1067,1 +1067,1 @@\n-  Node* ld_alloc = AllocateNode::Ideal_allocation(ld_base, phase);\n+  Node* ld_alloc = AllocateNode::Ideal_allocation(ld_base);\n@@ -1175,1 +1175,1 @@\n-        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == nullptr) {\n+        if (ReduceBulkZeroing || find_array_copy_clone(ld_alloc, in(MemNode::Memory)) == nullptr) {\n@@ -1554,0 +1554,29 @@\n+\n+\/\/------------------------------split_through_phi------------------------------\n+\/\/ Check whether a call to 'split_through_phi' would split this load through the\n+\/\/ Phi *base*. This method is essentially a copy of the validations performed\n+\/\/ by 'split_through_phi'. The first use of this method was in EA code as part\n+\/\/ of simplification of allocation merges.\n+bool LoadNode::can_split_through_phi_base(PhaseGVN* phase) {\n+  Node* mem        = in(Memory);\n+  Node* address    = in(Address);\n+  intptr_t ignore  = 0;\n+  Node*    base    = AddPNode::Ideal_base_and_offset(address, phase, ignore);\n+  bool base_is_phi = (base != nullptr) && base->is_Phi();\n+\n+  if (req() > 3 || !base_is_phi) {\n+    return false;\n+  }\n+\n+  if (!mem->is_Phi()) {\n+    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+      return false;\n+  } else if (base->in(0) != mem->in(0)) {\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -1556,1 +1585,1 @@\n-Node* LoadNode::split_through_phi(PhaseGVN* phase) {\n+Node* LoadNode::split_through_phi(PhaseGVN* phase, bool ignore_missing_instance_id) {\n@@ -1567,1 +1596,2 @@\n-         (t_oop->is_known_instance_field() ||\n+         (ignore_missing_instance_id ||\n+          t_oop->is_known_instance_field() ||\n@@ -1579,2 +1609,2 @@\n-        (load_boxed_values || t_oop->is_known_instance_field()))) {\n-    return nullptr; \/\/ memory is not Phi\n+        (ignore_missing_instance_id || load_boxed_values || t_oop->is_known_instance_field()))) {\n+    return nullptr; \/\/ Neither memory or base are Phi\n@@ -1624,1 +1654,1 @@\n-  assert(C->have_alias_type(t_oop), \"instance should have alias type\");\n+  assert(ignore_missing_instance_id || C->have_alias_type(t_oop), \"instance should have alias type\");\n@@ -1660,0 +1690,1 @@\n+  Node* phi = nullptr;\n@@ -1661,8 +1692,11 @@\n-  int this_index  = C->get_alias_index(t_oop);\n-  int this_offset = t_oop->offset();\n-  int this_iid    = t_oop->instance_id();\n-  if (!t_oop->is_known_instance() && load_boxed_values) {\n-    \/\/ Use _idx of address base for boxed values.\n-    this_iid = base->_idx;\n-  }\n-  Node* phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n+  if (t_oop != nullptr && (t_oop->is_known_instance_field() || load_boxed_values)) {\n+    int this_index = C->get_alias_index(t_oop);\n+    int this_offset = t_oop->offset();\n+    int this_iid = t_oop->is_known_instance_field() ? t_oop->instance_id() : base->_idx;\n+    phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n+  } else if (ignore_missing_instance_id) {\n+    phi = new PhiNode(region, this_type, nullptr, mem->_idx);\n+  } else {\n+    return nullptr;\n+  }\n+\n@@ -1750,1 +1784,1 @@\n-AllocateNode* LoadNode::is_new_object_mark_load(PhaseGVN *phase) const {\n+AllocateNode* LoadNode::is_new_object_mark_load() const {\n@@ -1753,1 +1787,1 @@\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(address, phase);\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(address);\n@@ -2205,1 +2239,1 @@\n-  Node* alloc = is_new_object_mark_load(phase);\n+  Node* alloc = is_new_object_mark_load();\n@@ -2446,1 +2480,1 @@\n-  if (tary != nullptr && tary->elem() != Type::BOTTOM &&\n+  if (tary != nullptr &&\n@@ -2464,1 +2498,1 @@\n-      return tkls->is_aryklassptr()->elem();\n+      return tkls->is_aryklassptr()->elem()->isa_klassptr()->cast_to_exactness(tkls->klass_is_exact());\n@@ -2603,1 +2637,1 @@\n-    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base, phase);\n+    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base);\n@@ -2635,1 +2669,1 @@\n-    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base, phase);\n+    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base);\n@@ -2935,1 +2969,1 @@\n-bool StoreNode::value_never_loaded( PhaseTransform *phase) const {\n+bool StoreNode::value_never_loaded(PhaseValues* phase) const {\n@@ -3105,0 +3139,5 @@\n+\/\/ This method conservatively checks if the result of a LoadStoreNode is\n+\/\/ used, that is, if it returns true, then it is definitely the case that\n+\/\/ the result of the node is not needed.\n+\/\/ For example, GetAndAdd can be matched into a lock_add instead of a\n+\/\/ lock_xadd if the result of LoadStoreNode::result_not_used() is true\n@@ -3106,1 +3145,1 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n@@ -3108,1 +3147,8 @@\n-    if (x->Opcode() == Op_SCMemProj) continue;\n+    if (x->Opcode() == Op_SCMemProj) {\n+      continue;\n+    }\n+    if (x->bottom_type() == TypeTuple::MEMBAR &&\n+        !x->is_Call() &&\n+        x->Opcode() != Op_Blackhole) {\n+      continue;\n+    }\n@@ -3229,1 +3275,1 @@\n-bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseTransform* phase) {\n+bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseValues* phase) {\n@@ -3460,1 +3506,1 @@\n-      Node* alloc = AllocateNode::Ideal_allocation(in(MemBarNode::Precedent), phase);\n+      Node* alloc = AllocateNode::Ideal_allocation(in(MemBarNode::Precedent));\n@@ -3803,1 +3849,1 @@\n-intptr_t InitializeNode::get_store_offset(Node* st, PhaseTransform* phase) {\n+intptr_t InitializeNode::get_store_offset(Node* st, PhaseValues* phase) {\n@@ -4003,1 +4049,1 @@\n-                                                   PhaseTransform* phase) {\n+                                                   PhaseValues* phase) {\n@@ -4057,1 +4103,1 @@\n-                                          PhaseTransform* phase) {\n+                                          PhaseValues* phase) {\n@@ -4073,1 +4119,1 @@\n-                                       PhaseTransform* phase) {\n+                                       PhaseGVN* phase) {\n@@ -4621,1 +4667,1 @@\n-bool InitializeNode::stores_are_sane(PhaseTransform* phase) {\n+bool InitializeNode::stores_are_sane(PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":86,"deletions":40,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+class ParsePredicateNode;\n@@ -163,0 +164,1 @@\n+class SafePointScalarMergeNode;\n@@ -676,0 +678,1 @@\n+          DEFINE_CLASS_ID(ParsePredicate,         If, 3)\n@@ -737,0 +740,1 @@\n+      DEFINE_CLASS_ID(SafePointScalarMerge, Type, 10)\n@@ -841,1 +845,1 @@\n-  const juint class_id() const { return _class_id; }\n+  juint class_id() const { return _class_id; }\n@@ -843,1 +847,1 @@\n-  const juint flags() const { return _flags; }\n+  juint flags() const { return _flags; }\n@@ -960,0 +964,1 @@\n+  DEFINE_CLASS_QUERY(ParsePredicate)\n@@ -968,0 +973,1 @@\n+  DEFINE_CLASS_QUERY(SafePointScalarMerge)\n@@ -1045,0 +1051,5 @@\n+  \/\/ Is 'n' possibly a loop entry (i.e. a Parse Predicate projection)?\n+  static bool may_be_loop_entry(Node* n) {\n+    return n != nullptr && n->is_IfProj() && n->in(0)->is_ParsePredicate();\n+  }\n+\n@@ -1227,1 +1238,2 @@\n-  void dump_bfs(const int max_distance, Node* target, const char* options) const; \/\/ Print BFS traversal\n+  void dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st) const;\n+  void dump_bfs(const int max_distance, Node* target, const char* options) const; \/\/ directly to tty\n@@ -1563,0 +1575,6 @@\n+  Node_Array() : Node_Array(Thread::current()->resource_area()) {}\n+\n+  NONCOPYABLE(Node_Array);\n+  Node_Array& operator=(Node_Array&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_Array(Node_Array&&) = default;\n@@ -1564,1 +1582,0 @@\n-  Node_Array(Node_Array* na) : _a(na->_a), _max(na->_max), _nodes(na->_nodes) {}\n@@ -1588,0 +1605,6 @@\n+\n+  NONCOPYABLE(Node_List);\n+  Node_List& operator=(Node_List&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_List(Node_List&&) = default;\n+\n@@ -1622,0 +1645,5 @@\n+  NONCOPYABLE(Unique_Node_List);\n+  Unique_Node_List& operator=(Unique_Node_List&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Unique_Node_List(Unique_Node_List&&) = default;\n+\n@@ -1653,0 +1681,4 @@\n+  void ensure_empty() {\n+    assert(size() == 0, \"must be empty\");\n+    clear(); \/\/ just in case\n+  }\n@@ -1657,0 +1689,21 @@\n+  \/\/ If the idx of the Nodes change, we must recompute the VectorSet\n+  void recompute_idx_set() {\n+    _in_worklist.clear();\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      _in_worklist.set(n->_idx);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  bool is_subset_of(Unique_Node_List& other) {\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      if (!other.member(n)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+#endif\n+\n@@ -1699,1 +1752,1 @@\n-  _for_igvn->push(n);\n+  _igvn_worklist->push(n);\n@@ -1704,1 +1757,1 @@\n-  _for_igvn->remove(n);\n+  _igvn_worklist->remove(n);\n@@ -1775,0 +1828,2 @@\n+\n+  NONCOPYABLE(Node_Stack);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -798,1 +798,1 @@\n-    ObjectValue* sv = sv_for_node_id(objs, spobj->_idx);\n+    ObjectValue* sv = (ObjectValue*) sv_for_node_id(objs, spobj->_idx);\n@@ -838,0 +838,25 @@\n+  } else if (local->is_SafePointScalarMerge()) {\n+    SafePointScalarMergeNode* smerge = local->as_SafePointScalarMerge();\n+    ObjectMergeValue* mv = (ObjectMergeValue*) sv_for_node_id(objs, smerge->_idx);\n+\n+    if (mv == NULL) {\n+      GrowableArray<ScopeValue*> deps;\n+\n+      int merge_pointer_idx = smerge->merge_pointer_idx(sfpt->jvms());\n+      (void)FillLocArray(0, sfpt, sfpt->in(merge_pointer_idx), &deps, objs);\n+      assert(deps.length() == 1, \"missing value\");\n+\n+      int selector_idx = smerge->selector_idx(sfpt->jvms());\n+      (void)FillLocArray(1, NULL, sfpt->in(selector_idx), &deps, NULL);\n+      assert(deps.length() == 2, \"missing value\");\n+\n+      mv = new ObjectMergeValue(smerge->_idx, deps.at(0), deps.at(1));\n+      set_sv_for_object_node(objs, mv);\n+\n+      for (uint i = 1; i < smerge->req(); i++) {\n+        Node* obj_node = smerge->in(i);\n+        (void)FillLocArray(mv->possible_objects()->length(), sfpt, obj_node, mv->possible_objects(), objs);\n+      }\n+    }\n+    array->append(mv);\n+    return;\n@@ -1003,0 +1028,12 @@\n+\/\/ Determine if there is a monitor that has 'ov' as its owner.\n+bool PhaseOutput::contains_as_owner(GrowableArray<MonitorValue*> *monarray, ObjectValue *ov) const {\n+  for (int k = 0; k < monarray->length(); k++) {\n+    MonitorValue* mv = monarray->at(k);\n+    if (mv->owner() == ov) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -1137,0 +1174,15 @@\n+    \/\/ Mark ObjectValue nodes as root nodes if they are directly\n+    \/\/ referenced in the JVMS.\n+    for (int i = 0; i < objs->length(); i++) {\n+      ScopeValue* sv = objs->at(i);\n+      if (sv->is_object_merge()) {\n+        ObjectMergeValue* merge = sv->as_ObjectMergeValue();\n+\n+        for (int j = 0; j< merge->possible_objects()->length(); j++) {\n+          ObjectValue* ov = merge->possible_objects()->at(j)->as_ObjectValue();\n+          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n+          ov->set_root(is_root);\n+        }\n+      }\n+    }\n+\n@@ -2146,2 +2198,6 @@\n-    tty->print(\"\\n---- After ScheduleAndBundle ----\\n\");\n-    print_scheduling();\n+    \/\/ Buffer and print all at once\n+    ResourceMark rm;\n+    stringStream ss;\n+    ss.print(\"\\n---- After ScheduleAndBundle ----\\n\");\n+    print_scheduling(&ss);\n+    tty->print(\"%s\", ss.as_string());\n@@ -2155,0 +2211,4 @@\n+  print_scheduling(tty);\n+}\n+\n+void PhaseOutput::print_scheduling(outputStream* output_stream) {\n@@ -2156,1 +2216,1 @@\n-    tty->print(\"\\nBB#%03d:\\n\", i);\n+    output_stream->print(\"\\nBB#%03d:\\n\", i);\n@@ -2161,2 +2221,2 @@\n-      tty->print(\" %-6s \", reg >= 0 && reg < REG_COUNT ? Matcher::regName[reg] : \"\");\n-      n->dump();\n+      output_stream->print(\" %-6s \", reg >= 0 && reg < REG_COUNT ? Matcher::regName[reg] : \"\");\n+      n->dump(\"\\n\", false, output_stream);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":66,"deletions":6,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -54,5 +54,5 @@\n-int nodes_created              = 0;\n-int methods_parsed             = 0;\n-int methods_seen               = 0;\n-int blocks_parsed              = 0;\n-int blocks_seen                = 0;\n+uint nodes_created             = 0;\n+uint methods_parsed            = 0;\n+uint methods_seen              = 0;\n+uint blocks_parsed             = 0;\n+uint blocks_seen               = 0;\n@@ -60,4 +60,4 @@\n-int explicit_null_checks_inserted = 0;\n-int explicit_null_checks_elided   = 0;\n-int all_null_checks_found         = 0;\n-int implicit_null_checks          = 0;\n+uint explicit_null_checks_inserted = 0;\n+uint explicit_null_checks_elided   = 0;\n+uint all_null_checks_found         = 0;\n+uint implicit_null_checks          = 0;\n@@ -74,2 +74,2 @@\n-  tty->print(\"Methods seen: %d  Methods parsed: %d\", methods_seen, methods_parsed);\n-  tty->print(\"  Nodes created: %d\", nodes_created);\n+  tty->print(\"Methods seen: %u  Methods parsed: %u\", methods_seen, methods_parsed);\n+  tty->print(\"  Nodes created: %u\", nodes_created);\n@@ -80,1 +80,1 @@\n-  tty->print_cr(\"Blocks parsed: %d  Blocks seen: %d\", blocks_parsed, blocks_seen);\n+  tty->print_cr(\"Blocks parsed: %u  Blocks seen: %u\", blocks_parsed, blocks_seen);\n@@ -83,1 +83,1 @@\n-    tty->print_cr(\"%d original null checks - %d elided (%2d%%); optimizer leaves %d,\",\n+    tty->print_cr(\"%u original null checks - %u elided (%2u%%); optimizer leaves %u,\",\n@@ -89,1 +89,1 @@\n-    tty->print_cr(\"%d made implicit (%2d%%)\", implicit_null_checks,\n+    tty->print_cr(\"%u made implicit (%2u%%)\", implicit_null_checks,\n@@ -93,1 +93,1 @@\n-    tty->print_cr(\"%d implicit null exceptions at runtime\",\n+    tty->print_cr(\"%u implicit null exceptions at runtime\",\n@@ -1092,1 +1092,1 @@\n-      AllocateNode *alloc = AllocateNode::Ideal_allocation(alloc_with_final(), &_gvn);\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-  C->for_igvn()->clear();\n-  C->initial_gvn()->replace_with(&_igvn);\n+  C->igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -63,1 +62,1 @@\n-    PhaseRemoveUseless pru(C->initial_gvn(), C->for_igvn());\n+    PhaseRemoveUseless pru(C->initial_gvn(), *C->igvn_worklist());\n@@ -68,1 +67,1 @@\n-    _igvn = PhaseIterGVN(C->initial_gvn());\n+    _igvn.reset_from_gvn(C->initial_gvn());\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n@@ -155,0 +159,4 @@\n+  if (is_vector_shuffle(vbox_type->instance_klass())) {\n+    assert(elem_bt == T_BYTE, \"must be consistent with shuffle representation\");\n+  }\n+\n@@ -598,0 +606,111 @@\n+\/\/ <Sh extends VectorShuffle<E>,  E>\n+\/\/  Sh ShuffleIota(Class<?> E, Class<?> shuffleClass, Vector.Species<E> s, int length,\n+\/\/                  int start, int step, int wrap, ShuffleIotaOperation<Sh, E> defaultImpl)\n+bool LibraryCallKit::inline_vector_shuffle_iota() {\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     start_val     = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     step_val      = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     wrap          = gvn().type(argument(6))->isa_int();\n+\n+  if (shuffle_klass == nullptr || shuffle_klass->const_oop() == nullptr ||\n+      vlen == nullptr || !vlen->is_con() || start_val == nullptr || step_val == nullptr ||\n+      wrap == nullptr || !wrap->is_con()) {\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(shuffle_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  int do_wrap = wrap->get_con();\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = T_BYTE;\n+\n+  bool effective_indices_in_range = false;\n+  if (start_val->is_con() && step_val->is_con()) {\n+    int effective_min_index = start_val->get_con();\n+    int effective_max_index = start_val->get_con() + step_val->get_con() * (num_elem - 1);\n+    effective_indices_in_range = effective_max_index >= effective_min_index && effective_min_index >= -128 && effective_max_index <= 127;\n+  }\n+\n+  if (!do_wrap && !effective_indices_in_range) {\n+    \/\/ Disable instrinsification for unwrapped shuffle iota if start\/step\n+    \/\/ values are non-constant OR if intermediate result overflows byte value range.\n+    return false;\n+  }\n+\n+  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)           ||\n+      !arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)            ||\n+      !arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n+\n+  if (!do_wrap &&\n+      (!arch_supports_vector(Op_SubVB, num_elem, elem_bt, VecMaskNotUsed)       ||\n+      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskNotUsed)  ||\n+      !arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskNotUsed))) {\n+    return false;\n+  }\n+\n+  bool step_multiply = !step_val->is_con() || !is_power_of_2(step_val->get_con());\n+  if ((step_multiply && !arch_supports_vector(Op_MulVB, num_elem, elem_bt, VecMaskNotUsed)) ||\n+      (!step_multiply && !arch_supports_vector(Op_LShiftVB, num_elem, elem_bt, VecMaskNotUsed))) {\n+    return false;\n+  }\n+\n+  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n+\n+  Node* res = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n+\n+  Node* start = argument(4);\n+  Node* step  = argument(5);\n+\n+  if (step_multiply) {\n+    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n+    res = gvn().transform(VectorNode::make(Op_MulVB, res, bcast_step, vt));\n+  } else if (step_val->get_con() > 1) {\n+    Node* cnt = gvn().makecon(TypeInt::make(log2i_exact(step_val->get_con())));\n+    Node* shift_cnt = vector_shift_count(cnt, Op_LShiftI, elem_bt, num_elem);\n+    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, shift_cnt, vt));\n+  }\n+\n+  if (!start_val->is_con() || start_val->get_con() != 0) {\n+    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n+    res = gvn().transform(VectorNode::make(Op_AddVB, res, bcast_start, vt));\n+  }\n+\n+  Node * mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+\n+  if (do_wrap)  {\n+    \/\/ Wrap the indices greater than lane count.\n+     res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n+  } else {\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ugt));\n+    Node * lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n+    Node * bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n+    const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ugt, bcast_lane_cnt, res, pred_node, vmask_type));\n+\n+    \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n+    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n+    Node * biased_val = gvn().transform(VectorNode::make(Op_SubVB, res, bcast_lane_cnt, vt));\n+    res = gvn().transform(new VectorBlendNode(biased_val, res, mask));\n+  }\n+\n+  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  res = box_vector(res, shuffle_box_type, elem_bt, num_elem);\n+  set_result(res);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -658,0 +777,68 @@\n+\/\/ public static\n+\/\/ <V,\n+\/\/  Sh extends VectorShuffle<E>,\n+\/\/  E>\n+\/\/ V shuffleToVector(Class<? extends Vector<E>> vclass, Class<E> elementType,\n+\/\/                   Class<? extends Sh> shuffleClass, Sh s, int length,\n+\/\/                   ShuffleToVectorOperation<V, Sh, E> defaultImpl)\n+bool LibraryCallKit::inline_vector_shuffle_to_vector() {\n+  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->isa_instptr();\n+  Node*              shuffle       = argument(3);\n+  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n+\n+  if (vector_klass == nullptr || elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr) {\n+    return false; \/\/ dead code\n+  }\n+  if (!vlen->is_con() || vector_klass->const_oop() == nullptr || shuffle_klass->const_oop() == nullptr) {\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(shuffle_klass) || !is_klass_initialized(vector_klass) ) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  if (num_elem < 4) {\n+    return false;\n+  }\n+\n+  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n+  \/\/ Make sure that cast is implemented to particular type\/size combination.\n+  if (!arch_supports_vector(cast_vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+        cast_vopc, num_elem, type2name(elem_bt));\n+    }\n+    return false;\n+  }\n+\n+  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n+\n+  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n+  \/\/ shuffle is a byte array\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem);\n+  if (shuffle_vec == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ cast byte to target element type\n+  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vec_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  \/\/ Box vector\n+  Node* res = box_vector(shuffle_vec, vec_box_type, elem_bt, num_elem);\n+  set_result(res);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -1912,10 +2099,1 @@\n-\n-  BasicType shuffle_bt = elem_bt;\n-  if (shuffle_bt == T_FLOAT) {\n-    shuffle_bt = T_INT;\n-  } else if (shuffle_bt == T_DOUBLE) {\n-    shuffle_bt = T_LONG;\n-  }\n-\n-  bool need_load_shuffle = Matcher::vector_needs_load_shuffle(shuffle_bt, num_elem);\n-  if (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, shuffle_bt, VecMaskNotUsed)) {\n+  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -1927,1 +2105,1 @@\n-                    num_elem, type2name(shuffle_bt));\n+                    num_elem, type2name(elem_bt));\n@@ -1963,3 +2141,1 @@\n-  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);\n+  Node* shuffle = unbox_vector(argument(6), shbox_type, T_BYTE, num_elem);\n@@ -1985,4 +2161,1 @@\n-  if (need_load_shuffle) {\n-    shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, st));\n-  }\n-\n+  shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, TypeVect::make(elem_bt, num_elem)));\n@@ -1995,0 +2168,1 @@\n+      const TypeVect* vt = v1->bottom_type()->is_vect();\n@@ -2288,1 +2462,3 @@\n-\n+  if (is_vector_shuffle(vbox_klass_from)) {\n+    return false; \/\/ vector shuffles aren't supported\n+  }\n@@ -2538,1 +2714,1 @@\n-\/\/  <V extends Vector<E>,\n+\/\/  <VM extends VectorPayload,\n@@ -2540,3 +2716,4 @@\n-\/\/  long extract(Class<? extends V> vectorClass, Class<E> elementType, int vlen,\n-\/\/               V vec, int ix,\n-\/\/               VecExtractOp<V> defaultImpl)\n+\/\/  long extract(Class<? extends VM> vClass, Class<E> eClass,\n+\/\/               int length,\n+\/\/               VM vm, int i,\n+\/\/               VecExtractOp<VM> defaultImpl)\n@@ -2552,1 +2729,1 @@\n-  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -2554,1 +2731,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2557,2 +2734,1 @@\n-                    NodeClassNames[argument(2)->Opcode()],\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()]);\n@@ -2577,8 +2753,0 @@\n-  int vopc = ExtractNode::opcode(elem_bt);\n-  if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n-                    num_elem, type2name(elem_bt));\n-    }\n-    return false; \/\/ not supported\n-  }\n@@ -2589,4 +2757,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n-  if (opd == nullptr) {\n-    return false;\n-  }\n+  Node* opd = nullptr;\n@@ -2594,2 +2759,2 @@\n-  ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n-  Node* operation = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n+  if (is_vector_mask(vbox_klass)) {\n+    \/\/ vbox_klass is mask. This is used for VectorMask.laneIsSet(int).\n@@ -2597,7 +2762,28 @@\n-  Node* bits = nullptr;\n-  switch (elem_bt) {\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT: {\n-      bits = gvn().transform(new ConvI2LNode(operation));\n-      break;\n+    Node* pos = argument(4); \/\/ can be variable\n+    if (arch_supports_vector(Op_ExtractUB, num_elem, elem_bt, VecMaskUseAll)) {\n+      \/\/ Transform mask to vector with type of boolean and utilize ExtractUB node.\n+      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      if (opd == nullptr) {\n+        return false;\n+      }\n+      opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));\n+      opd = gvn().transform(new ExtractUBNode(opd, pos));\n+      opd = gvn().transform(new ConvI2LNode(opd));\n+    } else if (arch_supports_vector(Op_VectorMaskToLong, num_elem, elem_bt, VecMaskUseLoad)) {\n+      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      if (opd == nullptr) {\n+        return false;\n+      }\n+      \/\/ VectorMaskToLongNode requires the input is either a mask or a vector with BOOLEAN type.\n+      if (opd->bottom_type()->isa_vectmask() == nullptr) {\n+        opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));\n+      }\n+      \/\/ ((toLong() >>> pos) & 1L\n+      opd = gvn().transform(new VectorMaskToLongNode(opd, TypeLong::LONG));\n+      opd = gvn().transform(new URShiftLNode(opd, pos));\n+      opd = gvn().transform(new AndLNode(opd, gvn().makecon(TypeLong::ONE)));\n+    } else {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected mask extraction because architecture does not support it\");\n+      }\n+      return false; \/\/ not supported\n@@ -2605,4 +2791,7 @@\n-    case T_FLOAT: {\n-      bits = gvn().transform(new MoveF2INode(operation));\n-      bits = gvn().transform(new ConvI2LNode(bits));\n-      break;\n+  } else {\n+    \/\/ vbox_klass is vector. This is used for Vector.lane(int).\n+    if (!idx->is_con()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n+      }\n+      return false; \/\/ not enough info for intrinsification\n@@ -2610,3 +2799,8 @@\n-    case T_DOUBLE: {\n-      bits = gvn().transform(new MoveD2LNode(operation));\n-      break;\n+\n+    int vopc = ExtractNode::opcode(elem_bt);\n+    if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n+                      num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n@@ -2614,3 +2808,4 @@\n-    case T_LONG: {\n-      bits = operation; \/\/ no conversion needed\n-      break;\n+\n+    opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+    if (opd == nullptr) {\n+      return false;\n@@ -2618,2 +2813,1 @@\n-    default: fatal(\"%s\", type2name(elem_bt));\n-  }\n+    ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n@@ -2621,1 +2815,25 @@\n-  set_result(bits);\n+    opd = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n+    switch (elem_bt) {\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT: {\n+        opd = gvn().transform(new ConvI2LNode(opd));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        opd = gvn().transform(new MoveF2INode(opd));\n+        opd = gvn().transform(new ConvI2LNode(opd));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        opd = gvn().transform(new MoveD2LNode(opd));\n+        break;\n+      }\n+      case T_LONG: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+  }\n+  set_result(opd);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":279,"deletions":61,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    return (bt == T_FLOAT ? Op_CMoveVF : 0);\n+    return (bt == T_FLOAT ? Op_VectorBlend : 0);\n@@ -88,1 +88,3 @@\n-    return (bt == T_DOUBLE ? Op_CMoveVD : 0);\n+    return (bt == T_DOUBLE ? Op_VectorBlend : 0);\n+  case Op_Bool:\n+    return Op_VectorMaskCmp;\n@@ -687,4 +689,0 @@\n-  case Op_CMoveI:  case Op_CMoveL:  case Op_CMoveF:  case Op_CMoveD:\n-    *start = 2;\n-    *end   = n->req();\n-    break;\n@@ -1212,1 +1210,1 @@\n-\/\/ Extract a scalar element of vector.\n+\/\/ Extract a scalar element of vector by constant position.\n@@ -1214,1 +1212,2 @@\n-  assert(pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n+  assert(pos->get_int() >= 0 &&\n+         pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -396,16 +396,0 @@\n-\/\/------------------------------CMoveVFNode--------------------------------------\n-\/\/ Vector float conditional move\n-class CMoveVFNode : public VectorNode {\n-public:\n-  CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------CMoveVDNode--------------------------------------\n-\/\/ Vector double conditional move\n-class CMoveVDNode : public VectorNode {\n-public:\n-  CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n@@ -1300,3 +1284,1 @@\n-  ExtractNode(Node* src, ConINode* pos) : Node(nullptr, src, (Node*)pos) {\n-    assert(in(2)->get_int() >= 0, \"positive constants\");\n-  }\n+  ExtractNode(Node* src, Node* pos) : Node(nullptr, src, pos) {}\n@@ -1304,2 +1286,0 @@\n-  uint  pos() const { return in(2)->get_int(); }\n-\n@@ -1314,1 +1294,1 @@\n-  ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractBNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1324,1 +1304,1 @@\n-  ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractUBNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1326,1 +1306,1 @@\n-  virtual const Type* bottom_type() const { return TypeInt::UBYTE; }\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n@@ -1334,1 +1314,1 @@\n-  ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractCNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1344,1 +1324,1 @@\n-  ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractSNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1354,1 +1334,1 @@\n-  ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractINode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1364,1 +1344,1 @@\n-  ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractLNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1374,1 +1354,1 @@\n-  ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractFNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1384,1 +1364,1 @@\n-  ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractDNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1502,1 +1482,3 @@\n-    : VectorNode(in, vt) {}\n+    : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be BYTE\");\n+  }\n@@ -1504,0 +1486,1 @@\n+  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -89,1 +90,0 @@\n-bool   Arguments::_xdebug_mode                  = false;\n@@ -516,1 +516,0 @@\n-  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -524,1 +523,0 @@\n-  { \"G1UsePreventiveGC\",            JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -1154,1 +1152,1 @@\n-                  \"Did you mean '%s%s%s'? \",\n+                  \"Did you mean '%s%s%s'?\\n\",\n@@ -1918,1 +1916,1 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n@@ -1928,1 +1926,1 @@\n-                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\", LockingMode);\n+                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\\n\", LockingMode);\n@@ -1937,1 +1935,1 @@\n-                \"LockingMode == 0 (LM_MONITOR) is not fully implemented on this architecture\");\n+                \"LockingMode == 0 (LM_MONITOR) is not fully implemented on this architecture\\n\");\n@@ -1941,1 +1939,1 @@\n-#if (defined(X86) || defined(PPC64)) && !defined(ZERO)\n+#if defined(X86) && !defined(ZERO)\n@@ -1944,1 +1942,1 @@\n-                \"LockingMode == 0 (LM_MONITOR) and -XX:+UseRTMForStackLocks are mutually exclusive\");\n+                \"LockingMode == 0 (LM_MONITOR) and -XX:+UseRTMForStackLocks are mutually exclusive\\n\");\n@@ -1951,1 +1949,1 @@\n-                \"-XX:+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\");\n+                \"-XX:+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\\n\");\n@@ -2735,2 +2733,1 @@\n-      \/\/ note this flag has been used, then ignore\n-      set_xdebug_mode(true);\n+      warning(\"Option -Xdebug was deprecated in JDK 22 and will likely be removed in a future release.\");\n@@ -2739,1 +2736,1 @@\n-      \/\/ For compatibility with classic. HotSpot refuses to load the old style agent.dll.\n+      warning(\"Option -Xnoagent was deprecated in JDK 22 and will likely be removed in a future release.\");\n@@ -2906,1 +2903,1 @@\n-    } else if (match_option(option, \"-XX:-EnableJVMCIProduct\")) {\n+    } else if (match_option(option, \"-XX:-EnableJVMCIProduct\") || match_option(option, \"-XX:-UseGraalJIT\")) {\n@@ -2909,1 +2906,1 @@\n-                  \"-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\\n\");\n+                  \"-XX:-EnableJVMCIProduct or -XX:-UseGraalJIT cannot come after -XX:+EnableJVMCIProduct or -XX:+UseGraalJIT\\n\");\n@@ -2912,2 +2909,16 @@\n-    } else if (match_option(option, \"-XX:+EnableJVMCIProduct\")) {\n-      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" has been specified before\n+    } else if (match_option(option, \"-XX:+EnableJVMCIProduct\") || match_option(option, \"-XX:+UseGraalJIT\")) {\n+      bool use_graal_jit = match_option(option, \"-XX:+UseGraalJIT\");\n+      if (use_graal_jit) {\n+        const char* jvmci_compiler = get_property(\"jvmci.Compiler\");\n+        if (jvmci_compiler != nullptr) {\n+          if (strncmp(jvmci_compiler, \"graal\", strlen(\"graal\")) != 0) {\n+            jio_fprintf(defaultStream::error_stream(),\n+              \"Value of jvmci.Compiler incompatible with +UseGraalJIT: %s\\n\", jvmci_compiler);\n+            return JNI_ERR;\n+          }\n+        } else if (!add_property(\"jvmci.Compiler=graal\")) {\n+            return JNI_ENOMEM;\n+        }\n+      }\n+\n+      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" or \"-XX:+UseGraalJIT\" has been specified before\n@@ -2920,1 +2931,1 @@\n-        if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {\n+        if (!JVMCIGlobals::enable_jvmci_product_mode(origin, use_graal_jit)) {\n@@ -2922,1 +2933,1 @@\n-            \"Unable to enable JVMCI in product mode\");\n+            \"Unable to enable JVMCI in product mode\\n\");\n@@ -2927,1 +2938,1 @@\n-      else if (!process_argument(\"EnableJVMCIProduct\", args->ignoreUnrecognized, origin)) {\n+      else if (!process_argument(use_graal_jit ? \"UseGraalJIT\" : \"EnableJVMCIProduct\", args->ignoreUnrecognized, origin)) {\n@@ -4037,1 +4048,1 @@\n-                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", nullptr);\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\\n\");\n@@ -4050,0 +4061,6 @@\n+  bool log_class_load_cause = log_is_enabled(Info, class, load, cause, native) ||\n+                              log_is_enabled(Info, class, load, cause);\n+  if (log_class_load_cause && LogClassLoadingCauseFor == nullptr) {\n+    warning(\"class load cause logging will not produce output without LogClassLoadingCauseFor\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":38,"deletions":21,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+\n+  \/\/ for JVM_ReadSystemPropertiesInfo\n+  static int value_offset_in_bytes()  { return (int)offset_of(PathString, _value);  }\n@@ -140,0 +143,4 @@\n+\n+  \/\/ for JVM_ReadSystemPropertiesInfo\n+  static int key_offset_in_bytes()  { return (int)offset_of(SystemProperty, _key);  }\n+  static int next_offset_in_bytes() { return (int)offset_of(SystemProperty, _next); }\n@@ -247,5 +254,0 @@\n-  \/\/ -Xdebug flag\n-  static bool _xdebug_mode;\n-  static void set_xdebug_mode(bool arg) { _xdebug_mode = arg; }\n-  static bool xdebug_mode()             { return _xdebug_mode; }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -339,1 +340,1 @@\n-  GrowableArray<ScopeValue*>* objects = chunk->at(0)->scope()->objects();\n+  GrowableArray<ScopeValue*>* objects = chunk->at(0)->scope()->objects_to_rematerialize(deoptee, map);\n@@ -1715,0 +1716,1 @@\n+    assert(objects->at(i)->is_object(), \"invalid debug information\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        st->print(\"nullptr\");\n+        st->print(\"null\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,7 +144,7 @@\n-int SharedRuntime::_ic_miss_ctr = 0;\n-int SharedRuntime::_wrong_method_ctr = 0;\n-int SharedRuntime::_resolve_static_ctr = 0;\n-int SharedRuntime::_resolve_virtual_ctr = 0;\n-int SharedRuntime::_resolve_opt_virtual_ctr = 0;\n-int SharedRuntime::_implicit_null_throws = 0;\n-int SharedRuntime::_implicit_div0_throws = 0;\n+uint SharedRuntime::_ic_miss_ctr = 0;\n+uint SharedRuntime::_wrong_method_ctr = 0;\n+uint SharedRuntime::_resolve_static_ctr = 0;\n+uint SharedRuntime::_resolve_virtual_ctr = 0;\n+uint SharedRuntime::_resolve_opt_virtual_ctr = 0;\n+uint SharedRuntime::_implicit_null_throws = 0;\n+uint SharedRuntime::_implicit_div0_throws = 0;\n@@ -160,22 +160,22 @@\n-int SharedRuntime::_new_instance_ctr=0;\n-int SharedRuntime::_new_array_ctr=0;\n-int SharedRuntime::_multi2_ctr=0;\n-int SharedRuntime::_multi3_ctr=0;\n-int SharedRuntime::_multi4_ctr=0;\n-int SharedRuntime::_multi5_ctr=0;\n-int SharedRuntime::_mon_enter_stub_ctr=0;\n-int SharedRuntime::_mon_exit_stub_ctr=0;\n-int SharedRuntime::_mon_enter_ctr=0;\n-int SharedRuntime::_mon_exit_ctr=0;\n-int SharedRuntime::_partial_subtype_ctr=0;\n-int SharedRuntime::_jbyte_array_copy_ctr=0;\n-int SharedRuntime::_jshort_array_copy_ctr=0;\n-int SharedRuntime::_jint_array_copy_ctr=0;\n-int SharedRuntime::_jlong_array_copy_ctr=0;\n-int SharedRuntime::_oop_array_copy_ctr=0;\n-int SharedRuntime::_checkcast_array_copy_ctr=0;\n-int SharedRuntime::_unsafe_array_copy_ctr=0;\n-int SharedRuntime::_generic_array_copy_ctr=0;\n-int SharedRuntime::_slow_array_copy_ctr=0;\n-int SharedRuntime::_find_handler_ctr=0;\n-int SharedRuntime::_rethrow_ctr=0;\n+uint SharedRuntime::_new_instance_ctr=0;\n+uint SharedRuntime::_new_array_ctr=0;\n+uint SharedRuntime::_multi2_ctr=0;\n+uint SharedRuntime::_multi3_ctr=0;\n+uint SharedRuntime::_multi4_ctr=0;\n+uint SharedRuntime::_multi5_ctr=0;\n+uint SharedRuntime::_mon_enter_stub_ctr=0;\n+uint SharedRuntime::_mon_exit_stub_ctr=0;\n+uint SharedRuntime::_mon_enter_ctr=0;\n+uint SharedRuntime::_mon_exit_ctr=0;\n+uint SharedRuntime::_partial_subtype_ctr=0;\n+uint SharedRuntime::_jbyte_array_copy_ctr=0;\n+uint SharedRuntime::_jshort_array_copy_ctr=0;\n+uint SharedRuntime::_jint_array_copy_ctr=0;\n+uint SharedRuntime::_jlong_array_copy_ctr=0;\n+uint SharedRuntime::_oop_array_copy_ctr=0;\n+uint SharedRuntime::_checkcast_array_copy_ctr=0;\n+uint SharedRuntime::_unsafe_array_copy_ctr=0;\n+uint SharedRuntime::_generic_array_copy_ctr=0;\n+uint SharedRuntime::_slow_array_copy_ctr=0;\n+uint SharedRuntime::_find_handler_ctr=0;\n+uint SharedRuntime::_rethrow_ctr=0;\n@@ -486,0 +486,3 @@\n+  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n+\n@@ -1473,3 +1476,3 @@\n-  int *addr = (is_optimized) ? (&_resolve_opt_virtual_ctr) :\n-                (is_virtual) ? (&_resolve_virtual_ctr) :\n-                               (&_resolve_static_ctr);\n+  uint *addr = (is_optimized) ? (&_resolve_opt_virtual_ctr) :\n+                 (is_virtual) ? (&_resolve_virtual_ctr) :\n+                                (&_resolve_static_ctr);\n@@ -2076,1 +2079,1 @@\n-    assert(a->value() == b->value(), \"register allocation mismatch: a=\" INTX_FORMAT \", b=\" INTX_FORMAT, a->value(), b->value());\n+    assert(a->value() == b->value(), \"register allocation mismatch: a= %d, b= %d\", a->value(), b->value());\n@@ -2142,0 +2145,3 @@\n+  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, JavaThread::current()));\n+\n@@ -2154,3 +2160,0 @@\n-  assert(!JavaThread::current()->is_interp_only_mode() || !nm->method()->is_continuation_enter_intrinsic()\n-    || ContinuationEntry::is_interpreted_call(return_pc), \"interp_only_mode but not in enterSpecial interpreted entry\");\n-\n@@ -2194,2 +2197,0 @@\n-        assert(ContinuationEntry::is_interpreted_call(call->instruction_address()) == JavaThread::current()->is_interp_only_mode(),\n-          \"mode: %d\", JavaThread::current()->is_interp_only_mode());\n@@ -2356,29 +2357,29 @@\n-  if (_new_instance_ctr) tty->print_cr(\"%5d new instance requires GC\", _new_instance_ctr);\n-  if (_new_array_ctr) tty->print_cr(\"%5d new array requires GC\", _new_array_ctr);\n-  if (_multi2_ctr) tty->print_cr(\"%5d multianewarray 2 dim\", _multi2_ctr);\n-  if (_multi3_ctr) tty->print_cr(\"%5d multianewarray 3 dim\", _multi3_ctr);\n-  if (_multi4_ctr) tty->print_cr(\"%5d multianewarray 4 dim\", _multi4_ctr);\n-  if (_multi5_ctr) tty->print_cr(\"%5d multianewarray 5 dim\", _multi5_ctr);\n-\n-  tty->print_cr(\"%5d inline cache miss in compiled\", _ic_miss_ctr);\n-  tty->print_cr(\"%5d wrong method\", _wrong_method_ctr);\n-  tty->print_cr(\"%5d unresolved static call site\", _resolve_static_ctr);\n-  tty->print_cr(\"%5d unresolved virtual call site\", _resolve_virtual_ctr);\n-  tty->print_cr(\"%5d unresolved opt virtual call site\", _resolve_opt_virtual_ctr);\n-\n-  if (_mon_enter_stub_ctr) tty->print_cr(\"%5d monitor enter stub\", _mon_enter_stub_ctr);\n-  if (_mon_exit_stub_ctr) tty->print_cr(\"%5d monitor exit stub\", _mon_exit_stub_ctr);\n-  if (_mon_enter_ctr) tty->print_cr(\"%5d monitor enter slow\", _mon_enter_ctr);\n-  if (_mon_exit_ctr) tty->print_cr(\"%5d monitor exit slow\", _mon_exit_ctr);\n-  if (_partial_subtype_ctr) tty->print_cr(\"%5d slow partial subtype\", _partial_subtype_ctr);\n-  if (_jbyte_array_copy_ctr) tty->print_cr(\"%5d byte array copies\", _jbyte_array_copy_ctr);\n-  if (_jshort_array_copy_ctr) tty->print_cr(\"%5d short array copies\", _jshort_array_copy_ctr);\n-  if (_jint_array_copy_ctr) tty->print_cr(\"%5d int array copies\", _jint_array_copy_ctr);\n-  if (_jlong_array_copy_ctr) tty->print_cr(\"%5d long array copies\", _jlong_array_copy_ctr);\n-  if (_oop_array_copy_ctr) tty->print_cr(\"%5d oop array copies\", _oop_array_copy_ctr);\n-  if (_checkcast_array_copy_ctr) tty->print_cr(\"%5d checkcast array copies\", _checkcast_array_copy_ctr);\n-  if (_unsafe_array_copy_ctr) tty->print_cr(\"%5d unsafe array copies\", _unsafe_array_copy_ctr);\n-  if (_generic_array_copy_ctr) tty->print_cr(\"%5d generic array copies\", _generic_array_copy_ctr);\n-  if (_slow_array_copy_ctr) tty->print_cr(\"%5d slow array copies\", _slow_array_copy_ctr);\n-  if (_find_handler_ctr) tty->print_cr(\"%5d find exception handler\", _find_handler_ctr);\n-  if (_rethrow_ctr) tty->print_cr(\"%5d rethrow handler\", _rethrow_ctr);\n+  if (_new_instance_ctr) tty->print_cr(\"%5u new instance requires GC\", _new_instance_ctr);\n+  if (_new_array_ctr) tty->print_cr(\"%5u new array requires GC\", _new_array_ctr);\n+  if (_multi2_ctr) tty->print_cr(\"%5u multianewarray 2 dim\", _multi2_ctr);\n+  if (_multi3_ctr) tty->print_cr(\"%5u multianewarray 3 dim\", _multi3_ctr);\n+  if (_multi4_ctr) tty->print_cr(\"%5u multianewarray 4 dim\", _multi4_ctr);\n+  if (_multi5_ctr) tty->print_cr(\"%5u multianewarray 5 dim\", _multi5_ctr);\n+\n+  tty->print_cr(\"%5u inline cache miss in compiled\", _ic_miss_ctr);\n+  tty->print_cr(\"%5u wrong method\", _wrong_method_ctr);\n+  tty->print_cr(\"%5u unresolved static call site\", _resolve_static_ctr);\n+  tty->print_cr(\"%5u unresolved virtual call site\", _resolve_virtual_ctr);\n+  tty->print_cr(\"%5u unresolved opt virtual call site\", _resolve_opt_virtual_ctr);\n+\n+  if (_mon_enter_stub_ctr) tty->print_cr(\"%5u monitor enter stub\", _mon_enter_stub_ctr);\n+  if (_mon_exit_stub_ctr) tty->print_cr(\"%5u monitor exit stub\", _mon_exit_stub_ctr);\n+  if (_mon_enter_ctr) tty->print_cr(\"%5u monitor enter slow\", _mon_enter_ctr);\n+  if (_mon_exit_ctr) tty->print_cr(\"%5u monitor exit slow\", _mon_exit_ctr);\n+  if (_partial_subtype_ctr) tty->print_cr(\"%5u slow partial subtype\", _partial_subtype_ctr);\n+  if (_jbyte_array_copy_ctr) tty->print_cr(\"%5u byte array copies\", _jbyte_array_copy_ctr);\n+  if (_jshort_array_copy_ctr) tty->print_cr(\"%5u short array copies\", _jshort_array_copy_ctr);\n+  if (_jint_array_copy_ctr) tty->print_cr(\"%5u int array copies\", _jint_array_copy_ctr);\n+  if (_jlong_array_copy_ctr) tty->print_cr(\"%5u long array copies\", _jlong_array_copy_ctr);\n+  if (_oop_array_copy_ctr) tty->print_cr(\"%5u oop array copies\", _oop_array_copy_ctr);\n+  if (_checkcast_array_copy_ctr) tty->print_cr(\"%5u checkcast array copies\", _checkcast_array_copy_ctr);\n+  if (_unsafe_array_copy_ctr) tty->print_cr(\"%5u unsafe array copies\", _unsafe_array_copy_ctr);\n+  if (_generic_array_copy_ctr) tty->print_cr(\"%5u generic array copies\", _generic_array_copy_ctr);\n+  if (_slow_array_copy_ctr) tty->print_cr(\"%5u slow array copies\", _slow_array_copy_ctr);\n+  if (_find_handler_ctr) tty->print_cr(\"%5u find exception handler\", _find_handler_ctr);\n+  if (_rethrow_ctr) tty->print_cr(\"%5u rethrow handler\", _rethrow_ctr);\n@@ -2728,1 +2729,1 @@\n-ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+using AdapterHandlerTable = ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n@@ -2731,1 +2732,2 @@\n-                  AdapterFingerPrint::equals> _adapter_handler_table;\n+                  AdapterFingerPrint::equals>;\n+static AdapterHandlerTable* _adapter_handler_table;\n@@ -2738,1 +2740,1 @@\n-  AdapterHandlerEntry** entry = _adapter_handler_table.get(&fp);\n+  AdapterHandlerEntry** entry = _adapter_handler_table->get(&fp);\n@@ -2754,1 +2756,1 @@\n-  TableStatistics ts = _adapter_handler_table.statistics_calculate(size);\n+  TableStatistics ts = _adapter_handler_table->statistics_calculate(size);\n@@ -2757,1 +2759,1 @@\n-                _adapter_handler_table.table_size(), _adapter_handler_table.number_of_entries());\n+                _adapter_handler_table->table_size(), _adapter_handler_table->number_of_entries());\n@@ -2805,0 +2807,1 @@\n+    _adapter_handler_table = new (mtCode) AdapterHandlerTable();\n@@ -3174,1 +3177,4 @@\n-    method->set_has_scalarized_args();\n+    if (!method->has_scalarized_args()) {\n+      assert(!method()->constMethod()->is_shared(), \"Cannot update shared const object\");\n+      method->set_has_scalarized_args();\n+    }\n@@ -3178,1 +3184,2 @@\n-    if (ces.c2_needs_stack_repair()) {\n+    if (ces.c2_needs_stack_repair() && !method->c2_needs_stack_repair()) {\n+      assert(!method->constMethod()->is_shared(), \"Cannot update a shared const object\");\n@@ -3289,1 +3296,1 @@\n-                  _adapter_handler_table.number_of_entries(), fingerprint->as_basic_args_string(),\n+                  _adapter_handler_table->number_of_entries(), fingerprint->as_basic_args_string(),\n@@ -3307,1 +3314,1 @@\n-    _adapter_handler_table.put(fingerprint, entry);\n+    _adapter_handler_table->put(fingerprint, entry);\n@@ -3662,1 +3669,1 @@\n-  _adapter_handler_table.iterate(findblob);\n+  _adapter_handler_table->iterate(findblob);\n@@ -3679,1 +3686,1 @@\n-  _adapter_handler_table.iterate(findblob);\n+  _adapter_handler_table->iterate(findblob);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":85,"deletions":78,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -564,28 +564,28 @@\n-  static int _ic_miss_ctr;                       \/\/ total # of IC misses\n-  static int _wrong_method_ctr;\n-  static int _resolve_static_ctr;\n-  static int _resolve_virtual_ctr;\n-  static int _resolve_opt_virtual_ctr;\n-  static int _implicit_null_throws;\n-  static int _implicit_div0_throws;\n-\n-  static int _jbyte_array_copy_ctr;        \/\/ Slow-path byte array copy\n-  static int _jshort_array_copy_ctr;       \/\/ Slow-path short array copy\n-  static int _jint_array_copy_ctr;         \/\/ Slow-path int array copy\n-  static int _jlong_array_copy_ctr;        \/\/ Slow-path long array copy\n-  static int _oop_array_copy_ctr;          \/\/ Slow-path oop array copy\n-  static int _checkcast_array_copy_ctr;    \/\/ Slow-path oop array copy, with cast\n-  static int _unsafe_array_copy_ctr;       \/\/ Slow-path includes alignment checks\n-  static int _generic_array_copy_ctr;      \/\/ Slow-path includes type decoding\n-  static int _slow_array_copy_ctr;         \/\/ Slow-path failed out to a method call\n-\n-  static int _new_instance_ctr;            \/\/ 'new' object requires GC\n-  static int _new_array_ctr;               \/\/ 'new' array requires GC\n-  static int _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n-  static int _find_handler_ctr;            \/\/ find exception handler\n-  static int _rethrow_ctr;                 \/\/ rethrow exception\n-  static int _mon_enter_stub_ctr;          \/\/ monitor enter stub\n-  static int _mon_exit_stub_ctr;           \/\/ monitor exit stub\n-  static int _mon_enter_ctr;               \/\/ monitor enter slow\n-  static int _mon_exit_ctr;                \/\/ monitor exit slow\n-  static int _partial_subtype_ctr;         \/\/ SubRoutines::partial_subtype_check\n+  static uint _ic_miss_ctr;                      \/\/ total # of IC misses\n+  static uint _wrong_method_ctr;\n+  static uint _resolve_static_ctr;\n+  static uint _resolve_virtual_ctr;\n+  static uint _resolve_opt_virtual_ctr;\n+  static uint _implicit_null_throws;\n+  static uint _implicit_div0_throws;\n+\n+  static uint _jbyte_array_copy_ctr;       \/\/ Slow-path byte array copy\n+  static uint _jshort_array_copy_ctr;      \/\/ Slow-path short array copy\n+  static uint _jint_array_copy_ctr;        \/\/ Slow-path int array copy\n+  static uint _jlong_array_copy_ctr;       \/\/ Slow-path long array copy\n+  static uint _oop_array_copy_ctr;         \/\/ Slow-path oop array copy\n+  static uint _checkcast_array_copy_ctr;   \/\/ Slow-path oop array copy, with cast\n+  static uint _unsafe_array_copy_ctr;      \/\/ Slow-path includes alignment checks\n+  static uint _generic_array_copy_ctr;     \/\/ Slow-path includes type decoding\n+  static uint _slow_array_copy_ctr;        \/\/ Slow-path failed out to a method call\n+\n+  static uint _new_instance_ctr;           \/\/ 'new' object requires GC\n+  static uint _new_array_ctr;              \/\/ 'new' array requires GC\n+  static uint _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n+  static uint _find_handler_ctr;           \/\/ find exception handler\n+  static uint _rethrow_ctr;                \/\/ rethrow exception\n+  static uint _mon_enter_stub_ctr;         \/\/ monitor enter stub\n+  static uint _mon_exit_stub_ctr;          \/\/ monitor exit stub\n+  static uint _mon_enter_ctr;              \/\/ monitor enter slow\n+  static uint _mon_exit_ctr;               \/\/ monitor exit slow\n+  static uint _partial_subtype_ctr;        \/\/ SubRoutines::partial_subtype_check\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -677,0 +677,36 @@\n+    \/* ============================================================================ *\/\n+    public interface ShuffleIotaOperation<S extends VectorSpecies<?>,\n+                                          SH extends VectorShuffle<?>> {\n+        SH apply(int length, int start, int step, S s);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <E,\n+     S extends VectorSpecies<E>,\n+     SH extends VectorShuffle<E>>\n+    SH shuffleIota(Class<E> eClass, Class<? extends SH> shClass, S s,\n+                   int length,\n+                   int start, int step, int wrap,\n+                   ShuffleIotaOperation<S, SH> defaultImpl) {\n+       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+       return defaultImpl.apply(length, start, step, s);\n+    }\n+\n+    public interface ShuffleToVectorOperation<V extends Vector<?>,\n+                                              SH extends VectorShuffle<?>> {\n+       V apply(SH sh);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     SH extends VectorShuffle<E>,\n+     E>\n+    V shuffleToVector(Class<? extends Vector<E>> vClass, Class<E> eClass, Class<? extends SH> shClass, SH sh,\n+                      int length,\n+                      ShuffleToVectorOperation<V, SH> defaultImpl) {\n+      assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+      return defaultImpl.apply(sh);\n+    }\n+\n@@ -720,2 +756,2 @@\n-    public interface VecExtractOp<V extends Vector<?>> {\n-        long apply(V v, int i);\n+    public interface VecExtractOp<VM extends VectorPayload> {\n+        long apply(VM vm, int i);\n@@ -726,1 +762,1 @@\n-    <V extends Vector<E>,\n+    <VM extends VectorPayload,\n@@ -728,1 +764,1 @@\n-    long extract(Class<? extends V> vClass, Class<E> eClass,\n+    long extract(Class<? extends VM> vClass, Class<E> eClass,\n@@ -730,2 +766,2 @@\n-                 V v, int i,\n-                 VecExtractOp<V> defaultImpl) {\n+                 VM vm, int i,\n+                 VecExtractOp<VM> defaultImpl) {\n@@ -733,1 +769,1 @@\n-        return defaultImpl.apply(v, i);\n+        return defaultImpl.apply(vm, i);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -142,13 +142,0 @@\n-    @Override\n-    @ForceInline\n-    public boolean laneIsSet(int i) {\n-        int length = length();\n-        Objects.checkIndex(i, length);\n-        if (length <= Long.SIZE) {\n-            return ((toLong() >>> i) & 1L) == 1;\n-        } else {\n-            VectorPayloadMF bits = getBits();\n-            return Unsafe.getUnsafe().getBoolean(bits, bits.multiFieldOffset() + i);\n-        }\n-    }\n-\n@@ -225,0 +212,6 @@\n+    \/*package-private*\/\n+    boolean laneIsSetHelper(int idx) {\n+        VectorPayloadMF bits = getBits();\n+        return Unsafe.getUnsafe().getBoolean(bits, bits.multiFieldOffset() + idx);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.vector.VectorSupport;\n@@ -37,1 +36,1 @@\n-    \/\/ Internal representation allows for a maximum index of E.MAX_VALUE - 1\n+    \/\/ Internal representation allows for a maximum index of 256\n@@ -43,0 +42,26 @@\n+    static VectorPayloadMF prepare(int length, int[] indices, int offset) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mf_offset = payload.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            int si = indices[offset + i];\n+            si = partiallyWrapIndex(si, length);\n+            Unsafe.getUnsafe().putByte(payload, mf_offset + i * Byte.BYTES, (byte) si);\n+        }\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n+    }\n+\n+    static VectorPayloadMF prepare(int length, IntUnaryOperator f) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long offset = payload.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            int si = f.applyAsInt(i);\n+            si = partiallyWrapIndex(si, length);\n+            Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n+        }\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n+    }\n+\n@@ -52,16 +77,0 @@\n-    \/*package-private*\/\n-    abstract AbstractVector<?> toBitsVector();\n-\n-    final AbstractVector<?> toBitsVectorTemplate() {\n-        AbstractSpecies<?> dsp = vspecies().asIntegral();\n-        Class<?> etype = dsp.elementType();\n-        Class<?> rvtype = dsp.dummyVectorMF().getClass();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n-                                     getClass(), etype, length(),\n-                                     rvtype, etype, length(),\n-                                     this, dsp,\n-                                     (v, s) -> v.toBitsVector0());\n-    }\n-\n-    abstract AbstractVector<?> toBitsVector0();\n-\n@@ -70,2 +79,9 @@\n-    public final Vector<E> toVector() {\n-        return toBitsVector().castShape(vspecies(), 0);\n+    public void intoArray(int[] a, int offset) {\n+        VectorPayloadMF indices = indices();\n+        int vlen = indices.length();\n+        long mf_offset = indices.multiFieldOffset();\n+        for (int i = 0; i < vlen; i++) {\n+            int sourceIndex = Unsafe.getUnsafe().getByte(indices, mf_offset + i * Byte.BYTES);\n+            assert(sourceIndex >= -vlen && sourceIndex < vlen);\n+            a[offset + i] = sourceIndex;\n+        }\n@@ -76,2 +92,3 @@\n-    public final int[] toArray() {\n-        int[] a = new int[length()];\n+    public int[] toArray() {\n+        VectorPayloadMF indices = indices();\n+        int[] a = new int[indices.length()];\n@@ -82,1 +99,1 @@\n-    @Override\n+    \/*package-private*\/\n@@ -84,5 +101,9 @@\n-    public final <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-        if (length() != s.length()) {\n-            throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-        }\n-        return toBitsVector().toShuffle((AbstractSpecies<F>) s);\n+    final\n+    AbstractVector<E>\n+    toVectorTemplate() {\n+        \/\/ Note that the values produced by laneSource\n+        \/\/ are already clipped.  At this point we convert\n+        \/\/ them from internal ints (or bytes) into the ETYPE.\n+        \/\/ FIXME: Use a conversion intrinsic for this operation.\n+        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8225740\n+        return (AbstractVector<E>) vspecies().fromIntValues(toArray());\n@@ -91,1 +112,0 @@\n-    @Override\n@@ -97,2 +117,2 @@\n-        Vector<?> shufvec = this.toBitsVector();\n-        VectorMask<?> vecmask = shufvec.compare(VectorOperators.LT, 0);\n+        Vector<E> shufvec = this.toVector();\n+        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n@@ -100,2 +120,3 @@\n-            int[] indices = toArray();\n-            throw checkIndexFailed(indices[vecmask.firstTrue()], length());\n+            VectorPayloadMF indices = indices();\n+            long offset = indices.multiFieldOffset();\n+            throw checkIndexFailed(Unsafe.getUnsafe().getByte(indices, offset + vecmask.firstTrue() * Byte.BYTES), length());\n@@ -106,5 +127,9 @@\n-    @Override\n-    public final VectorMask<E> laneIsValid() {\n-        Vector<?> shufvec = this.toBitsVector();\n-        return shufvec.compare(VectorOperators.GE, 0)\n-                      .cast(vspecies());\n+    public final VectorShuffle<E> wrapIndexes() {\n+        Vector<E> shufvec = this.toVector();\n+        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n+        if (vecmask.anyTrue()) {\n+            \/\/ FIXME: vectorize this\n+            VectorPayloadMF indices = indices();\n+            return wrapAndRebuild(indices);\n+        }\n+        return this;\n@@ -115,7 +140,19 @@\n-    @Override\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    public final VectorShuffle<E> rearrange(VectorShuffle<E> shuffle) {\n-        Vector v = toBitsVector();\n-        return (VectorShuffle<E>) v.rearrange(shuffle.cast(vspecies().asIntegral()))\n-                                   .toShuffle()\n-                                   .cast(vspecies());\n+    public final VectorShuffle<E> wrapAndRebuild(VectorPayloadMF oldIndices) {\n+        int length = oldIndices.length();\n+        VectorPayloadMF indices = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        long offset = oldIndices.multiFieldOffset();\n+        indices = Unsafe.getUnsafe().makePrivateBuffer(indices);\n+        for (int i = 0; i < length; i++) {\n+            int si = Unsafe.getUnsafe().getByte(oldIndices, offset + i * Byte.BYTES);\n+            \/\/ FIXME: This does not work unless it's a power of 2.\n+            if ((length & (length - 1)) == 0) {\n+                si += si & length;  \/\/ power-of-two optimization\n+            } else if (si < 0) {\n+                \/\/ non-POT code requires a conditional add\n+                si += length;\n+            }\n+            assert(si >= 0 && si < length);\n+            Unsafe.getUnsafe().putByte(indices, offset + i * Byte.BYTES, (byte) si);\n+        }\n+        indices = Unsafe.getUnsafe().finishPrivateBuffer(indices);\n+        return vspecies().dummyVectorMF().shuffleFromBytes(indices);\n@@ -125,11 +162,3 @@\n-    @Override\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    public final VectorShuffle<E> wrapIndexes() {\n-        Vector v = toBitsVector();\n-        if ((length() & (length() - 1)) == 0) {\n-            v = v.lanewise(VectorOperators.AND, length() - 1);\n-        } else {\n-            v = v.blend(v.lanewise(VectorOperators.ADD, length()),\n-                        v.compare(VectorOperators.LT, 0));\n-        }\n-        return (VectorShuffle<E>) v.toShuffle().cast(vspecies());\n+    public final VectorMask<E> laneIsValid() {\n+        Vector<E> shufvec = this.toVector();\n+        return shufvec.compare(VectorOperators.GE, vspecies().zero());\n@@ -189,0 +218,19 @@\n+\n+    static boolean indexesInRange(VectorPayloadMF indices) {\n+        int length = indices.length();\n+        long offset = indices.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n+            if (si >= length || si < -length) {\n+                boolean assertsEnabled = false;\n+                assert(assertsEnabled = true);\n+                if (assertsEnabled) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                            indices.toString());\n+                    throw new AssertionError(msg);\n+                }\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":104,"deletions":56,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-    final Class<? extends AbstractShuffle<E>> shuffleType;\n-    @Stable\n@@ -70,1 +68,0 @@\n-                    Class<? extends AbstractShuffle<E>> shuffleType,\n@@ -76,1 +73,0 @@\n-        this.shuffleType = shuffleType;\n@@ -119,3 +115,0 @@\n-    @Stable \/\/lazy JIT constant\n-    AbstractVector<E> dummyVector;\n-\n@@ -176,5 +169,0 @@\n-    @ForceInline\n-    final Class<? extends AbstractShuffle<E>> shuffleType() {\n-        return shuffleType;\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    abstract <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp);\n+    abstract AbstractShuffle<E> iotaShuffle();\n@@ -194,23 +194,1 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final <F> VectorShuffle<F> toShuffleTemplate(AbstractSpecies<F> dsp) {\n-        Class<?> etype = vspecies().elementType();\n-        Class<?> dvtype = dsp.shuffleType();\n-        Class<?> dtype = dsp.asIntegral().elementType();\n-        int dlength = dsp.dummyVectorMF().length();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), etype, length(),\n-                                     dvtype, dtype, dlength,\n-                                     this, dsp,\n-                                     AbstractVector::toShuffle0);\n-    }\n-\n-    abstract <F> VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp);\n-\n-    @ForceInline\n-    public final\n-    VectorShuffle<E> toShuffle() {\n-        return toShuffle(vspecies());\n-    }\n-\n-    abstract VectorShuffle<E> iotaShuffle();\n+    abstract AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n@@ -218,25 +196,2 @@\n-    @ForceInline\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    final VectorShuffle<E> iotaShuffle(int start, int step, boolean wrap) {\n-        if (start == 0 && step == 1) {\n-            return iotaShuffle();\n-        }\n-\n-        if ((length() & (length() - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, length())))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        AbstractSpecies<?> species = vspecies().asIntegral();\n-        Vector iota = species.iota();\n-        iota = iota.lanewise(VectorOperators.MUL, step)\n-                   .lanewise(VectorOperators.ADD, start);\n-        Vector wrapped = iota.lanewise(VectorOperators.AND, length() - 1);\n-\n-        if (!wrap) {\n-            Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n-            VectorMask<?> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return ((AbstractVector) wrapped).toShuffle(vspecies());\n-    }\n+    \/*do not alias this byte array*\/\n+    abstract AbstractShuffle<E> shuffleFromBytes(VectorPayloadMF indexes);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":4,"deletions":49,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Byte128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Byte128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte128Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Byte128Shuffle shuffleFromArray(int[] indices, int i) { return new Byte128Shuffle(indices, i); }\n+    Byte128Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte128Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n@@ -703,0 +716,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte128Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Byte128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -744,1 +767,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Byte128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -747,2 +774,2 @@\n-        Byte128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -751,2 +778,2 @@\n-        Byte128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -762,1 +789,0 @@\n-        @ForceInline\n@@ -777,2 +803,3 @@\n-        Byte128Vector toBitsVector() {\n-            return (Byte128Vector) super.toBitsVectorTemplate();\n+        public Byte128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte128Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -783,2 +810,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte128Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -787,27 +818,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte128Shuffle s = (Byte128Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -815,37 +826,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, mfOffset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -855,1 +832,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Byte128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":58,"deletions":80,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Byte256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Byte256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte256Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Byte256Shuffle shuffleFromArray(int[] indices, int i) { return new Byte256Shuffle(indices, i); }\n+    Byte256Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte256Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n@@ -735,0 +748,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte256Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Byte256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -776,1 +799,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Byte256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -779,2 +806,2 @@\n-        Byte256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -783,2 +810,2 @@\n-        Byte256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -794,1 +821,0 @@\n-        @ForceInline\n@@ -809,2 +835,3 @@\n-        Byte256Vector toBitsVector() {\n-            return (Byte256Vector) super.toBitsVectorTemplate();\n+        public Byte256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte256Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -815,2 +842,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte256Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -819,27 +850,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte256Shuffle s = (Byte256Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -847,37 +858,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, mfOffset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -887,1 +864,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Byte256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":58,"deletions":80,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Byte512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Byte512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte512Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Byte512Shuffle shuffleFromArray(int[] indices, int i) { return new Byte512Shuffle(indices, i); }\n+    Byte512Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte512Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n@@ -799,0 +812,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte512Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Byte512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -840,1 +863,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Byte512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -843,2 +870,2 @@\n-        Byte512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -847,2 +874,2 @@\n-        Byte512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -858,1 +885,0 @@\n-        @ForceInline\n@@ -873,2 +899,3 @@\n-        Byte512Vector toBitsVector() {\n-            return (Byte512Vector) super.toBitsVectorTemplate();\n+        public Byte512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte512Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -879,2 +906,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte512Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -883,27 +914,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte512Shuffle s = (Byte512Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -911,37 +922,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, mfOffset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -951,1 +928,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Byte512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":58,"deletions":80,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Byte64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Byte64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte64Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Byte64Shuffle shuffleFromArray(int[] indices, int i) { return new Byte64Shuffle(indices, i); }\n+    Byte64Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte64Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n@@ -687,0 +700,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte64Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Byte64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -728,1 +751,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Byte64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -731,2 +758,2 @@\n-        Byte64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -735,2 +762,2 @@\n-        Byte64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -746,1 +773,0 @@\n-        @ForceInline\n@@ -761,2 +787,3 @@\n-        Byte64Vector toBitsVector() {\n-            return (Byte64Vector) super.toBitsVectorTemplate();\n+        public Byte64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte64Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -767,2 +794,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte64Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -771,27 +802,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte64Shuffle s = (Byte64Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -799,37 +810,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, mfOffset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -839,1 +816,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Byte64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":58,"deletions":80,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1189,1 +1189,1 @@\n-    \/**\n+   \/**\n@@ -2598,2 +2598,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Byte> toShuffle0(ByteSpecies dsp) {\n@@ -2608,0 +2608,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), byte.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ByteVector::toShuffle0);\n+    }\n+\n@@ -4203,1 +4215,0 @@\n-                Class<? extends AbstractShuffle<Byte>> shuffleType,\n@@ -4206,1 +4217,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4502,1 +4513,0 @@\n-                            Byte64Vector.Byte64Shuffle.class,\n@@ -4510,1 +4520,0 @@\n-                            Byte128Vector.Byte128Shuffle.class,\n@@ -4518,1 +4527,0 @@\n-                            Byte256Vector.Byte256Shuffle.class,\n@@ -4526,1 +4534,0 @@\n-                            Byte512Vector.Byte512Shuffle.class,\n@@ -4535,1 +4542,0 @@\n-                            ByteMaxVector.ByteMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Double128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Double128Shuffle shuffleFromArray(int[] indices, int i) { return new Double128Shuffle(indices, i); }\n+    Double128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double128Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Double128Shuffle shuffleFromArray(int[] indexes, int i) { return new Double128Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n@@ -664,0 +677,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double128Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Double128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -698,1 +721,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -700,1 +723,1 @@\n-        private final VectorPayloadMF128L payload;\n+        private final VectorPayloadMF16B payload;\n@@ -703,1 +726,1 @@\n-            this.payload = (VectorPayloadMF128L) payload;\n+            this.payload = (VectorPayloadMF16B) payload;\n@@ -705,1 +728,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Double128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -708,2 +735,2 @@\n-        Double128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -712,2 +739,2 @@\n-        Double128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -723,1 +750,0 @@\n-        @ForceInline\n@@ -731,2 +757,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -738,2 +764,3 @@\n-        Long128Vector toBitsVector() {\n-            return (Long128Vector) super.toBitsVectorTemplate();\n+        public Double128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double128Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -744,2 +771,6 @@\n-        LongVector toBitsVector0() {\n-            return Long128Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -748,38 +779,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double128Shuffle s = (Double128Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -787,37 +787,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -827,1 +793,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Double128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":63,"deletions":96,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Double256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Double256Shuffle shuffleFromArray(int[] indices, int i) { return new Double256Shuffle(indices, i); }\n+    Double256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double256Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Double256Shuffle shuffleFromArray(int[] indexes, int i) { return new Double256Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n@@ -668,0 +681,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double256Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Double256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -702,1 +725,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -704,1 +727,1 @@\n-        private final VectorPayloadMF256L payload;\n+        private final VectorPayloadMF32B payload;\n@@ -707,1 +730,1 @@\n-            this.payload = (VectorPayloadMF256L) payload;\n+            this.payload = (VectorPayloadMF32B) payload;\n@@ -709,1 +732,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Double256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -712,2 +739,2 @@\n-        Double256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -716,2 +743,2 @@\n-        Double256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -727,1 +754,0 @@\n-        @ForceInline\n@@ -735,2 +761,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -742,2 +768,3 @@\n-        Long256Vector toBitsVector() {\n-            return (Long256Vector) super.toBitsVectorTemplate();\n+        public Double256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double256Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -748,2 +775,6 @@\n-        LongVector toBitsVector0() {\n-            return Long256Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -752,38 +783,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double256Shuffle s = (Double256Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -791,37 +791,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -831,1 +797,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Double256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":63,"deletions":96,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Double512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Double512Shuffle shuffleFromArray(int[] indices, int i) { return new Double512Shuffle(indices, i); }\n+    Double512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double512Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Double512Shuffle shuffleFromArray(int[] indexes, int i) { return new Double512Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n@@ -676,0 +689,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double512Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Double512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -710,1 +733,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -712,1 +735,1 @@\n-        private final VectorPayloadMF512L payload;\n+        private final VectorPayloadMF64B payload;\n@@ -715,1 +738,1 @@\n-            this.payload = (VectorPayloadMF512L) payload;\n+            this.payload = (VectorPayloadMF64B) payload;\n@@ -717,1 +740,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Double512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -720,2 +747,2 @@\n-        Double512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -724,2 +751,2 @@\n-        Double512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -735,1 +762,0 @@\n-        @ForceInline\n@@ -743,2 +769,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -750,2 +776,3 @@\n-        Long512Vector toBitsVector() {\n-            return (Long512Vector) super.toBitsVectorTemplate();\n+        public Double512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double512Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -756,2 +783,6 @@\n-        LongVector toBitsVector0() {\n-            return Long512Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -760,38 +791,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double512Shuffle s = (Double512Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -799,37 +799,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -839,1 +805,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Double512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":63,"deletions":96,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Double64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Double64Shuffle shuffleFromArray(int[] indices, int i) { return new Double64Shuffle(indices, i); }\n+    Double64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double64Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Double64Shuffle shuffleFromArray(int[] indexes, int i) { return new Double64Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n@@ -662,0 +675,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double64Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Double64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -696,1 +719,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -698,1 +721,1 @@\n-        private final VectorPayloadMF64L payload;\n+        private final VectorPayloadMF8B payload;\n@@ -701,1 +724,1 @@\n-            this.payload = (VectorPayloadMF64L) payload;\n+            this.payload = (VectorPayloadMF8B) payload;\n@@ -703,1 +726,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Double64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -706,2 +733,2 @@\n-        Double64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -710,2 +737,2 @@\n-        Double64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -721,1 +748,0 @@\n-        @ForceInline\n@@ -729,2 +755,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -736,2 +762,3 @@\n-        Long64Vector toBitsVector() {\n-            return (Long64Vector) super.toBitsVectorTemplate();\n+        public Double64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double64Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -742,2 +769,6 @@\n-        LongVector toBitsVector0() {\n-            return Long64Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -746,38 +777,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double64Shuffle s = (Double64Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -785,37 +785,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -825,1 +791,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Double64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":63,"deletions":96,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1063,1 +1063,1 @@\n-    \/**\n+   \/**\n@@ -2432,2 +2432,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n@@ -2442,0 +2442,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n+        DoubleSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), double.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     DoubleVector::toShuffle0);\n+    }\n+\n@@ -3807,1 +3819,0 @@\n-                Class<? extends AbstractShuffle<Double>> shuffleType,\n@@ -3810,1 +3821,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4106,1 +4117,0 @@\n-                            Double64Vector.Double64Shuffle.class,\n@@ -4114,1 +4124,0 @@\n-                            Double128Vector.Double128Shuffle.class,\n@@ -4122,1 +4131,0 @@\n-                            Double256Vector.Double256Shuffle.class,\n@@ -4130,1 +4138,0 @@\n-                            Double512Vector.Double512Shuffle.class,\n@@ -4139,1 +4146,0 @@\n-                            DoubleMaxVector.DoubleMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Float128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Float128Shuffle shuffleFromArray(int[] indices, int i) { return new Float128Shuffle(indices, i); }\n+    Float128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float128Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Float128Shuffle shuffleFromArray(int[] indexes, int i) { return new Float128Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n@@ -668,0 +681,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float128Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Float128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -702,1 +725,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -704,1 +727,1 @@\n-        private final VectorPayloadMF128I payload;\n+        private final VectorPayloadMF32B payload;\n@@ -707,1 +730,1 @@\n-            this.payload = (VectorPayloadMF128I) payload;\n+            this.payload = (VectorPayloadMF32B) payload;\n@@ -709,1 +732,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Float128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -712,2 +739,2 @@\n-        Float128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -716,2 +743,2 @@\n-        Float128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -727,1 +754,0 @@\n-        @ForceInline\n@@ -735,2 +761,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -742,2 +768,3 @@\n-        Int128Vector toBitsVector() {\n-            return (Int128Vector) super.toBitsVectorTemplate();\n+        public Float128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float128Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -748,2 +775,6 @@\n-        IntVector toBitsVector0() {\n-            return Int128Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -752,27 +783,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float128Shuffle s = (Float128Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -780,24 +791,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -807,1 +797,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Float128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":63,"deletions":72,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Float256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Float256Shuffle shuffleFromArray(int[] indices, int i) { return new Float256Shuffle(indices, i); }\n+    Float256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float256Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Float256Shuffle shuffleFromArray(int[] indexes, int i) { return new Float256Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n@@ -676,0 +689,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float256Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Float256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -710,1 +733,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -712,1 +735,1 @@\n-        private final VectorPayloadMF256I payload;\n+        private final VectorPayloadMF64B payload;\n@@ -715,1 +738,1 @@\n-            this.payload = (VectorPayloadMF256I) payload;\n+            this.payload = (VectorPayloadMF64B) payload;\n@@ -717,1 +740,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Float256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -720,2 +747,2 @@\n-        Float256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -724,2 +751,2 @@\n-        Float256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -735,1 +762,0 @@\n-        @ForceInline\n@@ -743,2 +769,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -750,2 +776,3 @@\n-        Int256Vector toBitsVector() {\n-            return (Int256Vector) super.toBitsVectorTemplate();\n+        public Float256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float256Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -756,2 +783,6 @@\n-        IntVector toBitsVector0() {\n-            return Int256Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -760,27 +791,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float256Shuffle s = (Float256Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -788,24 +799,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -815,1 +805,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Float256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":63,"deletions":72,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Float512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Float512Shuffle shuffleFromArray(int[] indices, int i) { return new Float512Shuffle(indices, i); }\n+    Float512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float512Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Float512Shuffle shuffleFromArray(int[] indexes, int i) { return new Float512Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n@@ -692,0 +705,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float512Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Float512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -726,1 +749,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -728,1 +751,1 @@\n-        private final VectorPayloadMF512I payload;\n+        private final VectorPayloadMF128B payload;\n@@ -731,1 +754,1 @@\n-            this.payload = (VectorPayloadMF512I) payload;\n+            this.payload = (VectorPayloadMF128B) payload;\n@@ -733,1 +756,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Float512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -736,2 +763,2 @@\n-        Float512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -740,2 +767,2 @@\n-        Float512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -751,1 +778,0 @@\n-        @ForceInline\n@@ -759,2 +785,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -766,2 +792,3 @@\n-        Int512Vector toBitsVector() {\n-            return (Int512Vector) super.toBitsVectorTemplate();\n+        public Float512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float512Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -772,2 +799,6 @@\n-        IntVector toBitsVector0() {\n-            return Int512Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -776,27 +807,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float512Shuffle s = (Float512Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -804,24 +815,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -831,1 +821,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Float512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":63,"deletions":72,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Float64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Float64Shuffle shuffleFromArray(int[] indices, int i) { return new Float64Shuffle(indices, i); }\n+    Float64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float64Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Float64Shuffle shuffleFromArray(int[] indexes, int i) { return new Float64Shuffle(indexes, i); }\n@@ -332,4 +347,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n@@ -664,0 +677,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float64Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Float64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -698,1 +721,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -700,1 +723,1 @@\n-        private final VectorPayloadMF64I payload;\n+        private final VectorPayloadMF16B payload;\n@@ -703,1 +726,1 @@\n-            this.payload = (VectorPayloadMF64I) payload;\n+            this.payload = (VectorPayloadMF16B) payload;\n@@ -705,1 +728,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Float64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -708,2 +735,2 @@\n-        Float64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -712,2 +739,2 @@\n-        Float64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -723,1 +750,0 @@\n-        @ForceInline\n@@ -731,2 +757,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -738,2 +764,3 @@\n-        Int64Vector toBitsVector() {\n-            return (Int64Vector) super.toBitsVectorTemplate();\n+        public Float64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float64Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -744,2 +771,6 @@\n-        IntVector toBitsVector0() {\n-            return Int64Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -748,27 +779,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float64Shuffle s = (Float64Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -776,24 +787,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -803,1 +793,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Float64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":63,"deletions":72,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1063,1 +1063,1 @@\n-    \/**\n+   \/**\n@@ -2444,2 +2444,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n@@ -2454,0 +2454,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n+        FloatSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), float.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     FloatVector::toShuffle0);\n+    }\n+\n@@ -3748,1 +3760,0 @@\n-                Class<? extends AbstractShuffle<Float>> shuffleType,\n@@ -3751,1 +3762,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4047,1 +4058,0 @@\n-                            Float64Vector.Float64Shuffle.class,\n@@ -4055,1 +4065,0 @@\n-                            Float128Vector.Float128Shuffle.class,\n@@ -4063,1 +4072,0 @@\n-                            Float256Vector.Float256Shuffle.class,\n@@ -4071,1 +4079,0 @@\n-                            Float512Vector.Float512Shuffle.class,\n@@ -4080,1 +4087,0 @@\n-                            FloatMaxVector.FloatMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int128Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Int128Shuffle shuffleFromArray(int[] indices, int i) { return new Int128Shuffle(indices, i); }\n+    Int128Shuffle shuffleFromArray(int[] indexes, int i) { return new Int128Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n@@ -679,0 +692,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int128Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Int128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -715,1 +738,1 @@\n-        private final VectorPayloadMF128I payload;\n+        private final VectorPayloadMF32B payload;\n@@ -718,1 +741,1 @@\n-            this.payload = (VectorPayloadMF128I) payload;\n+            this.payload = (VectorPayloadMF32B) payload;\n@@ -720,1 +743,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Int128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -723,2 +750,2 @@\n-        Int128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -727,2 +754,2 @@\n-        Int128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -738,1 +765,0 @@\n-        @ForceInline\n@@ -746,2 +772,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -753,2 +779,3 @@\n-        Int128Vector toBitsVector() {\n-            return (Int128Vector) super.toBitsVectorTemplate();\n+        public Int128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int128Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -759,2 +786,6 @@\n-        IntVector toBitsVector0() {\n-            return Int128Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -763,27 +794,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int128Shuffle s = (Int128Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -791,24 +802,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -818,1 +808,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Int128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":62,"deletions":71,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int256Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Int256Shuffle shuffleFromArray(int[] indices, int i) { return new Int256Shuffle(indices, i); }\n+    Int256Shuffle shuffleFromArray(int[] indexes, int i) { return new Int256Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n@@ -687,0 +700,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int256Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Int256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -723,1 +746,1 @@\n-        private final VectorPayloadMF256I payload;\n+        private final VectorPayloadMF64B payload;\n@@ -726,1 +749,1 @@\n-            this.payload = (VectorPayloadMF256I) payload;\n+            this.payload = (VectorPayloadMF64B) payload;\n@@ -728,1 +751,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Int256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -731,2 +758,2 @@\n-        Int256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -735,2 +762,2 @@\n-        Int256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -746,1 +773,0 @@\n-        @ForceInline\n@@ -754,2 +780,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -761,2 +787,3 @@\n-        Int256Vector toBitsVector() {\n-            return (Int256Vector) super.toBitsVectorTemplate();\n+        public Int256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int256Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -767,2 +794,6 @@\n-        IntVector toBitsVector0() {\n-            return Int256Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -771,27 +802,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int256Shuffle s = (Int256Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -799,24 +810,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -826,1 +816,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Int256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":62,"deletions":71,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int512Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Int512Shuffle shuffleFromArray(int[] indices, int i) { return new Int512Shuffle(indices, i); }\n+    Int512Shuffle shuffleFromArray(int[] indexes, int i) { return new Int512Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n@@ -703,0 +716,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int512Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Int512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -739,1 +762,1 @@\n-        private final VectorPayloadMF512I payload;\n+        private final VectorPayloadMF128B payload;\n@@ -742,1 +765,1 @@\n-            this.payload = (VectorPayloadMF512I) payload;\n+            this.payload = (VectorPayloadMF128B) payload;\n@@ -744,1 +767,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Int512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -747,2 +774,2 @@\n-        Int512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -751,2 +778,2 @@\n-        Int512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -762,1 +789,0 @@\n-        @ForceInline\n@@ -770,2 +796,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -777,2 +803,3 @@\n-        Int512Vector toBitsVector() {\n-            return (Int512Vector) super.toBitsVectorTemplate();\n+        public Int512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int512Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -783,2 +810,6 @@\n-        IntVector toBitsVector0() {\n-            return Int512Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -787,27 +818,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int512Shuffle s = (Int512Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -815,24 +826,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -842,1 +832,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Int512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":62,"deletions":71,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int64Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Int64Shuffle shuffleFromArray(int[] indices, int i) { return new Int64Shuffle(indices, i); }\n+    Int64Shuffle shuffleFromArray(int[] indexes, int i) { return new Int64Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n@@ -675,0 +688,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int64Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Int64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -711,1 +734,1 @@\n-        private final VectorPayloadMF64I payload;\n+        private final VectorPayloadMF16B payload;\n@@ -714,1 +737,1 @@\n-            this.payload = (VectorPayloadMF64I) payload;\n+            this.payload = (VectorPayloadMF16B) payload;\n@@ -716,1 +739,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Int64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -719,2 +746,2 @@\n-        Int64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -723,2 +750,2 @@\n-        Int64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -734,1 +761,0 @@\n-        @ForceInline\n@@ -742,2 +768,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -749,2 +775,3 @@\n-        Int64Vector toBitsVector() {\n-            return (Int64Vector) super.toBitsVectorTemplate();\n+        public Int64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int64Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -755,2 +782,6 @@\n-        IntVector toBitsVector0() {\n-            return Int64Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -759,27 +790,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, mfOffset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(int.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int64Shuffle s = (Int64Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -787,24 +798,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putInt(payload, offset + i * Integer.BYTES, (int) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                int si = Unsafe.getUnsafe().getInt(indices, offset + i * Integer.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -814,1 +804,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Int64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":62,"deletions":71,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1196,1 +1196,1 @@\n-    \/**\n+   \/**\n@@ -2587,2 +2587,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Integer> toShuffle0(IntSpecies dsp) {\n@@ -2597,0 +2597,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), int.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     IntVector::toShuffle0);\n+    }\n+\n@@ -3916,1 +3928,0 @@\n-                Class<? extends AbstractShuffle<Integer>> shuffleType,\n@@ -3919,1 +3930,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4215,1 +4226,0 @@\n-                            Int64Vector.Int64Shuffle.class,\n@@ -4223,1 +4233,0 @@\n-                            Int128Vector.Int128Shuffle.class,\n@@ -4231,1 +4240,0 @@\n-                            Int256Vector.Int256Shuffle.class,\n@@ -4239,1 +4247,0 @@\n-                            Int512Vector.Int512Shuffle.class,\n@@ -4248,1 +4255,0 @@\n-                            IntMaxVector.IntMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -139,0 +139,11 @@\n+    @ForceInline\n+    Long128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -141,1 +152,5 @@\n-    Long128Shuffle shuffleFromArray(int[] indices, int i) { return new Long128Shuffle(indices, i); }\n+    Long128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long128Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Long128Shuffle shuffleFromArray(int[] indexes, int i) { return new Long128Shuffle(indexes, i); }\n@@ -340,4 +355,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n@@ -665,0 +678,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long128Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Long128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -701,1 +724,1 @@\n-        private final VectorPayloadMF128L payload;\n+        private final VectorPayloadMF16B payload;\n@@ -704,1 +727,1 @@\n-            this.payload = (VectorPayloadMF128L) payload;\n+            this.payload = (VectorPayloadMF16B) payload;\n@@ -706,1 +729,1 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n@@ -709,2 +732,2 @@\n-        Long128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -713,2 +736,6 @@\n-        Long128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n+        }\n+\n+        public Long128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -724,1 +751,0 @@\n-        @ForceInline\n@@ -732,2 +758,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -739,2 +765,3 @@\n-        Long128Vector toBitsVector() {\n-            return (Long128Vector) super.toBitsVectorTemplate();\n+        public Long128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long128Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -745,2 +772,6 @@\n-        LongVector toBitsVector0() {\n-            return Long128Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -749,51 +780,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long128Shuffle s = (Long128Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -801,24 +788,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -828,1 +794,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Long128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":62,"deletions":95,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -139,0 +139,11 @@\n+    @ForceInline\n+    Long256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -141,1 +152,5 @@\n-    Long256Shuffle shuffleFromArray(int[] indices, int i) { return new Long256Shuffle(indices, i); }\n+    Long256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long256Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Long256Shuffle shuffleFromArray(int[] indexes, int i) { return new Long256Shuffle(indexes, i); }\n@@ -340,4 +355,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n@@ -669,0 +682,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long256Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Long256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -705,1 +728,1 @@\n-        private final VectorPayloadMF256L payload;\n+        private final VectorPayloadMF32B payload;\n@@ -708,1 +731,1 @@\n-            this.payload = (VectorPayloadMF256L) payload;\n+            this.payload = (VectorPayloadMF32B) payload;\n@@ -710,1 +733,1 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n@@ -713,2 +736,2 @@\n-        Long256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -717,2 +740,6 @@\n-        Long256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n+        }\n+\n+        public Long256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -728,1 +755,0 @@\n-        @ForceInline\n@@ -736,2 +762,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -743,2 +769,3 @@\n-        Long256Vector toBitsVector() {\n-            return (Long256Vector) super.toBitsVectorTemplate();\n+        public Long256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long256Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -749,2 +776,6 @@\n-        LongVector toBitsVector0() {\n-            return Long256Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -753,51 +784,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long256Shuffle s = (Long256Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -805,24 +792,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -832,1 +798,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Long256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":62,"deletions":95,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -139,0 +139,11 @@\n+    @ForceInline\n+    Long512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -141,1 +152,5 @@\n-    Long512Shuffle shuffleFromArray(int[] indices, int i) { return new Long512Shuffle(indices, i); }\n+    Long512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long512Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Long512Shuffle shuffleFromArray(int[] indexes, int i) { return new Long512Shuffle(indexes, i); }\n@@ -340,4 +355,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n@@ -677,0 +690,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long512Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Long512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -713,1 +736,1 @@\n-        private final VectorPayloadMF512L payload;\n+        private final VectorPayloadMF64B payload;\n@@ -716,1 +739,1 @@\n-            this.payload = (VectorPayloadMF512L) payload;\n+            this.payload = (VectorPayloadMF64B) payload;\n@@ -718,1 +741,1 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n@@ -721,2 +744,2 @@\n-        Long512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -725,2 +748,6 @@\n-        Long512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n+        }\n+\n+        public Long512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -736,1 +763,0 @@\n-        @ForceInline\n@@ -744,2 +770,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -751,2 +777,3 @@\n-        Long512Vector toBitsVector() {\n-            return (Long512Vector) super.toBitsVectorTemplate();\n+        public Long512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long512Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -757,2 +784,6 @@\n-        LongVector toBitsVector0() {\n-            return Long512Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -761,51 +792,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long512Shuffle s = (Long512Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -813,24 +800,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -840,1 +806,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Long512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":62,"deletions":95,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -139,0 +139,11 @@\n+    @ForceInline\n+    Long64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -141,1 +152,5 @@\n-    Long64Shuffle shuffleFromArray(int[] indices, int i) { return new Long64Shuffle(indices, i); }\n+    Long64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long64Shuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    Long64Shuffle shuffleFromArray(int[] indexes, int i) { return new Long64Shuffle(indexes, i); }\n@@ -340,4 +355,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n@@ -663,0 +676,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long64Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Long64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -699,1 +722,1 @@\n-        private final VectorPayloadMF64L payload;\n+        private final VectorPayloadMF8B payload;\n@@ -702,1 +725,1 @@\n-            this.payload = (VectorPayloadMF64L) payload;\n+            this.payload = (VectorPayloadMF8B) payload;\n@@ -704,1 +727,1 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n@@ -707,2 +730,2 @@\n-        Long64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -711,2 +734,6 @@\n-        Long64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n+        }\n+\n+        public Long64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -722,1 +749,0 @@\n-        @ForceInline\n@@ -730,2 +756,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -737,2 +763,3 @@\n-        Long64Vector toBitsVector() {\n-            return (Long64Vector) super.toBitsVectorTemplate();\n+        public Long64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long64Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -743,2 +770,6 @@\n-        LongVector toBitsVector0() {\n-            return Long64Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -747,51 +778,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, mfOffset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(long.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n+        public Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long64Shuffle s = (Long64Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -799,24 +786,3 @@\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putLong(payload, offset + i * Long.BYTES, (long) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                long si = Unsafe.getUnsafe().getLong(indices, offset + i * Long.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -826,1 +792,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Long64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":62,"deletions":95,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1109,1 +1109,1 @@\n-    \/**\n+   \/**\n@@ -2453,2 +2453,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Long> toShuffle0(LongSpecies dsp) {\n@@ -2463,0 +2463,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), long.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     LongVector::toShuffle0);\n+    }\n+\n@@ -3860,1 +3872,0 @@\n-                Class<? extends AbstractShuffle<Long>> shuffleType,\n@@ -3863,1 +3874,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4150,1 +4161,0 @@\n-                            Long64Vector.Long64Shuffle.class,\n@@ -4158,1 +4168,0 @@\n-                            Long128Vector.Long128Shuffle.class,\n@@ -4166,1 +4175,0 @@\n-                            Long256Vector.Long256Shuffle.class,\n@@ -4174,1 +4182,0 @@\n-                            Long512Vector.Long512Shuffle.class,\n@@ -4183,1 +4190,0 @@\n-                            LongMaxVector.LongMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Short128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Short128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short128Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Short128Shuffle shuffleFromArray(int[] indices, int i) { return new Short128Shuffle(indices, i); }\n+    Short128Shuffle shuffleFromArray(int[] indexes, int i) { return new Short128Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n@@ -687,0 +700,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short128Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Short128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -723,1 +746,1 @@\n-        private final VectorPayloadMF128S payload;\n+        private final VectorPayloadMF64B payload;\n@@ -726,1 +749,1 @@\n-            this.payload = (VectorPayloadMF128S) payload;\n+            this.payload = (VectorPayloadMF64B) payload;\n@@ -728,1 +751,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Short128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -731,2 +758,2 @@\n-        Short128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -735,2 +762,2 @@\n-        Short128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -746,1 +773,0 @@\n-        @ForceInline\n@@ -754,2 +780,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -761,2 +787,3 @@\n-        Short128Vector toBitsVector() {\n-            return (Short128Vector) super.toBitsVectorTemplate();\n+        public Short128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short128Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -767,2 +794,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short128Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -771,21 +802,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short128Shuffle s = (Short128Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -793,37 +810,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, mfOffset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, offset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                short si = Unsafe.getUnsafe().getShort(indices, offset + i * Short.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -833,1 +816,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Short128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":62,"deletions":78,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Short256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Short256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short256Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Short256Shuffle shuffleFromArray(int[] indices, int i) { return new Short256Shuffle(indices, i); }\n+    Short256Shuffle shuffleFromArray(int[] indexes, int i) { return new Short256Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n@@ -703,0 +716,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short256Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Short256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -739,1 +762,1 @@\n-        private final VectorPayloadMF256S payload;\n+        private final VectorPayloadMF128B payload;\n@@ -742,1 +765,1 @@\n-            this.payload = (VectorPayloadMF256S) payload;\n+            this.payload = (VectorPayloadMF128B) payload;\n@@ -744,1 +767,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Short256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -747,2 +774,2 @@\n-        Short256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -751,2 +778,2 @@\n-        Short256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -762,1 +789,0 @@\n-        @ForceInline\n@@ -770,2 +796,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -777,2 +803,3 @@\n-        Short256Vector toBitsVector() {\n-            return (Short256Vector) super.toBitsVectorTemplate();\n+        public Short256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short256Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -783,2 +810,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short256Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -787,21 +818,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short256Shuffle s = (Short256Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -809,37 +826,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, mfOffset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, offset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                short si = Unsafe.getUnsafe().getShort(indices, offset + i * Short.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -849,1 +832,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Short256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":62,"deletions":78,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Short512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Short512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short512Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Short512Shuffle shuffleFromArray(int[] indices, int i) { return new Short512Shuffle(indices, i); }\n+    Short512Shuffle shuffleFromArray(int[] indexes, int i) { return new Short512Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n@@ -735,0 +748,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short512Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Short512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -771,1 +794,1 @@\n-        private final VectorPayloadMF512S payload;\n+        private final VectorPayloadMF256B payload;\n@@ -774,1 +797,1 @@\n-            this.payload = (VectorPayloadMF512S) payload;\n+            this.payload = (VectorPayloadMF256B) payload;\n@@ -776,1 +799,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Short512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -779,2 +806,2 @@\n-        Short512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -783,2 +810,2 @@\n-        Short512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -794,1 +821,0 @@\n-        @ForceInline\n@@ -802,2 +828,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -809,2 +835,3 @@\n-        Short512Vector toBitsVector() {\n-            return (Short512Vector) super.toBitsVectorTemplate();\n+        public Short512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short512Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -815,2 +842,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short512Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -819,21 +850,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short512Shuffle s = (Short512Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -841,37 +858,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, mfOffset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, offset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                short si = Unsafe.getUnsafe().getShort(indices, offset + i * Short.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -881,1 +864,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Short512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":62,"deletions":78,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Short64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Short64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short64Shuffle(indexes); }\n+\n@@ -146,1 +161,1 @@\n-    Short64Shuffle shuffleFromArray(int[] indices, int i) { return new Short64Shuffle(indices, i); }\n+    Short64Shuffle shuffleFromArray(int[] indexes, int i) { return new Short64Shuffle(indexes, i); }\n@@ -345,4 +360,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n@@ -679,0 +692,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short64Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((Short64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -715,1 +738,1 @@\n-        private final VectorPayloadMF64S payload;\n+        private final VectorPayloadMF32B payload;\n@@ -718,1 +741,1 @@\n-            this.payload = (VectorPayloadMF64S) payload;\n+            this.payload = (VectorPayloadMF32B) payload;\n@@ -720,1 +743,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public Short64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -723,2 +750,2 @@\n-        Short64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -727,2 +754,2 @@\n-        Short64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -738,1 +765,0 @@\n-        @ForceInline\n@@ -746,2 +772,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -753,2 +779,3 @@\n-        Short64Vector toBitsVector() {\n-            return (Short64Vector) super.toBitsVectorTemplate();\n+        public Short64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short64Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -759,2 +786,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short64Vector.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -763,21 +794,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short64Shuffle s = (Short64Shuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -785,37 +802,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, mfOffset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(short.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().putShort(payload, offset + i * Short.BYTES, (short) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                short si = Unsafe.getUnsafe().getShort(indices, offset + i * Short.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -825,1 +808,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new Short64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":62,"deletions":78,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1189,1 +1189,1 @@\n-    \/**\n+   \/**\n@@ -2599,2 +2599,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Short> toShuffle0(ShortSpecies dsp) {\n@@ -2609,0 +2609,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), short.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ShortVector::toShuffle0);\n+    }\n+\n@@ -4197,1 +4209,0 @@\n-                Class<? extends AbstractShuffle<Short>> shuffleType,\n@@ -4200,1 +4211,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4496,1 +4507,0 @@\n-                            Short64Vector.Short64Shuffle.class,\n@@ -4504,1 +4514,0 @@\n-                            Short128Vector.Short128Shuffle.class,\n@@ -4512,1 +4521,0 @@\n-                            Short256Vector.Short256Shuffle.class,\n@@ -4520,1 +4528,0 @@\n-                            Short512Vector.Short512Shuffle.class,\n@@ -4529,1 +4536,0 @@\n-                            ShortMaxVector.ShortMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-    public abstract int laneSource(int i);\n+    public int laneSource(int i) { return toArray()[i]; }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1340,1 +1340,1 @@\n-    \/**\n+   \/**\n@@ -2993,2 +2993,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<$Boxtype$> toShuffle0($Type$Species dsp) {\n@@ -3003,0 +3003,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), $type$.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     $Type$Vector::toShuffle0);\n+    }\n+\n@@ -5482,1 +5494,0 @@\n-                Class<? extends AbstractShuffle<$Boxtype$>> shuffleType,\n@@ -5485,1 +5496,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -5788,1 +5799,0 @@\n-                            $Type$64Vector.$Type$64Shuffle.class,\n@@ -5796,1 +5806,0 @@\n-                            $Type$128Vector.$Type$128Shuffle.class,\n@@ -5804,1 +5813,0 @@\n-                            $Type$256Vector.$Type$256Shuffle.class,\n@@ -5812,1 +5820,0 @@\n-                            $Type$512Vector.$Type$512Shuffle.class,\n@@ -5821,1 +5828,0 @@\n-                            $Type$MaxVector.$Type$MaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -146,0 +146,11 @@\n+    @ForceInline\n+    $shuffletype$ iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -148,1 +159,5 @@\n-    $shuffletype$ shuffleFromArray(int[] indices, int i) { return new $shuffletype$(indices, i); }\n+    $shuffletype$ shuffleFromBytes(VectorPayloadMF indexes) { return new $shuffletype$(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    $shuffletype$ shuffleFromArray(int[] indexes, int i) { return new $shuffletype$(indexes, i); }\n@@ -349,4 +364,2 @@\n-    @Override\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<$Boxtype$> toShuffle() {\n+        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n@@ -950,0 +963,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,\n+                                         this, i, (m, idx) -> ((($masktype$) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n@@ -1002,1 +1025,1 @@\n-        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n+        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n@@ -1004,1 +1027,1 @@\n-        private final VectorPayloadMF$bits$$Boxbitsinitials$ payload;\n+        private final VectorPayloadMF$vectorsizeinbytes$B payload;\n@@ -1007,1 +1030,1 @@\n-            this.payload = (VectorPayloadMF$bits$$Boxbitsinitials$) payload;\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B) payload;\n@@ -1009,1 +1032,5 @@\n-            assert(indicesInRange(payload));\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public $shuffletype$(int[] indexes) {\n+            this(indexes, 0);\n@@ -1012,2 +1039,2 @@\n-        $shuffletype$(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public $shuffletype$(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -1016,2 +1043,2 @@\n-        $shuffletype$(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public $shuffletype$(IntUnaryOperator fn) {\n+            this(prepare(VLENGTH, fn));\n@@ -1027,1 +1054,0 @@\n-        @ForceInline\n@@ -1035,2 +1061,2 @@\n-            assert(VLENGTH < $Boxbitstype$.MAX_VALUE);\n-            assert($Boxbitstype$.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -1042,2 +1068,3 @@\n-        $bitsvectortype$ toBitsVector() {\n-            return ($bitsvectortype$) super.toBitsVectorTemplate();\n+        public $vectortype$ toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, $shuffletype$.class, this, VLENGTH,\n+                                                    (s) -> (($vectortype$)(((AbstractShuffle<$Boxtype$>)(s)).toVectorTemplate())));\n@@ -1048,2 +1075,6 @@\n-        $Bitstype$Vector toBitsVector0() {\n-            return $bitsvectortype$.VSPECIES.dummyVectorMF().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -1052,69 +1083,7 @@\n-        @Override\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-#if[byte]\n-            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-#end[byte]\n-#if[short]\n-            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-#end[short]\n-#if[intOrFloat]\n-            toBitsVector().intoArray(a, offset);\n-#end[intOrFloat]\n-#if[longOrDouble]\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-#end[longOrDouble]\n-        }\n-\n-        private static VectorPayloadMF prepare(int[] indices, int offset) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory($bitstype$.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long mfOffset = payload.multiFieldOffset();\n+        public $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n+            $shuffletype$ s = ($shuffletype$) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n@@ -1122,37 +1091,3 @@\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().put$Bitstype$(payload, mfOffset + i * $Boxbitstype$.BYTES, ($bitstype$) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-        private static VectorPayloadMF prepare(IntUnaryOperator f) {\n-            VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory($bitstype$.class, VLENGTH);\n-            payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n-            long offset = payload.multiFieldOffset();\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                Unsafe.getUnsafe().put$Bitstype$(payload, offset + i * $Boxbitstype$.BYTES, ($bitstype$) si);\n-            }\n-            payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n-            return payload;\n-        }\n-\n-\n-        private static boolean indicesInRange(VectorPayloadMF indices) {\n-            int length = indices.length();\n-            long offset = indices.multiFieldOffset();\n-            for (int i = 0; i < length; i++) {\n-                $bitstype$ si = Unsafe.getUnsafe().get$Bitstype$(indices, offset + i * $Boxbitstype$.BYTES);\n-                if (si >= length || si < -length) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                indices.toString());\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -1162,1 +1097,2 @@\n-            return true;\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new $shuffletype$(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":63,"deletions":127,"binary":false,"changes":190,"status":"modified"}]}