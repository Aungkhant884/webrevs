{"files":[{"patch":"@@ -3550,2 +3550,1 @@\n-\/\/ Check if 'obj' is an inline type by checking if it has the inline_type_pattern markWord pattern set.\n-Node* GraphKit::inline_type_test(Node* obj) {\n+Node* GraphKit::inline_type_test(Node* obj, bool is_inline) {\n@@ -3554,3 +3553,4 @@\n-  Node* mask = _gvn.MakeConX(markWord::inline_type_pattern);\n-  Node* andx = _gvn.transform(new AndXNode(mark, mask));\n-  return _gvn.transform(new CmpXNode(andx, mask));\n+  Node* mask = MakeConX(markWord::inline_type_pattern);\n+  Node* masked = _gvn.transform(new AndXNode(mark, mask));\n+  Node* cmp = _gvn.transform(new CmpXNode(masked, mask));\n+  return _gvn.transform(new BoolNode(cmp, is_inline ? BoolTest::eq : BoolTest::ne));\n@@ -3559,2 +3559,7 @@\n-Node* GraphKit::is_inline_type(Node* obj) {\n-  return _gvn.transform(new BoolNode(inline_type_test(obj), BoolTest::eq));\n+Node* GraphKit::array_lh_test(Node* klass, jint mask, jint val, bool eq) {\n+  Node* lh_adr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+  \/\/ Make sure to use immutable memory here to enable hoisting the check out of loops\n+  Node* lh_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lh_adr, lh_adr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* masked = _gvn.transform(new AndINode(lh_val, intcon(mask)));\n+  Node* cmp = _gvn.transform(new CmpINode(masked, intcon(val)));\n+  return _gvn.transform(new BoolNode(cmp, eq ? BoolTest::eq : BoolTest::ne));\n@@ -3563,2 +3568,3 @@\n-Node* GraphKit::is_not_inline_type(Node* obj) {\n-  return _gvn.transform(new BoolNode(inline_type_test(obj), BoolTest::ne));\n+Node* GraphKit::flat_array_test(Node* ary, bool flat) {\n+  Node* klass = load_object_klass(ary);\n+  return array_lh_test(klass, Klass::_lh_array_tag_vt_value_bit_inplace, 0, !flat);\n@@ -3567,21 +3573,2 @@\n-\/\/ Check if 'ary' is a non-flattened array\n-Node* GraphKit::is_non_flattened_array(Node* ary) {\n-  Node* kls = load_object_klass(ary);\n-  Node* cmp = gen_lh_array_test(kls, Klass::_lh_array_tag_vt_value);\n-  return _gvn.transform(new BoolNode(cmp, BoolTest::ne));\n-}\n-\n-\/\/ Check bit that determines if an array is null-free\n-Node* GraphKit::check_null_free_bit(Node* klass, bool null_free) {\n-  Node* lhp = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n-  Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-  Node* bit = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));\n-  bit = _gvn.transform(new AndINode(bit, intcon(Klass::_lh_null_free_mask)));\n-  Node* cmp = _gvn.transform(new CmpINode(bit, intcon(0)));\n-  return _gvn.transform(new BoolNode(cmp, null_free ? BoolTest::ne : BoolTest::eq));\n-}\n-\n-\/\/ Check if 'ary' is a nullable array\n-Node* GraphKit::is_nullable_array(Node* ary) {\n-  Node* kls = load_object_klass(ary);\n-  return check_null_free_bit(kls, false);\n+Node* GraphKit::null_free_array_test(Node* klass, bool null_free) {\n+  return array_lh_test(klass, Klass::_lh_null_free_bit_inplace, 0, !null_free);\n@@ -3591,1 +3578,1 @@\n-Node* GraphKit::gen_inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {\n+Node* GraphKit::inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {\n@@ -3604,1 +3591,1 @@\n-      BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);\n+      BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n@@ -3627,12 +3614,0 @@\n-Node* GraphKit::load_lh_array_tag(Node* kls) {\n-  Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));\n-  Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-  return _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n-}\n-\n-Node* GraphKit::gen_lh_array_test(Node* kls, unsigned int lh_value) {\n-  Node* layout_val = load_lh_array_tag(kls);\n-  Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(lh_value)));\n-  return cmp;\n-}\n-\n@@ -4044,8 +4019,0 @@\n-\/\/ With compressed oops, the 64 bit init value for non flattened value\n-\/\/ arrays is built from 2 32 bit compressed oops\n-static Node* raw_default_for_coops(Node* default_value, GraphKit& kit) {\n-  Node* lower = kit.gvn().transform(new CastP2XNode(kit.control(), default_value));\n-  Node* upper = kit.gvn().transform(new LShiftLNode(lower, kit.intcon(32)));\n-  return kit.gvn().transform(new OrLNode(lower, upper));\n-}\n-\n@@ -4226,6 +4193,0 @@\n-        if (UseCompressedOops) {\n-          default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n-          raw_default_value = raw_default_for_coops(default_value, *this);\n-        } else {\n-          raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n-        }\n@@ -4237,1 +4198,1 @@\n-    Node* r = new RegionNode(4);\n+    Node* r = new RegionNode(3);\n@@ -4240,3 +4201,1 @@\n-    \/\/ Check if array is an object array\n-    Node* cmp = gen_lh_array_test(klass_node, Klass::_lh_array_tag_obj_value);\n-    Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+    Node* bol = array_lh_test(klass_node, Klass::_lh_array_tag_vt_value_bit_inplace | Klass::_lh_null_free_bit_inplace, Klass::_lh_null_free_bit_inplace);\n@@ -4245,12 +4204,0 @@\n-    \/\/ Not an object array, initialize with all zero\n-    r->init_req(1, _gvn.transform(new IfFalseNode(iff)));\n-    default_value->init_req(1, null());\n-\n-    \/\/ Object array, check if null-free\n-    set_control(_gvn.transform(new IfTrueNode(iff)));\n-    iff = create_and_map_if(control(), check_null_free_bit(klass_node, true), PROB_FAIR, COUNT_UNKNOWN);\n-\n-    \/\/ Not null-free, initialize with all zero\n-    r->init_req(2, _gvn.transform(new IfFalseNode(iff)));\n-    default_value->init_req(2, null());\n-\n@@ -4268,2 +4215,6 @@\n-    r->init_req(3, control());\n-    default_value->init_req(3, val);\n+    r->init_req(1, control());\n+    default_value->init_req(1, val);\n+\n+    \/\/ Otherwise initialize with all zero\n+    r->init_req(2, _gvn.transform(new IfFalseNode(iff)));\n+    default_value->init_req(2, null());\n@@ -4273,0 +4224,2 @@\n+  }\n+  if (default_value != NULL) {\n@@ -4274,0 +4227,1 @@\n+      \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n@@ -4275,1 +4229,3 @@\n-      raw_default_value = raw_default_for_coops(default_value, *this);\n+      Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n+      Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n+      raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":33,"deletions":77,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -856,9 +856,6 @@\n-  Node* inline_type_test(Node* obj);\n-  Node* is_inline_type(Node* obj);\n-  Node* is_not_inline_type(Node* obj);\n-  Node* is_non_flattened_array(Node* ary);\n-  Node* check_null_free_bit(Node* klass, bool null_free);\n-  Node* is_nullable_array(Node* ary);\n-  Node* gen_inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace = false);\n-  Node* load_lh_array_tag(Node* kls);\n-  Node* gen_lh_array_test(Node* kls, unsigned int lh_value);\n+  \/\/ Inline types\n+  Node* inline_type_test(Node* obj, bool is_inline = true);\n+  Node* array_lh_test(Node* kls, jint mask, jint val, bool eq = true);\n+  Node* flat_array_test(Node* ary, bool flat = true);\n+  Node* null_free_array_test(Node* klass, bool null_free = true);\n+  Node* inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-  if ((unsigned int)cmp_in2->find_int_con(0) != Klass::_lh_array_tag_vt_value) {\n+  if (cmp_in2->find_int_con(-1) != 0) {\n@@ -1200,1 +1200,1 @@\n-  if (cmp_in1->Opcode() != Op_RShiftI) {\n+  if (cmp_in1->Opcode() != Op_AndI) {\n@@ -1203,3 +1203,3 @@\n-  Node* shift_in1 = cmp_in1->in(1);\n-  Node* shift_in2 = cmp_in1->in(2);\n-  if ((unsigned int)shift_in2->find_int_con(0) != Klass::_lh_array_tag_shift) {\n+  Node* and_in1 = cmp_in1->in(1);\n+  Node* and_in2 = cmp_in1->in(2);\n+  if (and_in2->find_int_con(0) != Klass::_lh_array_tag_vt_value_bit_inplace) {\n@@ -1208,1 +1208,1 @@\n-  if (shift_in1->Opcode() != Op_LoadI) {\n+  if (and_in1->Opcode() != Op_LoadI) {\n@@ -1212,1 +1212,1 @@\n-  Node* ptr = shift_in1->in(MemNode::Address);\n+  Node* ptr = and_in1->in(MemNode::Address);\n@@ -1228,1 +1228,0 @@\n-  assert(bol->isa_Bool()->_test._test == BoolTest::ne, \"IfTrue proj must point to non-flattened array\");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3495,3 +3495,3 @@\n-      value = Klass::_lh_array_tag_vt_value;\n-      layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n-      btest = (kind == FlatArray) ? BoolTest::eq : BoolTest::ne;\n+      value = 0;\n+      layout_val = _gvn.transform(new AndINode(layout_val, intcon(Klass::_lh_array_tag_vt_value_bit_inplace)));\n+      btest = (kind == FlatArray) ? BoolTest::ne : BoolTest::eq;\n@@ -3740,1 +3740,1 @@\n-        generate_fair_guard(check_null_free_bit(klass_node, true), bailout);\n+        generate_fair_guard(null_free_array_test(klass_node), bailout);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -223,1 +223,2 @@\n-  if (unswitch_iffs.size() > 1) {\n+  bool flat_array_checks = unswitch_iffs.size() > 1;\n+  if (flat_array_checks) {\n@@ -230,3 +231,5 @@\n-    \/\/ can be removed from the fast loop but not from the slow loop\n-    \/\/ as it can have a mix of flattened\/legacy accesses.\n-    bol = bol->clone()->as_Bool();\n+    \/\/ can be removed from the fast loop (true proj) but not from the\n+    \/\/ slow loop (false proj) as it can have a mix of flattened\/legacy accesses.\n+    assert(bol->_test._test == BoolTest::ne, \"IfTrue proj must point to flat array\");\n+    \/\/ Adjust condition such that the true proj points to non-flat array\n+    bol = new BoolNode(bol->in(1), bol->_test.negate());\n@@ -238,1 +241,1 @@\n-    Node* in1 = NULL;\n+    Node* lhs = NULL;\n@@ -240,5 +243,3 @@\n-      Node* array_tag = unswitch_iffs.at(i)->in(1)->in(1)->in(1);\n-      array_tag = new AndINode(array_tag, _igvn.intcon(Klass::_lh_array_tag_vt_value));\n-      register_new_node(array_tag, invar_iff->in(0));\n-      if (in1 == NULL) {\n-        in1 = array_tag;\n+      Node* lh = unswitch_iffs.at(i)->in(1)->in(1)->in(1)->in(1);\n+      if (lhs == NULL) {\n+        lhs = lh;\n@@ -246,2 +247,2 @@\n-        in1 = new OrINode(in1, array_tag);\n-        register_new_node(in1, invar_iff->in(0));\n+        lhs = new OrINode(lhs, lh);\n+        register_new_node(lhs, invar_iff->in(0));\n@@ -250,1 +251,3 @@\n-    cmp->set_req(1, in1);\n+    Node* masked = new AndINode(lhs, _igvn.intcon(Klass::_lh_array_tag_vt_value_bit_inplace));\n+    register_new_node(masked, invar_iff->in(0));\n+    cmp->set_req(1, masked);\n@@ -267,1 +270,1 @@\n-      ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();\n+      ProjNode* invar_proj = invar_iff->proj_out(flat_array_checks ? (1-proj->_con) : proj->_con)->as_Proj();\n@@ -275,1 +278,1 @@\n-        if (unswitch_iffs.size() == 1) {\n+        if (!flat_array_checks) {\n@@ -287,1 +290,1 @@\n-    dominated_by(proj_true, iff, false, false);\n+    dominated_by(proj_true, iff, \/* flip = *\/ flat_array_checks, false);\n@@ -290,1 +293,1 @@\n-  if (unswitch_iffs.size() == 1) {\n+  if (!flat_array_checks) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -137,1 +137,2 @@\n-  Node* generate_flat_array_guard(Node** ctrl, Node* mem, Node* obj, RegionNode* region);\n+  Node* array_lh_test(Node* array, jint mask);\n+  Node* generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,1 +192,11 @@\n-Node* PhaseMacroExpand::generate_flat_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {\n+Node* PhaseMacroExpand::array_lh_test(Node* array, jint mask) {\n+  Node* klass_adr = basic_plus_adr(array, oopDesc::klass_offset_in_bytes());\n+  Node* klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+  Node* lh_addr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+  Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* masked = transform_later(new AndINode(lh_val, intcon(mask)));\n+  Node* cmp = transform_later(new CmpINode(masked, intcon(0)));\n+  return transform_later(new BoolNode(cmp, BoolTest::ne));\n+}\n+\n+Node* PhaseMacroExpand::generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region) {\n@@ -194,1 +204,1 @@\n-  return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_vt_value);\n+  return generate_fair_guard(ctrl, array_lh_test(array, Klass::_lh_array_tag_vt_value_bit_inplace), region);\n@@ -198,9 +208,2 @@\n-  Node* k_adr = basic_plus_adr(array, oopDesc::klass_offset_in_bytes());\n-  Node* klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n-  Node* lhp = basic_plus_adr(klass_node, in_bytes(Klass::layout_helper_offset()));\n-  Node* layout_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lhp, lhp->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-  Node* null_free = _igvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));\n-  null_free = _igvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));\n-  Node* cmp = _igvn.transform(new CmpINode(null_free, intcon(0)));\n-  Node* test = _igvn.transform(new BoolNode(cmp, BoolTest::ne));\n-  return generate_fair_guard(ctrl, test, region);\n+  assert(EnableValhalla, \"can never be null free\");\n+  return generate_fair_guard(ctrl, array_lh_test(array, Klass::_lh_null_free_bit_inplace), region);\n@@ -1418,1 +1421,6 @@\n-        generate_flat_array_guard(&ctrl, merge_mem, src, slow_region);\n+        generate_flat_array_guard(&ctrl, src, slow_region);\n+      }\n+      if (EnableValhalla) {\n+        \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n+        \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n+        generate_null_free_array_guard(&ctrl, dest, slow_region);\n@@ -1420,3 +1428,0 @@\n-      \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n-      \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n-      generate_null_free_array_guard(&ctrl, dest, slow_region);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    ideal.if_then(is_non_flattened_array(ary)); {\n+    ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n@@ -307,1 +307,1 @@\n-      ideal.if_then(is_non_flattened_array(ary)); {\n+      ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n@@ -311,1 +311,1 @@\n-        gen_inline_array_null_guard(ary, cast_val, 3);\n+        inline_array_null_guard(ary, cast_val, 3);\n@@ -390,1 +390,1 @@\n-      ary = gen_inline_array_null_guard(ary, cast_val, 3, true);\n+      ary = inline_array_null_guard(ary, cast_val, 3, true);\n@@ -576,1 +576,1 @@\n-        BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);\n+        BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n@@ -605,1 +605,1 @@\n-        BuildCutout unless(this, is_non_flattened_array(ary), PROB_MAX);\n+        BuildCutout unless(this, flat_array_test(ary, \/* flat = *\/ false), PROB_MAX);\n@@ -2152,1 +2152,1 @@\n-    BuildCutout unless(this, is_not_inline_type(cast), PROB_MAX);\n+    BuildCutout unless(this, inline_type_test(cast, \/* is_inline = *\/ false), PROB_MAX);\n@@ -2330,1 +2330,1 @@\n-  Node* is_value = is_inline_type(not_null_right);\n+  Node* is_value = inline_type_test(not_null_right);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}