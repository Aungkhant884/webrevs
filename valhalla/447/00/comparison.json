{"files":[{"patch":"@@ -794,0 +794,4 @@\n+     * object represents the {@linkplain #isPrimaryType() reference type}\n+     * of a {@linkplain #isPrimitiveClass() primitive class}, this method\n+     * return {@code true} if the specified {@code Class} parameter represents\n+     * the same primitive class. If this {@code Class}\n@@ -802,3 +806,3 @@\n-     * or via a widening reference conversion. See <cite>The Java Language\n-     * Specification<\/cite>, sections {@jls 5.1.1} and {@jls 5.1.4},\n-     * for details.\n+     * or via a widening reference conversion or via a primitive widening\n+     * conversion. See <cite>The Java Language Specification<\/cite>,\n+     * sections {@jls 5.1.1} and {@jls 5.1.4}, for details.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4316,1 +4316,3 @@\n-     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be\n+     * is {@code null} or if the array's element type is a {@link Class#isValueType()\n+     * a primitive value type} and attempts to set {@code null} in the\n+     * array element.  An {@code ArrayIndexOutOfBoundsException} will be\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test VarHandle on inline class array\n+ * @summary test VarHandle on primitive class array\n@@ -39,110 +39,0 @@\n-    private final Class<?> varHandleArrayType;\n-    private final Class<?> componentType;\n-    private final VarHandle vh;\n-\n-    ArrayElementVarHandleTest(Class<?> arrayType) {\n-        this.varHandleArrayType = arrayType;\n-        this.componentType = arrayType.getComponentType();\n-        this.vh = MethodHandles.arrayElementVarHandle(arrayType);\n-    }\n-\n-    Object[] newArray(int size) throws Throwable {\n-        MethodHandle ctor = MethodHandles.arrayConstructor(varHandleArrayType);\n-        return (Object[]) ctor.invoke(size);\n-    }\n-\n-    void setElements(Object[] array, Object[] elements) {\n-        Class<?> arrayType = array.getClass();\n-        assertTrue(varHandleArrayType.isAssignableFrom(arrayType));\n-        assertTrue(array.length >= elements.length);\n-        set(array.clone(), elements);\n-        setVolatile(array.clone(), elements);\n-        setOpaque(array.clone(), elements);\n-        setRelease(array.clone(), elements);\n-        getAndSet(array.clone(), elements);\n-        compareAndSet(array.clone(), elements);\n-        compareAndExchange(array.clone(), elements);\n-    }\n-\n-    \/\/ VarHandle::set\n-    void set(Object[] array, Object[] elements) {\n-        for (int i = 0; i < elements.length; i++) {\n-            vh.set(array, i, elements[i]);\n-        }\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = (Object) vh.get(array, i);\n-            assertEquals(v, elements[i]);\n-        }\n-    }\n-\n-    \/\/ VarHandle::setVolatile\n-    void setVolatile(Object[] array, Object[] elements) {\n-        for (int i = 0; i < elements.length; i++) {\n-            vh.setVolatile(array, i, elements[i]);\n-        }\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = (Object) vh.getVolatile(array, i);\n-            assertEquals(v, elements[i]);\n-        }\n-    }\n-\n-    \/\/ VarHandle::setOpaque\n-    void setOpaque(Object[] array, Object[] elements) {\n-        for (int i = 0; i < elements.length; i++) {\n-            vh.setOpaque(array, i, elements[i]);\n-        }\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = (Object) vh.getOpaque(array, i);\n-            assertEquals(v, elements[i]);\n-        }\n-    }\n-\n-    \/\/ VarHandle::setRelease\n-    void setRelease(Object[] array, Object[] elements) {\n-        for (int i = 0; i < elements.length; i++) {\n-            vh.setRelease(array, i, elements[i]);\n-        }\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = (Object) vh.getAcquire(array, i);\n-            assertEquals(v, elements[i]);\n-        }\n-    }\n-\n-    void getAndSet(Object[] array, Object[] elements) {\n-        for (int i = 0; i < elements.length; i++) {\n-            Object o = vh.getAndSet(array, i, elements[i]);\n-        }\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = (Object) vh.get(array, i);\n-            assertEquals(v, elements[i]);\n-        }\n-    }\n-\n-    \/\/ sanity CAS test\n-    \/\/ see test\/jdk\/java\/lang\/invoke\/VarHandles tests\n-    void compareAndSet(Object[] array, Object[] elements) {\n-        \/\/ initialize to some values\n-        for (int i = 0; i < elements.length; i++) {\n-            vh.set(array, i, elements[i]);\n-        }\n-        \/\/ shift to the right element\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = elements[i+1 < elements.length ? i+1 : 0];\n-            boolean cas = vh.compareAndSet(array, i, elements[i], v);\n-            if (!cas)\n-                System.out.format(\"cas = %s array[%d] = %s vs old = %s new = %s%n\", cas, i, array[i], elements[i], v);\n-            assertTrue(cas);\n-        }\n-    }\n-    void compareAndExchange(Object[] array, Object[] elements) {\n-        \/\/ initialize to some values\n-        for (int i = 0; i < elements.length; i++) {\n-            vh.set(array, i, elements[i]);\n-        }\n-        \/\/ shift to the right element\n-        for (int i = 0; i < elements.length; i++) {\n-            Object v = elements[i+1 < elements.length ? i+1 : 0];\n-            assertEquals(vh.compareAndExchange(array, i, elements[i], v), elements[i]);\n-        }\n-    }\n-\n@@ -160,3 +50,3 @@\n-        Point.makePoint(11, 22),\n-                Point.makePoint(110, 220),\n-                null\n+            Point.makePoint(11, 22),\n+            Point.makePoint(110, 220),\n+            null\n@@ -184,2 +74,1 @@\n-    public static void testObjectArrayVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Object[].class);\n+    public void testObjectArrayVarHandle() throws Throwable {\n@@ -187,4 +76,4 @@\n-        Object[] array1 = test.newArray(POINTS.length);\n-        test.setElements(array1, POINTS);\n-        test.setElements(array1, NULL_POINTS);\n-        test.setElements(array1, new Object[] { \"abc\", Point.makePoint(1, 2) });\n+        Object[] array1 = newArray(Object[].class, POINTS.length);\n+        setElements(array1, POINTS);\n+        setElements(array1, NULL_POINTS);\n+        setElements(array1, new Object[] { \"abc\", Point.makePoint(1, 2) });\n@@ -192,3 +81,3 @@\n-        Point.ref []array2 = new Point.ref [NULL_POINTS.length];\n-        test.setElements(array2, POINTS);\n-        test.setElements(array2, NULL_POINTS);\n+        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];\n+        setElements(array2, POINTS);\n+        setElements(array2, NULL_POINTS);\n@@ -197,1 +86,1 @@\n-        test.setElements(array3, POINTS);\n+        setElements(array3, POINTS);\n@@ -204,4 +93,1 @@\n-    public static void testPointRefVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Point.ref[].class);\n-        assertTrue(test.componentType == Point.ref.class);\n-\n+    public void testPointRefVarHandle() throws Throwable {\n@@ -209,3 +95,5 @@\n-        Point.ref[] array1 = (Point.ref[])test.newArray(POINTS.length);\n-        test.setElements(array1, POINTS);\n-        test.setElements(array1, NULL_POINTS);\n+        Point.ref[] array1 = (Point.ref[])newArray(Point.ref[].class, POINTS.length);\n+        assertTrue(array1.getClass().componentType() == Point.ref.class);\n+\n+        setElements(array1, POINTS);\n+        setElements(array1, NULL_POINTS);\n@@ -214,2 +102,2 @@\n-        test.setElements(array2, POINTS);\n-        test.setElements(array2, NULL_POINTS);\n+        setElements(array2, POINTS);\n+        setElements(array2, NULL_POINTS);\n@@ -218,1 +106,1 @@\n-        test.setElements(array3, POINTS);\n+        setElements(array3, POINTS);\n@@ -225,4 +113,1 @@\n-    public static void testPointArrayVarHandle()  throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Point[].class);\n-        assertTrue(test.componentType == Point.class);\n-\n+    public void testPointArrayVarHandle()  throws Throwable {\n@@ -230,2 +115,3 @@\n-        Point[] array1 = (Point[]) test.newArray(POINTS.length);\n-        test.setElements(array1, POINTS);\n+        Point[] array1 = (Point[]) newArray(Point[].class, POINTS.length);\n+        assertTrue(array1.getClass().componentType() == Point.class);\n+        setElements(array1, POINTS);\n@@ -234,1 +120,1 @@\n-        test.setElements(array3, POINTS);\n+        setElements(array3, POINTS);\n@@ -241,4 +127,1 @@\n-    public static void testLineRefVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Line.ref[].class);\n-        assertTrue(test.componentType == Line.ref.class);\n-\n+    public void testLineRefVarHandle() throws Throwable {\n@@ -246,3 +129,5 @@\n-        Line.ref[] array1 = (Line.ref[])test.newArray(LINES.length);\n-        test.setElements(array1, LINES);\n-        test.setElements(array1, NULL_LINES);\n+        Line.ref[] array1 = (Line.ref[])newArray(Line.ref[].class, LINES.length);\n+        assertTrue(array1.getClass().componentType() == Line.ref.class);\n+\n+        setElements(array1, LINES);\n+        setElements(array1, NULL_LINES);\n@@ -251,2 +136,2 @@\n-        test.setElements(array2, LINES);\n-        test.setElements(array2, NULL_LINES);\n+        setElements(array2, LINES);\n+        setElements(array2, NULL_LINES);\n@@ -255,1 +140,1 @@\n-        test.setElements(array3, LINES);\n+        setElements(array3, LINES);\n@@ -262,6 +147,4 @@\n-    public static void testLineVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Line[].class);\n-        assertTrue(test.componentType == Line.class);\n-\n-        Line[] array1 = (Line[]) test.newArray(LINES.length);\n-        test.setElements(array1, LINES);\n+    public void testLineVarHandle() throws Throwable {\n+        Line[] array1 = (Line[])newArray(Line[].class, LINES.length);\n+        assertTrue(array1.getClass().componentType() == Line.class);\n+        setElements(array1, LINES);\n@@ -270,1 +153,1 @@\n-        test.setElements(array3, LINES);\n+        setElements(array3, LINES);\n@@ -277,6 +160,4 @@\n-    public static void testNonFlattenedValueVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(NonFlattenValue[].class);\n-        assertTrue(test.componentType == NonFlattenValue.class);\n-\n-        NonFlattenValue[] array1 = (NonFlattenValue[]) test.newArray(NFV_ARRAY.length);\n-        test.setElements(array1, NFV_ARRAY);\n+    public void testNonFlattenedValueVarHandle() throws Throwable {\n+        NonFlattenValue[] array1 = (NonFlattenValue[])newArray(NonFlattenValue[].class, NFV_ARRAY.length);\n+        assertTrue(array1.getClass().componentType() == NonFlattenValue.class);\n+        setElements(array1, NFV_ARRAY);\n@@ -285,1 +166,103 @@\n-        test.setElements(array3, NFV_ARRAY);\n+        setElements(array3, NFV_ARRAY);\n+    }\n+\n+    Object[] newArray(Class<?> arrayType, int size) throws Throwable {\n+        MethodHandle ctor = MethodHandles.arrayConstructor(arrayType);\n+        return (Object[]) ctor.invoke(size);\n+    }\n+\n+    void setElements(Object[] array, Object[] elements) {\n+        Class<?> arrayType = array.getClass();\n+        assertTrue(array.length >= elements.length);\n+\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayType);\n+        set(vh, array.clone(), elements);\n+        setVolatile(vh, array.clone(), elements);\n+        setOpaque(vh, array.clone(), elements);\n+        setRelease(vh, array.clone(), elements);\n+        getAndSet(vh, array.clone(), elements);\n+        compareAndSet(vh, array.clone(), elements);\n+        compareAndExchange(vh, array.clone(), elements);\n+    }\n+\n+    \/\/ VarHandle::set\n+    void set(VarHandle vh, Object[] array, Object[] elements) {\n+        for (int i = 0; i < elements.length; i++) {\n+            vh.set(array, i, elements[i]);\n+        }\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = (Object) vh.get(array, i);\n+            assertEquals(v, elements[i]);\n+        }\n+    }\n+\n+    \/\/ VarHandle::setVolatile\n+    void setVolatile(VarHandle vh, Object[] array, Object[] elements) {\n+        for (int i = 0; i < elements.length; i++) {\n+            vh.setVolatile(array, i, elements[i]);\n+        }\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = (Object) vh.getVolatile(array, i);\n+            assertEquals(v, elements[i]);\n+        }\n+    }\n+\n+    \/\/ VarHandle::setOpaque\n+    void setOpaque(VarHandle vh, Object[] array, Object[] elements) {\n+        for (int i = 0; i < elements.length; i++) {\n+            vh.setOpaque(array, i, elements[i]);\n+        }\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = (Object) vh.getOpaque(array, i);\n+            assertEquals(v, elements[i]);\n+        }\n+    }\n+\n+    \/\/ VarHandle::setRelease\n+    void setRelease(VarHandle vh, Object[] array, Object[] elements) {\n+        for (int i = 0; i < elements.length; i++) {\n+            vh.setRelease(array, i, elements[i]);\n+        }\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = (Object) vh.getAcquire(array, i);\n+            assertEquals(v, elements[i]);\n+        }\n+    }\n+\n+    void getAndSet(VarHandle vh, Object[] array, Object[] elements) {\n+        for (int i = 0; i < elements.length; i++) {\n+            Object o = vh.getAndSet(array, i, elements[i]);\n+        }\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = (Object) vh.get(array, i);\n+            assertEquals(v, elements[i]);\n+        }\n+    }\n+\n+    \/\/ sanity CAS test\n+    \/\/ see test\/jdk\/java\/lang\/invoke\/VarHandles tests\n+    void compareAndSet(VarHandle vh, Object[] array, Object[] elements) {\n+        \/\/ initialize to some values\n+        for (int i = 0; i < elements.length; i++) {\n+            vh.set(array, i, elements[i]);\n+        }\n+        \/\/ shift to the right element\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = elements[i + 1 < elements.length ? i + 1 : 0];\n+            boolean cas = vh.compareAndSet(array, i, elements[i], v);\n+            if (!cas)\n+                System.out.format(\"cas = %s array[%d] = %s vs old = %s new = %s%n\", cas, i, array[i], elements[i], v);\n+            assertTrue(cas);\n+        }\n+    }\n+\n+    void compareAndExchange(VarHandle vh, Object[] array, Object[] elements) {\n+        \/\/ initialize to some values\n+        for (int i = 0; i < elements.length; i++) {\n+            vh.set(array, i, elements[i]);\n+        }\n+        \/\/ shift to the right element\n+        for (int i = 0; i < elements.length; i++) {\n+            Object v = elements[i + 1 < elements.length ? i + 1 : 0];\n+            assertEquals(vh.compareAndExchange(array, i, elements[i], v), elements[i]);\n+        }\n@@ -287,0 +270,2 @@\n+\n+\n","filename":"test\/jdk\/valhalla\/valuetypes\/ArrayElementVarHandleTest.java","additions":151,"deletions":166,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary test reflection on inline types\n+ * @summary test reflection on primitive classes\n@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,2 @@\n+import java.util.Set;\n+import java.util.stream.Collectors;\n@@ -102,0 +105,3 @@\n+    \/*\n+     * Tests the primary and secondary mirror.\n+     *\/\n@@ -108,1 +114,0 @@\n-        \/\/ ## ldc not implemented\n@@ -111,0 +116,1 @@\n+\n@@ -113,0 +119,1 @@\n+\n@@ -114,0 +121,3 @@\n+        assertFalse(refType.isValueType());\n+\n+        assertTrue(valType.isValueType());\n@@ -116,0 +126,1 @@\n+        assertEquals(refType.getName(), valType.getName());\n@@ -117,1 +128,33 @@\n-        assertEquals(valType.getName(), \"BasicTest$Point\");\n+        assertEquals(refType.getSimpleName(),\"Point\");\n+        assertEquals(valType.getSimpleName(),\"Point\");\n+\n+        assertEquals(valType.getTypeName(), \"BasicTest$Point\");\n+        assertEquals(refType.getTypeName(), \"BasicTest$Point.ref\");\n+    }\n+\n+    \/*\n+     * Tests subtyping relationship: Point <: Point.ref and Point <: Object\n+     *\n+     * Class:isAssignableFrom\n+     * Class::isInstance\n+     * Class::asSubclass\n+     *\/\n+    @Test\n+    public void testSubtypes() {\n+        \/\/ Point <: Point.ref and Point <: Object\n+        assertTrue(Point.ref.class.isAssignableFrom(Point.class));\n+        assertTrue(Object.class.isAssignableFrom(Point.class));\n+        assertFalse(Point.class.isAssignableFrom(Point.ref.class));\n+        assertTrue(Object.class.isAssignableFrom(Point.ref.class));\n+\n+        assertTrue(Point.class.asSubclass(Point.ref.class) == Point.class);\n+        try {\n+            Class<?> c = Point.ref.class.asSubclass(Point.class);\n+            fail(\"Point.ref cannot be cast to Point.class\");\n+        } catch (ClassCastException e) { }\n+\n+        Point o = new Point(10, 20);\n+        assertTrue(Point.class.isInstance(o));\n+        assertTrue(Point.ref.class.isInstance(o));\n+        assertFalse(Point.class.isInstance(null));\n+        assertFalse(Point.ref.class.isInstance(null));\n@@ -125,1 +168,1 @@\n-                new Object[] { \"[LBasicTest$Point;\", Point.ref[].class},\n+                new Object[] { \"[[LBasicTest$Point;\", Point.ref[][].class},\n@@ -132,0 +175,1 @@\n+        assertEquals(type.getName(), name);\n@@ -225,0 +269,17 @@\n+\n+    @Test\n+    public void testNestMembership() {\n+        assertTrue(Point.class.getNestHost() == BasicTest.class);\n+        assertTrue(T.class.getNestHost() == BasicTest.class);\n+        assertTrue(C.class.getNestHost() == BasicTest.class);\n+\n+        Class<?>[] members = BasicTest.class.getNestMembers();\n+        assertEquals(Point.class.getNestMembers(), members);\n+        assertEquals(T.class.getNestMembers(), members);\n+        assertEquals(C.class.getNestMembers(), members);\n+        assertEquals(Arrays.stream(members).collect(Collectors.toSet()),\n+                     Set.of(BasicTest.class,\n+                            Point.class.asPrimaryType(),\n+                            C.class.asPrimaryType(),\n+                            T.class.asPrimaryType()));\n+    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/BasicTest.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary Test reflection of constructors for inline classes\n- * @run testng\/othervm InlineConstructorTest\n- *\/\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class InlineConstructorTest {\n-\n-    \/\/ Target test class\n-    static primitive class SimpleInline {\n-        public final int x;\n-\n-        SimpleInline() {\n-            x = -1;\n-        }\n-\n-        public SimpleInline(int x) {\n-            this.x = x;\n-        }\n-    }\n-\n-    static final Class<?> INLINE_TYPE = SimpleInline.class;\n-\n-    @Test\n-    public static void testInlineClassConstructor() throws Exception {\n-        String cn = INLINE_TYPE.getName();\n-        Class<?> c = Class.forName(cn).asValueType();\n-\n-        assertTrue(c.isPrimitiveClass());\n-        assertTrue(c == INLINE_TYPE);\n-    }\n-\n-    @Test\n-    public static void constructor() throws Exception {\n-        Constructor<?> ctor = INLINE_TYPE.getDeclaredConstructor();\n-        Object o = ctor.newInstance();\n-        assertTrue(o.getClass() == INLINE_TYPE.asPrimaryType());\n-    }\n-\n-    \/\/ Check that the class has the expected Constructors\n-    @Test\n-    public static void constructors() throws Exception {\n-        Set<String> expectedSig = Set.of(\"public InlineConstructorTest$SimpleInline(int)\",\n-                                         \"InlineConstructorTest$SimpleInline()\");\n-        Constructor<? extends Object>[] cons = INLINE_TYPE.getDeclaredConstructors();\n-        Set<String> actualSig = Arrays.stream(cons).map(Constructor::toString)\n-                                      .collect(Collectors.toSet());\n-        boolean ok = expectedSig.equals(actualSig);\n-        if (!ok) {\n-            System.out.printf(\"expected: %s%n\", expectedSig);\n-            System.out.printf(\"declared: %s%n\", actualSig);\n-            assertTrue(ok);\n-        }\n-    }\n-\n-    \/\/ Check that the constructor and field can be set accessible\n-    @Test\n-    public static void setAccessible() throws Exception {\n-        Constructor<?> ctor = INLINE_TYPE.getDeclaredConstructor();\n-        ctor.setAccessible(true);\n-\n-        Field field = INLINE_TYPE.getField(\"x\");\n-        field.setAccessible(true);\n-    }\n-\n-    \/\/ Check that the constructor and field can be set accessible\n-    @Test\n-    public static void trySetAccessible() throws Exception {\n-        Constructor<?> ctor = INLINE_TYPE.getDeclaredConstructor();\n-        assertTrue(ctor.trySetAccessible());\n-\n-        Field field = INLINE_TYPE.getField(\"x\");\n-        assertTrue(field.trySetAccessible());\n-    }\n-\n-    \/\/ Check that the final field cannot be modified\n-    @Test(expectedExceptions = IllegalAccessException.class)\n-    public static void setFinalField() throws Exception {\n-        Field field = INLINE_TYPE.getField(\"x\");\n-        field.setAccessible(true);\n-        field.setInt(new SimpleInline(100), 200);\n-    }\n-\n-\n-    \/\/ Check that the class does not have a static method with the name <init>\n-    @Test\n-    public static void initFactoryNotMethods() {\n-        Method[] methods = INLINE_TYPE.getDeclaredMethods();\n-        for (Method m : methods) {\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                assertFalse(m.getName().equals(\"<init>\"));\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlineConstructorTest.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test method handles with inline type conversion\n- * @run testng\/othervm InlineTypeConversionTest\n- *\/\n-\n-import java.lang.invoke.*;\n-\n-import static java.lang.invoke.MethodType.*;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class InlineTypeConversionTest {\n-    static primitive class Value {\n-        Point val;\n-        Point.ref ref;\n-        Value(Point p1, Point.ref p2) {\n-            this.val = p1;\n-            this.ref = p2;\n-        }\n-    }\n-\n-    static Value narrow(Value.ref v) {\n-        return v;\n-    }\n-\n-    static Value.ref widen(Value v) {\n-        if (((Object)v) == null) {\n-            throw new Error(\"should never reach here: should be caught by runtime\");\n-        }\n-        return null;\n-    }\n-\n-    static final Value VALUE = new Value(new Point(10,10), new Point(20, 20));\n-\n-    @Test\n-    public static void inlineWidening() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findStatic(InlineTypeConversionTest.class, \"narrow\", methodType(Value.class, Value.ref.class));\n-        MethodHandle mh2 = mh1.asType(methodType(Value.class, Value.class));\n-        Object v = mh1.invoke(VALUE);\n-        assertEquals(v, VALUE);\n-        try {\n-            Object v1 = mh1.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-\n-        try {\n-            Object v2 = mh2.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-\n-    @Test\n-    public static void inlineNarrowing() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh = lookup.findStatic(InlineTypeConversionTest.class, \"widen\", methodType(Value.ref.class, Value.class));\n-        Object v = mh.invoke(VALUE);\n-        assertTrue(v == null);\n-        try {\n-            Object v1 = mh.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {\n-            e.printStackTrace();\n-        }\n-        MethodHandle mh2 = mh.asType(methodType(Value.class, Value.ref.class));\n-        try {\n-            Value v2 = (Value) mh2.invoke((Value.ref)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Test\n-    public static void valToRef() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point p1 = (Point) mh1.invokeExact(VALUE);\n-        Point.ref p2 = (Point.ref) mh2.invokeExact(VALUE);\n-        assertEquals(p1, p2);\n-    }\n-\n-    @Test\n-    public static void refToVal() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(VALUE);\n-        Point p2 = (Point) mh2.invokeExact(VALUE);\n-        assertEquals(p1, p2);\n-    }\n-\n-    @Test\n-    public static void valToRef1() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.ref.class));\n-\n-        Point p1 = (Point) mh1.invokeExact(VALUE);\n-        Point p2 = (Point) mh2.invoke(VALUE);\n-        Point p3 = (Point) mh2.invokeExact((Value.ref)VALUE);\n-        assertEquals(p1, p2);\n-        assertEquals(p1, p3);\n-    }\n-\n-    @Test\n-    public static void refToVal1() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.ref.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n-        Point.ref p2 = (Point.ref) mh2.invoke(v);\n-        Point.ref p3 = (Point.ref) mh2.invokeExact((Value.ref)v);\n-        assertEquals(p1, p2);\n-        assertEquals(p1, p3);\n-    }\n-\n-    @Test\n-    public static void refToVal2() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n-        try {\n-            Point p2 = (Point) mh2.invokeExact(v);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlineTypeConversionTest.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test lambda type conversion of inline type\n+ * @summary test lambda type conversion of primitive class\n@@ -30,1 +30,0 @@\n-import java.util.List;\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaConversion.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test MethodHandle\/VarHandle on inline types\n+ * @summary test MethodHandle\/VarHandle o primitive classes\n@@ -36,0 +36,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -40,0 +41,1 @@\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n@@ -44,4 +46,15 @@\n-    @Test\n-    public static void testPointClass() throws Throwable  {\n-        MethodHandleTest test = new MethodHandleTest(\"Point\", P, \"x\", \"y\");\n-        test.run();\n+    @DataProvider(name=\"fields\")\n+    static Object[][] fields() {\n+        MutablePath path = MutablePath.makePath(1, 2, 3, 4);\n+        MixedValues mv = new MixedValues(P, L, PATH, \"mixed\", \"types\");\n+        return new Object[][]{\n+                \/\/ primitive class with int fields\n+                new Object[] { \"Point\", P, new String[] { \"x\", \"y\"} },\n+                \/\/ primitive class whose fields are of primitive value type\n+                new Object[] { \"Line\", L, new String[] { \"p1\", \"p2\"} },\n+                \/\/ non-primitive class whose non-final fields are of primitive value type\n+                new Object[] { \"MutablePath\", PATH, new String[] {\"p1\", \"p2\"} },\n+                new Object[] { \"Point\", path.p1, new String[] {\"x\", \"y\"} },\n+                new Object[] { \"Point\", path.p2, new String[] {\"x\", \"y\"} },\n+                new Object[] { \"MixedValues\", mv, new String[] {\"p\", \"l\", \"mutablePath\", \"list\", \"nfp\"} },\n+        };\n@@ -50,5 +63,10 @@\n-    @Test\n-    public static void testLineClass() throws Throwable {\n-        MethodHandleTest test = new MethodHandleTest(\"Line\", L, \"p1\", \"p2\");\n-        test.run();\n-    }\n+    \/**\n+     * Test MethodHandle invocation on the fields of a given class.\n+     * MethodHandle produced by Lookup::unreflectGetter, Lookup::findGetter,\n+     * Lookup::findVarHandle.\n+     *\/\n+    @Test(dataProvider = \"fields\")\n+    public void testFieldGetterAndSetter(String cn, Object o, String[] fieldNames) throws Throwable  {\n+        Class<?> c = Class.forName(cn);\n+        for (String name : fieldNames) {\n+            Field f = c.getDeclaredField(name);\n@@ -56,4 +74,2 @@\n-    @Test\n-    public static void testMutablePath() throws Throwable {\n-        MethodHandleTest test = new MethodHandleTest(\"MutablePath\", PATH, \"p1\", \"p2\");\n-        test.run();\n+            MethodHandle mh = LOOKUP.findGetter(c, f.getName(), f.getType());\n+            Object v1 = mh.invoke(o);\n@@ -61,5 +77,11 @@\n-        \/\/ set the mutable fields\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n-        Point p = Point.makePoint(100, 200);\n-        test.setValueField(\"p1\", path, p);\n-        test.setValueField(\"p2\", path, p);\n+            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            Object v2 = vh.get(o);\n+\n+            MethodHandle mh3 = LOOKUP.unreflectGetter(f);\n+            Object v3 = mh.invoke(o);\n+\n+            if (c.isPrimitiveClass())\n+                ensureImmutable(f, o);\n+            else\n+                ensureNullable(f, o);\n+        }\n@@ -69,8 +91,6 @@\n-    public static void testValueFields() throws Throwable {\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 4);\n-        \/\/ p1 and p2 are a non-final field of inline type in a reference\n-        MethodHandleTest test1 = new MethodHandleTest(\"Point\", path.p1, \"x\", \"y\");\n-        test1.run();\n-\n-        MethodHandleTest test2 = new MethodHandleTest(\"Point\", path.p2, \"x\", \"y\");\n-        test2.run();\n+    public void testValueFields() throws Throwable {\n+        \/\/ set the mutable value fields\n+        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n+        Point p = Point.makePoint(100, 200);\n+        setValueField(MutablePath.class, \"p1\", path, p);\n+        setValueField(MutablePath.class, \"p2\", path, p);\n@@ -79,0 +99,2 @@\n+    \/\/ Test writing to a field of primitive value type and of primitive\n+    \/\/ reference type\n@@ -80,1 +102,3 @@\n-    public static void testMixedValues() throws Throwable {\n+    public void testMixedValues() throws Throwable {\n+        \/\/ set the mutable fields\n+        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n@@ -82,4 +106,0 @@\n-        MethodHandleTest test =\n-            new MethodHandleTest(\"MixedValues\", mv, \"p\", \"l\", \"mutablePath\", \"list\", \"nfp\");\n-        test.run();\n-\n@@ -88,3 +108,6 @@\n-        test.setValueField(\"p\", mv, p);\n-        test.setValueField(\"l\", mv, l);\n-        test.setValueField(\"staticPoint\", null, p);\n+\n+        setValueField(MutablePath.class, \"p1\", path, p);\n+        setValueField(MutablePath.class, \"p2\", path, p);\n+        setValueField(MixedValues.class, \"p\", mv, p);\n+        setValueField(MixedValues.class, \"l\", mv, l);\n+        setValueField(MixedValues.class, \"staticPoint\", null, p);\n@@ -92,3 +115,3 @@\n-        test.setField(\"nfp\", mv, p, false);\n-        test.setField(\"staticLine\", null, l, false);\n-        test.setField(\"staticLine\", null, null, false);\n+        setField(MixedValues.class, \"nfp\", mv, p, false);\n+        setField(MixedValues.class, \"staticLine\", null, l, false);\n+        setField(MixedValues.class, \"staticLine\", null, null, false);\n@@ -97,5 +120,8 @@\n-    @Test\n-    public static void testArrayElementSetterAndGetter() throws Throwable {\n-        testArray(Point[].class, P);\n-        testArray(Line[].class, L);\n-        testArray(MutablePath[].class, PATH);\n+    @DataProvider(name=\"arrays\")\n+    static Object[][] arrays() {\n+        return new Object[][]{\n+                new Object[] { Point[].class, P },\n+                new Object[] { Point.ref[].class, P },\n+                new Object[] { Line[].class, L },\n+                new Object[] { MutablePath[].class, PATH },\n+        };\n@@ -104,4 +130,6 @@\n-    static void testArray(Class<?> c, Object o) throws Throwable {\n-        MethodHandle setter = MethodHandles.arrayElementSetter(c);\n-        MethodHandle getter = MethodHandles.arrayElementGetter(c);\n-        MethodHandle ctor = MethodHandles.arrayConstructor(c);\n+    @Test(dataProvider = \"arrays\")\n+    public void testArrayElementSetterAndGetter(Class<?> arrayClass, Object o) throws Throwable {\n+        Class<?> elementType = arrayClass.getComponentType();\n+        MethodHandle setter = MethodHandles.arrayElementSetter(arrayClass);\n+        MethodHandle getter = MethodHandles.arrayElementGetter(arrayClass);\n+        MethodHandle ctor = MethodHandles.arrayConstructor(arrayClass);\n@@ -117,5 +145,0 @@\n-\n-        Class<?> elementType = c.getComponentType();\n-        if (elementType.isPrimitiveClass()) {\n-            assertTrue(elementType == elementType.asValueType());\n-        }\n@@ -124,2 +147,3 @@\n-            Object v = (Object)setter.invoke(array, 0, null);\n-            assertFalse(elementType.isPrimitiveClass(), \"should fail to set an inline class array element to null\");\n+            Object v = (Object)setter.invoke(array, 1, null);\n+            assertFalse(elementType.isValueType(), \"should fail to set a primitive class array element to null\");\n+            assertNull((Object)getter.invoke(array, 1));\n@@ -127,1 +151,1 @@\n-            assertTrue(elementType.isPrimitiveClass(), \"should only fail to set an inline class array element to null\");\n+            assertTrue(elementType.isValueType(), \"should only fail to set a primitive class array element to null\");\n@@ -131,35 +155,31 @@\n-    @Test\n-    public static void testNullableArray() throws Throwable {\n-        Class<?> arrayClass = (new Point.ref[0]).getClass();\n-        Class<?> elementType = arrayClass.getComponentType();\n-        assertTrue(elementType == Point.ref.class, arrayClass.getComponentType().toString());\n-\n-        MethodHandle setter = MethodHandles.arrayElementSetter(arrayClass);\n-        MethodHandle getter = MethodHandles.arrayElementGetter(arrayClass);\n-        MethodHandle ctor = MethodHandles.arrayConstructor(arrayClass);\n-        Object[] array = (Object[]) ctor.invoke(2);\n-        setter.invoke(array, 0, P);\n-        setter.invoke(array, 1, null);\n-        assertEquals((Point)getter.invoke(array, 0), P);\n-        assertNull((Object)getter.invoke(array, 1));\n-    }\n-\n-    private final Class<?> c;\n-    private final Object o;\n-    private final List<String> names;\n-    public MethodHandleTest(String cn, Object o, String... fields) throws Exception {\n-        this.c = Class.forName(cn);\n-        this.o = o;\n-        this.names = List.of(fields);\n-    }\n-\n-    public void run() throws Throwable {\n-        for (String name : names) {\n-            Field f = c.getDeclaredField(name);\n-            unreflectField(f);\n-            findGetter(f);\n-            varHandle(f);\n-            if (c.isPrimitiveClass())\n-                ensureImmutable(f);\n-            else\n-                ensureNullable(f);\n+    \/*\n+     * Test setting the given field to null via reflection, method handle\n+     * and var handle.\n+     *\/\n+    static void ensureNullable(Field f, Object o) throws Throwable {\n+        Class<?> c = f.getDeclaringClass();\n+        assertFalse(Modifier.isFinal(f.getModifiers()));\n+        assertFalse(Modifier.isStatic(f.getModifiers()));\n+        boolean canBeNull = f.getType().isPrimaryType();\n+        \/\/ test reflection\n+        try {\n+            f.set(o, null);\n+            assertTrue(canBeNull, f + \" cannot be set to null\");\n+        } catch (NullPointerException e) {\n+            assertFalse(canBeNull, f + \" should allow be set to null\");\n+        }\n+        \/\/ test method handle, i.e. putfield bytecode behavior\n+        try {\n+            MethodHandle mh = LOOKUP.findSetter(c, f.getName(), f.getType());\n+            mh.invoke(o, null);\n+            assertTrue(canBeNull, f + \" cannot be set to null\");\n+        } catch (NullPointerException e) {\n+            assertFalse(canBeNull, f + \" should allow be set to null\");\n+        }\n+        \/\/ test var handle\n+        try {\n+            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            vh.set(o, null);\n+            assertTrue(canBeNull, f + \" cannot be set to null\");\n+        } catch (NullPointerException e) {\n+            assertFalse(canBeNull, f + \" should allow be set to null\");\n@@ -169,13 +189,11 @@\n-    public List<String> names() {\n-        return names;\n-    }\n-\n-    void findGetter(Field f) throws Throwable {\n-        MethodHandle mh = MethodHandles.lookup().findGetter(c, f.getName(), f.getType());\n-        Object value = mh.invoke(o);\n-    }\n-\n-    void varHandle(Field f) throws Throwable {\n-        VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n-        Object value = vh.get(o);\n-    }\n+    static void ensureImmutable(Field f, Object o) throws Throwable {\n+        Class<?> c = f.getDeclaringClass();\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        assertFalse(Modifier.isStatic(f.getModifiers()));\n+        Object v = f.get(o);\n+        \/\/ test Field::set\n+        try {\n+            f.set(o, v);\n+            throw new RuntimeException(f + \" should be immutable\");\n+        } catch (IllegalAccessException e) {\n+        }\n@@ -183,3 +201,14 @@\n-    void unreflectField(Field f) throws Throwable {\n-        MethodHandle mh = MethodHandles.lookup().unreflectGetter(f);\n-        Object value = mh.invoke(o);\n+        \/\/ test method handle, i.e. putfield bytecode behavior\n+        try {\n+            MethodHandle mh = LOOKUP.findSetter(c, f.getName(), f.getType());\n+            mh.invoke(o, v);\n+            throw new RuntimeException(f + \" should be immutable\");\n+        } catch (IllegalAccessException e) {\n+        }\n+        \/\/ test var handle\n+        try {\n+            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            vh.set(o, v);\n+            throw new RuntimeException(f + \" should be immutable\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n@@ -189,1 +218,1 @@\n-     * Test setting a field of an inline type to a new value.\n+     * Test setting a field of a primitive class to a new value.\n@@ -192,2 +221,2 @@\n-    void setValueField(String name, Object obj, Object value) throws Throwable {\n-        setField(name, obj, value, true);\n+    static void setValueField(Class<?> c, String name, Object obj, Object value) throws Throwable {\n+        setField(c, name, obj, value, true);\n@@ -196,1 +225,5 @@\n-    void setField(String name, Object obj, Object value, boolean isValue) throws Throwable {\n+    \/*\n+     * Test Field::set, MethodHandle::set on a method handle of a field\n+     * and VarHandle::compareAndSet and compareAndExchange.\n+     *\/\n+    static void setField(Class<?> c, String name, Object obj, Object value, boolean isValue) throws Throwable {\n@@ -212,1 +245,0 @@\n-\n@@ -220,1 +252,1 @@\n-    private void setInstanceField(Field f, Object obj, Object value) throws Throwable {\n+    static void setInstanceField(Field f, Object obj, Object value) throws Throwable {\n@@ -224,1 +256,1 @@\n-            MethodHandle mh = MethodHandles.lookup().findSetter(c, f.getName(), f.getType());\n+            MethodHandle mh = LOOKUP.findSetter(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -232,1 +264,1 @@\n-        VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n+        VarHandle vh = LOOKUP.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -255,1 +287,1 @@\n-    private void setStaticField(Field f, Object value) throws Throwable {\n+    static void setStaticField(Field f, Object value) throws Throwable {\n@@ -259,1 +291,1 @@\n-            MethodHandle mh = MethodHandles.lookup().findStaticSetter(c, f.getName(), f.getType());\n+            MethodHandle mh = LOOKUP.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -266,1 +298,1 @@\n-        VarHandle vh = MethodHandles.lookup().findStaticVarHandle(c, f.getName(), f.getType());\n+        VarHandle vh = LOOKUP.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -288,59 +320,0 @@\n-\n-    \/*\n-     * Test setting the given field to null via reflection, method handle\n-     * and var handle.\n-     *\/\n-    void ensureNullable(Field f) throws Throwable {\n-        assertFalse(Modifier.isStatic(f.getModifiers()));\n-        boolean canBeNull = f.getType().isPrimaryType();\n-        \/\/ test reflection\n-        try {\n-            f.set(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-        \/\/ test method handle, i.e. putfield bytecode behavior\n-        try {\n-            MethodHandle mh = MethodHandles.lookup().findSetter(c, f.getName(), f.getType());\n-            mh.invoke(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-        \/\/ test var handle\n-        try {\n-            VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n-            vh.set(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-    }\n-\n-    void ensureImmutable(Field f) throws Throwable {\n-        assertFalse(Modifier.isStatic(f.getModifiers()));\n-        Object v = f.get(o);\n-        \/\/ test reflection\n-        try {\n-            f.set(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (IllegalAccessException e) {}\n-\n-        \/\/ test method handle, i.e. putfield bytecode behavior\n-        try {\n-            MethodHandle mh = MethodHandles.lookup().findSetter(c, f.getName(), f.getType());\n-            mh.invoke(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (IllegalAccessException e) { }\n-        \/\/ test var handle\n-        try {\n-            VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n-            vh.set(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (UnsupportedOperationException e) {}\n-    }\n-\n-    boolean isFlattened(Field f) {\n-        return (f.getModifiers() & 0x00008000) == 0x00008000;\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":150,"deletions":177,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test Object methods on inline types\n+ * @summary test Object methods on primitive classes\n@@ -91,1 +91,1 @@\n-            \/\/ reference classes containing fields of inline type\n+            \/\/ reference classes containing fields of primitive class\n@@ -99,7 +99,7 @@\n-            { new IndirectType0(10), new IndirectType0(10), true},\n-            { new InlineType1(10),   new InlineType1(10), true},\n-            { new InlineType2(10),   new InlineType2(10), true},\n-            { new InlineType1(20),   new InlineType2(20), false},\n-            { new InlineType2(20),   new InlineType1(20), true},\n-            { new IndirectType0(30), new InlineType1(30), true},\n-            { new IndirectType0(30), new InlineType2(30), true},\n+            { new ReferenceType0(10), new ReferenceType0(10), true},\n+            { new ValueType1(10),   new ValueType1(10), true},\n+            { new ValueType2(10),   new ValueType2(10), true},\n+            { new ValueType1(20),   new ValueType2(20), false},\n+            { new ValueType2(20),   new ValueType1(20), true},\n+            { new ReferenceType0(30), new ValueType1(30), true},\n+            { new ReferenceType0(30), new ValueType2(30), true},\n@@ -117,7 +117,7 @@\n-                { new IndirectType0(10), new IndirectType0(10), false, true},\n-                { new InlineType1(10),   new InlineType1(10),   true,  true},\n-                { new InlineType2(10),   new InlineType2(10),   true,  true},\n-                { new InlineType1(20),   new InlineType2(20),   false, false},\n-                { new InlineType2(20),   new InlineType1(20),   false, true},\n-                { new IndirectType0(30), new InlineType1(30),   false, true},\n-                { new IndirectType0(30), new InlineType2(30),   false, true},\n+                { new ReferenceType0(10), new ReferenceType0(10), false, true},\n+                { new ValueType1(10),   new ValueType1(10),   true,  true},\n+                { new ValueType2(10),   new ValueType2(10),   true,  true},\n+                { new ValueType1(20),   new ValueType2(20),   false, false},\n+                { new ValueType2(20),   new ValueType1(20),   false, true},\n+                { new ReferenceType0(30), new ValueType1(30),   false, true},\n+                { new ReferenceType0(30), new ValueType2(30),   false, true},\n@@ -220,1 +220,1 @@\n-    static class IndirectType0 implements Number {\n+    static class ReferenceType0 implements Number {\n@@ -222,1 +222,1 @@\n-        public IndirectType0(int i) {\n+        public ReferenceType0(int i) {\n@@ -237,1 +237,1 @@\n-    static primitive class InlineType1 implements Number {\n+    static primitive class ValueType1 implements Number {\n@@ -239,1 +239,1 @@\n-        public InlineType1(int i) {\n+        public ValueType1(int i) {\n@@ -247,1 +247,1 @@\n-    static primitive class InlineType2 implements Number {\n+    static primitive class ValueType2 implements Number {\n@@ -249,1 +249,1 @@\n-        public InlineType2(int i) {\n+        public ValueType2(int i) {\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary test method handles with primitive narrowing\/widening conversion\n+ * @run testng\/othervm PrimitiveTypeConversionTest\n+ *\/\n+\n+import java.lang.invoke.*;\n+\n+import static java.lang.invoke.MethodType.*;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class PrimitiveTypeConversionTest {\n+    static primitive class Value {\n+        Point val;\n+        Point.ref ref;\n+        Value(Point p1, Point.ref p2) {\n+            this.val = p1;\n+            this.ref = p2;\n+        }\n+    }\n+\n+    static Value narrow(Value.ref v) {\n+        return v;\n+    }\n+\n+    static Value.ref widen(Value v) {\n+        if (((Object)v) == null) {\n+            throw new Error(\"should never reach here: should be caught by runtime\");\n+        }\n+        return null;\n+    }\n+\n+    static final Value VALUE = new Value(new Point(10,10), new Point(20, 20));\n+\n+    @Test\n+    public static void primitiveWidening() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh1 = lookup.findStatic(PrimitiveTypeConversionTest.class, \"narrow\", methodType(Value.class, Value.ref.class));\n+        MethodHandle mh2 = mh1.asType(methodType(Value.class, Value.class));\n+        Object v = mh1.invoke(VALUE);\n+        assertEquals(v, VALUE);\n+        try {\n+            Object v1 = mh1.invoke((Object)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {}\n+\n+        try {\n+            Object v2 = mh2.invoke((Object)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {}\n+    }\n+\n+    @Test\n+    public static void primitiveNarrowing() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh = lookup.findStatic(PrimitiveTypeConversionTest.class, \"widen\", methodType(Value.ref.class, Value.class));\n+        Object v = mh.invoke(VALUE);\n+        assertTrue(v == null);\n+        try {\n+            Object v1 = mh.invoke((Object)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+        }\n+        MethodHandle mh2 = mh.asType(methodType(Value.class, Value.ref.class));\n+        try {\n+            Value v2 = (Value) mh2.invoke((Value.ref)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Test\n+    public static void valToRef() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.class));\n+        Value v = new Value(new Point(10,10), null);\n+\n+        Point p1 = (Point) mh1.invokeExact(VALUE);\n+        Point.ref p2 = (Point.ref) mh2.invokeExact(VALUE);\n+        assertEquals(p1, p2);\n+    }\n+\n+    @Test\n+    public static void refToVal() throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n+        Point.ref p1 = (Point.ref) mh1.invokeExact(VALUE);\n+        Point p2 = (Point) mh2.invokeExact(VALUE);\n+        assertEquals(p1, p2);\n+    }\n+\n+    @Test\n+    public static void valToRef1() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.ref.class));\n+\n+        Point p1 = (Point) mh1.invokeExact(VALUE);\n+        Point p2 = (Point) mh2.invoke(VALUE);\n+        Point p3 = (Point) mh2.invokeExact((Value.ref)VALUE);\n+        assertEquals(p1, p2);\n+        assertEquals(p1, p3);\n+    }\n+\n+    @Test\n+    public static void refToVal1() throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.ref.class));\n+        Value v = new Value(new Point(10,10), null);\n+\n+        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n+        Point.ref p2 = (Point.ref) mh2.invoke(v);\n+        Point.ref p3 = (Point.ref) mh2.invokeExact((Value.ref)v);\n+        assertEquals(p1, p2);\n+        assertEquals(p1, p3);\n+    }\n+\n+    @Test\n+    public static void refToVal2() throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n+        Value v = new Value(new Point(10,10), null);\n+\n+        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n+        try {\n+            Point p2 = (Point) mh2.invokeExact(v);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {}\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/PrimitiveTypeConversionTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    public static void testLambda() {\n+    public void testLambda() {\n@@ -61,1 +61,1 @@\n-    public static void testMethodInvoke() throws Exception {\n+    public void testMethodInvoke() throws Exception {\n@@ -80,2 +80,2 @@\n-    public static void testStaticMethod() throws Throwable {\n-        \/\/ static method in an inline type with no parameter and void return type\n+    public void testStaticMethod() throws Throwable {\n+        \/\/ static method in a primitive class with no parameter and void return type\n@@ -99,1 +99,1 @@\n-    public static void testConstructor() throws Exception {\n+    public void testConstructor() throws Exception {\n@@ -108,1 +108,1 @@\n-    public static void testProxy() throws Exception {\n+    public void testProxy() throws Exception {\n@@ -140,1 +140,1 @@\n-    public static void testDescriptors(Class<?> defc, String name, Class<?>[] params, boolean found) throws Exception {\n+    public void testDescriptors(Class<?> defc, String name, Class<?>[] params, boolean found) throws Exception {\n@@ -169,1 +169,1 @@\n-    public static void methodHandleLookup(String name, MethodType mtype, boolean found) throws Throwable {\n+    public void methodHandleLookup(String name, MethodType mtype, boolean found) throws Throwable {\n","filename":"test\/jdk\/valhalla\/valuetypes\/QTypeDescriptorTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test reflection on inline types\n+ * @summary test reflection on primitive classes\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Array;\n@@ -45,9 +44,2 @@\n-        Point o = Point.makePoint(10, 20);\n-        Reflection test = new Reflection(Point.class, \"Point\", o);\n-        test.newInstance();\n-        test.constructor();\n-        test.accessFieldX(o.x);\n-        test.checkStaticField(\"STATIC_FIELD\", Object.class);\n-        Class<?> declaringClass = Point.class;\n-        test.testSetAccessible(declaringClass.getDeclaredField(\"STATIC_FIELD\"));\n-    }\n+        Object o = Point.class.newInstance();\n+        assertEquals(o.getClass(), Point.class.asPrimaryType());\n@@ -55,37 +47,3 @@\n-    @Test\n-    public static void testLineClass() throws Exception {\n-        Line l = Line.makeLine(10, 20, 30, 40);\n-        Reflection test = new Reflection(Line.class, \"Line\", l);\n-        test.checkInstanceField(\"p1\", Point.class);\n-        test.checkInstanceField(\"p2\", Point.class);\n-        test.checkInstanceMethod(\"p1\", Point.class);\n-        test.checkInstanceMethod(\"p2\", Point.class);\n-    }\n-\n-    @Test\n-    public static void testNonFlattenValue() throws Exception {\n-        NonFlattenValue nfv = NonFlattenValue.make(10, 20);\n-        Reflection test = new Reflection(NonFlattenValue.class, \"NonFlattenValue\", nfv);\n-        test.checkInstanceField(\"nfp\", Point.ref.class);\n-        test.checkInstanceMethod(\"pointValue\", Point.class);\n-        test.checkInstanceMethod(\"point\", Point.ref.class);\n-        test.checkInstanceMethod(\"has\", boolean.class, Point.class, Point.ref.class);\n-    }\n-\n-    \/*\n-     * Tests reflection APIs with the value and reference projection type\n-     *\/\n-    @Test\n-    public static void testMirrors() throws Exception {\n-        assertTrue(Point.class.isPrimitiveClass());\n-        assertTrue(Point.ref.class.isPrimitiveClass());\n-        assertFalse(Point.class.isPrimaryType());\n-        assertTrue(Point.ref.class.isPrimaryType());\n-        assertEquals(Point.class.asValueType(), Point.class);\n-        assertEquals(Point.class.asPrimaryType(), Point.ref.class);\n-\n-        Point o = Point.makePoint(10, 20);\n-        assertTrue(Point.class.isInstance(o));\n-        assertTrue(Point.ref.class.isInstance(o));\n-\n-    }\n+        Constructor<?> ctor = Point.class.getDeclaredConstructor(int.class, int.class);\n+        o = ctor.newInstance(20, 30);\n+        assertEquals(o.getClass(), Point.class.asPrimaryType());\n@@ -93,31 +51,3 @@\n-    @Test\n-    public static void testAssignableFrom() {\n-        \/\/ V <: V? and V <: Object\n-        assertTrue(Point.ref.class.isAssignableFrom(Point.class));\n-        assertTrue(Object.class.isAssignableFrom(Point.class));\n-        assertFalse(Point.class.isAssignableFrom(Point.ref.class));\n-        assertTrue(Object.class.isAssignableFrom(Point.ref.class));\n-\n-        assertEquals(Point.class, Point.class.asSubclass(Point.ref.class));\n-        try {\n-            Class<?> c = Point.ref.class.asSubclass(Point.class);\n-            assertTrue(false);\n-        } catch (ClassCastException e) { }\n-    }\n-\n-    @Test\n-    public static void testClassName() {\n-        assertEquals(Point.class.getName(), \"Point\");\n-        assertEquals(Point.ref.class.getName(), \"Point\");\n-        assertEquals(Line.class.getName(), \"Line\");\n-        assertEquals((new Point[0]).getClass().getName(), \"[QPoint;\");\n-        assertEquals((new Point.ref[0][0]).getClass().getName(), \"[[LPoint;\");\n-    }\n-\n-    private final Class<?> c;\n-    private final Constructor<?> ctor;\n-    private final Object o;\n-    Reflection(Class<?> type, String cn, Object o) throws Exception {\n-        this.c = Class.forName(cn).asValueType();\n-        if (c != type) {\n-            throw new RuntimeException(c + \" is not a primitive value type\");\n+        Field field = Point.class.getField(\"x\");\n+        if (field.getInt(o) != 20) {\n+            fail(\"Unexpected Point.x value: \" +  field.getInt(o));\n@@ -125,51 +55,0 @@\n-\n-        \/\/ V.class, Class.forName, and the type of the object return the primary mirror\n-        assertEquals(type.asPrimaryType(), o.getClass());\n-        assertEquals(type, c.asValueType());\n-        assertEquals(c, c.asValueType());\n-\n-        this.ctor = c.getDeclaredConstructor();\n-        this.o = o;\n-\n-\n-        \/\/ test the primary mirror and secondary mirror\n-        testMirrors(this.c);\n-        \/\/ test array of Q-type and L-type\n-        testArray(c.asValueType());\n-        testArray(c.asPrimaryType());\n-    }\n-\n-    private static void testMirrors(Class<?> c) {\n-        Class<?> valType = c.asValueType();\n-        Class<?> refType = c.asPrimaryType();\n-\n-        assertEquals(refType.getName(), valType.getName());\n-        assertEquals(refType.getTypeName(), c.getTypeName() + \".ref\");\n-        assertEquals(refType.getSimpleName(), c.getSimpleName());\n-\n-        assertEquals(valType.asPrimaryType(), refType);\n-        assertEquals(refType.asValueType(), valType);\n-    }\n-\n-    void testArray(Class<?> elementType) {\n-        Object[] array = (Object[])Array.newInstance(elementType, 1);\n-        Class<?> arrayType = array.getClass();\n-        assertTrue(arrayType.isArray());\n-        Class<?> componentType = arrayType.getComponentType();\n-        assertTrue(componentType.isPrimitiveClass());\n-        assertEquals(componentType, elementType);\n-        \/\/ Array is a reference type\n-        assertEquals(arrayType.asPrimaryType(), arrayType);\n-        if (array[0] == null) {\n-            System.out.println(\"array[0] = null\");\n-        } else {\n-            System.out.println(\"array[0] = \" + array[0]);\n-        }\n-    }\n-\n-    void accessFieldX(int x) throws Exception {\n-        Field field = c.getField(\"x\");\n-        if (field.getInt(o) != x) {\n-            throw new RuntimeException(\"Unexpected Point.x value: \" +  field.getInt(o));\n-        }\n-\n@@ -178,1 +57,1 @@\n-            throw new RuntimeException(\"IllegalAccessException not thrown\");\n+            fail(\"IllegalAccessException not thrown\");\n@@ -180,1 +59,0 @@\n-    }\n@@ -182,4 +60,7 @@\n-    @SuppressWarnings(\"deprecation\")\n-    void newInstance() throws Exception {\n-        Object o = c.newInstance();\n-        assertEquals(o.getClass(), c.asPrimaryType());\n+        \/\/ final static field in a primitive class\n+        Field f = Point.class.getDeclaredField(\"STATIC_FIELD\");\n+        assertTrue(f.getType() == Object.class);\n+        \/\/ accessible but no write access\n+        f.trySetAccessible();\n+        assertTrue(f.isAccessible());\n+        checkToString(f);\n@@ -188,3 +69,6 @@\n-    void constructor() throws Exception {\n-        Object o = ctor.newInstance();\n-        assertEquals(o.getClass(), c.asPrimaryType());\n+    @Test\n+    public static void testLineClass() throws Exception {\n+        checkInstanceField(Line.class, \"p1\", Point.class);\n+        checkInstanceField(Line.class, \"p2\", Point.class);\n+        checkInstanceMethod(Line.class, \"p1\", Point.class);\n+        checkInstanceMethod(Line.class, \"p2\", Point.class);\n@@ -193,3 +77,6 @@\n-    void testSetAccessible(Field f) throws Exception {\n-        f.trySetAccessible();\n-        assertTrue(f.isAccessible());\n+    @Test\n+    public static void testNonFlattenValue() throws Exception {\n+        checkInstanceField(NonFlattenValue.class, \"nfp\", Point.ref.class);\n+        checkInstanceMethod(NonFlattenValue.class, \"pointValue\", Point.class);\n+        checkInstanceMethod(NonFlattenValue.class, \"point\", Point.ref.class);\n+        checkInstanceMethod(NonFlattenValue.class, \"has\", boolean.class, Point.class, Point.ref.class);\n@@ -198,8 +85,0 @@\n-    \/*\n-     * Fields are in the value projection\n-     *\/\n-    void checkInstanceField(String name, Class<?> type) throws Exception {\n-        Field f = c.getDeclaredField(name);\n-        assertTrue(f.getType() == type);\n-        checkToString(f);\n-    }\n@@ -207,5 +86,1 @@\n-    \/*\n-     * Static members are in the reference projection\n-     *\/\n-    void checkStaticField(String name, Class<?> type) throws Exception {\n-        Class<?> declaringClass = c;\n+    static void checkInstanceField(Class<?> declaringClass, String name, Class<?> type) throws Exception {\n@@ -217,5 +92,1 @@\n-    \/*\n-     * Methods are in the reference projection\n-     *\/\n-    void checkInstanceMethod(String name, Class<?> returnType, Class<?>... params) throws Exception {\n-        Class<?> declaringClass = c;\n+    static void checkInstanceMethod(Class<?> declaringClass,String name, Class<?> returnType, Class<?>... params) throws Exception {\n@@ -227,1 +98,1 @@\n-    void checkToString(Field f) {\n+    static void checkToString(Field f) {\n@@ -239,7 +110,0 @@\n-        \/\/ instance fields are in the value projection\n-        \/\/ whereas static fields are in the reference projection\n-        Class<?> declaringClass = c;\n-        \/\/ TODO: static members are in the reference projection\n-        \/\/ if (Modifier.isStatic(mods)) {\n-        \/\/    declaringClass = c.referenceType().get();\n-        \/\/ }\n@@ -247,1 +111,1 @@\n-        sb.append(declaringClass.getName()).append(\".\").append(f.getName());\n+        sb.append(f.getDeclaringClass().getName()).append(\".\").append(f.getName());\n@@ -251,1 +115,1 @@\n-    void checkToString(Method m) {\n+    static void checkToString(Method m) {\n@@ -264,2 +128,1 @@\n-        Class<?> declaringClass = c;\n-        sb.append(declaringClass.getName()).append(\".\").append(m.getName());\n+        sb.append(m.getDeclaringClass().getName()).append(\".\").append(m.getName());\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":36,"deletions":173,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary No Serialization support of inline value classes, without a proxy\n+ * @summary No Serialization support of primitive classes, without a proxy\n@@ -74,1 +74,1 @@\n-    \/\/ inline class that DOES NOT implement Serializable should throw NSE\n+    \/\/ primitive class that DOES NOT implement Serializable should throw NSE\n@@ -126,1 +126,1 @@\n-    \/\/ inline class that DOES implement Serializable should throw NSE\n+    \/\/ primitive class that DOES implement Serializable should throw NSE\n@@ -178,1 +178,1 @@\n-    \/\/ inline classes that DO implement Serializable, but have a serial proxy\n+    \/\/ primitive classes that DO implement Serializable, but have a serial proxy\n@@ -237,2 +237,2 @@\n-    @DataProvider(name = \"inlineClasses\")\n-    public Object[][] inlineClasses() {\n+    @DataProvider(name = \"classes\")\n+    public Object[][] classes() {\n@@ -247,2 +247,2 @@\n-    \/\/ inline class read directly from a byte stream\n-    @Test(dataProvider = \"inlineClasses\")\n+    \/\/ primitive class read directly from a byte stream\n+    @Test(dataProvider = \"classes\")\n","filename":"test\/jdk\/valhalla\/valuetypes\/Serialization.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm StaticInitFactoryTest\n+ * @run main\/othervm StaticFactoryMethodHandleTest\n@@ -40,1 +40,1 @@\n-public class StaticInitFactoryTest {\n+public class StaticFactoryMethodHandleTest {\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryMethodHandleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/valhalla\/valuetypes\/StaticInitFactoryTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Test reflection of constructors for primitive classes\n+ * @run testng\/othervm StaticFactoryTest\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class StaticFactoryTest {\n+    \/\/ Target test class\n+    static primitive class SimplePrimitive {\n+        public final int x;\n+\n+        SimplePrimitive() {\n+            x = -1;\n+        }\n+\n+        public SimplePrimitive(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static final Class<?> PRIMITIVE_TYPE = SimplePrimitive.class;\n+\n+    @Test\n+    public static void testPrimitiveClassConstructor() throws Exception {\n+        String cn = PRIMITIVE_TYPE.getName();\n+        Class<?> c = Class.forName(cn).asValueType();\n+\n+        assertTrue(c.isPrimitiveClass());\n+        assertTrue(c == PRIMITIVE_TYPE);\n+    }\n+\n+    @Test\n+    public static void constructor() throws Exception {\n+        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+        Object o = ctor.newInstance();\n+        assertTrue(o.getClass() == PRIMITIVE_TYPE.asPrimaryType());\n+    }\n+\n+    \/\/ Check that the class has the expected Constructors\n+    @Test\n+    public static void constructors() throws Exception {\n+        Set<String> expectedSig = Set.of(\"public StaticFactoryTest$SimplePrimitive(int)\",\n+                                         \"StaticFactoryTest$SimplePrimitive()\");\n+        Constructor<? extends Object>[] cons = PRIMITIVE_TYPE.getDeclaredConstructors();\n+        Set<String> actualSig = Arrays.stream(cons).map(Constructor::toString)\n+                                      .collect(Collectors.toSet());\n+        boolean ok = expectedSig.equals(actualSig);\n+        if (!ok) {\n+            System.out.printf(\"expected: %s%n\", expectedSig);\n+            System.out.printf(\"declared: %s%n\", actualSig);\n+            assertTrue(ok);\n+        }\n+    }\n+\n+    \/\/ Check that the constructor and field can be set accessible\n+    @Test\n+    public static void setAccessible() throws Exception {\n+        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+        ctor.setAccessible(true);\n+\n+        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+        field.setAccessible(true);\n+    }\n+\n+    \/\/ Check that the constructor and field can be set accessible\n+    @Test\n+    public static void trySetAccessible() throws Exception {\n+        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+        assertTrue(ctor.trySetAccessible());\n+\n+        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+        assertTrue(field.trySetAccessible());\n+    }\n+\n+    \/\/ Check that the final field cannot be modified\n+    @Test(expectedExceptions = IllegalAccessException.class)\n+    public static void setFinalField() throws Exception {\n+        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+        field.setAccessible(true);\n+        field.setInt(new SimplePrimitive(100), 200);\n+    }\n+\n+\n+    \/\/ Check that the class does not have a static method with the name <init>\n+    @Test\n+    public static void initFactoryNotMethods() {\n+        Method[] methods = PRIMITIVE_TYPE.getDeclaredMethods();\n+        for (Method m : methods) {\n+            if (Modifier.isStatic(m.getModifiers())) {\n+                assertFalse(m.getName().equals(\"<init>\"));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Basic test for Array::get, Array::set, Arrays::setAll on inline class array\n+ * @summary Basic test for Array::get, Array::set, Arrays::setAll on primitive class array\n@@ -56,1 +56,1 @@\n-    public void testInlineType() {\n+    public void testValueType() {\n","filename":"test\/jdk\/valhalla\/valuetypes\/StreamTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary test MethodHandle\/VarHandle on inline types\n+ * @summary test MethodHandle\/VarHandle on primitive classes\n@@ -182,1 +182,1 @@\n-     * non-null and of the same inline class.\n+     * non-null and of the same primitive class.\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @compile --enable-preview --source ${jdk.version} UninitializedInlineValueTest.java\n- * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=128 UninitializedInlineValueTest\n- * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=0 UninitializedInlineValueTest\n- * @summary Test reflection and method handle on accessing a field of inline type\n- *          that may be flattened or non-flattened\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class UninitializedInlineValueTest {\n-    static primitive class EmptyInline {\n-        public boolean isEmpty() {\n-            return true;\n-        }\n-    }\n-\n-    static primitive class InlineValue {\n-        Object o;\n-        EmptyInline empty;\n-        InlineValue() {\n-            this.o = null;\n-            this.empty = new EmptyInline();\n-        }\n-    }\n-\n-    static class MutableValue {\n-        Object o;\n-        EmptyInline empty;\n-        volatile EmptyInline vempty;\n-    }\n-\n-    @Test\n-    public void emptyInlineClass() throws ReflectiveOperationException {\n-        EmptyInline e = new EmptyInline();\n-        Field[] fields = e.getClass().getDeclaredFields();\n-        assertTrue(fields.length == 0);\n-    }\n-\n-    @Test\n-    public void testInlineValue() throws ReflectiveOperationException {\n-        InlineValue v = new InlineValue();\n-        Field f0 = v.getClass().getDeclaredField(\"o\");\n-        Object o = f0.get(v);\n-        assertTrue(o == null);\n-\n-        \/\/ field of inline type must be non-null\n-        Field f1 = v.getClass().getDeclaredField(\"empty\");\n-        assertTrue(f1.getType() == EmptyInline.class);\n-        EmptyInline empty = (EmptyInline)f1.get(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-    }\n-\n-    @Test\n-    public void testMutableValue() throws ReflectiveOperationException {\n-        MutableValue v = new MutableValue();\n-        Field f0 = v.getClass().getDeclaredField(\"o\");\n-        f0.set(v, null);\n-        assertTrue( f0.get(v) == null);\n-\n-        \/\/ field of inline type must be non-null\n-        Field f1 = v.getClass().getDeclaredField(\"empty\");\n-        assertTrue(f1.getType() == EmptyInline.class);\n-        EmptyInline empty = (EmptyInline)f1.get(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-\n-        Field f2 = v.getClass().getDeclaredField(\"vempty\");\n-        assertTrue(f2.getType() == EmptyInline.class);\n-        EmptyInline vempty = (EmptyInline)f2.get(v);\n-        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n-\n-        f1.set(v, new EmptyInline());\n-        assertTrue((EmptyInline)f1.get(v) == new EmptyInline());\n-        f2.set(v, new EmptyInline());\n-        assertTrue((EmptyInline)f2.get(v) == new EmptyInline());\n-    }\n-\n-    @Test\n-    public void testMethodHandleInlineValue() throws Throwable {\n-        InlineValue v = new InlineValue();\n-        MethodHandle mh = MethodHandles.lookup().findGetter(InlineValue.class, \"empty\", EmptyInline.class);\n-        EmptyInline empty = (EmptyInline) mh.invokeExact(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-    }\n-\n-    @Test\n-    public void testMethodHandleMutableValue() throws Throwable {\n-        MutableValue v = new MutableValue();\n-        MethodHandle getter = MethodHandles.lookup().findGetter(MutableValue.class, \"empty\", EmptyInline.class);\n-        EmptyInline empty = (EmptyInline) getter.invokeExact(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-\n-        MethodHandle getter1 = MethodHandles.lookup().findGetter(MutableValue.class, \"vempty\", EmptyInline.class);\n-        EmptyInline vempty = (EmptyInline) getter1.invokeExact(v);\n-        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n-\n-        MethodHandle setter = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyInline.class);\n-        setter.invokeExact(v, new EmptyInline());\n-        empty = (EmptyInline) getter.invokeExact(v);\n-        assertTrue(empty == new EmptyInline());\n-\n-        MethodHandle setter1 = MethodHandles.lookup().findSetter(MutableValue.class, \"vempty\", EmptyInline.class);\n-        setter1.invokeExact(v, new EmptyInline());\n-        vempty = (EmptyInline) getter1.invokeExact(v);\n-        assertTrue(vempty == new EmptyInline());\n-    }\n-\n-    @Test(expectedExceptions = { IllegalAccessException.class})\n-    public void noWriteAccess() throws ReflectiveOperationException {\n-        InlineValue v = new InlineValue();\n-        Field f = v.getClass().getDeclaredField(\"empty\");\n-        f.set(v, null);\n-    }\n-\n-    @Test(expectedExceptions = { NullPointerException.class})\n-    public void nonNullableField_reflection() throws ReflectiveOperationException {\n-        MutableValue v = new MutableValue();\n-        Field f = v.getClass().getDeclaredField(\"empty\");\n-        f.set(v, null);\n-    }\n-\n-    @Test(expectedExceptions = { NullPointerException.class})\n-    public void nonNullableField_MethodHandle() throws Throwable {\n-        MutableValue v = new MutableValue();\n-        MethodHandle mh = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyInline.class);\n-        EmptyInline.ref e = null;\n-        EmptyInline empty = (EmptyInline) mh.invokeExact(v, (EmptyInline)e);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UninitializedInlineValueTest.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @compile --enable-preview --source ${jdk.version} UninitializedValueTest.java\n+ * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=128 UninitializedValueTest\n+ * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=0 UninitializedValueTest\n+ * @summary Test reflection and method handle on accessing a field of a primitive class\n+ *          that may be flattened or non-flattened\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class UninitializedValueTest {\n+    static primitive class EmptyValue {\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+    }\n+\n+    static primitive class Value {\n+        Object o;\n+        EmptyValue empty;\n+        Value() {\n+            this.o = null;\n+            this.empty = new EmptyValue();\n+        }\n+    }\n+\n+    static class MutableValue {\n+        Object o;\n+        EmptyValue empty;\n+        volatile EmptyValue vempty;\n+    }\n+\n+    @Test\n+    public void emptyValueClass() throws ReflectiveOperationException {\n+        EmptyValue e = new EmptyValue();\n+        Field[] fields = e.getClass().getDeclaredFields();\n+        assertTrue(fields.length == 0);\n+    }\n+\n+    @Test\n+    public void testValue() throws ReflectiveOperationException {\n+        Value v = new Value();\n+        Field f0 = v.getClass().getDeclaredField(\"o\");\n+        Object o = f0.get(v);\n+        assertTrue(o == null);\n+\n+        \/\/ field of primitive value type must be non-null\n+        Field f1 = v.getClass().getDeclaredField(\"empty\");\n+        assertTrue(f1.getType() == EmptyValue.class);\n+        EmptyValue empty = (EmptyValue)f1.get(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+    }\n+\n+    @Test\n+    public void testMutableValue() throws ReflectiveOperationException {\n+        MutableValue v = new MutableValue();\n+        Field f0 = v.getClass().getDeclaredField(\"o\");\n+        f0.set(v, null);\n+        assertTrue( f0.get(v) == null);\n+\n+        \/\/ field of primitive value type type must be non-null\n+        Field f1 = v.getClass().getDeclaredField(\"empty\");\n+        assertTrue(f1.getType() == EmptyValue.class);\n+        EmptyValue empty = (EmptyValue)f1.get(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+\n+        Field f2 = v.getClass().getDeclaredField(\"vempty\");\n+        assertTrue(f2.getType() == EmptyValue.class);\n+        EmptyValue vempty = (EmptyValue)f2.get(v);\n+        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n+\n+        f1.set(v, new EmptyValue());\n+        assertTrue((EmptyValue)f1.get(v) == new EmptyValue());\n+        f2.set(v, new EmptyValue());\n+        assertTrue((EmptyValue)f2.get(v) == new EmptyValue());\n+    }\n+\n+    @Test\n+    public void testMethodHandleValue() throws Throwable {\n+        Value v = new Value();\n+        MethodHandle mh = MethodHandles.lookup().findGetter(Value.class, \"empty\", EmptyValue.class);\n+        EmptyValue empty = (EmptyValue) mh.invokeExact(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+    }\n+\n+    @Test\n+    public void testMethodHandleMutableValue() throws Throwable {\n+        MutableValue v = new MutableValue();\n+        MethodHandle getter = MethodHandles.lookup().findGetter(MutableValue.class, \"empty\", EmptyValue.class);\n+        EmptyValue empty = (EmptyValue) getter.invokeExact(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+\n+        MethodHandle getter1 = MethodHandles.lookup().findGetter(MutableValue.class, \"vempty\", EmptyValue.class);\n+        EmptyValue vempty = (EmptyValue) getter1.invokeExact(v);\n+        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n+\n+        MethodHandle setter = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyValue.class);\n+        setter.invokeExact(v, new EmptyValue());\n+        empty = (EmptyValue) getter.invokeExact(v);\n+        assertTrue(empty == new EmptyValue());\n+\n+        MethodHandle setter1 = MethodHandles.lookup().findSetter(MutableValue.class, \"vempty\", EmptyValue.class);\n+        setter1.invokeExact(v, new EmptyValue());\n+        vempty = (EmptyValue) getter1.invokeExact(v);\n+        assertTrue(vempty == new EmptyValue());\n+    }\n+\n+    @Test(expectedExceptions = { IllegalAccessException.class})\n+    public void noWriteAccess() throws ReflectiveOperationException {\n+        Value v = new Value();\n+        Field f = v.getClass().getDeclaredField(\"empty\");\n+        f.set(v, null);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class})\n+    public void nonNullableField_reflection() throws ReflectiveOperationException {\n+        MutableValue v = new MutableValue();\n+        Field f = v.getClass().getDeclaredField(\"empty\");\n+        f.set(v, null);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class})\n+    public void nonNullableField_MethodHandle() throws Throwable {\n+        MutableValue v = new MutableValue();\n+        MethodHandle mh = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyValue.class);\n+        EmptyValue.ref e = null;\n+        EmptyValue empty = (EmptyValue) mh.invokeExact(v, (EmptyValue)e);\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UninitializedValueTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Basic test for Array::get, Array::set, Arrays::setAll on inline class array\n+ * @summary Basic test for Array::get, Array::set, Arrays::setAll on primitive class array\n@@ -39,9 +39,6 @@\n-    private final Class<?> arrayClass;\n-    private final Class<?> componentType;\n-    private final Object[] array;\n-    ValueArray(Class<?> arrayClass, Object[] array) {\n-        this.arrayClass = arrayClass;\n-        this.array = array;\n-        this.componentType = arrayClass.getComponentType();\n-        assertTrue(arrayClass.isArray());\n-        assertTrue(array.getClass() == arrayClass);\n+    @DataProvider(name=\"elementTypes\")\n+    static Object[][] elementTypes() {\n+        return new Object[][]{\n+            new Object[] { Point.class, new Point(0,0) },\n+            new Object[] { Point.ref.class, null },\n+        };\n@@ -49,4 +46,21 @@\n-\n-    private static Class<?> nullablePointArrayClass() {\n-        Object a = new Point.ref[0];\n-        return a.getClass();\n+    @Test(dataProvider=\"elementTypes\")\n+    public void testPrimitiveElementType(Class<?> elementType, Object defaultValue) {\n+        assertTrue(elementType.isPrimitiveClass());\n+        assertTrue(elementType.isPrimaryType() || defaultValue != null);\n+\n+        Object[] array = (Object[])Array.newInstance(elementType, 1);\n+        Class<?> arrayType = array.getClass();\n+        assertTrue(arrayType.componentType() == elementType);\n+        \/\/ Array is a reference type\n+        assertTrue(arrayType.isArray());\n+        assertTrue(arrayType.isPrimaryType());\n+        assertEquals(arrayType.asPrimaryType(), arrayType);\n+        assertTrue(array[0] == defaultValue);\n+\n+        \/\/ check the element type of multi-dimensional array\n+        Object[][] multiArray = (Object[][])Array.newInstance(elementType, 1, 2, 3);\n+        Class<?> c = multiArray.getClass();\n+        while (c.getComponentType() != null) {\n+            c = c.getComponentType();\n+        }\n+        assertTrue(c == elementType);\n@@ -55,3 +69,24 @@\n-    void run() {\n-        testClassName();\n-        testArrayElements();\n+    @DataProvider(name=\"arrayTypes\")\n+    static Object[][] arrayTypes() {\n+        return new Object[][] {\n+            new Object[] { Object[].class,\n+                           new Object[] { new Object(), new Object()}},\n+            new Object[] { Point[].class,\n+                           new Point[] { Point.makePoint(1, 2),\n+                                         Point.makePoint(10, 20),\n+                                         Point.makePoint(100, 200)}},\n+            new Object[] { Point[][].class,\n+                           new Point[][] { new Point[] { Point.makePoint(1, 2),\n+                                                         Point.makePoint(10, 20)}}},\n+            new Object[] { Point.ref[].class,\n+                           new Point.ref[] { Point.makePoint(11, 22),\n+                                             Point.makePoint(110, 220),\n+                                             null }},\n+            new Object[] { NonFlattenValue[].class,\n+                           new NonFlattenValue[] { NonFlattenValue.make(1, 2),\n+                                                   NonFlattenValue.make(10, 20),\n+                                                   NonFlattenValue.make(100, 200)}},\n+            new Object[] { Point[].class,  new Point[0] },\n+            new Object[] { Point.ref[].class,  new Point.ref[0] },\n+        };\n+    }\n@@ -59,2 +94,7 @@\n-        if (componentType.isValueType()) {\n-            Object[] qArray = (Object[]) Array.newInstance(componentType, 0);\n+    @Test(dataProvider=\"arrayTypes\")\n+    public void testArrays(Class<?> arrayClass, Object[] array) {\n+        testClassName(arrayClass);\n+        testArrayElements(arrayClass, array);\n+        Class<?> componentType = arrayClass.componentType();\n+        if (componentType.isPrimitiveClass()) {\n+            Object[] qArray = (Object[]) Array.newInstance(componentType.asValueType(), 0);\n@@ -62,1 +102,1 @@\n-            testInlineArrayCovariance(componentType, qArray, lArray);\n+            testArrayCovariance(componentType, qArray, lArray);\n@@ -66,1 +106,4 @@\n-    void testClassName() {\n+    \/**\n+     * Verify the array class's name of the form \"[QPoint;\" or \"[LPoint;\"\n+     *\/\n+    static void testClassName(Class<?> arrayClass) {\n@@ -79,2 +122,7 @@\n-    void testArrayElements() {\n-        Object[] array = (Object[]) Array.newInstance(componentType, this.array.length);\n+    \/**\n+     * Setting the elements of an array.\n+     * NPE will be thrown if null is set on an element in an array of value type\n+     *\/\n+    static void testArrayElements(Class<?> arrayClass, Object[] array) {\n+        Class<?> componentType = arrayClass.getComponentType();\n+        assertTrue(arrayClass.isArray());\n@@ -82,1 +130,3 @@\n-        assertTrue(array.getClass().getComponentType() == componentType);\n+        Object[] newArray = (Object[]) Array.newInstance(componentType, array.length);\n+        assertTrue(newArray.getClass() == arrayClass);\n+        assertTrue(newArray.getClass().getComponentType() == componentType);\n@@ -85,2 +135,2 @@\n-        for (int i=0; i < this.array.length; i++) {\n-            Array.set(array, i, this.array[i]);\n+        for (int i = 0; i < array.length; i++) {\n+            Array.set(newArray, i, array[i]);\n@@ -88,3 +138,3 @@\n-        for (int i=0; i < this.array.length; i++) {\n-            Object o = Array.get(array, i);\n-            assertEquals(o, this.array[i]);\n+        for (int i = 0; i < array.length; i++) {\n+            Object o = Array.get(newArray, i);\n+            assertEquals(o, array[i]);\n@@ -92,1 +142,1 @@\n-        Arrays.setAll(array, i -> this.array[i]);\n+        Arrays.setAll(newArray, i -> array[i]);\n@@ -96,2 +146,2 @@\n-            for (int i=0; i < array.length; i++) {\n-                Array.set(array, i, null);\n+            for (int i = 0; i < newArray.length; i++) {\n+                Array.set(newArray, i, null);\n@@ -100,1 +150,1 @@\n-            for (int i=0; i < array.length; i++) {\n+            for (int i = 0; i < newArray.length; i++) {\n@@ -102,3 +152,4 @@\n-                    Array.set(array, i, null);\n-                    assertFalse(true, \"expect NPE but not thrown\");\n-                } catch (NullPointerException e) { }\n+                    Array.set(newArray, i, null);\n+                    fail(\"expect NPE but not thrown\");\n+                } catch (NullPointerException e) {\n+                }\n@@ -109,2 +160,5 @@\n-    void testInlineArrayCovariance(Class<?> componentType, Object[] qArray, Object[] lArray) {\n-        assertTrue(componentType.isValueType());\n+    \/**\n+     * Point[] is a subtype of Point.ref[], which is a subtype of Object[].\n+     *\/\n+    static void testArrayCovariance(Class<?> componentType, Object[] qArray, Object[] lArray) {\n+        assertTrue(componentType.isPrimitiveClass());\n@@ -116,4 +170,0 @@\n-        \/\/ Class.instanceof inline vs indirect\n-        assertFalse(qArray.getClass().isInstance(lArray));\n-        assertTrue(lArray.getClass().isInstance(qArray));\n-\n@@ -124,1 +174,5 @@\n-        \/\/ Class.isAssignableFrom inline vs indirect\n+        \/\/ V.val[] is a subtype of V.ref[]\n+        assertFalse(qArray.getClass().isInstance(lArray));\n+        assertTrue(lArray.getClass().isInstance(qArray));\n+\n+        \/\/ V.val[] is a subtype of V.ref[]\n@@ -132,1 +186,1 @@\n-        \/\/ Class.cast inline vs indirect\n+        \/\/ Class.cast\n@@ -136,32 +190,3 @@\n-            assertFalse(true, \"cast of Point? to Point should not succeed\");\n-        } catch (ClassCastException cce) { }\n-    }\n-\n-\n-    @DataProvider(name=\"arrayTypes\")\n-    static Object[][] arrayTypes() {\n-        return new Object[][] {\n-            new Object[] { Object[].class,\n-                           new Object[] { new Object(), new Object()}},\n-            new Object[] { Point[].class,\n-                           new Point[] { Point.makePoint(1, 2),\n-                                         Point.makePoint(10, 20),\n-                                         Point.makePoint(100, 200)}},\n-            new Object[] { Point[][].class,\n-                           new Point[][] { new Point[] { Point.makePoint(1, 2),\n-                                                         Point.makePoint(10, 20)}}},\n-            new Object[] { nullablePointArrayClass(),\n-                           new Point.ref[] { Point.makePoint(11, 22),\n-                                          Point.makePoint(110, 220),\n-                                          null }},\n-            new Object[] { NonFlattenValue[].class,\n-                           new NonFlattenValue[] { NonFlattenValue.make(1, 2),\n-                                                   NonFlattenValue.make(10, 20),\n-                                                   NonFlattenValue.make(100, 200)}},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"arrayTypes\")\n-    public static void test(Class<?> arrayClass, Object[] array) {\n-        ValueArray test = new ValueArray(arrayClass, array);\n-        test.run();\n+            fail(\"cast of Point.ref[] to Point[] should not succeed\");\n+        } catch (ClassCastException cce) {\n+        }\n@@ -189,1 +214,1 @@\n-            throw new AssertionError(\"IAE not thrown\");\n+            fail(\"IAE not thrown\");\n@@ -194,1 +219,1 @@\n-            throw new AssertionError(\"IAE not thrown\");\n+            fail(\"IAE not thrown\");\n@@ -204,6 +229,0 @@\n-        ValueArray test = new ValueArray(Point[].class, qArray);\n-        test.run();\n-\n-        ValueArray test1 = new ValueArray(Point.ref[].class, lArray);\n-        test.run();\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueArray.java","additions":104,"deletions":85,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueBootstrapMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n- * @summary Test inline classes with Reference types\n- * @run testng\/othervm InlineReferenceTest\n+ * @summary Test primitive classes with Reference types\n+ * @run testng\/othervm WeakReferenceTest\n@@ -38,1 +38,1 @@\n-public class InlineReferenceTest {\n+public class WeakReferenceTest {\n","filename":"test\/jdk\/valhalla\/valuetypes\/WeakReferenceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/valhalla\/valuetypes\/InlineReferenceTest.java","status":"renamed"}]}