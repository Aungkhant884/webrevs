{"files":[{"patch":"@@ -753,6 +753,0 @@\n-    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType() && !gvn().type(peek())->maybe_null()) {\n-      Node* retnode = pop();\n-      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n-      push_node(T_INLINE_TYPE, retnode);\n-    }\n-\n@@ -779,0 +773,5 @@\n+    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineTypeBase()) {\n+      Node* retnode = pop();\n+      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass(), !gvn().type(retnode)->maybe_null());\n+      push_node(T_INLINE_TYPE, retnode);\n+    }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1262,0 +1262,5 @@\n+    if (assert_null) {\n+      vtptr = InlineTypePtrNode::make_null(_gvn, vtptr->type()->inline_klass());\n+      replace_in_map(value, vtptr);\n+      return vtptr;\n+    }\n@@ -1923,12 +1928,6 @@\n-  } else if (call->method()->return_type()->is_inlinetype()) {\n-    const Type* ret_type = call->tf()->range_sig()->field_at(TypeFunc::Parms);\n-    if (call->tf()->returns_inline_type_as_fields()) {\n-      \/\/ Return of multiple values (inline type fields): we create a\n-      \/\/ InlineType node, each field is a projection from the call.\n-      ciInlineKlass* vk = call->method()->return_type()->as_inline_klass();\n-      uint base_input = TypeFunc::Parms;\n-      ret = InlineTypeNode::make_from_multi(this, call, ret_type->inline_klass(), base_input, false);\n-    } else {\n-      ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-      ret = _gvn.transform(InlineTypeNode::make_from_oop(this, ret, ret_type->inline_klass(), !ret_type->maybe_null()));\n-    }\n+  } else if (call->tf()->returns_inline_type_as_fields()) {\n+    \/\/ Return of multiple values (inline type fields): we create a\n+    \/\/ InlineType node, each field is a projection from the call.\n+    ciInlineKlass* vk = call->method()->return_type()->as_inline_klass();\n+    uint base_input = TypeFunc::Parms;\n+    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -741,0 +741,3 @@\n+      if (!null_free) {\n+        vt->set_oop(oop);\n+      }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -605,3 +605,3 @@\n-  int arg_size_sig = tf()->domain_sig()->cnt();\n-  for (uint i = 0; i < (uint)arg_size_sig; i++) {\n-    Node* parm = map()->in(i);\n+  int arg_size = method()->arg_size();\n+  for (int i = 0; i < arg_size; i++) {\n+    Node* parm = local(i);\n@@ -612,2 +612,2 @@\n-      map()->replace_edge(parm, vt);\n-    } else if (UseTypeSpeculation && (i == (uint)(arg_size_sig - 1)) && !is_osr_parse() &&\n+      set_local(i, vt);\n+    } else if (UseTypeSpeculation && (i == (arg_size - 1)) && !is_osr_parse() &&\n@@ -621,1 +621,1 @@\n-      replace_in_map(parm, cast);\n+      set_local(i, cast);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+        protected static final String CMPP = START + \"(CmpP|CmpN)\" + MID + \"\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+\n+            mt = MethodType.methodType(MyValue2.class);\n+            test54_mh = lookup.findVirtual(clazz, \"test54_callee\", mt);\n@@ -1194,0 +1197,33 @@\n+\n+    static MethodHandle test54_mh;\n+\n+    @DontInline\n+    public MyValue2.ref test54_callee() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that method handle invocation does not block scalarization of return value\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test54(Method m, boolean b1, boolean b2) throws Throwable {\n+        MyInterface obj = MyValue2.createWithFieldsInline(rI, rD);\n+        if (b1) {\n+            obj = (MyValue2.ref)test54_mh.invokeExact(this);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.hash();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier(RunInfo info) throws Throwable {\n+        Asserts.assertEQ(test54(info.getTest(), true, false), -1L);\n+        Asserts.assertEQ(test54(info.getTest(), false, false), -1L);\n+        if (!info.isWarmUp()) {\n+            MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+            Asserts.assertEQ(test54(info.getTest(), true, true), v.hash());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-        Asserts.assertEquals((Object)vt, null);\n+        Asserts.assertEquals(vt, null);\n@@ -480,1 +480,1 @@\n-        return (Object)vt == null;\n+        return vt == null;\n@@ -2472,0 +2472,46 @@\n+\n+    @ForceInline\n+    public boolean test90_inline(MyValue1.ref vt) {\n+        return vt == null;\n+    }\n+\n+    \/\/ Test scalarization with speculative NULL type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test90(Method m) throws Exception {\n+        Object arg = null;\n+        return (boolean)m.invoke(this, arg);\n+    }\n+\n+    @Run(test = \"test90\")\n+    @Warmup(10000)\n+    public void test90_verifier() throws Exception {\n+        Method m = getClass().getMethod(\"test90_inline\", MyValue1.ref.class);\n+        Asserts.assertTrue(test90(m));\n+    }\n+\n+    \/\/ Test that scalarization does not introduce redundant\/unused checks\n+    @Test\n+    @IR(failOn = {ALLOC, CMPP})\n+    public Object test91(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        Asserts.assertEQ(test91(testValue1), testValue1);\n+    }\n+\n+    MyValue1.ref test92Field = testValue1;\n+\n+    \/\/ Same as test91 but with field access\n+    @Test\n+    @IR(failOn = {ALLOC, CMPP})\n+    public Object test92() {\n+        return test92Field;\n+    }\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier() {\n+        Asserts.assertEQ(test92(), testValue1);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8280440\n+ * @summary Test that speculative types are properly handled by scalarization.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestWithSpeculativeTypes::*\n+ *                   -XX:TypeProfileLevel=222 -XX:-TieredCompilation -Xbatch\n+ *                   TestWithSpeculativeTypes\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestWithSpeculativeTypes {\n+\n+    static primitive class MyValue {\n+        int x = 0;\n+    }\n+\n+    static MyValue.ref getNull() {\n+        return null;\n+    }\n+\n+    \/\/ Return value has speculative type NULL\n+    static boolean test1() {\n+        return getNull() == null;\n+    }\n+\n+    \/\/ Argument has speculative type NULL\n+    static boolean test2(MyValue.ref vt) {\n+        return vt == null;\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Make sure class is loaded\n+        MyValue val = new MyValue();\n+        for (int i = 0; i < 100_000; ++i) {\n+            Asserts.assertTrue(test1());\n+            Asserts.assertTrue(test2(null));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithSpeculativeTypes.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}