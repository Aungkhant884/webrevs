{"files":[{"patch":"@@ -1712,1 +1712,1 @@\n-  if ((method()->is_object_constructor() || method()->is_static_init_factory()) &&\n+  if ((method()->is_object_constructor() || method()->is_static_vnew_factory()) &&\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -999,1 +999,1 @@\n-\/\/ ciMethod::is_static_init_factory\n+\/\/ ciMethod::is_static_vnew_factory\n@@ -1001,2 +1001,2 @@\n-bool ciMethod::is_static_init_factory() const {\n-   return (name() == ciSymbols::object_initializer_name()\n+bool ciMethod::is_static_vnew_factory() const {\n+   return (name() == ciSymbols::inline_factory_name()\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-  bool is_static_init_factory() const;\n+  bool is_static_vnew_factory() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -718,2 +718,2 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature\n-          \/\/ unless it's an inline type.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature,\n+          \/\/ or if it is an inline type, <vnew> with return.\n@@ -723,1 +723,2 @@\n-            if (name != vmSymbols::object_initializer_name()) {\n+            if (name != vmSymbols::object_initializer_name() &&\n+                name != vmSymbols::inline_factory_name()) {\n@@ -729,3 +730,4 @@\n-              \/\/ if return type is non-void then it cannot be a basic primitive\n-              \/\/ and primitve types must be supported.\n-              if (!signature->ends_with(JVM_SIGNATURE_ENDCLASS) || !EnableValhalla) {\n+              \/\/ if return type is non-void then it must be an inline type\n+              if (name == vmSymbols::object_initializer_name() ||\n+                  !EnableValhalla || !supports_inline_types() ||\n+                  !signature->ends_with(JVM_SIGNATURE_ENDCLASS)) {\n@@ -752,1 +754,12 @@\n-            if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) { \/\/ <vnew>\n+              \/\/ <vnew> factory methods must be non-void return and invokeStatic.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature() || ref_kind != JVM_REF_invokeStatic) {\n+                classfile_parse_error(\n+                  \"Bad factory method name at constant pool index %u in class file %s\",\n+                  name_ref_index, CHECK);\n+              }\n+            } else if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n@@ -759,1 +772,1 @@\n-            } else {\n+            } else { \/\/ <init>\n@@ -768,3 +781,0 @@\n-              } else if (!signature->is_void_method_signature()\n-                         && ref_kind == JVM_REF_invokeStatic) {\n-                \/\/ also OK, could be a static factory call\n@@ -2392,1 +2402,1 @@\n-  if (name == vmSymbols::object_initializer_name()) {\n+  if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) {\n@@ -2394,6 +2404,6 @@\n-      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n-      return NULL;\n-    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n-      \/\/ OK, a constructor\n-    } else if (is_value_class && !signature->is_void_method_signature()) {\n-      \/\/ also OK, a static factory, as long as the return value is good\n+      classfile_parse_error(\"Interface cannot have a method named <vnew>, class file %s\", CHECK_NULL);\n+    } else if (!is_value_class) {\n+       classfile_parse_error(\"Identity class cannot have a method <vnew>, class file %s\", CHECK_NULL);\n+    } else if (signature->is_void_method_signature()) {\n+       classfile_parse_error(\"Factory method <vnew> must have a non-void return type, class file %s\", CHECK_NULL);\n+    } else { \/\/ also OK, a static factory, as long as the return value is good\n@@ -2407,5 +2417,2 @@\n-          \/\/ The original class name in hidden classes gets changed.  So using\n-          \/\/ the original name in the return type is no longer valid.\n-          \/\/ Note that expecting the return type for inline hidden class factory\n-          \/\/ methods to be java.lang.Object works around a JVM Spec issue for\n-          \/\/ hidden classes.\n+          \/\/ The original class name for hidden classes changed.\n+          \/\/\/ So using the original name in the return type is no longer valid.\n@@ -2419,0 +2426,14 @@\n+      \/\/ factory method, with a non-void return.  No other\n+      \/\/ definition of <vnew> is possible.\n+      \/\/\n+      \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+      \/\/ signature of any attempt to invoke <vnew>, and ensure that it\n+      \/\/ returns non-void.\n+    }\n+  }\n+\n+  if (name == vmSymbols::object_initializer_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n+    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n+      \/\/ OK, a constructor\n@@ -2423,4 +2444,2 @@\n-    \/\/ A declared <init> method must always be either a non-static\n-    \/\/ object constructor, with a void return, or else it must be a\n-    \/\/ static factory method, with a non-void return.  No other\n-    \/\/ definition of <init> is possible.\n+    \/\/ A declared <init> method must always be a non-static\n+    \/\/ object constructor, with a void return.\n@@ -2429,11 +2448,2 @@\n-    \/\/ signature of any attempt to invoke <init>, and ensures that it\n-    \/\/ returns non-void if and only if it is being invoked by\n-    \/\/ invokestatic, and void if and only if it is being invoked by\n-    \/\/ invokespecial.\n-    \/\/\n-    \/\/ When a symbolic reference to <init> is resolved for a\n-    \/\/ particular invocation mode (special or static), the mode is\n-    \/\/ matched to the JVM_ACC_STATIC modifier of the <init> method.\n-    \/\/ Thus, it is impossible to statically invoke a constructor, and\n-    \/\/ impossible to \"new + invokespecial\" a static factory, either\n-    \/\/ through bytecode or through reflection.\n+    \/\/ signature of any attempt to invoke <init>, and ensure that it\n+    \/\/ returns void.\n@@ -4996,0 +5006,1 @@\n+  const bool is_factory      = (name == vmSymbols::inline_factory_name() && supports_inline_types());\n@@ -5037,3 +5048,3 @@\n-      if (is_initializer) {\n-        if (is_final || is_synchronized || is_native ||\n-            is_abstract || (major_gte_1_5 && is_bridge)) {\n+      if (is_factory) { \/\/ <vnew> factory method\n+        if (is_final || is_synchronized || is_native || !is_static ||\n+            is_abstract || is_bridge) {\n@@ -5041,0 +5052,1 @@\n+          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n@@ -5042,6 +5054,3 @@\n-        if (!is_static && (!is_value_class || is_abstract_class)) {\n-          \/\/ OK, an object constructor in a regular class or an abstract value class\n-        } else if (is_static && is_value_class) {\n-          \/\/ OK, a static init factory in an inline class\n-        } else {\n-          \/\/ but no other combinations are allowed\n+      } else if (is_initializer) {\n+        if (is_static || is_final || is_synchronized || is_native ||\n+            is_abstract || (major_gte_1_5 && is_bridge)) {\n@@ -5049,1 +5058,0 @@\n-          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n@@ -5069,5 +5077,14 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), class_note, flags);\n+    if (is_value_class && is_initializer) {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method <init> is not allowed in value class %s\",\n+        _class_name->as_C_string());\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+        name->as_C_string(), _class_name->as_C_string(),\n+        class_note, flags);\n+    }\n@@ -5378,1 +5395,4 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()  ||\n+          (EnableValhalla && supports_inline_types() &&\n+          name == vmSymbols::inline_factory_name())) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":74,"deletions":54,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2939,5 +2939,7 @@\n-    \/\/ Make sure <init> can only be invoked by invokespecial or invokestatic.\n-    \/\/ The allowed invocation mode of <init> depends on its signature.\n-    if ((opcode != Bytecodes::_invokespecial &&\n-         opcode != Bytecodes::_invokestatic) ||\n-        method_name != vmSymbols::object_initializer_name()) {\n+    \/\/ Make sure:\n+    \/\/   <init> can only be invoked by invokespecial.\n+    \/\/   <vnew> can only be invoked by invokestatic.\n+    if (!((opcode == Bytecodes::_invokestatic &&\n+           method_name == vmSymbols::inline_factory_name()) ||\n+         (opcode == Bytecodes::_invokespecial &&\n+          method_name == vmSymbols::object_initializer_name()))) {\n@@ -2983,1 +2985,0 @@\n-      \/\/ (use of <init> as a static factory is handled under invokestatic)\n@@ -3036,3 +3037,2 @@\n-    if (method_name == vmSymbols::object_initializer_name() &&\n-        opcode != Bytecodes::_invokestatic) {\n-      \/\/ an <init> method must have a void return type, unless it's a static factory\n+    if (method_name == vmSymbols::object_initializer_name()) {\n+      \/\/ an <init> method must have a void return type\n@@ -3051,4 +3051,3 @@\n-  } else {\n-    \/\/ an <init> method may not have a void return type, if it's a static factory\n-    if (method_name == vmSymbols::object_initializer_name() &&\n-        opcode != Bytecodes::_invokespecial) {\n+  } else { \/\/ no return type\n+    \/\/ <vnew> method may not have a void return type\n+    if (method_name == vmSymbols::inline_factory_name()) {\n@@ -3056,1 +3055,1 @@\n-          \"Return type must be non-void in <init> static factory method\");\n+          \"Return type must be non-void in <vnew> static factory method\");\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -391,0 +391,1 @@\n+  template(inline_factory_name,                       \"<vnew>\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -306,2 +306,3 @@\n-          !vmSymbols::class_initializer_name()->equals(method_name)) {\n-        error_msg = \"Chars '<' and '>' only allowed in <init> and <clinit>\";\n+          !vmSymbols::class_initializer_name()->equals(method_name) &&\n+          !vmSymbols::inline_factory_name()->equals(method_name)) {\n+        error_msg = \"Chars '<' and '>' only allowed in <init>, <clinit> and <vnew>\";\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2614,1 +2614,1 @@\n-  else if (m->is_object_constructor() || m->is_static_init_factory()) {\n+  else if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2170,2 +2170,3 @@\n-    if (name == vmSymbols::object_initializer_name()) {\n-      break;  \/\/ <init> is never inherited, not even as a static factory\n+    if (name == vmSymbols::object_initializer_name() ||\n+        name == vmSymbols::inline_factory_name()) {\n+      break;  \/\/ <init> and <vnew> is never inherited\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -945,1 +945,1 @@\n-   return name() == vmSymbols::object_initializer_name() && !is_static();\n+  return name() == vmSymbols::object_initializer_name() && !is_static();\n@@ -948,3 +948,3 @@\n-\/\/ A static method named <init> is a factory for an inline class.\n-bool Method::is_static_init_factory() const {\n-   return name() == vmSymbols::object_initializer_name() && is_static();\n+\/\/ A static method named <vnew> is a factory for an inline class.\n+bool Method::is_static_vnew_factory() const {\n+  return name() == vmSymbols::inline_factory_name() && is_static();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-  \/\/ (non-static <init> or <clinit>), but false for factories (static <init>).\n+  \/\/ (non-static <init> or <clinit>), but false for factories (static <vnew>).\n@@ -673,2 +673,2 @@\n-  \/\/ returns true if the method name is <init> and the method is static\n-  bool is_static_init_factory() const;\n+  \/\/ returns true if the method name is <vnew> and the method is static\n+  bool is_static_vnew_factory() const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  if (m->is_object_constructor() || m->is_static_init_factory()) {\n+  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1835,1 +1835,1 @@\n-                  method->is_static_init_factory());\n+                  method->is_static_vnew_factory());\n@@ -1905,1 +1905,1 @@\n-               method->is_static_init_factory(), \"must be\");\n+               method->is_static_vnew_factory(), \"must be\");\n@@ -2188,1 +2188,1 @@\n-  if (m->is_object_constructor() || m->is_static_init_factory()) {\n+  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -819,3 +819,1 @@\n-        if (name != vmSymbols::object_initializer_name()) {\n-          break;                \/\/ will throw after end of switch\n-        } else if (type->is_void_method_signature()) {\n+        if (name == vmSymbols::object_initializer_name() && type->is_void_method_signature()) {\n@@ -823,2 +821,1 @@\n-        } else {\n-          \/\/ LinkageError unless it returns something reasonable\n+        } else if (name == vmSymbols::inline_factory_name()) {\n@@ -826,0 +823,2 @@\n+        } else {\n+          break;                \/\/ will throw after end of switch\n@@ -998,0 +997,1 @@\n+    Symbol* factory_name = vmSymbols::inline_factory_name();\n@@ -1011,1 +1011,1 @@\n-      ctor_ok = false;  \/\/ but sfac_ok is true, so we might find <init>\n+      ctor_ok = false;  \/\/ but sfac_ok is true\n@@ -1025,1 +1025,1 @@\n-      if (m_name == init_name) {  \/\/ might be either ctor or sfac\n+      if (m_name == init_name) {  \/\/ might be ctor\n@@ -1027,1 +1027,3 @@\n-        if (m->is_static_init_factory() && !sfac_ok)  continue;\n+      }\n+      if (m_name == factory_name) { \/\/ might be sfac\n+        if (m->is_static_vnew_factory() && !sfac_ok) continue;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -299,2 +299,2 @@\n-  if (!constructor_signature->is_void_method_signature()) {\n-    assert(klass->is_inline_klass(), \"inline classes must use factory methods\");\n+  if (EnableValhalla && !constructor_signature->is_void_method_signature()) {\n+    guarantee(klass->is_inline_klass(), \"inline classes must use factory methods\");\n@@ -303,1 +303,1 @@\n-                           vmSymbols::object_initializer_name(),\n+                           vmSymbols::inline_factory_name(),\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-         method()->is_static_init_factory(),\n+         method()->is_static_vnew_factory(),\n@@ -1003,2 +1003,4 @@\n-    \/\/ no need to resolve if method is private or <init>\n-    if (reflected_method->is_private() || reflected_method->name() == vmSymbols::object_initializer_name()) {\n+    \/\/ no need to resolve if method is private, <init> or <vnew>\n+    if (reflected_method->is_private() ||\n+        reflected_method->name() == vmSymbols::object_initializer_name() ||\n+        reflected_method->name() == vmSymbols::inline_factory_name()) {\n@@ -1188,1 +1190,0 @@\n-  assert(method->name() == vmSymbols::object_initializer_name(), \"invalid constructor\");\n@@ -1199,0 +1200,1 @@\n+    assert(method->name() == vmSymbols::inline_factory_name(), \"wrong factory method name\");\n@@ -1211,0 +1213,1 @@\n+  assert(method->name() == vmSymbols::object_initializer_name(), \"wrong constructor name\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1677,1 +1677,1 @@\n-        boolean isConstructor() { return !isPartial() && \"<init>\".equals(name); }\n+        boolean isObjectConstructor() { return !isPartial() && \"<init>\".equals(name); }\n@@ -1679,1 +1679,5 @@\n-        boolean isMethod() { return !isPartial() && !isConstructor() && !\"<clinit>\".equals(name); }\n+        boolean isValueFactoryMethod() { return !isPartial() && \"<vnew>\".equals(name); }\n+\n+        boolean isMethod() { return !isPartial() && !isObjectConstructor()\n+                                        && !isValueFactoryMethod()\n+                                        && !\"<clinit>\".equals(name); }\n@@ -1738,1 +1742,1 @@\n-            if (!enclosingInfo.isConstructor())\n+            if (!enclosingInfo.isObjectConstructor() && !enclosingInfo.isValueFactoryMethod())\n@@ -3840,1 +3844,1 @@\n-        throw new NoSuchMethodException(methodToString(\"<init>\", parameterTypes));\n+        throw new NoSuchMethodException(methodToString(isValue() ? \"<vnew>\" : \"<init>\", parameterTypes));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static final Set<String> pointyNames = Set.of(\"<init>\", \"<clinit>\");\n+    private static final Set<String> pointyNames = Set.of(\"<init>\", \"<vnew>\", \"<clinit>\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,0 +235,1 @@\n+     * For static value class instance factory methods, return {@code \"<vnew>\"}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        if (kind == CONSTRUCTOR)\n+        if (kind == CONSTRUCTOR) {\n@@ -68,0 +68,1 @@\n+        }\n@@ -75,1 +76,1 @@\n-            case CONSTRUCTOR   -> validateConstructor(type);\n+            case CONSTRUCTOR   -> validateObjectConstructor(type);\n@@ -105,1 +106,1 @@\n-    private static void validateConstructor(MethodTypeDesc type) {\n+    private static void validateObjectConstructor(MethodTypeDesc type) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        if (member.isObjectConstructorOrStaticInitMethod()) {\n+        if (member.isObjectConstructor()) {\n@@ -117,1 +117,1 @@\n-                methodType.returnType() != void.class) {\n+                    methodType.returnType() != void.class) {\n@@ -120,5 +120,0 @@\n-            } else if (MethodHandleNatives.refKindIsMethod(refKind) &&\n-                       methodType.returnType() != PrimitiveClass.asValueType(defc)) {\n-                \/\/ TODO: allow to return Object or perhaps one of the supertypes of that class\n-                \/\/ static init factory\n-                throw new IllegalArgumentException(\"static constructor must be of \" + defc.getName());\n@@ -126,1 +121,11 @@\n-\n+            return isPublic ? defc.getConstructor(methodType.parameterArray())\n+                            : defc.getDeclaredConstructor(methodType.parameterArray());\n+        } else if (member.isStaticValueFactoryMethod()) {\n+            assert defc.isValue();\n+            MethodType methodType = getMethodType();\n+            Class<?> rtype = PrimitiveClass.isPrimitiveClass(defc) ? PrimitiveClass.asValueType(defc) : defc;\n+            if (MethodHandleNatives.refKindIsMethod(refKind) &&\n+                    methodType.returnType() != rtype) {\n+                \/\/ static vnew factory\n+                throw new IllegalArgumentException(\"static factory must be of \" + defc.getName());\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1005,1 +1005,1 @@\n-        if (member.isObjectConstructorOrStaticInitMethod())  return false;\n+        if (member.isObjectConstructor() || member.isStaticValueFactoryMethod())  return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,2 @@\n-     *  For a constructor, it is always {@code \"<init>\"}.\n+     *  For an identity object constructor, it is {@code \"<init>\"}.\n+     *  For a value class static factory method, it is {@code \"<vnew>\"}.\n@@ -488,1 +489,2 @@\n-    static final String CONSTRUCTOR_NAME = \"<init>\";  \/\/ the ever-popular\n+    static final String CONSTRUCTOR_NAME = \"<init>\";\n+    static final String VALUE_FACTORY_NAME = \"<vnew>\";  \/\/ the ever-popular\n@@ -490,1 +492,0 @@\n-    \/\/ modifiers exported by the JVM:\n@@ -526,2 +527,2 @@\n-    public boolean isObjectConstructorOrStaticInitMethod() {\n-        return isObjectConstructor() || (getName().equals(CONSTRUCTOR_NAME) && testAllFlags(IS_METHOD));\n+    public boolean isStaticValueFactoryMethod() {\n+        return VALUE_FACTORY_NAME.equals(name) && isMethod();\n@@ -529,0 +530,1 @@\n+\n@@ -698,1 +700,1 @@\n-        this.name = CONSTRUCTOR_NAME;\n+        this.name = this.clazz.isValue() ? VALUE_FACTORY_NAME : CONSTRUCTOR_NAME;\n@@ -841,1 +843,2 @@\n-     *  It will be a constructor if and only if the name is {@code \"<init>\"}.\n+     *  It will be an object constructor if and only if the name is {@code \"<init>\"}.\n+     *  It will be a value class instance factory method if and only if the name is {@code \"<vnew>\"}.\n@@ -847,1 +850,1 @@\n-        int initFlags = (name != null && name.equals(CONSTRUCTOR_NAME) && type.returnType() == void.class ? IS_OBJECT_CONSTRUCTOR : IS_METHOD);\n+        int initFlags = CONSTRUCTOR_NAME.equals(name) ? IS_OBJECT_CONSTRUCTOR : IS_METHOD;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -163,2 +163,2 @@\n-     * This is {@code \"<init>\"} if the underlying member was a constructor,\n-     * else it is a simple method name or field name.\n+     * This is {@code \"<init>\"} or {@code \"<vnew>\"} if the underlying member\n+     * was a constructor, else it is a simple method name or field name.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -709,1 +709,1 @@\n-     * with special names ({@code \"<init>\"} and {@code \"<clinit>\"}).\n+     * with special names ({@code \"<init>\"}, {@code \"<vnew>\"} and {@code \"<clinit>\"}).\n@@ -2600,6 +2600,0 @@\n-            \/\/ resolveOrFail could return a non-static <init> method if present\n-            \/\/ detect and throw NSME before producing a MethodHandle\n-            if (!method.isStatic() && name.equals(\"<init>\")) {\n-                throw new NoSuchMethodException(\"illegal method name: \" + name);\n-            }\n-\n@@ -3457,1 +3451,1 @@\n-            assert(ctor.isObjectConstructorOrStaticInitMethod());\n+            assert(ctor.isObjectConstructor() || ctor.isStaticValueFactoryMethod());\n@@ -3714,1 +3708,1 @@\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial) {\n+            if (isIllegalMethodName(refKind, name)) {\n@@ -3717,0 +3711,1 @@\n+\n@@ -3736,0 +3731,12 @@\n+        \/*\n+         * \"<init>\" can only be invoked via invokespecial\n+         * \"<vnew>\" factory can only invoked via invokestatic\n+         *\/\n+        boolean isIllegalMethodName(byte refKind, String name) {\n+            if (name.startsWith(\"<\")) {\n+                return MemberName.VALUE_FACTORY_NAME.equals(name) ? refKind != REF_invokeStatic\n+                                                                  : refKind != REF_newInvokeSpecial;\n+            }\n+            return false;\n+        }\n+\n@@ -3738,4 +3745,2 @@\n-            \/\/ \"<init>\" can only be invoked via invokespecial or it's a static init factory\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial &&\n-                    !(refKind == REF_invokeStatic && name.equals(\"<init>\"))) {\n-                    throw new NoSuchMethodException(\"illegal method name: \" + name);\n+            if (isIllegalMethodName(refKind, name)) {\n+                throw new NoSuchMethodException(\"illegal method name: \" + name + \" \" + refKind);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -142,4 +142,4 @@\n-     * initializer}  For a constructor, the name {@code \"<init>\"} is\n-     * returned, for a static initializer, the name {@code \"<clinit>\"}\n-     * is returned, and for an anonymous class or instance\n-     * initializer, an <a href=Name.html#empty_name>empty name<\/a> is\n+     * initializer}  For a constructor, the name {@code \"<init>\"} or\n+     * {@code \"<vnew>\"} is returned, for a static initializer, the\n+     * name {@code \"<clinit>\"} is returned, and for an anonymous class\n+     * or instance initializer, an <a href=Name.html#empty_name>empty name<\/a> is\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -618,1 +618,2 @@\n-        for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+        Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n@@ -638,1 +639,1 @@\n-        if (methodName == names.init)\n+        if (names.isInitOrVNew(methodName))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -388,3 +388,1 @@\n-            String ms = (s.name == s.name.table.names.init)\n-                    ? s.owner.name.toString()\n-                    : s.name.toString();\n+            String ms = s.isInitOrVNew() ? s.owner.name.toString() : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-        if (name == name.table.names.init && owner.hasOuterInstance()) {\n+        if (isInitOrVNew() && owner.hasOuterInstance()) {\n@@ -427,0 +427,4 @@\n+    public boolean isConcreteValueClass() {\n+        return isValueClass() && !isAbstract();\n+    }\n+\n@@ -486,1 +490,7 @@\n-        return ((name == name.table.names.init && this.type.getReturnType().tsym == this.owner));\n+        return name == name.table.names.vnew && this.type.getReturnType().tsym == this.owner;\n+    }\n+\n+    \/** Is this symbol a constructor or value factory?\n+     *\/\n+    public boolean isInitOrVNew() {\n+        return name.table.names.isInitOrVNew(name);\n@@ -1992,1 +2002,1 @@\n-                String s = (name == name.table.names.init)\n+                String s = isInitOrVNew()\n@@ -2054,1 +2064,1 @@\n-            if (isConstructor() || _other.kind != MTH) return false;\n+            if (isInitOrVNew() || _other.kind != MTH) return false;\n@@ -2123,1 +2133,1 @@\n-            if (isConstructor() || _other.kind != MTH) return false;\n+            if (isInitOrVNew() || _other.kind != MTH) return false;\n@@ -2248,1 +2258,1 @@\n-            if (name == name.table.names.init)\n+            if (isInitOrVNew())\n@@ -2421,1 +2431,1 @@\n-                if (refSym.isConstructor()) {\n+                if (refSym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                    !s.isConstructor())\n+                    !s.isInitOrVNew())\n@@ -243,1 +243,1 @@\n-                    (s.kind == MTH && !s.isConstructor() &&\n+                    (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -245,1 +245,1 @@\n-                    (s.kind == MTH && s.isConstructor()))\n+                    (s.kind == MTH && s.isInitOrVNew()))\n@@ -1056,1 +1056,1 @@\n-                    } else if (exsym.isConstructor()) {\n+                    } else if (exsym.isInitOrVNew()) {\n@@ -1159,1 +1159,1 @@\n-                    if (tree.sym.isConstructor()) {\n+                    if (tree.sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -978,1 +978,1 @@\n-                        t.name != names.init &&\n+                        !names.isInitOrVNew(t.name) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n+            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n@@ -1080,1 +1080,1 @@\n-                if (tree.name == names.init) {\n+                if (names.isInitOrVNew(tree.name)) {\n@@ -1195,1 +1195,1 @@\n-                if (tree.name == names.init && owner.type != syms.objectType) {\n+                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n@@ -2643,1 +2643,1 @@\n-            if (enclMethod != null && enclMethod.name == names.init) {\n+            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n@@ -3544,1 +3544,2 @@\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n+                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n@@ -3607,0 +3608,1 @@\n+            Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3608,0 +3610,4 @@\n+                \/\/ TODO - a bit hacky but...\n+                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n+                    that.name = names.vnew;\n+                }\n@@ -3613,1 +3619,0 @@\n-                Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3697,1 +3702,1 @@\n-            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n@@ -4761,1 +4766,1 @@\n-            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n+            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -782,1 +782,1 @@\n-                    } else if (s.isConstructor()) {\n+                    } else if (s.isInitOrVNew()) {\n@@ -1125,1 +1125,1 @@\n-                (s.isConstructor() ||\n+                (s.isInitOrVNew() ||\n@@ -1201,0 +1201,1 @@\n+        \/\/ TODO - is enum so <init>\n@@ -1384,1 +1385,1 @@\n-            if (sym.name == names.init) {\n+            if (names.isInitOrVNew(sym.name)) {\n@@ -1787,1 +1788,1 @@\n-                    env.enclMethod != null && env.enclMethod.name == names.init;\n+                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n@@ -2383,1 +2384,1 @@\n-                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n@@ -2934,1 +2935,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -2993,1 +2994,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -3680,1 +3681,1 @@\n-                if (s.kind == MTH && !s.isConstructor())\n+                if (s.kind == MTH && !s.isInitOrVNew())\n@@ -3688,1 +3689,1 @@\n-                if (s.kind == MTH && s.isConstructor())\n+                if (s.kind == MTH && s.isInitOrVNew())\n@@ -3707,1 +3708,1 @@\n-                        (s.kind == MTH && !s.isConstructor() &&\n+                        (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -3709,1 +3710,1 @@\n-                        (s.kind == MTH && s.isConstructor())) {\n+                        (s.kind == MTH && s.isInitOrVNew())) {\n@@ -4973,1 +4974,1 @@\n-                    if (sym.isConstructor() &&\n+                    if (sym.isInitOrVNew() &&\n@@ -5001,1 +5002,1 @@\n-                        if (sym.isConstructor()) {\n+                        if (sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-                Name name = msym.name == msym.name.table.names.init ?\n+                Name name = msym.name.table.names.isInitOrVNew(msym.name) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,1 +356,2 @@\n-            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n+            \/\/ TODO - can <vnew> exist in this context?\n+            if ((init = names.isInitOrVNew(owner.name)) || owner.name == names.clinit) {\n@@ -1664,1 +1665,2 @@\n-                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n+                Name constructorName = csym.isConcreteValueClass() ? names.vnew : names.init;\n+                for (Symbol s : csym.members_field.getSymbolsByName(constructorName)) {\n@@ -1768,1 +1770,1 @@\n-                    && sym.name != names.init;\n+                    && !names.isInitOrVNew(sym.name);\n@@ -1890,0 +1892,2 @@\n+                } else if (methodName.equals(\"<vnew>\")) {\n+                    methodName = \"vnew\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1054,1 +1054,1 @@\n-        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (names.isInitOrVNew(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1267,0 +1267,1 @@\n+                Name constructorName = accOwner.isConcreteValueClass() ? names.vnew : names.init;\n@@ -1269,1 +1270,1 @@\n-                    names.init,\n+                    constructorName,\n@@ -1313,1 +1314,1 @@\n-        if (sym.name == names.init) {\n+        if (names.isInitOrVNew(sym.name)) {\n@@ -1527,1 +1528,1 @@\n-            (owner.isConstructor() && owner.isAnonymous()) ||\n+            (owner.isInitOrVNew() && owner.isAnonymous()) ||\n@@ -1529,1 +1530,1 @@\n-            (owner.isConstructor() && c.isInner() &&\n+            (owner.isInitOrVNew() && c.isInner() &&\n@@ -2662,0 +2663,1 @@\n+        \/\/ TODO - enum so is always <init>\n@@ -2703,1 +2705,1 @@\n-        if (tree.name == names.init &&\n+        if (names.isInitOrVNew(tree.name) &&\n@@ -2784,1 +2786,1 @@\n-        if (tree.name == names.init && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+        if (names.isInitOrVNew(tree.name) && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -3025,1 +3027,2 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        \/\/ TODO - is enum so always <init>.\n+        if (names.isInitOrVNew(meth.name) && meth.owner == syms.enumSym)\n@@ -3030,1 +3033,1 @@\n-        if (meth.name==names.init) {\n+        if (names.isInitOrVNew(meth.name)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private final boolean allowValueClasses;\n@@ -84,0 +85,2 @@\n+        Source source = Source.instance(context);\n+        allowValueClasses = Source.Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -180,0 +183,3 @@\n+        if (tree.name == tree.name.table.names.init && allowValueClasses && enclScope.owner.isConcreteValueClass()) {\n+            tree.name = tree.name.table.names.vnew;\n+        }\n@@ -233,1 +239,1 @@\n-        if (m.isConstructor() && m.type.getParameterTypes().size() == 0) {\n+        if (m.isInitOrVNew() && m.type.getParameterTypes().size() == 0) {\n@@ -347,1 +353,1 @@\n-        if (m.isConstructor()) {\n+        if (m.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1058,1 +1058,2 @@\n-            for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+            Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n+            for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    public final boolean allowValueClasses;\n@@ -143,1 +144,0 @@\n-        Target target = Target.instance(context);\n@@ -150,0 +150,1 @@\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -219,1 +220,1 @@\n-        if (bestSoFar.name == names.init &&\n+        if (names.isInitOrVNew(bestSoFar.name) &&\n@@ -292,1 +293,1 @@\n-        return owner.isConstructor() ||\n+        return owner.isInitOrVNew() ||\n@@ -404,1 +405,1 @@\n-        if (sym.name == names.init && sym.owner != site.tsym) return false;\n+        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n@@ -481,1 +482,1 @@\n-        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n@@ -1884,1 +1885,1 @@\n-            if (name == names.init) return bestSoFar;\n+            if (names.isInitOrVNew(name)) return bestSoFar;\n@@ -2929,1 +2930,2 @@\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n@@ -2963,0 +2965,1 @@\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2964,1 +2967,1 @@\n-                                    names.init, argtypes,\n+                                    constructorName, argtypes,\n@@ -2987,0 +2990,1 @@\n+        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2988,1 +2992,1 @@\n-                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n@@ -3003,1 +3007,1 @@\n-                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n@@ -3050,1 +3054,2 @@\n-        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n@@ -3059,1 +3064,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n@@ -3101,1 +3106,1 @@\n-        if (!name.equals(names.init)) {\n+        if (!names.isInitOrVNew(name)) {\n@@ -3693,1 +3698,2 @@\n-            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n+            \/\/ TODO - array constructor will be <init>\n+            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3725,1 +3731,1 @@\n-            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -4130,1 +4136,1 @@\n-            boolean isConstructor = name == names.init;\n+            boolean isConstructor = names.isInitOrVNew(name);\n@@ -4222,1 +4228,1 @@\n-                      ws.name == names.init ? ws.owner.name : ws.name,\n+                      names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n@@ -4278,0 +4284,1 @@\n+                boolean isConstructor = names.isInitOrVNew(name);\n@@ -4286,2 +4293,2 @@\n-                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),\n-                        name == names.init ? site.tsym.name : name,\n+                        isConstructor ? KindName.CONSTRUCTOR : kind.absentKind(),\n+                        isConstructor ? site.tsym.name : name,\n@@ -4447,1 +4454,1 @@\n-            if (sym.name == names.init && sym.owner != site.tsym) {\n+            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n@@ -4660,1 +4667,1 @@\n-            if (sname == names.init) sname = s1.owner.name;\n+            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-                sym.name != names.init &&\n+                !names.isInitOrVNew(sym.name) &&\n@@ -680,0 +680,1 @@\n+        \/\/ TODO - is enum so <init>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1154,1 +1154,1 @@\n-                            } else if (s.isConstructor()) {\n+                            } else if (s.isInitOrVNew()) {\n@@ -1364,1 +1364,2 @@\n-                constructorSymbol = new MethodSymbol(flags, names.init,\n+                Name constructorName = owner().isConcreteValueClass() ? names.vnew : names.init;\n+                constructorSymbol = new MethodSymbol(flags, constructorName,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-                    if (sym.isConstructor()  && sym.type.getParameterTypes().size() == 0) {\n+                    if (sym.isInitOrVNew()  && sym.type.getParameterTypes().size() == 0) {\n@@ -1011,1 +1011,1 @@\n-                        if (sym.kind == MTH  && sym.name == names.init && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n+                        if (sym.kind == MTH  && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n@@ -1362,1 +1362,1 @@\n-        if (nt.name != names.init)\n+        if (!names.isInitOrVNew(nt.name))\n@@ -2275,1 +2275,1 @@\n-        if (name == names.init && ((flags & STATIC) != 0)) {\n+        if (names.isInitOrVNew(name) && ((flags & STATIC) != 0)) {\n@@ -2283,1 +2283,1 @@\n-        if (name == names.init && currentOwner.hasOuterInstance()) {\n+        if (names.isInitOrVNew(name) && currentOwner.hasOuterInstance()) {\n@@ -2326,1 +2326,1 @@\n-            (name == names.init && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            ((name == names.init || name ==names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2396,1 +2396,1 @@\n-            if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n+            if (names.isInitOrVNew(sym.name) && currentOwner.hasOuterInstance()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1037,1 +1037,1 @@\n-                || ((m.flags_field & RECORD) != 0 && (m.isConstructor() || m.isValueObjectFactory())))) {\n+                || ((m.flags_field & RECORD) != 0 && (m.isInitOrVNew() || m.isValueObjectFactory())))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-        if (member.isConstructor())\n+        if (member.isInitOrVNew())\n@@ -1385,1 +1385,1 @@\n-            if (meth.isConstructor() && thisType != syms.objectType) {\n+            if (meth.isInitOrVNew() && thisType != syms.objectType) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-        else items.makeMemberItem(msym, name == names.init).invoke();\n+        else items.makeMemberItem(msym, names.isInitOrVNew(name)).invoke();\n@@ -564,1 +564,1 @@\n-        if (md.name == names.init && TreeInfo.isInitialConstructor(md)) {\n+        if (names.isInitOrVNew(md.name) && TreeInfo.isInitialConstructor(md)) {\n@@ -967,1 +967,1 @@\n-            if (meth.isConstructor()) {\n+            if (meth.isInitOrVNew()) {\n@@ -1074,1 +1074,1 @@\n-                if (meth.isConstructor() && selfType != syms.objectType)\n+                if (meth.isInitOrVNew() && selfType != syms.objectType)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import static com.sun.tools.javac.code.Flags.RECORD;\n@@ -374,1 +375,1 @@\n-        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.isConstructor();\n+        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.name == names.vnew;\n@@ -385,1 +386,1 @@\n-        Assert.check(init.name.equals(names.init));\n+        Assert.check(init.name.equals(names.vnew));\n@@ -396,1 +397,1 @@\n-                                        names.init,\n+                                        names.vnew,\n@@ -415,1 +416,1 @@\n-        if (md.name == names.init && md.body != null) {\n+        if (names.isInitOrVNew(md.name) && md.body != null) {\n@@ -430,15 +431,0 @@\n-\n-    private MethodSymbol getDefaultConstructor(Symbol klass) {\n-        for (Symbol method : klass.members().getSymbolsByName(names.init, s->s.kind == MTH && s.type.getParameterTypes().size() == 0, LookupKind.NON_RECURSIVE)) {\n-            return (MethodSymbol) method;\n-        }\n-        \/\/ class defines a non-nullary but no nullary constructor, fabricate a symbol.\n-        MethodType dctorType = new MethodType(List.nil(),\n-                klass.type,\n-                List.nil(),\n-                klass.type.tsym);\n-        return new MethodSymbol(Flags.PUBLIC,\n-                names.init,\n-                dctorType,\n-                klass);\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1702,1 +1702,1 @@\n-                                ((JCMethodDecl) t).sym.name == names.init ||\n+                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2370,0 +2370,1 @@\n+            \/\/ TODO - will be converted in Attr\n@@ -4104,1 +4105,2 @@\n-                if (methDef.name == names.init && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                \/\/ TODO - specifically for record.\n+                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -4698,1 +4700,1 @@\n-            if (!isRecord || name != names.init || token.kind == LPAREN) {\n+            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -961,0 +961,4 @@\n+\n+        public boolean isInitOrVNew() {\n+            return name.table.names.isInitOrVNew(name);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-            if (tree.name == tree.name.table.names.init &&\n+            if (tree.isInitOrVNew() &&\n@@ -603,1 +603,1 @@\n-            if (tree.name == tree.name.table.names.init) {\n+            if (tree.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,12 @@\n-            return name == name.table.names.init;\n+            return name == name.table.names.init || name == name.table.names.vnew;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/** Is tree a value factory declaration?\n+     *\/\n+    public static boolean isValueFactory(JCTree tree) {\n+        if (tree.hasTag(METHODDEF)) {\n+            Name name = ((JCMethodDecl) tree).name;\n+            return name == name.table.names.vnew;\n@@ -109,1 +120,1 @@\n-            if (isConstructor(l.head)) return true;\n+            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n@@ -255,2 +266,1 @@\n-        Names names = md.name.table.names;\n-        if (md.name != names.init) return null;\n+        if (!md.isInitOrVNew()) return null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+    public final Name vnew;\n@@ -288,0 +289,1 @@\n+        vnew = fromString(\"<vnew>\");\n@@ -434,0 +436,4 @@\n+    public boolean isInitOrVNew(Name name) {\n+        return name == init || name == vnew;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -434,3 +434,1 @@\n-                String ms = (s.name == s.name.table.names.init)\n-                    ? ownerName\n-                    : s.name.toString();\n+                String ms = (s.isInitOrVNew()) ? ownerName : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    valueFactoryName = null;\n@@ -98,0 +99,1 @@\n+  private static String valueFactoryName;\n@@ -105,0 +107,6 @@\n+  private static String valueFactoryName() {\n+    if (valueFactoryName == null) {\n+      valueFactoryName = \"<vnew>\";\n+    }\n+    return classInitializerName;\n+  }\n@@ -248,1 +256,1 @@\n-     return (!isStatic()) && getName().equals(objectInitializerName());\n+     return (!isStatic()) && (getName().equals(objectInitializerName()) || getName().equals(valueFactoryName()));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-      if (name.equals(\"<init>\")) {\n+      if (name.equals(\"<init>\") || name.equals(\"<vnew>\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/ObjectReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-        return getDeclaringClass().isJavaLangObject() && getName().equals(\"<init>\");\n+        return getDeclaringClass().isJavaLangObject() && (getName().equals(\"<init>\") || getName().equals(\"<vnew>\"));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -532,0 +532,1 @@\n+            case \"<vnew>\":\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+               s.equals(\"<vnew>\") ||\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/BreakpointSpec.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-        return name().equals(\"<init>\");\n+        return name().equals(\"<init>\") || name().equals(\"<vnew>\");\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/MethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        return name.equals(\"<init>\");\n+        return name.equals(\"<init>\") || name.equals(\"<vnew>\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/ConstructorTracerWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-    NameAndType #5 #11; \/\/ #9\n+    NameAndType #42 #11; \/\/ #9\n@@ -48,0 +48,1 @@\n+    Utf8 \"<vnew>\"; \/\/ #42\n@@ -175,1 +176,1 @@\n-    NameAndType #5 #11; \/\/ #9\n+    NameAndType #42 #11; \/\/ #9\n@@ -208,0 +209,1 @@\n+    Utf8 \"<vnew>\"; \/\/ #42\n@@ -345,1 +347,1 @@\n-    Utf8 \"<init>\"; \/\/ #19\n+    Utf8 \"<vnew>\"; \/\/ #19\n@@ -484,1 +486,1 @@\n-    Utf8 \"<init>\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #7\n@@ -640,1 +642,1 @@\n-    Utf8 \"<init>\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #7\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"<vnew>\"; \/\/ #14\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    public static Method <init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n@@ -44,1 +44,1 @@\n-        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n@@ -47,1 +47,1 @@\n-        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n@@ -85,1 +85,1 @@\n-    public static Method <init>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\" stack 2 {\n+    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\" stack 2 {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBufferingClasses.jasm","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/\/ method <init> in class HiddenPoint was changed to java.lang.Object because\n+\/\/ method <vnew> in class HiddenPoint was changed to java.lang.Object because\n@@ -66,1 +66,1 @@\n-    Utf8 \"<init>\"; \/\/ #20     at 0xC9\n+    Utf8 \"<vnew>\"; \/\/ #20     at 0xC9\n@@ -141,1 +141,1 @@\n-      #20; \/\/ name_index       : <init>\n+      #20; \/\/ name_index       : <vnew>\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESPECIAL, containerClass, \"<init>\", \"()V\", false)\n+                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESTATIC, containerClass, \"<vnew>\", \"()V\", false)\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    Utf8 \"<init>\"; \/\/ #13     at 0x5B\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x5B\n@@ -260,1 +260,1 @@\n-      #13; \/\/ name_index       : <init>\n+      #13; \/\/ name_index       : <vnew>\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCICCETests.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"<vnew>\"; \/\/ #5\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/PrimitiveUsers.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -913,1 +913,1 @@\n-    Utf8 \"<init>\"; \/\/ #30     at 0xF9\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0xF9\n@@ -1191,1 +1191,1 @@\n-    Utf8 \"<init>\"; \/\/ #29     at 0xF7\n+    Utf8 \"<vnew>\"; \/\/ #29     at 0xF7\n@@ -1506,1 +1506,1 @@\n-    Utf8 \"<init>\"; \/\/ #30     at 0x0114\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0x0114\n@@ -1784,1 +1784,1 @@\n-    Utf8 \"<init>\"; \/\/ #30     at 0x0114\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0x0114\n@@ -2059,1 +2059,1 @@\n-    Utf8 \"<init>\"; \/\/ #18     at 0xA0\n+    Utf8 \"<vnew>\"; \/\/ #18     at 0xA0\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"<vnew>\"; \/\/ #5\n@@ -96,1 +96,1 @@\n-    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"<vnew>\"; \/\/ #5\n@@ -157,1 +157,1 @@\n-    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"<vnew>\"; \/\/ #5\n@@ -220,1 +220,1 @@\n-    Utf8 \"<init>\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #7\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/ClassesWithInvalidModifiers.jcod","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -337,1 +337,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -597,1 +597,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -856,1 +856,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -1117,1 +1117,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -1377,1 +1377,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -1637,1 +1637,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -1897,1 +1897,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -2156,1 +2156,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n@@ -2417,1 +2417,1 @@\n-    Utf8 \"<init>\"; \/\/ #33     at 0x0171\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/InlineClassWithBadSupers.jcod","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n@@ -279,1 +279,1 @@\n-    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n@@ -375,1 +375,1 @@\n-    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n@@ -466,1 +466,1 @@\n-    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n@@ -556,1 +556,1 @@\n-    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n@@ -748,1 +748,1 @@\n-    Utf8 \"<init>\"; \/\/ #7     at 0x26\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n@@ -851,1 +851,1 @@\n-    Utf8 \"<init>\"; \/\/ #19     at 0xC0\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0xC0\n@@ -1075,1 +1075,1 @@\n-    Utf8 \"<init>\"; \/\/ #19     at 0x94\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0x94\n@@ -1144,1 +1144,1 @@\n-      #19; \/\/ name_index       : <init>\n+      #19; \/\/ name_index       : <vnew>\n@@ -1270,1 +1270,1 @@\n-    Utf8 \"<init>\"; \/\/ #32     at 0x0135\n+    Utf8 \"<vnew>\"; \/\/ #32     at 0x0135\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-\/\/ If putfieldPrimitive.<init>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ If putfieldPrimitive.<vnew>(bool) is passed TRUE then it uses a withfield bytecode.\n@@ -359,1 +359,1 @@\n-    Utf8 \"<init>\"; \/\/ #13     at 0x61\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x61\n@@ -412,1 +412,1 @@\n-      #13; \/\/ name_index       : <init>\n+      #13; \/\/ name_index       : <vnew>\n@@ -479,1 +479,1 @@\n-\/\/ If withfieldPrimitive.<init>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ If withfieldPrimitive.<vnew>(bool) is passed TRUE then it uses a withfield bytecode.\n@@ -500,1 +500,1 @@\n-    Utf8 \"<init>\"; \/\/ #13     at 0x61\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x61\n@@ -553,1 +553,1 @@\n-      #13; \/\/ name_index       : <init>\n+      #13; \/\/ name_index       : <vnew>\n@@ -624,1 +624,1 @@\n-    Utf8 \"<init>\"; \/\/ #9     at 0x41\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x41\n@@ -652,1 +652,1 @@\n-      #9; \/\/ name_index       : <init>\n+      #9; \/\/ name_index       : <vnew>\n@@ -729,1 +729,1 @@\n-    Utf8 \"<init>\"; \/\/ #9     at 0x58\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x58\n@@ -762,1 +762,1 @@\n-      #9; \/\/ name_index       : <init>\n+      #9; \/\/ name_index       : <vnew>\n@@ -818,1 +818,1 @@\n-    Utf8 \"<init>\"; \/\/ #9     at 0x58\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x58\n@@ -851,1 +851,1 @@\n-      #9; \/\/ name_index       : <init>\n+      #9; \/\/ name_index       : <vnew>\n@@ -915,1 +915,1 @@\n-    Utf8 \"<init>\"; \/\/ #17     at 0xA1\n+    Utf8 \"<vnew>\"; \/\/ #17     at 0xA1\n@@ -970,1 +970,1 @@\n-      #17; \/\/ name_index       : <init>\n+      #17; \/\/ name_index       : <vnew>\n@@ -1023,1 +1023,1 @@\n-  [33] { \/\/ Constant Pool\n+  [34] { \/\/ Constant Pool\n@@ -1033,1 +1033,1 @@\n-    NameAndType #5 #11; \/\/ #9     at 0x41\n+    NameAndType #33 #11; \/\/ #9     at 0x41\n@@ -1038,1 +1038,1 @@\n-    NameAndType #5 #16; \/\/ #14     at 0x83\n+    NameAndType #33 #16; \/\/ #14     at 0x83\n@@ -1043,1 +1043,1 @@\n-    NameAndType #5 #21; \/\/ #19     at 0xC5\n+    NameAndType #33 #21; \/\/ #19     at 0xC5\n@@ -1057,0 +1057,1 @@\n+    Utf8 \"<vnew>\"; \/\/ #33\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/withfieldTests\/withfieldTests.jcod","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary test MethodHandle of static init factories\n+ * @summary test MethodHandle of static vnew factories\n@@ -85,1 +85,1 @@\n-        \/\/ test default static init factory\n+        \/\/ test default vnew init factory\n@@ -87,1 +87,1 @@\n-        MethodHandle mh = staticInitFactory(cls, methodType(cls));\n+        MethodHandle mh = staticValueFactory(cls, methodType(cls));\n@@ -108,1 +108,1 @@\n-        MethodHandle mh = staticInitFactory(c, mtype);\n+        MethodHandle mh = staticValueFactory(c, mtype);\n@@ -131,1 +131,1 @@\n-        \/\/ test default static init factory\n+        \/\/ test default static value class factory\n@@ -133,1 +133,1 @@\n-        MethodHandle mh = staticInitFactory(Value.class, mtype);\n+        MethodHandle mh = staticValueFactory(Value.class, mtype);\n@@ -140,1 +140,1 @@\n-     * Test the following API when looking up a static init factory\n+     * Test the following API when looking up a static value class factory method\n@@ -142,1 +142,1 @@\n-     * 1. Lookup::findStatic accepts \"<init>\" to lookup a static init factory\n+     * 1. Lookup::findStatic accepts \"<vnew>\" to lookup a static value class factory method\n@@ -145,1 +145,1 @@\n-     *    Hence it won't find the static <init> factory.\n+     *    Hence it won't find the static <vnew> factory.\n@@ -148,1 +148,1 @@\n-    static MethodHandle staticInitFactory(Class<? extends Cons> c, MethodType mtype) throws Throwable {\n+    static MethodHandle staticValueFactory(Class<? extends Cons> c, MethodType mtype) throws Throwable {\n@@ -151,1 +151,1 @@\n-        MethodHandle mh = lookup.findStatic(c, \"<init>\", mtype);\n+        MethodHandle mh = lookup.findStatic(c, \"<vnew>\", mtype);\n@@ -161,1 +161,1 @@\n-        assertEquals(minfo.getName(), \"<init>\");\n+        assertEquals(minfo.getName(), \"<vnew>\");\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryMethodHandleTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -100,1 +100,3 @@\n-                                boolean isValueClass, boolean isPrimitiveClass) throws ReflectiveOperationException {\n+                                boolean isValueClass, boolean isPrimitiveClass)\n+            throws ReflectiveOperationException\n+    {\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandleInfo;\n@@ -37,0 +41,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n@@ -44,0 +50,1 @@\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n@@ -110,2 +117,1 @@\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        Class<?> c = (Class<?>) cd.resolveConstantDesc(lookup);\n+        Class<?> c = (Class<?>) cd.resolveConstantDesc(LOOKUP);\n@@ -115,0 +121,30 @@\n+    @DataProvider(name=\"classes\")\n+    static Object[][] classes() {\n+        Class<?> valType = PrimitiveClass.asValueType(Point.class);\n+        Class<?> refType = Point.class;\n+\n+        return new Object[][]{\n+            new Object[] { ValueOptional.class, \"(Ljava\/lang\/Object;)LValueOptional;\" },\n+            new Object[] { valType, \"(II)QPoint;\" },\n+            new Object[] { refType, \"(II)QPoint;\" },\n+        };\n+    }\n+    @Test(dataProvider=\"classes\")\n+    public void directMethodHandleDesc(Class<?> type, String methodDescriptor) throws Throwable {\n+        ClassDesc cd = type.describeConstable().orElseThrow();\n+        MethodTypeDesc methodTypeDesc = MethodTypeDesc.ofDescriptor(methodDescriptor);\n+\n+        DirectMethodHandleDesc dmhDesc = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, cd, \"<vnew>\", methodTypeDesc);\n+        MethodHandle mh = (MethodHandle) dmhDesc.resolveConstantDesc(LOOKUP);\n+        MethodType methodType = (MethodType) methodTypeDesc.resolveConstantDesc(LOOKUP);\n+        MethodHandle vnew = LOOKUP.findStatic(type, \"<vnew>\", methodType);\n+        assertMethodHandleEquals(mh, vnew);\n+    }\n+\n+    private static void assertMethodHandleEquals(MethodHandle mh1, MethodHandle mh2) {\n+        MethodHandleInfo minfo1 = LOOKUP.revealDirect(mh1);\n+        MethodHandleInfo minfo2 = LOOKUP.revealDirect(mh2);\n+        assertEquals(minfo1.getDeclaringClass(), minfo2.getDeclaringClass());\n+        assertEquals(minfo1.getName(), minfo2.getName());\n+        assertEquals(minfo1.getMethodType(), minfo2.getMethodType());\n+    }\n@@ -120,2 +156,1 @@\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        Class<?> c = (Class<?>) cd.resolveConstantDesc(lookup);\n+        Class<?> c = (Class<?>) cd.resolveConstantDesc(LOOKUP);\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueConstantDesc.java","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-              \"  #21 = NameAndType        #22:#23        \/\/ \\\"<init>\\\":()QQTypedValue;\",\n+              \"  #21 = NameAndType        #22:#23        \/\/ \\\"<vnew>\\\":()QQTypedValue;\",\n@@ -88,1 +88,1 @@\n-              \"         1: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n+              \"         1: invokestatic  #20                 \/\/ Method \\\"<vnew>\\\":()QQTypedValue;\",\n@@ -97,1 +97,1 @@\n-              \"        19: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n+              \"        19: invokestatic  #20                 \/\/ Method \\\"<vnew>\\\":()QQTypedValue;\",\n@@ -102,1 +102,1 @@\n-              \"        29: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n+              \"        29: invokestatic  #20                 \/\/ Method \\\"<vnew>\\\":()QQTypedValue;\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                } else if (methodName.equals(\"<init>\")) {\n+                } else if (methodName.equals(\"<vnew>\")) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,24 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n+ * @test \/nodynamiccopyright\/\n@@ -29,2 +6,2 @@\n- * @compile --source 16 ConsumeValueClassAtLowerLevel.java\n- * @run main ConsumeValueClassAtLowerLevel\n+ * @compile ConsumeValueClassAtLowerLevel.java\n+ * @compile\/fail\/ref=ConsumeValueClassAtLowerLevel.out --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n@@ -34,10 +11,4 @@\n-    public static void main(String [] args) {\n-\n-        \/* Attempting to instantiate a value\/primitive class in earlier source level should\n-         * result in an InstantiationError since javac's class reader downgrades\n-         * the value class to an identity class if current source level does not\n-         * support value\/primitive class. And so rather than invoke the factory method,\n-         * the source code of earlier vintage would attempt to invoke the constructor\n-         * and so should crash and burn with an InstantiationError.\n-         *\n-         * This behavior is subject to change - see JDK-8282525\n+    void m() {\n+        \/* GenericPoint was compiled with a source that allows value classes but ConsumeValueClassAtLowerLevel was not\n+         * so GenericPoint has a <vnew> initializer but in a source that doesn't allow value classes we look for <ini>\n+         * thus the compiler error in the second compilation of ConsumeValueClassAtLowerLevel.java\n@@ -45,9 +16,1 @@\n-        boolean gotIE = false;\n-        try {\n-            GenericPoint<Integer> gl = new GenericPoint<>(0, 0);\n-        } catch (java.lang.InstantiationError ie) {\n-            gotIE = true;\n-        }\n-        if (!gotIE) {\n-            throw new AssertionError(\"Did not see instantiation error!\");\n-        }\n+        GenericPoint<Integer> gl = new GenericPoint<>(0, 0);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.java","additions":8,"deletions":45,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 16\n+ConsumeValueClassAtLowerLevel.java:16:36: compiler.err.cant.resolve.location.args: kindname.constructor, GenericPoint, , int,int, (compiler.misc.location: kindname.class, GenericPoint<T>, null)\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-        V foo(X x) {\n+        V bar(X x) {\n@@ -40,1 +40,1 @@\n-            void foo(X x) {\n+            void ooo(X x) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-         \"4: invokestatic  #10                 \/\/ Method \\\"<init>\\\":(II)LValueCreationTest$Point;\",\n+         \"4: invokestatic  #10                 \/\/ Method \\\"<vnew>\\\":(II)LValueCreationTest$Point;\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,5 @@\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n@@ -47,0 +52,3 @@\n+import com.sun.tools.classfile.Instruction;\n+import com.sun.tools.classfile.Method;\n+\n@@ -742,0 +750,101 @@\n+\n+    public void testCheckVnew() throws Exception {\n+        for (String source : List.of(\n+                \"\"\"\n+                abstract value class A {}\n+                \"\"\",\n+                \"\"\"\n+                value class A {}\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                boolean isAbstract = classFile.access_flags.is(Flags.ABSTRACT);\n+                for (Method method : classFile.methods) {\n+                    if (isAbstract) {\n+                        assertTrue(method.getName(classFile.constant_pool).equals(\"<init>\"));\n+                        assertTrue(!method.access_flags.is(Flags.STATIC));\n+                    } else {\n+                        assertTrue(method.getName(classFile.constant_pool).equals(\"<vnew>\"));\n+                        assertTrue(method.access_flags.is(Flags.STATIC));\n+                        assertTrue(!method.access_flags.is(Flags.ABSTRACT));\n+                        assertTrue(method.descriptor.getReturnType(classFile.constant_pool).equals(\"A\"));\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ check that <vnew> is invoked with invokestatic\n+        for (String source : List.of(\n+                \"\"\"\n+                value class A {\n+                    void FIND_ME() {\n+                        A a = new A();\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"FIND_ME\")) {\n+                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n+                        boolean firstInst = true;\n+                        for (Instruction inst: code_attribute.getInstructions()) {\n+                            if (firstInst) {\n+                                assertTrue(inst.getMnemonic().equals(\"invokestatic\"));\n+                                CONSTANT_Methodref_info methodInfo =\n+                                        (CONSTANT_Methodref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n+                                assertTrue(methodInfo.getClassInfo().getName().equals(\"A\"));\n+                                assertTrue(methodInfo.getNameAndTypeInfo().getName().equals(\"<vnew>\"));\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ checking the aconst_init and withfield instructions\n+        for (String source : List.of(\n+                \"\"\"\n+                value class A {\n+                    int i;\n+                    String s;\n+\n+                    A(int i, String s) {\n+                        this.i = i;\n+                        this.s = s;\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"<vnew>\")) {\n+                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n+                        for (Instruction inst: code_attribute.getInstructions()) {\n+                            if (inst.getMnemonic().equals(\"aconst_init\")) {\n+                                CONSTANT_Class_info classInfo =\n+                                        (CONSTANT_Class_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n+                                assertTrue(classInfo.getName().equals(\"A\"));\n+                            } else if (inst.getMnemonic().equals(\"withfield\")) {\n+                                CONSTANT_Fieldref_info fieldInfo = (CONSTANT_Fieldref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n+                                assertTrue(fieldInfo.getClassName().equals(\"A\"));\n+                                ConstantPool.CONSTANT_NameAndType_info nameAndType = fieldInfo.getNameAndTypeInfo();\n+                                if (nameAndType.getName().equals(\"i\")) {\n+                                    assertTrue(nameAndType.getType().equals(\"I\"));\n+                                } else if (nameAndType.getName().equals(\"s\")) {\n+                                    assertTrue(nameAndType.getType().equals(\"Ljava\/lang\/String;\"));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"}]}