{"files":[{"patch":"@@ -1124,1 +1124,1 @@\n-            } else if (isSubtype(t, s, capture)) {\n+            } else if (isSubtype(t, s, capture, refValSubtypingRelation)) {\n@@ -1178,0 +1178,4 @@\n+        return isSubtype(t, s, capture, isSubtypeRelation);\n+    }\n+\n+    public boolean isSubtype(Type t, Type s, boolean capture, SubtypingRelation typeRelations) {\n@@ -1180,1 +1184,4 @@\n-        if (t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+        if (typeRelations.allowRefValSubtyping() && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+            if (warnStack.head != null && allowUniversalTVars && t.isReferenceProjection() != s.isReferenceProjection()) {\n+                warnStack.head.warn(LintCategory.UNCHECKED);\n+            }\n@@ -1188,1 +1195,1 @@\n-                if (!isSubtype(t, s2, capture))\n+                if (!isSubtype(t, s2, capture, typeRelations))\n@@ -1201,1 +1208,1 @@\n-                return isSubtype(capture ? capture(t) : t, lower, false);\n+                return isSubtype(capture ? capture(t) : t, lower, false, typeRelations);\n@@ -1204,1 +1211,2 @@\n-        return isSubtype.visit(capture ? capture(t) : t, s);\n+        t = capture ? capture(t) : t;\n+        return typeRelations.visit(t, s);\n@@ -1207,2 +1215,10 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        SubtypingRelation isSubtypeRelation = new SubtypingRelation();\n+        class SubtypingRelation extends TypeRelation {\n+            public boolean allowRefValSubtyping() {\n+                return false;\n+            }\n+\n+            TypeRelation containmentRelation() {\n+                return containsType;\n+            }\n+\n@@ -1222,1 +1238,1 @@\n-                     return isSubtypeNoCapture(t.getUpperBound(), s);\n+                     return isSubtype(t.getUpperBound(), s, false, this);\n@@ -1224,3 +1240,0 @@\n-                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n-                         warnStack.head.warn(LintCategory.UNIVERSAL);\n-                     }\n@@ -1240,1 +1253,1 @@\n-            private boolean containsTypeRecursive(Type t, Type s) {\n+            public boolean containsTypeRecursive(Type t, Type s) {\n@@ -1245,1 +1258,1 @@\n-                                            s.getTypeArguments());\n+                                            s.getTypeArguments(), containmentRelation());\n@@ -1251,1 +1264,1 @@\n-                                        rewriteSupers(s).getTypeArguments());\n+                                        rewriteSupers(s).getTypeArguments(), containmentRelation());\n@@ -1255,1 +1268,1 @@\n-            private Type rewriteSupers(Type t) {\n+            protected Type rewriteSupers(Type t) {\n@@ -1350,1 +1363,22 @@\n-        };\n+        }\n+\n+        RefValSubtypingRelation refValSubtypingRelation = new RefValSubtypingRelation();\n+        class RefValSubtypingRelation extends SubtypingRelation {\n+            public boolean allowRefValSubtyping() {\n+                return true;\n+            }\n+\n+            TypeRelation containmentRelation() {\n+                return refValContainsType;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                if (t.getTag() == BOT) {\n+                    if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n+                        warnStack.head.warn(LintCategory.UNIVERSAL);\n+                    }\n+                }\n+                return super.visitType(t, s);\n+            }\n+        }\n@@ -1458,0 +1492,5 @@\n+        return isSameType(t, s, containsType);\n+    }\n+\n+    public boolean isSameType(Type t, Type s, ContainsType containmentRelation) {\n+        isSameTypeVisitor.setContainmentRel(containmentRelation);\n@@ -1466,1 +1505,7 @@\n-        TypeRelation isSameTypeVisitor = new TypeRelation() {\n+        SameTypeVisitor isSameTypeVisitor = new SameTypeVisitor();\n+        class SameTypeVisitor extends TypeRelation {\n+            ContainsType containmentRel = containsType;\n+\n+            public void setContainmentRel(ContainsType containmentRel) {\n+                this.containmentRel = containmentRel;\n+            }\n@@ -1543,1 +1588,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments(), containmentRel);\n@@ -1609,1 +1654,1 @@\n-        };\n+        }\n@@ -1646,0 +1691,4 @@\n+        return containsType(ts, ss, containsType);\n+    }\n+\n+    boolean containsType(List<Type> ts, List<Type> ss, TypeRelation containmentRelation) {\n@@ -1647,1 +1696,1 @@\n-               && containsType(ts.head, ss.head)) {\n+                && containsType(ts.head, ss.head, containmentRelation)) {\n@@ -1680,1 +1729,5 @@\n-        return containsType.visit(t, s);\n+        return containsType(t, s, containsType);\n+    }\n+\n+    public boolean containsType(Type t, Type s, TypeRelation containmentRelation) {\n+        return containmentRelation.visit(t, s);\n@@ -1683,1 +1736,2 @@\n-        private TypeRelation containsType = new TypeRelation() {\n+        private ContainsType containsType = new ContainsType();\n+        class ContainsType extends TypeRelation {\n@@ -1688,1 +1742,1 @@\n-                else\n+                else {\n@@ -1690,0 +1744,1 @@\n+                }\n@@ -1724,1 +1779,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))) &&\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, refValSubtypingRelation))) &&\n@@ -1726,1 +1781,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))));\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, refValSubtypingRelation))));\n@@ -1739,0 +1794,25 @@\n+            @Override\n+            public Boolean visitErrorType(ErrorType t, Type s) {\n+                return true;\n+            }\n+        }\n+\n+        private RefValContainsType refValContainsType = new RefValContainsType();\n+        class RefValContainsType extends ContainsType {\n+\n+            public Boolean visitType(Type t, Type s) {\n+                if (s.isPartial())\n+                    return containedBy(s, t);\n+                else {\n+                    boolean result = isSameType(t, s, this);\n+                    \/\/ the order in the condition below matters\n+                    if (warnStack.head != null && allowUniversalTVars && !result) {\n+                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                        if (result) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n+                    }\n+                    return result;\n+                }\n+            }\n+\n@@ -1743,1 +1823,4 @@\n-                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym)\n+                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        if (warnStack.head != null) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n@@ -1745,0 +1828,1 @@\n+                    }\n@@ -1748,6 +1832,1 @@\n-\n-            @Override\n-            public Boolean visitErrorType(ErrorType t, Type s) {\n-                return true;\n-            }\n-        };\n+        }\n@@ -1769,0 +1848,4 @@\n+        return containsTypeEquivalent(ts, ss, containsType);\n+    }\n+\n+    public boolean containsTypeEquivalent(List<Type> ts, List<Type> ss, TypeRelation containmentRelation) {\n@@ -1770,1 +1853,1 @@\n-               && containsTypeEquivalent(ts.head, ss.head)) {\n+                && containsTypeEquivalent(ts.head, ss.head, containmentRelation)) {\n@@ -3573,1 +3656,1 @@\n-                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes());\n+                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes(), refValContainsType);\n@@ -3643,1 +3726,3 @@\n-                    return to.head.withTypeVar(t);\n+                    return to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ?\n+                            ((TypeVar)to.head).referenceProjection() :\n+                            to.head;\n@@ -4866,0 +4951,4 @@\n+        return containsTypeEquivalent(t, s, refValContainsType);\n+    }\n+\n+    private boolean containsTypeEquivalent(Type t, Type s, TypeRelation containmentRelation) {\n@@ -4867,1 +4956,1 @@\n-            containsType(t, s) && containsType(s, t);\n+                containsType(t, s, containmentRelation) && containsType(s, t, containmentRelation);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":125,"deletions":36,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        \"-Xlint:universal\"\n+        \"-Xlint:all\"\n@@ -81,1 +81,1 @@\n-    public void testWarningNullAssigment() {\n+    public void testWarnings() {\n@@ -111,1 +111,0 @@\n-\n@@ -115,1 +114,0 @@\n-\n@@ -131,0 +129,138 @@\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            val = ref;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            ref = val;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom.ref> f) {}\n+                        void m() {\n+                            Foo<Atom> val = null;\n+                            bar(val);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom> f) {}\n+                        void m() {\n+                            Foo<Atom.ref> ref = null;\n+                            bar(ref);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Wrapper<__universal T> {}\n+                    class Test<__universal T> {\n+                        Wrapper<T.ref> newWrapper() { return null; }\n+                        void m() {\n+                            Wrapper<T> w = newWrapper();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point.ref, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point.ref, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T.ref> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T.ref> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T.ref>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T>> entries = allEntries();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T.ref>> entries = allEntries();\n+                        }\n+                    }\n@@ -132,1 +268,1 @@\n-                    )) {\n+                )) {\n@@ -177,0 +313,7 @@\n+                \"\"\",\n+                \"\"\"\n+                primitive class Atom {}\n+                class Test {\n+                    void bar(Atom f) {}\n+                    void bar(Atom.ref f) {}\n+                }\n@@ -188,1 +331,0 @@\n-\n@@ -195,1 +337,0 @@\n-\n@@ -197,1 +338,0 @@\n-\n@@ -199,1 +339,0 @@\n-\n@@ -208,1 +347,0 @@\n-\n@@ -214,1 +352,0 @@\n-\n@@ -216,1 +353,0 @@\n-\n@@ -218,1 +354,0 @@\n-\n@@ -223,1 +358,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":148,"deletions":14,"binary":false,"changes":162,"status":"modified"}]}