{"files":[{"patch":"@@ -2032,0 +2032,6 @@\n+\n+        public Type withTypeVar(Type t) {\n+            return t.hasTag(TYPEVAR) && t.isReferenceProjection() && t == projection ?\n+                    referenceProjection() :\n+                    this;\n+        }\n@@ -2098,0 +2104,4 @@\n+\n+        public Type withTypeVar(Type t) {\n+            return this;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1181,0 +1181,4 @@\n+            \/\/ warnStack.head is != null if we are checking for an assignment\n+            if (warnStack.head != null && allowUniversalTVars && t.isReferenceProjection() != s.isReferenceProjection()) {\n+                warnStack.head.warn(LintCategory.UNCHECKED);\n+            }\n@@ -1204,1 +1208,2 @@\n-        return isSubtype.visit(capture ? capture(t) : t, s);\n+        t = capture ? capture(t) : t;\n+        return isSubtype.visit(t, s);\n@@ -1688,2 +1693,12 @@\n-                else\n-                    return isSameType(t, s);\n+                else {\n+                    boolean result = isSameType(t, s);\n+                    \/\/ warnStack.head is != null if we are checking for an assignment, in other cases we should be strict\n+                    \/\/ the order in the condition below matters\n+                    if (warnStack.head != null && allowUniversalTVars && !result) {\n+                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                        if (result) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n+                    }\n+                    return result;\n+                }\n@@ -1743,1 +1758,4 @@\n-                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym)\n+                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        if (warnStack.head != null) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n@@ -1745,0 +1763,1 @@\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        \"-Xlint:universal\"\n+        \"-Xlint:all\"\n@@ -81,1 +81,1 @@\n-    public void testWarningNullAssigment() {\n+    public void testWarnings() {\n@@ -111,1 +111,0 @@\n-\n@@ -115,1 +114,0 @@\n-\n@@ -131,0 +129,138 @@\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            val = ref;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            ref = val;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom.ref> f) {}\n+                        void m() {\n+                            Foo<Atom> val = null;\n+                            bar(val);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom> f) {}\n+                        void m() {\n+                            Foo<Atom.ref> ref = null;\n+                            bar(ref);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Wrapper<__universal T> {}\n+                    class Test<__universal T> {\n+                        Wrapper<T.ref> newWrapper() { return null; }\n+                        void m() {\n+                            Wrapper<T> w = newWrapper();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point.ref, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point.ref, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T.ref> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T.ref> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T.ref>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T>> entries = allEntries();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T.ref>> entries = allEntries();\n+                        }\n+                    }\n@@ -132,1 +268,1 @@\n-                    )) {\n+                )) {\n@@ -177,0 +313,7 @@\n+                \"\"\",\n+                \"\"\"\n+                primitive class Atom {}\n+                class Test {\n+                    void bar(Atom f) {}\n+                    void bar(Atom.ref f) {}\n+                }\n@@ -188,1 +331,0 @@\n-\n@@ -195,1 +337,0 @@\n-\n@@ -197,1 +338,0 @@\n-\n@@ -199,1 +339,0 @@\n-\n@@ -208,1 +347,0 @@\n-\n@@ -214,1 +352,0 @@\n-\n@@ -216,1 +353,0 @@\n-\n@@ -218,1 +354,0 @@\n-\n@@ -223,1 +358,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":148,"deletions":14,"binary":false,"changes":162,"status":"modified"}]}