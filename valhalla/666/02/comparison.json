{"files":[{"patch":"@@ -2032,0 +2032,6 @@\n+\n+        public Type withTypeVar(Type t) {\n+            return t.hasTag(TYPEVAR) && t.isReferenceProjection() && t == projection ?\n+                    referenceProjection() :\n+                    this;\n+        }\n@@ -2098,0 +2104,4 @@\n+\n+        public Type withTypeVar(Type t) {\n+            return this;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1124,1 +1124,1 @@\n-            } else if (isSubtype(t, s, capture)) {\n+            } else if (isSubtype(t, s, capture, typeRelationsUnchecked)) {\n@@ -1178,0 +1178,9 @@\n+        return isSubtype(t, s, capture, typeRelations);\n+    }\n+\n+    record TypeRelations(boolean uncheckedAllowed, TypeRelation subtypingRelation, TypeRelation containmentRelation) {}\n+\n+    TypeRelations typeRelations = new TypeRelations(false, new IsSubtypeRelation(), new ContainsType());\n+    TypeRelations typeRelationsUnchecked = new TypeRelations(true, new IsSubtypeUncheckedRelation(), new ContainsTypeUnchecked());\n+\n+    public boolean isSubtype(Type t, Type s, boolean capture, TypeRelations subtypingParameters) {\n@@ -1180,1 +1189,4 @@\n-        if (t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+        if (subtypingParameters.uncheckedAllowed() && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+            if (warnStack.head != null && allowUniversalTVars && t.isReferenceProjection() != s.isReferenceProjection()) {\n+                warnStack.head.warn(LintCategory.UNCHECKED);\n+            }\n@@ -1188,1 +1200,1 @@\n-                if (!isSubtype(t, s2, capture))\n+                if (!isSubtype(t, s2, capture, subtypingParameters))\n@@ -1201,1 +1213,1 @@\n-                return isSubtype(capture ? capture(t) : t, lower, false);\n+                return isSubtype(capture ? capture(t) : t, lower, false, subtypingParameters);\n@@ -1204,1 +1216,2 @@\n-        return isSubtype.visit(capture ? capture(t) : t, s);\n+        t = capture ? capture(t) : t;\n+        return subtypingParameters.subtypingRelation().visit(t, s);\n@@ -1207,2 +1220,5 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        class IsSubtypeRelation extends TypeRelation {\n+            public TypeRelations getTypeRelations() {\n+                return typeRelations;\n+            }\n+\n@@ -1222,1 +1238,1 @@\n-                     return isSubtypeNoCapture(t.getUpperBound(), s);\n+                     return isSubtype(t.getUpperBound(), s, false, getTypeRelations());\n@@ -1224,3 +1240,0 @@\n-                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n-                         warnStack.head.warn(LintCategory.UNIVERSAL);\n-                     }\n@@ -1240,1 +1253,1 @@\n-            private boolean containsTypeRecursive(Type t, Type s) {\n+            public boolean containsTypeRecursive(Type t, Type s) {\n@@ -1255,1 +1268,1 @@\n-            private Type rewriteSupers(Type t) {\n+            protected Type rewriteSupers(Type t) {\n@@ -1350,1 +1363,35 @@\n-        };\n+        }\n+\n+        class IsSubtypeUncheckedRelation extends IsSubtypeRelation {\n+            public TypeRelations getTypeRelations() {\n+                return typeRelationsUnchecked;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                if (t.getTag() == BOT) {\n+                    if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n+                        warnStack.head.warn(LintCategory.UNIVERSAL);\n+                    }\n+                }\n+                return super.visitType(t, s);\n+            }\n+\n+            private Set<TypePair> cache = new HashSet<>();\n+\n+            @Override\n+            public boolean containsTypeRecursive(Type t, Type s) {\n+                TypePair pair = new TypePair(t, s);\n+                if (cache.add(pair)) {\n+                    try {\n+                        return containsType(t.getTypeArguments(),\n+                                s.getTypeArguments(), containsTypeUnchecked);\n+                    } finally {\n+                        cache.remove(pair);\n+                    }\n+                } else {\n+                    return containsType(t.getTypeArguments(),\n+                            rewriteSupers(s).getTypeArguments(), containsTypeUnchecked);\n+                }\n+            }\n+        }\n@@ -1646,0 +1693,4 @@\n+        return containsType(ts, ss, containsType);\n+    }\n+\n+    boolean containsType(List<Type> ts, List<Type> ss, TypeRelation containmentRelation) {\n@@ -1647,1 +1698,1 @@\n-               && containsType(ts.head, ss.head)) {\n+                && containsType(ts.head, ss.head, containmentRelation)) {\n@@ -1680,1 +1731,5 @@\n-        return containsType.visit(t, s);\n+        return containsType(t, s, containsType);\n+    }\n+\n+    public boolean containsType(Type t, Type s, TypeRelation containmentRelation) {\n+        return containmentRelation.visit(t, s);\n@@ -1683,1 +1738,2 @@\n-        private TypeRelation containsType = new TypeRelation() {\n+        private ContainsType containsType = new ContainsType();\n+        class ContainsType extends TypeRelation {\n@@ -1688,1 +1744,1 @@\n-                else\n+                else {\n@@ -1690,0 +1746,1 @@\n+                }\n@@ -1724,1 +1781,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))) &&\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, typeRelationsUnchecked))) &&\n@@ -1726,1 +1783,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))));\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, typeRelationsUnchecked))));\n@@ -1739,0 +1796,26 @@\n+            @Override\n+            public Boolean visitErrorType(ErrorType t, Type s) {\n+                return true;\n+            }\n+        }\n+\n+        private ContainsTypeUnchecked containsTypeUnchecked = new ContainsTypeUnchecked();\n+        class ContainsTypeUnchecked extends ContainsType {\n+\n+            public Boolean visitType(Type t, Type s) {\n+                if (s.isPartial())\n+                    return containedBy(s, t);\n+                else {\n+                    boolean result = isSameType(t, s);\n+                    \/\/ warnStack.head is != null if we are checking for an assignment, in other cases we should be strict\n+                    \/\/ the order in the condition below matters\n+                    if (warnStack.head != null && allowUniversalTVars && !result) {\n+                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                        if (result) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n+                    }\n+                    return result;\n+                }\n+            }\n+\n@@ -1743,1 +1826,4 @@\n-                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym)\n+                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        if (warnStack.head != null) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n@@ -1745,0 +1831,1 @@\n+                    }\n@@ -1748,6 +1835,1 @@\n-\n-            @Override\n-            public Boolean visitErrorType(ErrorType t, Type s) {\n-                return true;\n-            }\n-        };\n+        }\n@@ -4867,1 +4949,1 @@\n-            containsType(t, s) && containsType(s, t);\n+            containsType(t, s, containsTypeUnchecked) && containsType(s, t, containsTypeUnchecked);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":110,"deletions":28,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        \"-Xlint:universal\"\n+        \"-Xlint:all\"\n@@ -81,1 +81,1 @@\n-    public void testWarningNullAssigment() {\n+    public void testWarnings() {\n@@ -111,1 +111,0 @@\n-\n@@ -115,1 +114,0 @@\n-\n@@ -131,0 +129,138 @@\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            val = ref;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            ref = val;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom.ref> f) {}\n+                        void m() {\n+                            Foo<Atom> val = null;\n+                            bar(val);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom> f) {}\n+                        void m() {\n+                            Foo<Atom.ref> ref = null;\n+                            bar(ref);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Wrapper<__universal T> {}\n+                    class Test<__universal T> {\n+                        Wrapper<T.ref> newWrapper() { return null; }\n+                        void m() {\n+                            Wrapper<T> w = newWrapper();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point.ref, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point.ref, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T.ref> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T.ref> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T.ref>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T>> entries = allEntries();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T.ref>> entries = allEntries();\n+                        }\n+                    }\n@@ -132,1 +268,1 @@\n-                    )) {\n+                )) {\n@@ -177,0 +313,7 @@\n+                \"\"\",\n+                \"\"\"\n+                primitive class Atom {}\n+                class Test {\n+                    void bar(Atom f) {}\n+                    void bar(Atom.ref f) {}\n+                }\n@@ -188,1 +331,0 @@\n-\n@@ -195,1 +337,0 @@\n-\n@@ -197,1 +338,0 @@\n-\n@@ -199,1 +339,0 @@\n-\n@@ -208,1 +347,0 @@\n-\n@@ -214,1 +352,0 @@\n-\n@@ -216,1 +353,0 @@\n-\n@@ -218,1 +354,0 @@\n-\n@@ -223,1 +358,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":148,"deletions":14,"binary":false,"changes":162,"status":"modified"}]}