{"files":[{"patch":"@@ -2032,6 +2032,0 @@\n-\n-        public Type withTypeVar(Type t) {\n-            return t.hasTag(TYPEVAR) && t.isReferenceProjection() && t == projection ?\n-                    referenceProjection() :\n-                    this;\n-        }\n@@ -2104,4 +2098,0 @@\n-\n-        public Type withTypeVar(Type t) {\n-            return this;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1124,1 +1124,1 @@\n-            } else if (isSubtype(t, s, capture, typeRelationsUnchecked)) {\n+            } else if (isSubtype(t, s, capture, refValSubtypingRelation)) {\n@@ -1178,1 +1178,1 @@\n-        return isSubtype(t, s, capture, typeRelations);\n+        return isSubtype(t, s, capture, isSubtypeRelation);\n@@ -1181,6 +1181,1 @@\n-    record TypeRelations(boolean uncheckedAllowed, TypeRelation subtypingRelation, TypeRelation containmentRelation) {}\n-\n-    TypeRelations typeRelations = new TypeRelations(false, new IsSubtypeRelation(), new ContainsType());\n-    TypeRelations typeRelationsUnchecked = new TypeRelations(true, new IsSubtypeUncheckedRelation(), new ContainsTypeUnchecked());\n-\n-    public boolean isSubtype(Type t, Type s, boolean capture, TypeRelations typeRelations) {\n+    public boolean isSubtype(Type t, Type s, boolean capture, SubtypingRelation typeRelations) {\n@@ -1189,1 +1184,1 @@\n-        if (typeRelations.uncheckedAllowed() && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+        if (typeRelations.allowRefValSubtyping() && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n@@ -1217,1 +1212,1 @@\n-        return typeRelations.subtypingRelation().visit(t, s);\n+        return typeRelations.visit(t, s);\n@@ -1220,3 +1215,8 @@\n-        class IsSubtypeRelation extends TypeRelation {\n-            public TypeRelations getTypeRelations() {\n-                return typeRelations;\n+        SubtypingRelation isSubtypeRelation = new SubtypingRelation();\n+        class SubtypingRelation extends TypeRelation {\n+            public boolean allowRefValSubtyping() {\n+                return false;\n+            }\n+\n+            TypeRelation containmentRelation() {\n+                return containsType;\n@@ -1238,1 +1238,1 @@\n-                     return isSubtype(t.getUpperBound(), s, false, getTypeRelations());\n+                     return isSubtype(t.getUpperBound(), s, false, this);\n@@ -1258,1 +1258,1 @@\n-                                            s.getTypeArguments());\n+                                            s.getTypeArguments(), containmentRelation());\n@@ -1264,1 +1264,1 @@\n-                                        rewriteSupers(s).getTypeArguments());\n+                                        rewriteSupers(s).getTypeArguments(), containmentRelation());\n@@ -1365,3 +1365,8 @@\n-        class IsSubtypeUncheckedRelation extends IsSubtypeRelation {\n-            public TypeRelations getTypeRelations() {\n-                return typeRelationsUnchecked;\n+        RefValSubtypingRelation refValSubtypingRelation = new RefValSubtypingRelation();\n+        class RefValSubtypingRelation extends SubtypingRelation {\n+            public boolean allowRefValSubtyping() {\n+                return true;\n+            }\n+\n+            TypeRelation containmentRelation() {\n+                return refValContainsType;\n@@ -1379,18 +1384,0 @@\n-\n-            private Set<TypePair> cache = new HashSet<>();\n-\n-            @Override\n-            public boolean containsTypeRecursive(Type t, Type s) {\n-                TypePair pair = new TypePair(t, s);\n-                if (cache.add(pair)) {\n-                    try {\n-                        return containsType(t.getTypeArguments(),\n-                                s.getTypeArguments(), containsTypeUnchecked);\n-                    } finally {\n-                        cache.remove(pair);\n-                    }\n-                } else {\n-                    return containsType(t.getTypeArguments(),\n-                            rewriteSupers(s).getTypeArguments(), containsTypeUnchecked);\n-                }\n-            }\n@@ -1505,0 +1492,5 @@\n+        return isSameType(t, s, containsType);\n+    }\n+\n+    public boolean isSameType(Type t, Type s, ContainsType containmentRelation) {\n+        isSameTypeVisitor.setContainmentRel(containmentRelation);\n@@ -1513,1 +1505,7 @@\n-        TypeRelation isSameTypeVisitor = new TypeRelation() {\n+        SameTypeVisitor isSameTypeVisitor = new SameTypeVisitor();\n+        class SameTypeVisitor extends TypeRelation {\n+            ContainsType containmentRel = containsType;\n+\n+            public void setContainmentRel(ContainsType containmentRel) {\n+                this.containmentRel = containmentRel;\n+            }\n@@ -1590,1 +1588,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments(), containmentRel);\n@@ -1656,1 +1654,1 @@\n-        };\n+        }\n@@ -1781,1 +1779,1 @@\n-                                (t1, s1, w) -> isSubtype(t1, s1, false, typeRelationsUnchecked))) &&\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, refValSubtypingRelation))) &&\n@@ -1783,1 +1781,1 @@\n-                                (t1, s1, w) -> isSubtype(t1, s1, false, typeRelationsUnchecked))));\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, refValSubtypingRelation))));\n@@ -1802,2 +1800,2 @@\n-        private ContainsTypeUnchecked containsTypeUnchecked = new ContainsTypeUnchecked();\n-        class ContainsTypeUnchecked extends ContainsType {\n+        private RefValContainsType refValContainsType = new RefValContainsType();\n+        class RefValContainsType extends ContainsType {\n@@ -1809,2 +1807,1 @@\n-                    boolean result = isSameType(t, s);\n-                    \/\/ warnStack.head is != null if we are checking for an assignment, in other cases we should be strict\n+                    boolean result = isSameType(t, s, this);\n@@ -1851,0 +1848,4 @@\n+        return containsTypeEquivalent(ts, ss, containsType);\n+    }\n+\n+    public boolean containsTypeEquivalent(List<Type> ts, List<Type> ss, TypeRelation containmentRelation) {\n@@ -1852,1 +1853,1 @@\n-               && containsTypeEquivalent(ts.head, ss.head)) {\n+                && containsTypeEquivalent(ts.head, ss.head, containmentRelation)) {\n@@ -3655,1 +3656,1 @@\n-                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes());\n+                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes(), refValContainsType);\n@@ -3725,1 +3726,3 @@\n-                    return to.head.withTypeVar(t);\n+                    return to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ?\n+                            ((TypeVar)to.head).referenceProjection() :\n+                            to.head;\n@@ -4948,0 +4951,4 @@\n+        return containsTypeEquivalent(t, s, refValContainsType);\n+    }\n+\n+    private boolean containsTypeEquivalent(Type t, Type s, TypeRelation containmentRelation) {\n@@ -4949,1 +4956,1 @@\n-            containsType(t, s, containsTypeUnchecked) && containsType(s, t, containsTypeUnchecked);\n+                containsType(t, s, containmentRelation) && containsType(s, t, containmentRelation);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":57,"deletions":50,"binary":false,"changes":107,"status":"modified"}]}