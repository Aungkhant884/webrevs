{"files":[{"patch":"@@ -1124,1 +1124,1 @@\n-            } else if (isSubtype(t, s, capture)) {\n+            } else if (isSubtype(t, s, capture, SubtypingRelationKind.REF_VAL_ALLOWED)) {\n@@ -1178,0 +1178,4 @@\n+        return isSubtype(t, s, capture, SubtypingRelationKind.STRICT);\n+    }\n+\n+    public boolean isSubtype(Type t, Type s, boolean capture, SubtypingRelationKind subtypingKind) {\n@@ -1180,1 +1184,4 @@\n-        if (t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+        if (subtypingKind == SubtypingRelationKind.REF_VAL_ALLOWED && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+            if (warnStack.head != null && allowUniversalTVars && t.isReferenceProjection() != s.isReferenceProjection()) {\n+                warnStack.head.warn(LintCategory.UNCHECKED);\n+            }\n@@ -1188,1 +1195,1 @@\n-                if (!isSubtype(t, s2, capture))\n+                if (!isSubtype(t, s2, capture, subtypingKind))\n@@ -1201,1 +1208,1 @@\n-                return isSubtype(capture ? capture(t) : t, lower, false);\n+                return isSubtype(capture ? capture(t) : t, lower, false, subtypingKind);\n@@ -1204,1 +1211,2 @@\n-        return isSubtype.visit(capture ? capture(t) : t, s);\n+        t = capture ? capture(t) : t;\n+        return isSubtypeRelation.visit(t, s, subtypingKind);\n@@ -1207,2 +1215,25 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        enum SubtypingRelationKind {\n+            STRICT,\n+            REF_VAL_ALLOWED\n+        }\n+\n+        public abstract static class ParameterizedTypeRelation<P> extends TypeRelation {\n+            P param;\n+\n+            public final Boolean visit(Type t, Type s, P param) {\n+                P prevParam = this.param;\n+                try {\n+                    this.param = param;\n+                    return visit(t, s);\n+                } finally {\n+                    this.param = prevParam;\n+                }\n+            }\n+        }\n+\n+        SubtypingRelation isSubtypeRelation = new SubtypingRelation();\n+        class SubtypingRelation extends ParameterizedTypeRelation<SubtypingRelationKind> {\n+            public boolean allowRefValSubtyping() {\n+                return param == SubtypingRelationKind.REF_VAL_ALLOWED;\n+            }\n+\n@@ -1222,1 +1253,1 @@\n-                     return isSubtypeNoCapture(t.getUpperBound(), s);\n+                     return isSubtype(t.getUpperBound(), s, false, param);\n@@ -1224,1 +1255,1 @@\n-                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n+                     if (allowUniversalTVars && allowRefValSubtyping() && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n@@ -1240,1 +1271,1 @@\n-            private boolean containsTypeRecursive(Type t, Type s) {\n+            public boolean containsTypeRecursive(Type t, Type s) {\n@@ -1245,1 +1276,1 @@\n-                                            s.getTypeArguments());\n+                                            s.getTypeArguments(), param);\n@@ -1251,1 +1282,1 @@\n-                                        rewriteSupers(s).getTypeArguments());\n+                                        rewriteSupers(s).getTypeArguments(), param);\n@@ -1255,1 +1286,1 @@\n-            private Type rewriteSupers(Type t) {\n+            protected Type rewriteSupers(Type t) {\n@@ -1350,1 +1381,1 @@\n-        };\n+        }\n@@ -1458,1 +1489,1 @@\n-        return isSameTypeVisitor.visit(t, s);\n+        return isSameType(t, s, SubtypingRelationKind.STRICT);\n@@ -1460,1 +1491,0 @@\n-    \/\/ where\n@@ -1462,0 +1492,4 @@\n+    public boolean isSameType(Type t, Type s, SubtypingRelationKind subtypingKind) {\n+        return isSameTypeVisitor.visit(t, s, subtypingKind);\n+    }\n+    \/\/ where\n@@ -1466,2 +1500,2 @@\n-        TypeRelation isSameTypeVisitor = new TypeRelation() {\n-\n+        SameTypeVisitor isSameTypeVisitor = new SameTypeVisitor();\n+        class SameTypeVisitor extends ParameterizedTypeRelation<SubtypingRelationKind> {\n@@ -1543,1 +1577,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments(), param);\n@@ -1609,1 +1643,1 @@\n-        };\n+        }\n@@ -1646,0 +1680,4 @@\n+        return containsType(ts, ss, SubtypingRelationKind.STRICT);\n+    }\n+\n+    boolean containsType(List<Type> ts, List<Type> ss, SubtypingRelationKind subtypingKind) {\n@@ -1647,1 +1685,1 @@\n-               && containsType(ts.head, ss.head)) {\n+                && containsType(ts.head, ss.head, subtypingKind)) {\n@@ -1680,1 +1718,5 @@\n-        return containsType.visit(t, s);\n+        return containsType(t, s, SubtypingRelationKind.STRICT);\n+    }\n+\n+    public boolean containsType(Type t, Type s, SubtypingRelationKind subtypingKind) {\n+        return containsType.visit(t, s, subtypingKind);\n@@ -1683,1 +1725,2 @@\n-        private TypeRelation containsType = new TypeRelation() {\n+        private ContainsType containsType = new ContainsType();\n+        class ContainsType extends ParameterizedTypeRelation<SubtypingRelationKind> {\n@@ -1688,2 +1731,11 @@\n-                else\n-                    return isSameType(t, s);\n+                else {\n+                    boolean result = isSameType(t, s, param);\n+                    \/\/ the order in the condition below matters\n+                    if (param == SubtypingRelationKind.REF_VAL_ALLOWED &&  warnStack.head != null && allowUniversalTVars && !result) {\n+                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                        if (result) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n+                    }\n+                    return result;\n+                }\n@@ -1724,1 +1776,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))) &&\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED))) &&\n@@ -1726,1 +1778,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))));\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED))));\n@@ -1743,1 +1795,6 @@\n-                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym)\n+                    if (allowUniversalTVars\n+                            && param == SubtypingRelationKind.REF_VAL_ALLOWED\n+                            && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        if (warnStack.head != null) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n@@ -1745,0 +1802,1 @@\n+                    }\n@@ -1753,1 +1811,1 @@\n-        };\n+        }\n@@ -1769,0 +1827,4 @@\n+        return containsTypeEquivalent(ts, ss, SubtypingRelationKind.STRICT);\n+    }\n+\n+    public boolean containsTypeEquivalent(List<Type> ts, List<Type> ss, SubtypingRelationKind subtypingKind) {\n@@ -1770,1 +1832,1 @@\n-               && containsTypeEquivalent(ts.head, ss.head)) {\n+                && containsTypeEquivalent(ts.head, ss.head, subtypingKind)) {\n@@ -3573,1 +3635,1 @@\n-                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes());\n+                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes(), SubtypingRelationKind.REF_VAL_ALLOWED);\n@@ -3643,1 +3705,3 @@\n-                    return to.head.withTypeVar(t);\n+                    return to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ?\n+                            ((TypeVar)to.head).referenceProjection() :\n+                            to.head;\n@@ -4866,0 +4930,4 @@\n+        return containsTypeEquivalent(t, s, SubtypingRelationKind.REF_VAL_ALLOWED);\n+    }\n+\n+    private boolean containsTypeEquivalent(Type t, Type s, SubtypingRelationKind subtypingKind) {\n@@ -4867,1 +4935,1 @@\n-            containsType(t, s) && containsType(s, t);\n+                containsType(t, s, subtypingKind) && containsType(s, t, subtypingKind);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":101,"deletions":33,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        \"-Xlint:universal\"\n+        \"-Xlint:all\"\n@@ -81,1 +81,1 @@\n-    public void testWarningNullAssigment() {\n+    public void testWarnings() {\n@@ -111,1 +111,0 @@\n-\n@@ -115,1 +114,0 @@\n-\n@@ -131,0 +129,138 @@\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            val = ref;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom { }\n+                    class Test {\n+                        void m(Foo<Atom> val, Foo<Atom.ref> ref) {\n+                            ref = val;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom.ref> f) {}\n+                        void m() {\n+                            Foo<Atom> val = null;\n+                            bar(val);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.unchecked.meth.invocation.applied\",\n+                    \"\"\"\n+                    class Foo<__universal X> { }\n+                    primitive class Atom {}\n+                    class Test {\n+                        void bar(Foo<Atom> f) {}\n+                        void m() {\n+                            Foo<Atom.ref> ref = null;\n+                            bar(ref);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Wrapper<__universal T> {}\n+                    class Test<__universal T> {\n+                        Wrapper<T.ref> newWrapper() { return null; }\n+                        void m() {\n+                            Wrapper<T> w = newWrapper();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point.ref, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MyFunction<__universal T, __universal R> {\n+                        R apply(T t);\n+                    }\n+                    primitive class Point {}\n+                    class Color {\n+                        static Color gray() { return new Color(); }\n+                    }\n+                    class Test {\n+                        void plot(MyFunction<Point, Color> f) {}\n+                        void m() {\n+                            MyFunction<Point.ref, Color> gradient = p -> Color.gray();\n+                            plot(gradient);\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T.ref> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySupplier<__universal S> {\n+                        S get();\n+                    }\n+                    class Test<__universal T> {\n+                        void m() {\n+                            MySupplier<? extends T> factory = nullFactory();\n+                        }\n+                        MySupplier<? extends T.ref> nullFactory() { return () -> null; }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T.ref>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T>> entries = allEntries();\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    interface MySet<__universal E> {}\n+                    interface MyMap<__universal K, __universal V> {\n+                        interface Entry<__universal K, __universal V> {}\n+                    }\n+                    class Test<__universal T> {\n+                        MySet<MyMap.Entry<String, T>> allEntries() { return null; }\n+                        void m() {\n+                            MySet<MyMap.Entry<String, T.ref>> entries = allEntries();\n+                        }\n+                    }\n@@ -132,1 +268,1 @@\n-                    )) {\n+                )) {\n@@ -177,0 +313,7 @@\n+                \"\"\",\n+                \"\"\"\n+                primitive class Atom {}\n+                class Test {\n+                    void bar(Atom f) {}\n+                    void bar(Atom.ref f) {}\n+                }\n@@ -188,1 +331,0 @@\n-\n@@ -195,1 +337,0 @@\n-\n@@ -197,1 +338,0 @@\n-\n@@ -199,1 +339,0 @@\n-\n@@ -208,1 +347,0 @@\n-\n@@ -214,1 +352,0 @@\n-\n@@ -216,1 +353,0 @@\n-\n@@ -218,1 +354,0 @@\n-\n@@ -223,1 +358,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":148,"deletions":14,"binary":false,"changes":162,"status":"modified"}]}