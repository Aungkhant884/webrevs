{"files":[{"patch":"@@ -1124,1 +1124,1 @@\n-            } else if (isSubtype(t, s, capture)) {\n+            } else if (isSubtype(t, s, capture, typeRelationsUnchecked)) {\n@@ -1178,0 +1178,9 @@\n+        return isSubtype(t, s, capture, typeRelations);\n+    }\n+\n+    record TypeRelations(boolean uncheckedAllowed, TypeRelation subtypingRelation, TypeRelation containmentRelation) {}\n+\n+    TypeRelations typeRelations = new TypeRelations(false, new IsSubtypeRelation(), new ContainsType());\n+    TypeRelations typeRelationsUnchecked = new TypeRelations(true, new IsSubtypeUncheckedRelation(), new ContainsTypeUnchecked());\n+\n+    public boolean isSubtype(Type t, Type s, boolean capture, TypeRelations subtypingParameters) {\n@@ -1180,2 +1189,1 @@\n-        if (t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n-            \/\/ warnStack.head is != null if we are checking for an assignment\n+        if (subtypingParameters.uncheckedAllowed() && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n@@ -1192,1 +1200,1 @@\n-                if (!isSubtype(t, s2, capture))\n+                if (!isSubtype(t, s2, capture, subtypingParameters))\n@@ -1205,1 +1213,1 @@\n-                return isSubtype(capture ? capture(t) : t, lower, false);\n+                return isSubtype(capture ? capture(t) : t, lower, false, subtypingParameters);\n@@ -1209,1 +1217,1 @@\n-        return isSubtype.visit(t, s);\n+        return subtypingParameters.subtypingRelation().visit(t, s);\n@@ -1212,2 +1220,5 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        class IsSubtypeRelation extends TypeRelation {\n+            public TypeRelations getTypeRelations() {\n+                return typeRelations;\n+            }\n+\n@@ -1227,1 +1238,1 @@\n-                     return isSubtypeNoCapture(t.getUpperBound(), s);\n+                     return isSubtype(t.getUpperBound(), s, false, getTypeRelations());\n@@ -1229,3 +1240,0 @@\n-                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n-                         warnStack.head.warn(LintCategory.UNIVERSAL);\n-                     }\n@@ -1245,1 +1253,1 @@\n-            private boolean containsTypeRecursive(Type t, Type s) {\n+            public boolean containsTypeRecursive(Type t, Type s) {\n@@ -1260,1 +1268,1 @@\n-            private Type rewriteSupers(Type t) {\n+            protected Type rewriteSupers(Type t) {\n@@ -1355,1 +1363,35 @@\n-        };\n+        }\n+\n+        class IsSubtypeUncheckedRelation extends IsSubtypeRelation {\n+            public TypeRelations getTypeRelations() {\n+                return typeRelationsUnchecked;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                if (t.getTag() == BOT) {\n+                    if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n+                        warnStack.head.warn(LintCategory.UNIVERSAL);\n+                    }\n+                }\n+                return super.visitType(t, s);\n+            }\n+\n+            private Set<TypePair> cache = new HashSet<>();\n+\n+            @Override\n+            public boolean containsTypeRecursive(Type t, Type s) {\n+                TypePair pair = new TypePair(t, s);\n+                if (cache.add(pair)) {\n+                    try {\n+                        return containsType(t.getTypeArguments(),\n+                                s.getTypeArguments(), containsTypeUnchecked);\n+                    } finally {\n+                        cache.remove(pair);\n+                    }\n+                } else {\n+                    return containsType(t.getTypeArguments(),\n+                            rewriteSupers(s).getTypeArguments(), containsTypeUnchecked);\n+                }\n+            }\n+        }\n@@ -1651,0 +1693,4 @@\n+        return containsType(ts, ss, containsType);\n+    }\n+\n+    boolean containsType(List<Type> ts, List<Type> ss, TypeRelation containmentRelation) {\n@@ -1652,1 +1698,1 @@\n-               && containsType(ts.head, ss.head)) {\n+                && containsType(ts.head, ss.head, containmentRelation)) {\n@@ -1685,1 +1731,5 @@\n-        return containsType.visit(t, s);\n+        return containsType(t, s, containsType);\n+    }\n+\n+    public boolean containsType(Type t, Type s, TypeRelation containmentRelation) {\n+        return containmentRelation.visit(t, s);\n@@ -1688,1 +1738,2 @@\n-        private TypeRelation containsType = new TypeRelation() {\n+        private ContainsType containsType = new ContainsType();\n+        class ContainsType extends TypeRelation {\n@@ -1694,10 +1745,1 @@\n-                    boolean result = isSameType(t, s);\n-                    \/\/ warnStack.head is != null if we are checking for an assignment, in other cases we should be strict\n-                    \/\/ the order in the condition below matters\n-                    if (warnStack.head != null && allowUniversalTVars && !result) {\n-                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n-                        if (result) {\n-                            warnStack.head.warn(LintCategory.UNCHECKED);\n-                        }\n-                    }\n-                    return result;\n+                    return isSameType(t, s);\n@@ -1739,1 +1781,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))) &&\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, typeRelationsUnchecked))) &&\n@@ -1741,1 +1783,1 @@\n-                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))));\n+                                (t1, s1, w) -> isSubtype(t1, s1, false, typeRelationsUnchecked))));\n@@ -1754,0 +1796,26 @@\n+            @Override\n+            public Boolean visitErrorType(ErrorType t, Type s) {\n+                return true;\n+            }\n+        }\n+\n+        private ContainsTypeUnchecked containsTypeUnchecked = new ContainsTypeUnchecked();\n+        class ContainsTypeUnchecked extends ContainsType {\n+\n+            public Boolean visitType(Type t, Type s) {\n+                if (s.isPartial())\n+                    return containedBy(s, t);\n+                else {\n+                    boolean result = isSameType(t, s);\n+                    \/\/ warnStack.head is != null if we are checking for an assignment, in other cases we should be strict\n+                    \/\/ the order in the condition below matters\n+                    if (warnStack.head != null && allowUniversalTVars && !result) {\n+                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                        if (result) {\n+                            warnStack.head.warn(LintCategory.UNCHECKED);\n+                        }\n+                    }\n+                    return result;\n+                }\n+            }\n+\n@@ -1767,6 +1835,1 @@\n-\n-            @Override\n-            public Boolean visitErrorType(ErrorType t, Type s) {\n-                return true;\n-            }\n-        };\n+        }\n@@ -4886,1 +4949,1 @@\n-            containsType(t, s) && containsType(s, t);\n+            containsType(t, s, containsTypeUnchecked) && containsType(s, t, containsTypeUnchecked);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":100,"deletions":37,"binary":false,"changes":137,"status":"modified"}]}