{"files":[{"patch":"@@ -1241,0 +1241,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-  __ mov(rscratch1, StubRoutines::aarch64::method_entry_barrier());\n+  __ movptr(rscratch1, (uintptr_t) StubRoutines::aarch64::method_entry_barrier());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-  ldr(esp,\n+  ldr(rscratch2,\n@@ -692,0 +692,2 @@\n+    \/\/ look for an overflow into the stack reserved zone, i.e.\n+    \/\/ interpreter_frame_sender_sp <= JavaThread::reserved_stack_activation\n@@ -693,1 +695,1 @@\n-    cmp(esp, rscratch1);\n+    cmp(rscratch2, rscratch1);\n@@ -731,0 +733,3 @@\n+\n+  \/\/ restore sender esp\n+  mov(esp, rscratch2);\n@@ -1815,1 +1820,1 @@\n-      subs(zr, rscratch1, vmIntrinsics::_compiledLambdaForm);\n+      subs(zr, rscratch1, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1468,1 +1468,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1170,1 +1170,2 @@\n-      __ ld4(v0, v1, v2, v3, __ T16B, Address(s, 0));\n+      __ ldpq(v0, v1, Address(s, 0));\n+      __ ldpq(v2, v3, Address(s, 32));\n@@ -1172,1 +1173,2 @@\n-      __ st4(v0, v1, v2, v3, __ T16B, Address(d, 0));\n+      __ stpq(v0, v1, Address(d, 0));\n+      __ stpq(v2, v3, Address(d, 32));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1922,1 +1922,1 @@\n-      cmpwi(CCR1, tmp2, vmIntrinsics::_compiledLambdaForm);\n+      cmpwi(CCR1, tmp2, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1809,1 +1809,1 @@\n-        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, vmIntrinsics::_compiledLambdaForm);\n+        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n@@ -1813,1 +1813,1 @@\n-        z_chi(tmp, vmIntrinsics::_compiledLambdaForm);\n+        z_chi(tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), vmIntrinsics::_compiledLambdaForm);\n+      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -754,0 +754,4 @@\n+void MacroAssembler::reset_last_Java_frame(bool clear_fp) {\n+  reset_last_Java_frame(r15_thread, clear_fp);\n+}\n+\n@@ -2866,4 +2870,0 @@\n-void MacroAssembler::reset_last_Java_frame(bool clear_fp) {\n-  reset_last_Java_frame(r15_thread, clear_fp);\n-}\n-\n@@ -2876,1 +2876,1 @@\n-  movslq(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n+  movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n@@ -2880,1 +2880,1 @@\n-    movslq(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);\n+    movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);\n@@ -2883,2 +2883,2 @@\n-  movslq(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);\n-  movslq(Address(java_thread, JavaThread::saved_rbp_address_offset()), NULL_WORD);\n+  movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);\n+  movptr(Address(java_thread, JavaThread::saved_rbp_address_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-      fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+      fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1308,1 +1308,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n@@ -3012,0 +3012,8 @@\n+\n+BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1904,1 +1904,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1314,3 +1314,4 @@\n-    \/\/ Some defaults for AMD family 17h || Hygon family 18h\n-    if (cpu_family() == 0x17 || cpu_family() == 0x18) {\n-      \/\/ On family 17h processors use XMM and UnalignedLoadStores for Array Copy\n+    \/\/ Some defaults for AMD family >= 17h && Hygon family 18h\n+    if (cpu_family() >= 0x17) {\n+      \/\/ On family >=17h processors use XMM and UnalignedLoadStores\n+      \/\/ for Array Copy\n@@ -1522,0 +1523,8 @@\n+  \/\/ For AMD Processors use XMM\/YMM MOVDQU instructions\n+  \/\/ for Object Initialization as default\n+  if (is_amd() && cpu_family() >= 0x19) {\n+    if (FLAG_IS_DEFAULT(UseFastStosb)) {\n+      UseFastStosb = false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -311,1 +311,6 @@\n-  return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();\n+  return 5 + pre_call_resets_size() + (_leaf_no_fp ? 0 : sizeof_FFree_Float_Stack_All);\n+}\n+\n+int MachCallNativeNode::ret_addr_offset() {\n+  ShouldNotCallThis();\n+  return -1;\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,0 +187,6 @@\n+  \/\/ checks if two CodeSections are disjoint\n+  \/\/\n+  \/\/ limit is an exclusive address and can be the start of another\n+  \/\/ section.\n+  bool disjoint(CodeSection* cs) const { return cs->_limit <= _start || cs->_start >= _limit; }\n+\n@@ -495,1 +501,1 @@\n-    verify_section_allocation();\n+    debug_only(verify_section_allocation();)\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4526,1 +4526,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3937,1 +3937,1 @@\n-    if (_method->has_option_value(\"CompileThresholdScaling\", scale)) {\n+    if (_method->has_option_value(CompileCommand::CompileThresholdScaling, scale)) {\n@@ -3978,1 +3978,1 @@\n-  if (_method->has_option_value(\"CompileThresholdScaling\", scale)) {\n+  if (_method->has_option_value(CompileCommand::CompileThresholdScaling, scale)) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1125,1 +1125,1 @@\n-      tty->print_cr(\"Eliminated Intrinsic %d's null check for value %d\", x->id(), recv->id());\n+      tty->print_cr(\"Eliminated Intrinsic %d's null check for value %d\", vmIntrinsics::as_int(x->id()), recv->id());\n@@ -1131,1 +1131,1 @@\n-      tty->print_cr(\"Intrinsic %d of value %d proves value to be non-null\", x->id(), recv->id());\n+      tty->print_cr(\"Intrinsic %d of value %d proves value to be non-null\", vmIntrinsics::as_int(x->id()), recv->id());\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-bool ciMethod::has_option(const char* option) {\n+bool ciMethod::has_option(enum CompileCommand option) {\n@@ -1097,1 +1097,1 @@\n-  return CompilerOracle::has_option_string(mh, option);\n+  return CompilerOracle::has_option(mh, option);\n@@ -1103,1 +1103,1 @@\n-bool ciMethod::has_option_value(const char* option, double& value) {\n+bool ciMethod::has_option_value(enum CompileCommand option, double& value) {\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -300,2 +300,2 @@\n-  bool has_option(const char *option);\n-  bool has_option_value(const char* option, double& value);\n+  bool has_option(enum CompileCommand option);\n+  bool has_option_value(enum CompileCommand option, double& value);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5544,1 +5544,2 @@\n-      for (int id = vmIntrinsics::FIRST_ID; id < (int)vmIntrinsics::ID_LIMIT; ++id) {\n+      for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+        vmIntrinsicID id = *it;\n@@ -5552,1 +5553,1 @@\n-        if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {\n+        if (vmIntrinsics::class_for(id) == klass_id) {\n@@ -5568,2 +5569,1 @@\n-                        vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),\n-                                                             buf, sizeof(buf)),\n+                        vmIntrinsics::short_name_as_C_string(id, buf, sizeof(buf)),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2612,1 +2612,1 @@\n-Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,\n+Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsicID iid,\n@@ -2616,0 +2616,1 @@\n+  const int iid_as_int = vmIntrinsics::as_int(iid);\n@@ -2619,1 +2620,1 @@\n-         \"must be a known MH intrinsic iid=%d: %s\", iid, vmIntrinsics::name_at(iid));\n+         \"must be a known MH intrinsic iid=%d: %s\", iid_as_int, vmIntrinsics::name_at(iid));\n@@ -2621,1 +2622,1 @@\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid);\n+  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid_as_int);\n@@ -2623,1 +2624,1 @@\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid);\n+  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n@@ -2642,1 +2643,1 @@\n-      spe = invoke_method_table()->find_entry(index, hash, signature, iid);\n+      spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n@@ -2644,1 +2645,1 @@\n-        spe = invoke_method_table()->add_entry(index, hash, signature, iid);\n+        spe = invoke_method_table()->add_entry(index, hash, signature, iid_as_int);\n@@ -2795,1 +2796,1 @@\n-  vmIntrinsics::ID null_iid = vmIntrinsics::_none;  \/\/ distinct from all method handle invoker intrinsics\n+  int null_iid = vmIntrinsics::as_int(vmIntrinsics::_none);  \/\/ distinct from all method handle invoker intrinsics\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -477,1 +478,1 @@\n-  static Method* find_method_handle_intrinsic(vmIntrinsics::ID iid,\n+  static Method* find_method_handle_intrinsic(vmIntrinsicID iid,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -573,2 +573,2 @@\n-static const char* vm_intrinsic_name_table[vmIntrinsics::ID_LIMIT];\n-static TriBoolArray<vmIntrinsics::ID_LIMIT, int> vm_intrinsic_control_words;\n+static const char* vm_intrinsic_name_table[vmIntrinsics::number_of_intrinsics()];\n+static TriBoolArray<(size_t)vmIntrinsics::number_of_intrinsics(), int> vm_intrinsic_control_words;\n@@ -576,1 +576,1 @@\n-static void init_vm_intrinsic_name_table() {\n+void vmIntrinsics::init_vm_intrinsic_name_table() {\n@@ -579,2 +579,4 @@\n-  for (int index = vmIntrinsics::FIRST_ID; index < vmIntrinsics::ID_LIMIT; index++) {\n-    nt[index] = string;\n+\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID index = *it;\n+    nt[as_int(index)] = string;\n@@ -584,2 +586,2 @@\n-  assert(!strcmp(nt[vmIntrinsics::_hashCode], \"_hashCode\"), \"lined up\");\n-  nt[vmIntrinsics::_none] = \"_none\";\n+  assert(!strcmp(nt[as_int(vmIntrinsics::_hashCode)], \"_hashCode\"), \"lined up\");\n+  nt[as_int(vmIntrinsics::_none)] = \"_none\";\n@@ -590,1 +592,1 @@\n-  if (nt[_none] == NULL) {\n+  if (nt[as_int(_none)] == NULL) {\n@@ -594,2 +596,2 @@\n-  if ((uint)id < (uint)ID_LIMIT)\n-    return vm_intrinsic_name_table[(uint)id];\n+  if (id < ID_LIMIT)\n+    return vm_intrinsic_name_table[as_int(id)];\n@@ -602,1 +604,1 @@\n-  if (nt[_none] == NULL) {\n+  if (nt[as_int(_none)] == NULL) {\n@@ -606,3 +608,4 @@\n-  for (int index = FIRST_ID; index < ID_LIMIT; ++index) {\n-    if (0 == strcmp(name, nt[index])) {\n-      return ID_from(index);\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID index = *it;\n+    if (0 == strcmp(name, nt[as_int(index)])) {\n+      return index;\n@@ -624,1 +627,1 @@\n-  if (vm_intrinsic_control_words[_none].is_default()) {\n+  if (vm_intrinsic_control_words[as_int(_none)].is_default()) {\n@@ -629,1 +632,1 @@\n-        vm_intrinsic_control_words[id] = iter.is_enabled() && !disabled_by_jvm_flags(id);\n+        vm_intrinsic_control_words[as_int(id)] = iter.is_enabled() && !disabled_by_jvm_flags(id);\n@@ -638,1 +641,1 @@\n-        vm_intrinsic_control_words[id] = false;\n+        vm_intrinsic_control_words[as_int(id)] = false;\n@@ -642,1 +645,1 @@\n-    vm_intrinsic_control_words[_none] = true;\n+    vm_intrinsic_control_words[as_int(_none)] = true;\n@@ -645,1 +648,1 @@\n-  TriBool b = vm_intrinsic_control_words[id];\n+  TriBool b = vm_intrinsic_control_words[as_int(id)];\n@@ -648,1 +651,1 @@\n-    b = vm_intrinsic_control_words[id] = !disabled_by_jvm_flags(id);\n+    b = vm_intrinsic_control_words[as_int(id)] = !disabled_by_jvm_flags(id);\n@@ -713,1 +716,1 @@\n-static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {\n+static const jlong intrinsic_info_array[vmIntrinsics::number_of_intrinsics()+1] = {\n@@ -719,1 +722,1 @@\n-    0\n+  0\n@@ -724,1 +727,1 @@\n-  return intrinsic_info_array[vmIntrinsics::ID_from((int)id)];\n+  return intrinsic_info_array[vmIntrinsics::as_int(id)];\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -393,0 +394,2 @@\n+  do_intrinsic(_Reference_refersTo0,     java_lang_ref_Reference, refersTo0_name, object_boolean_signature, F_R)        \\\n+  do_intrinsic(_PhantomReference_refersTo0, java_lang_ref_PhantomReference, refersTo0_name, object_boolean_signature, F_R) \\\n@@ -1025,0 +1028,7 @@\n+#define VM_INTRINSIC_ID_ENUM(id, klass, name, sig, flags)  id,\n+#define VM_INTRINSICS_CONST(id, klass, name, sig, flags)   static const vmIntrinsicID id = vmIntrinsicID::id;\n+#define __IGNORE_CLASS(id, name)                      \/*ignored*\/\n+#define __IGNORE_NAME(id, name)                       \/*ignored*\/\n+#define __IGNORE_SIGNATURE(id, name)                  \/*ignored*\/\n+#define __IGNORE_ALIAS(id, name)                      \/*ignored*\/\n+\n@@ -1026,0 +1036,20 @@\n+enum class vmIntrinsicID : int {\n+  _none = 0,                      \/\/ not an intrinsic (default answer)\n+\n+  VM_INTRINSICS_DO(VM_INTRINSIC_ID_ENUM,\n+                   __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n+\n+  ID_LIMIT,\n+  LAST_COMPILER_INLINE = _VectorScatterOp,\n+  FIRST_MH_SIG_POLY    = _invokeGeneric,\n+  FIRST_MH_STATIC      = _linkToVirtual,\n+  LAST_MH_SIG_POLY     = _linkToNative,\n+\n+  FIRST_ID = _none + 1,\n+  LAST_ID = ID_LIMIT - 1,\n+};\n+\n+ENUMERATOR_RANGE(vmIntrinsicID, vmIntrinsicID::FIRST_ID, vmIntrinsicID::LAST_ID)\n+constexpr EnumRange<vmIntrinsicID> vmIntrinsicsRange; \/\/ the default range of all valid vmIntrinsicIDs\n+using vmIntrinsicsIterator = EnumIterator<vmIntrinsicID>; \/\/ convenience\n+\n@@ -1031,9 +1061,1 @@\n-  \/\/ Accessing\n-  enum ID {\n-    _none = 0,                      \/\/ not an intrinsic (default answer)\n-\n-    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n-    #define __IGNORE_CLASS(id, name)                      \/*ignored*\/\n-    #define __IGNORE_NAME(id, name)                       \/*ignored*\/\n-    #define __IGNORE_SIGNATURE(id, name)                  \/*ignored*\/\n-    #define __IGNORE_ALIAS(id, name)                      \/*ignored*\/\n+  typedef vmIntrinsicID ID;\n@@ -1041,7 +1063,8 @@\n-    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n-                     __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n-    #undef VM_INTRINSIC_ENUM\n-    #undef __IGNORE_CLASS\n-    #undef __IGNORE_NAME\n-    #undef __IGNORE_SIGNATURE\n-    #undef __IGNORE_ALIAS\n+  \/\/ Convenient access of vmIntrinsicID::FOO as vmIntrinsics::FOO\n+  static const ID _none                = vmIntrinsicID::_none;\n+  static const ID ID_LIMIT             = vmIntrinsicID::ID_LIMIT;\n+  static const ID LAST_COMPILER_INLINE = vmIntrinsicID::LAST_COMPILER_INLINE;\n+  static const ID FIRST_MH_SIG_POLY    = vmIntrinsicID::FIRST_MH_SIG_POLY;\n+  static const ID FIRST_MH_STATIC      = vmIntrinsicID::FIRST_MH_STATIC;\n+  static const ID LAST_MH_SIG_POLY     = vmIntrinsicID::LAST_MH_SIG_POLY;\n+  static const ID FIRST_ID             = vmIntrinsicID::FIRST_ID;\n@@ -1049,8 +1072,2 @@\n-    ID_LIMIT,\n-    LAST_COMPILER_INLINE = _VectorScatterOp,\n-    FIRST_MH_SIG_POLY    = _invokeGeneric,\n-    FIRST_MH_STATIC      = _linkToVirtual,\n-    LAST_MH_SIG_POLY     = _linkToNative,\n-\n-    FIRST_ID = _none + 1\n-  };\n+  VM_INTRINSICS_DO(VM_INTRINSICS_CONST,\n+                   __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n@@ -1073,0 +1090,14 @@\n+\n+  \/\/ Convert an arbitrary vmIntrinsicID to int (checks validity):\n+  \/\/    vmIntrinsicID x = ...; int n = vmIntrinsics::as_int(x);\n+  \/\/ Convert a known vmIntrinsicID to int (no need for validity check):\n+  \/\/    int n = static_cast<int>(vmIntrinsicID::_invokeGeneric);\n+  static constexpr int as_int(vmIntrinsicID id) {\n+    assert(is_valid_id(id), \"must be\");\n+    return static_cast<int>(id);\n+  }\n+\n+  static constexpr int number_of_intrinsics() {\n+    return static_cast<int>(ID_LIMIT);\n+  }\n+\n@@ -1074,4 +1105,11 @@\n-  static ID ID_from(int raw_id) {\n-    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n-           \"must be a valid intrinsic ID\");\n-    return (ID)raw_id;\n+  static constexpr bool is_valid_id(int raw_id) {\n+    return (raw_id >= static_cast<int>(_none) && raw_id < static_cast<int>(ID_LIMIT));\n+  }\n+\n+  static constexpr bool is_valid_id(ID id) {\n+    return is_valid_id(static_cast<int>(id));\n+  }\n+\n+  static constexpr ID ID_from(int raw_id) {\n+    assert(is_valid_id(raw_id), \"must be a valid intrinsic ID\");\n+    return static_cast<ID>(raw_id);\n@@ -1090,0 +1128,1 @@\n+  static void init_vm_intrinsic_name_table();\n@@ -1155,0 +1194,7 @@\n+#undef VM_INTRINSIC_ENUM\n+#undef VM_INTRINSICS_CONST\n+#undef __IGNORE_CLASS\n+#undef __IGNORE_NAME\n+#undef __IGNORE_SIGNATURE\n+#undef __IGNORE_ALIAS\n+\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":74,"deletions":28,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -399,0 +399,1 @@\n+  template(refersTo0_name,                            \"refersTo0\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1002,1 +1002,1 @@\n-    if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(mh, \"PrintDebugInfo\")) {\n+    if (printmethod || PrintDebugInfo || CompilerOracle::has_option(mh, CompileCommand::PrintDebugInfo)) {\n@@ -1006,1 +1006,1 @@\n-    if (printmethod || PrintRelocations || CompilerOracle::has_option_string(mh, \"PrintRelocations\")) {\n+    if (printmethod || PrintRelocations || CompilerOracle::has_option(mh, CompileCommand::PrintRelocations)) {\n@@ -1010,1 +1010,1 @@\n-    if (printmethod || PrintDependencies || CompilerOracle::has_option_string(mh, \"PrintDependencies\")) {\n+    if (printmethod || PrintDependencies || CompilerOracle::has_option(mh, CompileCommand::PrintDependencies)) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1588,2 +1588,2 @@\n-  if (excluded || (CompilerOracle::has_option_value(method, \"CompileThresholdScaling\", scale) && scale == 0)) {\n-    bool quietly = CompilerOracle::should_exclude_quietly();\n+  if (excluded || (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, scale) && scale == 0)) {\n+    bool quietly = CompilerOracle::be_quiet();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -607,0 +607,1 @@\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n@@ -608,0 +609,1 @@\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n@@ -621,2 +623,2 @@\n-  bool need_read_barrier = in_heap && (on_weak ||\n-                                       (unknown && offset != top && obj != top));\n+  bool need_read_barrier = (((on_weak || on_phantom) && !no_keepalive) ||\n+                            (in_heap && unknown && offset != top && obj != top));\n@@ -632,1 +634,1 @@\n-  if (on_weak) {\n+  if (on_weak || on_phantom) {\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -998,3 +998,7 @@\n-    assert(!is_narrow, \"phantom access cannot be narrow\");\n-    calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom);\n-    name = \"load_reference_barrier_phantom\";\n+    if (is_narrow) {\n+      calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom_narrow);\n+      name = \"load_reference_barrier_phantom_narrow\";\n+    } else {\n+      calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom);\n+      name = \"load_reference_barrier_phantom\";\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,2 +67,1 @@\n-    if (mach->barrier_data() != ZLoadBarrierStrong &&\n-        mach->barrier_data() != ZLoadBarrierWeak) {\n+    if (mach->barrier_data() == ZLoadBarrierElided) {\n@@ -87,2 +86,2 @@\n-ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) {\n-  ZLoadBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZLoadBarrierStubC2(node, ref_addr, ref, tmp, weak);\n+ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n+  ZLoadBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZLoadBarrierStubC2(node, ref_addr, ref, tmp, barrier_data);\n@@ -96,1 +95,1 @@\n-ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) :\n+ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) :\n@@ -101,1 +100,1 @@\n-    _weak(weak),\n+    _barrier_data(barrier_data),\n@@ -121,1 +120,13 @@\n-  const DecoratorSet decorators = _weak ? ON_WEAK_OOP_REF : ON_STRONG_OOP_REF;\n+  DecoratorSet decorators = DECORATORS_NONE;\n+  if (_barrier_data & ZLoadBarrierStrong) {\n+    decorators |= ON_STRONG_OOP_REF;\n+  }\n+  if (_barrier_data & ZLoadBarrierWeak) {\n+    decorators |= ON_WEAK_OOP_REF;\n+  }\n+  if (_barrier_data & ZLoadBarrierPhantom) {\n+    decorators |= ON_PHANTOM_OOP_REF;\n+  }\n+  if (_barrier_data & ZLoadBarrierNoKeepalive) {\n+    decorators |= AS_NO_KEEPALIVE;\n+  }\n@@ -321,0 +332,8 @@\n+        if ((mach->barrier_data() & ZLoadBarrierStrong) != 0) {\n+          barrier_loads.push(mach);\n+        }\n+        if ((mach->barrier_data() & (ZLoadBarrierStrong | ZLoadBarrierNoKeepalive)) ==\n+            ZLoadBarrierStrong) {\n+          mem_ops.push(mach);\n+        }\n+        break;\n@@ -324,1 +343,1 @@\n-        if (mach->barrier_data() == ZLoadBarrierStrong) {\n+        if ((mach->barrier_data() & ZLoadBarrierStrong) != 0) {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -68,2 +69,2 @@\n-                                                                   + (vmIntrinsics::LAST_MH_SIG_POLY\n-                                                                      - vmIntrinsics::FIRST_MH_SIG_POLY)),\n+                                                                   + (static_cast<int>(vmIntrinsics::LAST_MH_SIG_POLY)\n+                                                                      - static_cast<int>(vmIntrinsics::FIRST_MH_SIG_POLY))),\n@@ -98,1 +99,1 @@\n-      return (vmIntrinsics::ID)( vmIntrinsics::FIRST_MH_SIG_POLY + (kind - method_handle_invoke_FIRST) );\n+      return vmIntrinsics::ID_from(static_cast<int>(vmIntrinsics::FIRST_MH_SIG_POLY) + (kind - method_handle_invoke_FIRST));\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1722,1 +1722,1 @@\n-  assert(_intrinsic_id == vmIntrinsics::_none, \"do this just once\");\n+  assert(_intrinsic_id == static_cast<int>(vmIntrinsics::_none), \"do this just once\");\n@@ -2449,1 +2449,1 @@\n-    st->print_cr(\" - intrinsic id:      %d %s\", intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));\n+    st->print_cr(\" - intrinsic id:      %d %s\", vmIntrinsics::as_int(intrinsic_id()), vmIntrinsics::name_at(intrinsic_id()));\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n@@ -796,1 +795,1 @@\n-  static methodHandle make_method_handle_intrinsic(vmIntrinsics::ID iid, \/\/ _invokeBasic, _linkToVirtual\n+  static methodHandle make_method_handle_intrinsic(vmIntrinsicID iid, \/\/ _invokeBasic, _linkToVirtual\n@@ -893,2 +892,2 @@\n-  vmIntrinsics::ID intrinsic_id() const          { return (vmIntrinsics::ID) _intrinsic_id;           }\n-  void     set_intrinsic_id(vmIntrinsics::ID id) {                           _intrinsic_id = (u2) id; }\n+  vmIntrinsicID intrinsic_id() const          { return (vmIntrinsicID) _intrinsic_id;           }\n+  void     set_intrinsic_id(vmIntrinsicID id) {                           _intrinsic_id = (u2) id; }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1336,1 +1336,1 @@\n-  CompilerOracle::has_option_value(mh, \"CompileThresholdScaling\", scale);\n+  CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n@@ -1353,2 +1353,2 @@\n-      !CompilerOracle::has_option_string(mh, \"NoRTMLockEliding\")) {\n-    if (CompilerOracle::has_option_string(mh, \"UseRTMLockEliding\") || !UseRTMDeopt) {\n+      !CompilerOracle::has_option(mh, CompileCommand::NoRTMLockEliding)) {\n+    if (CompilerOracle::has_option(mh, CompileCommand::UseRTMLockEliding) || !UseRTMDeopt) {\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+  const Type *t1 = phase->type(in(1));\n+  const Type *t2 = phase->type(in(2));\n@@ -118,1 +118,1 @@\n-  if( commute(this,con_left,con_right) ) return this;\n+  if (commute(this, con_left, con_right)) return this;\n@@ -129,2 +129,2 @@\n-  if( con_right && t2 != Type::TOP && \/\/ Right input is a constant?\n-      add1_op == this_op ) { \/\/ Left input is an Add?\n+  if (con_right && t2 != Type::TOP && \/\/ Right input is a constant?\n+      add1_op == this_op) { \/\/ Left input is an Add?\n@@ -133,2 +133,2 @@\n-    const Type *t12 = phase->type( add1->in(2) );\n-    if( t12->singleton() && t12 != Type::TOP ) { \/\/ Left input is an add of a constant?\n+    const Type *t12 = phase->type(add1->in(2));\n+    if (t12->singleton() && t12 != Type::TOP) { \/\/ Left input is an add of a constant?\n@@ -140,2 +140,2 @@\n-      if( (add1 == add1->in(1))\n-         || (add11_op == this_op && add11->in(1) == add1) ) {\n+      if ((add1 == add1->in(1))\n+          || (add11_op == this_op && add11->in(1) == add1)) {\n@@ -147,1 +147,1 @@\n-      Node *x2 = phase->makecon( add1->as_Add()->add_ring( t2, t12 ));\n+      Node *x2 = phase->makecon(add1->as_Add()->add_ring(t2, t12));\n@@ -149,1 +149,1 @@\n-      if( igvn ) {\n+      if (igvn) {\n@@ -163,1 +163,1 @@\n-  if( add1_op == this_op && !con_right ) {\n+  if (add1_op == this_op && !con_right) {\n@@ -166,2 +166,2 @@\n-    if( t12->singleton() && t12 != Type::TOP && (add1 != add1->in(1)) &&\n-       !(add1->in(1)->is_Phi() && add1->in(1)->as_Phi()->is_tripcount()) ) {\n+    if (t12->singleton() && t12 != Type::TOP && (add1 != add1->in(1)) &&\n+        !(add1->in(1)->is_Phi() && (add1->in(1)->as_Phi()->is_tripcount(T_INT) || add1->in(1)->as_Phi()->is_tripcount(T_LONG)))) {\n@@ -181,1 +181,1 @@\n-  if( add2_op == this_op && !con_left ) {\n+  if (add2_op == this_op && !con_left) {\n@@ -184,2 +184,2 @@\n-    if( t22->singleton() && t22 != Type::TOP && (add2 != add2->in(1)) &&\n-       !(add2->in(1)->is_Phi() && add2->in(1)->as_Phi()->is_tripcount()) ) {\n+    if (t22->singleton() && t22 != Type::TOP && (add2 != add2->in(1)) &&\n+        !(add2->in(1)->is_Phi() && (add2->in(1)->as_Phi()->is_tripcount(T_INT) || add2->in(1)->as_Phi()->is_tripcount(T_LONG)))) {\n@@ -238,0 +238,11 @@\n+AddNode* AddNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new AddINode(in1, in2);\n+    case T_LONG:\n+      return new AddLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n@@ -922,0 +933,8 @@\n+  Node* hook = NULL;\n+  if (gvn.is_IterGVN()) {\n+    \/\/ Make sure a and b are not destroyed\n+    hook = new Node(2);\n+    hook->init_req(0, a);\n+    hook->init_req(1, b);\n+  }\n+  Node* res = NULL;\n@@ -925,1 +944,1 @@\n-        Node* res =  gvn.transform(new MaxINode(a, b));\n+        res =  gvn.transform(new MaxINode(a, b));\n@@ -927,1 +946,0 @@\n-        return res;\n@@ -931,1 +949,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -937,1 +955,0 @@\n-        return res;\n@@ -941,1 +958,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -949,1 +966,1 @@\n-        return gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n+        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n@@ -953,1 +970,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -959,1 +976,1 @@\n-        return gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n+        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n@@ -963,1 +980,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -967,0 +984,4 @@\n+  if (hook != NULL) {\n+    hook->destruct(&gvn);\n+  }\n+  return res;\n@@ -979,0 +1000,8 @@\n+  Node* hook = NULL;\n+  if (gvn.is_IterGVN()) {\n+    \/\/ Make sure a and b are not destroyed\n+    hook = new Node(2);\n+    hook->init_req(0, a);\n+    hook->init_req(1, b);\n+  }\n+  Node* res = NULL;\n@@ -984,1 +1013,1 @@\n-      return gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n+      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n@@ -989,1 +1018,1 @@\n-      return gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n+      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n@@ -996,1 +1025,1 @@\n-      return gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n+      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n@@ -1001,1 +1030,1 @@\n-      return gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n+      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n@@ -1004,0 +1033,4 @@\n+  if (hook != NULL) {\n+    hook->destruct(&gvn);\n+  }\n+  return res;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":63,"deletions":30,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -621,0 +621,2 @@\n+  case vmIntrinsics::_Reference_refersTo0:\n+  case vmIntrinsics::_PhantomReference_refersTo0:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1156,1 +1156,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -893,0 +893,1 @@\n+    init_class_id(Class_CallLeafNoFP);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -90,0 +94,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -102,0 +110,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1095,1 +1095,1 @@\n-  CountedLoopNode* l = r->is_CountedLoop() ? r->as_CountedLoop() : NULL;\n+  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : NULL;\n@@ -1099,2 +1099,2 @@\n-      const Node *init   = l->init_trip();\n-      const Node *limit  = l->limit();\n+      const Node* init = l->init_trip();\n+      const Node* limit = l->limit();\n@@ -1103,3 +1103,3 @@\n-        const TypeInt* lo = phase->type(init)->isa_int();\n-        const TypeInt* hi = phase->type(limit)->isa_int();\n-        const TypeInt* stride_t = phase->type(stride)->isa_int();\n+        const TypeInteger* lo = phase->type(init)->isa_integer(l->bt());\n+        const TypeInteger* hi = phase->type(limit)->isa_integer(l->bt());\n+        const TypeInteger* stride_t = phase->type(stride)->isa_integer(l->bt());\n@@ -1107,1 +1107,1 @@\n-          assert(stride_t->_hi >= stride_t->_lo, \"bad stride type\");\n+          assert(stride_t->hi_as_long() >= stride_t->lo_as_long(), \"bad stride type\");\n@@ -1114,1 +1114,1 @@\n-            if (stride_t->_hi < 0) {          \/\/ Down-counter loop\n+            if (stride_t->hi_as_long() < 0) {          \/\/ Down-counter loop\n@@ -1116,3 +1116,5 @@\n-              return TypeInt::make(MIN2(lo->_lo, hi->_lo) , hi->_hi, 3)->filter_speculative(_type);\n-            } else if (stride_t->_lo >= 0) {\n-              return TypeInt::make(lo->_lo, MAX2(lo->_hi, hi->_hi), 3)->filter_speculative(_type);\n+              return TypeInteger::make(MIN2(lo->lo_as_long(), hi->lo_as_long()), hi->hi_as_long(), 3,\n+                                       l->bt())->filter_speculative(_type);\n+            } else if (stride_t->lo_as_long() >= 0) {\n+              return TypeInteger::make(lo->lo_as_long(), MAX2(lo->hi_as_long(), hi->hi_as_long()), 3,\n+                                       l->bt())->filter_speculative(_type);\n@@ -2487,3 +2489,4 @@\n-bool PhiNode::is_tripcount() const {\n-  return (in(0) != NULL && in(0)->is_CountedLoop() &&\n-          in(0)->as_CountedLoop()->phi() == this);\n+bool PhiNode::is_tripcount(BasicType bt) const {\n+  return (in(0) != NULL && in(0)->is_BaseCountedLoop() &&\n+          in(0)->as_BaseCountedLoop()->operates_on(bt, true) &&\n+          in(0)->as_BaseCountedLoop()->phi() == this);\n@@ -2516,1 +2519,1 @@\n-  if (is_tripcount()) {\n+  if (is_tripcount(T_INT) || is_tripcount(T_LONG)) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  bool is_tripcount() const;\n+  bool is_tripcount(BasicType bt) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+macro(LongCountedLoop)\n+macro(LongCountedLoopEnd)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,2 +173,6 @@\n-juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};\n-jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};\n+juint  Compile::_intrinsic_hist_count[vmIntrinsics::number_of_intrinsics()] = {0};\n+jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::number_of_intrinsics()] = {0};\n+\n+inline int as_int(vmIntrinsics::ID id) {\n+  return vmIntrinsics::as_int(id);\n+}\n@@ -178,1 +182,1 @@\n-  int oflags = _intrinsic_hist_flags[id];\n+  int oflags = _intrinsic_hist_flags[as_int(id)];\n@@ -185,1 +189,1 @@\n-    juint count = (_intrinsic_hist_count[id] += 1);\n+    juint count = (_intrinsic_hist_count[as_int(id)] += 1);\n@@ -190,1 +194,1 @@\n-    _intrinsic_hist_count[vmIntrinsics::_none] += 1;\n+    _intrinsic_hist_count[as_int(vmIntrinsics::_none)] += 1;\n@@ -206,1 +210,1 @@\n-    _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);\n+    _intrinsic_hist_flags[as_int(id)] = (jubyte) (oflags | flags);\n@@ -209,1 +213,1 @@\n-  _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;\n+  _intrinsic_hist_flags[as_int(vmIntrinsics::_none)] |= (jubyte) flags;\n@@ -230,1 +234,1 @@\n-  juint total = _intrinsic_hist_count[vmIntrinsics::_none];\n+  juint total = _intrinsic_hist_count[as_int(vmIntrinsics::_none)];\n@@ -234,4 +238,4 @@\n-  for (int index = 1 + (int)vmIntrinsics::_none; index < (int)vmIntrinsics::ID_LIMIT; index++) {\n-    vmIntrinsics::ID id = (vmIntrinsics::ID) index;\n-    int   flags = _intrinsic_hist_flags[id];\n-    juint count = _intrinsic_hist_count[id];\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID id = *it;\n+    int   flags = _intrinsic_hist_flags[as_int(id)];\n+    juint count = _intrinsic_hist_count[as_int(id)];\n@@ -242,1 +246,1 @@\n-  PRINT_STAT_LINE(\"total\", total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));\n+  PRINT_STAT_LINE(\"total\", total, format_flags(_intrinsic_hist_flags[as_int(vmIntrinsics::_none)], flagsbuf));\n@@ -257,1 +261,1 @@\n-  if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {\n+  if (_intrinsic_hist_flags[as_int(vmIntrinsics::_none)] != 0) {\n@@ -964,1 +968,1 @@\n-    if (method_has_option(\"NoRTMLockEliding\") || ((rtm_state & NoRTM) != 0)) {\n+    if (method_has_option(CompileCommand::NoRTMLockEliding) || ((rtm_state & NoRTM) != 0)) {\n@@ -967,1 +971,1 @@\n-    } else if (method_has_option(\"UseRTMLockEliding\") || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n+    } else if (method_has_option(CompileCommand::UseRTMLockEliding) || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n@@ -3809,0 +3813,1 @@\n+  case Op_LongCountedLoop:\n@@ -4135,1 +4140,1 @@\n-    if (n->is_OuterStripMinedLoopEnd()) {\n+    if (n->is_OuterStripMinedLoopEnd() || n->is_LongCountedLoopEnd()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-  bool          method_has_option(const char * option) {\n+  bool          method_has_option(enum CompileCommand option) {\n@@ -1105,2 +1105,2 @@\n-  static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];\n-  static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];\n+  static juint  _intrinsic_hist_count[];\n+  static jubyte _intrinsic_hist_flags[];\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1748,1 +1748,1 @@\n-  if (iff->is_CountedLoopEnd())  return NULL;\n+  if (iff->is_BaseCountedLoopEnd())  return NULL;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -530,0 +530,2 @@\n+  case vmIntrinsics::_Reference_refersTo0:      return inline_reference_refersTo0(false);\n+  case vmIntrinsics::_PhantomReference_refersTo0: return inline_reference_refersTo0(true);\n@@ -679,1 +681,1 @@\n-                    vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());\n+                    vmIntrinsics::name_at(intrinsic_id()), vmIntrinsics::as_int(intrinsic_id()));\n@@ -715,1 +717,1 @@\n-                    vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());\n+                    vmIntrinsics::name_at(intrinsic_id()), vmIntrinsics::as_int(intrinsic_id()));\n@@ -5621,1 +5623,1 @@\n-  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*is_exact*\/ false, \/*is_static*\/ true, crc32c_class);\n+  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n@@ -5812,8 +5814,4 @@\n-  const TypeInstPtr* tinst = _gvn.type(reference_obj)->isa_instptr();\n-  assert(tinst != NULL, \"obj is null\");\n-  assert(tinst->klass()->is_loaded(), \"obj is not loaded\");\n-  ciInstanceKlass* referenceKlass = tinst->klass()->as_instance_klass();\n-  ciField* field = referenceKlass->get_field_by_name(ciSymbol::make(\"referent\"),\n-                                                     ciSymbol::make(\"Ljava\/lang\/Object;\"),\n-                                                     false);\n-  assert (field != NULL, \"undefined field\");\n+  DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;\n+  Node* result = load_field_from_object(reference_obj, \"referent\", \"Ljava\/lang\/Object;\",\n+                                        decorators, \/*is_static*\/ false, NULL);\n+  if (result == NULL) return false;\n@@ -5821,2 +5819,3 @@\n-  Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);\n-  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+  \/\/ Add memory barrier to prevent commoning reads from this field\n+  \/\/ across safepoint since GC can change its value.\n+  insert_mem_bar(Op_MemBarCPUOrder);\n@@ -5824,2 +5823,18 @@\n-  ciInstanceKlass* klass = env()->Object_klass();\n-  const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);\n+  set_result(result);\n+  return true;\n+}\n+\n+\/\/----------------------------inline_reference_refersTo0----------------------------\n+\/\/ bool java.lang.ref.Reference.refersTo0();\n+\/\/ bool java.lang.ref.PhantomReference.refersTo0();\n+bool LibraryCallKit::inline_reference_refersTo0(bool is_phantom) {\n+  \/\/ Get arguments:\n+  Node* reference_obj = null_check_receiver();\n+  Node* other_obj = argument(1);\n+  if (stopped()) return true;\n+\n+  DecoratorSet decorators = IN_HEAP | AS_NO_KEEPALIVE;\n+  decorators |= (is_phantom ? ON_PHANTOM_OOP_REF : ON_WEAK_OOP_REF);\n+  Node* referent = load_field_from_object(reference_obj, \"referent\", \"Ljava\/lang\/Object;\",\n+                                          decorators, \/*is_static*\/ false, NULL);\n+  if (referent == NULL) return false;\n@@ -5827,2 +5842,0 @@\n-  DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;\n-  Node* result = access_load_at(reference_obj, adr, adr_type, object_type, T_OBJECT, decorators);\n@@ -5833,1 +5846,18 @@\n-  set_result(result);\n+  Node* cmp = _gvn.transform(new CmpPNode(referent, other_obj));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  IfNode* if_node = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+  RegionNode* region = new RegionNode(3);\n+  PhiNode* phi = new PhiNode(region, TypeInt::BOOL);\n+\n+  Node* if_true = _gvn.transform(new IfTrueNode(if_node));\n+  region->init_req(1, if_true);\n+  phi->init_req(1, intcon(1));\n+\n+  Node* if_false = _gvn.transform(new IfFalseNode(if_node));\n+  region->init_req(2, if_false);\n+  phi->init_req(2, intcon(0));\n+\n+  set_control(_gvn.transform(region));\n+  record_for_igvn(region);\n+  set_result(_gvn.transform(phi));\n@@ -5838,3 +5868,3 @@\n-Node * LibraryCallKit::load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,\n-                                              bool is_exact=true, bool is_static=false,\n-                                              ciInstanceKlass * fromKls=NULL) {\n+Node* LibraryCallKit::load_field_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString,\n+                                             DecoratorSet decorators = IN_HEAP, bool is_static = false,\n+                                             ciInstanceKlass* fromKls = NULL) {\n@@ -5845,1 +5875,0 @@\n-    assert(!is_exact || tinst->klass_is_exact(), \"klass not exact\");\n@@ -5881,2 +5910,0 @@\n-  DecoratorSet decorators = IN_HEAP;\n-\n@@ -6036,1 +6063,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6057,1 +6084,1 @@\n-  Node* objRvec = load_field_from_object(cipherBlockChaining_object, \"r\", \"[B\", \/*is_exact*\/ false);\n+  Node* objRvec = load_field_from_object(cipherBlockChaining_object, \"r\", \"[B\");\n@@ -6124,1 +6151,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6197,1 +6224,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(counterMode_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(counterMode_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6214,1 +6241,1 @@\n-  Node* obj_counter = load_field_from_object(counterMode_object, \"counter\", \"[B\", \/*is_exact*\/ false);\n+  Node* obj_counter = load_field_from_object(counterMode_object, \"counter\", \"[B\");\n@@ -6218,1 +6245,1 @@\n-  Node* saved_encCounter = load_field_from_object(counterMode_object, \"encryptedCounter\", \"[B\", \/*is_exact*\/ false);\n+  Node* saved_encCounter = load_field_from_object(counterMode_object, \"encryptedCounter\", \"[B\");\n@@ -6242,1 +6269,1 @@\n-  Node* objSessionK = load_field_from_object(aescrypt_object, \"sessionK\", \"[[I\", \/*is_exact*\/ false);\n+  Node* objSessionK = load_field_from_object(aescrypt_object, \"sessionK\", \"[[I\");\n@@ -6249,1 +6276,1 @@\n-  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"K\", \"[I\", \/*is_exact*\/ false);\n+  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"K\", \"[I\");\n@@ -6276,1 +6303,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(objCBC, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(objCBC, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6339,1 +6366,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(objECB, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(objECB, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6399,1 +6426,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(objCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(objCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6760,1 +6787,1 @@\n-  Node* digest_state = load_field_from_object(digest_object, \"state\", state_type, \/*is_exact*\/ false);\n+  Node* digest_state = load_field_from_object(digest_object, \"state\", state_type);\n@@ -6771,1 +6798,1 @@\n-  Node* digest_length = load_field_from_object(digest_object, \"digestLength\", \"I\", \/*is_exact*\/ false);\n+  Node* digest_length = load_field_from_object(digest_object, \"digestLength\", \"I\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":64,"deletions":37,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -215,2 +215,2 @@\n-  Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);\n-  Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);\n+  Node* load_field_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, DecoratorSet decorators, bool is_static, ciInstanceKlass* fromKls);\n+  Node* field_address_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass* fromKls);\n@@ -300,0 +300,1 @@\n+  bool inline_reference_refersTo0(bool is_phantom);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -72,4 +73,4 @@\n-bool LoopNode::is_valid_counted_loop() const {\n-  if (is_CountedLoop()) {\n-    CountedLoopNode*    l  = as_CountedLoop();\n-    CountedLoopEndNode* le = l->loopexit_or_null();\n+bool LoopNode::is_valid_counted_loop(BasicType bt) const {\n+  if (is_BaseCountedLoop() && operates_on(bt, false)) {\n+    BaseCountedLoopNode*    l  = as_BaseCountedLoop();\n+    BaseCountedLoopEndNode* le = l->loopexit_or_null();\n@@ -245,1 +246,1 @@\n-void PhaseIdealLoop::set_early_ctrl( Node *n ) {\n+void PhaseIdealLoop::set_early_ctrl(Node* n, bool update_body) {\n@@ -250,0 +251,4 @@\n+  IdealLoopTree *loop = get_loop(early);\n+  if (update_body && loop->_child == NULL) {\n+    loop->_body.push(n);\n+  }\n@@ -254,1 +259,1 @@\n-void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {\n+void PhaseIdealLoop::set_subtree_ctrl(Node* n, bool update_body) {\n@@ -256,1 +261,1 @@\n-  if( _nodes[n->_idx] ) return;\n+  if (_nodes[n->_idx]) return;\n@@ -259,1 +264,1 @@\n-  for( i = 0; i < n->req(); ++i ) {\n+  for (i = 0; i < n->req(); ++i) {\n@@ -261,2 +266,3 @@\n-    if( m && m != C->root() )\n-      set_subtree_ctrl( m );\n+    if (m && m != C->root()) {\n+      set_subtree_ctrl(m, update_body);\n+    }\n@@ -266,1 +272,1 @@\n-  set_early_ctrl( n );\n+  set_early_ctrl(n, update_body);\n@@ -348,1 +354,1 @@\n-  set_subtree_ctrl(bol);\n+  set_subtree_ctrl(bol, false);\n@@ -487,21 +493,1 @@\n-\/\/ Return 0 if it won't overflow, -1 if it must overflow, and 1 otherwise.\n-static int check_stride_overflow(jint stride_con, const TypeInt* limit_t) {\n-  if (stride_con > 0) {\n-    if (limit_t->_lo > (max_jint - stride_con)) {\n-      return -1;\n-    }\n-    if (limit_t->_hi > (max_jint - stride_con)) {\n-      return 1;\n-    }\n-  } else {\n-    if (limit_t->_hi < (min_jint - stride_con)) {\n-      return -1;\n-    }\n-    if (limit_t->_lo < (min_jint - stride_con)) {\n-      return 1;\n-    }\n-  }\n-  return 0;\n-}\n-\n-static int check_stride_overflow(jlong stride_con, const TypeLong* limit_t) {\n+static int check_stride_overflow(jlong stride_con, const TypeInteger* limit_t, BasicType bt) {\n@@ -509,1 +495,1 @@\n-    if (limit_t->_lo > (max_jlong - stride_con)) {\n+    if (limit_t->lo_as_long() > (max_signed_integer(bt) - stride_con)) {\n@@ -512,1 +498,1 @@\n-    if (limit_t->_hi > (max_jlong - stride_con)) {\n+    if (limit_t->hi_as_long() > (max_signed_integer(bt) - stride_con)) {\n@@ -516,1 +502,1 @@\n-    if (limit_t->_hi < (min_jlong - stride_con)) {\n+    if (limit_t->hi_as_long() < (min_signed_integer(bt) - stride_con)) {\n@@ -519,1 +505,1 @@\n-    if (limit_t->_lo < (min_jlong - stride_con)) {\n+    if (limit_t->lo_as_long() < (min_signed_integer(bt) - stride_con)) {\n@@ -571,1 +557,1 @@\n-    set_subtree_ctrl(bol);\n+    set_subtree_ctrl(bol, false);\n@@ -612,1 +598,1 @@\n-      set_subtree_ctrl(unc->in(i));\n+      set_subtree_ctrl(unc->in(i), false);\n@@ -630,0 +616,48 @@\n+static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm) {\n+  SafePointNode* safepoint = NULL;\n+  for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n+    Node* u = x->fast_out(i);\n+    if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n+      Node* m = u->in(LoopNode::LoopBackControl);\n+      if (u->adr_type() == TypePtr::BOTTOM) {\n+        if (m->is_MergeMem() && mem->is_MergeMem()) {\n+          if (m != mem DEBUG_ONLY(|| true)) {\n+            for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n+              if (!mms.is_empty()) {\n+                if (mms.memory() != mms.memory2()) {\n+                  return false;\n+                }\n+#ifdef ASSERT\n+                if (mms.alias_idx() != Compile::AliasIdxBot) {\n+                  mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n+                }\n+#endif\n+              }\n+            }\n+          }\n+        } else if (mem->is_MergeMem()) {\n+          if (m != mem->as_MergeMem()->base_memory()) {\n+            return false;\n+          }\n+        } else {\n+          return false;\n+        }\n+      } else {\n+        if (mem->is_MergeMem()) {\n+          if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n+            return false;\n+          }\n+#ifdef ASSERT\n+          mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n+#endif\n+        } else {\n+          if (m != mem) {\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -654,1 +688,0 @@\n-#ifdef ASSERT\n@@ -657,0 +690,1 @@\n+#ifdef ASSERT\n@@ -667,42 +701,4 @@\n-    for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n-      Node* u = x->fast_out(i);\n-      if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n-        Node* m = u->in(LoopNode::LoopBackControl);\n-        if (u->adr_type() == TypePtr::BOTTOM) {\n-          if (m->is_MergeMem() && mem->is_MergeMem()) {\n-            if (m != mem DEBUG_ONLY(|| true)) {\n-              for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n-                if (!mms.is_empty()) {\n-                  if (mms.memory() != mms.memory2()) {\n-                    return NULL;\n-                  }\n-#ifdef ASSERT\n-                  if (mms.alias_idx() != Compile::AliasIdxBot) {\n-                    mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n-                  }\n-#endif\n-                }\n-              }\n-            }\n-          } else if (mem->is_MergeMem()) {\n-            if (m != mem->as_MergeMem()->base_memory()) {\n-              return NULL;\n-            }\n-          } else {\n-            return NULL;\n-          }\n-        } else {\n-          if (mem->is_MergeMem()) {\n-            if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n-              return NULL;\n-            }\n-#ifdef ASSERT\n-            mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n-#endif\n-          } else {\n-            if (m != mem) {\n-              return NULL;\n-            }\n-          }\n-        }\n-      }\n+    if (!no_side_effect_since_safepoint(C, x, mem, mm)) {\n+      safepoint = NULL;\n+    } else {\n+      assert(mm == NULL|| _igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -712,1 +708,0 @@\n-      assert (_igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -730,1 +725,0 @@\n-\/\/   \/\/ phi_incr := phi (test happens before increment)\n@@ -740,1 +734,0 @@\n-\/\/   \/\/ phi_incr := NULL (test happens after increment)\n@@ -770,1 +763,2 @@\n-bool PhaseIdealLoop::is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new) {\n+bool PhaseIdealLoop::transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new) {\n+  Node* x = loop->_head;\n@@ -772,1 +766,1 @@\n-  if (loop->_child != NULL) {\n+  if (loop->_child != NULL || !x->is_LongCountedLoop()) {\n@@ -776,5 +770,1 @@\n-  \/\/ Checks whether the loop has the shape of a counted loop\n-  Node* back_control = loop_exit_control(x, loop);\n-  if (back_control == NULL) {\n-    return false;\n-  }\n+  check_long_counted_loop(loop, x);\n@@ -782,22 +772,1 @@\n-  BoolTest::mask bt = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = NULL;\n-  Node* limit = NULL;\n-\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-  if (cmp == NULL || cmp->Opcode() != Op_CmpL) {\n-    return false; \/\/ Avoid pointer & float & 32-bit compares\n-  }\n-\n-  Node* phi_incr = NULL;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  if (incr == NULL || incr->Opcode() != Op_AddL) {\n-    return false;\n-  }\n-\n-  Node* xphi = NULL;\n-  Node* stride = loop_iv_stride(incr, loop, xphi);\n-\n-  if (stride == NULL) {\n-    return false;\n-  }\n+  LongCountedLoopNode* head = x->as_LongCountedLoop();\n@@ -809,1 +778,1 @@\n-  jlong stride_con = stride->get_long();\n+  jlong stride_con = head->stride_con();\n@@ -829,1 +798,2 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+  PhiNode* phi = head->phi()->as_Phi();\n+  Node* incr = head->incr();\n@@ -831,8 +801,1 @@\n-  if (phi == NULL || phi->in(LoopNode::LoopBackControl) != incr) {\n-    return false;\n-  }\n-\n-  \/\/ Safepoint on backedge not supported\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n-    return false;\n-  }\n+  Node* back_control = head->in(LoopNode::LoopBackControl);\n@@ -845,4 +808,1 @@\n-  if (!condition_stride_ok(bt, stride_con)) {\n-    return false;\n-  }\n-\n+  Node* limit = head->limit();\n@@ -854,1 +814,6 @@\n-  IfNode* exit_test = back_control->in(0)->as_If();\n+  const TypeLong* phi_t = _igvn.type(phi)->is_long();\n+  assert(phi_t->_hi >= phi_t->_lo, \"dead phi?\");\n+  iters_limit = (int)MIN2((julong)iters_limit, (julong)(phi_t->_hi - phi_t->_lo));\n+\n+  LongCountedLoopEndNode* exit_test = head->loopexit();\n+  BoolTest::mask bt = exit_test->test_trip();\n@@ -858,13 +823,2 @@\n-  if (safepoint == NULL) {\n-    \/\/ If exit condition is ne, then a loop limit check is likely needed\n-    if (bt == BoolTest::ne) {\n-      return false;\n-    }\n-  } else if (C->too_many_traps(safepoint->jvms()->method(),\n-                        safepoint->jvms()->bci(),\n-                        Deoptimization::Reason_loop_limit_check)) {\n-    \/\/ We must have transformed the loop already and a loop limit\n-    \/\/ check must have failed.\n-    return false;\n-  }\n-  Node* exit_branch = exit_test->proj_out(back_control->Opcode() == Op_IfFalse);\n+  assert(back_control->Opcode() == Op_IfTrue, \"wrong projection for back edge\");\n+  Node* exit_branch = exit_test->proj_out(false);\n@@ -873,20 +827,1 @@\n-\n-  \/\/ if the loop exit test is on the IV before it is incremented: i <\n-  \/\/ limit, we transform the exit test so it is performed on the exit\n-  \/\/ test after it is incremented: i + stride < limit + stride.  We\n-  \/\/ need limit + stride to not overflow. See adjusted_limit below.\n-  bool limit_check_required = false;\n-  if (phi_incr != NULL) {\n-    const TypeLong* limit_t = _igvn.type(limit)->is_long();\n-    int sov = check_stride_overflow(stride_con, limit_t);\n-    if (sov != 0) {\n-      if (sov < 0) {\n-        return false;  \/\/ Bailout: integer overflow is certain.\n-      }\n-      \/\/ Check that inserting a predicate is indeed possible\n-      if (find_predicate_insertion_point(x->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check) == NULL) {\n-        return false;\n-      }\n-      limit_check_required = true;\n-    }\n-  }\n+  Node* cmp = exit_test->cmp_node();\n@@ -896,1 +831,1 @@\n-  Node* outer_exit_test = exit_test->clone();\n+  Node* outer_exit_test = new IfNode(exit_test->in(0), exit_test->in(1), exit_test->_prob, exit_test->_fcnt);\n@@ -927,9 +862,0 @@\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != NULL) {\n-    \/\/ If compare points directly to the phi we need to adjust the\n-    \/\/ compare so that it points to the incr.\n-    Node* long_stride = _igvn.longcon(stride_con);\n-    set_ctrl(long_stride, C->root());\n-    adjusted_limit = new AddLNode(limit, long_stride);\n-    _igvn.register_new_node_with_optimizer(adjusted_limit);\n-  }\n@@ -938,1 +864,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(adjusted_limit, outer_phi, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeLong::LONG, _igvn);\n@@ -940,1 +866,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, adjusted_limit, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeLong::LONG, _igvn);\n@@ -965,6 +891,1 @@\n-  if (cmp->in(1) == incr || cmp->in(1) == phi) {\n-    inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n-  }  else {\n-    assert(cmp->in(2) == incr || cmp->in(2) == phi, \"bad iv shape\");\n-    inner_cmp = new CmpINode(inner_iters_actual_int, inner_incr);\n-  }\n+  inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n@@ -981,36 +902,2 @@\n-  \/\/ Add a predicate to guarantee limit adjustment doesn't overflow\n-  if (limit_check_required) {\n-    assert(phi_incr != NULL, \"only when exit test must be transformed\");\n-    ProjNode *limit_check_proj = find_predicate_insertion_point(outer_head->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check);\n-    assert(limit_check_proj != NULL, \"was tested before\");\n-    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n-    Node* cmp_limit;\n-    Node* bol;\n-\n-    if (stride_con > 0) {\n-      cmp_limit = new CmpLNode(limit, _igvn.longcon(max_jlong - stride_con));\n-      bol = new BoolNode(cmp_limit, BoolTest::le);\n-    } else {\n-      cmp_limit = new CmpLNode(limit, _igvn.longcon(min_jlong - stride_con));\n-      bol = new BoolNode(cmp_limit, BoolTest::ge);\n-    }\n-\n-    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n-    Node* new_predicate = limit_check_proj->in(0)->in(0);\n-    Node* above_predicate = new_predicate->in(0)->in(0);\n-    Node* entry = outer_head->in(LoopNode::EntryControl);\n-    _igvn.replace_input_of(limit_check_proj->in(0), 0, above_predicate);\n-    _igvn.replace_input_of(new_predicate->in(0), 0, entry);\n-    _igvn.replace_input_of(outer_head, LoopNode::EntryControl, new_predicate);\n-    set_idom(new_predicate->in(0), entry, dom_depth(entry));\n-    set_idom(new_predicate, new_predicate->in(0), dom_depth(entry));\n-    Node* region = new_predicate->in(0)->as_If()->proj_out(new_predicate->Opcode() == Op_IfFalse)->unique_ctrl_out();\n-    assert(region->is_Region(), \"should be region merging predicates\");\n-    set_idom(region, entry, dom_depth(entry));\n-    set_idom(limit_check_proj->in(0), above_predicate, dom_depth(above_predicate));\n-  }\n-\n-  LoopNode* inner_head = x->as_Loop();\n-\n-  for (uint i = 0; i < inner_head->outcnt(); i++) {\n-    Node* u = inner_head->raw_out(i);\n+  for (uint i = 0; i < head->outcnt(); i++) {\n+    Node* u = head->raw_out(i);\n@@ -1019,1 +906,1 @@\n-      assert(u->in(0) == inner_head, \"inconsistent\");\n+      assert(u->in(0) == head, \"inconsistent\");\n@@ -1029,1 +916,1 @@\n-  long_loop_replace_long_iv(phi, inner_phi, outer_phi, inner_head);\n+  long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n@@ -1033,1 +920,3 @@\n-  long_loop_replace_long_iv(incr, inner_incr, outer_phi, inner_head);\n+  long_loop_replace_long_iv(incr, inner_incr, outer_phi, head);\n+\n+  set_subtree_ctrl(inner_iters_actual_int, body_populated);\n@@ -1035,1 +924,1 @@\n-  set_subtree_ctrl(inner_iters_actual_int);\n+  LoopNode* inner_head = create_inner_head(loop, head, exit_test);\n@@ -1051,1 +940,0 @@\n-  \/\/   \/\/ test happens before increment => phi == phi_incr != NULL\n@@ -1099,0 +987,2 @@\n+  } else {\n+    C->set_major_progress();\n@@ -1122,0 +1012,59 @@\n+LoopNode* PhaseIdealLoop::create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head,\n+                                            LongCountedLoopEndNode* exit_test) {\n+  LoopNode* new_inner_head = new LoopNode(head->in(1), head->in(2));\n+  IfNode* new_inner_exit = new IfNode(exit_test->in(0), exit_test->in(1), exit_test->_prob, exit_test->_fcnt);\n+  _igvn.register_new_node_with_optimizer(new_inner_head);\n+  _igvn.register_new_node_with_optimizer(new_inner_exit);\n+  loop->_body.push(new_inner_head);\n+  loop->_body.push(new_inner_exit);\n+  loop->_body.yank(head);\n+  loop->_body.yank(exit_test);\n+  set_loop(new_inner_head, loop);\n+  set_loop(new_inner_exit, loop);\n+  set_idom(new_inner_head, idom(head), dom_depth(head));\n+  set_idom(new_inner_exit, idom(exit_test), dom_depth(exit_test));\n+  lazy_replace(head, new_inner_head);\n+  lazy_replace(exit_test, new_inner_exit);\n+  loop->_head = new_inner_head;\n+  return new_inner_head;\n+}\n+\n+#ifdef ASSERT\n+void PhaseIdealLoop::check_long_counted_loop(IdealLoopTree* loop, Node* x) {\n+  Node* back_control = loop_exit_control(x, loop);\n+  assert(back_control != NULL, \"no back control\");\n+\n+  BoolTest::mask bt = BoolTest::illegal;\n+  float cl_prob = 0;\n+  Node* incr = NULL;\n+  Node* limit = NULL;\n+\n+  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n+  assert(cmp != NULL && cmp->Opcode() == Op_CmpL, \"no exit test\");\n+\n+  Node* phi_incr = NULL;\n+  incr = loop_iv_incr(incr, x, loop, phi_incr);\n+  assert(incr != NULL && incr->Opcode() == Op_AddL, \"no incr\");\n+\n+  Node* xphi = NULL;\n+  Node* stride = loop_iv_stride(incr, loop, xphi);\n+\n+  assert(stride != NULL, \"no stride\");\n+\n+  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+\n+  assert(phi != NULL && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n+\n+  jlong stride_con = stride->get_long();\n+\n+  assert(condition_stride_ok(bt, stride_con), \"illegal condition\");\n+\n+  assert(bt != BoolTest::ne, \"unexpected condition\");\n+  assert(phi_incr == NULL, \"bad loop shape\");\n+  assert(cmp->in(1) == incr, \"bad exit test shape\");\n+\n+  \/\/ Safepoint on backedge not supported\n+  assert(x->in(LoopNode::LoopBackControl)->Opcode() != Op_SafePoint, \"no safepoint on backedge\");\n+}\n+#endif\n+\n@@ -1193,1 +1142,1 @@\n-        set_subtree_ctrl(in_clone);\n+        set_subtree_ctrl(in_clone, false);\n@@ -1210,1 +1159,1 @@\n-    set_subtree_ctrl(clone);\n+    set_subtree_ctrl(clone, false);\n@@ -1220,1 +1169,1 @@\n-        set_subtree_ctrl(m);\n+        set_subtree_ctrl(m, false);\n@@ -1232,1 +1181,1 @@\n-bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*& loop) {\n+bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt) {\n@@ -1245,1 +1194,1 @@\n-  if (cmp == NULL || cmp->Opcode() != Op_CmpI) {\n+  if (cmp == NULL || !(cmp->is_Cmp() && cmp->operates_on(iv_bt, true))) {\n@@ -1250,1 +1199,1 @@\n-  if (incr->Opcode() == Op_CastII) {\n+  if (incr->is_ConstraintCast() && incr->operates_on(iv_bt, false)) {\n@@ -1262,1 +1211,1 @@\n-  const TypeInt* iv_trunc_t = NULL;\n+  const TypeInteger* iv_trunc_t = NULL;\n@@ -1264,1 +1213,1 @@\n-  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t))) {\n+  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t, iv_bt))) {\n@@ -1267,1 +1216,1 @@\n-  assert(incr->Opcode() == Op_AddI, \"wrong increment code\");\n+  assert(incr->is_Add() && incr->operates_on(iv_bt, false), \"wrong increment code\");\n@@ -1276,1 +1225,1 @@\n-  if (xphi->Opcode() == Op_CastII) {\n+  if (xphi->is_ConstraintCast() && xphi->operates_on(iv_bt, false)) {\n@@ -1281,1 +1230,1 @@\n-  int stride_con = stride->get_int();\n+  jlong stride_con = stride->get_integer_as_long(iv_bt);\n@@ -1293,1 +1242,2 @@\n-      LoopStripMiningIter != 0) {\n+          ((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+           iv_bt == T_LONG)) {\n@@ -1306,1 +1256,1 @@\n-  const TypeInt* limit_t = gvn->type(limit)->is_int();\n+  const TypeInteger* limit_t = gvn->type(limit)->is_integer(iv_bt);\n@@ -1325,2 +1275,2 @@\n-    const TypeInt* incr_t = gvn->type(orig_incr)->is_int();\n-    if (limit_t->_hi > incr_t->_hi) {\n+    const TypeInteger* incr_t = gvn->type(orig_incr)->is_integer(iv_bt);\n+    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n@@ -1335,1 +1285,1 @@\n-  if (!TypeInt::INT->higher_equal(iv_trunc_t)) {\n+  if (!TypeInteger::bottom(iv_bt)->higher_equal(iv_trunc_t)) {\n@@ -1339,1 +1289,1 @@\n-    const TypeInt* phi_ft = filtered_type(phi);\n+    const TypeInteger* phi_ft = filtered_type(phi);\n@@ -1353,2 +1303,2 @@\n-      if (iv_trunc_t->_hi - phi_ft->_hi < stride_con ||\n-          iv_trunc_t->_lo > phi_ft->_lo) {\n+      if (iv_trunc_t->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          iv_trunc_t->lo_as_long() > phi_ft->lo_as_long()) {\n@@ -1358,2 +1308,2 @@\n-      if (iv_trunc_t->_lo - phi_ft->_lo > stride_con ||\n-          iv_trunc_t->_hi < phi_ft->_hi) {\n+      if (iv_trunc_t->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          iv_trunc_t->hi_as_long() < phi_ft->hi_as_long()) {\n@@ -1373,1 +1323,1 @@\n-  const TypeInt* init_t = gvn->type(init_trip)->is_int();\n+  const TypeInteger* init_t = gvn->type(init_trip)->is_integer(iv_bt);\n@@ -1376,3 +1326,3 @@\n-    jlong init_p = (jlong)init_t->_lo + stride_con;\n-    if (init_p > (jlong)max_jint || init_p > (jlong)limit_t->_hi)\n-      return false; \/\/ cyclic loop or this loop trips only once\n+    if (init_t->lo_as_long() > max_signed_integer(iv_bt) - stride_con) {\n+      return false; \/\/ cyclic loop\n+    }\n@@ -1380,3 +1330,3 @@\n-    jlong init_p = (jlong)init_t->_hi + stride_con;\n-    if (init_p < (jlong)min_jint || init_p < (jlong)limit_t->_lo)\n-      return false; \/\/ cyclic loop or this loop trips only once\n+    if (init_t->hi_as_long() < min_signed_integer(iv_bt) - stride_con) {\n+      return false; \/\/ cyclic loop\n+    }\n@@ -1388,1 +1338,1 @@\n-      if (init_t->_hi > max_jint - stride_con) {\n+      if (init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) {\n@@ -1392,1 +1342,1 @@\n-      if (init_t->_lo < min_jint - stride_con) {\n+      if (init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con) {\n@@ -1401,1 +1351,1 @@\n-  assert(x->Opcode() == Op_Loop, \"regular loops only\");\n+  assert(x->Opcode() == Op_Loop || x->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n@@ -1421,1 +1371,1 @@\n-  int stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n+  jlong stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n@@ -1434,1 +1384,1 @@\n-  int sov = check_stride_overflow(stride_m, limit_t);\n+  int sov = check_stride_overflow(stride_m, limit_t, iv_bt);\n@@ -1467,1 +1417,1 @@\n-      cmp_limit = new CmpINode(limit, _igvn.intcon(max_jint - stride_m));\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_jint - stride_m, iv_bt), iv_bt);\n@@ -1470,1 +1420,1 @@\n-      cmp_limit = new CmpINode(limit, _igvn.intcon(min_jint - stride_m));\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_jint - stride_m, iv_bt), iv_bt);\n@@ -1480,1 +1430,1 @@\n-    if (stride_con > 0 && init_t->_hi < limit_t->_lo) {\n+    if (stride_con > 0 && init_t->hi_as_long() < limit_t->lo_as_long()) {\n@@ -1483,1 +1433,1 @@\n-    } else if (stride_con < 0 && init_t->_lo > limit_t->_hi) {\n+    } else if (stride_con < 0 && init_t->lo_as_long() > limit_t->hi_as_long()) {\n@@ -1510,1 +1460,1 @@\n-        cmp_limit = new CmpINode(init_trip, limit);\n+        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n@@ -1513,1 +1463,1 @@\n-        cmp_limit = new CmpINode(init_trip, limit);\n+        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n@@ -1530,1 +1480,5 @@\n-  if (!x->as_Loop()->is_transformed_long_loop() && StressLongCountedLoop > 0 && trunc1 == NULL && convert_to_long_loop(cmp, phi, loop)) {\n+  if (iv_bt == T_INT &&\n+      !x->as_Loop()->is_transformed_long_loop() &&\n+      StressLongCountedLoop > 0 &&\n+      trunc1 == NULL &&\n+      convert_to_long_loop(cmp, phi, loop)) {\n@@ -1545,1 +1499,1 @@\n-    adjusted_limit = gvn->transform(new AddINode(limit, stride));\n+    adjusted_limit = gvn->transform(AddNode::make(limit, stride, iv_bt));\n@@ -1552,2 +1506,2 @@\n-    Node* one = (stride_con > 0) ? gvn->intcon( 1) : gvn->intcon(-1);\n-    adjusted_limit = gvn->transform(new AddINode(adjusted_limit, one));\n+    Node* one = (stride_con > 0) ? gvn->integercon( 1, iv_bt) : gvn->integercon(-1, iv_bt);\n+    adjusted_limit = gvn->transform(AddNode::make(adjusted_limit, one, iv_bt));\n@@ -1561,1 +1515,1 @@\n-  set_subtree_ctrl(adjusted_limit);\n+  set_subtree_ctrl(adjusted_limit, false);\n@@ -1563,1 +1517,1 @@\n-  if (LoopStripMiningIter == 0) {\n+  if (iv_bt == T_INT && LoopStripMiningIter == 0) {\n@@ -1581,1 +1535,1 @@\n-  set_early_ctrl( incr );\n+  set_early_ctrl(incr, false);\n@@ -1588,2 +1542,2 @@\n-  if (!TypeInt::INT->higher_equal(phi->bottom_type())) {\n-    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInt::INT);\n+  if (!TypeInteger::bottom(iv_bt)->higher_equal(phi->bottom_type())) {\n+    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInteger::bottom(iv_bt));\n@@ -1609,1 +1563,1 @@\n-  Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff->in(0), test, cl_prob, iff->as_If()->_fcnt ));\n+  Node *lex = _igvn.register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0), test, cl_prob, iff->as_If()->_fcnt, iv_bt));\n@@ -1649,2 +1603,5 @@\n-  bool strip_mine_loop = LoopStripMiningIter > 1 && loop->_child == NULL &&\n-    sfpt2->Opcode() == Op_SafePoint && !loop->_has_call;\n+  bool strip_mine_loop = iv_bt == T_INT &&\n+                         LoopStripMiningIter > 1 &&\n+                         loop->_child == NULL &&\n+                         sfpt2->Opcode() == Op_SafePoint &&\n+                         !loop->_has_call;\n@@ -1659,1 +1616,1 @@\n-  CountedLoopNode *l = new CountedLoopNode(entry_control, back_control);\n+  BaseCountedLoopNode *l = BaseCountedLoopNode::make(entry_control, back_control, iv_bt);\n@@ -1673,1 +1630,1 @@\n-  if (LoopStripMiningIter == 0 || strip_mine_loop) {\n+  if (iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n@@ -1694,1 +1651,1 @@\n-  assert(l->is_valid_counted_loop(), \"counted loop shape is messed up\");\n+  assert(l->is_valid_counted_loop(iv_bt), \"counted loop shape is messed up\");\n@@ -1731,1 +1688,1 @@\n-  assert(cl->is_valid_counted_loop(), \"\");\n+  assert(cl->is_valid_counted_loop(T_INT), \"\");\n@@ -1781,1 +1738,1 @@\n-    if (!is_valid_counted_loop()) {\n+    if (!is_valid_counted_loop(T_INT)) {\n@@ -1790,1 +1747,1 @@\n-    assert(inner->is_valid_counted_loop() && inner->is_strip_mined(), \"OuterStripMinedLoop should have been removed\");\n+    assert(inner->is_valid_counted_loop(T_INT) && inner->is_strip_mined(), \"OuterStripMinedLoop should have been removed\");\n@@ -1888,2 +1845,11 @@\n-int CountedLoopEndNode::stride_con() const {\n-  return stride()->bottom_type()->is_int()->get_con();\n+jlong BaseCountedLoopEndNode::stride_con() const {\n+  return stride()->bottom_type()->is_integer(bt())->get_con_as_long(bt());\n+}\n+\n+\n+BaseCountedLoopEndNode* BaseCountedLoopEndNode::make(Node* control, Node* test, float prob, float cnt, BasicType bt) {\n+  if (bt == T_INT) {\n+    return new CountedLoopEndNode(control, test, prob, cnt);\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return new LongCountedLoopEndNode(control, test, prob, cnt);\n@@ -2020,2 +1986,3 @@\n-Node* CountedLoopNode::match_incr_with_optional_truncation(\n-                      Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type) {\n+Node* CountedLoopNode::match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2,\n+                                                           const TypeInteger** trunc_type,\n+                                                           BasicType bt) {\n@@ -2027,1 +1994,0 @@\n-  const TypeInt* trunc_t = TypeInt::INT;\n@@ -2030,18 +1996,8 @@\n-\n-  \/\/ Try to strip (n1 & M) or (n1 << N >> N) from n1.\n-  if (n1op == Op_AndI &&\n-      n1->in(2)->is_Con() &&\n-      n1->in(2)->bottom_type()->is_int()->get_con() == 0x7fff) {\n-    \/\/ %%% This check should match any mask of 2**K-1.\n-    t1 = n1;\n-    n1 = t1->in(1);\n-    n1op = n1->Opcode();\n-    trunc_t = TypeInt::CHAR;\n-  } else if (n1op == Op_RShiftI &&\n-             n1->in(1) != NULL &&\n-             n1->in(1)->Opcode() == Op_LShiftI &&\n-             n1->in(2) == n1->in(1)->in(2) &&\n-             n1->in(2)->is_Con()) {\n-    jint shift = n1->in(2)->bottom_type()->is_int()->get_con();\n-    \/\/ %%% This check should match any shift in [1..31].\n-    if (shift == 16 || shift == 8) {\n+  const TypeInteger* trunc_t = TypeInteger::bottom(bt);\n+\n+  if (bt == T_INT) {\n+    \/\/ Try to strip (n1 & M) or (n1 << N >> N) from n1.\n+    if (n1op == Op_AndI &&\n+        n1->in(2)->is_Con() &&\n+        n1->in(2)->bottom_type()->is_int()->get_con() == 0x7fff) {\n+      \/\/ %%% This check should match any mask of 2**K-1.\n@@ -2049,2 +2005,1 @@\n-      t2 = t1->in(1);\n-      n1 = t2->in(1);\n+      n1 = t1->in(1);\n@@ -2052,4 +2007,18 @@\n-      if (shift == 16) {\n-        trunc_t = TypeInt::SHORT;\n-      } else if (shift == 8) {\n-        trunc_t = TypeInt::BYTE;\n+      trunc_t = TypeInt::CHAR;\n+    } else if (n1op == Op_RShiftI &&\n+               n1->in(1) != NULL &&\n+               n1->in(1)->Opcode() == Op_LShiftI &&\n+               n1->in(2) == n1->in(1)->in(2) &&\n+               n1->in(2)->is_Con()) {\n+      jint shift = n1->in(2)->bottom_type()->is_int()->get_con();\n+      \/\/ %%% This check should match any shift in [1..31].\n+      if (shift == 16 || shift == 8) {\n+        t1 = n1;\n+        t2 = t1->in(1);\n+        n1 = t2->in(1);\n+        n1op = n1->Opcode();\n+        if (shift == 16) {\n+          trunc_t = TypeInt::SHORT;\n+        } else if (shift == 8) {\n+          trunc_t = TypeInt::BYTE;\n+        }\n@@ -2061,1 +2030,1 @@\n-  if (n1op == Op_AddI) {\n+  if (n1->is_Add() && n1->operates_on(bt, true)) {\n@@ -2073,1 +2042,1 @@\n-  if (is_strip_mined() && is_valid_counted_loop()) {\n+  if (is_strip_mined() && is_valid_counted_loop(T_INT)) {\n@@ -2185,0 +2154,20 @@\n+\n+int CountedLoopNode::stride_con() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+jlong LongCountedLoopNode::stride_con() const {\n+  LongCountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+BaseCountedLoopNode* BaseCountedLoopNode::make(Node* entry, Node* backedge, BasicType bt) {\n+  if (bt == T_INT) {\n+    return new CountedLoopNode(entry, backedge);\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return new LongCountedLoopNode(entry, backedge);\n+}\n+\n+\n@@ -2414,1 +2403,1 @@\n-    \/\/ If limit < init for stride > 0 (or limit > init for stride 0),\n+    \/\/ If limit < init for stride > 0 (or limit > init for stride < 0),\n@@ -3163,1 +3152,1 @@\n-  if (!cl->is_valid_counted_loop())\n+  if (!cl->is_valid_counted_loop(T_INT))\n@@ -3227,1 +3216,1 @@\n-      set_early_ctrl(ratio_init);\n+      set_early_ctrl(ratio_init, false);\n@@ -3230,1 +3219,1 @@\n-      set_early_ctrl(diff);\n+      set_early_ctrl(diff, false);\n@@ -3290,1 +3279,1 @@\n-      phase->is_counted_loop(_head, loop)) {\n+      phase->is_counted_loop(_head, loop, T_INT)) {\n@@ -3303,1 +3292,3 @@\n-\n+  } else if (_head->is_LongCountedLoop() ||\n+             phase->is_counted_loop(_head, loop, T_LONG)) {\n+    remove_safepoints(phase, true);\n@@ -3307,4 +3298,4 @@\n-    \/\/ Not a counted loop. Keep one safepoint.\n-    bool keep_one_sfpt = true;\n-    remove_safepoints(phase, keep_one_sfpt);\n-  }\n+      \/\/ Not a counted loop. Keep one safepoint.\n+      bool keep_one_sfpt = true;\n+      remove_safepoints(phase, keep_one_sfpt);\n+    }\n@@ -3943,5 +3934,0 @@\n-  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n-    IdealLoopTree* lpt = iter.current();\n-    is_long_counted_loop(lpt->_head, lpt, worklist);\n-  }\n-\n@@ -4014,0 +4000,7 @@\n+  if (C->has_loops() && !C->major_progress()) {\n+    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+      IdealLoopTree *lpt = iter.current();\n+      transform_long_counted_loop(lpt, worklist);\n+    }\n+  }\n+\n@@ -4774,1 +4767,1 @@\n-          set_early_ctrl( n );\n+          set_early_ctrl(n, false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":318,"deletions":325,"binary":false,"changes":643,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class CountedLoopEndNode;\n+class BaseCountedLoopEndNode;\n@@ -156,1 +156,1 @@\n-  bool is_valid_counted_loop() const;\n+  bool is_valid_counted_loop(BasicType bt) const;\n@@ -198,1 +198,30 @@\n-class CountedLoopNode : public LoopNode {\n+class BaseCountedLoopNode : public LoopNode {\n+public:\n+  BaseCountedLoopNode(Node *entry, Node *backedge)\n+    : LoopNode(entry, backedge) {\n+  }\n+\n+  Node *init_control() const { return in(EntryControl); }\n+  Node *back_control() const { return in(LoopBackControl); }\n+\n+  Node* init_trip() const;\n+  Node* stride() const;\n+  bool stride_is_con() const;\n+  Node* limit() const;\n+  Node* incr() const;\n+  Node* phi() const;\n+\n+  BaseCountedLoopEndNode* loopexit_or_null() const;\n+  BaseCountedLoopEndNode* loopexit() const;\n+\n+  virtual BasicType bt() const = 0;\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n+  static BaseCountedLoopNode* make(Node* entry, Node* backedge, BasicType bt);\n+};\n+\n+\n+class CountedLoopNode : public BaseCountedLoopNode {\n@@ -222,2 +251,2 @@\n-  CountedLoopNode( Node *entry, Node *backedge )\n-    : LoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),\n+  CountedLoopNode(Node *entry, Node *backedge)\n+    : BaseCountedLoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),\n@@ -234,6 +263,2 @@\n-  Node *init_control() const { return in(EntryControl); }\n-  Node *back_control() const { return in(LoopBackControl); }\n-  CountedLoopEndNode *loopexit_or_null() const;\n-  CountedLoopEndNode *loopexit() const;\n-  Node *init_trip() const;\n-  Node *stride() const;\n+  CountedLoopEndNode* loopexit_or_null() const { return (CountedLoopEndNode*) BaseCountedLoopNode::loopexit_or_null(); }\n+  CountedLoopEndNode* loopexit() const { return (CountedLoopEndNode*) BaseCountedLoopNode::loopexit(); }\n@@ -241,4 +266,0 @@\n-  bool  stride_is_con() const;\n-  Node *limit() const;\n-  Node *incr() const;\n-  Node *phi() const;\n@@ -247,1 +268,3 @@\n-  static Node* match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type);\n+  static Node*\n+  match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInteger** trunc_type,\n+                                      BasicType bt);\n@@ -322,0 +345,8 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n+  virtual BasicType bt() const {\n+    return T_INT;\n+  }\n+\n@@ -327,0 +358,24 @@\n+class LongCountedLoopNode : public BaseCountedLoopNode {\n+public:\n+  LongCountedLoopNode(Node *entry, Node *backedge)\n+    : BaseCountedLoopNode(entry, backedge) {\n+    init_class_id(Class_LongCountedLoop);\n+  }\n+\n+  virtual int Opcode() const;\n+\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n+\n+  virtual BasicType bt() const {\n+    return T_LONG;\n+  }\n+\n+  LongCountedLoopEndNode* loopexit_or_null() const { return (LongCountedLoopEndNode*) BaseCountedLoopNode::loopexit_or_null(); }\n+  LongCountedLoopEndNode* loopexit() const { return (LongCountedLoopEndNode*) BaseCountedLoopNode::loopexit(); }\n+  jlong   stride_con() const;\n+};\n+\n+\n@@ -330,1 +385,2 @@\n-class CountedLoopEndNode : public IfNode {\n+\n+class BaseCountedLoopEndNode : public IfNode {\n@@ -333,4 +389,3 @@\n-\n-  CountedLoopEndNode( Node *control, Node *test, float prob, float cnt )\n-    : IfNode( control, test, prob, cnt) {\n-    init_class_id(Class_CountedLoopEnd);\n+  BaseCountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : IfNode(control, test, prob, cnt) {\n+    init_class_id(Class_BaseCountedLoopEnd);\n@@ -338,1 +393,0 @@\n-  virtual int Opcode() const;\n@@ -341,9 +395,8 @@\n-  Node *incr() const                { Node *tmp = cmp_node(); return (tmp && tmp->req()==3) ? tmp->in(1) : NULL; }\n-  Node *limit() const               { Node *tmp = cmp_node(); return (tmp && tmp->req()==3) ? tmp->in(2) : NULL; }\n-  Node *stride() const              { Node *tmp = incr    (); return (tmp && tmp->req()==3) ? tmp->in(2) : NULL; }\n-  Node *init_trip() const           { Node *tmp = phi     (); return (tmp && tmp->req()==3) ? tmp->in(1) : NULL; }\n-  int stride_con() const;\n-  bool stride_is_con() const        { Node *tmp = stride  (); return (tmp != NULL && tmp->is_Con()); }\n-  BoolTest::mask test_trip() const  { return in(TestValue)->as_Bool()->_test._test; }\n-  PhiNode *phi() const {\n-    Node *tmp = incr();\n+  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n+  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n+  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n+  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n+  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != NULL && tmp->is_Con()); }\n+\n+  PhiNode* phi() const {\n+    Node* tmp = incr();\n@@ -358,1 +411,2 @@\n-  CountedLoopNode *loopnode() const {\n+\n+  BaseCountedLoopNode* loopnode() const {\n@@ -366,3 +420,3 @@\n-    Node *ln = iv_phi->in(0);\n-    if (ln->is_CountedLoop() && ln->as_CountedLoop()->loopexit_or_null() == this) {\n-      return (CountedLoopNode*)ln;\n+    Node* ln = iv_phi->in(0);\n+    if (!ln->is_BaseCountedLoop() || ln->as_BaseCountedLoop()->loopexit_or_null() != this) {\n+      return NULL;\n@@ -370,1 +424,37 @@\n-    return NULL;\n+    if (!ln->operates_on(bt(), true)) {\n+      return NULL;\n+    }\n+    return ln->as_BaseCountedLoop();\n+  }\n+\n+  BoolTest::mask test_trip() const  { return in(TestValue)->as_Bool()->_test._test; }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n+  jlong stride_con() const;\n+  virtual BasicType bt() const = 0;\n+\n+  static BaseCountedLoopEndNode* make(Node* control, Node* test, float prob, float cnt, BasicType bt);\n+};\n+\n+class CountedLoopEndNode : public BaseCountedLoopEndNode {\n+public:\n+\n+  CountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : BaseCountedLoopEndNode(control, test, prob, cnt) {\n+    init_class_id(Class_CountedLoopEnd);\n+  }\n+  virtual int Opcode() const;\n+\n+  CountedLoopNode* loopnode() const {\n+    return (CountedLoopNode*) BaseCountedLoopEndNode::loopnode();\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n+\n+  virtual BasicType bt() const {\n+    return T_INT;\n@@ -378,0 +468,21 @@\n+class LongCountedLoopEndNode : public BaseCountedLoopEndNode {\n+public:\n+  LongCountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : BaseCountedLoopEndNode(control, test, prob, cnt) {\n+    init_class_id(Class_LongCountedLoopEnd);\n+  }\n+\n+  LongCountedLoopNode* loopnode() const {\n+    return (LongCountedLoopNode*) BaseCountedLoopEndNode::loopnode();\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n+  virtual int Opcode() const;\n+\n+  virtual BasicType bt() const {\n+    return T_LONG;\n+  }\n+};\n+\n@@ -379,1 +490,1 @@\n-inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {\n+inline BaseCountedLoopEndNode* BaseCountedLoopNode::loopexit_or_null() const {\n@@ -384,2 +495,8 @@\n-  return (CountedLoopEndNode*)\n-      (lexit->Opcode() == Op_CountedLoopEnd ? lexit : NULL);\n+  if (!lexit->is_BaseCountedLoopEnd()) {\n+    return NULL;\n+  }\n+  BaseCountedLoopEndNode* result = lexit->as_BaseCountedLoopEnd();\n+  if (!result->operates_on(bt(), true)) {\n+    return NULL;\n+  }\n+  return result;\n@@ -388,2 +505,2 @@\n-inline CountedLoopEndNode* CountedLoopNode::loopexit() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline BaseCountedLoopEndNode* BaseCountedLoopNode::loopexit() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -394,2 +511,2 @@\n-inline Node* CountedLoopNode::init_trip() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::init_trip() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -398,2 +515,2 @@\n-inline Node* CountedLoopNode::stride() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::stride() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -402,6 +519,3 @@\n-inline int CountedLoopNode::stride_con() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n-  return cle != NULL ? cle->stride_con() : 0;\n-}\n-inline bool CountedLoopNode::stride_is_con() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+\n+inline bool BaseCountedLoopNode::stride_is_con() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -410,2 +524,2 @@\n-inline Node* CountedLoopNode::limit() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::limit() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -414,2 +528,2 @@\n-inline Node* CountedLoopNode::incr() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::incr() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -418,2 +532,2 @@\n-inline Node* CountedLoopNode::phi() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::phi() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -827,2 +941,2 @@\n-  void set_early_ctrl( Node *n );\n-  void set_subtree_ctrl( Node *root );\n+  void set_early_ctrl(Node* n, bool update_body);\n+  void set_subtree_ctrl(Node* n, bool update_body);\n@@ -937,11 +1051,0 @@\n-  \/\/ Perform verification that the graph is valid.\n-  PhaseIdealLoop( PhaseIterGVN &igvn) :\n-    PhaseTransform(Ideal_Loop),\n-    _igvn(igvn),\n-    _verify_me(NULL),\n-    _verify_only(true),\n-    _dom_lca_tags(arena()),  \/\/ Thread::resource_area\n-    _nodes_required(UINT_MAX) {\n-    build_and_optimize(LoopOptsVerify);\n-  }\n-\n@@ -955,1 +1058,1 @@\n-  PhaseIdealLoop(PhaseIterGVN &igvn, LoopOptsMode mode) :\n+  PhaseIdealLoop(PhaseIterGVN& igvn, LoopOptsMode mode) :\n@@ -958,1 +1061,1 @@\n-    _verify_me(NULL),\n+    _verify_me(nullptr),\n@@ -962,0 +1065,1 @@\n+    assert(mode != LoopOptsVerify, \"wrong constructor to verify IdealLoop\");\n@@ -965,2 +1069,4 @@\n-  \/\/ Verify that verify_me made the same decisions as a fresh run.\n-  PhaseIdealLoop(PhaseIterGVN &igvn, const PhaseIdealLoop *verify_me) :\n+#ifndef PRODUCT\n+  \/\/ Verify that verify_me made the same decisions as a fresh run\n+  \/\/ or only verify that the graph is valid if verify_me is null.\n+  PhaseIdealLoop(PhaseIterGVN& igvn, const PhaseIdealLoop* verify_me = nullptr) :\n@@ -970,1 +1076,1 @@\n-    _verify_only(false),\n+    _verify_only(verify_me == nullptr),\n@@ -975,0 +1081,1 @@\n+#endif\n@@ -1060,1 +1167,2 @@\n-  bool is_counted_loop(Node* n, IdealLoopTree* &loop);\n+  bool is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt);\n+\n@@ -1062,1 +1170,1 @@\n-  bool is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new);\n+  bool transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new);\n@@ -1498,0 +1606,4 @@\n+\n+  void check_long_counted_loop(IdealLoopTree* loop, Node* x) NOT_DEBUG_RETURN;\n+\n+  LoopNode* create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head, LongCountedLoopEndNode* exit_test);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":189,"deletions":77,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-      set_early_ctrl(cd);\n+      set_early_ctrl(cd, false);\n@@ -525,1 +525,1 @@\n-        loop_n->_head->as_Loop()->is_valid_counted_loop() &&\n+        loop_n->_head->as_Loop()->is_valid_counted_loop(T_INT) &&\n@@ -1104,1 +1104,2 @@\n-  if ((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) {\n+  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) ||\n+      (n_blk->is_LongCountedLoop() && n->Opcode() == Op_AddL)) {\n@@ -2463,1 +2464,1 @@\n-  const TypeInt* ttype = NULL;\n+  const TypeInteger* ttype = NULL;\n@@ -2484,1 +2485,1 @@\n-                                &trunc1, &trunc2, &ttype);\n+                                &trunc1, &trunc2, &ttype, T_INT);\n@@ -2494,1 +2495,1 @@\n-                                &trunc1, &trunc2, &ttype);\n+                                &trunc1, &trunc2, &ttype, T_INT);\n@@ -3664,1 +3665,1 @@\n-  if (!loop->_head->as_Loop()->is_valid_counted_loop())\n+  if (!loop->_head->as_Loop()->is_valid_counted_loop(T_INT))\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-  void set_barrier_data(uint data) { _barrier = data; }\n+  void set_barrier_data(uint8_t data) { _barrier = data; }\n@@ -1034,0 +1034,1 @@\n+  bool _leaf_no_fp;             \/\/ Is this CallLeafNoFP?\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1306,1 +1306,3 @@\n-      mcall->as_MachCallRuntime()->_name = call->as_CallRuntime()->_name;\n+      MachCallRuntimeNode* mach_call_rt = mcall->as_MachCallRuntime();\n+      mach_call_rt->_name = call->as_CallRuntime()->_name;\n+      mach_call_rt->_leaf_no_fp = call->is_CallLeafNoFP();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3051,1 +3051,1 @@\n-    _barrier(0)\n+    _barrier_data(0)\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  uint8_t _barrier; \/\/ Bit field with barrier information\n+  uint8_t _barrier_data;   \/\/ Bit field with barrier information\n@@ -72,1 +72,1 @@\n-      _barrier(0) {\n+      _barrier_data(0) {\n@@ -81,1 +81,1 @@\n-      _barrier(0) {\n+      _barrier_data(0) {\n@@ -90,1 +90,1 @@\n-      _barrier(0) {\n+      _barrier_data(0) {\n@@ -147,2 +147,2 @@\n-  uint8_t barrier_data() { return _barrier; }\n-  void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }\n+  uint8_t barrier_data() { return _barrier_data; }\n+  void set_barrier_data(uint8_t barrier_data) { _barrier_data = barrier_data; }\n@@ -845,1 +845,1 @@\n-  uint8_t _barrier; \/\/ Bit field with barrier information\n+  uint8_t _barrier_data;        \/\/ Bit field with barrier information\n@@ -859,2 +859,2 @@\n-  uint8_t barrier_data() { return _barrier; }\n-  void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }\n+  uint8_t barrier_data() { return _barrier_data; }\n+  void set_barrier_data(uint8_t barrier_data) { _barrier_data = barrier_data; }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1519,0 +1519,10 @@\n+const TypeInteger* Node::find_integer_type(BasicType bt) const {\n+  if (this->is_Type()) {\n+    return this->as_Type()->type()->isa_integer(bt);\n+  } else if (this->is_Con()) {\n+    assert(is_Mach(), \"should be ConNode(TypeNode) or else a MachNode\");\n+    return this->bottom_type()->isa_integer(bt);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+class BaseCountedLoopNode;\n+class BaseCountedLoopEndNode;\n@@ -52,0 +54,1 @@\n+class CallLeafNoFPNode;\n@@ -92,0 +95,2 @@\n+class LongCountedLoopNode;\n+class LongCountedLoopEndNode;\n@@ -636,0 +641,1 @@\n+              DEFINE_CLASS_ID(CallLeafNoFP,     CallLeaf, 0)\n@@ -648,1 +654,3 @@\n-          DEFINE_CLASS_ID(CountedLoopEnd,         If, 0)\n+          DEFINE_CLASS_ID(BaseCountedLoopEnd,     If, 0)\n+            DEFINE_CLASS_ID(CountedLoopEnd,       BaseCountedLoopEnd, 0)\n+            DEFINE_CLASS_ID(LongCountedLoopEnd,   BaseCountedLoopEnd, 1)\n@@ -725,1 +733,3 @@\n-        DEFINE_CLASS_ID(CountedLoop,         Loop, 1)\n+        DEFINE_CLASS_ID(BaseCountedLoop,     Loop, 1)\n+          DEFINE_CLASS_ID(CountedLoop,       BaseCountedLoop, 0)\n+          DEFINE_CLASS_ID(LongCountedLoop,   BaseCountedLoop, 1)\n@@ -829,0 +839,2 @@\n+  DEFINE_CLASS_QUERY(BaseCountedLoop)\n+  DEFINE_CLASS_QUERY(BaseCountedLoopEnd)\n@@ -836,0 +848,1 @@\n+  DEFINE_CLASS_QUERY(CallLeafNoFP)\n@@ -867,0 +880,2 @@\n+  DEFINE_CLASS_QUERY(LongCountedLoop)\n+  DEFINE_CLASS_QUERY(LongCountedLoopEnd)\n@@ -1113,0 +1128,1 @@\n+  const TypeInteger* find_integer_type(BasicType bt) const;\n@@ -1126,0 +1142,5 @@\n+  jlong get_integer_as_long(BasicType bt) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    guarantee(t != NULL, \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n@@ -1235,0 +1256,6 @@\n+public:\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    Unimplemented();\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1753,3 +1753,1 @@\n-#if 0 \/\/ new assert, since moved below \"if (C->failing())\", but always triggers in Valhalla\n-      assert(!is_mcall || (call_returns[block->_pre_order] <= (uint) current_offset), \"ret_addr_offset() not within emitted code\");\n-#endif\n+\n@@ -1763,0 +1761,4 @@\n+#if 0 \/\/ new assert, always triggers in Valhalla\n+      assert(!is_mcall || (call_returns[block->_pre_order] <= (uint)current_offset),\n+             \"ret_addr_offset() not within emitted code\");\n+#endif\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -790,0 +790,10 @@\n+ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+  if (bt == T_INT) {\n+    jint int_con = (jint)l;\n+    assert(((long)int_con) == l, \"not an int\");\n+    return intcon(int_con);\n+  }\n+  assert(bt == T_LONG, \"not an integer\");\n+  return longcon(l);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1314,1 +1314,2 @@\n-                                ch, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) \/* mismatched *\/);\n+                                ch, bt, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+                                false \/* unaligned *\/, (bt != T_BYTE) \/* mismatched *\/);\n@@ -1352,1 +1353,2 @@\n-                            sign, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) \/* mismatched *\/);\n+                            sign, bt, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+                            false \/* unaligned *\/, (bt != T_BYTE) \/* mismatched *\/);\n@@ -1545,1 +1547,2 @@\n-      __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, true \/* mismatched *\/);\n+      __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+               true \/* mismatched *\/);\n@@ -1632,1 +1635,2 @@\n-    __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, true \/* mismatched *\/);\n+    __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+             true \/* mismatched *\/);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,0 +118,12 @@\n+SubNode* SubNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new SubINode(in1, in2);\n+    case T_LONG:\n+      return new SubLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+\n+  static SubNode* make(Node* in1, Node* in2, BasicType bt);\n@@ -151,0 +153,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -161,0 +167,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT && signed_int;\n+  }\n@@ -172,0 +182,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT && !signed_int;\n+  }\n@@ -204,0 +218,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG && signed_int;\n+  }\n@@ -213,0 +231,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG && !signed_int;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-void Type::check_symmetrical(const Type *t, const Type *mt) const {\n+void Type::check_symmetrical(const Type* t, const Type* mt) const {\n@@ -887,1 +887,9 @@\n-  assert(mt == t->xmeet(this), \"meet not commutative\");\n+  const Type* mt2 = t->xmeet(this);\n+  if (mt != mt2) {\n+    tty->print_cr(\"=== Meet Not Commutative ===\");\n+    tty->print(\"t           = \");   t->dump(); tty->cr();\n+    tty->print(\"this        = \");      dump(); tty->cr();\n+    tty->print(\"t meet this = \"); mt2->dump(); tty->cr();\n+    tty->print(\"this meet t = \");  mt->dump(); tty->cr();\n+    fatal(\"meet not commutative\");\n+  }\n@@ -889,2 +897,2 @@\n-  const Type *t2t    = dual_join->xmeet(t->_dual);\n-  const Type *t2this = dual_join->xmeet(this->_dual);\n+  const Type* t2t    = dual_join->xmeet(t->_dual);\n+  const Type* t2this = dual_join->xmeet(this->_dual);\n@@ -896,1 +904,1 @@\n-  if( !interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n+  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n@@ -909,1 +917,1 @@\n-    fatal(\"meet not symmetric\" );\n+    fatal(\"meet not symmetric\");\n@@ -1421,0 +1429,16 @@\n+jlong TypeInteger::get_con_as_long(BasicType bt) const {\n+  if (bt == T_INT) {\n+    return is_int()->get_con();\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return is_long()->get_con();\n+}\n+\n+const TypeInteger* TypeInteger::bottom(BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::INT;\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::LONG;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -312,1 +312,0 @@\n-  const TypeInteger* isa_integer() const;\n@@ -572,0 +571,2 @@\n+\n+  static const TypeInteger* bottom(BasicType type);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,6 +222,13 @@\n-  for (DUIterator_Fast imax, i = vec_box->fast_outs(imax); i < imax; i++) {\n-    Node* use = vec_box->fast_out(i);\n-    if (use->is_SafePoint()) {\n-      SafePointNode* sfpt = use->as_SafePoint();\n-      if (!sfpt->is_Call() || !sfpt->as_Call()->has_non_debug_use(vec_box)) {\n-        safepoints.push(sfpt);\n+  Unique_Node_List worklist(C->comp_arena());\n+  worklist.push(vec_box);\n+  while (worklist.size() > 0) {\n+    Node* n = worklist.pop();\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* use = n->fast_out(i);\n+      if (use->is_SafePoint()) {\n+        SafePointNode* sfpt = use->as_SafePoint();\n+        if (!sfpt->is_Call() || !sfpt->as_Call()->has_non_debug_use(n)) {\n+          safepoints.push(sfpt);\n+        }\n+      } else if (use->is_ConstraintCast()) {\n+        worklist.push(use); \/\/ reversed version of Node::uncast()\n@@ -254,5 +261,7 @@\n-    \/\/ to the allocated object with \"sobj\"\n-    int start = jvms->debug_start();\n-    int end   = jvms->debug_end();\n-    sfpt->replace_edges_in_range(vec_box, sobj, start, end);\n-\n+    \/\/ to the allocated object with vector value.\n+    for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n+      Node* debug = sfpt->in(i);\n+      if (debug != NULL && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n+        sfpt->set_req(i, sobj);\n+      }\n+    }\n@@ -322,1 +331,1 @@\n-    assert(value->as_Vector()->bottom_type()->is_vect()->element_basic_type() == bt,\n+    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n@@ -383,1 +392,2 @@\n-    BasicType bt = vec_unbox->vect_type()->element_basic_type();\n+    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n+    BasicType bt = vt->element_basic_type();\n@@ -422,1 +432,0 @@\n-    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n@@ -435,2 +444,1 @@\n-    if (is_vector_mask(from_kls) && masktype != T_BOOLEAN) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect mask type consistency\");\n+    if (is_vector_mask(from_kls)) {\n@@ -442,1 +450,1 @@\n-      } else if (elem_bt != T_BYTE) {\n+      } else {\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -259,5 +259,5 @@\n-  JvmtiTagMap* tag_map_to_deallocate = _tag_map;\n-  set_tag_map(NULL);\n-  \/\/ A tag map can be big, deallocate it now\n-  if (tag_map_to_deallocate != NULL) {\n-    delete tag_map_to_deallocate;\n+  JvmtiTagMap* tag_map_to_clear = tag_map_acquire();\n+  \/\/ A tag map can be big, clear it now to save memory until\n+  \/\/ the destructor runs.\n+  if (tag_map_to_clear != NULL) {\n+    tag_map_to_clear->clear();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-  assert(is_signature_polymorphic_intrinsic(iid), \"%d %s\", iid, vmIntrinsics::name_at(iid));\n+  assert(is_signature_polymorphic_intrinsic(iid), \"%d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -434,1 +434,1 @@\n-    fatal(\"unexpected intrinsic id: %d %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic id: %d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -461,1 +461,1 @@\n-    fatal(\"unexpected intrinsic id: %d %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic id: %d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -305,1 +305,0 @@\n-  os::init_random(seed);\n@@ -1062,1 +1061,1 @@\n-  BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);\n+  BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg, false);\n@@ -1908,1 +1907,1 @@\n-  bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);\n+  enum CompileCommand option = CompilerOracle::string_to_option(flag_name);\n@@ -1910,1 +1909,7 @@\n-  return result;\n+  if (option == CompileCommand::Unknown) {\n+    return false;\n+  }\n+  if (!CompilerOracle::option_matches_type(option, *value)) {\n+    return false;\n+  }\n+  return CompilerOracle::has_option_value(mh, option, *value);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1743,4 +1744,1 @@\n-  if (deoptee_thread != thread) {\n-    \/\/ Process stack of deoptee thread as we will access oops during object deoptimization.\n-    StackWatermarkSet::start_processing(deoptee_thread, StackWatermarkKind::gc);\n-  }\n+  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -732,0 +732,16 @@\n+inline jlong max_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_jlong;\n+}\n+\n+inline jlong min_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return min_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return min_jlong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2224,0 +2224,3 @@\n+            public void addExports(Module m, String pn) {\n+                m.implAddExports(pn);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.Function;\n@@ -391,4 +392,6 @@\n-            if (member.isField())\n-                updateForm(preparedFieldLambdaForm(member));\n-            else\n-                updateForm(preparedLambdaForm(member));\n+            updateForm(new Function<>() {\n+                public LambdaForm apply(LambdaForm oldForm) {\n+                    return (member.isField() ? preparedFieldLambdaForm(member)\n+                                             : preparedLambdaForm(member));\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -74,1 +75,0 @@\n-    private static final String NAME_FIELD_IMPL_METHOD = \"protectedImplMethod\";\n@@ -79,1 +79,0 @@\n-    private static final String DESCR_METHOD_HANDLE = \"Ljava\/lang\/invoke\/MethodHandle;\";\n@@ -97,0 +96,3 @@\n+    \/\/ condy to load implMethod from class data\n+    private static final ConstantDynamic implMethodCondy;\n+\n@@ -104,0 +106,6 @@\n+\n+        \/\/ condy to load implMethod from class data\n+        MethodType classDataMType = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n+        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n+                                         classDataMType.descriptorString(), false);\n+        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm);\n@@ -364,8 +372,0 @@\n-        if (useImplMethodHandle) {\n-            FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_STATIC,\n-                                            NAME_FIELD_IMPL_METHOD,\n-                                            DESCR_METHOD_HANDLE,\n-                                            null, null);\n-            fv.visitEnd();\n-        }\n-\n@@ -397,1 +397,1 @@\n-            Lookup lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+            Lookup lookup;\n@@ -406,2 +406,4 @@\n-                MethodHandle mh = lookup.findStaticSetter(lookup.lookupClass(), NAME_FIELD_IMPL_METHOD, MethodHandle.class);\n-                mh.invokeExact(implMethod);\n+                lookup = caller.defineHiddenClassWithClassData(classBytes, implMethod, !disableEagerInitialization,\n+                                                               NESTMATE, STRONG);\n+            } else {\n+                lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n@@ -557,2 +559,1 @@\n-                visitVarInsn(ALOAD, 0);\n-                visitFieldInsn(GETSTATIC, lambdaClassName, NAME_FIELD_IMPL_METHOD, DESCR_METHOD_HANDLE);\n+                visitLdcInsn(implMethodCondy);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -508,0 +508,3 @@\n+        if (customized == mh) {\n+            return this;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -844,12 +844,0 @@\n-        \/\/ Customize target if counting happens for too long.\n-        private int invocations = CUSTOMIZE_THRESHOLD;\n-        private void maybeCustomizeTarget() {\n-            int c = invocations;\n-            if (c >= 0) {\n-                if (c == 1) {\n-                    target.customize();\n-                }\n-                invocations = c - 1;\n-            }\n-        }\n-\n@@ -858,1 +846,1 @@\n-            maybeCustomizeTarget();\n+            target.maybeCustomize(); \/\/ customize if counting happens for too long\n@@ -875,1 +863,1 @@\n-             CountingWrapper wrapper = (CountingWrapper) o1;\n+             final CountingWrapper wrapper = (CountingWrapper) o1;\n@@ -878,3 +866,6 @@\n-                 LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);\n-                 lform.compileToBytecode(); \/\/ speed up warmup by avoiding LF interpretation again after transition\n-                 wrapper.updateForm(lform);\n+                 wrapper.updateForm(new Function<>() {\n+                     public LambdaForm apply(LambdaForm oldForm) {\n+                         LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);\n+                         lform.compileToBytecode(); \/\/ speed up warmup by avoiding LF interpretation again after transition\n+                         return lform;\n+                     }});\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -686,2 +687,4 @@\n-     * A convenient method for LambdaForms to get the class data of a given class.\n-     * LambdaForms cannot use condy via MethodHandles.classData\n+     * Returns the class data set by the VM in the Class::classData field.\n+     *\n+     * This is also invoked by LambdaForms as it cannot use condy via\n+     * MethodHandles.classData due to bootstrapping issue.\n@@ -690,0 +693,1 @@\n+        UNSAFE.ensureClassInitialized(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n@@ -45,0 +44,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -104,0 +104,2 @@\n+     * This lookup object is created by the original lookup class\n+     * and has the {@link Lookup#ORIGINAL ORIGINAL} bit set.\n@@ -110,1 +112,2 @@\n-     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}\n+     * {@linkplain Lookup#ORIGINAL original} and\n+     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}.\n@@ -204,2 +207,2 @@\n-     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} and\n-     * {@code null} previous lookup class.\n+     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}\n+     * with {@code null} previous lookup class.\n@@ -209,2 +212,4 @@\n-     * the lookup class of the caller as the new previous lookup class and\n-     * drops {@code MODULE} access from the full privilege access.\n+     * the lookup class of the caller as the new previous lookup class with\n+     * {@code PRIVATE} access but no {@code MODULE} access.\n+     * <p>\n+     * The resulting {@code Lookup} object has no {@code ORIGINAL} access.\n@@ -235,1 +240,2 @@\n-        if (!caller.hasFullPrivilegeAccess())\n+        int requireAccess = Lookup.PRIVATE|Lookup.MODULE;\n+        if ((caller.lookupModes() & requireAccess) != requireAccess)\n@@ -245,1 +251,1 @@\n-        int newModes = Lookup.FULL_POWER_MODES;\n+        int newModes = Lookup.FULL_POWER_MODES & ~Lookup.ORIGINAL;\n@@ -273,1 +279,1 @@\n-     * of the specified {@code Lookup} object, or {@code null}.\n+     * of the given {@code caller} lookup object, or {@code null}.\n@@ -275,2 +281,2 @@\n-     * <p> Classes can be created with class data by calling\n-     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)\n+     * <p> A hidden class with class data can be created by calling\n+     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n@@ -278,5 +284,8 @@\n-     * A hidden class with a class data behaves as if the hidden class\n-     * has a private static final unnamed field pre-initialized with\n-     * the class data and this method is equivalent as if calling\n-     * {@link ConstantBootstraps#getStaticFinal(Lookup, String, Class)} to\n-     * obtain the value of such field corresponding to the class data.\n+     * This method will cause the static class initializer of the lookup\n+     * class of the given {@code caller} lookup object be executed if\n+     * it has not been initialized.\n+     *\n+     * <p> A hidden class created by {@link Lookup#defineHiddenClass(byte[], boolean, Lookup.ClassOption...)\n+     * Lookup::defineHiddenClass} and non-hidden classes have no class data.\n+     * {@code null} is returned if this method is called on the lookup object\n+     * on these classes.\n@@ -285,2 +294,2 @@\n-     * must have {@link Lookup#ORIGINAL ORIGINAL} access in order to retrieve\n-     * the class data.\n+     * must have {@linkplain Lookup#ORIGINAL original access}\n+     * in order to retrieve the class data.\n@@ -291,2 +300,2 @@\n-     * example that can be {@code List.of(o1, o2, o3....)} containing more than\n-     * one live object.  The class data is accessible only to the lookup object\n+     * example that can be {@code Class} or {@code MethodHandle} object.\n+     * The class data is accessible only to the lookup object\n@@ -294,1 +303,1 @@\n-     * in the same nest.  If a framework passes security sensitive live objects\n+     * in the same nest.  If a framework passes security sensitive objects\n@@ -297,2 +306,2 @@\n-     * the live objects in private fields which are accessible to other\n-     * nestmates.\n+     * the class data in private static field(s) which are accessible to\n+     * other nestmates.\n@@ -303,1 +312,2 @@\n-     * @param name ignored\n+     * @param name must be {@link ConstantDescs#DEFAULT_NAME}\n+     *             ({@code \"_\"})\n@@ -307,0 +317,1 @@\n+     * @throws IllegalArgumentException if name is not {@code \"_\"}\n@@ -308,1 +319,1 @@\n-     * original caller access\n+     * {@linkplain Lookup#ORIGINAL original} access\n@@ -310,3 +321,90 @@\n-     * the specified {@code type}\n-     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)\n-     * @since 15\n+     * the given {@code type}\n+     * @throws NullPointerException if {@code caller} or {@code type} argument\n+     * is {@code null}\n+     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n+     * @see MethodHandles#classDataAt(Lookup, String, Class, int)\n+     * @since 16\n+     * @jvms 5.5 Initialization\n+     *\/\n+     public static <T> T classData(Lookup caller, String name, Class<T> type) throws IllegalAccessException {\n+         Objects.requireNonNull(caller);\n+         Objects.requireNonNull(type);\n+         if (!ConstantDescs.DEFAULT_NAME.equals(name)) {\n+             throw new IllegalArgumentException(\"name must be \\\"_\\\": \" + name);\n+         }\n+\n+         if ((caller.lookupModes() & Lookup.ORIGINAL) != Lookup.ORIGINAL)  {\n+             throw new IllegalAccessException(caller + \" does not have ORIGINAL access\");\n+         }\n+\n+         Object classdata = MethodHandleNatives.classData(caller.lookupClass());\n+         if (classdata == null) return null;\n+\n+         try {\n+             return BootstrapMethodInvoker.widenAndCast(classdata, type);\n+         } catch (RuntimeException|Error e) {\n+             throw e; \/\/ let CCE and other runtime exceptions through\n+         } catch (Throwable e) {\n+             throw new InternalError(e);\n+         }\n+    }\n+\n+    \/**\n+     * Returns the element at the specified index in the\n+     * {@linkplain #classData(Lookup, String, Class) class data},\n+     * if the class data associated with the lookup class\n+     * of the given {@code caller} lookup object is a {@code List}.\n+     * If the class data is not present in this lookup class, this method\n+     * returns {@code null}.\n+     *\n+     * <p> A hidden class with class data can be created by calling\n+     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n+     * Lookup::defineHiddenClassWithClassData}.\n+     * This method will cause the static class initializer of the lookup\n+     * class of the given {@code caller} lookup object be executed if\n+     * it has not been initialized.\n+     *\n+     * <p> A hidden class created by {@link Lookup#defineHiddenClass(byte[], boolean, Lookup.ClassOption...)\n+     * Lookup::defineHiddenClass} and non-hidden classes have no class data.\n+     * {@code null} is returned if this method is called on the lookup object\n+     * on these classes.\n+     *\n+     * <p> The {@linkplain Lookup#lookupModes() lookup modes} for this lookup\n+     * must have {@linkplain Lookup#ORIGINAL original access}\n+     * in order to retrieve the class data.\n+     *\n+     * @apiNote\n+     * This method can be called as a bootstrap method for a dynamically computed\n+     * constant.  A framework can create a hidden class with class data, for\n+     * example that can be {@code List.of(o1, o2, o3....)} containing more than\n+     * one object and use this method to load one element at a specific index.\n+     * The class data is accessible only to the lookup object\n+     * created by the original caller but inaccessible to other members\n+     * in the same nest.  If a framework passes security sensitive objects\n+     * to a hidden class via class data, it is recommended to load the value\n+     * of class data as a dynamically computed constant instead of storing\n+     * the class data in private static field(s) which are accessible to other\n+     * nestmates.\n+     *\n+     * @param <T> the type to cast the result object to\n+     * @param caller the lookup context describing the class performing the\n+     * operation (normally stacked by the JVM)\n+     * @param name must be {@link java.lang.constant.ConstantDescs#DEFAULT_NAME}\n+     *             ({@code \"_\"})\n+     * @param type the type of the element at the given index in the class data\n+     * @param index index of the element in the class data\n+     * @return the element at the given index in the class data\n+     * if the class data is present; otherwise {@code null}\n+     * @throws IllegalArgumentException if name is not {@code \"_\"}\n+     * @throws IllegalAccessException if the lookup context does not have\n+     * {@linkplain Lookup#ORIGINAL original} access\n+     * @throws ClassCastException if the class data cannot be converted to {@code List}\n+     * or the element at the specified index cannot be converted to the given type\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * @throws NullPointerException if {@code caller} or {@code type} argument is\n+     * {@code null}; or if unboxing operation fails because\n+     * the element at the given index is {@code null}\n+     *\n+     * @since 16\n+     * @see #classData(Lookup, String, Class)\n+     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n@@ -314,3 +412,14 @@\n-    static <T> T classData(Lookup caller, String name, Class<T> type) throws IllegalAccessException {\n-        if (!caller.hasFullPrivilegeAccess()) {\n-            throw new IllegalAccessException(caller + \" does not have full privilege access\");\n+    public static <T> T classDataAt(Lookup caller, String name, Class<T> type, int index)\n+            throws IllegalAccessException\n+    {\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> classdata = (List<Object>)classData(caller, name, List.class);\n+        if (classdata == null) return null;\n+\n+        try {\n+            Object element = classdata.get(index);\n+            return BootstrapMethodInvoker.widenAndCast(element, type);\n+        } catch (RuntimeException|Error e) {\n+            throw e; \/\/ let specified exceptions and other runtime exceptions\/errors through\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n@@ -318,2 +427,0 @@\n-        Object classData = MethodHandleNatives.classData(caller.lookupClass);\n-        return type.cast(classData);\n@@ -639,2 +746,6 @@\n-     * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.  Such a lookup has\n-     * the following additional capability:\n+     * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.\n+     * <p style=\"font-size:smaller;\">\n+     * A lookup with <em>original access<\/em> ensures that this lookup is created by\n+     * the original lookup class and the bootstrap method invoked by the VM.\n+     * Such a lookup with original access also has private and module access\n+     * which has the following additional capability:\n@@ -644,0 +755,2 @@\n+     * <li>obtain the {@linkplain MethodHandles#classData(Lookup, String, Class)\n+     * class data} associated with the lookup class<\/li>\n@@ -814,0 +927,1 @@\n+     * <th style=\"text-align:center\">original<\/th>\n@@ -824,0 +938,1 @@\n+     * <td style=\"text-align:center\">ORI<\/td>\n@@ -834,0 +949,1 @@\n+     * <td><\/td>\n@@ -843,0 +959,1 @@\n+     * <td><\/td>\n@@ -852,0 +969,1 @@\n+     * <td><\/td>\n@@ -860,0 +978,1 @@\n+     * <td><\/td>\n@@ -864,0 +983,1 @@\n+     * <td><\/td>\n@@ -872,0 +992,1 @@\n+     * <td><\/td>\n@@ -882,0 +1003,1 @@\n+     * <td><\/td>\n@@ -891,0 +1013,1 @@\n+     * <td><\/td>\n@@ -900,0 +1023,1 @@\n+     * <td><\/td>\n@@ -905,0 +1029,1 @@\n+     * <td><\/td>\n@@ -914,0 +1039,1 @@\n+     * <td><\/td>\n@@ -923,0 +1049,1 @@\n+     * <td><\/td>\n@@ -932,0 +1059,1 @@\n+     * <td><\/td>\n@@ -940,0 +1068,1 @@\n+     * <td><\/td>\n@@ -943,0 +1072,1 @@\n+     * <td><\/td>\n@@ -951,0 +1081,1 @@\n+     * <td><\/td>\n@@ -963,0 +1094,1 @@\n+     * <td><\/td>\n@@ -969,0 +1101,1 @@\n+     * <td><\/td>\n@@ -979,0 +1112,1 @@\n+     * <td><\/td>\n@@ -987,0 +1121,1 @@\n+     * <td><\/td>\n@@ -995,0 +1130,1 @@\n+     * <td><\/td>\n@@ -1000,0 +1136,1 @@\n+     * <td><\/td>\n@@ -1009,0 +1146,1 @@\n+     * <td><\/td>\n@@ -1019,0 +1157,1 @@\n+     * <td><\/td>\n@@ -1027,0 +1166,1 @@\n+     * <td><\/td>\n@@ -1035,0 +1175,1 @@\n+     * <td><\/td>\n@@ -1040,0 +1181,1 @@\n+     * <td><\/td>\n@@ -1049,0 +1191,1 @@\n+     * <td><\/td>\n@@ -1058,0 +1201,1 @@\n+     * <td><\/td>\n@@ -1067,0 +1211,1 @@\n+     * <td><\/td>\n@@ -1075,0 +1220,1 @@\n+     * <td><\/td>\n@@ -1083,0 +1229,1 @@\n+     * <td><\/td>\n@@ -1091,0 +1238,1 @@\n+     * <td><\/td>\n@@ -1099,0 +1247,1 @@\n+     * <td><\/td>\n@@ -1107,0 +1256,1 @@\n+     * <td><\/td>\n@@ -1115,0 +1265,1 @@\n+     * <td><\/td>\n@@ -1123,0 +1274,1 @@\n+     * <td><\/td>\n@@ -1135,1 +1287,2 @@\n-     * <li>{@code PRO} indicates {@link #PROTECTED} bit set,\n+     * <li>{@code ORI} indicates {@link #ORIGINAL} bit set,\n+     *     {@code PRO} indicates {@link #PROTECTED} bit set,\n@@ -1220,1 +1373,4 @@\n-     * {@link #defineClass(byte[]) defineClass}\n+     * {@link #defineClass(byte[]) defineClass},\n+     * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass},\n+     * {@link #defineHiddenClassWithClassData(byte[], Object, boolean, ClassOption...)\n+     * defineHiddenClassWithClassData}\n@@ -1243,1 +1399,1 @@\n-     * {@linkplain #hasFullPrivilegeAccess() full privilege access},\n+     * {@linkplain #ORIGINAL original access},\n@@ -1354,2 +1510,18 @@\n-        private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);\n-        private static final int FULL_POWER_MODES = (ALL_MODES & ~UNCONDITIONAL);\n+        \/** A single-bit mask representing {@code original} access\n+         *  which may contribute to the result of {@link #lookupModes lookupModes}.\n+         *  The value is {@code 0x40}, which does not correspond meaningfully to\n+         *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.\n+         *\n+         *  <p>\n+         *  If this lookup mode is set, the {@code Lookup} object must be\n+         *  created by the original lookup class by calling\n+         *  {@link MethodHandles#lookup()} method or by a bootstrap method\n+         *  invoked by the VM.  The {@code Lookup} object with this lookup\n+         *  mode has {@linkplain #hasFullPrivilegeAccess() full privilege access}.\n+         *\n+         *  @since 16\n+         *\/\n+        public static final int ORIGINAL = PACKAGE << 3;\n+\n+        private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL | ORIGINAL);\n+        private static final int FULL_POWER_MODES = (ALL_MODES & ~UNCONDITIONAL);   \/\/ with original access\n@@ -1359,1 +1531,1 @@\n-         * Adjust PUBLIC => PUBLIC|MODULE|UNCONDITIONAL\n+         * Adjust PUBLIC => PUBLIC|MODULE|ORIGINAL|UNCONDITIONAL\n@@ -1363,1 +1535,1 @@\n-            mods &= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);\n+            mods &= (ALL_MODES - PACKAGE - MODULE - ORIGINAL - UNCONDITIONAL);\n@@ -1419,1 +1591,2 @@\n-         *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.\n+         *  {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)},\n+         *  and {@linkplain #ORIGINAL ORIGINAL (0x40)}.\n@@ -1476,0 +1649,2 @@\n+         * <li>If the new lookup class is different from the old lookup class,\n+         * i.e. {@link #ORIGINAL ORIGINAL} access is lost.\n@@ -1531,1 +1706,1 @@\n-            int newModes = (allowedModes & FULL_POWER_MODES);\n+            int newModes = (allowedModes & FULL_POWER_MODES) & ~ORIGINAL;\n@@ -1572,1 +1747,2 @@\n-         * {@link #PRIVATE PRIVATE}, or {@link #UNCONDITIONAL UNCONDITIONAL}.\n+         * {@link #PRIVATE PRIVATE}, {@link #ORIGINAL ORIGINAL}, or\n+         * {@link #UNCONDITIONAL UNCONDITIONAL}.\n@@ -1581,2 +1757,3 @@\n-         * {@link #PROTECTED PROTECTED} is always dropped and so the resulting lookup\n-         * mode will never have this access capability. When dropping {@code PACKAGE}\n+         * {@link #PROTECTED PROTECTED} and {@link #ORIGINAL ORIGINAL} are always\n+         * dropped and so the resulting lookup mode will never have these access\n+         * capabilities. When dropping {@code PACKAGE}\n@@ -1603,1 +1780,2 @@\n-         * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}\n+         * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE}, {@code ORIGINAL}\n+         * or {@code UNCONDITIONAL}\n@@ -1609,1 +1787,1 @@\n-            int newModes = oldModes & ~(modeToDrop | PROTECTED);\n+            int newModes = oldModes & ~(modeToDrop | PROTECTED | ORIGINAL);\n@@ -1616,0 +1794,1 @@\n+                case ORIGINAL:\n@@ -1908,1 +2087,3 @@\n-         * @return the {@code Lookup} object on the hidden class\n+         * @return the {@code Lookup} object on the hidden class,\n+         * with {@linkplain #ORIGINAL original} and\n+         * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege} access\n@@ -1961,5 +2142,5 @@\n-         * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}\n-         * as if the hidden class has a private static final unnamed field whose value\n-         * is initialized to {@code classData} right before the class initializer is\n-         * executed.  The newly created class is linked and initialized by the Java\n-         * Virtual Machine.\n+         * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, initialize, options)}\n+         * as if the hidden class is injected with a private static final <i>unnamed<\/i>\n+         * field which is initialized with the given {@code classData} at\n+         * the first instruction of the class initializer.\n+         * The newly created class is linked by the Java Virtual Machine.\n@@ -1968,1 +2149,16 @@\n-         * method can be used to retrieve the {@code classData}.\n+         * and {@link MethodHandles#classDataAt(Lookup, String, Class, int) MethodHandles::classDataAt}\n+         * methods can be used to retrieve the {@code classData}.\n+         *\n+         * @apiNote\n+         * A framework can create a hidden class with class data with one or more\n+         * objects and load the class data as dynamically-computed constant(s)\n+         * via a bootstrap method.  {@link MethodHandles#classData(Lookup, String, Class)\n+         * Class data} is accessible only to the lookup object created by the newly\n+         * defined hidden class but inaccessible to other members in the same nest\n+         * (unlike private static fields that are accessible to nestmates).\n+         * Care should be taken w.r.t. mutability for example when passing\n+         * an array or other mutable structure through the class data.\n+         * Changing any value stored in the class data at runtime may lead to\n+         * unpredictable behavior.\n+         * If the class data is a {@code List}, it is good practice to make it\n+         * unmodifiable for example via {@link List#of List::of}.\n@@ -1972,0 +2168,1 @@\n+         * @param initialize if {@code true} the class will be initialized.\n@@ -1973,1 +2170,3 @@\n-         * @return the {@code Lookup} object on the hidden class\n+         * @return the {@code Lookup} object on the hidden class,\n+         * with {@linkplain #ORIGINAL original} and\n+         * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege} access\n@@ -1993,1 +2192,1 @@\n-         * @since 15\n+         * @since 16\n@@ -1996,0 +2195,12 @@\n+         * @see MethodHandles#classData(Lookup, String, Class)\n+         * @see MethodHandles#classDataAt(Lookup, String, Class, int)\n+         * @jvms 4.2.1 Binary Class and Interface Names\n+         * @jvms 4.2.2 Unqualified Names\n+         * @jvms 4.7.28 The {@code NestHost} Attribute\n+         * @jvms 4.7.29 The {@code NestMembers} Attribute\n+         * @jvms 5.4.3.1 Class and Interface Resolution\n+         * @jvms 5.4.4 Access Control\n+         * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation\n+         * @jvms 5.4 Linking\n+         * @jvms 5.5 Initialization\n+         * @jls 12.7 Unloading of Classes and Interface\n@@ -1997,1 +2208,1 @@\n-        \/* package-private *\/ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)\n+        public Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, boolean initialize, ClassOption... options)\n@@ -2010,1 +2221,1 @@\n-                       .defineClassAsLookup(true, classData);\n+                       .defineClassAsLookup(initialize, classData);\n@@ -2241,2 +2452,0 @@\n-                \/\/ initialize must be true if classData is non-null\n-                assert classData == null || initialize == true;\n@@ -2298,1 +2507,2 @@\n-         * If none of the above cases apply, it is the case that full access\n+         * If none of the above cases apply, it is the case that\n+         * {@linkplain #hasFullPrivilegeAccess() full privilege access}\n@@ -2332,3 +2542,5 @@\n-            case FULL_POWER_MODES & (~PROTECTED):\n-            case FULL_POWER_MODES & ~(PROTECTED|MODULE):\n-                return cname + \"\/private\";\n+            case PUBLIC|PACKAGE|PRIVATE:\n+            case PUBLIC|MODULE|PACKAGE|PRIVATE:\n+                    return cname + \"\/private\";\n+            case PUBLIC|PACKAGE|PRIVATE|PROTECTED:\n+            case PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED:\n@@ -2336,2 +2548,1 @@\n-            case FULL_POWER_MODES & (~MODULE):\n-                return cname;\n+                    return cname;\n@@ -3442,1 +3653,1 @@\n-                if (!hasFullPrivilegeAccess() || callerClass != lookupClass())\n+                if ((lookupModes() & ORIGINAL) == 0 || callerClass != lookupClass())\n@@ -3509,1 +3720,1 @@\n-         * If this lookup object has full privilege access, then the caller class is the lookupClass.\n+         * If this lookup object has original full privilege access, then the caller class is the lookupClass.\n@@ -3513,1 +3724,1 @@\n-            if (MethodHandleNatives.isCallerSensitive(m) && !hasFullPrivilegeAccess()) {\n+            if (MethodHandleNatives.isCallerSensitive(m) && (lookupModes() & ORIGINAL) == 0) {\n@@ -3539,1 +3750,2 @@\n-         * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.\n+         * access all members that are allowed to the\n+         * {@linkplain #lookupClass() lookup class}.\n@@ -3560,2 +3772,2 @@\n-            boolean fullPowerLookup = hasFullPrivilegeAccess();\n-            if (!fullPowerLookup ||\n+            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n+            if (!fullPrivilegeLookup ||\n@@ -3567,1 +3779,1 @@\n-            if (!fullPowerLookup) {\n+            if (!fullPrivilegeLookup) {\n@@ -3575,1 +3787,5 @@\n-         * If this lookup object has full privilege access, then the caller class is the lookupClass.\n+         * If this lookup object has full privilege access except original access,\n+         * then the caller class is the lookupClass.\n+         *\n+         * Lookup object created by {@link MethodHandles#privateLookupIn(Class, Lookup)}\n+         * from the same module skips the security permission check.\n@@ -3587,2 +3803,2 @@\n-            boolean fullPowerLookup = hasFullPrivilegeAccess();\n-            if (!fullPowerLookup ||\n+            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n+            if (!fullPrivilegeLookup ||\n@@ -3595,1 +3811,1 @@\n-            if (!fullPowerLookup) {\n+            if (!fullPrivilegeLookup) {\n@@ -3601,1 +3817,1 @@\n-            if (!fullPowerLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && defc != refc) {\n@@ -3816,1 +4032,1 @@\n-            if (!boundCaller.hasFullPrivilegeAccess())\n+            if ((boundCaller.lookupModes() & ORIGINAL) == 0)\n@@ -3819,0 +4035,2 @@\n+            assert boundCaller.hasFullPrivilegeAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":299,"deletions":81,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -72,0 +73,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,0 +362,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -69,0 +70,1 @@\n+    @Stable\n@@ -77,0 +79,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -62,0 +63,2 @@\n+    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n+\n@@ -65,0 +68,2 @@\n+    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n+    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n@@ -78,0 +83,1 @@\n+    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n@@ -487,1 +493,1 @@\n-                visitField(Modifier.PRIVATE | Modifier.STATIC, pm.methodFieldName,\n+                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n@@ -496,1 +502,1 @@\n-\n+        generateLookupAccessor();\n@@ -628,0 +634,40 @@\n+    \/**\n+     * Generate the static lookup accessor method that returns the Lookup\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n+     * otherwise, IllegalAccessException is thrown\n+     *\/\n+    private void generateLookupAccessor() {\n+        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n+                new String[] { JL_ILLEGAL_ACCESS_EX });\n+        mv.visitCode();\n+        Label L_illegalAccess = new Label();\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n+                \"()Ljava\/lang\/Class;\", false);\n+        mv.visitLdcInsn(Type.getType(Proxy.class));\n+        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n+                \"()Z\", false);\n+        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n+        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n+                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n+        mv.visitInsn(ARETURN);\n+\n+        mv.visitLabel(L_illegalAccess);\n+        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n+                \"()Ljava\/lang\/String;\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n+                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        mv.visitInsn(ATHROW);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1479,0 +1479,1 @@\n+    @Deprecated(since = \"15\", forRemoval = true)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    private static final int ORIGINAL_ALLOWED = java.lang.invoke.MethodHandles.Lookup.ORIGINAL;\n@@ -102,1 +103,1 @@\n-        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);\n+        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED|ORIGINAL_ALLOWED)) == 0);\n@@ -192,1 +193,1 @@\n-        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);\n+        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED|ORIGINAL_ALLOWED)) == 0);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1614,0 +1614,4 @@\n+            \/\/ Currently, an InapplicableMethodException occurs.\n+            \/\/ If bestSoFar.kind was ABSENT_MTH, return an InapplicableSymbolError(kind is WRONG_MTH).\n+            \/\/ If bestSoFar.kind was HIDDEN(AccessError)\/WRONG_MTH\/WRONG_MTHS, return an InapplicableSymbolsError(kind is WRONG_MTHS).\n+            \/\/ See JDK-8255968 for more information.\n@@ -1617,0 +1621,10 @@\n+                case HIDDEN:\n+                    if (bestSoFar instanceof AccessError) {\n+                        \/\/ Add the JCDiagnostic of previous AccessError to the currentResolutionContext\n+                        \/\/ and construct InapplicableSymbolsError.\n+                        \/\/ Intentionally fallthrough.\n+                        currentResolutionContext.addInapplicableCandidate(((AccessError) bestSoFar).sym,\n+                                ((AccessError) bestSoFar).getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, null, null, site, null, argtypes, typeargtypes));\n+                    } else {\n+                        return bestSoFar;\n+                    }\n@@ -1624,3 +1638,25 @@\n-            return (bestSoFar.kind == ABSENT_MTH)\n-                ? new AccessError(env, site, sym)\n-                : bestSoFar;\n+            AccessError curAccessError = new AccessError(env, site, sym);\n+            JCDiagnostic curDiagnostic = curAccessError.getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, null, null, site, null, argtypes, typeargtypes);\n+            \/\/ Currently, an AccessError occurs.\n+            \/\/ If bestSoFar.kind was ABSENT_MTH, return an AccessError(kind is HIDDEN).\n+            \/\/ If bestSoFar.kind was HIDDEN(AccessError), WRONG_MTH, WRONG_MTHS, return an InapplicableSymbolsError(kind is WRONG_MTHS).\n+            \/\/ See JDK-8255968 for more information.\n+            if (bestSoFar.kind == ABSENT_MTH) {\n+                bestSoFar = curAccessError;\n+            } else if (bestSoFar.kind == WRONG_MTH) {\n+                \/\/ Add the JCDiagnostic of current AccessError to the currentResolutionContext\n+                \/\/ and construct InapplicableSymbolsError.\n+                currentResolutionContext.addInapplicableCandidate(sym, curDiagnostic);\n+                bestSoFar = new InapplicableSymbolsError(currentResolutionContext);\n+            } else if (bestSoFar.kind == WRONG_MTHS) {\n+                \/\/ Add the JCDiagnostic of current AccessError to the currentResolutionContext\n+                currentResolutionContext.addInapplicableCandidate(sym, curDiagnostic);\n+            } else if (bestSoFar.kind == HIDDEN && bestSoFar instanceof AccessError) {\n+                \/\/ Add the JCDiagnostics of previous and current AccessError to the currentResolutionContext\n+                \/\/ and construct InapplicableSymbolsError.\n+                currentResolutionContext.addInapplicableCandidate(((AccessError) bestSoFar).sym,\n+                        ((AccessError) bestSoFar).getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, null, null, site, null, argtypes, typeargtypes));\n+                currentResolutionContext.addInapplicableCandidate(sym, curDiagnostic);\n+                bestSoFar = new InapplicableSymbolsError(currentResolutionContext);\n+            }\n+            return bestSoFar;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import jdk.vm.ci.services.Services;\n@@ -390,0 +389,2 @@\n+         *\n+         * @param runtime\n@@ -391,1 +392,1 @@\n-        static void parse() {\n+        static void parse(HotSpotJVMCIRuntime runtime) {\n@@ -406,1 +407,1 @@\n-                        msg.format(\"Could not find option %s\", name);\n+                        msg.format(\"Error parsing JVMCI options: Could not find option %s\", name);\n@@ -413,1 +414,2 @@\n-                        throw new IllegalArgumentException(msg.toString());\n+                        msg.format(\"%nError: A fatal exception has occurred. Program will exit.%n\");\n+                        runtime.exitHotSpotWithMessage(1, msg.toString());\n@@ -542,1 +544,1 @@\n-        Option.parse();\n+        Option.parse(this);\n@@ -555,1 +557,1 @@\n-        compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();\n+        compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory(this);\n@@ -1167,2 +1169,2 @@\n-     * Informs HotSpot that no method whose module is in {@code modules} is to be compiled\n-     * with {@link #compileMethod}.\n+     * Informs HotSpot that no method whose module is in {@code modules} is to be compiled with\n+     * {@link #compileMethod}.\n@@ -1172,1 +1174,1 @@\n-    public void excludeFromJVMCICompilation(Module...modules) {\n+    public void excludeFromJVMCICompilation(Module... modules) {\n@@ -1185,0 +1187,11 @@\n+\n+    \/**\n+     * Writes a message to HotSpot's log stream and then calls {@link System#exit(int)} in HotSpot's\n+     * runtime.\n+     *\/\n+    JVMCIError exitHotSpotWithMessage(int status, String format, Object... args) {\n+        byte[] messageBytes = String.format(format, args).getBytes();\n+        compilerToVm.writeDebugOutput(messageBytes, 0, messageBytes.length, true, true);\n+        exitHotSpot(status);\n+        throw JVMCIError.shouldNotReachHere();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -879,2 +879,3 @@\n-     * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}\n-     * method.\n+     * @deprecated Use {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}\n+     * or {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, MethodHandles.Lookup.ClassOption...)}\n+     * instead.\n@@ -887,1 +888,2 @@\n-    @Deprecated(since = \"15\", forRemoval = false)\n+    @Deprecated(since = \"15\", forRemoval = true)\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-runtime\/ReservedStack\/ReservedStackTestCompiler.java 8256359 linux-aarch64\n@@ -261,2 +260,0 @@\n-vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted001\/TestDescription.java 8253916 linux-all\n-vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted004\/TestDescription.java 8253916 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}