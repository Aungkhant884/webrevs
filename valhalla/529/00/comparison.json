{"files":[{"patch":"@@ -521,1 +521,1 @@\n-                         vmClasses::ValueBootstrapMethods_klass(),\n+                         vmClasses::PrimitiveObjectMethods_klass(),\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  do_klass(ValueBootstrapMethods_klass,                 java_lang_invoke_ValueBootstrapMethods                ) \\\n+  do_klass(PrimitiveObjectMethods_klass,                java_lang_runtime_PrimitiveObjectMethods              ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -718,3 +718,3 @@\n-  template(java_lang_invoke_ValueBootstrapMethods, \"java\/lang\/invoke\/ValueBootstrapMethods\")                      \\\n-  template(isSubstitutable_name,                   \"isSubstitutable\")                                             \\\n-  template(inlineObjectHashCode_name,              \"inlineObjectHashCode\")                                        \\\n+  template(java_lang_runtime_PrimitiveObjectMethods,        \"java\/lang\/runtime\/PrimitiveObjectMethods\")           \\\n+  template(isSubstitutable_name,                            \"isSubstitutable\")                                    \\\n+  template(primitiveObjectHashCode_name,                    \"primitiveObjectHashCode\")                            \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-LatestMethodCache* Universe::_inline_type_hash_code_cache = NULL;\n+LatestMethodCache* Universe::_primitive_type_hash_code_cache = NULL;\n@@ -235,1 +235,1 @@\n-  _inline_type_hash_code_cache->metaspace_pointers_do(it);\n+  _primitive_type_hash_code_cache->metaspace_pointers_do(it);\n@@ -286,1 +286,1 @@\n-  _inline_type_hash_code_cache->serialize(f);\n+  _primitive_type_hash_code_cache->serialize(f);\n@@ -799,1 +799,1 @@\n-  Universe::_inline_type_hash_code_cache = new LatestMethodCache();\n+  Universe::_primitive_type_hash_code_cache = new LatestMethodCache();\n@@ -966,1 +966,1 @@\n-                          vmClasses::ValueBootstrapMethods_klass(),\n+                          vmClasses::PrimitiveObjectMethods_klass(),\n@@ -969,3 +969,3 @@\n-  initialize_known_method(_inline_type_hash_code_cache,\n-                          vmClasses::ValueBootstrapMethods_klass(),\n-                          vmSymbols::inlineObjectHashCode_name()->as_C_string(),\n+  initialize_known_method(_primitive_type_hash_code_cache,\n+                          vmClasses::PrimitiveObjectMethods_klass(),\n+                          vmSymbols::primitiveObjectHashCode_name()->as_C_string(),\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  static LatestMethodCache* _is_substitutable_cache;   \/\/ ValueBootstrapMethods.isSubstitutable() method\n-  static LatestMethodCache* _inline_type_hash_code_cache;  \/\/ ValueBootstrapMethods.inlineObjectHashCode() method\n+  static LatestMethodCache* _is_substitutable_cache;   \/\/ PrimitiveObjectMethods.isSubstitutable() method\n+  static LatestMethodCache* _primitive_type_hash_code_cache;  \/\/ PrimitiveObjectMethods.primitiveObjectHashCode() method\n@@ -266,1 +266,1 @@\n-  static Method*      inline_type_hash_code_method()  { return _inline_type_hash_code_cache->get_method(); }\n+  static Method*      primitive_type_hash_code_method()  { return _primitive_type_hash_code_cache->get_method(); }\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2287,1 +2287,1 @@\n-  \/\/ substitutability test. Delegate to ValueBootstrapMethods::isSubstitutable().\n+  \/\/ substitutability test. Delegate to PrimitiveObjectMethods::isSubstitutable().\n@@ -2302,1 +2302,1 @@\n-  ciMethod* subst_method = ciEnv::current()->ValueBootstrapMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n+  ciMethod* subst_method = ciEnv::current()->PrimitiveObjectMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n@@ -2312,1 +2312,1 @@\n-  \/\/ Test the return value of ValueBootstrapMethods::isSubstitutable()\n+  \/\/ Test the return value of PrimitiveObjectMethods::isSubstitutable()\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -611,1 +611,1 @@\n-      methodHandle method(THREAD, Universe::inline_type_hash_code_method());\n+      methodHandle method(THREAD, Universe::primitive_type_hash_code_method());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-      \/\/ a full substitutability test is required, calling ValueBootstrapMethods.isSubstitutable()\n+      \/\/ a full substitutability test is required, calling PrimitiveObjectMethods.isSubstitutable()\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1099,1 +1099,1 @@\n-    vmClasses::ValueBootstrapMethods_klass()->initialize(CHECK_NH);\n+    vmClasses::PrimitiveObjectMethods_klass()->initialize(CHECK_NH);\n@@ -1102,1 +1102,1 @@\n-    Method* is_subst = vmClasses::ValueBootstrapMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    Method* is_subst = vmClasses::PrimitiveObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.lang.reflect.Field;\n@@ -1506,0 +1507,10 @@\n+\n+            @Override\n+            public MethodHandle findStatic(Class<?> cls, String name, MethodType methodType) throws NoSuchMethodException, IllegalAccessException {\n+                return IMPL_LOOKUP.findStatic(cls, name, methodType);\n+            }\n+\n+            @Override\n+            public MethodHandle unreflectGetter(Field field) throws IllegalAccessException {\n+                return IMPL_LOOKUP.unreflectGetter(field);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,538 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.invoke;\n-\n-import sun.invoke.util.Wrapper;\n-import sun.security.action.GetIntegerAction;\n-import sun.security.action.GetPropertyAction;\n-\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.Objects;\n-import java.util.stream.Stream;\n-\n-import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n-import static java.lang.invoke.MethodHandles.*;\n-import static java.lang.invoke.MethodType.*;\n-import static java.lang.invoke.ValueBootstrapMethods.MethodHandleBuilder.*;\n-\n-\n-\/**\n- * Bootstrap methods for value types\n- *\/\n-public final class ValueBootstrapMethods {\n-    private ValueBootstrapMethods() {}\n-    private static final boolean VERBOSE =\n-        GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n-\n-    \/**\n-     * Makes a bootstrap method for the named operation for the given Class.\n-     *\n-     * @apiNote {@code c} parameter for testing purpose.  This method will be removed.\n-     *\n-     * @param caller    A lookup context\n-     * @param name      The name of the method to implement.\n-     * @param type      The expected signature of the {@code CallSite}\n-     * @param c         Class\n-     * @return a CallSite whose target can be used to perform the named operation\n-     *\/\n-    public static CallSite makeBootstrapMethod(MethodHandles.Lookup caller,\n-                                               String name,\n-                                               MethodType type,\n-                                               Class<?> c) {\n-        MethodHandles.Lookup lookup = caller;\n-        if (caller.lookupClass() != c) {\n-            lookup = new MethodHandles.Lookup(c);\n-        }\n-        return makeBootstrapMethod(lookup, name, type);\n-    }\n-\n-    \/**\n-     * Makes a bootstrap method for the named operation for the given Class.\n-     *\n-     * @param lookup    A lookup context\n-     * @param name      The name of the method to implement.\n-     * @param type      The expected signature of the {@code CallSite}\n-     * @return a CallSite whose target can be used to perform the named operation\n-     *\/\n-    public static CallSite makeBootstrapMethod(MethodHandles.Lookup lookup,\n-                                               String name,\n-                                               MethodType type) {\n-        return new ConstantCallSite(generateTarget(lookup, name, type));\n-    }\n-\n-    private static MethodHandle generateTarget(Lookup lookup, String name, MethodType methodType) {\n-        if (VERBOSE) {\n-            System.out.println(\"generate BSM for \" + lookup + \"::\" + name);\n-        }\n-        Class<?> valType = lookup.lookupClass().asValueType();\n-        switch (name) {\n-            case \"hashCode\":\n-                return inlineTypeHashCode(valType);\n-            case \"equals\":\n-                return substitutableInvoker(valType).asType(methodType);\n-            default:\n-                throw new IllegalArgumentException(name + \" not valid method name\");\n-        }\n-    }\n-\n-    static class MethodHandleBuilder {\n-        static MethodHandle[] getters(Class<?> type) {\n-            return getters(type, null);\n-        }\n-\n-        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {\n-            Lookup lookup = new MethodHandles.Lookup(type.asPrimaryType());\n-            \/\/ filter static fields\n-            Stream<MethodHandle> s = Arrays.stream(type.getDeclaredFields())\n-                .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-                .map(f -> {\n-                    try {\n-                        return lookup.unreflectGetter(f);\n-                    } catch (IllegalAccessException e) {\n-                        throw newLinkageError(e);\n-                    }\n-                });\n-            if (comparator != null) {\n-                s = s.sorted(comparator);\n-            }\n-            return s.toArray(MethodHandle[]::new);\n-        }\n-\n-        static MethodHandle primitiveEquals(Class<?> primitiveType) {\n-            int index = Wrapper.forPrimitiveType(primitiveType).ordinal();\n-            return EQUALS[index];\n-        }\n-\n-        static MethodHandle hashCodeForType(Class<?> type) {\n-            if (type.isPrimitive()) {\n-                int index = Wrapper.forPrimitiveType(type).ordinal();\n-                return HASHCODE[index];\n-            } else {\n-                return HASHCODE[Wrapper.OBJECT.ordinal()].asType(methodType(int.class, type));\n-            }\n-        }\n-\n-        \/*\n-         * Produces a MethodHandle that returns boolean if two instances\n-         * of the given reference type are substitutable.\n-         *\n-         * Two values of reference type are substitutable i== iff\n-         * 1. if o1 and o2 are both reference objects then o1 r== o2; or\n-         * 2. if o1 and o2 are both values then o1 v== o2\n-         *\n-         * At invocation time, it needs a dynamic check on the objects and\n-         * do the substitutability test if they are of a primitive type.\n-         *\/\n-        static MethodHandle referenceTypeEquals(Class<?> type) {\n-            return EQUALS[Wrapper.OBJECT.ordinal()].asType(methodType(boolean.class, type, type));\n-        }\n-\n-        static Class<?> fieldType(MethodHandle getter) {\n-            Class<?> ftype = getter.type().returnType();\n-            return ftype;\n-        }\n-\n-        \/*\n-         * Produces a MethodHandle that returns boolean if two value instances\n-         * of the given primitive class are substitutable.\n-         *\/\n-        static MethodHandle inlineTypeEquals(Class<?> type) {\n-            assert type.isValueType();\n-            MethodType mt = methodType(boolean.class, type, type);\n-            MethodHandle[] getters = getters(type, TYPE_SORTER);\n-            MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n-            MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n-            MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n-            for (MethodHandle getter : getters) {\n-                Class<?> ftype = fieldType(getter);\n-                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n-                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n-                accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n-            }\n-            \/\/ if both arguments are null, return true;\n-            \/\/ otherwise return accumulator;\n-            return guardWithTest(IS_NULL.asType(mt),\n-                                 instanceTrue,\n-                                 guardWithTest(IS_SAME_INLINE_CLASS.asType(mt),\n-                                               accumulator,\n-                                               instanceFalse));\n-        }\n-\n-        static MethodHandle inlineTypeHashCode(Class<?> type) {\n-            assert type.isValueType();\n-            MethodHandle target = dropArguments(constant(int.class, SALT), 0, type);\n-            MethodHandle cls = dropArguments(constant(Class.class, type),0, type);\n-            MethodHandle classHashCode = filterReturnValue(cls, hashCodeForType(Class.class));\n-            MethodHandle combiner = filterArguments(HASH_COMBINER, 0, target, classHashCode);\n-            \/\/ int v = SALT * 31 + type.hashCode();\n-            MethodHandle init = permuteArguments(combiner, target.type(), 0, 0);\n-            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n-            MethodHandle iterations = dropArguments(constant(int.class, getters.length), 0, type);\n-            MethodHandle[] hashers = new MethodHandle[getters.length];\n-            for (int i=0; i < getters.length; i++) {\n-                MethodHandle getter = getters[i];\n-                Class<?> ftype = fieldType(getter);\n-\n-                \/\/ For primitive type or reference type, this calls Objects::hashCode.\n-                \/\/ If the instance is of primitive type and the hashCode method is not\n-                \/\/ overridden, VM will call inlineObjectHashCode to compute the\n-                \/\/ hash code.\n-                MethodHandle hasher = hashCodeForType(ftype);\n-                hashers[i] = filterReturnValue(getter, hasher);\n-            }\n-\n-            \/\/ for (int i=0; i < getters.length; i++) {\n-            \/\/   v = computeHash(v, i, a);\n-            \/\/ }\n-            MethodHandle body = COMPUTE_HASH.bindTo(hashers)\n-                    .asType(methodType(int.class, int.class, int.class, type));\n-            return countedLoop(iterations, init, body);\n-        }\n-\n-        \/\/ ------ utility methods ------\n-        private static boolean eq(byte a, byte b)       { return a == b; }\n-        private static boolean eq(short a, short b)     { return a == b; }\n-        private static boolean eq(char a, char b)       { return a == b; }\n-        private static boolean eq(int a, int b)         { return a == b; }\n-        private static boolean eq(long a, long b)       { return a == b; }\n-        private static boolean eq(float a, float b)     { return Float.compare(a, b) == 0; }\n-        private static boolean eq(double a, double b)   { return Double.compare(a, b) == 0; }\n-        private static boolean eq(boolean a, boolean b) { return a == b; }\n-        private static boolean eq(Object a, Object b)   {\n-            if (a == null && b == null) return true;\n-            if (a == null || b == null) return false;\n-            if (a.getClass() != b.getClass()) return false;\n-            return a.getClass().isPrimitiveClass() ? inlineValueEq(a, b) : (a == b);\n-        }\n-\n-        \/*\n-         * Returns true if two values are substitutable.\n-         *\/\n-        private static boolean inlineValueEq(Object a, Object b) {\n-            assert a != null && b != null && isSamePrimitiveClass(a, b);\n-            try {\n-                Class<?> type = a.getClass().asValueType();\n-                return (boolean) substitutableInvoker(type).invoke(type.cast(a), type.cast(b));\n-            } catch (Error|RuntimeException e) {\n-                throw e;\n-            } catch (Throwable e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-\n-        private static boolean isNull(Object a, Object b) {\n-            \/\/ avoid acmp that will call isSubstitutable\n-            if (a != null) return false;\n-            if (b != null) return false;\n-            return true;\n-        }\n-\n-        \/*\n-         * Returns true if the given objects are of the same primitive class.\n-         *\n-         * Two objects are of the same primitive class iff:\n-         * 1. a != null and b != null\n-         * 2. the declaring class of a and b is the same primitive class\n-         *\/\n-        private static boolean isSamePrimitiveClass(Object a, Object b) {\n-            if (a == null || b == null) return false;\n-\n-            return a.getClass().isPrimitiveClass() && a.getClass() == b.getClass();\n-        }\n-\n-        private static int hashCombiner(int accumulator, int value) {\n-            return accumulator * 31 + value;\n-        }\n-\n-        private static int computeHashCode(MethodHandle[] hashers, int v, int i, Object o) {\n-            try {\n-                int hc = (int)hashers[i].invoke(o);\n-                return hashCombiner(v, hc);\n-            } catch (Error|RuntimeException e) {\n-                throw e;\n-            } catch (Throwable e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-\n-        private static final MethodHandle[] EQUALS = initEquals();\n-        private static final MethodHandle[] HASHCODE = initHashCode();\n-\n-        static final MethodHandle IS_SAME_INLINE_CLASS =\n-            findStatic(\"isSamePrimitiveClass\", methodType(boolean.class, Object.class, Object.class));\n-        static final MethodHandle IS_NULL =\n-            findStatic(\"isNull\", methodType(boolean.class, Object.class, Object.class));\n-\n-        static final MethodHandle FALSE = constant(boolean.class, false);\n-        static final MethodHandle TRUE = constant(boolean.class, true);\n-        static final MethodHandle HASH_COMBINER =\n-            findStatic(\"hashCombiner\", methodType(int.class, int.class, int.class));\n-        static final MethodHandle COMPUTE_HASH =\n-            findStatic(\"computeHashCode\", methodType(int.class, MethodHandle[].class, int.class, int.class, Object.class));\n-\n-        private static MethodHandle[] initEquals() {\n-            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n-            for (Wrapper wrapper : Wrapper.values()) {\n-                if (wrapper == Wrapper.VOID) continue;\n-\n-                Class<?> type = wrapper.primitiveType();\n-                mhs[wrapper.ordinal()] = findStatic(\"eq\", methodType(boolean.class, type, type));\n-            }\n-            return mhs;\n-        }\n-\n-        private static MethodHandle[] initHashCode() {\n-            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n-            for (Wrapper wrapper : Wrapper.values()) {\n-                if (wrapper == Wrapper.VOID) continue;\n-                Class<?> cls = wrapper == Wrapper.OBJECT ? Objects.class : wrapper.wrapperType();\n-                mhs[wrapper.ordinal()] = findStatic(cls, \"hashCode\",\n-                                                    methodType(int.class, wrapper.primitiveType()));\n-            }\n-            return mhs;\n-        }\n-\n-        private static MethodHandle findStatic(String name, MethodType methodType) {\n-            return findStatic(MethodHandleBuilder.class, name, methodType);\n-        }\n-        private static MethodHandle findStatic(Class<?> cls, String name, MethodType methodType) {\n-            try {\n-                return IMPL_LOOKUP.findStatic(cls, name, methodType);\n-            } catch (NoSuchMethodException|IllegalAccessException e) {\n-                throw newLinkageError(e);\n-            }\n-        }\n-\n-        \/**\n-         * A \"salt\" value used for this internal hashcode implementation that\n-         * needs to vary sufficiently from one run to the next so that\n-         * the default hashcode for value types will vary between JVM runs.\n-         *\/\n-        static final int SALT;\n-        static {\n-            long nt = System.nanoTime();\n-            int value = (int)((nt >>> 32) ^ nt);\n-            SALT = GetIntegerAction.privilegedGetProperty(\"value.bsm.salt\", value);\n-        }\n-    }\n-\n-    private static LinkageError newLinkageError(Throwable e) {\n-        return (LinkageError) new LinkageError().initCause(e);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the arguments are <em>substitutable<\/em> to each\n-     * other and {@code false} otherwise.\n-     * <em>Substitutability<\/em> means that they cannot be distinguished from\n-     * each other in any data-dependent way, meaning that it is safe to substitute\n-     * one for the other.\n-     *\n-     * <ul>\n-     * <li>If {@code a} and {@code b} are both {@code null}, this method returns\n-     *     {@code true}.\n-     * <li>If {@code a} and {@code b} are both value instances of the same class\n-     *     {@code V}, this method returns {@code true} if, for all fields {@code f}\n-     *      declared in {@code V}, {@code a.f} and {@code b.f} are substitutable.\n-     * <li>If {@code a} and {@code b} are both primitives of the same type,\n-     *     this method returns {@code a == b} with the following exception:\n-     *     <ul>\n-     *     <li> If {@code a} and {@code b} both represent {@code NaN},\n-     *          this method returns {@code true}, even though {@code NaN == NaN}\n-     *          has the value {@code false}.\n-     *     <li> If {@code a} is floating point positive zero while {@code b} is\n-     *          floating point negative zero, or vice versa, this method\n-     *          returns {@code false}, even though {@code +0.0 == -0.0} has\n-     *          the value {@code true}.\n-     *     <\/ul>\n-     * <li>If {@code a} and {@code b} are both instances of the same reference type,\n-     *     this method returns {@code a == b}.\n-     * <li>Otherwise this method returns {@code false}.\n-     * <\/ul>\n-     *\n-     * <p>For example,\n-     * <pre>{@code interface Number { ... }\n-     * \/\/ ordinary reference class\n-     * class IntNumber implements Number { ... }\n-     * \/\/ value class\n-     * value class IntValue implements Number {\n-     *     int i;\n-     *     :\n-     *     public static IntValue of(int i) {...}     \/\/ IntValue::of creates a new value instance\n-     * }\n-     * \/\/ value class with an Object field\n-     * value class RefValue {\n-     *     Object o;\n-     *     :\n-     * }\n-     *\n-     * var val1 = IntValue.of(10);\n-     * var val2 = IntValue.of(10);                    \/\/ val1 and val2 have the same value\n-     * var ref1 = new IntNumber(10);                  \/\/ ref1 and ref2 are two reference instances\n-     * var ref2 = new IntNumber(10);\n-     * assertTrue(isSubstitutable(val1, val2));       \/\/ val1 and val2 are both value instances of IntValue\n-     * assertFalse(isSubstitutable(ref1, ref2));      \/\/ ref1 and ref2 are two reference instances that are not substitutable\n-     * assertTrue(isSubstitutable(ref1, ref1));       \/\/ a reference instance is substitutable with itself\n-     *\n-     * var rval1 = RefValue.of(List.of(\"list\"));      \/\/ rval1.o and rval2.o both contain a list of one-single element \"list\"\n-     * var rval2 = RefValue.of(List.of(\"list\");\n-     * var rval3 = RefValue.of(rval1.o);\n-     *\n-     * assertFalse(isSubstitutable(rval1, rval2));    \/\/ rval1.o and rval2.o are two different List instances and hence not substitutable\n-     * assertTrue(isSubstitutable(rval1, rval3 ));    \/\/ rval1.o and rval3.o are the same reference instance\n-     * }<\/pre>\n-     *\n-     * @apiNote\n-     * This API is intended for performance evaluation of this idiom for\n-     * {@code acmp}.  Hence it is not in the {@link System} class.\n-     *\n-     * @param a an object\n-     * @param b an object to be compared with {@code a} for substitutability\n-     * @return {@code true} if the arguments are substitutable to each other;\n-     *         {@code false} otherwise.\n-     * @param <T> type\n-     * @see Float#equals(Object)\n-     * @see Double#equals(Object)\n-     *\/\n-    public static <T> boolean isSubstitutable(T a, Object b) {\n-        if (VERBOSE) {\n-            System.out.println(\"substitutable \" + a + \" vs \" + b);\n-        }\n-\n-        \/\/ Called directly from the VM.\n-        \/\/\n-        \/\/ DO NOT use \"==\" or \"!=\" on args \"a\" and \"b\", with this code or any of\n-        \/\/ its callees. Could be inside of if_acmp<eq|ne> bytecode implementation.\n-\n-        if (a == null && b == null) return true;\n-        if (a == null || b == null) return false;\n-        if (a.getClass() != b.getClass()) return false;\n-\n-        try {\n-            Class<?> type = a.getClass();\n-            if (type.isPrimitiveClass()) {\n-                type = type.asValueType();\n-            }\n-            return (boolean) substitutableInvoker(type).invoke(a, b);\n-        } catch (Error|RuntimeException e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw e;\n-        } catch (Throwable e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Produces a method handle which tests if two arguments are\n-     * {@linkplain #isSubstitutable(Object, Object) substitutable}.\n-     *\n-     * <ul>\n-     * <li>If {@code T} is a non-floating point primitive type, this method\n-     *     returns a method handle testing the two arguments are the same value,\n-     *     i.e. {@code a == b}.\n-     * <li>If {@code T} is {@code float} or {@code double}, this method\n-     *     returns a method handle representing {@link Float#equals(Object)} or\n-     *     {@link Double#equals(Object)} respectively.\n-     * <li>If {@code T} is a reference type that is not {@code Object} and not an\n-     *     interface, this method returns a method handle testing\n-     *     the two arguments are the same reference, i.e. {@code a == b}.\n-     * <li>If {@code T} is a value type, this method returns\n-     *     a method handle that returns {@code true} if\n-     *     for all fields {@code f} declared in {@code T}, where {@code U} is\n-     *     the type of {@code f}, if {@code a.f} and {@code b.f} are substitutable\n-     *     with respect to {@code U}.\n-     * <li>If {@code T} is an interface or {@code Object}, and\n-     *     {@code a} and {@code b} are of the same value class {@code V},\n-     *     this method returns a method handle that returns {@code true} if\n-     *     {@code a} and {@code b} are substitutable with respect to {@code V}.\n-     * <\/ul>\n-     *\n-     * @param type class type\n-     * @param <T> type\n-     * @return a method handle for substitutability test\n-     *\/\n-    static <T> MethodHandle substitutableInvoker(Class<T> type) {\n-        if (type.isPrimitive())\n-            return MethodHandleBuilder.primitiveEquals(type);\n-\n-        if (type.isValueType())\n-            return SUBST_TEST_METHOD_HANDLES.get(type);\n-\n-        return MethodHandleBuilder.referenceTypeEquals(type);\n-    }\n-\n-    \/\/ store the method handle for value types in ClassValue\n-    private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {\n-        @Override protected MethodHandle computeValue(Class<?> type) {\n-            return MethodHandleBuilder.inlineTypeEquals(type.asValueType());\n-        }\n-    };\n-\n-    \/**\n-     * Invoke the bootstrap methods hashCode for the given primitive class object.\n-     * @param o the instance to hash.\n-     * @return the hash code of the given primitive class object.\n-     *\/\n-    private static int inlineObjectHashCode(Object o) {\n-        try {\n-            \/\/ Note: javac disallows user to call super.hashCode if user implementated\n-            \/\/ risk for recursion for experts crafting byte-code\n-            if (!o.getClass().isPrimitiveClass())\n-                throw new InternalError(\"must be primitive type: \" + o.getClass().getName());\n-            Class<?> type = o.getClass().asValueType();\n-            return (int) HASHCODE_METHOD_HANDLES.get(type).invoke(o);\n-        } catch (Error|RuntimeException e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n-        @Override protected MethodHandle computeValue(Class<?> type) {\n-            return MethodHandleBuilder.inlineTypeHashCode(type.asValueType());\n-        }\n-    };\n-\n-    private static final Comparator<MethodHandle> TYPE_SORTER = (mh1, mh2) -> {\n-        \/\/ sort the getters with the return type\n-        Class<?> t1 = mh1.type().returnType();\n-        Class<?> t2 = mh2.type().returnType();\n-        if (t1.isPrimitive()) {\n-            if (!t2.isPrimitive()) {\n-                return 1;\n-            }\n-        } else {\n-            if (t2.isPrimitive()) {\n-                return -1;\n-            }\n-        }\n-        return -1;\n-    };\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ValueBootstrapMethods.java","additions":0,"deletions":538,"binary":false,"changes":538,"status":"deleted"},{"patch":"@@ -69,1 +69,3 @@\n-    private static final HashMap<Class<?>, MethodHandle> primitiveEquals = new HashMap<>();\n+    \/* package-private *\/\n+    static final HashMap<Class<?>, MethodHandle> primitiveEquals = new HashMap<>();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.invoke.util.Wrapper;\n+import sun.security.action.GetIntegerAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import static java.lang.invoke.MethodHandles.constant;\n+import static java.lang.invoke.MethodHandles.countedLoop;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.guardWithTest;\n+import static java.lang.invoke.MethodHandles.permuteArguments;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.runtime.ObjectMethods.primitiveEquals;\n+\n+\/**\n+ * Implementation for Object::equals and Object::hashCode for primitive classes.\n+ *\n+ * PrimitiveObjectMethods::isSubstitutable and primitiveObjectHashCode are\n+ * private entry points called by VM.\n+ *\/\n+final class PrimitiveObjectMethods {\n+    private PrimitiveObjectMethods() {}\n+    private static final boolean VERBOSE =\n+        GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n+    static class MethodHandleBuilder {\n+        static MethodHandle[] getters(Class<?> type) {\n+            return getters(type, null);\n+        }\n+\n+        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {\n+            \/\/ filter static fields\n+            Stream<MethodHandle> s = Arrays.stream(type.getDeclaredFields())\n+                .filter(f -> !Modifier.isStatic(f.getModifiers()))\n+                .map(f -> {\n+                    try {\n+                        return JLIA.unreflectGetter(f);\n+                    } catch (IllegalAccessException e) {\n+                        throw newLinkageError(e);\n+                    }\n+                });\n+            if (comparator != null) {\n+                s = s.sorted(comparator);\n+            }\n+            return s.toArray(MethodHandle[]::new);\n+        }\n+\n+        static MethodHandle hashCodeForType(Class<?> type) {\n+            if (type.isPrimitive()) {\n+                int index = Wrapper.forPrimitiveType(type).ordinal();\n+                return HASHCODE[index];\n+            } else {\n+                return HASHCODE[Wrapper.OBJECT.ordinal()].asType(methodType(int.class, type));\n+            }\n+        }\n+\n+        static MethodHandle primitiveEquals(Class<?> primitiveType) {\n+            return primitiveEquals.get(primitiveType);\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two instances\n+         * of the given reference type are substitutable.\n+         *\n+         * Two values of reference type are substitutable i== iff\n+         * 1. if o1 and o2 are both reference objects then o1 r== o2; or\n+         * 2. if o1 and o2 are both values then o1 v== o2\n+         *\n+         * At invocation time, it needs a dynamic check on the objects and\n+         * do the substitutability test if they are of a primitive type.\n+         *\/\n+        static MethodHandle referenceTypeEquals(Class<?> type) {\n+            return OBJECT_EQUALS.asType(methodType(boolean.class, type, type));\n+        }\n+\n+        static Class<?> fieldType(MethodHandle getter) {\n+            Class<?> ftype = getter.type().returnType();\n+            return ftype;\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two value instances\n+         * of the given primitive class are substitutable.\n+         *\/\n+        static MethodHandle primitiveTypeEquals(Class<?> type) {\n+            assert type.isValueType();\n+            MethodType mt = methodType(boolean.class, type, type);\n+            MethodHandle[] getters = getters(type, TYPE_SORTER);\n+            MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n+            MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n+            MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n+            for (MethodHandle getter : getters) {\n+                Class<?> ftype = fieldType(getter);\n+                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n+                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n+                accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n+            }\n+            \/\/ if both arguments are null, return true;\n+            \/\/ otherwise return accumulator;\n+            return guardWithTest(IS_NULL.asType(mt),\n+                                 instanceTrue,\n+                                 guardWithTest(IS_SAME_PRIMITIVE_CLASS.asType(mt),\n+                                               accumulator,\n+                                               instanceFalse));\n+        }\n+\n+        static MethodHandle primitiveTypeHashCode(Class<?> type) {\n+            assert type.isValueType();\n+            MethodHandle target = dropArguments(constant(int.class, SALT), 0, type);\n+            MethodHandle cls = dropArguments(constant(Class.class, type),0, type);\n+            MethodHandle classHashCode = filterReturnValue(cls, hashCodeForType(Class.class));\n+            MethodHandle combiner = filterArguments(HASH_COMBINER, 0, target, classHashCode);\n+            \/\/ int v = SALT * 31 + type.hashCode();\n+            MethodHandle init = permuteArguments(combiner, target.type(), 0, 0);\n+            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n+            MethodHandle iterations = dropArguments(constant(int.class, getters.length), 0, type);\n+            MethodHandle[] hashers = new MethodHandle[getters.length];\n+            for (int i=0; i < getters.length; i++) {\n+                MethodHandle getter = getters[i];\n+                Class<?> ftype = fieldType(getter);\n+\n+                \/\/ For primitive type or reference type, this calls Objects::hashCode.\n+                \/\/ If the instance is of primitive type and the hashCode method is not\n+                \/\/ overridden, VM will call primitiveObjectHashCode to compute the\n+                \/\/ hash code.\n+                MethodHandle hasher = hashCodeForType(ftype);\n+                hashers[i] = filterReturnValue(getter, hasher);\n+            }\n+\n+            \/\/ for (int i=0; i < getters.length; i++) {\n+            \/\/   v = computeHash(v, i, a);\n+            \/\/ }\n+            MethodHandle body = COMPUTE_HASH.bindTo(hashers)\n+                    .asType(methodType(int.class, int.class, int.class, type));\n+            return countedLoop(iterations, init, body);\n+        }\n+\n+        \/\/ ------ utility methods ------\n+        private static boolean eq(Object a, Object b)   {\n+            if (a == null && b == null) return true;\n+            if (a == null || b == null) return false;\n+            if (a.getClass() != b.getClass()) return false;\n+            return a.getClass().isPrimitiveClass() ? valueEq(a, b) : (a == b);\n+        }\n+\n+        \/*\n+         * Returns true if two values are substitutable.\n+         *\/\n+        private static boolean valueEq(Object a, Object b) {\n+            assert a != null && b != null && isSamePrimitiveClass(a, b);\n+            try {\n+                Class<?> type = a.getClass().asValueType();\n+                return (boolean) substitutableInvoker(type).invoke(type.cast(a), type.cast(b));\n+            } catch (Error|RuntimeException e) {\n+                throw e;\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        private static boolean isNull(Object a, Object b) {\n+            \/\/ avoid acmp that will call isSubstitutable\n+            if (a != null) return false;\n+            if (b != null) return false;\n+            return true;\n+        }\n+\n+        \/*\n+         * Returns true if the given objects are of the same primitive class.\n+         *\n+         * Two objects are of the same primitive class iff:\n+         * 1. a != null and b != null\n+         * 2. the declaring class of a and b is the same primitive class\n+         *\/\n+        private static boolean isSamePrimitiveClass(Object a, Object b) {\n+            if (a == null || b == null) return false;\n+\n+            return a.getClass().isPrimitiveClass() && a.getClass() == b.getClass();\n+        }\n+\n+        private static int hashCombiner(int accumulator, int value) {\n+            return accumulator * 31 + value;\n+        }\n+\n+        private static int computeHashCode(MethodHandle[] hashers, int v, int i, Object o) {\n+            try {\n+                int hc = (int)hashers[i].invoke(o);\n+                return hashCombiner(v, hc);\n+            } catch (Error|RuntimeException e) {\n+                throw e;\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        private static final MethodHandle FALSE = constant(boolean.class, false);\n+        private static final MethodHandle TRUE = constant(boolean.class, true);\n+        private static final MethodHandle OBJECT_EQUALS = findStatic(\"eq\", methodType(boolean.class, Object.class, Object.class));\n+        private static final MethodHandle IS_SAME_PRIMITIVE_CLASS =\n+            findStatic(\"isSamePrimitiveClass\", methodType(boolean.class, Object.class, Object.class));\n+        private static final MethodHandle IS_NULL =\n+            findStatic(\"isNull\", methodType(boolean.class, Object.class, Object.class));\n+        private static final MethodHandle HASH_COMBINER =\n+            findStatic(\"hashCombiner\", methodType(int.class, int.class, int.class));\n+        private static final MethodHandle COMPUTE_HASH =\n+            findStatic(\"computeHashCode\", methodType(int.class, MethodHandle[].class, int.class, int.class, Object.class));\n+        private static final MethodHandle[] HASHCODE = initHashCode();\n+\n+        private static MethodHandle[] initHashCode() {\n+            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n+            for (Wrapper wrapper : Wrapper.values()) {\n+                if (wrapper == Wrapper.VOID) continue;\n+                Class<?> cls = wrapper == Wrapper.OBJECT ? Objects.class : wrapper.wrapperType();\n+                mhs[wrapper.ordinal()] = findStatic(cls, \"hashCode\",\n+                                                    methodType(int.class, wrapper.primitiveType()));\n+            }\n+            return mhs;\n+        }\n+\n+        private static MethodHandle findStatic(String name, MethodType methodType) {\n+            return findStatic(MethodHandleBuilder.class, name, methodType);\n+        }\n+        private static MethodHandle findStatic(Class<?> cls, String name, MethodType methodType) {\n+            try {\n+                return JLIA.findStatic(cls, name, methodType);\n+            } catch (NoSuchMethodException|IllegalAccessException e) {\n+                throw newLinkageError(e);\n+            }\n+        }\n+\n+        \/**\n+         * A \"salt\" value used for this internal hashcode implementation that\n+         * needs to vary sufficiently from one run to the next so that\n+         * the default hashcode for value types will vary between JVM runs.\n+         *\/\n+        static final int SALT;\n+        static {\n+            long nt = System.nanoTime();\n+            int value = (int)((nt >>> 32) ^ nt);\n+            SALT = GetIntegerAction.privilegedGetProperty(\"value.bsm.salt\", value);\n+        }\n+    }\n+\n+    private static LinkageError newLinkageError(Throwable e) {\n+        return (LinkageError) new LinkageError().initCause(e);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the arguments are <em>substitutable<\/em> to each\n+     * other and {@code false} otherwise.\n+     * <em>Substitutability<\/em> means that they cannot be distinguished from\n+     * each other in any data-dependent way, meaning that it is safe to substitute\n+     * one for the other.\n+     *\n+     * <ul>\n+     * <li>If {@code a} and {@code b} are both {@code null}, this method returns\n+     *     {@code true}.\n+     * <li>If {@code a} and {@code b} are both value instances of the same class\n+     *     {@code V}, this method returns {@code true} if, for all fields {@code f}\n+     *      declared in {@code V}, {@code a.f} and {@code b.f} are substitutable.\n+     * <li>If {@code a} and {@code b} are both primitives of the same type,\n+     *     this method returns {@code a == b} with the following exception:\n+     *     <ul>\n+     *     <li> If {@code a} and {@code b} both represent {@code NaN},\n+     *          this method returns {@code true}, even though {@code NaN == NaN}\n+     *          has the value {@code false}.\n+     *     <li> If {@code a} is floating point positive zero while {@code b} is\n+     *          floating point negative zero, or vice versa, this method\n+     *          returns {@code false}, even though {@code +0.0 == -0.0} has\n+     *          the value {@code true}.\n+     *     <\/ul>\n+     * <li>If {@code a} and {@code b} are both instances of the same reference type,\n+     *     this method returns {@code a == b}.\n+     * <li>Otherwise this method returns {@code false}.\n+     * <\/ul>\n+     *\n+     * <p>For example,\n+     * <pre>{@code interface Number { ... }\n+     * \/\/ ordinary reference class\n+     * class IntNumber implements Number { ... }\n+     * \/\/ value class\n+     * value class IntValue implements Number {\n+     *     int i;\n+     *     :\n+     *     public static IntValue of(int i) {...}     \/\/ IntValue::of creates a new value instance\n+     * }\n+     * \/\/ value class with an Object field\n+     * value class RefValue {\n+     *     Object o;\n+     *     :\n+     * }\n+     *\n+     * var val1 = IntValue.of(10);\n+     * var val2 = IntValue.of(10);                    \/\/ val1 and val2 have the same value\n+     * var ref1 = new IntNumber(10);                  \/\/ ref1 and ref2 are two reference instances\n+     * var ref2 = new IntNumber(10);\n+     * assertTrue(isSubstitutable(val1, val2));       \/\/ val1 and val2 are both value instances of IntValue\n+     * assertFalse(isSubstitutable(ref1, ref2));      \/\/ ref1 and ref2 are two reference instances that are not substitutable\n+     * assertTrue(isSubstitutable(ref1, ref1));       \/\/ a reference instance is substitutable with itself\n+     *\n+     * var rval1 = RefValue.of(List.of(\"list\"));      \/\/ rval1.o and rval2.o both contain a list of one-single element \"list\"\n+     * var rval2 = RefValue.of(List.of(\"list\");\n+     * var rval3 = RefValue.of(rval1.o);\n+     *\n+     * assertFalse(isSubstitutable(rval1, rval2));    \/\/ rval1.o and rval2.o are two different List instances and hence not substitutable\n+     * assertTrue(isSubstitutable(rval1, rval3 ));    \/\/ rval1.o and rval3.o are the same reference instance\n+     * }<\/pre>\n+     *\n+     * @param a an object\n+     * @param b an object to be compared with {@code a} for substitutability\n+     * @return {@code true} if the arguments are substitutable to each other;\n+     *         {@code false} otherwise.\n+     * @param <T> type\n+     * @see Float#equals(Object)\n+     * @see Double#equals(Object)\n+     *\/\n+    private static <T> boolean isSubstitutable(T a, Object b) {\n+        if (VERBOSE) {\n+            System.out.println(\"substitutable \" + a + \" vs \" + b);\n+        }\n+\n+        \/\/ Called directly from the VM.\n+        \/\/\n+        \/\/ DO NOT use \"==\" or \"!=\" on args \"a\" and \"b\", with this code or any of\n+        \/\/ its callees. Could be inside of if_acmp<eq|ne> bytecode implementation.\n+\n+        if (a == null && b == null) return true;\n+        if (a == null || b == null) return false;\n+        if (a.getClass() != b.getClass()) return false;\n+\n+        try {\n+            Class<?> type = a.getClass();\n+            if (type.isPrimitiveClass()) {\n+                type = type.asValueType();\n+            }\n+            return (boolean) substitutableInvoker(type).invoke(a, b);\n+        } catch (Error|RuntimeException e) {\n+            if (VERBOSE) e.printStackTrace();\n+            throw e;\n+        } catch (Throwable e) {\n+            if (VERBOSE) e.printStackTrace();\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Produces a method handle which tests if two arguments are\n+     * {@linkplain #isSubstitutable(Object, Object) substitutable}.\n+     *\n+     * <ul>\n+     * <li>If {@code T} is a non-floating point primitive type, this method\n+     *     returns a method handle testing the two arguments are the same value,\n+     *     i.e. {@code a == b}.\n+     * <li>If {@code T} is {@code float} or {@code double}, this method\n+     *     returns a method handle representing {@link Float#equals(Object)} or\n+     *     {@link Double#equals(Object)} respectively.\n+     * <li>If {@code T} is a reference type that is not {@code Object} and not an\n+     *     interface, this method returns a method handle testing\n+     *     the two arguments are the same reference, i.e. {@code a == b}.\n+     * <li>If {@code T} is a value type, this method returns\n+     *     a method handle that returns {@code true} if\n+     *     for all fields {@code f} declared in {@code T}, where {@code U} is\n+     *     the type of {@code f}, if {@code a.f} and {@code b.f} are substitutable\n+     *     with respect to {@code U}.\n+     * <li>If {@code T} is an interface or {@code Object}, and\n+     *     {@code a} and {@code b} are of the same value class {@code V},\n+     *     this method returns a method handle that returns {@code true} if\n+     *     {@code a} and {@code b} are substitutable with respect to {@code V}.\n+     * <\/ul>\n+     *\n+     * @param type class type\n+     * @param <T> type\n+     * @return a method handle for substitutability test\n+     *\/\n+    private static <T> MethodHandle substitutableInvoker(Class<T> type) {\n+        if (type.isPrimitive())\n+            return MethodHandleBuilder.primitiveEquals(type);\n+\n+        if (type.isValueType())\n+            return SUBST_TEST_METHOD_HANDLES.get(type);\n+\n+        return MethodHandleBuilder.referenceTypeEquals(type);\n+    }\n+\n+    \/\/ store the method handle for value types in ClassValue\n+    private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {\n+        @Override protected MethodHandle computeValue(Class<?> type) {\n+            return MethodHandleBuilder.primitiveTypeEquals(type.asValueType());\n+        }\n+    };\n+\n+    \/**\n+     * Invoke the bootstrap methods hashCode for the given primitive class object.\n+     * @param o the instance to hash.\n+     * @return the hash code of the given primitive class object.\n+     *\/\n+    private static int primitiveObjectHashCode(Object o) {\n+        try {\n+            \/\/ Note: javac disallows user to call super.hashCode if user implemented\n+            \/\/ risk for recursion for experts crafting byte-code\n+            if (!o.getClass().isPrimitiveClass())\n+                throw new InternalError(\"must be primitive type: \" + o.getClass().getName());\n+            Class<?> type = o.getClass().asValueType();\n+            return (int) HASHCODE_METHOD_HANDLES.get(type).invoke(o);\n+        } catch (Error|RuntimeException e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            if (VERBOSE) e.printStackTrace();\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n+        @Override protected MethodHandle computeValue(Class<?> type) {\n+            return MethodHandleBuilder.primitiveTypeHashCode(type.asValueType());\n+        }\n+    };\n+\n+    private static final Comparator<MethodHandle> TYPE_SORTER = (mh1, mh2) -> {\n+        \/\/ sort the getters with the return type\n+        Class<?> t1 = mh1.type().returnType();\n+        Class<?> t2 = mh2.type().returnType();\n+        if (t1.isPrimitive()) {\n+            if (!t2.isPrimitive()) {\n+                return 1;\n+            }\n+        } else {\n+            if (t2.isPrimitive()) {\n+                return -1;\n+            }\n+        }\n+        return -1;\n+    };\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/PrimitiveObjectMethods.java","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.Field;\n@@ -142,0 +143,4 @@\n+\n+    MethodHandle findStatic(Class<?> cls, String name, MethodType methodType) throws NoSuchMethodException, IllegalAccessException;\n+\n+    MethodHandle unreflectGetter(Field field) throws IllegalAccessException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-        protected static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.invoke.ValueBootstrapMethods::isSubstitutable\" + END;\n+        protected static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.runtime.PrimitiveObjectMethods::isSubstitutable\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @summary Verify that call reresolution works for C2 compiled calls to java.lang.invoke.ValueBootstrapMethods::isSubstitutable0.\n+ * @summary Verify that call reresolution works for C2 compiled calls to java.lang.runtime.PrimitiveObjectMethods::isSubstitutable0.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIsSubstitutableReresolution.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules java.base\/java.lang.invoke:open\n+ * @modules java.base\/java.lang.runtime:open\n+ *          java.base\/jdk.internal.org.objectweb.asm\n@@ -32,1 +33,0 @@\n-import java.lang.invoke.ValueBootstrapMethods;\n@@ -79,1 +79,1 @@\n-        assertTrue(ValueBootstrapMethods.isSubstitutable(a, b));\n+        assertTrue(isSubstitutable(a, b));\n@@ -111,1 +111,1 @@\n-        assertFalse(ValueBootstrapMethods.isSubstitutable(a, b));\n+        assertFalse(isSubstitutable(a, b));\n@@ -184,1 +184,1 @@\n-     * This verifies ValueBootstrapMethods::isSubstitutable0 that does not\n+     * This verifies PrimitiveObjectMethods::isSubstitutable that does not\n@@ -189,1 +189,1 @@\n-    public void testIsSubstitutable0(Object a, Object b) throws Exception {\n+    public void testIsSubstitutable(Object a, Object b) {\n@@ -206,1 +206,2 @@\n-            m = ValueBootstrapMethods.class.getDeclaredMethod(\"isSubstitutable\", Object.class, Object.class);\n+            Class<?> c = Class.forName(\"java.lang.runtime.PrimitiveObjectMethods\");\n+            m = c.getDeclaredMethod(\"isSubstitutable\", Object.class, Object.class);\n@@ -213,2 +214,6 @@\n-    private static boolean isSubstitutable(Object a, Object b) throws ReflectiveOperationException {\n-        return (boolean) IS_SUBSTITUTABLE.invoke(null, a, b);\n+    private static boolean isSubstitutable(Object a, Object b) {\n+        try {\n+            return (boolean) IS_SUBSTITUTABLE.invoke(null, a, b);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test value bootstrap methods\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- * @compile -XDallowWithFieldOperator ValueBootstrapMethods.java\n- * @run main\/othervm -Dvalue.bsm.salt=1 ValueBootstrapMethods\n- *\/\n-\n-import java.io.IOException;\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Type;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n-public class ValueBootstrapMethods {\n-    private static final String TEST_CLASSES = System.getProperty(\"test.classes\", \".\");\n-\n-    public static void main(String... args) throws Throwable {\n-        Class<?> test = valueTestClass();\n-        Value value = new Value(10, 5.03, \"foo\", \"bar\", \"goo\");\n-\n-        Class<?> valueClass = Value.class.asValueType();\n-        Method hashCode = test.getMethod(\"hashCode\", valueClass);\n-        int hash = (int)hashCode.invoke(null, value);\n-        assertEquals(hash, value.localHashCode());\n-        assertEquals(hash, value.hashCode());\n-\n-        Method equals = test.getMethod(\"equals\", valueClass, Object.class);\n-        boolean rc = (boolean)equals.invoke(null, value, value);\n-        if (!rc) {\n-            throw new RuntimeException(\"expected equals\");\n-        }\n-    }\n-\n-    public static primitive class Value {\n-        private final int i;\n-        private final double d;\n-        private final String s;\n-        private final List<String> l;\n-        Value(int i, double d, String s, String... items) {\n-            this.i = i;\n-            this.d = d;\n-            this.s = s;\n-            this.l = List.of(items);\n-        }\n-\n-        List<Object> values() {\n-            return List.of(Value.class.asValueType(), i, d, s, l);\n-        }\n-\n-        public int localHashCode() {\n-            return values().hashCode();\n-        }\n-    }\n-\n-    \/*\n-     * Generate ValueTest class\n-     *\/\n-    private static Class<?> valueTestClass() throws Exception {\n-        Path path = Paths.get(TEST_CLASSES, \"ValueTest.class\");\n-        generate(Value.class.asValueType(), \"ValueTest\", path);\n-        return Class.forName(\"ValueTest\");\n-    }\n-\n-    private static void assertEquals(Object o1, Object expected) {\n-        if (!Objects.equals(o1, expected)) {\n-            throw new RuntimeException(o1 + \" expected: \" + expected);\n-        }\n-    }\n-\n-    static final int CLASSFILE_VERSION = 56;\n-    static void generate(Class<?> c, String className, Path path) throws IOException {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-\n-        cw.visit(CLASSFILE_VERSION,\n-            ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,\n-            className,\n-            null,\n-            \"java\/lang\/Object\",\n-            null\n-        );\n-\n-\n-        MethodType mt = MethodType.methodType(CallSite.class,\n-            MethodHandles.Lookup.class, String.class, MethodType.class, Class.class);\n-        Handle bootstrap = new Handle(H_INVOKESTATIC, Type.getInternalName(java.lang.invoke.ValueBootstrapMethods.class),\n-            \"makeBootstrapMethod\", mt.toMethodDescriptorString(), false);\n-\n-        Type type = Type.getType(c);\n-        MethodVisitor mv = cw.visitMethod(\n-            ACC_PUBLIC + ACC_STATIC + ACC_FINAL,\n-            \"hashCode\",\n-            Type.getMethodDescriptor(Type.INT_TYPE, type),\n-            null,\n-            null);\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInvokeDynamicInsn(\"hashCode\",\n-            Type.getMethodDescriptor(Type.INT_TYPE, type),\n-            bootstrap, type);\n-        mv.visitInsn(IRETURN);\n-\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(\n-            ACC_PUBLIC + ACC_STATIC + ACC_FINAL,\n-            \"equals\",\n-            Type.getMethodDescriptor(Type.BOOLEAN_TYPE, type, Type.getType(Object.class)),\n-            null,\n-            null);\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitInvokeDynamicInsn(\"equals\",\n-            Type.getMethodDescriptor(Type.BOOLEAN_TYPE, type, Type.getType(Object.class)),\n-            bootstrap, type);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-\n-        byte[] classBytes = cw.toByteArray();\n-        System.out.println(\"writing \" + path);\n-        Files.write(path, classBytes);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueBootstrapMethods.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"}]}