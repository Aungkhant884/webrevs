{"files":[{"patch":"@@ -314,0 +314,22 @@\n+ * HPROF_FLAT_ARRAYS        list of flat arrays\n+ *\n+ *               [flat array sub-records]*\n+ *\n+ *               HPROF_FLAT_ARRAY      flat array\n+ *\n+ *                          id         array object ID (dumped as HPROF_GC_PRIM_ARRAY_DUMP)\n+ *                          id         element class ID (dumped by HPROF_GC_CLASS_DUMP)\n+ *\n+ * HPROF_INLINED_FIELDS     decribes inlined fields\n+ *\n+ *               [class with inlined fields sub-records]*\n+ *\n+ *               HPROF_CLASS_WITH_INLINED_FIELDS\n+ *\n+ *                          id         class ID (dumped as HPROF_GC_CLASS_DUMP)\n+ *\n+ *                          u2         number of instance inlined fields (not including super)\n+ *                          [u2,       inlined field index,\n+ *                           u2,       synthetic field count,\n+ *                           id,       original field name,\n+ *                           id]*      inlined field class ID (dumped by HPROF_GC_CLASS_DUMP)\n@@ -351,0 +373,7 @@\n+  \/\/ inlined object support\n+  HPROF_FLAT_ARRAYS             = 0x12,\n+  HPROF_INLINED_FIELDS          = 0x13,\n+  \/\/ inlined object subrecords\n+  HPROF_FLAT_ARRAY                  = 0x01,\n+  HPROF_CLASS_WITH_INLINED_FIELDS   = 0x01,\n+\n@@ -386,6 +415,1 @@\n-\/\/ Inlined fields of primitive classes are dumped as identity objects and require unique object ids.\n-\/\/ We cannot use address of the object in container oop (as we do for identity objects)\n-\/\/ because the address can be the same for inlined object which contains inlined field with offset 0.\n-class InlinedObjectSupport : public StackObj {\n-    friend class AbstractDumpWriter;\n-    InlinedObjectSupport(int initial_value = 1) : _counter(initial_value) {}\n+class AbstractDumpWriter;\n@@ -393,5 +417,10 @@\n-    int _counter;\n-    int getId() { return _counter++; }\n-public:\n-    InlinedObjectSupport save() const {\n-        return InlinedObjectSupport(_counter);\n+class InlinedObjects {\n+\n+  struct ClassInlinedFields {\n+    const Klass *klass;\n+    uintx base_index;   \/\/ base index of the inlined field names (1st field has index base_index+1).\n+    ClassInlinedFields(const Klass *klass = nullptr, uintx base_index = 0) : klass(klass), base_index(base_index) {}\n+\n+    \/\/ For GrowableArray::find_sorted().\n+    static int compare(const ClassInlinedFields& a, const ClassInlinedFields& b) {\n+      return a.klass - b.klass;\n@@ -399,0 +428,46 @@\n+    \/\/ For GrowableArray::sort().\n+    static int compare(ClassInlinedFields* a, ClassInlinedFields* b) {\n+      return compare(*a, *b);\n+    }\n+  };\n+\n+  uintx _min_string_id;\n+  uintx _max_string_id;\n+\n+  GrowableArray<ClassInlinedFields> *_inlined_field_map;\n+\n+  \/\/ counters for classes with inlined fields and for the fields\n+  int _classes_count;\n+  int _inlined_fields_count;\n+\n+  static InlinedObjects *_instance;\n+\n+  static void inlined_field_names_callback(InlinedObjects* _this, const Klass *klass, uintx base_index, int count);\n+\n+  GrowableArray<oop> *_flat_arrays;\n+\n+public:\n+  InlinedObjects()\n+    : _min_string_id(0), _max_string_id(0),\n+    _inlined_field_map(nullptr),\n+    _classes_count(0), _inlined_fields_count(0),\n+    _flat_arrays(nullptr) {\n+  }\n+\n+  static InlinedObjects* get_instance() {\n+    return _instance;\n+  }\n+\n+  void init();\n+  void release();\n+\n+  void dump_inlined_field_names(AbstractDumpWriter *writer);\n+\n+  uintx get_base_index_for(Klass* k);\n+  uintx get_next_string_id(uintx id);\n+\n+  void dump_classed_with_inlined_fields(AbstractDumpWriter* writer);\n+\n+  void add_flat_array(oop array);\n+  void dump_flat_arrays(AbstractDumpWriter* writer);\n+\n@@ -401,0 +476,3 @@\n+InlinedObjects *InlinedObjects::_instance = nullptr;\n+\n+\n@@ -431,3 +509,0 @@\n-\n-  InlinedObjectSupport _inlined_object_support;\n-\n@@ -445,2 +520,0 @@\n-  InlinedObjectSupport& inlined_object_support() { return _inlined_object_support; }\n-\n@@ -455,1 +528,0 @@\n-  void write_inlinedObjectID(InlinedObjectSupport &inlinedObjectSupport);\n@@ -547,8 +619,0 @@\n-void AbstractDumpWriter::write_inlinedObjectID(InlinedObjectSupport& inlinedObjectSupport) {\n-#ifdef _LP64\n-  write_u8(inlinedObjectSupport.getId());\n-#else\n-  write_u4(inlinedObjectSupport.getId());\n-#endif\n-}\n-\n@@ -927,2 +991,2 @@\n-  \/\/ returns the size of the instance of the given class\n-  static u4 instance_size(Klass* k);\n+  \/\/ calculates the total size of the all fields of the given class.\n+  static u4 instance_size(InstanceKlass* ik);\n@@ -934,3 +998,2 @@\n-  \/\/ dumps the raw value of the given field; obj and offset specify the object (offset is 0 for identity objects)\n-  \/\/ for inlined fields writed object id generated by writer->inlined_object_support()\n-  static void dump_field_value(AbstractDumpWriter* writer, const FieldStream& fld, oop obj, int offset);\n+  \/\/ dumps the raw value of the given field\n+  static void dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset);\n@@ -944,5 +1007,4 @@\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, Klass* klass);\n-  \/\/ dump inlined instance fields of the given object (identity or inlined);\n-  \/\/ o is the holder object, offset and klass specify flattened field (or field of flattened field, etc.);\n-  \/\/ for identity object offset is 0 and klass is o->klass()\n-  static void dump_inlined_instance_fields(AbstractDumpWriter* writer, oop o, int offset, Klass* klass, InlinedObjectSupport &ios);\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass* klass);\n+  \/\/ dump the raw values of the instance fields of the given inlined object;\n+  \/\/ dump_instance_fields wrapper for inlined objects\n+  static void dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, InlineKlass* klass);\n@@ -953,3 +1015,1 @@\n-  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k);\n-  \/\/ creates HPROF_GC_INSTANCE_DUMP record for the given inlined object\n-  static void dump_inlined_object(AbstractDumpWriter* writer, oop holder, int offset, InlineKlass* klass, InlinedObjectSupport& ios);\n+  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* k, uintx *inlined_fields_index = nullptr);\n@@ -964,1 +1024,3 @@\n-  static void dump_object_array(AbstractDumpWriter* writer, arrayOop array);\n+  static void dump_object_array(AbstractDumpWriter* writer, objArrayOop array);\n+  \/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+  static void dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array);\n@@ -972,0 +1034,3 @@\n+  \/\/ extended version to dump flat arrays as primitive arrays;\n+  \/\/ type_size specifies size of the inlined objects.\n+  static int calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size);\n@@ -985,0 +1050,10 @@\n+\n+  \/\/ helper methods for inlined fields.\n+  static bool is_inlined_field(const FieldStream& fld) {\n+    return fld.field_descriptor().is_inlined();\n+  }\n+  static InlineKlass* get_inlined_field_klass(const FieldStream &fld) {\n+    assert(is_inlined_field(fld), \"must be inlined field\");\n+    InstanceKlass* holder_klass = fld.field_descriptor().field_holder();\n+    return InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n+  }\n@@ -998,1 +1073,1 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT: return HPROF_NORMAL_OBJECT;\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: return HPROF_NORMAL_OBJECT; \/\/ not inlined Q-object, i.e. identity object.\n@@ -1068,5 +1143,3 @@\n-\/\/ dumps the raw value of the given field; obj and offset specify the object (offset is 0 for identity objects)\n-\/\/ for inlined fields writed object id generated by writer->inlined_object_support()\n-void DumperSupport::dump_field_value(AbstractDumpWriter* writer, const FieldStream& fld, oop obj, int offset) {\n-  char type = fld.signature()->char_at(0);\n-  offset += fld.offset();\n+\n+\/\/ dumps the raw value of the given field\n+void DumperSupport::dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset) {\n@@ -1074,7 +1147,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT: {\n-      if (fld.field_descriptor().is_inlined()) {\n-        writer->write_inlinedObjectID(writer->inlined_object_support());\n-        break;\n-      }\n-    }\n-    \/\/ pass through\n@@ -1082,0 +1148,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ not inlined Q-object, i.e. identity object.\n@@ -1142,3 +1209,2 @@\n-\/\/ returns the size of the instance of the given class\n-u4 DumperSupport::instance_size(Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ calculates the total size of the all fields of the given class.\n+u4 DumperSupport::instance_size(InstanceKlass *ik) {\n@@ -1149,1 +1215,5 @@\n-      size += sig2size(fld.signature());\n+      if (is_inlined_field(fld)) {\n+        size += instance_size(get_inlined_field_klass(fld));\n+      } else {\n+        size += sig2size(fld.signature());\n+      }\n@@ -1161,0 +1231,2 @@\n+      assert(!is_inlined_field(fldc), \"static fields cannot be inlined\");\n+\n@@ -1203,0 +1275,2 @@\n+      assert(!is_inlined_field(fld), \"static fields cannot be inlined\");\n+\n@@ -1208,3 +1282,0 @@\n-      \/\/ if this changes, need to handle this properly (dump inlined objects after dump_static_fields)\n-      assert(!fld.field_descriptor().is_inlined(), \"static fields cannot be inlined\");\n-\n@@ -1212,1 +1283,1 @@\n-      dump_field_value(writer, fld, ik->java_mirror(), 0);\n+      dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n@@ -1242,6 +1313,5 @@\n-\n-\/\/ dump the raw values of the instance fields of the given object\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, Klass *klass) {\n-  InstanceKlass* ik = InstanceKlass::cast(klass);\n-\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+\/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+\/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+\/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class.\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass *klass) {\n+  for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n@@ -1249,1 +1319,9 @@\n-      dump_field_value(writer, fld, o, offset);\n+      if (is_inlined_field(fld)) {\n+        InlineKlass* field_klass = get_inlined_field_klass(fld);\n+        \/\/ the field is inlined, so all its fields are stored without headers.\n+        int fields_offset = offset + fld.offset() - field_klass->first_field_offset();\n+        dump_inlined_object_fields(writer, o, offset + fld.offset(), field_klass);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        dump_field_value(writer, sig->char_at(0), o, offset + fld.offset());\n+      }\n@@ -1254,14 +1332,3 @@\n-void DumperSupport::dump_inlined_instance_fields(AbstractDumpWriter *writer, oop o, int offset, Klass *klass, InlinedObjectSupport &ios) {\n-  InstanceKlass* ik = InstanceKlass::cast(klass);\n-\n-  assert(&ios != &writer->inlined_object_support(), \"must be saved copy\");\n-\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n-    if (!fld.access_flags().is_static()) {\n-      if (fld.field_descriptor().is_inlined()) {\n-        InstanceKlass* holder_klass = fld.field_descriptor().field_holder();\n-        InlineKlass* field_klass = InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n-        dump_inlined_object(writer, o, offset + fld.offset(), field_klass, ios);\n-      }\n-    }\n-  }\n+void DumperSupport::dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, InlineKlass* klass) {\n+  \/\/ the object is inlined, so all its fields are stored without headers.\n+  dump_instance_fields(writer, o, offset - klass->first_field_offset(), klass);\n@@ -1275,1 +1342,8 @@\n-    if (!fldc.access_flags().is_static()) field_count++;\n+    if (!fldc.access_flags().is_static()) {\n+      if (is_inlined_field(fldc)) {\n+        \/\/ add \"synthetic\" fields for inlined fields.\n+        field_count += get_instance_fields_count(get_inlined_field_klass(fldc));\n+      } else {\n+        field_count++;\n+      }\n+    }\n@@ -1282,2 +1356,8 @@\n-void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ inlined_fields_id is not-NULL for inlined fields (to get synthetic field name IDs\n+\/\/ by using InlinedObjects::get_next_string_id()).\n+void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* ik, uintx* inlined_fields_id) {\n+  \/\/ inlined_fields_id != NULL means ik is a class of inlined field.\n+  \/\/ Inlined field id pointer for this class; lazyly initialized\n+  \/\/ if the class has inlined field(s) and the caller didn't provide inlined_fields_id.\n+  uintx *this_klass_inlined_fields_id = inlined_fields_id;\n+  uintx inlined_id = 0;\n@@ -1288,1 +1368,23 @@\n-      Symbol* sig = fld.signature();\n+      if (is_inlined_field(fld)) {\n+        \/\/ dump \"synthetic\" fields for inlined fields.\n+        if (this_klass_inlined_fields_id == nullptr) {\n+          inlined_id = InlinedObjects::get_instance()->get_base_index_for(ik);\n+          this_klass_inlined_fields_id = &inlined_id;\n+        }\n+        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld), this_klass_inlined_fields_id);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        Symbol* name = nullptr;\n+        \/\/ Use inlined_fields_id provided by caller.\n+        if (inlined_fields_id != nullptr) {\n+          uintx name_id = InlinedObjects::get_instance()->get_next_string_id(*inlined_fields_id);\n+\n+          \/\/ name_id == 0 is returned on error. use original field signature.\n+          if (name_id != 0) {\n+            *inlined_fields_id = name_id;\n+            name = reinterpret_cast<Symbol*>(name_id);\n+          }\n+        }\n+        if (name == nullptr) {\n+          name = fld.name();\n+        }\n@@ -1290,2 +1392,3 @@\n-      writer->write_symbolID(fld.name());   \/\/ name\n-      writer->write_u1(sig2tag(sig));       \/\/ type\n+        writer->write_symbolID(name);         \/\/ name\n+        writer->write_u1(sig2tag(sig));       \/\/ type\n+      }\n@@ -1296,31 +1399,0 @@\n-\/\/ creates HPROF_GC_INSTANCE_DUMP record for the given inlined object\n-void DumperSupport::dump_inlined_object(AbstractDumpWriter* writer, oop holder, int offset, InlineKlass* klass, InlinedObjectSupport& ios) {\n-  u4 is = instance_size(klass);\n-  u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;\n-\n-  writer->start_sub_record(HPROF_GC_INSTANCE_DUMP, size);\n-  writer->write_inlinedObjectID(ios);\n-\n-  writer->write_u4(STACK_TRACE_ID);\n-\n-  \/\/ class ID\n-  writer->write_classID(klass);\n-\n-  \/\/ number of bytes that follow\n-  writer->write_u4(is);\n-\n-  \/\/ the object if flattened, so all fields are stored without headers\n-  \/\/ update offset here instead of handling it in both dump_instance_fields and dump_inlined_instance_fields\n-  offset -= klass->first_field_offset();\n-\n-  InlinedObjectSupport saved_ios = writer->inlined_object_support().save();\n-\n-  \/\/ field values\n-  dump_instance_fields(writer, holder, offset, klass);\n-\n-  writer->end_sub_record();\n-\n-  \/\/ dump flattened fields\n-  dump_inlined_instance_fields(writer, holder, offset, klass, saved_ios);\n-}\n-\n@@ -1343,2 +1415,0 @@\n-  InlinedObjectSupport saved_ios = writer->inlined_object_support().save();\n-\n@@ -1346,1 +1416,1 @@\n-  dump_instance_fields(writer, o, 0, o->klass());\n+  dump_instance_fields(writer, o, 0, ik);\n@@ -1349,3 +1419,0 @@\n-\n-  \/\/ dump inlined fields\n-  dump_inlined_instance_fields(writer, o, 0, o->klass(), saved_ios);\n@@ -1394,1 +1461,1 @@\n-  writer->write_u4(DumperSupport::instance_size(ik));\n+  writer->write_u4(HeapWordSize * ik->size_helper());\n@@ -1448,4 +1515,1 @@\n-int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n-  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n-  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n-\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size) {\n@@ -1454,7 +1518,0 @@\n-  int type_size;\n-  if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {\n-    type_size = sizeof(address);\n-  } else {\n-    type_size = type2aelembytes(type);\n-  }\n-\n@@ -1468,0 +1525,1 @@\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n@@ -1474,0 +1532,13 @@\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n+  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+  int type_size;\n+  if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {  \/\/ TODO: FIXME\n+    type_size = sizeof(address);\n+  } else {\n+    type_size = type2aelembytes(type);\n+  }\n+\n+  return calculate_array_max_length(writer, array, type_size, header_size);\n+}\n+\n@@ -1475,1 +1546,1 @@\n-void DumperSupport::dump_object_array(AbstractDumpWriter* writer, arrayOop array) {\n+void DumperSupport::dump_object_array(AbstractDumpWriter* writer, objArrayOop array) {\n@@ -1489,20 +1560,8 @@\n-  InlinedObjectSupport ios = writer->inlined_object_support().save();\n-  if (array->is_objArray()) {\n-    \/\/ [id]* elements\n-    objArrayOop objArray = objArrayOop(array);\n-    for (int index = 0; index < length; index++) {\n-      oop o = objArray->obj_at(index);\n-      if (o != NULL && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == NULL) {\n-        ResourceMark rm;\n-        log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n-                             p2i(o), o->klass()->external_name(),\n-                             p2i(array), array->klass()->external_name());\n-      }\n-      o = mask_dormant_archived_object(o);\n-      writer->write_objectID(o);\n-    }\n-  } else { \/\/ flatArray\n-    \/\/ [id]* elements\n-    flatArrayOop flatArray = flatArrayOop(array);\n-    for (int index = 0; index < length; index++) {\n-      writer->write_inlinedObjectID(writer->inlined_object_support());\n+  \/\/ [id]* elements\n+  for (int index = 0; index < length; index++) {\n+    oop o = array->obj_at(index);\n+    if (o != NULL && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == NULL) {\n+      ResourceMark rm;\n+      log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n+                           p2i(o), o->klass()->external_name(),\n+                           p2i(array), array->klass()->external_name());\n@@ -1510,0 +1569,2 @@\n+    o = mask_dormant_archived_object(o);\n+    writer->write_objectID(o);\n@@ -1513,0 +1574,1 @@\n+}\n@@ -1514,8 +1576,18 @@\n-  if (array->is_flatArray()) {\n-    flatArrayOop flatArray = flatArrayOop(array);\n-    FlatArrayKlass* vaklass = FlatArrayKlass::cast(flatArray->klass());\n-    InlineKlass* vklass = vaklass->element_klass();\n-    for (int index = 0; index < length; index++) {\n-      \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n-      int offset = (int)((address)flatArray->value_at_addr(index, vaklass->layout_helper())\n-                        - cast_from_oop<address>(flatArray));\n+\/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+void DumperSupport::dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array) {\n+  FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* element_klass = array_klass->element_klass();\n+  int element_size = instance_size(element_klass);\n+  \/*                          id         array object ID\n+   *                          u4         stack trace serial number\n+   *                          u4         number of elements\n+   *                          u1         element type\n+   *\/\n+  short header_size = 1 + sizeof(address) + 2 * 4 + 1;\n+\n+  \/\/ TODO: use T_SHORT\/T_INT\/T_LONG if needed to avoid truncation\n+  BasicType type = T_BYTE;\n+  int type_size = type2aelembytes(type);\n+  int length = calculate_array_max_length(writer, array, element_size, header_size);\n+  u4 length_in_bytes = (u4)(length * element_size);\n+  u4 size = header_size + length_in_bytes;\n@@ -1523,2 +1595,12 @@\n-      dump_inlined_object(writer, flatArray, offset, vklass, ios);\n-    }\n+  writer->start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);\n+  writer->write_objectID(array);\n+  writer->write_u4(STACK_TRACE_ID);\n+  \/\/ TODO: round up array length for T_SHORT\/T_INT\/T_LONG\n+  writer->write_u4(length * element_size);\n+  writer->write_u1(type2tag(type));\n+\n+  for (int index = 0; index < length; index++) {\n+    \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n+    int offset = (int)((address)array->value_at_addr(index, array_klass->layout_helper())\n+                  - cast_from_oop<address>(array));\n+    dump_inlined_object_fields(writer, array, offset, element_klass);\n@@ -1526,0 +1608,6 @@\n+\n+  \/\/ TODO: write padding bytes for T_SHORT\/T_INT\/T_LONG\n+\n+  InlinedObjects::get_instance()->add_flat_array(array);\n+\n+  writer->end_sub_record();\n@@ -1649,0 +1737,264 @@\n+class InlinedFieldNameDumper : public LockedClassesDo {\n+public:\n+  typedef void (*Callback)(InlinedObjects *owner, const Klass *klass, uintx base_index, int count);\n+\n+private:\n+  AbstractDumpWriter* _writer;\n+  InlinedObjects *_owner;\n+  Callback       _callback;\n+  uintx _index;\n+\n+  void dump_inlined_field_names(GrowableArray<Symbol*>* super_names, Symbol* field_name, InlineKlass* klass) {\n+    super_names->push(field_name);\n+    for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+        } else {\n+          \/\/ get next string ID.\n+          uintx next_index = _owner->get_next_string_id(_index);\n+          if (next_index == 0) {\n+            \/\/ something went wrong (overflow?)\n+            \/\/ stop generation; the rest of inlined objects will have original field names.\n+            return;\n+          }\n+          _index = next_index;\n+\n+          \/\/ Calculate length.\n+          int len = fld.name()->utf8_length();\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            len += (*it)->utf8_length() + 1;    \/\/ +1 for \".\".\n+          }\n+\n+          DumperSupport::write_header(_writer, HPROF_UTF8, oopSize + len);\n+          _writer->write_symbolID(reinterpret_cast<Symbol*>(_index));\n+          \/\/ Write the string value.\n+          \/\/ 1) super_names.\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            _writer->write_raw((*it)->bytes(), (*it)->utf8_length());\n+            _writer->write_u1('.');\n+          }\n+          \/\/ 2) field name.\n+          _writer->write_raw(fld.name()->bytes(), fld.name()->utf8_length());\n+        }\n+      }\n+    }\n+    super_names->pop();\n+  }\n+\n+  void dump_inlined_field_names(Symbol* field_name, InlineKlass* field_klass) {\n+    GrowableArray<Symbol*> super_names(4, mtServiceability);\n+    dump_inlined_field_names(&super_names, field_name, field_klass);\n+  }\n+\n+public:\n+  InlinedFieldNameDumper(AbstractDumpWriter* writer, InlinedObjects* owner, Callback callback)\n+    : _writer(writer), _owner(owner), _callback(callback), _index(0)  {\n+  }\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    uintx base_index = _index;\n+    int count = 0;\n+\n+    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+          count++;\n+        }\n+      }\n+    }\n+\n+    if (count != 0) {\n+      _callback(_owner, k, base_index, count);\n+    }\n+  }\n+};\n+\n+class InlinedFieldsDumper : public LockedClassesDo {\n+private:\n+  AbstractDumpWriter* _writer;\n+\n+public:\n+  InlinedFieldsDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    \/\/ We can be at a point where java mirror does not exist yet.\n+    \/\/ So we need to check that the class is at least loaded, to avoid crash from a null mirror.\n+    if (!ik->is_loaded()) {\n+      return;\n+    }\n+\n+    u2 inlined_count = 0;\n+    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          inlined_count++;\n+        }\n+      }\n+    }\n+    if (inlined_count != 0) {\n+      _writer->write_u1(HPROF_CLASS_WITH_INLINED_FIELDS);\n+\n+      \/\/ class ID\n+      _writer->write_classID(ik);\n+      \/\/ number of inlined fields\n+      _writer->write_u2(inlined_count);\n+      u2 index = 0;\n+      for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+        if (!fld.access_flags().is_static()) {\n+          if (DumperSupport::is_inlined_field(fld)) {\n+            \/\/ inlined field index\n+            _writer->write_u2(index);\n+            \/\/ synthetic field count\n+            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld));\n+            _writer->write_u2(field_count);\n+            \/\/ original field name\n+            _writer->write_symbolID(fld.name());\n+            \/\/ inlined field class ID\n+            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld));\n+\n+            index += field_count;\n+          } else {\n+            index++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\n+void InlinedObjects::init() {\n+  _instance = this;\n+\n+  struct Closure : public SymbolClosure {\n+    uintx _min_id = max_uintx;\n+    uintx _max_id = 0;\n+    Closure() : _min_id(max_uintx), _max_id(0) {}\n+\n+    void do_symbol(Symbol** p) {\n+      uintx val = reinterpret_cast<uintx>(*p);\n+      if (val < _min_id) {\n+        _min_id = val;\n+      }\n+      if (val > _max_id) {\n+        _max_id = val;\n+      }\n+    }\n+  } closure;\n+\n+  SymbolTable::symbols_do(&closure);\n+\n+  _min_string_id = closure._min_id;\n+  _max_string_id = closure._max_id;\n+}\n+\n+void InlinedObjects::release() {\n+  _instance = nullptr;\n+\n+  if (_inlined_field_map != nullptr) {\n+    delete _inlined_field_map;\n+    _inlined_field_map = nullptr;\n+  }\n+  if (_flat_arrays != nullptr) {\n+    delete _flat_arrays;\n+    _flat_arrays = nullptr;\n+  }\n+}\n+\n+void InlinedObjects::inlined_field_names_callback(InlinedObjects* _this, const Klass* klass, uintx base_index, int count) {\n+  if (_this->_inlined_field_map == nullptr) {\n+    _this->_inlined_field_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n+  }\n+  _this->_inlined_field_map->append(ClassInlinedFields(klass, base_index));\n+\n+  \/\/ counters for dumping classes with inlined fields\n+  _this->_classes_count++;\n+  _this->_inlined_fields_count += count;\n+}\n+\n+void InlinedObjects::dump_inlined_field_names(AbstractDumpWriter* writer) {\n+  InlinedFieldNameDumper nameDumper(writer, this, inlined_field_names_callback);\n+  ClassLoaderDataGraph::classes_do(&nameDumper);\n+\n+  if (_inlined_field_map != nullptr) {\n+    \/\/ prepare the map for  get_base_index_for().\n+    _inlined_field_map->sort(ClassInlinedFields::compare);\n+  }\n+}\n+\n+uintx InlinedObjects::get_base_index_for(Klass* k) {\n+  if (_inlined_field_map != nullptr) {\n+    bool found = false;\n+    int idx = _inlined_field_map->find_sorted<ClassInlinedFields, ClassInlinedFields::compare>(ClassInlinedFields(k, 0), found);\n+    if (found) {\n+        return _inlined_field_map->at(idx).base_index;\n+    }\n+  }\n+\n+  \/\/ return max_uintx, so get_next_string_id returns 0.\n+  return max_uintx;\n+}\n+\n+uintx InlinedObjects::get_next_string_id(uintx id) {\n+  if (++id == _min_string_id) {\n+    return _max_string_id + 1;\n+  }\n+  return id;\n+}\n+\n+void InlinedObjects::dump_classed_with_inlined_fields(AbstractDumpWriter* writer) {\n+  if (_classes_count != 0) {\n+    \/\/ Record for each class contains tag(u1), class ID and count(u2)\n+    \/\/ for each inlined field index(u2), synthetic fields count(u2), original field name and class ID\n+    int size = _classes_count * (1 + sizeof(address) + 2)\n+             + _inlined_fields_count * (2 + 2 + sizeof(address) + sizeof(address));\n+    DumperSupport::write_header(writer, HPROF_INLINED_FIELDS, (u4)size);\n+\n+    InlinedFieldsDumper dumper(writer);\n+    ClassLoaderDataGraph::classes_do(&dumper);\n+  }\n+}\n+\n+void InlinedObjects::add_flat_array(oop array) {\n+  if (_flat_arrays == nullptr) {\n+    _flat_arrays = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(100, mtServiceability);\n+  }\n+  _flat_arrays->append(array);\n+}\n+\n+void InlinedObjects::dump_flat_arrays(AbstractDumpWriter* writer) {\n+  if (_flat_arrays != nullptr) {\n+    \/\/ For each flat array the record contains tag (u1), object ID and class ID.\n+    int size = _flat_arrays->length() * (1 + sizeof(address) + sizeof(address));\n+\n+    DumperSupport::write_header(writer, HPROF_FLAT_ARRAYS, (u4)size);\n+    for (GrowableArrayIterator<oop> it = _flat_arrays->begin(); it != _flat_arrays->end(); ++it) {\n+      flatArrayOop array = flatArrayOop(*it);\n+      FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+      InlineKlass* element_klass = array_klass->element_klass();\n+      writer->write_u1(HPROF_FLAT_ARRAY);\n+      writer->write_objectID(array);\n+      writer->write_classID(element_klass);\n+    }\n+  }\n+}\n+\n+\n@@ -1868,1 +2220,1 @@\n-  } else if (o->is_objArray() || o->is_flatArray()) {\n+  } else if (o->is_objArray()) {\n@@ -1870,1 +2222,3 @@\n-    DumperSupport::dump_object_array(writer(), arrayOop(o));\n+    DumperSupport::dump_object_array(writer(), objArrayOop(o));\n+  } else if (o->is_flatArray()) {\n+    DumperSupport::dump_flat_array(writer(), flatArrayOop(o));\n@@ -1889,0 +2243,8 @@\n+  } else if (o->is_typeArray()) {\n+    flatArrayOop array = flatArrayOop(o);\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+    assert(type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+    int length = array->length();\n+    \/\/TODO: FIXME\n+    \/\/int type_size = type2aelembytes(type);\n+    \/\/size = (size_t)length * type_size;\n@@ -1961,0 +2323,5 @@\n+\n+  \/\/ Inlined object support.\n+  InlinedObjects          _inlined_objects;\n+  InlinedObjects* inlined_objects() { return &_inlined_objects; }\n+\n@@ -2370,0 +2737,7 @@\n+    \/\/ HPROF_UTF8 records for inlined field names.\n+    inlined_objects()->init();\n+    inlined_objects()->dump_inlined_field_names(writer());\n+\n+    \/\/ HPROF_INLINED_FIELDS\n+    inlined_objects()->dump_classed_with_inlined_fields(writer());\n+\n@@ -2448,0 +2822,3 @@\n+\n+  inlined_objects()->dump_flat_arrays(writer());\n+\n@@ -2450,0 +2827,2 @@\n+\n+  inlined_objects()->release();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":548,"deletions":169,"binary":false,"changes":717,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.lang.ref.Reference;\n@@ -35,3 +36,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n@@ -42,0 +40,1 @@\n+import jdk.test.lib.hprof.model.InlinedJavaObject;\n@@ -61,0 +60,4 @@\n+    public static primitive class MyPrimitive0 {\n+        public byte prim0_fld1;\n+        public MyPrimitive0(int fld1) { prim0_fld1 = (byte)fld1; }\n+    }\n@@ -62,2 +65,3 @@\n-        public byte fld1;\n-        public int fld2;\n+        public MyPrimitive0 prim_prim0;\n+        public byte prim_fld1;\n+        public int prim_fld2;\n@@ -65,2 +69,3 @@\n-        public MyPrimitive(int v1, int v2) { fld1 = (byte)v1; fld2 = v2; }\n-        public static MyPrimitive create(int v1, int v2) { return new MyPrimitive(v1, v2); }\n+        public MyPrimitive(int p0, int fld1, int fld2) {\n+            prim_fld1 = (byte)fld1; prim_fld2 = fld2; prim_prim0 = new MyPrimitive0(p0);\n+        }\n@@ -70,2 +75,2 @@\n-        \/\/ offset of the inlined flatObj is the same as offset of inlined PrimitiveHolder\n-        public MyPrimitive flatObj = MyPrimitive.create(12, 142);\n+        \/\/ offset of the inlined hld_flatObj is the same as offset of inlined PrimitiveHolder\n+        public MyPrimitive hld_flatObj;\n@@ -73,2 +78,3 @@\n-        public PrimitiveHolder(int n) { }\n-        public static PrimitiveHolder create(int n) { return new PrimitiveHolder(n); }\n+        public PrimitiveHolder(int n) {\n+            hld_flatObj = new MyPrimitive((byte)n, n+1, n+2);\n+        }\n@@ -79,6 +85,8 @@\n-        public int fld1;\n-        public int fld2;\n-        public String strObj;\n-\n-        public MyPrimitiveRef(int v1, int v2) { fld1 = v1; fld2 = v2; strObj = \"#\" + String.valueOf(v1); }\n-        public static MyPrimitiveRef create(int v1, int v2) { return new MyPrimitiveRef(v1, v2); }\n+        public byte ref_fld1;\n+        public int ref_fld2;\n+        public String ref_strObj;\n+\n+        public MyPrimitiveRef(int v1, int v2) {\n+            ref_fld1 = (byte)v1;\n+            ref_fld2 = v2;\n+            ref_strObj = \"#\" + String.valueOf(v2); }\n@@ -88,3 +96,3 @@\n-        public MyPrimitiveRef[] flatArr = new MyPrimitiveRef[4];\n-        public MyPrimitiveRef flatObj = MyPrimitiveRef.create(13, 143);\n-\n+        public MyPrimitiveRef[] flatArr = new MyPrimitiveRef[5];\n+        public MyPrimitiveRef flatObj;\n+        public String ref_str;\n@@ -92,0 +100,2 @@\n+            ref_str = String.valueOf(n);\n+            flatObj = new MyPrimitiveRef(n, n + 10);\n@@ -93,1 +103,1 @@\n-                flatArr[i] = MyPrimitiveRef.create(i + n + 1, i + n + 11);\n+                flatArr[i] = new MyPrimitiveRef(i + n + 1, i + n + 11);\n@@ -96,1 +106,0 @@\n-        public static PrimitiveHolderRef create(int n) { return new PrimitiveHolderRef(n); }\n@@ -99,3 +108,3 @@\n-    public MyPrimitive[] flatArr = new MyPrimitive[4];\n-    public MyPrimitive flatObj = MyPrimitive.create(11, 141);\n-    public MyPrimitiveRef flatObjRef = MyPrimitiveRef.create(11, 144);\n+    public MyPrimitive[] main_flatArr = new MyPrimitive[3];\n+    public MyPrimitive main_flatObj = new MyPrimitive(10, 15, 9);\n+    public MyPrimitiveRef main_flatObjRef = new MyPrimitiveRef(11, 144);\n@@ -103,1 +112,1 @@\n-    public String strObj = \"targ.strObj\";\n+    public String main_strObj = \"targ.strObj\";\n@@ -105,1 +114,1 @@\n-    public Object nullObj;\n+    public Object main_nullObj;\n@@ -107,1 +116,1 @@\n-    public final PrimitiveHolder primHolder = PrimitiveHolder.create(16);\n+    public final PrimitiveHolder main_primHolder = new PrimitiveHolder(16);\n@@ -113,2 +122,2 @@\n-    public static MyPrimitive flatObjStatic = MyPrimitive.create(11, 241);\n-    public static MyPrimitiveRef[] flatArrRefStatic = new MyPrimitiveRef[4];\n+    public static MyPrimitive main_flatObjStatic = new MyPrimitive(13, 241, 24);\n+    public static MyPrimitiveRef[] flatArrRefStatic = new MyPrimitiveRef[6];\n@@ -117,1 +126,1 @@\n-            flatArrRefStatic[i] = MyPrimitiveRef.create(i + 200, i + 225);\n+            flatArrRefStatic[i] = new MyPrimitiveRef(i + 200, i + 225);\n@@ -122,2 +131,2 @@\n-        for (int i = 0; i < flatArr.length; i++) {\n-            flatArr[i] = MyPrimitive.create(i + 10, i + 110);\n+        for (int i = 0; i < main_flatArr.length; i++) {\n+            main_flatArr[i] = new MyPrimitive(i + 10, i + 110, i + 35);\n@@ -126,1 +135,1 @@\n-            flatArrRef[i] = MyPrimitiveRef.create(i + 100, i + 120);\n+            flatArrRef[i] = new MyPrimitiveRef(i + 100, i + 120);\n@@ -129,1 +138,1 @@\n-            primHolderArr[i] = PrimitiveHolderRef.create(20+i);\n+            primHolderArr[i] = new PrimitiveHolderRef(20 + i);\n@@ -139,1 +148,1 @@\n-        System.out.println(testObj);\n+        Reference.reachabilityFence(testObj);\n@@ -145,15 +154,0 @@\n-\n-    public static void copyDirectory(String sourceDirectoryLocation, String destinationDirectoryLocation)\n-            throws Exception {\n-        Files.walk(Paths.get(sourceDirectoryLocation))\n-                .forEach(source -> {\n-                    Path destination = Paths.get(destinationDirectoryLocation, source.toString()\n-                            .substring(sourceDirectoryLocation.length()));\n-                    try {\n-                        Files.copy(source, destination);\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n-                });\n-    }\n-\n@@ -166,0 +160,1 @@\n+            \/\/ -XX:+PrintInlineLayout is debug-only arg\n@@ -168,1 +163,1 @@\n-            \/\/jcmd <pid> GC.heap_dump\n+            \/\/ jcmd <pid> GC.heap_dump\n@@ -188,6 +183,1 @@\n-            try {\n-                copyDirectory(\".\", System.getProperty(\"test.classes\") + \"\/scratch\");\n-            } finally {\n-                LingeredApp.stopApp(theApp);\n-            }\n-\n+            LingeredApp.stopApp(theApp);\n@@ -248,1 +238,0 @@\n-            \/\/ we know testValue != null\n@@ -280,0 +269,1 @@\n+                    + (testField.getType().isPrimitiveClass() ? \"(primitive) \" : \"\")\n@@ -311,2 +301,2 @@\n-                            if ((char) arr.getElementType() != testElementType) {\n-                                throw new Exception(\"wrong element type: '\" + (char) arr.getElementType() + \"'\");\n+                            if ((char)arr.getElementType() != testElementType) {\n+                                throw new Exception(\"wrong element type: '\" + (char)arr.getElementType() + \"'\");\n@@ -323,2 +313,6 @@\n-                                comparePrimitiveValues(elementValue, dumpElements[j]);\n-                                log(logPrefix + \"  [\" + j + \"]: \" + elementValue + \" ( == \" + dumpElements[j] + \")\");\n+                                if (arr.isFlatArray()) {\n+                                    compareObjects(logPrefix + \"  \", elementValue, dumpElements[j]);\n+                                } else {\n+                                    comparePrimitiveValues(elementValue, dumpElements[j]);\n+                                    log(logPrefix + \"  [\" + j + \"]: \" + elementValue + \" ( == \" + dumpElements[j] + \")\");\n+                                }\n@@ -385,1 +379,5 @@\n-        if (dumpField.getSignature().charAt(0) != type) {\n+        char dumpType = dumpField.getSignature().charAt(0);\n+        if (dumpType == 'Q') {\n+            dumpType = 'L';\n+        }\n+        if (dumpType != type) {\n@@ -466,1 +464,1 @@\n-                    log(logPrefix + \"object \" + obj);\n+                    log(logPrefix + (value instanceof InlinedJavaObject ? \"inlined \" : \"\") + \"object \" + obj);\n@@ -478,2 +476,13 @@\n-            } else if (value instanceof JavaValueArray arr) { \/\/ array of primitive type\n-                log(logPrefix + \"(array of '\" + (char) arr.getElementType() + \"')\" + \": \" + arr.valueString());\n+            } else if (value instanceof JavaValueArray arr) { \/\/ array of primitive type or flat array\n+                if (arr.isFlatArray()) {\n+                    log(logPrefix + \" flat array \" + arr + \" length: \" + arr.getLength());\n+                    JavaThing[] values = arr.getElements();\n+                    for (int v = 0; v < values.length; v++) {\n+                        log(prefix + \"  [\" + v + \"]: \" + values[v]);\n+                        if (values[v] instanceof JavaObject obj) {\n+                            print(prefix + \"    \", obj);\n+                        }\n+                    }\n+                } else {\n+                    log(logPrefix + \"(array of '\" + (char)arr.getElementType() + \"')\" + \": \" + arr.valueString());\n+                }\n@@ -481,1 +490,1 @@\n-                log(logPrefix + value.toString());\n+                log(logPrefix + \"(\" + value.getClass() +  \")\" + value.toString());\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/HeapDump\/HeapDump.java","additions":78,"deletions":69,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hprof.model;\n+\n+public class InlinedJavaField extends JavaField {\n+\n+    private final JavaClass inlinedFieldClass;\n+\n+    public InlinedJavaField(String name, String signature, JavaClass inlinedFieldClass) {\n+        super(name, signature);\n+        this.inlinedFieldClass = inlinedFieldClass;\n+    }\n+\n+    @Override\n+    public boolean hasId() {\n+        return false;\n+    }\n+\n+    public JavaClass getInlinedFieldClass() {\n+        return inlinedFieldClass;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/InlinedJavaField.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hprof.model;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * Represents Inlined Java object\n+ *\/\n+public class InlinedJavaObject extends JavaObject {\n+\n+    \/**\n+     * Construct a new InlinedJavaObject.\n+     *\n+     * @param clazz the class object\n+     * @param offset The offset of field data\n+     *\/\n+    public InlinedJavaObject(JavaClass clazz, long offset) {\n+        super(clazz, offset);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"inlined \" + super.toString();\n+    }\n+\n+    @Override\n+    protected final long readValueLength() throws IOException {\n+        \/\/ TODO: revise - clazz.getInlinedInstanceSize()?\n+        return 0;\n+    }\n+\n+    @Override\n+    protected long dataStartOffset() {\n+        return getOffset();\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/InlinedJavaObject.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,3 @@\n+    \/\/ Size of the instance in the object of the class is inlined.\n+    \/\/ Calculated lazily.\n+    private int inlinedInstanceSize = -1;\n@@ -119,0 +122,40 @@\n+\n+        \/\/ Resolve inlined fields. Should be done before resolveSuperclass for correct field counting\n+        Snapshot.ClassInlinedFields[] inlinedFields = snapshot.findClassInlinedFields(id);\n+        if (inlinedFields != null) {\n+            int newCount = fields.length;\n+            for (Snapshot.ClassInlinedFields f: inlinedFields) {\n+                if (f.synthFieldCount == 0) {\n+                    \/\/ Empty primitive class. just skip it - no data there.\n+                    continue;\n+                }\n+                JavaHeapObject clazz = snapshot.findThing(f.fieldClassID);\n+                if (clazz instanceof JavaClass fieldClass) {\n+                    fieldClass.resolve(snapshot);\n+\n+                    \/\/ Set new field.\n+                    fields[f.fieldIndex] = new InlinedJavaField(f.fieldName, 'Q' + fieldClass.getName() + ';', fieldClass);\n+                    newCount -= (f.synthFieldCount - 1);\n+                    \/\/ Reset invalid fields.\n+                    for (int i = 1; i < f.synthFieldCount; i++) {\n+                        fields[f.fieldIndex + i] = null;\n+                    }\n+                } else {\n+                    \/\/ The field class not found.\n+                    System.out.println(\"WARNING: class of inlined field not found:\" + getName() + \".\" + f.fieldName);\n+                }\n+            }\n+\n+            \/\/ Set new fields.\n+            JavaField[] newFields = new JavaField[newCount];\n+            int oldIndex = 0;\n+            for (int i = 0; i < newFields.length; i++) {\n+                while (fields[oldIndex] == null) {\n+                    oldIndex++;\n+                }\n+                newFields[i] = fields[oldIndex];\n+                oldIndex++;\n+            }\n+            fields = newFields;\n+        }\n+\n@@ -133,0 +176,1 @@\n+\n@@ -382,0 +426,43 @@\n+    public int getInlinedInstanceSize() {\n+        if (inlinedInstanceSize < 0) {\n+            int size = 0;\n+            for (JavaField f: fields) {\n+                if (f instanceof InlinedJavaField inlinedField) {\n+                    size += inlinedField.getInlinedFieldClass().getInlinedInstanceSize();\n+                } else {\n+                    char sig = f.getSignature().charAt(0);\n+                    switch (sig) {\n+                        case 'Q': {\n+                            System.out.println(\"WARNING: (getInlinedInstanceSize) field \"\n+                                    + getClazz().getName() + \".\" + f.getName()\n+                                    + \" is not inlined, but has Q-signature: \" + f.getSignature());\n+                        } \/\/ continue as 'L' object\n+                        case 'L':\n+                        case '[':\n+                            size += mySnapshot.getIdentifierSize();\n+                            break;\n+                        case 'B':\n+                        case 'Z':\n+                            size += 1;\n+                            break;\n+                        case 'C':\n+                        case 'S':\n+                            size += 2;\n+                            break;\n+                        case 'I':\n+                        case 'F':\n+                            size += 4;\n+                            break;\n+                        case 'J':\n+                        case 'D':\n+                            size += 8;\n+                            break;\n+                        default:\n+                            throw new RuntimeException(\"unknown field type: \" + sig);\n+                    }\n+                }\n+            }\n+            inlinedInstanceSize = size;\n+        }\n+        return inlinedInstanceSize;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaClass.java","additions":88,"deletions":1,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,6 @@\n+\n+    public JavaObject(Object clazz, long offset) {\n+        super(offset);\n+        this.clazz = clazz;\n+    }\n+\n@@ -54,2 +60,1 @@\n-        super(offset);\n-        this.clazz = makeId(classID);\n+        this(makeId(classID), offset);\n@@ -216,1 +221,1 @@\n-    protected final long readValueLength() throws IOException {\n+    protected long readValueLength() throws IOException {\n@@ -226,1 +231,1 @@\n-    private long dataStartOffset() {\n+    protected long dataStartOffset() {\n@@ -260,59 +265,68 @@\n-                switch (sig) {\n-                    case 'L':\n-                    case '[': {\n-                        long id = objectIdAt(offset);\n-                        offset += idSize();\n-                        JavaObjectRef ref = new JavaObjectRef(id);\n-                        fieldValues[target+fieldNo] = ref.dereference(snapshot, f, verbose);\n-                        break;\n-                    }\n-                    case 'Z': {\n-                        byte value = byteAt(offset);\n-                        offset++;\n-                        fieldValues[target+fieldNo] = new JavaBoolean(value != 0);\n-                        break;\n-                    }\n-                    case 'B': {\n-                        byte value = byteAt(offset);\n-                        offset++;\n-                        fieldValues[target+fieldNo] = new JavaByte(value);\n-                        break;\n-                    }\n-                    case 'S': {\n-                        short value = shortAt(offset);\n-                        offset += 2;\n-                        fieldValues[target+fieldNo] = new JavaShort(value);\n-                        break;\n-                    }\n-                    case 'C': {\n-                        char value = charAt(offset);\n-                        offset += 2;\n-                        fieldValues[target+fieldNo] = new JavaChar(value);\n-                        break;\n-                    }\n-                    case 'I': {\n-                        int value = intAt(offset);\n-                        offset += 4;\n-                        fieldValues[target+fieldNo] = new JavaInt(value);\n-                        break;\n-                    }\n-                    case 'J': {\n-                        long value = longAt(offset);\n-                        offset += 8;\n-                        fieldValues[target+fieldNo] = new JavaLong(value);\n-                        break;\n-                    }\n-                    case 'F': {\n-                        float value = floatAt(offset);\n-                        offset += 4;\n-                        fieldValues[target+fieldNo] = new JavaFloat(value);\n-                        break;\n-                    }\n-                    case 'D': {\n-                        double value = doubleAt(offset);\n-                        offset += 8;\n-                        fieldValues[target+fieldNo] = new JavaDouble(value);\n-                        break;\n-                    }\n-                    default:\n-                        throw new RuntimeException(\"invalid signature: \" + sig);\n+                if (f instanceof InlinedJavaField inlinedField) {\n+                    JavaClass fieldClass = inlinedField.getInlinedFieldClass();\n+                    fieldValues[target+fieldNo] = new InlinedJavaObject(fieldClass, offset);\n+                    offset += fieldClass.getInlinedInstanceSize();\n+                } else {\n+                    switch (sig) {\n+                        case 'Q': {\n+                            warn(\"(parseFields) field \" + getClazz().getName() + \".\" + f.getName()\n+                                    + \" is not inlined, but has Q-signature: \" + f.getSignature());\n+                        } \/\/ continue as 'L' object\n+                        case 'L':\n+                        case '[': {\n+                            long id = objectIdAt(offset);\n+                            offset += idSize();\n+                            JavaObjectRef ref = new JavaObjectRef(id);\n+                            fieldValues[target + fieldNo] = ref.dereference(snapshot, f, verbose);\n+                            break;\n+                        }\n+                        case 'Z': {\n+                            byte value = byteAt(offset);\n+                            offset++;\n+                            fieldValues[target + fieldNo] = new JavaBoolean(value != 0);\n+                            break;\n+                        }\n+                        case 'B': {\n+                            byte value = byteAt(offset);\n+                            offset++;\n+                            fieldValues[target + fieldNo] = new JavaByte(value);\n+                            break;\n+                        }\n+                        case 'S': {\n+                            short value = shortAt(offset);\n+                            offset += 2;\n+                            fieldValues[target + fieldNo] = new JavaShort(value);\n+                            break;\n+                        }\n+                        case 'C': {\n+                            char value = charAt(offset);\n+                            offset += 2;\n+                            fieldValues[target + fieldNo] = new JavaChar(value);\n+                            break;\n+                        }\n+                        case 'I': {\n+                            int value = intAt(offset);\n+                            offset += 4;\n+                            fieldValues[target + fieldNo] = new JavaInt(value);\n+                            break;\n+                        }\n+                        case 'J': {\n+                            long value = longAt(offset);\n+                            offset += 8;\n+                            fieldValues[target + fieldNo] = new JavaLong(value);\n+                            break;\n+                        }\n+                        case 'F': {\n+                            float value = floatAt(offset);\n+                            offset += 4;\n+                            fieldValues[target + fieldNo] = new JavaFloat(value);\n+                            break;\n+                        }\n+                        case 'D': {\n+                            double value = doubleAt(offset);\n+                            offset += 8;\n+                            fieldValues[target + fieldNo] = new JavaDouble(value);\n+                            break;\n+                        }\n+                        default:\n+                            throw new RuntimeException(\"invalid signature: \" + sig);\n@@ -320,0 +334,1 @@\n+                    }\n@@ -321,4 +336,4 @@\n-        } catch (IOException exp) {\n-            System.err.println(\"lazy read failed at offset \" + offset);\n-            exp.printStackTrace();\n-            return Snapshot.EMPTY_JAVATHING_ARRAY;\n+            } catch (IOException exp) {\n+                System.err.println(\"lazy read failed at offset \" + offset);\n+                exp.printStackTrace();\n+                return Snapshot.EMPTY_JAVATHING_ARRAY;\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaObject.java","additions":83,"deletions":68,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n- * An array of values, that is, an array of ints, boolean, floats or the like.\n+ * An array of values, that is, an array of ints, boolean, floats, etc.\n+ * or flat array of primitive objects.\n@@ -46,23 +47,0 @@\n-    private static String arrayTypeName(byte sig) {\n-        switch (sig) {\n-            case 'B':\n-                return \"byte[]\";\n-            case 'Z':\n-                return \"boolean[]\";\n-            case 'C':\n-                return \"char[]\";\n-            case 'S':\n-                return \"short[]\";\n-            case 'I':\n-                return \"int[]\";\n-            case 'F':\n-                return \"float[]\";\n-            case 'J':\n-                return \"long[]\";\n-            case 'D':\n-                return \"double[]\";\n-            default:\n-                throw new RuntimeException(\"invalid array element sig: \" + sig);\n-        }\n-    }\n-\n@@ -104,1 +82,1 @@\n-        return len * elementSize(getElementType());\n+        return len * elementSize(getRealElementType());\n@@ -176,0 +154,7 @@\n+                case 'Q': {\n+                    for (int i = 0; i < len; i++) {\n+                        res[i] = new InlinedJavaObject(flatArrayElementClass, offset);\n+                        offset += flatArrayElementClass.getInlinedInstanceSize();\n+                    }\n+                    return res;\n+                }\n@@ -186,0 +171,2 @@\n+    private long objID;\n+\n@@ -201,1 +188,4 @@\n-    public JavaValueArray(byte elementSignature, long offset) {\n+    \/\/ Flat array support.\n+    private JavaClass flatArrayElementClass;\n+\n+    public JavaValueArray(long id, byte elementSignature, long offset) {\n@@ -203,0 +193,1 @@\n+        this.objID = id;\n@@ -210,0 +201,8 @@\n+    public boolean isFlatArray() {\n+        return flatArrayElementClass != null;\n+    }\n+\n+    public JavaClass getFlatElementClazz() {\n+        return flatArrayElementClass;\n+    }\n+\n@@ -218,4 +217,17 @@\n-        byte elementSig = getElementType();\n-        clazz = snapshot.findClass(arrayTypeName(elementSig));\n-        if (clazz == null) {\n-            clazz = snapshot.getArrayClass(\"\" + ((char) elementSig));\n+\n+        byte elementType = getElementType();\n+        String elementSig = \"\" + (char)elementType;\n+        \/\/ Check if this is a flat array of primitive objects.\n+        Number elementClassID = snapshot.findFlatArrayElementType(objID);\n+        if (elementClassID != null) {\n+            \/\/ This is flat array.\n+            JavaHeapObject elementClazz = snapshot.findThing(getIdValue(elementClassID));\n+            if (elementClazz instanceof JavaClass elementJavaClazz) {\n+                flatArrayElementClass = elementJavaClazz;\n+                \/\/ need to resolve the element class\n+                flatArrayElementClass.resolve(snapshot);\n+                elementSig = \"Q\" + flatArrayElementClass.getName() + \";\";\n+            } else {\n+                \/\/ The class not found.\n+                System.out.println(\"WARNING: flat array element class not found\");\n+            }\n@@ -223,0 +235,1 @@\n+        clazz = snapshot.getArrayClass(elementSig);\n@@ -248,0 +261,3 @@\n+            case 'Q':\n+                divider = flatArrayElementClass.getInlinedInstanceSize();\n+                break;\n@@ -262,0 +278,4 @@\n+        return isFlatArray() ? (byte)'Q' : getRealElementType();\n+    }\n+\n+    private byte getRealElementType() {\n@@ -284,1 +304,1 @@\n-        if (elementSignature == 'C')  {\n+        if (elementSignature == 'C' && !isFlatArray())  {\n@@ -343,0 +363,4 @@\n+                    case 'Q': {\n+                        InlinedJavaObject obj = (InlinedJavaObject)things[i];\n+                        result.append(obj);\n+                    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":55,"deletions":31,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,4 @@\n+    private Map<Number, Number> flatArrays = new HashMap<>();\n+\n+    private Map<Number, ClassInlinedFields[]> inlinedFields = new HashMap<>();\n+\n@@ -207,0 +211,35 @@\n+    public void addFlatArray(long objID, long elementClassID) {\n+        flatArrays.put(makeId(objID), makeId(elementClassID));\n+    }\n+\n+    \/**\n+     * @return null if the array is not flat array\n+     *\/\n+    Number findFlatArrayElementType(long arrayObjectID) {\n+        return flatArrays.get(makeId(arrayObjectID));\n+    }\n+\n+    public static class ClassInlinedFields {\n+        final int fieldIndex;\n+        final int synthFieldCount;\n+        final String fieldName;\n+        final long fieldClassID;\n+\n+        public ClassInlinedFields(int fieldIndex, int synthFieldCount, String fieldName, long fieldClassID) {\n+            this.fieldIndex = fieldIndex;\n+            this.synthFieldCount = synthFieldCount;\n+            this.fieldName = fieldName;\n+            this.fieldClassID =  fieldClassID;\n+        }\n+    }\n+\n+    public void addClassInlinedFields(long classID, ClassInlinedFields[] fields) {\n+        inlinedFields.put(makeId(classID), fields);\n+    }\n+\n+    \/**\n+     * @return null if the class has no inlined fields\n+     *\/\n+    ClassInlinedFields[] findClassInlinedFields(long classID) {\n+        return inlinedFields.get(makeId(classID));\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -101,0 +101,6 @@\n+    static final int HPROF_FLAT_ARRAYS          = 0x12;\n+    static final int HPROF_INLINED_FIELDS       = 0x13;\n+\n+    static final int HPROF_FLAT_ARRAY           = 0x01;\n+    static final int HPROF_CLASS_WITH_INLINED_FIELDS = 0x01;\n+\n@@ -247,1 +253,1 @@\n-                    if (dumpsToSkip <= 0) {\n+                    if (dumpsToSkip == 0) {\n@@ -256,1 +262,0 @@\n-                        return snapshot;\n@@ -266,3 +271,3 @@\n-                        if (dumpsToSkip <= 0) {\n-                            skipBytes(length);  \/\/ should be no-op\n-                            return snapshot;\n+                        if (dumpsToSkip == 0) {\n+                            \/\/ update dumpsToSkip to skip other dumps\n+                            dumpsToSkip--;\n@@ -283,1 +288,1 @@\n-                        if (dumpsToSkip <= 0) {\n+                        if (dumpsToSkip == 0) {\n@@ -357,0 +362,9 @@\n+                case HPROF_FLAT_ARRAYS: {\n+                    readFlatArrays(length);\n+                    break;\n+                }\n+                case HPROF_INLINED_FIELDS: {\n+                    readInlinedFields(length);\n+                    break;\n+                }\n+\n@@ -855,1 +869,1 @@\n-            JavaValueArray va = new JavaValueArray(primitiveSignature, start);\n+            JavaValueArray va = new JavaValueArray(id, primitiveSignature, start);\n@@ -905,0 +919,52 @@\n+    private void readFlatArrays(long length) throws IOException {\n+        while (length > 0) {\n+            byte tag = in.readByte();\n+            length--;\n+            switch (tag) {\n+                case HPROF_FLAT_ARRAY: {\n+                    long objId = readID();\n+                    length -= identifierSize;\n+                    long elementClassId = readID();\n+                    length -= identifierSize;\n+                    snapshot.addFlatArray(objId, elementClassId);\n+                    break;\n+                }\n+                default: {\n+                    throw new IOException(\"Invalid tag \" + tag);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void readInlinedFields(long length) throws IOException {\n+        while (length > 0) {\n+            byte tag = in.readByte();\n+            length--;\n+            switch (tag) {\n+                case HPROF_CLASS_WITH_INLINED_FIELDS: {\n+                    long classID = readID();\n+                    length -= identifierSize;\n+                    int fieldNum = in.readUnsignedShort();\n+                    length -= 2;\n+                    Snapshot.ClassInlinedFields[] fields = new Snapshot.ClassInlinedFields[fieldNum];\n+                    for (int i = 0; i < fieldNum; i++) {\n+                        int fieldIndex = in.readUnsignedShort();\n+                        length -= 2;\n+                        int synthFieldCount = in.readUnsignedShort();\n+                        length -= 2;\n+                        String fieldName = getNameFromID(readID());\n+                        length -= identifierSize;\n+                        long fieldClassId = readID();\n+                        length -= identifierSize;\n+                        fields[i] = new Snapshot.ClassInlinedFields(fieldIndex, synthFieldCount, fieldName, fieldClassId);\n+                    }\n+                    snapshot.addClassInlinedFields(classID, fields);\n+                    break;\n+                }\n+                default: {\n+                    throw new IOException(\"Invalid tag \" + tag);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"}]}