{"files":[{"patch":"@@ -612,2 +612,0 @@\n-        boolean tValue = t.isPrimitiveClass();\n-        boolean sValue = s.isPrimitiveClass();\n@@ -627,2 +625,8 @@\n-        if (tValue != sValue) {\n-            boolean result = tValue ?\n+        boolean tIsPrimitiveClass = t.isPrimitiveClass();\n+        boolean sIsPrimitiveClass = s.isPrimitiveClass();\n+\n+        \/* next experiment should be to remove all this chunk of code but that will requiere changes in other areas\n+         * like mappings when type variables are present etc\n+         *\/\n+        if (tIsPrimitiveClass != sIsPrimitiveClass) {\n+            boolean result = tIsPrimitiveClass ?\n@@ -632,3 +636,9 @@\n-                    s.isPrimitiveClass() && !t.isPrimitiveClass() &&\n-                    s.referenceProjectionOrSelf().tsym == t.tsym)) {\n-                chk.warnUnchecked(warn.pos(), Warnings.PrimitiveValueConversion);\n+                    s.isPrimitiveClass() && !t.isPrimitiveClass())) {\n+                \/\/ let's check for an erroneous corner case: when the user defines an anonymous class of a primitive class\n+                \/\/ we don't want to issue a warning in that case\n+                boolean anonymousPrimitiveClass = !tIsPrimitiveClass ?\n+                        t.hasTag(CLASS) && supertype(t).isPrimitiveClass() :\n+                        s.hasTag(CLASS) && supertype(s).isPrimitiveClass();\n+                if (!anonymousPrimitiveClass) {\n+                    warn.warn(LintCategory.UNCHECKED);\n+                }\n@@ -641,1 +651,1 @@\n-        if (tPrimitive == sPrimitive) {\n+        if (tPrimitive == sPrimitive || tIsPrimitiveClass != sIsPrimitiveClass) {\n@@ -652,2 +662,2 @@\n-            ? isSubtype(boxedClass(t).type, s)\n-            : isSubtype(unboxedType(t), s);\n+                ? isSubtype(boxedClass(t).type, s)\n+                : isSubtype(unboxedType(t), s);\n@@ -1133,3 +1143,8 @@\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+                if (t2 != null) {\n+                    if (t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n@@ -1137,1 +1152,7 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        if (!isSameType(t2, s) &&\n+                                t2.isReferenceProjection() == s.isReferenceProjection() &&\n+                                structuralComparator.visit(t2, s)) {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                            return true;\n+                        }\n+                        return false;\n@@ -1139,1 +1160,0 @@\n-                    return true;\n@@ -1144,0 +1164,153 @@\n+        \/\/ where\n+        StructuralTypeComparator structuralComparator = new StructuralTypeComparator();\n+        class StructuralTypeComparator extends TypeRelation {\n+            private Set<TypePair> cache = new HashSet<>();\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                return t.hasTag(s.getTag());\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Type s) {\n+                if (t == s)\n+                    return true;\n+                return s.hasTag(ARRAY)\n+                        && visit(t.elemtype, elemtype(s));\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                \/\/ If t is an intersection, sup might not be a class type\n+                if (!t.hasTag(CLASS)) return false;\n+                return t.tsym == s.tsym\n+                        && (t.tsym != s.tsym || t.referenceProjectionOrSelf().tsym == s.referenceProjectionOrSelf().tsym)\n+                        && (!s.isParameterized() || compareTypeArgsRecursive(s, t))\n+                        && visit(t.getEnclosingType(), s.getEnclosingType());\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar other = (TypeVar)s;\n+                    if (allowUniversalTVars &&\n+                            t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+\n+            public boolean compareTypeArgsRecursive(Type t, Type s) {\n+                TypePair pair = new TypePair(t, s);\n+                if (cache.add(pair)) {\n+                    try {\n+                        return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+                    } finally {\n+                        cache.remove(pair);\n+                    }\n+                } else {\n+                    return compareTypeArgs(t.getTypeArguments(),\n+                            rewriteSupers(s).getTypeArguments());\n+                }\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()\n+                        && compareTypeArgs(ts.head, ss.head)) {\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n+            }\n+\n+            boolean compareTypeArgs(Type t, Type s) {\n+                return typeArgStructComparator.visit(t, s);\n+            }\n+        }\n+\n+        Type rewriteSupers(Type t) {\n+            if (!t.isParameterized())\n+                return t;\n+            ListBuffer<Type> from = new ListBuffer<>();\n+            ListBuffer<Type> to = new ListBuffer<>();\n+            adaptSelf(t, from, to);\n+            if (from.isEmpty())\n+                return t;\n+            ListBuffer<Type> rewrite = new ListBuffer<>();\n+            boolean changed = false;\n+            for (Type orig : to.toList()) {\n+                Type s = rewriteSupers(orig);\n+                if (s.isSuperBound() && !s.isExtendsBound()) {\n+                    s = new WildcardType(syms.objectType,\n+                            BoundKind.UNBOUND,\n+                            syms.boundClass,\n+                            s.getMetadata());\n+                    changed = true;\n+                } else if (s != orig) {\n+                    s = new WildcardType(wildUpperBound(s),\n+                            BoundKind.EXTENDS,\n+                            syms.boundClass,\n+                            s.getMetadata());\n+                    changed = true;\n+                }\n+                rewrite.append(s);\n+            }\n+            if (changed)\n+                return subst(t.tsym.type, from.toList(), rewrite.toList());\n+            else\n+                return t;\n+        }\n+\n+        private TypeArgStructComparator typeArgStructComparator = new TypeArgStructComparator();\n+        class TypeArgStructComparator extends TypeRelation {\n+\n+            public Boolean visitType(Type t, Type s) {\n+                boolean result = isSameType(t, s);\n+                if (!result) {\n+                    result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                return structuralComparator.visitClassType(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Type s) {\n+                return isSameWildcard(t, s)\n+                        || isCaptureOf(s, t)\n+                        || compareWildcardHelper(t, s);\n+            }\n+\n+            boolean compareWildcardHelper(WildcardType t, Type s) {\n+                \/\/ let's remove captured if any\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar v = (TypeVar) s;\n+                    s = v.isCaptured() ? ((CapturedType)v).wildcard : s;\n+                }\n+                if (!s.hasTag(WILDCARD) || ((WildcardType)s).kind != t.kind) return false;\n+                if (t.isExtendsBound()) {\n+                    return structuralComparator.visit(wildUpperBound(s), wildUpperBound(t));\n+                } else {\n+                    return structuralComparator.visit(wildLowerBound(s), wildLowerBound(t));\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitUndetVar(UndetVar t, Type s) {\n+                return isSameType(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                return structuralComparator.visit(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitErrorType(ErrorType t, Type s) {\n+                return true;\n+            }\n+        }\n@@ -1220,2 +1393,7 @@\n-        public abstract static class ParameterizedTypeRelation<P> extends TypeRelation {\n-            P param;\n+        SubtypingRelation isSubtypeRelation = new SubtypingRelation();\n+        class SubtypingRelation extends TypeRelation {\n+            SubtypingRelationKind param;\n+\n+            public boolean allowRefValSubtyping() {\n+                return param == SubtypingRelationKind.REF_VAL_ALLOWED;\n+            }\n@@ -1223,2 +1401,2 @@\n-            public final Boolean visit(Type t, Type s, P param) {\n-                P prevParam = this.param;\n+            public final Boolean visit(Type t, Type s, SubtypingRelationKind param) {\n+                SubtypingRelationKind prevParam = this.param;\n@@ -1227,1 +1405,1 @@\n-                    return visit(t, s);\n+                    return super.visit(t, s);\n@@ -1232,7 +1410,0 @@\n-        }\n-\n-        SubtypingRelation isSubtypeRelation = new SubtypingRelation();\n-        class SubtypingRelation extends ParameterizedTypeRelation<SubtypingRelationKind> {\n-            public boolean allowRefValSubtyping() {\n-                return param == SubtypingRelationKind.REF_VAL_ALLOWED;\n-            }\n@@ -1276,1 +1447,1 @@\n-                                            s.getTypeArguments(), param);\n+                                            s.getTypeArguments());\n@@ -1282,1 +1453,1 @@\n-                                        rewriteSupers(s).getTypeArguments(), param);\n+                                        rewriteSupers(s).getTypeArguments());\n@@ -1286,33 +1457,0 @@\n-            protected Type rewriteSupers(Type t) {\n-                if (!t.isParameterized())\n-                    return t;\n-                ListBuffer<Type> from = new ListBuffer<>();\n-                ListBuffer<Type> to = new ListBuffer<>();\n-                adaptSelf(t, from, to);\n-                if (from.isEmpty())\n-                    return t;\n-                ListBuffer<Type> rewrite = new ListBuffer<>();\n-                boolean changed = false;\n-                for (Type orig : to.toList()) {\n-                    Type s = rewriteSupers(orig);\n-                    if (s.isSuperBound() && !s.isExtendsBound()) {\n-                        s = new WildcardType(syms.objectType,\n-                                             BoundKind.UNBOUND,\n-                                             syms.boundClass,\n-                                             s.getMetadata());\n-                        changed = true;\n-                    } else if (s != orig) {\n-                        s = new WildcardType(wildUpperBound(s),\n-                                             BoundKind.EXTENDS,\n-                                             syms.boundClass,\n-                                             s.getMetadata());\n-                        changed = true;\n-                    }\n-                    rewrite.append(s);\n-                }\n-                if (changed)\n-                    return subst(t.tsym.type, from.toList(), rewrite.toList());\n-                else\n-                    return t;\n-            }\n-\n@@ -1489,5 +1627,1 @@\n-        return isSameType(t, s, SubtypingRelationKind.STRICT);\n-    }\n-\n-    public boolean isSameType(Type t, Type s, SubtypingRelationKind subtypingKind) {\n-        return isSameTypeVisitor.visit(t, s, subtypingKind);\n+        return isSameTypeVisitor.visit(t, s);\n@@ -1500,2 +1634,2 @@\n-        SameTypeVisitor isSameTypeVisitor = new SameTypeVisitor();\n-        class SameTypeVisitor extends ParameterizedTypeRelation<SubtypingRelationKind> {\n+        TypeRelation isSameTypeVisitor = new TypeRelation() {\n+\n@@ -1577,1 +1711,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments(), param);\n+                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n@@ -1643,1 +1777,1 @@\n-        }\n+        };\n@@ -1680,4 +1814,0 @@\n-        return containsType(ts, ss, SubtypingRelationKind.STRICT);\n-    }\n-\n-    boolean containsType(List<Type> ts, List<Type> ss, SubtypingRelationKind subtypingKind) {\n@@ -1685,1 +1815,1 @@\n-                && containsType(ts.head, ss.head, subtypingKind)) {\n+                && containsType(ts.head, ss.head)) {\n@@ -1718,5 +1848,1 @@\n-        return containsType(t, s, SubtypingRelationKind.STRICT);\n-    }\n-\n-    public boolean containsType(Type t, Type s, SubtypingRelationKind subtypingKind) {\n-        return containsType.visit(t, s, subtypingKind);\n+        return containsType.visit(t, s);\n@@ -1725,2 +1851,1 @@\n-        private ContainsType containsType = new ContainsType();\n-        class ContainsType extends ParameterizedTypeRelation<SubtypingRelationKind> {\n+        private TypeRelation containsType = new TypeRelation() {\n@@ -1732,9 +1857,1 @@\n-                    boolean result = isSameType(t, s, param);\n-                    \/\/ the order in the condition below matters\n-                    if (param == SubtypingRelationKind.REF_VAL_ALLOWED &&  warnStack.head != null && allowUniversalTVars && !result) {\n-                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n-                        if (result) {\n-                            warnStack.head.warn(LintCategory.UNCHECKED);\n-                        }\n-                    }\n-                    return result;\n+                    return isSameType(t, s);\n@@ -1775,4 +1892,1 @@\n-                        || ((t.isExtendsBound() || isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n-                                (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED))) &&\n-                            (t.isSuperBound() || isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n-                                (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED))));\n+                        || checkIfBoundedBy(t, s);\n@@ -1782,0 +1896,9 @@\n+            boolean checkIfBoundedBy(WildcardType t, Type s) {\n+                if (t.isUnbound()) return true;\n+                return (t.isExtendsBound()) ?\n+                    isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false)) :\n+                    isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false));\n+            }\n+\n@@ -1791,16 +1914,0 @@\n-            @Override\n-            public Boolean visitTypeVar(TypeVar t, Type s) {\n-                if (s.hasTag(TYPEVAR)) {\n-                    TypeVar other = (TypeVar)s;\n-                    if (allowUniversalTVars\n-                            && param == SubtypingRelationKind.REF_VAL_ALLOWED\n-                            && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n-                        if (warnStack.head != null) {\n-                            warnStack.head.warn(LintCategory.UNCHECKED);\n-                        }\n-                        return true;\n-                    }\n-                }\n-                return isSameType(t, s);\n-            }\n-\n@@ -1811,1 +1918,1 @@\n-        }\n+        };\n@@ -1827,4 +1934,0 @@\n-        return containsTypeEquivalent(ts, ss, SubtypingRelationKind.STRICT);\n-    }\n-\n-    public boolean containsTypeEquivalent(List<Type> ts, List<Type> ss, SubtypingRelationKind subtypingKind) {\n@@ -1832,1 +1935,1 @@\n-                && containsTypeEquivalent(ts.head, ss.head, subtypingKind)) {\n+                && containsTypeEquivalent(ts.head, ss.head)) {\n@@ -3630,2 +3733,17 @@\n-                return s.hasTag(METHOD)\n-                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes(), SubtypingRelationKind.REF_VAL_ALLOWED);\n+                return s.hasTag(METHOD) &&\n+                        (compareTypesStruc(t.argtypes, s.getParameterTypes()));\n+            }\n+\n+            boolean compareTypesStruc(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    boolean equivalent = containsTypeEquivalent(ts.head, ss.head);\n+                    if (equivalent ||\n+                            ts.head.hasTag(TYPEVAR) && ss.head.hasTag(TYPEVAR) &&\n+                            structuralComparator.visit(ts.head, ss.head)) {\n+                        ts = ts.tail;\n+                        ss = ss.tail;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n@@ -3704,0 +3822,7 @@\n+                    \/\/ experiment\n+                    \/*\n+                    * if (to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ||\n+                        to.head.hasTag(CLASS)) {\n+                        return to.head.referenceProjection() != null ? to.head.referenceProjection() : to.head;\n+                    } else return to.head;\n+                    * *\/\n@@ -4926,4 +5051,0 @@\n-        return containsTypeEquivalent(t, s, SubtypingRelationKind.REF_VAL_ALLOWED);\n-    }\n-\n-    private boolean containsTypeEquivalent(Type t, Type s, SubtypingRelationKind subtypingKind) {\n@@ -4931,1 +5052,1 @@\n-                containsType(t, s, subtypingKind) && containsType(s, t, subtypingKind);\n+                containsType(t, s) && containsType(s, t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":246,"deletions":125,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -4950,1 +4950,1 @@\n-        Warner noteWarner = new Warner();\n+        Warner noteWarner = new Warner(env.tree.pos());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4253,0 +4253,1 @@\n+                    this.warned = true;\n@@ -4260,0 +4261,1 @@\n+                        this.warned = true;\n@@ -4264,0 +4266,1 @@\n+                    this.warned = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,2 +224,2 @@\n-                    .stream().map(t -> ((UndetVar)t).getBounds(InferenceBound.EQ, InferenceBound.LOWER, InferenceBound.UPPER))\n-                    .flatMap(Collection::stream).anyMatch(Type::isPrimitiveClass)) {\n+                            .stream().map(t -> ((UndetVar) t).getBounds(InferenceBound.EQ, InferenceBound.LOWER, InferenceBound.UPPER))\n+                            .flatMap(Collection::stream).anyMatch(Type::isPrimitiveClass)) {\n@@ -494,0 +494,2 @@\n+         *\n+         * or S is unchecked-convertible to T, but S is not a subtype of T.\n@@ -496,2 +498,2 @@\n-            for (Type t : from.getBounds(InferenceBound.EQ, InferenceBound.LOWER)) {\n-                Type sup = types.asSuper(t, to.tsym);\n+            for (Type S : from.getBounds(InferenceBound.EQ, InferenceBound.LOWER)) {\n+                Type sup = types.asSuper(S, to.tsym);\n@@ -501,0 +503,3 @@\n+                if (types.isConvertible(S, to) && !types.isSubtype(S, to)) {\n+                    return true;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+compiler.warn.primitive.value.conversion\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.warn.primitive.value.conversion\n-\/\/ options: -Xlint:unchecked\n-\n-class PrimitiveValueConversionTest {\n-    primitive class Point {}\n-\n-    void m() {\n-        Point.ref pr = null;\n-        Point p = pr;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveValueConversionTest.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -6,1 +6,1 @@\n-GenericInlineTest.java:39:13: compiler.warn.primitive.value.conversion\n+GenericInlineTest.java:39:13: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), GenericInlineTest.ref<java.lang.String,java.lang.Integer>, GenericInlineTest<java.lang.String,java.lang.Integer>\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/GenericInlineTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-TypeRelationsNegativeTest.java:16:13: compiler.warn.primitive.value.conversion\n-TypeRelationsNegativeTest.java:17:13: compiler.warn.primitive.value.conversion\n+TypeRelationsNegativeTest.java:16:13: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), TypeRelationsNegativeTest.ref, TypeRelationsNegativeTest\n+TypeRelationsNegativeTest.java:17:13: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), TypeRelationsNegativeTest.ref, TypeRelationsNegativeTest\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TypeRelationsNegativeTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,17 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary unchecked warning test for universal type variables\n+ * @compile\/ref=UncheckedWarningsTest.out -Xlint:unchecked -XDrawDiagnostics UncheckedWarningsTest.java\n+ *\/\n+\n+class UncheckedWarningsTest {\n+    static primitive class Atom { }\n+\n+    static class Box<__universal X> { }\n+\n+    public static void main(String[] args) {\n+        Box<Box<Box<Atom>>> val = null;\n+        Box<Box<Box<Atom.ref>>> ref = null;\n+        val = ref;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UncheckedWarningsTest.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+UncheckedWarningsTest.java:15:15: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom.ref>>>, UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom>>>\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UncheckedWarningsTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -267,0 +267,34 @@\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        static primitive class Atom {}\n+                        static class Box<__universal X> {}\n+                        void test(Box<? extends Atom> t1, Box<? extends Atom.ref> t2) {\n+                            t1 = t2;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        static primitive class Atom {}\n+                        static class Box<__universal X> {}\n+                        void test(Box<? extends Atom> t1, Box<? extends Atom.ref> t2) {\n+                            t2 = t1;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        static primitive class Atom {}\n+                        static class Box<__universal X> {}\n+                        @SafeVarargs\n+                        private <__universal Z> Z make_box_uni(Z... bs) {\n+                            return bs[0];\n+                        }\n+                        void test(Box<Atom> bref, Box bval) {\n+                            Box<? extends Atom> res = make_box_uni(bref, bval, bval);\n+                        }\n+                    }\n@@ -592,1 +626,1 @@\n-        assertOKWithWarning(\"compiler.warn.primitive.value.conversion\",\n+        assertOKWithWarning(\"compiler.warn.prob.found.req\",\n@@ -659,0 +693,11 @@\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                class Test {\n+                    static primitive class Atom {}\n+                    static class Box<__universal X> {}\n+                    void test(Box<? extends Atom> t1, Box<Atom.ref> t2) {\n+                        t1 = t2;\n+                    }\n+                }\n+                \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"}]}