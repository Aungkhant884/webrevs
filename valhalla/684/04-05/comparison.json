{"files":[{"patch":"@@ -603,6 +603,0 @@\n-    enum IsConvertibleResult {\n-        CONVERTIBLE,\n-        CONVERTIBLE_REF_PROJECTION,\n-        NOT_CONVERTIBLE\n-    }\n-\n@@ -613,1 +607,1 @@\n-    private IsConvertibleResult isConvertibleInternal(Type t, Type s, Warner warn, boolean discriminateConvertibleKind) {\n+    public boolean isConvertible(Type t, Type s, Warner warn) {\n@@ -615,1 +609,1 @@\n-            return IsConvertibleResult.CONVERTIBLE;\n+            return true;\n@@ -625,1 +619,1 @@\n-            return IsConvertibleResult.CONVERTIBLE;\n+            return true;\n@@ -634,0 +628,3 @@\n+        \/* next experiment should be to remove all this chunk of code but that will requiere changes in other areas\n+         * like mappings when type variables are present etc\n+         *\/\n@@ -648,2 +645,0 @@\n-                if (discriminateConvertibleKind)\n-                    return IsConvertibleResult.CONVERTIBLE_REF_PROJECTION;\n@@ -651,1 +646,1 @@\n-            return result ? IsConvertibleResult.CONVERTIBLE : IsConvertibleResult.NOT_CONVERTIBLE;\n+            return result;\n@@ -656,18 +651,2 @@\n-        if (tPrimitive == sPrimitive) {\n-            boolean result = isSubtypeUnchecked(t, s, warn);\n-            if (result) return IsConvertibleResult.CONVERTIBLE;\n-            Type tRefProjection = mapToReferenceProjectionOrSelf(t);\n-            Type sRefProjection = mapToReferenceProjectionOrSelf(s);\n-            boolean tHasValue = t != tRefProjection;\n-            boolean sHasValue = s != sRefProjection;\n-\n-            if (tHasValue != sHasValue) {\n-                result = tHasValue ?\n-                        isSubtype(allowUniversalTVars && (tUndet || sUndet) ? t : tRefProjection, s) :\n-                        !t.hasTag(BOT) && isSubtype(t, allowUniversalTVars && (tUndet || sUndet) ? s : sRefProjection);\n-                if (result && (allowUniversalTVars && !t.hasTag(BOT))) {\n-                    warn.warn(LintCategory.UNCHECKED);\n-                }\n-                return result ? IsConvertibleResult.CONVERTIBLE_REF_PROJECTION : IsConvertibleResult.NOT_CONVERTIBLE;\n-            }\n-            return IsConvertibleResult.NOT_CONVERTIBLE;\n+        if (tPrimitive == sPrimitive || tIsPrimitiveClass != sIsPrimitiveClass) {\n+            return isSubtypeUnchecked(t, s, warn);\n@@ -677,1 +656,1 @@\n-            boolean result = tUndet ?\n+            return tUndet ?\n@@ -680,1 +659,0 @@\n-            return result ? IsConvertibleResult.CONVERTIBLE : IsConvertibleResult.NOT_CONVERTIBLE;\n@@ -683,8 +661,3 @@\n-        boolean result = tPrimitive\n-            ? isSubtype(boxedClass(t).type, s)\n-            : isSubtype(unboxedType(t), s);\n-        return result ? IsConvertibleResult.CONVERTIBLE : IsConvertibleResult.NOT_CONVERTIBLE;\n-    }\n-\n-    public boolean isConvertible(Type t, Type s, Warner warn) {\n-        return isConvertibleInternal(t, s, warn, false) == IsConvertibleResult.CONVERTIBLE;\n+        return tPrimitive\n+                ? isSubtype(boxedClass(t).type, s)\n+                : isSubtype(unboxedType(t), s);\n@@ -1170,3 +1143,8 @@\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+                if (t2 != null) {\n+                    if (t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n@@ -1174,1 +1152,7 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        if (!isSameType(t2, s) &&\n+                                t2.isReferenceProjection() == s.isReferenceProjection() &&\n+                                structuralComparator.visit(t2, s)) {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                            return true;\n+                        }\n+                        return false;\n@@ -1176,1 +1160,0 @@\n-                    return true;\n@@ -1181,0 +1164,169 @@\n+        \/\/ where\n+        StructuralTypeComparator structuralComparator = new StructuralTypeComparator();\n+        class StructuralTypeComparator extends TypeRelation {\n+            private Set<TypePair> cache = new HashSet<>();\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                switch (t.getTag()) {\n+                    case BYTE:\n+                    case CHAR:\n+                    case SHORT: case INT: case LONG:\n+                    case FLOAT: case DOUBLE:\n+                    case BOOLEAN: case VOID:\n+                    case BOT: case NONE:\n+                        return t.hasTag(s.getTag());\n+                    case WILDCARD: \/\/we shouldn't be here - avoids crash (see 7034495)\n+                        return false;\n+                    default:\n+                        throw new AssertionError(\"isSubtype \" + t.getTag());\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Type s) {\n+                if (t == s)\n+                    return true;\n+\n+                if (s.isPartial())\n+                    return visit(s, t);\n+\n+                return s.hasTag(ARRAY)\n+                        && visit(t.elemtype, elemtype(s));\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                \/\/ If t is an intersection, sup might not be a class type\n+                if (!t.hasTag(CLASS)) return visit(t, s);\n+                return t.tsym == s.tsym\n+                        && (t.tsym != s.tsym || t.referenceProjectionOrSelf().tsym == s.referenceProjectionOrSelf().tsym)\n+                        && (!s.isParameterized() || compareTypeArgsRecursive(s, t))\n+                        && visit(t.getEnclosingType(), s.getEnclosingType());\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar other = (TypeVar)s;\n+                    if (allowUniversalTVars &&\n+                            t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        return true;\n+                    }\n+                }\n+                return isSameType(t, s);\n+            }\n+\n+            public boolean compareTypeArgsRecursive(Type t, Type s) {\n+                TypePair pair = new TypePair(t, s);\n+                if (cache.add(pair)) {\n+                    try {\n+                        return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+                    } finally {\n+                        cache.remove(pair);\n+                    }\n+                } else {\n+                    return compareTypeArgs(t.getTypeArguments(),\n+                            rewriteSupers(s).getTypeArguments());\n+                }\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()\n+                        && compareTypeArgs(ts.head, ss.head)) {\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n+            }\n+\n+            boolean compareTypeArgs(Type t, Type s) {\n+                return typeArgStructComparator.visit(t, s);\n+            }\n+        }\n+\n+        Type rewriteSupers(Type t) {\n+            if (!t.isParameterized())\n+                return t;\n+            ListBuffer<Type> from = new ListBuffer<>();\n+            ListBuffer<Type> to = new ListBuffer<>();\n+            adaptSelf(t, from, to);\n+            if (from.isEmpty())\n+                return t;\n+            ListBuffer<Type> rewrite = new ListBuffer<>();\n+            boolean changed = false;\n+            for (Type orig : to.toList()) {\n+                Type s = rewriteSupers(orig);\n+                if (s.isSuperBound() && !s.isExtendsBound()) {\n+                    s = new WildcardType(syms.objectType,\n+                            BoundKind.UNBOUND,\n+                            syms.boundClass,\n+                            s.getMetadata());\n+                    changed = true;\n+                } else if (s != orig) {\n+                    s = new WildcardType(wildUpperBound(s),\n+                            BoundKind.EXTENDS,\n+                            syms.boundClass,\n+                            s.getMetadata());\n+                    changed = true;\n+                }\n+                rewrite.append(s);\n+            }\n+            if (changed)\n+                return subst(t.tsym.type, from.toList(), rewrite.toList());\n+            else\n+                return t;\n+        }\n+\n+        private TypeArgStructComparator typeArgStructComparator = new TypeArgStructComparator();\n+        class TypeArgStructComparator extends TypeRelation {\n+\n+            public Boolean visitType(Type t, Type s) {\n+                boolean result = isSameType(t, s);\n+                if (!result) {\n+                    result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                return structuralComparator.visitClassType(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Type s) {\n+                return isSameWildcard(t, s)\n+                        || isCaptureOf(s, t)\n+                        || compareWildcardHelper(t, s);\n+            }\n+\n+            boolean compareWildcardHelper(WildcardType t, Type s) {\n+                \/\/ let's remove captured if any\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar v = (TypeVar) s;\n+                    s = v.isCaptured() ? ((CapturedType)v).wildcard : s;\n+                }\n+                if (!s.hasTag(WILDCARD) || ((WildcardType)s).kind != t.kind) return false;\n+                if (t.isExtendsBound()) {\n+                    return structuralComparator.visit(wildUpperBound(s), wildUpperBound(t));\n+                } else {\n+                    return structuralComparator.visit(wildLowerBound(s), wildLowerBound(t));\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitUndetVar(UndetVar t, Type s) {\n+                return isSameType(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                return structuralComparator.visit(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitErrorType(ErrorType t, Type s) {\n+                return true;\n+            }\n+        }\n@@ -1313,1 +1465,1 @@\n-                                            s.getTypeArguments(), param);\n+                                            s.getTypeArguments());\n@@ -1319,30 +1471,1 @@\n-                                        rewriteSupers(s).getTypeArguments(), param);\n-                }\n-            }\n-\n-            protected Type rewriteSupers(Type t) {\n-                if (!t.isParameterized())\n-                    return t;\n-                ListBuffer<Type> from = new ListBuffer<>();\n-                ListBuffer<Type> to = new ListBuffer<>();\n-                adaptSelf(t, from, to);\n-                if (from.isEmpty())\n-                    return t;\n-                ListBuffer<Type> rewrite = new ListBuffer<>();\n-                boolean changed = false;\n-                for (Type orig : to.toList()) {\n-                    Type s = rewriteSupers(orig);\n-                    if (s.isSuperBound() && !s.isExtendsBound()) {\n-                        s = new WildcardType(syms.objectType,\n-                                             BoundKind.UNBOUND,\n-                                             syms.boundClass,\n-                                             s.getMetadata());\n-                        changed = true;\n-                    } else if (s != orig) {\n-                        s = new WildcardType(wildUpperBound(s),\n-                                             BoundKind.EXTENDS,\n-                                             syms.boundClass,\n-                                             s.getMetadata());\n-                        changed = true;\n-                    }\n-                    rewrite.append(s);\n+                                        rewriteSupers(s).getTypeArguments());\n@@ -1350,4 +1473,0 @@\n-                if (changed)\n-                    return subst(t.tsym.type, from.toList(), rewrite.toList());\n-                else\n-                    return t;\n@@ -1526,5 +1645,1 @@\n-        return isSameType(t, s, SubtypingRelationKind.STRICT);\n-    }\n-\n-    public boolean isSameType(Type t, Type s, SubtypingRelationKind subtypingKind) {\n-        return isSameTypeVisitor.visit(t, s, subtypingKind);\n+        return isSameTypeVisitor.visit(t, s);\n@@ -1537,2 +1652,2 @@\n-        SameTypeVisitor isSameTypeVisitor = new SameTypeVisitor();\n-        class SameTypeVisitor extends ParameterizedTypeRelation<SubtypingRelationKind> {\n+        TypeRelation isSameTypeVisitor = new TypeRelation() {\n+\n@@ -1614,1 +1729,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments(), param);\n+                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n@@ -1680,1 +1795,1 @@\n-        }\n+        };\n@@ -1717,4 +1832,0 @@\n-        return containsType(ts, ss, SubtypingRelationKind.STRICT);\n-    }\n-\n-    boolean containsType(List<Type> ts, List<Type> ss, SubtypingRelationKind subtypingKind) {\n@@ -1722,1 +1833,1 @@\n-                && containsType(ts.head, ss.head, subtypingKind)) {\n+                && containsType(ts.head, ss.head)) {\n@@ -1755,5 +1866,1 @@\n-        return containsType(t, s, SubtypingRelationKind.STRICT);\n-    }\n-\n-    public boolean containsType(Type t, Type s, SubtypingRelationKind subtypingKind) {\n-        return containsType.visit(t, s, subtypingKind);\n+        return containsType.visit(t, s);\n@@ -1762,2 +1869,1 @@\n-        private ContainsType containsType = new ContainsType();\n-        class ContainsType extends ParameterizedTypeRelation<SubtypingRelationKind> {\n+        private TypeRelation containsType = new TypeRelation() {\n@@ -1769,9 +1875,1 @@\n-                    boolean result = isSameType(t, s, param);\n-                    \/\/ the order in the condition below matters\n-                    if (param == SubtypingRelationKind.REF_VAL_ALLOWED &&  warnStack.head != null && allowUniversalTVars && !result) {\n-                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n-                        if (result) {\n-                            warnStack.head.warn(LintCategory.UNCHECKED);\n-                        }\n-                    }\n-                    return result;\n+                    return isSameType(t, s);\n@@ -1818,20 +1916,5 @@\n-                if (t.isExtendsBound()) {\n-                    boolean isBoundedBy = isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n-                            (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED));\n-                    if (isBoundedBy) {\n-                        return true;\n-                    }\n-                    return (allowUniversalTVars &&\n-                            isConvertibleInternal(wildUpperBound(s),\n-                                    wildUpperBound(t),\n-                                    warnStack.head != null ? warnStack.head : noWarnings, true) == IsConvertibleResult.CONVERTIBLE_REF_PROJECTION);\n-                } else {\n-                    boolean isBoundedBy = isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n-                            (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED));\n-                    if (isBoundedBy)\n-                        return true;\n-                    return (allowUniversalTVars &&\n-                            isConvertibleInternal(wildLowerBound(t),\n-                                    wildLowerBound(s),\n-                                    warnStack.head != null ? warnStack.head : noWarnings, true) == IsConvertibleResult.CONVERTIBLE_REF_PROJECTION);\n-                }\n+                return (t.isExtendsBound()) ?\n+                    isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false)) :\n+                    isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false));\n@@ -1849,16 +1932,0 @@\n-            @Override\n-            public Boolean visitTypeVar(TypeVar t, Type s) {\n-                if (s.hasTag(TYPEVAR)) {\n-                    TypeVar other = (TypeVar)s;\n-                    if (allowUniversalTVars\n-                            && param == SubtypingRelationKind.REF_VAL_ALLOWED\n-                            && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n-                        if (warnStack.head != null) {\n-                            warnStack.head.warn(LintCategory.UNCHECKED);\n-                        }\n-                        return true;\n-                    }\n-                }\n-                return isSameType(t, s);\n-            }\n-\n@@ -1869,1 +1936,1 @@\n-        }\n+        };\n@@ -1885,4 +1952,0 @@\n-        return containsTypeEquivalent(ts, ss, SubtypingRelationKind.STRICT);\n-    }\n-\n-    public boolean containsTypeEquivalent(List<Type> ts, List<Type> ss, SubtypingRelationKind subtypingKind) {\n@@ -1890,1 +1953,1 @@\n-                && containsTypeEquivalent(ts.head, ss.head, subtypingKind)) {\n+                && containsTypeEquivalent(ts.head, ss.head)) {\n@@ -2269,76 +2332,0 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"mapToReferenceProjectionOrSelf\">\n-    public Type mapToReferenceProjectionOrSelf(Type t) {\n-        return t.map(new ReferenceProjectionOrSelfMapping());\n-    }\n-    class ReferenceProjectionOrSelfMapping extends TypeMapping<Void> {\n-        Set<Type> seen = new HashSet<>();\n-\n-        @Override\n-        public Type visitClassType(ClassType t, Void _unused) {\n-            ClassType tproj = (ClassType) t.referenceProjectionOrSelf();\n-            Type outer = tproj.getEnclosingType();\n-            Type outer1 = visit(outer, _unused);\n-            List<Type> typarams = tproj.getTypeArguments();\n-            List<Type> typarams1 = visit(typarams, _unused);\n-            if (t == tproj && outer1 == outer && typarams1 == typarams) return t;\n-            else return new ClassType(outer1, typarams1, tproj.tsym, tproj.metadata, tproj.getFlavor());\n-        }\n-\n-        @Override\n-        public Type visitWildcardType(WildcardType wt, Void _unused) {\n-            Type t = wt.type;\n-            if (t != null)\n-                t = visit(t, _unused);\n-            if (t == wt.type)\n-                return wt;\n-            else\n-                return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata);\n-        }\n-\n-        @Override\n-        public Type visitTypeVar(TypeVar t, Void _unused) {\n-            if (!t.isUniversal()) {\n-                return t;\n-            }\n-            if (seen.add(t)) {\n-                try {\n-                    TypeVar tv = (TypeVar) t.referenceProjectionOrSelf();\n-                    Type ub = t.getUpperBound();\n-                    Type ubProj = visit(ub);\n-                    if (tv == t && ubProj == ub) {\n-                        return t;\n-                    } else {\n-                        return new TypeVar(tv.tsym, ubProj, tv.lower, tv.metadata);\n-                    }\n-                } finally {\n-                    seen.remove(t);\n-                }\n-            } else {\n-                \/\/ cycle\n-                return t;\n-            }\n-        }\n-\n-        @Override\n-        public Type visitCapturedType(CapturedType t, Void unused) {\n-            if (seen.add(t)) {\n-                try {\n-                    WildcardType wct = (WildcardType) visit(t.wildcard, unused);\n-                    Type ub = t.getUpperBound();\n-                    Type ubProj = visit(ub);\n-                    if (wct == t.wildcard && ubProj == ub) {\n-                        return t;\n-                    } else {\n-                        return new CapturedType(t.tsym.name, t.tsym.owner, ubProj, t.lower, wct);\n-                    }\n-                } finally {\n-                    seen.remove(t);\n-                }\n-            } else {\n-                \/\/ cycle\n-                return t;\n-            }\n-        }\n-    }\n-    \/\/ <\/editor-fold>\n-\n@@ -3764,2 +3751,17 @@\n-                return s.hasTag(METHOD)\n-                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes(), SubtypingRelationKind.REF_VAL_ALLOWED);\n+                return s.hasTag(METHOD) &&\n+                        (compareTypesStruc(t.argtypes, s.getParameterTypes()));\n+            }\n+\n+            boolean compareTypesStruc(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    boolean equivalent = containsTypeEquivalent(ts.head, ss.head);\n+                    if (equivalent ||\n+                            ts.head.hasTag(TYPEVAR) && ss.head.hasTag(TYPEVAR) &&\n+                            structuralComparator.visit(ts.head, ss.head)) {\n+                        ts = ts.tail;\n+                        ss = ss.tail;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n@@ -3838,0 +3840,7 @@\n+                    \/\/ experiment\n+                    \/*\n+                    * if (to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ||\n+                        to.head.hasTag(CLASS)) {\n+                        return to.head.referenceProjection() != null ? to.head.referenceProjection() : to.head;\n+                    } else return to.head;\n+                    * *\/\n@@ -5060,4 +5069,0 @@\n-        return containsTypeEquivalent(t, s, SubtypingRelationKind.REF_VAL_ALLOWED);\n-    }\n-\n-    private boolean containsTypeEquivalent(Type t, Type s, SubtypingRelationKind subtypingKind) {\n@@ -5065,1 +5070,1 @@\n-                containsType(t, s, subtypingKind) && containsType(s, t, subtypingKind);\n+                containsType(t, s) && containsType(s, t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":240,"deletions":235,"binary":false,"changes":475,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.unchecked.filename: GetClass.java\n-- compiler.note.unchecked.recompile\n","filename":"test\/langtools\/tools\/javac\/generics\/GetClass.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,2 +11,0 @@\n-    static class Pair<__universal X, __universal Y> { }\n-    static class Triple<__universal X, __universal Y, __universal Z> { }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UncheckedWarningsTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-UncheckedWarningsTest.java:17:15: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom.ref>>>, UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom>>>\n+UncheckedWarningsTest.java:15:15: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom.ref>>>, UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom>>>\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UncheckedWarningsTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,10 +268,0 @@\n-                new DiagAndCode(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        static primitive class Atom {}\n-                        static class Box<__universal X> {}\n-                        void test(Box<? extends Atom> t1, Box<Atom.ref> t2) {\n-                            t1 = t2;\n-                        }\n-                    }\n-                    \"\"\"),\n@@ -703,0 +693,11 @@\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                class Test {\n+                    static primitive class Atom {}\n+                    static class Box<__universal X> {}\n+                    void test(Box<? extends Atom> t1, Box<Atom.ref> t2) {\n+                        t1 = t2;\n+                    }\n+                }\n+                \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"}]}