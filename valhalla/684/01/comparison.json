{"files":[{"patch":"@@ -603,0 +603,6 @@\n+    enum IsConvertibleResult {\n+        CONVERTIBLE,\n+        CONVERTIBLE_REF_PROJECTION,\n+        NOT_CONVERTIBLE\n+    }\n+\n@@ -607,1 +613,1 @@\n-    public boolean isConvertible(Type t, Type s, Warner warn) {\n+    private IsConvertibleResult isConvertibleInternal(Type t, Type s, Warner warn, boolean discriminateConvertibleKind) {\n@@ -609,1 +615,1 @@\n-            return true;\n+            return IsConvertibleResult.CONVERTIBLE;\n@@ -612,2 +618,0 @@\n-        boolean tValue = t.isPrimitiveClass();\n-        boolean sValue = s.isPrimitiveClass();\n@@ -621,1 +625,1 @@\n-            return true;\n+            return IsConvertibleResult.CONVERTIBLE;\n@@ -627,2 +631,5 @@\n-        if (tValue != sValue) {\n-            boolean result = tValue ?\n+        boolean tIsPrimitiveClass = t.isPrimitiveClass();\n+        boolean sIsPrimitiveClass = s.isPrimitiveClass();\n+\n+        if (tIsPrimitiveClass != sIsPrimitiveClass) {\n+            boolean result = tIsPrimitiveClass ?\n@@ -632,3 +639,11 @@\n-                    s.isPrimitiveClass() && !t.isPrimitiveClass() &&\n-                    s.referenceProjectionOrSelf().tsym == t.tsym)) {\n-                chk.warnUnchecked(warn.pos(), Warnings.PrimitiveValueConversion);\n+                    s.isPrimitiveClass() && !t.isPrimitiveClass())) {\n+                \/\/ let's check for an erroneous corner case: when the user defines an anonymous class of a primitive class\n+                \/\/ we don't want to issue a warning in that case\n+                boolean anonymousPrimitiveClass = !tIsPrimitiveClass ?\n+                        t.hasTag(CLASS) && supertype(t).isPrimitiveClass() :\n+                        s.hasTag(CLASS) && supertype(s).isPrimitiveClass();\n+                if (!anonymousPrimitiveClass) {\n+                    warn.warn(LintCategory.UNCHECKED);\n+                }\n+                if (discriminateConvertibleKind)\n+                    return IsConvertibleResult.CONVERTIBLE_REF_PROJECTION;\n@@ -636,1 +651,1 @@\n-            return result;\n+            return result ? IsConvertibleResult.CONVERTIBLE : IsConvertibleResult.NOT_CONVERTIBLE;\n@@ -642,1 +657,17 @@\n-            return isSubtypeUnchecked(t, s, warn);\n+            boolean result = isSubtypeUnchecked(t, s, warn);\n+            if (result) return IsConvertibleResult.CONVERTIBLE;\n+            Type tRefProjection = mapToReferenceProjectionOrSelf(t);\n+            Type sRefProjection = mapToReferenceProjectionOrSelf(s);\n+            boolean tHasValue = t != tRefProjection;\n+            boolean sHasValue = s != sRefProjection;\n+\n+            if (tHasValue != sHasValue) {\n+                result = tHasValue ?\n+                        isSubtype(allowUniversalTVars && (tUndet || sUndet) ? t : tRefProjection, s) :\n+                        !t.hasTag(BOT) && isSubtype(t, allowUniversalTVars && (tUndet || sUndet) ? s : sRefProjection);\n+                if (result && (allowUniversalTVars && !t.hasTag(BOT))) {\n+                    warn.warn(LintCategory.UNCHECKED);\n+                }\n+                return result ? IsConvertibleResult.CONVERTIBLE_REF_PROJECTION : IsConvertibleResult.NOT_CONVERTIBLE;\n+            }\n+            return IsConvertibleResult.NOT_CONVERTIBLE;\n@@ -646,1 +677,1 @@\n-            return tUndet ?\n+            boolean result = tUndet ?\n@@ -649,0 +680,1 @@\n+            return result ? IsConvertibleResult.CONVERTIBLE : IsConvertibleResult.NOT_CONVERTIBLE;\n@@ -651,1 +683,1 @@\n-        return tPrimitive\n+        boolean result = tPrimitive\n@@ -654,0 +686,5 @@\n+        return result ? IsConvertibleResult.CONVERTIBLE : IsConvertibleResult.NOT_CONVERTIBLE;\n+    }\n+\n+    public boolean isConvertible(Type t, Type s, Warner warn) {\n+        return isConvertibleInternal(t, s, warn, false) == IsConvertibleResult.CONVERTIBLE;\n@@ -1775,4 +1812,25 @@\n-                        || ((t.isExtendsBound() || isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n-                                (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED))) &&\n-                            (t.isSuperBound() || isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n-                                (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED))));\n+                        || checkIfBoundedBy(t, s);\n+                }\n+            }\n+\n+            boolean checkIfBoundedBy(WildcardType t, Type s) {\n+                if (t.isUnbound()) return true;\n+                if (t.isExtendsBound()) {\n+                    boolean isBoundedBy = isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED));\n+                    if (isBoundedBy) {\n+                        return true;\n+                    }\n+                    return (allowUniversalTVars &&\n+                            isConvertibleInternal(wildUpperBound(s),\n+                                    wildUpperBound(t),\n+                                    warnStack.head != null ? warnStack.head : noWarnings, true) == IsConvertibleResult.CONVERTIBLE_REF_PROJECTION);\n+                } else {\n+                    boolean isBoundedBy = isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false, SubtypingRelationKind.REF_VAL_ALLOWED));\n+                    if (isBoundedBy)\n+                        return true;\n+                    return (allowUniversalTVars &&\n+                            isConvertibleInternal(wildLowerBound(t),\n+                                    wildLowerBound(s),\n+                                    warnStack.head != null ? warnStack.head : noWarnings, true) == IsConvertibleResult.CONVERTIBLE_REF_PROJECTION);\n@@ -2211,0 +2269,68 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"mapToReferenceProjectionOrSelf\">\n+    public Type mapToReferenceProjectionOrSelf(Type t) {\n+        return t.map(new ReferenceProjectionOrSelfMapping());\n+    }\n+    class ReferenceProjectionOrSelfMapping extends TypeMapping<Void> {\n+        Set<Type> seen = new HashSet<>();\n+\n+        @Override\n+        public Type visitClassType(ClassType t, Void _unused) {\n+            ClassType tproj = (ClassType) t.referenceProjectionOrSelf();\n+            Type outer = tproj.getEnclosingType();\n+            Type outer1 = visit(outer, _unused);\n+            List<Type> typarams = tproj.getTypeArguments();\n+            List<Type> typarams1 = visit(typarams, _unused);\n+            if (t == tproj && outer1 == outer && typarams1 == typarams) return t;\n+            else return new ClassType(outer1, typarams1, tproj.tsym, tproj.metadata, tproj.getFlavor());\n+        }\n+\n+        @Override\n+        public Type visitWildcardType(WildcardType wt, Void _unused) {\n+            Type t = wt.type;\n+            if (t != null)\n+                t = visit(t, _unused);\n+            if (t == wt.type)\n+                return wt;\n+            else\n+                return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata);\n+        }\n+\n+        @Override\n+        public Type visitTypeVar(TypeVar t, Void _unused) {\n+            if (!t.isUniversal()) {\n+                return t;\n+            }\n+            if (seen.add(t)) {\n+                try {\n+                    TypeVar tv = (TypeVar) t.referenceProjectionOrSelf();\n+                    Type ub = t.getUpperBound();\n+                    Type ubProj = visit(ub);\n+                    if (tv == t && ubProj == ub) {\n+                        return t;\n+                    } else {\n+                        return new TypeVar(tv.tsym, ubProj, tv.lower, tv.metadata);\n+                    }\n+                } finally {\n+                    seen.remove(t);\n+                }\n+            } else {\n+                \/\/ cycle\n+                return t;\n+            }\n+        }\n+\n+        @Override\n+        public Type visitCapturedType(CapturedType t, Void unused) {\n+            WildcardType wct = (WildcardType) visit(t.wildcard, unused);\n+            \/\/Type l = visit(t.lower);\n+            \/\/Type ub = t.getUpperBound();\n+            \/\/Type u = visit(ub);\n+            if (wct == t.wildcard) {\n+                return t;\n+            } else {\n+                return new CapturedType(t.tsym.name, t.tsym.owner, t.getUpperBound(), t.lower, wct);\n+            }\n+        }\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":144,"deletions":18,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -4950,1 +4950,1 @@\n-        Warner noteWarner = new Warner();\n+        Warner noteWarner = new Warner(env.tree.pos());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4253,0 +4253,1 @@\n+                    this.warned = true;\n@@ -4260,0 +4261,1 @@\n+                        this.warned = true;\n@@ -4264,0 +4266,1 @@\n+                    this.warned = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,2 +224,2 @@\n-                    .stream().map(t -> ((UndetVar)t).getBounds(InferenceBound.EQ, InferenceBound.LOWER, InferenceBound.UPPER))\n-                    .flatMap(Collection::stream).anyMatch(Type::isPrimitiveClass)) {\n+                            .stream().map(t -> ((UndetVar) t).getBounds(InferenceBound.EQ, InferenceBound.LOWER, InferenceBound.UPPER))\n+                            .flatMap(Collection::stream).anyMatch(Type::isPrimitiveClass)) {\n@@ -494,0 +494,2 @@\n+         *\n+         * or S is unchecked-convertible to T, but S is not a subtype of T.\n@@ -496,2 +498,2 @@\n-            for (Type t : from.getBounds(InferenceBound.EQ, InferenceBound.LOWER)) {\n-                Type sup = types.asSuper(t, to.tsym);\n+            for (Type S : from.getBounds(InferenceBound.EQ, InferenceBound.LOWER)) {\n+                Type sup = types.asSuper(S, to.tsym);\n@@ -501,0 +503,3 @@\n+                if (types.isConvertible(S, to) && !types.isSubtype(S, to)) {\n+                    return true;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+compiler.warn.primitive.value.conversion\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+compiler.warn.primitive.value.conversion\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt.orig","additions":1,"deletions":0,"binary":false,"changes":1,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","status":"copied"},{"patch":"@@ -0,0 +1,7 @@\n+--- test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt\n++++ test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt\n+@@ -226,4 +226,3 @@ compiler.err.generic.parameterization.with.primitive.class\n+ compiler.misc.feature.primitive.classes\n+ compiler.misc.feature.value.classes\n+ compiler.misc.feature.universal.tvars\n+-compiler.warn.primitive.value.conversion\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt.rej","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.warn.primitive.value.conversion\n-\/\/ options: -Xlint:unchecked\n-\n-class PrimitiveValueConversionTest {\n-    primitive class Point {}\n-\n-    void m() {\n-        Point.ref pr = null;\n-        Point p = pr;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveValueConversionTest.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -2,0 +2,2 @@\n+- compiler.note.unchecked.filename: GetClass.java\n+- compiler.note.unchecked.recompile\n","filename":"test\/langtools\/tools\/javac\/generics\/GetClass.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-GenericInlineTest.java:39:13: compiler.warn.primitive.value.conversion\n+GenericInlineTest.java:39:13: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), GenericInlineTest.ref<java.lang.String,java.lang.Integer>, GenericInlineTest<java.lang.String,java.lang.Integer>\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/GenericInlineTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-TypeRelationsNegativeTest.java:16:13: compiler.warn.primitive.value.conversion\n-TypeRelationsNegativeTest.java:17:13: compiler.warn.primitive.value.conversion\n+TypeRelationsNegativeTest.java:16:13: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), TypeRelationsNegativeTest.ref, TypeRelationsNegativeTest\n+TypeRelationsNegativeTest.java:17:13: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), TypeRelationsNegativeTest.ref, TypeRelationsNegativeTest\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TypeRelationsNegativeTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary unchecked warning test for universal type variables\n+ * @compile\/ref=UncheckedWarningsTest.out -Xlint:unchecked -XDrawDiagnostics UncheckedWarningsTest.java\n+ *\/\n+\n+class UncheckedWarningsTest {\n+    static primitive class Atom { }\n+\n+    static class Box<__universal X> { }\n+    static class Pair<__universal X, __universal Y> { }\n+    static class Triple<__universal X, __universal Y, __universal Z> { }\n+\n+    public static void main(String[] args) {\n+        Box<Box<Box<Atom>>> val = null;\n+        Box<Box<Box<Atom.ref>>> ref = null;\n+        val = ref;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UncheckedWarningsTest.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+UncheckedWarningsTest.java:17:15: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom.ref>>>, UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Box<UncheckedWarningsTest.Atom>>>\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UncheckedWarningsTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -267,0 +267,34 @@\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        static primitive class Atom {}\n+                        static class Box<__universal X> {}\n+                        void test(Box<? extends Atom> t1, Box<Atom.ref> t2) {\n+                            t1 = t2;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        static primitive class Atom {}\n+                        static class Box<__universal X> {}\n+                        void test(Box<? extends Atom> t1, Box<? extends Atom.ref> t2) {\n+                            t1 = t2;\n+                        }\n+                    }\n+                    \"\"\"),\n+                new DiagAndCode(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        static primitive class Atom {}\n+                        static class Box<__universal X> {}\n+                        @SafeVarargs\n+                        private <__universal Z> Z make_box_uni(Z... bs) {\n+                            return bs[0];\n+                        }\n+                        void test(Box<Atom> bref, Box bval) {\n+                            Box<? extends Atom> res = make_box_uni(bref, bval, bval);\n+                        }\n+                    }\n@@ -592,1 +626,1 @@\n-        assertOKWithWarning(\"compiler.warn.primitive.value.conversion\",\n+        assertOKWithWarning(\"compiler.warn.prob.found.req\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"}]}