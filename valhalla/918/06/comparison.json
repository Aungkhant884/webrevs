{"files":[{"patch":"@@ -87,0 +87,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1773,0 +1774,13 @@\n+bool ciEnv::is_multifield_scalarized(BasicType bt, int vec_length) {\n+#if COMPILER2\n+  CompilerThread* ct = CompilerThread::current();\n+  if (ct && ct->compiler()->is_c2()) {\n+    return InlineTypeNode::is_multifield_scalarized(bt, vec_length);\n+  } else {\n+    return true;\n+  }\n+#else\n+  return true;\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -523,0 +523,1 @@\n+  static bool is_multifield_scalarized(BasicType type, int vec_len);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,5 +171,0 @@\n-  int bundle_size = field_desc.secondary_fields_count(field_desc.index());\n-  if (bundle_size > 1) {\n-    _type = ciType::make(field_type, bundle_size);\n-  }\n-\n@@ -203,1 +198,1 @@\n-ciField::ciField(fieldDescriptor *fd) :\n+ciField::ciField(fieldDescriptor *fd, bool bundled) :\n@@ -221,1 +216,2 @@\n-    _type = ciType::make(field_type, fd->secondary_fields_count(fd->index()));\n+    int bundle_size = bundled ? fd->secondary_fields_count(fd->index()) : 1;\n+    _type = ciType::make(field_type, bundle_size);\n@@ -252,1 +248,0 @@\n-  _is_multifield = field->_is_multifield;\n@@ -254,0 +249,1 @@\n+  _is_multifield = field->_is_multifield;\n@@ -307,0 +303,2 @@\n+  _is_multifield_base = fd->is_multifield_base() &&\n+     !ciEnv::is_multifield_scalarized(fd->field_type(), fd->secondary_fields_count(fd->index()));\n@@ -308,1 +306,0 @@\n-  _is_multifield_base = fd->is_multifield_base();\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  ciField(fieldDescriptor* fd);\n+  ciField(fieldDescriptor* fd, bool bundled = false);\n@@ -208,1 +208,3 @@\n-  ciMultiField(fieldDescriptor* fd) : ciField(fd) {}\n+  ciMultiField(fieldDescriptor* fd, bool bundled) : ciField(fd, bundled) {\n+    _is_multifield_base = true;\n+  }\n@@ -213,6 +215,6 @@\n-     Arena* arena = CURRENT_ENV->arena();\n-     _secondary_fields = new (arena) GrowableArray<ciField*>(arena, fields->length(), 0, nullptr);\n-     for (int i = 0; i < fields->length(); i++) {\n-       ciField* field = fields->at(i);\n-       _secondary_fields->append(new (arena) ciField(field, field->holder(), field->offset_in_bytes(), field->is_final()));\n-     }\n+    Arena* arena = CURRENT_ENV->arena();\n+    _secondary_fields = new (arena) GrowableArray<ciField*>(arena, fields->length(), 0, nullptr);\n+    for (int i = 0; i < fields->length(); i++) {\n+      ciField* field = fields->at(i);\n+      _secondary_fields->append(new (arena) ciField(field, field->holder(), field->offset_in_bytes(), field->is_final()));\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-    ciField* field = _declared_nonstatic_fields->at(i);\n-    int field_offset = field->offset_in_bytes();\n+    int field_offset = _declared_nonstatic_fields->at(i)->offset_in_bytes();\n@@ -63,12 +62,0 @@\n-    } else if (field->is_multifield_base()) {\n-      for (int j = 0; j < field->secondary_fields_count(); j++) {\n-        ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_field_at(j);\n-        assert(sec_field != NULL, \"\");\n-        int sec_field_offset = sec_field->offset_in_bytes();\n-        if (sec_field_offset == offset) {\n-          return i + j + 1;\n-        } else if (sec_field_offset < offset && sec_field_offset > best_offset) {\n-          best_offset = sec_field_offset;\n-          best_index = i + j + 1;\n-        }\n-      }\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -74,16 +74,1 @@\n-    \/\/ Look for field in preceding multi-field bundle;\n-    for (int j = 0; j <= i; j++) {\n-      int bundle_size = _declared_nonstatic_fields->at(j)->secondary_fields_count();\n-      if (bundle_size > 1 && ((j + bundle_size) > i)) {\n-        if (j == i) {\n-          \/\/ Multifield base.\n-          return _declared_nonstatic_fields->at(i);\n-        } else {\n-          \/\/ Secondary multifield.\n-          return static_cast<ciMultiField*>(_declared_nonstatic_fields->at(j))->secondary_fields()->at(i - (j + 1));\n-        }\n-      } else if (j == i) {\n-        return _declared_nonstatic_fields->at(i);\n-      }\n-    }\n-    return nullptr;\n+    return _declared_nonstatic_fields->at(i);\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -423,2 +423,2 @@\n-      int curr_field_offset = field->offset_in_bytes();\n-      if (curr_field_offset == field_offset)\n+      int  field_off = field->offset_in_bytes();\n+      if (field_off == field_offset)\n@@ -426,1 +426,1 @@\n-      if (curr_field_offset > field_offset)\n+      if (field_off > field_offset)\n@@ -429,10 +429,0 @@\n-      if (field->secondary_fields_count() > 1) {\n-        for (int j = 0; j < field->secondary_fields_count(); j++) {\n-          ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_fields()->at(j);\n-          int sec_field_offset = sec_field->offset_in_bytes();\n-          if (sec_field_offset == field_offset)\n-            return sec_field;\n-          if (sec_field_offset > field_offset)\n-            return NULL;\n-        }\n-      }\n@@ -555,1 +545,2 @@\n-      mfield = new (arena) ciMultiField(&fd);\n+      mfield = new (arena) ciMultiField(&fd, true);\n+\n@@ -557,1 +548,1 @@\n-      mfield->add_secondary_fields(new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, NULL));\n+      mfield->add_secondary_fields(new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, nullptr));\n@@ -576,1 +567,0 @@\n-  Arena* arena = CURRENT_ENV->arena();\n@@ -578,0 +568,1 @@\n+  Arena* arena = CURRENT_ENV->arena();\n@@ -582,1 +573,0 @@\n-    if (fs.is_multifield()) continue;\n@@ -601,2 +591,2 @@\n-    if (fs.is_multifield()) {\n-      assert(sec_fields_count && fields->last()->is_multifield_base(), \"\");\n+    if (fs.is_multifield() && sec_fields_count) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n@@ -604,0 +594,1 @@\n+      flen--;\n@@ -626,2 +617,7 @@\n-        ciField* field = NULL;\n-        if (flattened_field->is_multifield_base()) {\n+        ciField* field = nullptr;\n+        ciType* ftype = flattened_field->type();\n+        assert(ftype, \"\");\n+        BasicType bt = ftype->basic_type();\n+        int sec_fields_count = ftype->bundle_size();\n+        bool scalarize_multifield = ciEnv::is_multifield_scalarized(bt, sec_fields_count);\n+        if (flattened_field->is_multifield_base() && !scalarize_multifield) {\n@@ -636,5 +632,7 @@\n-      ciField* field = NULL;\n-      if (fs.is_multifield_base()) {\n-        field = new (arena) ciMultiField(&fd);\n-        sec_fields_count = fd.secondary_fields_count(fd.index());\n-        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, NULL);\n+      ciField* field = nullptr;\n+      BasicType bt = fd.field_type();\n+      sec_fields_count = fd.secondary_fields_count(fd.index());\n+      bool scalarize_multifield = ciEnv::is_multifield_scalarized(bt, sec_fields_count);\n+      if (fs.is_multifield_base() && !scalarize_multifield) {\n+        field = new (arena) ciMultiField(&fd, true);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, nullptr);\n@@ -645,0 +643,1 @@\n+        sec_fields_count = 0;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -43,9 +43,5 @@\n-bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n-  if (!field->is_multifield_base()) {\n-    return true;\n-  }\n-  int field_count = field->secondary_fields_count();\n-  BasicType bt = field->type()->basic_type();\n-  if (!Matcher::match_rule_supported_vector(Op_LoadVector, field_count, bt)  ||\n-      !Matcher::match_rule_supported_vector(Op_StoreVector, field_count, bt) ||\n-      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), field_count, bt)) {\n+bool InlineTypeNode::is_multifield_scalarized(BasicType bt, int vec_len) {\n+  if (!is_java_primitive(bt) ||\n+      !Matcher::match_rule_supported_vector(Op_LoadVector, vec_len, bt)  ||\n+      !Matcher::match_rule_supported_vector(Op_StoreVector, vec_len, bt) ||\n+      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n@@ -57,13 +53,3 @@\n-void InlineTypeNode::expand_input_edges(ciInlineKlass* vk) {\n-  \/\/ We generally perform three operations on multi-field bundle, load its contents into vector,\n-  \/\/ store the contents of vector to multi-field bundle or broadcast a value into a vector equivalent\n-  \/\/ in size to a multi-field bundle. If any of these operations are not supported by target platform\n-  \/\/ scalarize the multi-fields into individual fields.\n-  for (int i = 0; i < vk->nof_declared_nonstatic_fields(); i++) {\n-    ciField* field = vk->declared_nonstatic_field_at(i);\n-    if (is_multifield_scalarized(field)) {\n-      int field_count = field->secondary_fields_count();\n-      while(--field_count) {\n-        add_req(NULL);\n-      }\n-    }\n+bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n+  if (!field->is_multifield_base()) {\n+    return true;\n@@ -71,0 +57,3 @@\n+  int field_count = field->secondary_fields_count();\n+  BasicType bt = field->type()->basic_type();\n+  return is_multifield_scalarized(bt, field_count);\n@@ -323,4 +312,0 @@\n-  \/\/ Number of fields for VectorPayload* class which a safepoint node tracks\n-  \/\/ should depend on actual field_count of InlineTypeNode, this is because\n-  \/\/ we may scalarize multifield bundle if corresponding vector size is not\n-  \/\/ supported by target.\n@@ -328,1 +313,1 @@\n-     nfields = field_count();\n+     assert(field_count() == nfields, \"\");\n@@ -330,1 +315,1 @@\n-     nfields = field_value(0)->as_InlineType()->field_count();\n+     assert(field_value(0)->as_InlineType()->field_count() == nfields, \"\");\n@@ -353,2 +338,0 @@\n-  int cnt = 0;\n-  ciMultiField* mfield = nullptr;\n@@ -356,9 +339,1 @@\n-    ciField* field = mfield != nullptr ? mfield->secondary_field_at(cnt++) : vk->nonstatic_field_at(j);\n-    if (field->is_multifield_base()) {\n-      mfield = static_cast<ciMultiField*>(field);\n-    }\n-    if (mfield && ((mfield->secondary_fields_count() - 1) == cnt)) {\n-      mfield = nullptr;\n-      cnt = 0;\n-    }\n-    int offset = field->offset_in_bytes();\n+    int offset = vk->nonstatic_field_at(j)->offset_in_bytes();\n@@ -856,1 +831,1 @@\n-  int is_multifield_base = klass->declared_nonstatic_field_at(index)->is_multifield_base();\n+  bool is_multifield_base = klass->declared_nonstatic_field_at(index)->is_multifield_base();\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":15,"deletions":40,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    expand_input_edges(vk);\n@@ -55,2 +54,0 @@\n-  void expand_input_edges(ciInlineKlass * vk);\n-\n@@ -98,0 +95,1 @@\n+  static bool is_multifield_scalarized(BasicType bt, int vec_len);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}