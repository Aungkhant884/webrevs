{"files":[{"patch":"@@ -86,0 +86,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1776,0 +1777,8 @@\n+\n+bool ciEnv::is_multifield_scalarized(BasicType bt, int vec_length) {\n+#if COMPILER2\n+  return InlineTypeNode::is_multifield_scalarized(bt, vec_length);\n+#else\n+  return false;\n+#endif\n+}\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -522,0 +522,1 @@\n+  static bool is_multifield_scalarized(BasicType type, int vec_len);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  assert(super() == NULL || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n+  assert(super() == nullptr || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n@@ -37,2 +37,2 @@\n-  GrowableArray<ciField*>* fields = NULL;\n-  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(NULL, false \/* no flattening *\/);)\n+  GrowableArray<ciField*>* fields = nullptr;\n+  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(nullptr, false \/* no flattening *\/);)\n@@ -40,1 +40,1 @@\n-  _declared_nonstatic_fields = (fields != NULL) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n+  _declared_nonstatic_fields = (fields != nullptr) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n@@ -58,2 +58,1 @@\n-    ciField* field = _declared_nonstatic_fields->at(i);\n-    int field_offset = field->offset_in_bytes();\n+    int field_offset = _declared_nonstatic_fields->at(i)->offset_in_bytes();\n@@ -63,12 +62,0 @@\n-    } else if (field->is_multifield_base()) {\n-      for (int j = 0; j < field->secondary_fields_count(); j++) {\n-        ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_field_at(j);\n-        assert(sec_field != NULL, \"\");\n-        int sec_field_offset = sec_field->offset_in_bytes();\n-        if (sec_field_offset == offset) {\n-          return i + j + 1;\n-        } else if (sec_field_offset < offset && sec_field_offset > best_offset) {\n-          best_offset = sec_field_offset;\n-          best_index = i + j + 1;\n-        }\n-      }\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    if (_declared_nonstatic_fields == NULL) {\n+    if (_declared_nonstatic_fields == nullptr) {\n@@ -73,17 +73,2 @@\n-    assert(_declared_nonstatic_fields != NULL, \"should be initialized\");\n-    \/\/ Look for field in preceding multi-field bundle;\n-    for (int j = 0; j <= i; j++) {\n-      int bundle_size = _declared_nonstatic_fields->at(j)->secondary_fields_count();\n-      if (bundle_size > 1 && ((j + bundle_size) > i)) {\n-        if (j == i) {\n-          \/\/ Multifield base.\n-          return _declared_nonstatic_fields->at(i);\n-        } else {\n-          \/\/ Secondary multifield.\n-          return static_cast<ciMultiField*>(_declared_nonstatic_fields->at(j))->secondary_fields()->at(i - (j + 1));\n-        }\n-      } else if (j == i) {\n-        return _declared_nonstatic_fields->at(i);\n-      }\n-    }\n-    return NULL;\n+    assert(_declared_nonstatic_fields != nullptr, \"should be initialized\");\n+    return _declared_nonstatic_fields->at(i);\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -423,2 +423,2 @@\n-      int curr_field_offset = field->offset_in_bytes();\n-      if (curr_field_offset == field_offset)\n+      int  field_off = field->offset_in_bytes();\n+      if (field_off == field_offset)\n@@ -426,1 +426,1 @@\n-      if (curr_field_offset > field_offset)\n+      if (field_off > field_offset)\n@@ -429,10 +429,0 @@\n-      if (field->secondary_fields_count() > 1) {\n-        for (int j = 0; j < field->secondary_fields_count(); j++) {\n-          ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_fields()->at(j);\n-          int sec_field_offset = sec_field->offset_in_bytes();\n-          if (sec_field_offset == field_offset)\n-            return sec_field;\n-          if (sec_field_offset > field_offset)\n-            return NULL;\n-        }\n-      }\n@@ -557,1 +547,1 @@\n-      mfield->add_secondary_fields(new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, NULL));\n+      mfield->add_secondary_fields(new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, nullptr));\n@@ -576,1 +566,0 @@\n-  Arena* arena = CURRENT_ENV->arena();\n@@ -578,0 +567,1 @@\n+  Arena* arena = CURRENT_ENV->arena();\n@@ -582,1 +572,0 @@\n-    if (fs.is_multifield()) continue;\n@@ -601,2 +590,2 @@\n-    if (fs.is_multifield()) {\n-      assert(sec_fields_count && fields->last()->is_multifield_base(), \"\");\n+    if (fs.is_multifield() && sec_fields_count) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n@@ -604,0 +593,1 @@\n+      flen--;\n@@ -626,2 +616,7 @@\n-        ciField* field = NULL;\n-        if (flattened_field->is_multifield_base()) {\n+        ciField* field = nullptr;\n+        ciType* ftype = flattened_field->type();\n+        assert(ftype, \"\");\n+        BasicType bt = ftype->basic_type();\n+        int sec_fields_count = ftype->bundle_size();\n+        bool scalarize_multifield = ciEnv::is_multifield_scalarized(bt, sec_fields_count);\n+        if (flattened_field->is_multifield_base() && !scalarize_multifield) {\n@@ -636,2 +631,5 @@\n-      ciField* field = NULL;\n-      if (fs.is_multifield_base()) {\n+      ciField* field = nullptr;\n+      BasicType bt = fd.field_type();\n+      sec_fields_count = fd.secondary_fields_count(fd.index());\n+      bool scalarize_multifield = ciEnv::is_multifield_scalarized(bt, sec_fields_count);\n+      if (fs.is_multifield_base() && !scalarize_multifield) {\n@@ -639,2 +637,1 @@\n-        sec_fields_count = fd.secondary_fields_count(fd.index());\n-        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, NULL);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, nullptr);\n@@ -645,0 +642,1 @@\n+        sec_fields_count = 0;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -43,9 +43,5 @@\n-bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n-  if (!field->is_multifield_base()) {\n-    return true;\n-  }\n-  int field_count = field->secondary_fields_count();\n-  BasicType bt = field->type()->basic_type();\n-  if (!Matcher::match_rule_supported_vector(Op_LoadVector, field_count, bt)  ||\n-      !Matcher::match_rule_supported_vector(Op_StoreVector, field_count, bt) ||\n-      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), field_count, bt)) {\n+bool InlineTypeNode::is_multifield_scalarized(BasicType bt, int vec_len) {\n+  if (!is_java_primitive(bt) ||\n+      !Matcher::match_rule_supported_vector(Op_LoadVector, vec_len, bt)  ||\n+      !Matcher::match_rule_supported_vector(Op_StoreVector, vec_len, bt) ||\n+      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n@@ -57,13 +53,3 @@\n-void InlineTypeNode::expand_input_edges(ciInlineKlass* vk) {\n-  \/\/ We generally perform three operations on multi-field bundle, load its contents into vector,\n-  \/\/ store the contents of vector to multi-field bundle or broadcast a value into a vector equivalent\n-  \/\/ in size to a multi-field bundle. If any of these operations are not supported by target platform\n-  \/\/ scalarize the multi-fields into individual fields.\n-  for (int i = 0; i < vk->nof_declared_nonstatic_fields(); i++) {\n-    ciField* field = vk->declared_nonstatic_field_at(i);\n-    if (is_multifield_scalarized(field)) {\n-      int field_count = field->secondary_fields_count();\n-      while(--field_count) {\n-        add_req(NULL);\n-      }\n-    }\n+bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n+  if (!field->is_multifield_base()) {\n+    return true;\n@@ -71,0 +57,3 @@\n+  int field_count = field->secondary_fields_count();\n+  BasicType bt = field->type()->basic_type();\n+  return is_multifield_scalarized(bt, field_count);\n@@ -323,4 +312,0 @@\n-  \/\/ Number of fields for VectorPayload* class which a safepoint node tracks\n-  \/\/ should depend on actual field_count of InlineTypeNode, this is because\n-  \/\/ we may scalarize multifield bundle if corresponding vector size is not\n-  \/\/ supported by target.\n@@ -328,1 +313,1 @@\n-     nfields = field_count();\n+     assert(field_count() == nfields, \"\");\n@@ -330,1 +315,1 @@\n-     nfields = field_value(0)->as_InlineType()->field_count();\n+     assert(field_value(0)->as_InlineType()->field_count() == nfields, \"\");\n@@ -334,1 +319,1 @@\n-  assert(jvms != NULL, \"missing JVMS\");\n+  assert(jvms != nullptr, \"missing JVMS\");\n@@ -338,1 +323,1 @@\n-                                                                  NULL,\n+                                                                  nullptr,\n@@ -355,2 +340,0 @@\n-  int cnt = 0;\n-  ciMultiField* mfield = nullptr;\n@@ -358,9 +341,1 @@\n-    ciField* field = mfield != nullptr ? mfield->secondary_field_at(cnt++) : vk->nonstatic_field_at(j);\n-    if (field->is_multifield_base()) {\n-      mfield = static_cast<ciMultiField*>(field);\n-    }\n-    if (mfield && ((mfield->secondary_fields_count() - 1) == cnt)) {\n-      mfield = nullptr;\n-      cnt = 0;\n-    }\n-    int offset = field->offset_in_bytes();\n+    int offset = vk->nonstatic_field_at(j)->offset_in_bytes();\n@@ -379,1 +354,1 @@\n-    if (debug != NULL && debug->uncast() == this) {\n+    if (debug != nullptr && debug->uncast() == this) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":17,"deletions":42,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    expand_input_edges(vk);\n@@ -98,0 +97,1 @@\n+  static bool is_multifield_scalarized(BasicType bt, int vec_len);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}