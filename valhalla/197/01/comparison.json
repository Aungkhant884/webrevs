{"files":[{"patch":"@@ -783,1 +783,1 @@\n-  if (!will_link || str->is_unresolved_klass()) {\n+  if (!will_link || str->is_unresolved_klass() || klass->is_inlinetype()) {\n@@ -795,1 +795,1 @@\n-  if (!will_link) {\n+  if (!will_link || !klass->is_inlinetype()) {\n@@ -798,1 +798,0 @@\n-    assert(klass->is_inlinetype(), \"should be inline type\");\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -871,1 +871,1 @@\n-    if (has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null()) {\n+    if (has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null() && t->inline_klass()->can_be_passed_as_fields()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-\n@@ -141,4 +140,0 @@\n-  bool is_vol = field->is_volatile();\n-  bool flattened = field->is_flattened();\n-\n-  \/\/ Compute address and memory type.\n@@ -146,6 +141,0 @@\n-  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n-  Node *adr = basic_plus_adr(obj, obj, offset);\n-\n-  \/\/ Build the resultant type of the load\n-  const Type *type;\n-\n@@ -154,16 +143,25 @@\n-  DecoratorSet decorators = IN_HEAP;\n-  decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;\n-\n-  bool is_obj = is_reference_type(bt);\n-\n-  if (is_obj) {\n-    if (!field->type()->is_loaded()) {\n-      type = TypeInstPtr::BOTTOM;\n-      must_assert_null = true;\n-    } else if (field->is_static_constant()) {\n-      \/\/ This can happen if the constant oop is non-perm.\n-      ciObject* con = field->constant_value().as_object();\n-      \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-      \/\/ and may yield a vacuous result if the field is of interface type.\n-      if (con->is_null_object()) {\n-        type = TypePtr::NULL_PTR;\n+  Node* ld = NULL;\n+  if (bt == T_INLINE_TYPE && field_klass->as_inline_klass()->is_empty()) {\n+    \/\/ Loading from a field of an empty inline type. Just return the default instance.\n+    ld = InlineTypeNode::make_default(_gvn, field_klass->as_inline_klass());\n+  } else if (field->is_flattened()) {\n+    \/\/ Loading from a flattened inline type field.\n+    ld = InlineTypeNode::make_from_flattened(this, field_klass->as_inline_klass(), obj, obj, field->holder(), offset);\n+  } else {\n+    \/\/ Build the resultant type of the load\n+    const Type* type;\n+    if (is_reference_type(bt)) {\n+      if (!field_klass->is_loaded()) {\n+        type = TypeInstPtr::BOTTOM;\n+        must_assert_null = true;\n+      } else if (field->is_static_constant()) {\n+        \/\/ This can happen if the constant oop is non-perm.\n+        ciObject* con = field->constant_value().as_object();\n+        \/\/ Do not \"join\" in the previous type; it doesn't add value,\n+        \/\/ and may yield a vacuous result if the field is of interface type.\n+        if (con->is_null_object()) {\n+          type = TypePtr::NULL_PTR;\n+        } else {\n+          type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n+        }\n+        assert(type != NULL, \"field singleton type must be consistent\");\n@@ -171,12 +169,8 @@\n-        type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n-      }\n-      assert(type != NULL, \"field singleton type must be consistent\");\n-    } else {\n-      type = TypeOopPtr::make_from_klass(field_klass->as_klass());\n-      if (bt == T_INLINE_TYPE && field->is_static()) {\n-        \/\/ Check if static inline type field is already initialized\n-        assert(!flattened, \"static fields should not be flattened\");\n-        ciInstance* mirror = field->holder()->java_mirror();\n-        ciObject* val = mirror->field_value(field).as_object();\n-        if (!val->is_null_object()) {\n-          type = type->join_speculative(TypePtr::NOTNULL);\n+        type = TypeOopPtr::make_from_klass(field_klass->as_klass());\n+        if (bt == T_INLINE_TYPE && field->is_static()) {\n+          \/\/ Check if static inline type field is already initialized\n+          ciInstance* mirror = field->holder()->java_mirror();\n+          ciObject* val = mirror->field_value(field).as_object();\n+          if (!val->is_null_object()) {\n+            type = type->join_speculative(TypePtr::NOTNULL);\n+          }\n@@ -185,0 +179,2 @@\n+    } else {\n+      type = Type::get_const_basic_type(bt);\n@@ -186,9 +182,2 @@\n-  } else {\n-    type = Type::get_const_basic_type(bt);\n-  }\n-\n-  Node* ld = NULL;\n-  if (flattened) {\n-    \/\/ Load flattened inline type\n-    ld = InlineTypeNode::make_from_flattened(this, field_klass->as_inline_klass(), obj, obj, field->holder(), offset);\n-  } else {\n+    Node* adr = basic_plus_adr(obj, obj, offset);\n+    const TypePtr* adr_type = C->alias_type(field)->adr_type();\n@@ -196,1 +185,1 @@\n-    decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;\n+    decorators |= field->is_volatile() ? MO_SEQ_CST : MO_UNORDERED;\n@@ -230,1 +219,1 @@\n-                     C->log()->identify(field->type()));\n+                     C->log()->identify(field_klass));\n@@ -241,2 +230,0 @@\n-\n-  \/\/ Compute address and memory type.\n@@ -244,2 +231,0 @@\n-  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n-  Node* adr = basic_plus_adr(obj, obj, offset);\n@@ -247,1 +232,0 @@\n-  \/\/ Value to be stored\n@@ -250,22 +234,3 @@\n-  DecoratorSet decorators = IN_HEAP;\n-  decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;\n-\n-  bool is_obj = is_reference_type(bt);\n-  \/\/ Store the value.\n-  const Type* field_type;\n-  if (!field->type()->is_loaded()) {\n-    field_type = TypeInstPtr::BOTTOM;\n-  } else {\n-    if (is_obj) {\n-      field_type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n-    } else {\n-      field_type = Type::BOTTOM;\n-    }\n-  }\n-\n-  if (bt == T_INLINE_TYPE && !val->is_InlineType()) {\n-    \/\/ We can see a null constant here\n-    assert(val->bottom_type()->remove_speculative() == TypePtr::NULL_PTR, \"Anything other than null?\");\n-    push(null());\n-    uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);\n-    assert(stopped(), \"dead path\");\n+  assert(bt != T_INLINE_TYPE || val->is_InlineType() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n+  if (bt == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+    \/\/ Storing to a field of an empty inline type. Ignore.\n@@ -273,4 +238,2 @@\n-  }\n-\n-  if (field->is_flattened()) {\n-    \/\/ Store flattened inline type to a non-static field\n+  } else if (field->is_flattened()) {\n+    \/\/ Storing to a flattened inline type field.\n@@ -278,1 +241,0 @@\n-      assert(!gvn().type(val)->maybe_null(), \"should never be null\");\n@@ -281,1 +243,1 @@\n-    val->as_InlineType()->store_flattened(this, obj, obj, field->holder(), offset, decorators);\n+    val->as_InlineType()->store_flattened(this, obj, obj, field->holder(), offset);\n@@ -283,0 +245,15 @@\n+    \/\/ Store the value.\n+    const Type* field_type;\n+    if (!field->type()->is_loaded()) {\n+      field_type = TypeInstPtr::BOTTOM;\n+    } else {\n+      if (is_reference_type(bt)) {\n+        field_type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n+      } else {\n+        field_type = Type::BOTTOM;\n+      }\n+    }\n+    Node* adr = basic_plus_adr(obj, obj, offset);\n+    const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+    DecoratorSet decorators = IN_HEAP;\n+    decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":60,"deletions":83,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+  assert(!klass->is_inlinetype(), \"unexpected inline type\");\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+    protected static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -343,0 +343,1 @@\n+    @DontCompile\n@@ -364,0 +365,1 @@\n+    @DontCompile\n@@ -374,0 +376,1 @@\n+    @DontCompile\n@@ -409,0 +412,1 @@\n+    @DontCompile\n@@ -429,0 +433,1 @@\n+    @DontCompile\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -904,0 +904,13 @@\n+\n+    \/\/ Test passing\/returning an empty inline type together with non-empty\n+    \/\/ inline types such that only some inline type arguments are scalarized.\n+    @Test(failOn = ALLOC + LOAD + STORE + TRAP)\n+    public MyValueEmpty test41(MyValue1 vt1, MyValueEmpty vt2, MyValue1 vt3) {\n+        return vt2.copy(vt2);\n+    }\n+\n+    @DontCompile\n+    public void test41_verifier(boolean warmup) {\n+        MyValueEmpty res = test41(MyValue1.default, MyValueEmpty.default, MyValue1.default);\n+        Asserts.assertEQ(res, MyValueEmpty.default);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    @DontCompile\n@@ -99,0 +100,1 @@\n+    @DontCompile\n@@ -109,0 +111,1 @@\n+    @DontCompile\n@@ -128,0 +131,1 @@\n+    @DontCompile\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3308,0 +3308,67 @@\n+\n+    \/\/ Test removal of empty inline type field stores\n+    @Test(failOn = ALLOC + ALLOC_G + LOAD + STORE + FIELD_ACCESS + NULL_CHECK_TRAP + TRAP)\n+    public void test120(MyValueEmpty empty) {\n+        fEmpty1 = empty;\n+        fEmpty3 = empty;\n+        \/\/ fEmpty2 and fEmpty4 could be null, store can't be removed\n+    }\n+\n+    @DontCompile\n+    public void test120_verifier(boolean warmup) {\n+        test120(MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty1, MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty2, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test removal of empty inline type field loads\n+    @Test(failOn = ALLOC + ALLOC_G + LOAD + STORE + FIELD_ACCESS + NULL_CHECK_TRAP + TRAP)\n+    public boolean test121() {\n+        return fEmpty1.equals(fEmpty3);\n+        \/\/ fEmpty2 and fEmpty4 could be null, load can't be removed\n+    }\n+\n+    @DontCompile\n+    public void test121_verifier(boolean warmup) {\n+        boolean res = test121();\n+        Asserts.assertTrue(res);\n+    }\n+\n+    \/\/ TODO Disabled until JDK-8253416 is fixed\n+    \/*\n+    \/\/ Verify that empty inline type field loads check for null holder\n+    @Test()\n+    public MyValueEmpty test122(TestLWorld t) {\n+        return t.fEmpty3;\n+    }\n+\n+    @DontCompile\n+    public void test122_verifier(boolean warmup) {\n+        MyValueEmpty res = test122(this);\n+        Asserts.assertEquals(res, MyValueEmpty.default);\n+        try {\n+            test122(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Verify that empty inline type field stores check for null holder\n+    @Test()\n+    public void test123(TestLWorld t) {\n+        t.fEmpty3 = MyValueEmpty.default;\n+    }\n+\n+    @DontCompile\n+    public void test123_verifier(boolean warmup) {\n+        test123(this);\n+        Asserts.assertEquals(fEmpty3, MyValueEmpty.default);\n+        try {\n+            test123(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+    @DontCompile\n@@ -385,0 +386,1 @@\n+    @DontCompile\n@@ -395,0 +397,1 @@\n+    @DontCompile\n@@ -430,0 +433,1 @@\n+    @DontCompile\n@@ -450,0 +454,1 @@\n+    @DontCompile\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}