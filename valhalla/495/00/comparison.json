{"files":[{"patch":"@@ -2074,5 +2074,10 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n-      mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n-      mb->init_req(TypeFunc::Control, storestore->in(TypeFunc::Control));\n-      igvn->register_new_node_with_optimizer(mb);\n-      igvn->replace_node(storestore, mb);\n+      if (alloc->in(AllocateNode::InlineTypeNode) != NULL) {\n+        \/\/ Non-escaping inline type buffer allocations don't require a membar\n+        storestore->as_MemBar()->remove(_igvn);\n+      } else {\n+        MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n+        mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n+        mb->init_req(TypeFunc::Control, storestore->in(TypeFunc::Control));\n+        igvn->register_new_node_with_optimizer(mb);\n+        igvn->replace_node(storestore, mb);\n+      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1080,5 +1080,0 @@\n-          \/\/ Inline type buffer allocations are followed by a membar\n-          Node* membar_after = ctrl_proj->unique_ctrl_out();\n-          if (inline_alloc && membar_after->Opcode() == Op_MemBarCPUOrder) {\n-            membar_after->as_MemBar()->remove(&_igvn);\n-          }\n@@ -1087,0 +1082,1 @@\n+          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become NULL\n@@ -1088,1 +1084,1 @@\n-          assert(tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n+          assert(tmp == NULL || tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8270995\n+ * @summary Membars of non-escaping inline type buffer allocations should be removed.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-TieredCompilation -XX:-ReduceInitialCardMarks\n+ *                   -XX:+AlwaysIncrementalInline -Xbatch -XX:CompileCommand=compileonly,*TestUnexpectedMemBar::test*\n+ *                   -XX:+StressIGVN -XX:+StressGCM -XX:+StressLCM -XX:StressSeed=851121348\n+ *                   compiler.valhalla.inlinetypes.TestUnexpectedMemBar\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-TieredCompilation -XX:-ReduceInitialCardMarks -XX:+AlwaysIncrementalInline\n+ *                   -Xbatch -XX:CompileCommand=compileonly,*TestUnexpectedMemBar::test*\n+ *                   -XX:+StressIGVN -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestUnexpectedMemBar\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch -XX:CompileCommand=compileonly,*TestUnexpectedMemBar::test*\n+ *                   -XX:+StressIGVN -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestUnexpectedMemBar\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.test.lib.Asserts;\n+\n+primitive class MyValue {\n+    final int a = 0;\n+    final int b = 0;\n+    final int c = 0;\n+    final int d = 0;\n+    final int e = 0;\n+\n+    final Integer i;\n+    final int[] array;\n+\n+    public MyValue(Integer i, int[] array) {\n+        this.i = i;\n+        this.array = array;\n+    }\n+}\n+\n+public class TestUnexpectedMemBar {\n+\n+    public static int test1(Integer i) {\n+        int[] array = new int[1];\n+        MyValue vt = new MyValue(i, array);\n+        vt = new MyValue(vt.i, vt.array);\n+        return vt.i + vt.array[0];\n+    }\n+\n+    public static int test2(Integer i) {\n+        int[] array = {i};\n+        MyValue vt = new MyValue(i, array);\n+        vt = new MyValue(vt.i, vt.array);\n+        return vt.i + vt.array[0];\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100_000; ++i) {\n+            int res = test1(i);\n+            Asserts.assertEquals(res, i, \"test1 failed\");\n+            res = test2(i);\n+            Asserts.assertEquals(res, 2*i, \"test2 failed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnexpectedMemBar.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}