{"files":[{"patch":"@@ -142,5 +142,0 @@\n-    \/**\n-     * Flag is set for a reference favoring primitive class.\n-     *\/\n-    public static final int REFERENCE_FAVORING          = 1<<19;\n-\n@@ -415,5 +410,0 @@\n-    \/\/ Encodings for extended flags stored using attributes\n-    \/**\n-     * Flag to indicate that the primitive class is reference default.\n-     *\/\n-    public static final int ACC_REF_DEFAULT = 1;\n@@ -514,1 +504,0 @@\n-        REFERENCE_FAVORING(Flags.REFERENCE_FAVORING),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+        boolean isReferenceProjection;\n@@ -238,7 +239,1 @@\n-            if (t.isReferenceProjection()) {\n-                buf.append('.');\n-                buf.append(t.tsym.name.table.names.ref);\n-            } else if (t.isValueProjection()) {\n-                buf.append('.');\n-                buf.append(t.tsym.name.table.names.val);\n-            }\n+            isReferenceProjection = t.isReferenceProjection();\n@@ -246,1 +241,5 @@\n-            \/\/ don't let missing types capsize the boat.\n+            isReferenceProjection = false; \/\/ handle missing types gracefully.\n+        }\n+        if (isReferenceProjection) {\n+            buf.append('.');\n+            buf.append(t.tsym.name.table.names.ref);\n@@ -248,1 +247,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -419,8 +419,0 @@\n-    public boolean isSynthetic() {\n-        return (flags_field & SYNTHETIC) != 0;\n-    }\n-\n-    public boolean isReferenceFavoringPrimitiveClass() {\n-        return (flags() & REFERENCE_FAVORING) != 0;  \/\/ bit set only for primitive classes\n-    }\n-\n@@ -1440,1 +1432,1 @@\n-                    ct.flavor = ct.flavor.metamorphose(this.flags_field);\n+                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -253,2 +253,2 @@\n-     * @return true IFF the receiver is a reference projection type of a *value favoring* primitive class\n-     * and false otherwise.\n+     * @return true IFF the receiver is a reference projection of a primitive class type and false\n+     * for primitives or plain references\n@@ -261,18 +261,2 @@\n-     * @return true IFF the receiver is a primitive reference type and false otherwise.\n-     *\/\n-    public boolean isPrimitiveReferenceType() {\n-        return false;\n-    }\n-\n-    \/**\n-     * @return true IFF the receiver is a value projection of a *reference favoring* primitive class type\n-     * and false otherwise.\n-     *\/\n-    public boolean isValueProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns the ClassType representing the primitive value type\n-     * of this type, if the class of this type is a primitive class\n-     * null otherwise\n+     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n+     * and null otherwise\n@@ -280,1 +264,1 @@\n-    public ClassType asValueType() {\n+    public Type valueProjection() {\n@@ -1060,2 +1044,2 @@\n-             * A primitive reference type:  (Assosiated primitive class could be either\n-             * reference default or value-default)\n+             * Reference projection type of a primitive-favoring aka primitive-default\n+             * plain vanilla primitive class type,\n@@ -1090,2 +1074,1 @@\n-             *  As yet unknown projection type of an as yet unknown default provenance class. Is also\n-             *  the terminal flavor for package-info\/module-info files.\n+             *  As yet unknown projection type of an as yet unknown default provenance class.\n@@ -1103,4 +1086,1 @@\n-            public Flavor metamorphose(long classFlags) {\n-\n-                boolean isPrimtiveClass = (classFlags & PRIMITIVE_CLASS) != 0;\n-                boolean isReferenceFavoring = (classFlags & REFERENCE_FAVORING) != 0;\n+            public Flavor metamorphose(boolean isPrimtiveClass) {\n@@ -1120,1 +1100,1 @@\n-                            return isReferenceFavoring ? Q_TypeOf_L : Q_TypeOf_Q;\n+                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n@@ -1122,1 +1102,1 @@\n-                            return isPrimtiveClass ? (isReferenceFavoring ? L_TypeOf_Q : Q_TypeOf_Q) : L_TypeOf_L;\n+                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n@@ -1235,0 +1215,2 @@\n+\n+            boolean isReferenceProjection;\n@@ -1236,7 +1218,1 @@\n-                if (isReferenceProjection()) {\n-                    buf.append('.');\n-                    buf.append(tsym.name.table.names.ref);\n-                } else if (isValueProjection()) {\n-                    buf.append('.');\n-                    buf.append(tsym.name.table.names.val);\n-                }\n+                isReferenceProjection = isReferenceProjection();\n@@ -1244,1 +1220,5 @@\n-                \/\/ don't let missing types capsize the boat.\n+                isReferenceProjection = false; \/\/ handle missing types gracefully.\n+            }\n+            if (isReferenceProjection) {\n+                buf.append('.');\n+                buf.append(tsym.name.table.names.ref);\n@@ -1246,0 +1226,1 @@\n+\n@@ -1308,1 +1289,1 @@\n-                outer_field = outer_field.asValueType();\n+                outer_field = outer_field.valueProjection();\n@@ -1343,7 +1324,1 @@\n-            \/\/ guard against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.Q_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.flags());\n-                }\n-            }\n-            return flavor == Flavor.Q_TypeOf_Q || flavor == Flavor.Q_TypeOf_L;\n+            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n@@ -1354,12 +1329,1 @@\n-            \/\/ guard against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.flags());\n-                }\n-            }\n-            return flavor == Flavor.L_TypeOf_Q && tsym.type.getFlavor() == Flavor.Q_TypeOf_Q; \/\/ discount reference favoring primitives.\n-        }\n-\n-        @Override\n-        public boolean isPrimitiveReferenceType() {\n-            \/\/ guard against over-eager and\/or inopportune completion\n+            \/\/ gaurd against over-eager and\/or inopportune completion\n@@ -1368,1 +1332,1 @@\n-                    flavor = flavor.metamorphose(tsym.flags());\n+                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n@@ -1375,5 +1339,3 @@\n-        public boolean isValueProjection() {\n-            \/\/ guard against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.Q_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.flags());\n+        public Type valueProjection() {\n+            if (!isReferenceProjection())\n+                return null;\n@@ -1381,4 +1343,2 @@\n-                }\n-            }\n-            return flavor == Flavor.Q_TypeOf_L;\n-        }\n+            if (projection !=  null)\n+                return projection;\n@@ -1386,5 +1346,3 @@\n-        \/\/ return the primitive value type *preserving parameterizations*\n-        @Override\n-        public ClassType asValueType() {\n-            if (tsym == null || !tsym.isPrimitiveClass())\n-                return null;\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n+            projection.allparams_field = allparams_field;\n+            projection.supertype_field = supertype_field;\n@@ -1392,21 +1350,4 @@\n-            switch (flavor) {\n-                case Q_TypeOf_L:\n-                case Q_TypeOf_Q:\n-                    return this;\n-                case L_TypeOf_Q:\n-                    if (projection != null)\n-                        return projection;\n-\n-                    projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(),\n-                            tsym.isReferenceFavoringPrimitiveClass() ? Flavor.Q_TypeOf_L : Flavor.Q_TypeOf_Q);\n-                    projection.allparams_field = allparams_field;\n-                    projection.supertype_field = supertype_field;\n-\n-                    projection.interfaces_field = interfaces_field;\n-                    projection.all_interfaces_field = all_interfaces_field;\n-                    projection.projection = this;\n-                    return projection;\n-                default:\n-                    Assert.check(false, \"Should not get here\");\n-                    return null;\n-            }\n+            projection.interfaces_field = interfaces_field;\n+            projection.all_interfaces_field = all_interfaces_field;\n+            projection.projection = this;\n+            return projection;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":36,"deletions":95,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -1214,2 +1213,1 @@\n-                    && (t.tsym != s.tsym ||\n-                        (t.isReferenceProjection() == s.isReferenceProjection() && t.isValueProjection() == s.isValueProjection()))\n+                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1462,1 +1460,0 @@\n-                    && t.isValueProjection() == s.isValueProjection()\n@@ -1470,1 +1467,1 @@\n-                        et = et.asValueType();\n+                        et = et.valueProjection();\n@@ -2266,1 +2263,1 @@\n-            if (t.hasTag(CLASS) && !t.tsym.isPrimitiveClass() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n+            if (t.hasTag(CLASS) && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n@@ -2629,9 +2626,1 @@\n-                Flavor wantedFlavor = t.flavor;\n-                if (t.isIntersection()) {\n-                    IntersectionClassType ict = (IntersectionClassType) t;\n-                    Type firstExplicitBound = ict.getExplicitComponents().head;\n-                    if (firstExplicitBound.hasTag(CLASS))\n-                        wantedFlavor = firstExplicitBound.getFlavor();\n-                    \/\/ Todo: Handle Type variable case.\n-                }\n-                if (erased.hasTag(CLASS) && wantedFlavor != erased.getFlavor()) {\n+                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n@@ -2640,1 +2629,1 @@\n-                            erased.getMetadata(), wantedFlavor);\n+                            erased.getMetadata(), t.flavor);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-                if (env.info.inWithField && v.getKind() == ElementKind.FIELD && (v.flags() & STATIC) == 0 && v.owner.isPrimitiveClass()) {\n+                if (env.info.inWithField && v.getKind() == ElementKind.FIELD && (v.flags() & STATIC) == 0 && types.isPrimitiveClass(v.owner.type)) {\n@@ -1334,1 +1334,1 @@\n-                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isPrimitiveClass()) ||\n+                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && types.isPrimitiveClass(v.owner.type)) ||\n@@ -1537,1 +1537,1 @@\n-                        (sym.flags() & STATIC) != 0 || !sym.owner.isPrimitiveClass()) {\n+                        (sym.flags() & STATIC) != 0 || !types.isPrimitiveClass(sym.owner.type)) {\n@@ -1551,2 +1551,1 @@\n-                    \/\/ withfield always evaluates to the primitive value type.\n-                    capturedType = capture(ownType.asValueType());\n+                    capturedType = capture(ownType);\n@@ -2215,1 +2214,1 @@\n-                                         : t.isPrimitiveReferenceType() ? t.asValueType() : t)\n+                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n@@ -2660,1 +2659,1 @@\n-                boolean superCallOnPrimitiveReceiver = env.enclClass.sym.isPrimitiveClass()\n+                boolean superCallOnPrimitiveReceiver = types.isPrimitiveClass(env.enclClass.sym.type)\n@@ -2664,1 +2663,1 @@\n-                if (qualifier.tsym.isPrimitiveClass() || superCallOnPrimitiveReceiver) {\n+                if (types.isPrimitiveClass(qualifier) || superCallOnPrimitiveReceiver) {\n@@ -2883,6 +2882,3 @@\n-            JCExpression instantiation = clazz;\n-            if (instantiation.hasTag(TYPEAPPLY))\n-                instantiation = ((JCTypeApply) instantiation).clazz;\n-            if (instantiation.hasTag(SELECT)) {\n-                JCFieldAccess fieldAccess = (JCFieldAccess) instantiation;\n-                if (fieldAccess.selected.type.tsym.isPrimitiveClass() &&\n+            if (clazz.hasTag(SELECT)) {\n+                JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n+                if (fieldAccess.selected.type.isPrimitiveClass() &&\n@@ -2982,4 +2978,0 @@\n-        \/\/ For primitive classes construction always returns the value type.\n-        if (owntype.tsym.isPrimitiveClass()) {\n-            owntype = owntype.asValueType();\n-        }\n@@ -4564,2 +4556,2 @@\n-                } else if ((name == names.ref || name == names.val) && site.tsym != null && site.tsym.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP)) {\n-                    return site.tsym; \/\/ TODO: JDK-8244229: Need more robust handling of .ref and .val reference in source code\n+                } else if (site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n+                    return site.tsym;\n@@ -4676,2 +4668,2 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference\/value projection\n-                    \/\/ is requested via the .ref\/.val notation, then adjust the computed type to\n+                    \/\/ (a) If symbol is a primitive class and its reference projection\n+                    \/\/ is requested via the .ref notation, then adjust the computed type to\n@@ -4679,22 +4671,2 @@\n-                    if (sym.isPrimitiveClass()) {\n-                        if (sym.isReferenceFavoringPrimitiveClass()) {\n-                            Assert.check(owntype.getFlavor() == Flavor.L_TypeOf_Q);\n-                        } else {\n-                            Assert.check(owntype.getFlavor() == Flavor.Q_TypeOf_Q);\n-                        }\n-                        if (tree.hasTag(SELECT)) {\n-                            Name name = ((JCFieldAccess)tree).name;\n-                            if (name == names.ref) {\n-                                if (sym.isReferenceFavoringPrimitiveClass()) {\n-                                    \/\/ We should already be good to go with owntype\n-                                } else {\n-                                    owntype = new ClassType(ownOuter, owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                                }\n-                            } else if (name == names.val) {\n-                                if (sym.isReferenceFavoringPrimitiveClass()) {\n-                                    owntype = new ClassType(ownOuter, owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.Q_TypeOf_L);\n-                                } else {\n-                                    \/\/ We should already be good to go with owntype\n-                                }\n-                            }\n-                        }\n+                    if (owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n+                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n@@ -5406,1 +5378,1 @@\n-            if (c.isPrimitiveClass()) {\n+            if (types.isPrimitiveClass(c.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":17,"deletions":45,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -808,6 +808,3 @@\n-                JCExpression instantiation = expr;\n-                if (instantiation.hasTag(TYPEAPPLY))\n-                    instantiation = ((JCTypeApply) instantiation).clazz;\n-                if (instantiation.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) instantiation;\n-                    if (fieldAccess.selected.type.tsym.isPrimitiveClass() &&\n+                if (expr.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n+                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n@@ -874,1 +871,1 @@\n-        if (t.isPrimitive() || t.tsym.isPrimitiveClass())\n+        if (t.isPrimitive() || t.isPrimitiveClass() || t.isReferenceProjection())\n@@ -1375,1 +1372,1 @@\n-                if (sym.owner.isPrimitiveClass() && (flags & STATIC) == 0) {\n+                if (types.isPrimitiveClass(sym.owner.type) && (flags & STATIC) == 0) {\n@@ -1687,1 +1684,1 @@\n-                    (!tree.type.tsym.isPrimitiveClass() || (tree.name != names.ref && tree.name != names.val))) {\n+                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n@@ -1691,5 +1688,2 @@\n-\n-                \/\/ Tolerate the pseudo-select V.ref\/V.val: V<T>.ref\/val will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type. Both\n-                \/\/ these constructs are illegal anyway & will be more appropriately complained against shortly.\n-                \/\/ Note: the canonicl form is V.ref<T> and V.val<T> not V<T>.ref and V<T>.val\n+                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n+                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -2759,1 +2753,1 @@\n-        if (c.tsym.isPrimitiveClass() && implementsIdentityObject) {\n+        if (c.isPrimitiveClass() && implementsIdentityObject) {\n@@ -2761,1 +2755,1 @@\n-        } else if (implementsPrimitiveObject && !c.tsym.isPrimitiveClass() && !c.isReferenceProjection() && !c.tsym.isInterface() && !c.tsym.isAbstract()) {\n+        } else if (implementsPrimitiveObject && !c.isPrimitiveClass() && !c.isReferenceProjection() && !c.tsym.isInterface() && !c.tsym.isAbstract()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-        ct.flavor = ct.flavor.metamorphose(c.flags_field);\n+        ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2205,1 +2205,1 @@\n-                        if (tree.sym.owner.isPrimitiveClass())\n+                        if (types.isPrimitiveClass(tree.sym.owner.type))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2281,1 +2281,1 @@\n-                return tree.getQualifierExpression().type.isPrimitiveReferenceType();\n+                return tree.getQualifierExpression().type.isReferenceProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1139,2 +1139,0 @@\n-                boolean requireValueProjection =\n-                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.val && tree.type.isValueProjection();\n@@ -1158,2 +1156,0 @@\n-                    } else if (requireValueProjection) {\n-                        tree.setType(tree.type.asValueType());\n@@ -1166,2 +1162,0 @@\n-                    } else if (requireValueProjection) {\n-                        tree.setType(tree.type.asValueType());\n@@ -2529,2 +2523,1 @@\n-            Type receiverType = tree.sym.type.isPrimitiveReferenceType() ? tree.sym.type.asValueType() : tree.sym.type;\n-            VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, receiverType, tree.sym);\n+            VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, tree.sym.type, tree.sym);\n@@ -2614,1 +2607,0 @@\n-        Type receiverType = tree.sym.type.isPrimitiveReferenceType() ? tree.sym.type.asValueType() : tree.sym.type;\n@@ -2616,1 +2608,1 @@\n-                isStatic ? List.nil() : indyType.argtypes.prepend(receiverType),\n+                isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),\n@@ -4113,1 +4105,1 @@\n-        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isPrimitiveReferenceType();\n+        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-            if ((v.flags_field & FINAL) != 0 && ((v.flags_field & STATIC) != 0 || !v.owner.isPrimitiveClass()) &&\n+            if ((v.flags_field & FINAL) != 0 && ((v.flags_field & STATIC) != 0 || !types.isPrimitiveClass(v.owner.type)) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-                site = site.asValueType();\n+                site = site.valueProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1279,13 +1279,0 @@\n-            new AttributeReader(names.JavaFlags, V61, CLASS_ATTRIBUTE) {\n-                @Override\n-                protected boolean accepts(AttributeKind kind) {\n-                    return super.accepts(kind) && allowPrimitiveClasses;\n-                }\n-                protected void read(Symbol sym, int attrLen) {\n-                    if (sym.kind == TYP) {\n-                        int extendedFlags = nextChar();\n-                        if ((extendedFlags & ACC_REF_DEFAULT) != 0)\n-                        ((ClassSymbol)sym).flags_field |= REFERENCE_FAVORING;\n-                    }\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -355,6 +355,0 @@\n-        if ((flags & REFERENCE_FAVORING) != 0) {\n-            int alenIdx = writeAttr(names.JavaFlags);\n-            databuf.appendChar(ACC_REF_DEFAULT);\n-            endAttr(alenIdx);\n-            acount++;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-                Type selfType = meth.owner.isPrimitiveClass() ? meth.owner.type.asValueType() : meth.owner.type;\n+                Type selfType = meth.owner.type;\n@@ -2289,1 +2289,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.asValueType(), tree.expr.type) || true) &&\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-        if (t.tsym.isPrimitiveClass())\n-            t = t.asValueType();\n+        if (t.isReferenceProjection())\n+            t = t.valueProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -193,4 +192,1 @@\n-                ClassType productType = (ClassType) currentClass.sym.erasure(types);\n-                if (currentClass.sym.isReferenceFavoringPrimitiveClass())\n-                    productType = new ClassType(productType.getEnclosingType(), List.nil(), productType.tsym, productType.getMetadata(), Flavor.Q_TypeOf_L);\n-                VarSymbol product = currentMethod.factoryProduct = new VarSymbol(0, names.dollarValue, productType, currentMethod.sym); \/\/ TODO: owner needs rewiring\n+                VarSymbol product = currentMethod.factoryProduct = new VarSymbol(0, names.dollarValue, currentClass.sym.type, currentMethod.sym); \/\/ TODO: owner needs rewiring\n@@ -204,1 +200,1 @@\n-                    final JCExpression type = make.Type(productType);\n+                    final JCExpression type = make.Type(currentClass.type);\n@@ -206,1 +202,1 @@\n-                    rhs.type = productType;\n+                    rhs.type = currentClass.type;\n@@ -339,1 +335,1 @@\n-                            fieldAccess.selected = make.Type(types.erasure(selectedType.asValueType()));\n+                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n@@ -343,1 +339,1 @@\n-                        fieldAccess.selected = make.Type(types.erasure(selectedType.asValueType()));\n+                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n@@ -354,1 +350,1 @@\n-        if (tree.clazz.type.tsym.isPrimitiveClass()) {\n+        if (types.isPrimitiveClass(tree.clazz.type)) {\n@@ -387,1 +383,1 @@\n-        Assert.check(init.owner.isPrimitiveClass());\n+        Assert.check(types.isPrimitiveClass(init.owner.type));\n@@ -393,1 +389,1 @@\n-                                                init.owner.type.asValueType(),\n+                                                init.owner.type,\n@@ -403,1 +399,1 @@\n-                init.owner.type.asValueType(),\n+                init.owner.type,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransPrimitiveClass.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2374,1 +2374,1 @@\n-                long badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~(Flags.FINAL | Flags.REFERENCE_FAVORING) : mods.flags;\n+                long badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~Flags.FINAL : mods.flags;\n@@ -2445,1 +2445,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.FINAL | Flags.REFERENCE_FAVORING);\n+            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.FINAL);\n@@ -2454,1 +2454,1 @@\n-                badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~(Flags.FINAL | Flags.REFERENCE_FAVORING) : mods.flags;\n+                badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~Flags.FINAL : mods.flags;\n@@ -4020,10 +4020,0 @@\n-        if ((mods.flags & Flags.PRIMITIVE_CLASS) != 0) {\n-            if (token.kind == DOT) {\n-                final Token pastDot = S.token(1);\n-                if (pastDot.kind == IDENTIFIER && pastDot.name() == names.val) {\n-                    nextToken(); nextToken(); \/\/ discard .val\n-                    mods.flags |= Flags.REFERENCE_FAVORING;\n-                }\n-            }\n-        }\n-\n@@ -4055,9 +4045,0 @@\n-        if ((mods.flags & Flags.PRIMITIVE_CLASS) != 0) {\n-            if (token.kind == DOT) {\n-                final Token pastDot = S.token(1);\n-                if (pastDot.kind == IDENTIFIER && pastDot.name() == names.val) {\n-                    nextToken(); nextToken(); \/\/ discard .val\n-                    mods.flags |= Flags.REFERENCE_FAVORING;\n-                }\n-            }\n-        }\n@@ -4499,1 +4480,0 @@\n-             peekToken(TokenKind.IDENTIFIER, TokenKind.DOT) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -856,1 +856,1 @@\n-                    JCExpression vp = Type(t.asValueType());\n+                    JCExpression vp = Type(t.valueProjection());\n@@ -867,13 +867,0 @@\n-                } else if (t.isValueProjection()) {\n-                    \/\/ For parameterized types, we want V.val<A1 ... An> not V<A1 ... An>.val\n-                    JCExpression vp = Type(t.referenceProjection());\n-                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n-                        \/\/ vp now is V<A1 ... An>, build V.val<A1 ... An>\n-                        JCFieldAccess f = (JCFieldAccess) Select(((JCTypeApply) vp).clazz, t.tsym);\n-                        f.name = names.val;\n-                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n-                    } else {\n-                        JCFieldAccess f = (JCFieldAccess) Select(vp, t.tsym);\n-                        f.name = names.val;\n-                        tp = f;\n-                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-    public final Name JavaFlags;\n@@ -343,1 +342,0 @@\n-        JavaFlags = fromString(\"JavaFlags\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    public static final int ACC_REF_DEFAULT   = 0x0001; \/\/ javac extra\n@@ -64,1 +63,1 @@\n-    public static enum Kind { Class, InnerClass, Field, Method, JavacExtra}\n+    public static enum Kind { Class, InnerClass, Field, Method}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    public static final String JavaFlags                = \"JavaFlags\";\n@@ -128,1 +127,0 @@\n-            standardAttributes.put(JavaFlags,         JavaFlags_attribute.class);\n@@ -196,1 +194,0 @@\n-        R visitJavaFlags(JavaFlags_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -477,6 +477,0 @@\n-        @Override\n-        public Void visitJavaFlags(JavaFlags_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.extendedFlags);\n-            return null;\n-        }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-public class JavaFlags_attribute extends Attribute {\n-\n-    JavaFlags_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        extendedFlags = cr.readUnsignedShort();\n-    }\n-\n-    public int getExtendedFlags() {\n-        return extendedFlags;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitJavaFlags(this, data);\n-    }\n-\n-    public final int extendedFlags;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/JavaFlags_attribute.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -51,1 +51,0 @@\n-import com.sun.tools.classfile.JavaFlags_attribute;\n@@ -358,10 +357,0 @@\n-    @Override\n-    public Void visitJavaFlags(JavaFlags_attribute attr, Void unused) {\n-        println(\"Extended Flags:\");\n-        indent(+1);\n-        if ((attr.extendedFlags & ACC_REF_DEFAULT) != 0)\n-            println(\"ACC_REF_DEFAULT\");\n-        indent(-1);\n-        return null;\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1374,5 +1374,0 @@\n-\n-        @Override\n-        public Void visitJavaFlags(JavaFlags_attribute attr, T p) {\n-            return null;\n-        }\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    public R visitJavaFlags(JavaFlags_attribute attr, P p) { return null; }\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222634\n- * @summary Check array creation with V and V.ref\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile ArrayCreationWithQuestion.java\n- * @run main\/othervm -Xverify:none ArrayCreationWithQuestion\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class ArrayCreationWithQuestion {\n-\n-    static primitive class VT.val {\n-        VT[] a1 = new VT[42];\n-        VT[] a2 = new VT[42];\n-        VT.val[] a3 = new VT.val[42];\n-        VT.val[] a4 = new VT.val[42];\n-    }\n-\n-    public static void main(String[] args) {\n-        new ArrayCreationWithQuestion().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"ArrayCreationWithQuestion$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-        \"         6: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n-        \"        17: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n-        \"        28: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-        \"        39: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ArrayCreationWithQuestion.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222402\n- * @summary LW2 array support in javac\n- * @run main\/othervm ArrayRelationsTest\n- *\/\n-\n-public primitive class ArrayRelationsTest.val {\n-\n-    int x = 42;\n-\n-    public static void main(String [] args) {\n-        ArrayRelationsTest [] la = new ArrayRelationsTest[10];\n-        ArrayRelationsTest.val [] qa = new ArrayRelationsTest.val[10];\n-        boolean cce = false;\n-        try {\n-            qa = (ArrayRelationsTest.val[]) (Object []) (new String [10]);\n-        } catch (ClassCastException e) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Missing CCE\");\n-        }\n-        la = qa;\n-        ArrayRelationsTest.ref[] la2 = qa;\n-        ArrayRelationsTest.val [] qa2 = (ArrayRelationsTest.val []) la2;\n-        boolean npe = false;\n-        try {\n-            la2[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-        }\n-        npe = false;\n-        Object [] oa = qa;\n-        try {\n-            oa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-        }\n-\n-        \/\/ round trip;\n-        Object o = oa = la = qa;\n-        qa = (ArrayRelationsTest.val[]) (la = (ArrayRelationsTest.ref []) (oa = (Object []) o));\n-        qa [0] = new ArrayRelationsTest();\n-\n-        npe = false;\n-        try {\n-            la[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-        }\n-\n-        la = new ArrayRelationsTest.ref [10];\n-\n-        cce = false;\n-        try {\n-            qa = (ArrayRelationsTest.val[]) la;\n-        } catch (ClassCastException c) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Unexpected CCE behavior\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ArrayRelationsTest.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8214421 8221545 8222792\n- * @summary Q<->L mixing should be OK for upcasts and should use checkcasts for downcasts.\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile BoxValCastTest.java\n- * @run main\/othervm -Xverify:none BoxValCastTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class BoxValCastTest {\n-\n-    static primitive class VT.val {\n-        int f = 0;\n-        static final VT vtbox = (VT) new VT(); \/\/ no binary cast\n-        static VT.val vt = (VT.val) vtbox; \/\/ binary cast\n-        static VT box = vt; \/\/ no binary cast\n-        static VT box2 = (VT.val) box; \/\/ binary cast\n-        static VT box3 = id(new VT()); \/\/ no binary cast + no binary cast\n-\n-        static VT.val id(VT vtb) {\n-            return (VT.val) vtb; \/\/ binary\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new BoxValCastTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"BoxValCastTest$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \"checkcast     #7                  \/\/ class \\\"QBoxValCastTest$VT;\\\"\"\n-\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-         int errors = 0;\n-         for (String eo: expectedOut) {\n-             if (!out.contains(eo)) {\n-                 System.err.println(\"Match not found for string: \" + eo);\n-                 errors++;\n-             }\n-         }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-        String [] splits = out.split(\"checkcast     #7\", -1);\n-        if (splits.length != 4) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-        splits = out.split(\"checkcast\", -1);\n-        if (splits.length != 9) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/BoxValCastTest.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8215110\n- * @summary Check that casting to a value type involves a null check.\n- *\n- * @compile -XDallowWithFieldOperator Point.java\n- * @compile -XDallowWithFieldOperator CastNullCheckTest.java\n- * @run main\/othervm CastNullCheckTest\n- *\/\n-\n-public class CastNullCheckTest {\n-\n-    final primitive class XX.val {\n-        final int x = 10;\n-    }\n-\n-    public static void main(String... args) {\n-        int caught = 0;\n-\n-        Object o = null;\n-        try {\n-            XX.val x = (XX.val) o;\n-        } catch (NullPointerException npe) {\n-            caught++;\n-        }\n-\n-        try {\n-            Point.val p = (Point.val) o;\n-        } catch (NullPointerException npe) {\n-            caught++;\n-        }\n-\n-        o = Point.val.default;\n-        try {\n-            Point.val p = (Point.val) o;\n-        } catch (NullPointerException npe) {\n-            caught++;\n-        }\n-        if (caught != 2)\n-            throw new AssertionError(\"Wrong NPE count: \" + caught);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CastNullCheckTest.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,20 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Value types may not declare fields of its own type either directly or indirectly.\n- *\n- * @compile\/fail\/ref=CheckCyclicMembership.out -XDrawDiagnostics CheckCyclicMembership.java\n- *\/\n-\n-final primitive class CheckCyclicMembership.val {\n-    class InnerRef {\n-        CheckCyclicMembership.val ccm;\n-    }\n-    primitive final class InnerValue.val {\n-        final CheckCyclicMembership.val ccm = CheckCyclicMembership.val.default; \/\/ Error.\n-    }\n-    final CheckCyclicMembership.val ccm = CheckCyclicMembership.val.default; \/\/ Error.\n-    final int i = 10;\n-    final String s = \"blah\";\n-    final InnerRef ir = new InnerRef(); \/\/ OK.\n-    final InnerValue.val iv = InnerValue.val.default; \/\/ Error\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckCyclicMembership.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-CheckCyclicMembership.java:13:41: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership.InnerValue\n-CheckCyclicMembership.java:15:37: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n-CheckCyclicMembership.java:19:26: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckCyclicMembership.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222634\n- * @summary Check field descriptors in class file\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @run main\/othervm CheckFieldDescriptors\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-public primitive class CheckFieldDescriptors.val {\n-\n-    int x = 10;\n-\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(CheckFieldDescriptors.class.getResourceAsStream(\"CheckFieldDescriptorsAuxilliary.class\"));\n-\n-        Field [] flds = cls.fields;\n-        int fCount = 0;\n-        for (Field fld : flds) {\n-            if (fld.getName(cls.constant_pool).equals(\"f1\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"QCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field1\");\n-            } else if (fld.getName(cls.constant_pool).equals(\"f2\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field2\");\n-            } else if (fld.getName(cls.constant_pool).equals(\"f3\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field3\");\n-            } else if (fld.getName(cls.constant_pool).equals(\"a1\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field4\");\n-            } else if (fld.getName(cls.constant_pool).equals(\"a2\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field5\");\n-            } else if (fld.getName(cls.constant_pool).equals(\"a3\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[QCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field6\");\n-            } else if (fld.getName(cls.constant_pool).equals(\"a4\")) {\n-                fCount++;\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[QCheckFieldDescriptors;\"))\n-                    throw new Exception(\"Bad descriptor for field7\");\n-            }\n-        }\n-        if (fCount != 7) {\n-            throw new Exception(\"Bad descriptor for field3\");\n-        }\n-    }\n-}\n-\n-class CheckFieldDescriptorsAuxilliary {\n-\n-    CheckFieldDescriptors.val f1;\n-    CheckFieldDescriptors f2;\n-    CheckFieldDescriptors f3;\n-\n-    CheckFieldDescriptors[] a1 = new CheckFieldDescriptors[42];\n-    CheckFieldDescriptors[] a2 = new CheckFieldDescriptors[42];\n-    CheckFieldDescriptors.val[] a3 = new CheckFieldDescriptors.val[42];\n-    CheckFieldDescriptors.val[] a4 = new CheckFieldDescriptors.val[42];\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckFieldDescriptors.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,20 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check for cycles through fields declared flattenable.\n- *\n- * @compile\/fail\/ref=CheckFlattenableCycles.out -XDrawDiagnostics CheckFlattenableCycles.java\n- *\/\n-\n-final primitive class CheckFlattenableCycles.val {\n-    class InnerRef {\n-        CheckFlattenableCycles.val cfc;\n-    }\n-    primitive final class InnerValue.val {\n-        final CheckFlattenableCycles.val     cfc = CheckFlattenableCycles.val.default; \/\/ Error.\n-    }\n-    final CheckFlattenableCycles.val cfc = CheckFlattenableCycles.val.default; \/\/ Error.\n-    final int i = 10;\n-    final String s = \"blah\";\n-    final InnerRef ir = new InnerRef(); \/\/ OK.\n-    final InnerValue.val     iv = InnerValue.val.default; \/\/ Error\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckFlattenableCycles.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-CheckFlattenableCycles.java:13:46: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles.InnerValue\n-CheckFlattenableCycles.java:15:38: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n-CheckFlattenableCycles.java:19:30: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckFlattenableCycles.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8197911\n- * @summary Check that valueness is deduced from class files and has the appropriate effect.\n- * @compile FlattenableFlagFromClass.java\n- * @compile\/fail\/ref=CheckFlattenableFlagFromClass.out -XDrawDiagnostics CheckFlattenableFlagFromClass.java\n- *\/\n-\n-public class CheckFlattenableFlagFromClass {\n-    void foo(FlattenableFlagFromClass f) {\n-        f.v = null; \/\/ Error.\n-        f.va[0] = null; \/\/ Error.\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckFlattenableFlagFromClass.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-CheckFlattenableFlagFromClass.java:11:15: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableFlagFromClass.V.val)\n-CheckFlattenableFlagFromClass.java:12:19: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableFlagFromClass.V.val)\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckFlattenableFlagFromClass.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check null store into multidimensional array\n- * @compile\/fail\/ref=CheckMultiDimensionalArrayStore.out -XDrawDiagnostics -XDdev CheckMultiDimensionalArrayStore.java\n- *\/\n-\n-public class CheckMultiDimensionalArrayStore {\n-\n-    primitive final class V {\n-\n-        class Y { \/\/ null usage inside class Y are NOT problematic.\n-            V.ref [][][] va = new V.ref[][][] {{{ null }}};\n-            V.ref [][] va2 =  {{ null }};\n-            void foo() {\n-                va = new V.ref[][][] {{{ null }}};\n-                va[0][0][0] = null;\n-            }\n-        }\n-\n-        class Z { \/\/ null usage inside class Z ARE ALL problematic.\n-            V [][][] va = new V[][][] {{{ null }}};\n-            V [][] va2 =  {{ null }};\n-            void foo() {\n-                va = new V[][][] {{{ null }}};\n-                va[0][0][0] = null;\n-            }\n-        }\n-    }\n-\n-    primitive final class R.val {\n-\n-        class Y { \/\/ null usage inside class Y NOT problematic.\n-            R [][][] va = new R[][][] {{{ null }}};\n-            R [][] va2 =  {{ null }};\n-            void foo() {\n-                va = new R[][][] {{{ null }}};\n-                va[0][0][0] = null;\n-            }\n-        }\n-\n-        class Z { \/\/ null usage inside class Z ARE ALL problematic.\n-            R.val [][][] va = new R.val[][][] {{{ null }}};\n-            R.val [][] va2 =  {{ null }};\n-            void foo() {\n-                va = new R.val[][][] {{{ null }}};\n-                va[0][0][0] = null;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckMultiDimensionalArrayStore.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-CheckMultiDimensionalArrayStore.java:21:43: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:22:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:24:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:25:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:42:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.R.val)\n-CheckMultiDimensionalArrayStore.java:43:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.R.val)\n-CheckMultiDimensionalArrayStore.java:45:42: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.R.val)\n-CheckMultiDimensionalArrayStore.java:46:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.R.val)\n-8 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckMultiDimensionalArrayStore.out","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,17 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Assignment of null to value types should be disallowed.\n- *\n- * @compile\/fail\/ref=CheckNullAssign.out -XDrawDiagnostics CheckNullAssign.java\n- *\/\n-\n-final primitive class CheckNullAssign.val {\n-    CheckNullAssign.val foo(CheckNullAssign.val cna) {\n-        \/\/ All of the below involve subtype\/assignability checks and should be rejected.\n-        cna = null;\n-        foo(null);\n-        if (null instanceof CheckNullAssign.val) {}\n-        return null;\n-    }\n-    boolean b = null instanceof CheckNullAssign; \/\/ OK.\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckNullAssign.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-CheckNullAssign.java:11:15: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullAssign.val)\n-CheckNullAssign.java:12:9: compiler.err.cant.apply.symbol: kindname.method, foo, CheckNullAssign.val, compiler.misc.type.null, kindname.class, CheckNullAssign, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullAssign.val))\n-CheckNullAssign.java:13:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullAssign.val)\n-CheckNullAssign.java:14:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullAssign.val)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckNullAssign.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary null cannot be casted to and compared with value types.\n- *\n- * @compile\/fail\/ref=CheckNullCastable.out -XDrawDiagnostics CheckNullCastable.java\n- *\/\n-\n-primitive final class CheckNullCastable.val {\n-    void foo(CheckNullCastable.val cnc) {\n-        CheckNullCastable.val cncl = (CheckNullCastable.val) null;\n-        if (cnc != null) {};\n-        if (null != cnc) {};\n-    }\n-    int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckNullCastable.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-CheckNullCastable.java:10:62: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullCastable.val)\n-CheckNullCastable.java:11:17: compiler.err.incomparable.types: CheckNullCastable.val, compiler.misc.type.null\n-CheckNullCastable.java:12:18: compiler.err.incomparable.types: compiler.misc.type.null, CheckNullCastable.val\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckNullCastable.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8222790\n- * @summary javac diagnostics don't discriminate between inline types and there nullable projection types.\n- *\n- * @compile\/fail\/ref=CheckQuestionInMessages.out -XDrawDiagnostics CheckQuestionInMessages.java\n- *\/\n-\n-import java.util.List;\n-\n-primitive class X.val {\n-    List<X.ref> ls = new Object() {};\n-    X.ref[] xa = new Object[10];  \/\/ no support for Object.ref yet, but they are the same.\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckQuestionInMessages.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-CheckQuestionInMessages.java:12:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.anonymous.class: java.lang.Object, java.util.List<X>)\n-CheckQuestionInMessages.java:13:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X[])\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckQuestionInMessages.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Check separate compilation\n- * @compile CheckSeparateCompile0.java\n- * @compile CheckSeparateCompile.java\n- * @run main\/othervm -XX:+EnableValhalla CheckSeparateCompile\n- *\/\n-\n-public class CheckSeparateCompile {\n-    public static void main(String[] args) {\n-        if (new CheckSeparateCompile0().new O().new M().new I().foo().i != 890)\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckSeparateCompile.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @summary Test seperate compilation\n- *\/\n-\n-public class CheckSeparateCompile0 {\n-    int x = 123;\n-    public class O {\n-        int o = 456;\n-        public class M {\n-            int m = 789;\n-            public primitive class I {\n-                int i = 890;\n-                I() {\n-\n-                }\n-                I foo() {\n-                    return this;\n-                }\n-            }\n-            public String toString() {\n-                return \"o = \" + o + \" m = \" + m + \" x = \" + x;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckSeparateCompile0.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check behavior of synzhronized key word on primitive class instances and methods.\n- *\n- * @compile\/fail\/ref=CheckSynchronized.out -XDrawDiagnostics CheckSynchronized.java\n- *\/\n-\n-primitive final class CheckSynchronized.val implements java.io.Serializable {\n-    synchronized void foo() { \/\/ <<-- ERROR, no monitor associated with `this'\n-    }\n-    void goo() {\n-        synchronized(this) {} \/\/ <<-- ERROR, no monitor associated with `this'\n-    }\n-    synchronized static void zoo(CheckSynchronized.val cs) { \/\/ OK, static method.\n-        synchronized(cs) {    \/\/ <<-- ERROR, no monitor associated with primitive class instance.\n-        }\n-\n-        CheckSynchronized.ref csr = cs;\n-        synchronized(csr) {\n-            \/\/ Error, no identity.\n-        }\n-\n-        synchronized(x) {\n-            \/\/ Error, no identity.\n-        }\n-\n-        Object o = cs;\n-        synchronized(o) {\n-            \/\/ Error BUT not discernible at compile time\n-        }\n-        java.io.Serializable jis = cs;\n-        synchronized(jis) {\n-            \/\/ Error BUT not discernible at compile time\n-        }\n-    }\n-    static int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckSynchronized.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-CheckSynchronized.java:9:23: compiler.err.mod.not.allowed.here: synchronized\n-CheckSynchronized.java:12:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n-CheckSynchronized.java:15:9: compiler.err.type.found.req: CheckSynchronized.val, (compiler.misc.type.req.identity)\n-CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n-CheckSynchronized.java:23:9: compiler.err.type.found.req: int, (compiler.misc.type.req.identity)\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/CheckSynchronized.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244796 8244799\n- * @summary Value class literal tests\n- * @compile\/fail\/ref=ClassLiteralNegativeTest.out -XDrawDiagnostics ClassLiteralNegativeTest.java\n- *\/\n-\n-final primitive class ClassLiteralNegativeTest.val {\n-    Class<ClassLiteralNegativeTest.val> c1 = null; \/\/ error\n-    Class<? extends ClassLiteralNegativeTest.val> c2 = null; \/\/ error\n-    Class<? super ClassLiteralNegativeTest.val> c3 = null; \/\/ error\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ClassLiteralNegativeTest.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-ClassLiteralNegativeTest.java:9:35: compiler.err.type.found.req: ClassLiteralNegativeTest.val, (compiler.misc.type.req.ref)\n-ClassLiteralNegativeTest.java:10:11: compiler.err.type.found.req: ClassLiteralNegativeTest.val, (compiler.misc.type.req.ref)\n-ClassLiteralNegativeTest.java:11:11: compiler.err.type.found.req: ClassLiteralNegativeTest.val, (compiler.misc.type.req.ref)\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ClassLiteralNegativeTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8221323\n- * @summary  Javac should support class literals for projection types.\n- * @compile\/fail\/ref=ClassLiteralTypingNegativeTest.out -XDrawDiagnostics ClassLiteralTypingNegativeTest.java\n- *\/\n-\n-public class ClassLiteralTypingNegativeTest {\n-\n-    public static primitive class Foo.val {\n-        final int value = 0;\n-\n-        public static void main(String[] args) {\n-            Class<? extends Foo> cFooRef = Foo.val.class; \/\/ Error\n-            cFooRef = ((Foo.val) new Foo()).getClass(); \/\/ OK\n-            cFooRef = Foo.class; \/\/ OK.\n-            cFooRef = Foo.val.class; \/\/ Error.\n-            Foo.val xv = new Foo();\n-            cFooRef = xv.getClass(); \/\/ OK\n-            Foo xr = new Foo();\n-            cFooRef = xr.getClass(); \/\/ OK.\n-        }\n-    }\n-\n-    interface I {}\n-\n-    public static primitive class Bar.val implements I {\n-        final int value = 0;\n-\n-        public static void main(String[] args) {\n-            Class<? extends Bar> cBarRef = Bar.val.class; \/\/ Error\n-            cBarRef = ((Bar.val) new Bar()).getClass(); \/\/ OK\n-            cBarRef = Bar.class; \/\/ OK.\n-            cBarRef = Bar.val.class; \/\/ Error.\n-            Bar.val xv = new Bar();\n-            cBarRef = xv.getClass(); \/\/ OK.\n-            Bar xr = new Bar();\n-            cBarRef = xr.getClass(); \/\/ OK.\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ClassLiteralTypingNegativeTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ClassLiteralTypingNegativeTest.java:14:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo>)\n-ClassLiteralTypingNegativeTest.java:17:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo>)\n-ClassLiteralTypingNegativeTest.java:31:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar>)\n-ClassLiteralTypingNegativeTest.java:34:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar>)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ClassLiteralTypingNegativeTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244513\n- * @summary Test conditional expression typing involving inlines.\n- * @compile\/fail\/ref=ConditionalTypeTest.out -XDrawDiagnostics ConditionalTypeTest.java\n- *\/\n-\n-final class ConditionalTypeTest {\n-    interface I {}\n-    static primitive class Node.val implements I {}\n-    static void foo(int i) {\n-        var ret1 = (i == 0) ? new XNodeWrapper() : new Node();\n-        ret1 = \"String cannot be assigned to I\";\n-        var ret2 = (i == 0) ? 10 : new XNodeWrapper();\n-        ret2 = \"String can be assigned to I\";\n-        var ret3 = (i == 0) ? new XNodeWrapper() : 10;\n-        ret3 = \"String can be assigned to Object\";\n-        var ret4 = (i == 0) ? new XNodeWrapper() : new ConditionalTypeTest();\n-        ret4 = \"String can be assigned to Object\";\n-        var ret5 = (i == 0) ? Integer.valueOf(10) : new ConditionalTypeTest();\n-        ret5 = \"String can be assigned to Object\";\n-\n-        var ret6 = (i == 0) ? new Node() : new Node();\n-        ret6 = \"String cannot be assigned to Node.val\";\n-\n-        var ret7 = (i == 0) ? (Node.ref) new Node() : (Node.ref) null;\n-        ret7 = \"String cannot be assigned to Node.ref\";\n-\n-        var ret8 = (i == 0) ? new Node() : (Node.ref) null;\n-        ret8 = \"String cannot be assigned to Node.val\";\n-\n-        var ret9 = (i == 0) ? (Node.ref) new Node() : new Node();\n-        ret9 = \"String cannot be assigned to Node.val\";\n-    }\n-    static primitive class XNodeWrapper.val implements I {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ConditionalTypeTest.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-ConditionalTypeTest.java:13:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.I)\n-ConditionalTypeTest.java:24:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node.val)\n-ConditionalTypeTest.java:27:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node)\n-ConditionalTypeTest.java:30:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node.val)\n-ConditionalTypeTest.java:33:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node.val)\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ConditionalTypeTest.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8266466\n- * @summary Enhance javac to consume unified primitive class files\n- * @compile -XDallowWithFieldOperator Point.java Rectangle.java\n- * @compile\/fail\/ref=ConsumeUnifiedClass.out -XDrawDiagnostics ConsumeUnifiedClass.java\n- *\/\n-\n-public primitive class ConsumeUnifiedClass {\n-    public static void main(String [] args) {\n-        Rectangle r = new Rectangle(null, null); \/\/ Check method type decoding, should error\n-        r = Rectangle.from(null, null); \/\/ OK.\n-        Rectangle.origin = null; \/\/ Check field type decoding, should error\n-        Rectangle.origin = Point.makePoint(0, 0); \/\/ OK\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ConsumeUnifiedClass.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-ConsumeUnifiedClass.java:36:23: compiler.err.cant.apply.symbol: kindname.constructor, Rectangle, Point.val,Point.val, compiler.misc.type.null,compiler.misc.type.null, kindname.class, Rectangle, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point.val))\n-ConsumeUnifiedClass.java:38:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point.val)\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ConsumeUnifiedClass.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test Check default values for non-inline types\n- * @bug 8237067\n- * @summary [lworld] Provide linguistic support to denote default values.\n- * @run main\/othervm -Dtest.compiler.opts=-release=13 DefaultNonInlines\n- *\/\n-\n-public class DefaultNonInlines {\n-\n-    static primitive class Val.val {\n-        public int v = 42;\n-    }\n-\n-    static <T> void checkDefaultT(Class<T> clazz) throws Exception {\n-        while (T.default != null)\n-            throw new AssertionError(\"Generic object should default to null\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Default value is set by inline class constructor\n-        while (Val.val.default.v != int.default)\n-            throw new AssertionError(\"inline object fields should default to defaults\");\n-\n-        while ((new Val()).v != 42)\n-            throw new AssertionError(\"inline object fields should default to whatever constructor says\");\n-\n-        \/\/ Simple reference default is just null\n-        while (String.default != null)\n-            throw new AssertionError(\"reference object should default to null\");\n-\n-        \/\/ Reference default checked in method above\n-        checkDefaultT(String.class);\n-\n-        \/\/ Array type - different syntactically\n-        while (int[].default != null)\n-            throw new AssertionError(\"arrays should default to null\");\n-\n-        while (boolean.default != false)\n-            throw new AssertionError(\"boolean should default to false\");\n-\n-        while (char.default != '\\0')\n-            throw new AssertionError(\"char should default to '\\0'\");\n-\n-        while (int.default != 0)\n-            throw new AssertionError(\"int should default to 0\");\n-\n-        while (byte.default != 0)\n-            throw new AssertionError(\"byte should default to 0\");\n-\n-        while (short.default != 0)\n-            throw new AssertionError(\"short should default to 0\");\n-\n-        while (long.default != 0L)\n-            throw new AssertionError(\"long should default to 0L\");\n-\n-        while (float.default != 0.0F)\n-            throw new AssertionError(\"float should default to 0.0F\");\n-\n-        while (double.default != 0.0D)\n-            throw new AssertionError(\"double should default to 0.0D\");\n-\n-        \/\/ Note: The while loops above implicitly test that the SomeType.default does not\n-        \/\/ return a constant expression.\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/DefaultNonInlines.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8229537\n- * @summary [lworld] Poor interaction between explicit lambda parameters and nullable projection types.\n- * @compile -XDallowWithFieldOperator ExplicitLambdaWithNullableTypes.java\n- * @run main\/othervm ExplicitLambdaWithNullableTypes\n- *\/\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.function.*;\n-import java.util.NoSuchElementException;\n-\n-primitive class OptionalInt.val {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n-\n-    private boolean isPresent = false;\n-    private int v = 0;\n-\n-    public static OptionalInt.val empty() {\n-        return OptionalInt.val.default;\n-    }\n-\n-    public static OptionalInt.val of(int val) {\n-        OptionalInt.val self = OptionalInt.val.default;\n-        self = __WithField(self.v, val);\n-        self = __WithField(self.isPresent, true);\n-        return self;\n-    }\n-\n-    public int getAsInt() {\n-        if (!isPresent)\n-            throw new NoSuchElementException(\"No value present\");\n-\n-        return v;\n-    }\n-\n-    public boolean isPresent() {\n-        return isPresent;\n-    }\n-\n-    public void ifPresent(IntConsumer consumer) {\n-        if (isPresent)\n-            consumer.accept(v);\n-    }\n-\n-    public int orElse(int other) {\n-        return isPresent ? v : other;\n-    }\n-}\n-\n-public final class ExplicitLambdaWithNullableTypes {\n-\n-   public static void main(String[] args) {\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n-       for (int i=0; i < 5; i++) {\n-           opts.add(OptionalInt.of(i));\n-           opts.add(OptionalInt.empty());\n-           opts.add(null);\n-       }\n-\n-       Integer total = opts.stream()\n-           .map((OptionalInt.ref o) -> {\n-               if (o == null)\n-                   return 0;\n-\n-               OptionalInt.val op = (OptionalInt.val)o;\n-               return op.orElse(0);\n-           })\n-           .reduce(0, (x, y) -> x + y);\n-\n-        if (total != 10) {\n-            throw new AssertionError(\"Incorrect output: \" + total);\n-        }\n-   }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ExplicitLambdaWithNullableTypes.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8229537\n- * @summary [lworld] Poor interaction between explicit lambda parameters and nullable projection types.\n- * @compile -XDallowWithFieldOperator ExplicitLambdaWithNullableTypes2.java\n- * @run main\/othervm ExplicitLambdaWithNullableTypes2\n- *\/\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.function.*;\n-import java.util.NoSuchElementException;\n-import java.util.stream.*;\n-\n-primitive class OptionalInt.val {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n-\n-    private boolean isPresent = false;\n-    private int v = 0;\n-\n-    public static OptionalInt.val empty() {\n-        return OptionalInt.val.default;\n-    }\n-\n-    public static OptionalInt.val of(int val) {\n-        OptionalInt.val self = OptionalInt.val.default;\n-        self = __WithField(self.v, val);\n-        self = __WithField(self.isPresent, true);\n-        return self;\n-    }\n-\n-    public int getAsInt() {\n-        if (!isPresent)\n-            throw new NoSuchElementException(\"No value present\");\n-\n-        return v;\n-    }\n-\n-    public boolean isPresent() {\n-        return isPresent;\n-    }\n-\n-    public void ifPresent(IntConsumer consumer) {\n-        if (isPresent)\n-            consumer.accept(v);\n-    }\n-\n-    public int orElse(int other) {\n-        return isPresent ? v : other;\n-    }\n-}\n-\n-public final class ExplicitLambdaWithNullableTypes2 {\n-\n-   public static void main(String[] args) {\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n-       for (int i=0; i < 5; i++) {\n-           opts.add(OptionalInt.of(i));\n-           opts.add(OptionalInt.empty());\n-           opts.add(null);\n-       }\n-\n-       Stream<OptionalInt.ref> soi = opts.stream();\n-       ToIntFunction<OptionalInt.ref> f = (OptionalInt.ref o) -> {\n-            if (o == null) return 0;\n-            OptionalInt.val op = (OptionalInt.val)o;\n-            return op.orElse(0);\n-       };\n-\n-       IntStream sint = soi.mapToInt(f);\n-       int total = sint.reduce(0, (x, y) -> x + y);\n-\n-       if (total != 10) {\n-            throw new AssertionError(\"Incorrect output: \" + total);\n-       }\n-   }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ExplicitLambdaWithNullableTypes2.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8229537\n- * @summary [lworld] Poor interaction between explicit lambda parameters and nullable projection types.\n- * @compile -XDallowWithFieldOperator ExplicitLambdaWithNullableTypes3.java\n- * @run main\/othervm ExplicitLambdaWithNullableTypes3\n- *\/\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.function.*;\n-import java.util.NoSuchElementException;\n-import java.util.stream.*;\n-\n-primitive class OptionalInt.val {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n-\n-    private boolean isPresent = false;\n-    private int v = 0;\n-\n-    public static OptionalInt.val empty() {\n-        return OptionalInt.val.default;\n-    }\n-\n-    public static OptionalInt.val of(int val) {\n-        OptionalInt.val self = OptionalInt.val.default;\n-        self = __WithField(self.v, val);\n-        self = __WithField(self.isPresent, true);\n-        return self;\n-    }\n-\n-    public int getAsInt() {\n-        if (!isPresent)\n-            throw new NoSuchElementException(\"No value present\");\n-\n-        return v;\n-    }\n-\n-    public boolean isPresent() {\n-        return isPresent;\n-    }\n-\n-    public void ifPresent(IntConsumer consumer) {\n-        if (isPresent)\n-            consumer.accept(v);\n-    }\n-\n-    public int orElse(int other) {\n-        return isPresent ? v : other;\n-    }\n-}\n-\n-public final class ExplicitLambdaWithNullableTypes3 {\n-\n-   public static void main(String[] args) {\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n-       for (int i=0; i < 5; i++) {\n-           opts.add(OptionalInt.of(i));\n-           opts.add(OptionalInt.empty());\n-           opts.add(null);\n-       }\n-\n-       Stream<OptionalInt.ref> soi = opts.stream();\n-       ToIntFunction<OptionalInt.ref> f = o -> {\n-            if (o == null) return 0;\n-            OptionalInt.val op = (OptionalInt.val)o;\n-            return op.orElse(0);\n-        };\n-\n-       IntStream sint = soi.mapToInt(f);\n-       int total = sint.reduce(0, (x, y) -> x + y);\n-\n-       if (total != 10) {\n-            throw new AssertionError(\"Incorrect output: \" + total);\n-       }\n-   }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ExplicitLambdaWithNullableTypes3.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class FlattenableFlagFromClass {\n-\n-    public primitive final class V.val {\n-        final int x = 10;\n-    }\n-\n-    public V.val v;\n-    public V.val[] va;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/FlattenableFlagFromClass.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8197911\n- * @summary Test Javac's treatment of null assignment to value instances\n- * @compile\/fail\/ref=FlattenableNegativeTest.out -XDallowWithFieldOperator -XDrawDiagnostics -XDdev FlattenableNegativeTest.java\n- *\/\n-\n-public class FlattenableNegativeTest {\n-    primitive final class V.val {\n-        final int x = 10;\n-\n-        primitive final class X.val {\n-            final V.val v = null;  \/\/ Error: initialization illegal\n-            final V.val v2 = v;    \/\/ OK, null not constant propagated.\n-\n-            V.val foo(X.val x) {\n-                x = __WithField(x.v, null);  \/\/ Error: withfield attempt is illegal.\n-                return x.v;\n-            }\n-        }\n-        V.val foo(X.val x) {\n-            x = __WithField(x.v, null); \/\/ withfield attempt is illegal\n-            return x.v;\n-        }\n-\n-        class Y {\n-            V.val v;\n-            V.val [] va = { null }; \/\/ Illegal array initialization\n-            V.val [] va2 = new V.val[] { null }; \/\/ Illegal array initialization\n-            void foo(X.val x) {\n-                x = __WithField(x.v, null); \/\/ illegal withfield attempt\n-                v = null; \/\/ illegal assignment.\n-                va[0] = null; \/\/ Illegal.\n-                va = new V.val[] { null }; \/\/ Illegal\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/FlattenableNegativeTest.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-FlattenableNegativeTest.java:13:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:17:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:22:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:28:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:29:42: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:31:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:32:21: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:33:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-FlattenableNegativeTest.java:34:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V.val)\n-9 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/FlattenableNegativeTest.out","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237072\n- * @summary Test various relationships between a value type and its reference projection.\n- * @compile\/fail\/ref=GenericInlineTest.out -XDrawDiagnostics GenericInlineTest.java\n- *\/\n-\n-abstract class Low<T, U> {}\n-abstract class Mid<T, U> extends Low<U, T> {}\n-abstract class High<T, U> extends Mid<U, T> {}\n-\n-primitive\n-class GenericInlineTest.val<T, U> extends High<U, T> {\n-\n-    int x = 0;\n-\n-    void foo() {\n-\n-        GenericInlineTest.val<String, Integer> g = new GenericInlineTest<String, Integer>();\n-\n-        High<String, Integer> h1 = g; \/\/ error.\n-\n-        High<Integer, String> h2 = g; \/\/ Ok.\n-\n-        Mid<String, Integer> m1 = g; \/\/ Ok\n-\n-        Mid<Integer, String> m2 = g; \/\/ error.\n-\n-        Low<String, Integer> l1 = g; \/\/ error.\n-\n-        Low<Integer, String> l2 = g; \/\/ Ok.\n-\n-        g = l2; \/\/ error.\n-        g = (GenericInlineTest.val<String, Integer>) l2; \/\/ OK.\n-\n-        GenericInlineTest<String, Integer> r1 = g; \/\/ ok.\n-        GenericInlineTest.ref<Integer, String> r2 = g; \/\/ error\n-\n-        g = r1; \/\/ ok.\n-        g = r2; \/\/ error.\n-        g = (GenericInlineTest.val<String, Integer>) r2; \/\/ still error.\n-\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/GenericInlineTest.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-GenericInlineTest.java:21:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.val<java.lang.String,java.lang.Integer>, High<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:27:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.val<java.lang.String,java.lang.Integer>, Mid<java.lang.Integer,java.lang.String>)\n-GenericInlineTest.java:29:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.val<java.lang.String,java.lang.Integer>, Low<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:33:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: Low<java.lang.Integer,java.lang.String>, GenericInlineTest.val<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:37:53: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.val<java.lang.String,java.lang.Integer>, GenericInlineTest<java.lang.Integer,java.lang.String>)\n-GenericInlineTest.java:40:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.Integer,java.lang.String>, GenericInlineTest.val<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:41:54: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.Integer,java.lang.String>, GenericInlineTest.val<java.lang.String,java.lang.Integer>)\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/GenericInlineTest.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8230121\n- * @summary Javac does not properly parse nullable projection types of parameterized inline types\n- * @compile GenericsAndValues5.java\n- * @run main\/othervm GenericsAndValues5\n- *\/\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.function.Function;\n-import java.util.List;\n-import java.util.ArrayList;\n-\n-primitive class Optional.val<T> {\n-    private T value;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Optional.val<T> empty() {\n-        return (Optional.val<T>) Optional.val.default;\n-    }\n-\n-    private Optional(T value) {\n-        this.value = value;\n-    }\n-\n-    public static <T> Optional.val<T> of(T value) {\n-        if (value == null)\n-            return empty();\n-        return new Optional<T>(value);\n-    }\n-\n-    public T get() {\n-        if (value == null)\n-            throw new NoSuchElementException(\"No value present\");\n-        return value;\n-    }\n-\n-    public boolean isPresent() {\n-        return value != null;\n-    }\n-\n-    public T orElse(T other) {\n-        return value != null ? value : other;\n-    }\n-\n-    public <U> Optional.val<U> map(Function<? super T, ? extends U> mapper) {\n-        Objects.requireNonNull(mapper);\n-        if (!isPresent())\n-            return empty();\n-        else\n-            return Optional.of(mapper.apply(value));\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return value != null ? String.format(\"Optional[%s]\", value) : \"Optional.empty\";\n-    }\n-}\n-\n-public final class GenericsAndValues5 {\n-\n-   public static void main(String[] args) {\n-\n-       List<Optional.ref<Integer>> opts = new ArrayList<>();\n-       for (int i=0; i < 6; i++) {\n-           Optional.val<Integer> oi = Optional.of(i);\n-           opts.add((Optional.ref<Integer>)oi);\n-           Optional.val<Integer> oe = Optional.empty();\n-           opts.add((Optional.ref<Integer>)oe);\n-       }\n-\n-       Integer total = opts.stream()\n-           .map((Optional.ref<Integer> o) -> {\n-               Optional.val<Integer> op = (Optional.val<Integer>)o;\n-               return op.orElse(0);\n-           })\n-           .reduce(0, (x, y) -> x + y);\n-\n-        if (total != 15) {\n-            throw new AssertionError(\"Incorrect output: \" + total);\n-        }\n-   }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/GenericsAndValues5.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8221545\n- * @summary Test Generics with ?\n- * @compile\/fail\/ref=GenericsWithQuestion.out -XDrawDiagnostics GenericsWithQuestion.java\n- *\/\n-\n-import java.util.HashMap;\n-\n-public class GenericsWithQuestion {\n-\n-    primitive class V.val {\n-        int x = 10;\n-    }\n-\n-    HashMap<V, V>good1;\n-    HashMap<V.ref, GenericsWithQuestion.V.ref>good2;\n-    HashMap<V.val, V.val>  bad1; \/\/ error;\n-    HashMap<V.ref, V.val> bad2; \/\/ error\n-    HashMap<V.val, V.ref> bad3; \/\/ error\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/GenericsWithQuestion.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-GenericsWithQuestion.java:18:14: compiler.err.type.found.req: GenericsWithQuestion.V.val, (compiler.misc.type.req.ref)\n-GenericsWithQuestion.java:18:21: compiler.err.type.found.req: GenericsWithQuestion.V.val, (compiler.misc.type.req.ref)\n-GenericsWithQuestion.java:19:21: compiler.err.type.found.req: GenericsWithQuestion.V.val, (compiler.misc.type.req.ref)\n-GenericsWithQuestion.java:20:14: compiler.err.type.found.req: GenericsWithQuestion.V.val, (compiler.misc.type.req.ref)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/GenericsWithQuestion.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244231\n- * @summary Javac should reject P<T>.{ref,val} preferring P.{ref,val}<T> instead\n- * @compile\/fail\/ref=MalformedParameterizedType.out -XDrawDiagnostics MalformedParameterizedType.java\n- *\/\n-\n-final class MalformedParameterizedType {\n-\n-    static primitive class P<T> {}\n-    static primitive class RDP.val<T> {}\n-\n-    P.ref<String> pr1; \/\/ OK\n-    P.val<String> pv1; \/\/ OK\n-\n-    P<String>.ref pr2; \/\/ Malformed\n-    P<String>.val pv2; \/\/ Malformed\n-\n-    RDP.ref<String> rdpr1; \/\/ OK\n-    RDP.val<String> rdpv1; \/\/ OK\n-\n-    RDP<String>.ref rdpr2; \/\/ Malformed\n-    RDP<String>.val rdpv2; \/\/ Malformed\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/MalformedParameterizedType.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-MalformedParameterizedType.java:16:14: compiler.err.improperly.formed.type.param.missing\n-MalformedParameterizedType.java:17:14: compiler.err.improperly.formed.type.param.missing\n-MalformedParameterizedType.java:22:16: compiler.err.improperly.formed.type.param.missing\n-MalformedParameterizedType.java:23:16: compiler.err.improperly.formed.type.param.missing\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/MalformedParameterizedType.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8237072\n- * @summary Test compiler on various constructs it had issues with.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-\n-public class NoCrashTest {\n-\n-    interface I {}\n-    static class C implements I {}\n-    static primitive final class V.val implements I { int x = 0; }\n-\n-    static void triggerNPE(V.ref [] vra) {\n-        vra[0] = null;\n-    }\n-\n-    static String foo(V.val[] va) {\n-        return \"array of nonnull v's\";\n-    }\n-\n-    static String foo(Object [] oa) {\n-        return \"array of nullable o's\";\n-    }\n-\n-    static public void main(String[] args) {\n-        I arg = args.length == 0 ? new V() : new C();\n-        V.val [] xs = new V.val[0];\n-        Object [] os = new Object [0];\n-        Object [] o = args.length == 0 ? xs : os;\n-        Object o2 = (o == null) ? new V()  : new Object();\n-\n-        triggerNPE(new V.ref[1]); \/\/ NO NPE.\n-        try {\n-            triggerNPE(new V.val[1]);\n-            throw new RuntimeException(\"Should not get here!\");\n-        } catch (NullPointerException npe) {\n-            \/\/ all is well.\n-        }\n-\n-        V.val [] v = new V.val[0];\n-        if (!foo((V.ref []) v).equals(\"array of nullable o's\"))\n-            throw new AssertionError(\"Broken\");\n-\n-        ArrayList<V.ref> vList = new ArrayList<V.ref>(Arrays.asList(new V.ref[10]));\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/NoCrashTest.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237072\n- * @summary Test various relationships between a value type and its reference projection.\n- * @compile\/fail\/ref=OverloadingPhaseTest.out -XDrawDiagnostics OverloadingPhaseTest.java\n- *\/\n-\n-public class OverloadingPhaseTest {\n-\n-    static primitive class V.val {\n-        int x = 0;\n-    }\n-\n-    static String roo(V v, int i) {\n-        return \"Phase 1\";\n-    }\n-\n-    static String roo(V v, Integer i) {\n-        return \"Phase 2\";\n-    }\n-\n-    public static void main(String args) {\n-        V.val o = new V();\n-        String result;\n-\n-        if (!(result = roo(o, 0)).equals(\"phase 2\"))\n-            throw new AssertionError(\"Broken: got \" + result);\n-        if (!(result = roo(o, Integer.valueOf(0))).equals(\"phase 2\"))\n-            throw new AssertionError(\"Broken: got \" + result);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/OverloadingPhaseTest.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-OverloadingPhaseTest.java:26:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V,java.lang.Integer), OverloadingPhaseTest\n-OverloadingPhaseTest.java:28:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V,java.lang.Integer), OverloadingPhaseTest\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/OverloadingPhaseTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8210906 8215109\n- * @summary [lworld] default value creation should not impose raw types on users.\n- * @run main\/othervm ParameterizedDefault\n- *\/\n-\n-public primitive class ParameterizedDefault.val<E> {\n-    E value;\n-    ParameterizedDefault(E value) { this.value = value; }\n-    static String foo (Object p) {\n-        return (\"Object version\");\n-    }\n-    static String foo (String p) {\n-        return (\"String version\");\n-    }\n-    static String foo (java.util.Date p) {\n-        return (\"Date version\");\n-    }\n-    public static void main(String [] args) {\n-        var foo = ParameterizedDefault.val.default;\n-        var soo = ParameterizedDefault.val<String>.default;\n-        if (!foo(foo.value).equals(\"Object version\") ||\n-            !foo(soo.value).equals(\"String version\") ||\n-            !foo(ParameterizedDefault.val<java.util.Date>.default.value).equals(\"Date version\"))\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ParameterizedDefault.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test basic syntax of values\n- *\n- * @compile -XDallowWithFieldOperator Point.java\n- *\/\n-\n-primitive class Point.val {\n-    static final Point origin = makePoint(10, 20);\n-    static final Point origin2 = makePoint(10, 20);\n-    int x;\n-    int y;\n-    Point () {\n-        x = 10;\n-        y = 20;\n-    }\n-    static Point.val makePoint(int x, int y) {\n-        Point.val p = Point.val.default;\n-        p = __WithField(p.x, x);\n-        p = __WithField(p.y, y);\n-        return p;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/Point.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222722\n- * @summary  Javac fails to compile V?[].class (syntax dead)\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile ProjectedArrayDotClass.java\n- * @run main\/othervm -Xverify:none ProjectedArrayDotClass\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class ProjectedArrayDotClass {\n-\n-    static primitive class VT.val {\n-        int x = 42;\n-        public static void main(String[] args) {\n-            System.out.println(VT[].class);\n-            System.out.println(VT.val[].class);\n-            System.out.println(ProjectedArrayDotClass.VT[].class);\n-            System.out.println(ProjectedArrayDotClass.VT.val[].class);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new ProjectedArrayDotClass().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"ProjectedArrayDotClass$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-        \"         3: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT;\\\"\",\n-        \"        11: ldc           #21                 \/\/ class \\\"[QProjectedArrayDotClass$VT;\\\"\",\n-        \"        19: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT;\\\"\",\n-        \"        27: ldc           #21                 \/\/ class \\\"[QProjectedArrayDotClass$VT;\\\"\",\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ProjectedArrayDotClass.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244561 8250997\n- * @summary Javac should not allow instantiation of V.ref or V.val\n- * @compile\/fail\/ref=ProjectionInstantiationTest.out -XDrawDiagnostics ProjectionInstantiationTest.java\n- *\/\n-import java.util.function.Supplier;\n-\n-final class ProjectionInstantiationTest {\n-\n-    static primitive class ValDefault {}\n-\n-    static primitive class RefDefault.val<T> {}\n-\n-    public static void main(String[] args) {\n-\n-        \/\/ Next two instantiations are good.\n-        var v1 = new ValDefault();\n-        var v2 = new RefDefault<>();\n-\n-        v1 = v2;\n-\n-        \/\/ Next four instantiations are problematic\n-        new ValDefault.ref();\n-        new RefDefault.ref<>();\n-        new ValDefault.val();\n-        new RefDefault.val<>();\n-\n-        \/\/ Next two references are good.\n-        voo(ValDefault::new);\n-        roo(RefDefault::new);\n-\n-        \/\/ Next four references are problematic\n-        voo(ValDefault.ref::new);\n-        voo(ValDefault.val::new);\n-        roo(RefDefault.ref::new);\n-        roo(RefDefault.val::new);\n-    }\n-\n-    static void voo(Supplier<ValDefault.ref> sx) {\n-        sx.get();\n-    }\n-\n-    static void roo(Supplier<RefDefault.ref> sx) {\n-        sx.get();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ProjectionInstantiationTest.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-ProjectionInstantiationTest.java:21:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ProjectionInstantiationTest.RefDefault.val<java.lang.Object>, ProjectionInstantiationTest.ValDefault)\n-ProjectionInstantiationTest.java:24:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:25:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:26:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:27:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:34:23: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:35:23: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:36:23: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:37:23: compiler.err.projection.cant.be.instantiated\n-9 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ProjectionInstantiationTest.out","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,279 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8237072\n- * @summary Test various relationships between a value type and its reference projection.\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.code\n- *          jdk.compiler\/com.sun.tools.javac.util\n- *\/\n-\n-import java.io.StringWriter;\n-import javax.tools.JavaFileObject;\n-import javax.tools.ToolProvider;\n-import javax.lang.model.element.Element;\n-import com.sun.source.util.JavacTask;\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Names;\n-\n-import toolbox.ToolBox;\n-\n-public class ProjectionRelationsTest {\n-\n-    private static final ToolBox tb = new ToolBox();\n-\n-    enum Relation {\n-        SUBTYPING,\n-        CASTING,\n-        ASSIGNING,\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        String code = \"primitive class C.val {\\n\" +\n-                \"         C cref     = new C();\\n\" +\n-                \"         C.val []  ca       = null;\\n\" +\n-                \"         C [] cra   = null;\\n\" +\n-                \"         Object[]  oa   = null;\\n\" +\n-                      \"}\\n\";\n-        List<JavaFileObject> files = List.of(new ToolBox.JavaSource(code));\n-\n-        JavacTool compiler = (JavacTool) ToolProvider.getSystemJavaCompiler();\n-        StringWriter out = new StringWriter();\n-\n-        Context context = new Context();\n-\n-        JavacTask task = (JavacTask) compiler.getTask(out, null, null, List.of(\"-XDinlinesAreIslands\"), null, files, context);\n-        Iterable<? extends Element> elements = task.analyze();\n-        if (elements == null || !elements.iterator().hasNext()) {\n-            throw new RuntimeException(\"Didn't compile alright!\");\n-        }\n-\n-        Names names =  Names.instance(context);\n-\n-        ClassSymbol valueCls = (ClassSymbol) elements.iterator().next();\n-        Type vType = valueCls.type.asValueType();\n-        Type vDotRefType = valueCls.members().findFirst(names.fromString(\"cref\")).type;\n-        Type vArrayType = valueCls.members().findFirst(names.fromString(\"ca\")).type;\n-        Type vRefArrayType = valueCls.members().findFirst(names.fromString(\"cra\")).type;\n-        Type jlOArrayType = valueCls.members().findFirst(names.fromString(\"oa\")).type;\n-\n-        for (Relation relation : Relation.values()) {\n-            testRelation(context, relation, vType, vDotRefType);\n-            testRelation(context, relation, vArrayType, vRefArrayType, jlOArrayType);\n-        }\n-    }\n-\n-    static void testRelation(Context context, Relation relation, Type vType, Type vDotRefType) {\n-        Types types =  Types.instance(context);\n-        Symtab syms =  Symtab.instance(context);\n-        Type intType = syms.intType;\n-        Type objectType = syms.objectType;\n-        Type integerType = types.boxedTypeOrType(syms.intType);\n-        Type stringType = syms.stringType;\n-\n-        System.out.println(\"Testing relation \" + relation + \" between \" +\n-                                       vType.tsym.name + \" and \" + vDotRefType.tsym.name);\n-            switch (relation) {\n-                case SUBTYPING:\n-\n-                    \/\/ self check\n-                    Assert.check(types.isSubtype(vType, vType));\n-                    Assert.check(types.isSubtype(vDotRefType, vDotRefType));\n-\n-                    Assert.check(types.isSubtype(vType, vDotRefType) ==\n-                                 types.isSubtype(intType, integerType));\n-                    Assert.check(types.isSubtype(vDotRefType, vType) ==\n-                                 types.isSubtype(integerType, intType));\n-\n-                    Assert.check(types.isSubtype(vType, objectType) ==\n-                                 types.isSubtype(intType, objectType));\n-                    Assert.check(types.isSubtype(objectType, vType) ==\n-                                 types.isSubtype(objectType, intType));\n-\n-                    Assert.check(types.isSubtype(vDotRefType, objectType) ==\n-                                 types.isSubtype(integerType, objectType));\n-                    Assert.check(types.isSubtype(objectType, vDotRefType) ==\n-                                 types.isSubtype(objectType, integerType));\n-\n-                    \/\/ check against a totally unrelated class.\n-                    Assert.check(types.isSubtype(vType, stringType) ==\n-                                 types.isSubtype(intType, stringType));\n-                    Assert.check(types.isSubtype(stringType, vType) ==\n-                                 types.isSubtype(stringType, intType));\n-\n-                    Assert.check(types.isSubtype(vDotRefType, stringType) ==\n-                                 types.isSubtype(integerType, stringType));\n-                    Assert.check(types.isSubtype(stringType, vDotRefType) ==\n-                                 types.isSubtype(stringType, integerType));\n-                    break;\n-\n-                case CASTING:\n-\n-                    \/\/ self check\n-                    Assert.check(types.isCastable(vType, vType));\n-                    Assert.check(types.isCastable(vDotRefType, vDotRefType));\n-\n-                    Assert.check(types.isCastable(vType, vDotRefType) ==\n-                                 types.isCastable(intType, integerType));\n-                    Assert.check(types.isCastable(vDotRefType, vType) ==\n-                                 types.isCastable(integerType, intType));\n-                    Assert.check(types.isCastable(vType, objectType) ==\n-                                 types.isCastable(intType, objectType));\n-                    Assert.check(types.isCastable(objectType, vType) ==\n-                                 types.isCastable(objectType, intType));\n-                    Assert.check(types.isCastable(vDotRefType, objectType) ==\n-                                 types.isCastable(integerType, objectType));\n-                    Assert.check(types.isCastable(objectType, vDotRefType) ==\n-                                 types.isCastable(objectType, integerType));\n-                    \/\/ check against a totally unrelated class.\n-                    Assert.check(types.isCastable(vType, stringType) ==\n-                                 types.isCastable(intType, stringType));\n-                    Assert.check(types.isCastable(stringType, vType) ==\n-                                 types.isCastable(stringType, intType));\n-\n-                    Assert.check(types.isCastable(vDotRefType, stringType) ==\n-                                 types.isCastable(integerType, stringType));\n-                    Assert.check(types.isCastable(stringType, vDotRefType) ==\n-                                 types.isCastable(stringType, integerType));\n-                    break;\n-\n-                case ASSIGNING:\n-\n-                    \/\/ self check\n-                    Assert.check(types.isAssignable(vType, vType));\n-                    Assert.check(types.isAssignable(vDotRefType, vDotRefType));\n-\n-                    Assert.check(types.isAssignable(vType, vDotRefType) ==\n-                                 types.isAssignable(intType, integerType));\n-                    Assert.check(types.isAssignable(vDotRefType, vType) ==\n-                                 types.isAssignable(integerType, intType));\n-                    Assert.check(types.isAssignable(vType, objectType) ==\n-                                 types.isAssignable(intType, objectType));\n-                    Assert.check(types.isAssignable(objectType, vType) ==\n-                                 types.isAssignable(objectType, intType));\n-                    Assert.check(types.isAssignable(vDotRefType, objectType) ==\n-                                 types.isAssignable(integerType, objectType));\n-                    Assert.check(types.isAssignable(objectType, vDotRefType) ==\n-                                 types.isAssignable(objectType, integerType));\n-                    \/\/ check against a totally unrelated class.\n-                    Assert.check(types.isAssignable(vType, stringType) ==\n-                                 types.isAssignable(intType, stringType));\n-                    Assert.check(types.isAssignable(stringType, vType) ==\n-                                 types.isAssignable(stringType, intType));\n-\n-                    Assert.check(types.isAssignable(vDotRefType, stringType) ==\n-                                 types.isAssignable(integerType, stringType));\n-                    Assert.check(types.isAssignable(stringType, vDotRefType) ==\n-                                 types.isAssignable(stringType, integerType));\n-                    break;\n-            }\n-    }\n-\n-    static void testRelation(Context context, Relation relation, Type vArrayType, Type vDotRefArrayType, Type objectArrayType) {\n-        Types types =  Types.instance(context);\n-        Symtab syms =  Symtab.instance(context);\n-\n-        System.out.println(\"Testing relation \" + relation + \" between \" +\n-                                       vArrayType.tsym.name + \" and \" + vDotRefArrayType.tsym.name);\n-            switch (relation) {\n-                case SUBTYPING:\n-\n-                    \/* check against self *\/\n-                    Assert.check(types.isSubtype(vArrayType, vArrayType));\n-                    Assert.check(types.isSubtype(vDotRefArrayType, vDotRefArrayType));\n-\n-                    \/* check against valid supers *\/\n-                    Assert.check(types.isSubtype(vArrayType, vDotRefArrayType));\n-                    Assert.check(types.isSubtype(vArrayType, objectArrayType));\n-                    Assert.check(types.isSubtype(vArrayType, syms.objectType));\n-                    Assert.check(types.isSubtype(vDotRefArrayType, objectArrayType));\n-                    Assert.check(types.isSubtype(vDotRefArrayType, syms.objectType));\n-\n-                    \/* check negative cases *\/\n-                    Assert.check(!types.isSubtype(vDotRefArrayType, vArrayType));\n-                    Assert.check(!types.isSubtype(objectArrayType, vArrayType));\n-                    Assert.check(!types.isSubtype(objectArrayType, vDotRefArrayType));\n-\n-                    break;\n-\n-                case CASTING:\n-\n-                    \/* check self cast *\/\n-                    Assert.check(types.isCastable(vArrayType, vArrayType));\n-                    Assert.check(types.isCastable(vDotRefArrayType, vDotRefArrayType));\n-\n-                    \/* check widening cast of V *\/\n-                    Assert.check(types.isCastable(vArrayType, vDotRefArrayType));\n-                    Assert.check(types.isCastable(vArrayType, objectArrayType));\n-                    Assert.check(types.isCastable(vArrayType, syms.objectType));\n-\n-                    \/* check cast of V.ref to supers *\/\n-                    Assert.check(types.isCastable(vDotRefArrayType, objectArrayType));\n-                    Assert.check(types.isCastable(vDotRefArrayType, syms.objectType));\n-\n-                    \/* check downcasts *\/\n-                    Assert.check(types.isCastable(vDotRefArrayType, vArrayType));\n-                    Assert.check(types.isCastable(objectArrayType, vArrayType));\n-                    Assert.check(types.isCastable(objectArrayType, vDotRefArrayType));\n-                    Assert.check(types.isCastable(syms.objectType, vArrayType));\n-                    Assert.check(types.isCastable(syms.objectType, vDotRefArrayType));\n-\n-                    break;\n-\n-                case ASSIGNING:\n-\n-                    \/* check self  *\/\n-                    Assert.check(types.isAssignable(vArrayType, vArrayType));\n-                    Assert.check(types.isAssignable(vDotRefArrayType, vDotRefArrayType));\n-\n-                    \/* check widening *\/\n-                    Assert.check(types.isAssignable(vArrayType, vDotRefArrayType));\n-                    Assert.check(types.isAssignable(vArrayType, objectArrayType));\n-                    Assert.check(types.isAssignable(vArrayType, syms.objectType));\n-\n-                    \/* check more widening *\/\n-                    Assert.check(types.isAssignable(vDotRefArrayType, objectArrayType));\n-                    Assert.check(types.isAssignable(vDotRefArrayType, syms.objectType));\n-\n-                    \/* misc *\/\n-                    Assert.check(!types.isAssignable(vDotRefArrayType, vArrayType));\n-                    Assert.check(!types.isAssignable(objectArrayType, vArrayType));\n-                    Assert.check(!types.isAssignable(objectArrayType, vDotRefArrayType));\n-                    Assert.check(!types.isAssignable(syms.objectType, vArrayType));\n-                    Assert.check(!types.isAssignable(syms.objectType, vDotRefArrayType));\n-\n-                    break;\n-            }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ProjectionRelationsTest.java","additions":0,"deletions":279,"binary":false,"changes":279,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8244559\n- * @summary Check that javac transforms Types to AST nodes properly.\n- * @run main ProperTypeApplySelectTest\n- *\/\n-\n-import java.util.List;\n-\n-public class ProperTypeApplySelectTest {\n-\n-  static String out = \"\";\n-\n-  primitive static class Foo.val<V> {\n-    int x;\n-    Foo(int x) { this.x = x; }\n-  }\n-\n-  static void m(Foo.val foo) {\n-    out += \"inline\";\n-  }\n-  static void m(Foo.ref foo) {\n-    out += \"ref\";\n-  }\n-\n-  public static void main(String[] args) {\n-    List<Foo.ref<Integer>> list = List.of(new Foo<Integer>(3));\n-    list.stream().forEach(e -> m(e));\n-    if (!out.equals(\"ref\"))\n-        throw new AssertionError(\"Unexpected: \" + out);\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ProperTypeApplySelectTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * bug 8212563\n- * @summary Check that javac emits Q types for values as needed\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile QTypedValue.java\n- * @run main\/othervm -Xverify:none QTypeTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class QTypeTest {\n-\n-    public static void main(String[] args) {\n-        new QTypeTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"QTypedValue.class\").toString() };\n-        runCheck(params, new String [] {\n-              \"final primitive class QTypedValue\",\n-              \"  flags: (0x0130) ACC_FINAL, ACC_SUPER, ACC_PRIMITIVE\",\n-              \"  this_class: #1                          \/\/ QTypedValue\",\n-              \"   #1 = Class              #2             \/\/ QTypedValue\",\n-              \"   #2 = Utf8               QTypedValue\",\n-              \"   #3 = Class              #4             \/\/ \\\"QQTypedValue;\\\"\",\n-              \"   #4 = Utf8               QQTypedValue;\",\n-              \"   #5 = Fieldref           #1.#6          \/\/ QTypedValue.f1:[QQTypedValue;\",\n-              \"   #8 = Utf8               [QQTypedValue;\",\n-              \"   #9 = Fieldref           #1.#10         \/\/ QTypedValue.f2:[QQTypedValue;\",\n-              \"  #12 = Class              #13            \/\/ \\\"[[[QQTypedValue;\\\"\",\n-              \"  #13 = Utf8               [[[QQTypedValue;\",\n-              \"  #14 = Fieldref           #1.#15         \/\/ QTypedValue.f3:[[[QQTypedValue;\",\n-              \"  #17 = Fieldref           #1.#18         \/\/ QTypedValue.f4:[[[QQTypedValue;\",\n-              \"  #27 = Utf8               (QQTypedValue;I)V\",\n-              \"  #21 = NameAndType        #22:#23        \/\/ \\\"<init>\\\":()QQTypedValue;\",\n-              \"  #25 = NameAndType        #26:#27        \/\/ foo:(QQTypedValue;I)V\",\n-              \"   #6 = NameAndType        #7:#8          \/\/ f1:[QQTypedValue;\",\n-              \"  #10 = NameAndType        #11:#8         \/\/ f2:[QQTypedValue;\",\n-              \"  #15 = NameAndType        #16:#13        \/\/ f3:[[[QQTypedValue;\",\n-              \"  #18 = NameAndType        #19:#13        \/\/ f4:[[[QQTypedValue;\",\n-              \" final QTypedValue[] f1;\",\n-              \"    descriptor: [QQTypedValue;\",\n-              \"    flags: (0x0010) ACC_FINAL\",\n-              \"  final QTypedValue[] f2;\",\n-              \"    descriptor: [QQTypedValue;\",\n-              \"    flags: (0x0010) ACC_FINAL\",\n-              \"  final QTypedValue[][][] f3;\",\n-              \"    descriptor: [[[QQTypedValue;\",\n-              \"    flags: (0x0010) ACC_FINAL\",\n-              \"  final QTypedValue[][][] f4;\",\n-              \"    descriptor: [[[QQTypedValue;\",\n-              \"    flags: (0x0010) ACC_FINAL\",\n-              \"  void foo(QTypedValue, int);\",\n-              \"    descriptor: (QQTypedValue;I)V\",\n-              \"    flags: (0x0000)\",\n-              \"    Code:\",\n-              \"      stack=3, locals=12, args_size=3\",\n-              \"         0: aload_0\",\n-              \"         1: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n-              \"         4: bipush        10\",\n-              \"         6: invokevirtual #24                 \/\/ Method foo:(QQTypedValue;I)V\",\n-              \"         9: iload_2\",\n-              \"        10: ifne          34\",\n-              \"        13: iconst_0\",\n-              \"        14: istore        8\",\n-              \"        16: dconst_0\",\n-              \"        17: dstore        9\",\n-              \"        19: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n-              \"        22: astore_3\",\n-              \"        23: iload         8\",\n-              \"        25: ifne          29\",\n-              \"        28: return\",\n-              \"        29: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n-              \"        32: astore        11\",\n-              \"        34: return\",\n-              \"      StackMapTable: number_of_entries = 2\",\n-              \"        frame_type = 255 \/* full_frame *\/\",\n-              \"          offset_delta = 29\",\n-              \"          locals = [ class \\\"QQTypedValue;\\\", class \\\"QQTypedValue;\\\", int, class \\\"QQTypedValue;\\\", top, top, top, top, int, double ]\",\n-              \"          stack = []\",\n-              \"        frame_type = 255 \/* full_frame *\/\",\n-              \"          offset_delta = 4\",\n-              \"          locals = [ class \\\"QQTypedValue;\\\", class \\\"QQTypedValue;\\\", int ]\",\n-              \"          stack = []\",\n-              \"static QTypedValue QTypedValue();\",\n-              \"    descriptor: ()QQTypedValue;\",\n-              \"    flags: (0x0008) ACC_STATIC\",\n-              \"    Code:\",\n-              \"      stack=2, locals=1, args_size=0\",\n-              \"         0: defaultvalue  #1                  \/\/ class QTypedValue\",\n-              \"         3: astore_0\",\n-              \"         4: bipush        10\",\n-              \"         6: anewarray     #3                  \/\/ class \\\"QQTypedValue;\\\"\",\n-              \"         9: aload_0\",\n-              \"        10: swap\",\n-              \"        11: withfield     #5                  \/\/ Field f1:[QQTypedValue;\",\n-              \"        14: astore_0\",\n-              \"        15: bipush        10\",\n-              \"        17: anewarray     #3                  \/\/ class \\\"QQTypedValue;\\\"\",\n-              \"        20: aload_0\",\n-              \"        21: swap\",\n-              \"        22: withfield     #9                  \/\/ Field f2:[QQTypedValue;\",\n-              \"        25: astore_0\",\n-              \"        26: bipush        10\",\n-              \"        28: bipush        10\",\n-              \"        30: multianewarray #12,  2            \/\/ class \\\"[[[QQTypedValue;\\\"\",\n-              \"        34: aload_0\",\n-              \"        35: swap\",\n-              \"        36: withfield     #14                 \/\/ Field f3:[[[QQTypedValue;\",\n-              \"        39: astore_0\",\n-              \"        40: bipush        10\",\n-              \"        42: bipush        10\",\n-              \"        44: multianewarray #12,  2            \/\/ class \\\"[[[QQTypedValue;\\\"\",\n-              \"        48: aload_0\",\n-              \"        49: swap\",\n-              \"        50: withfield     #17                 \/\/ Field f4:[[[QQTypedValue;\",\n-              \"        53: astore_0\",\n-              \"        54: aload_0\",\n-              \"        55: areturn\",\n-                         }, new String [] {\n-                            });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut, String [] unexpectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-        for (String eo: unexpectedOut) {\n-            if (out.contains(eo)) {\n-                System.err.println(\"Unexpected output found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-        if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/QTypeTest.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-primitive class QTypedValue.val {\n-\n-    QTypedValue.val [] f1 = new QTypedValue.val[10];\n-    QTypedValue.val [] f2 = new QTypedValue.val[10];\n-\n-    QTypedValue.val [][][] f3 = new QTypedValue.val[10][10][];\n-    QTypedValue.val [][][] f4 = new QTypedValue.val[10][10][];\n-\n-    void foo(QTypedValue.val x, int i) {\n-        foo(new QTypedValue(), 10);\n-        QTypedValue.val x1, x2, x4, x5, x6;\n-        if (i == 0) {\n-            int j = 0; double d = 0.0;\n-            x1 = new QTypedValue();\n-            if (j == 0)\n-                return;\n-            QTypedValue.val x9 = new QTypedValue();\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/QTypedValue.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public primitive class Rectangle.val {\n-\n-    Point.val topLeft, bottomRight;\n-\n-    static Point.val origin;\n-\n-    static Rectangle.val from (Point.ref topLeft, Point.ref bottomRight) {\n-        return new Rectangle(topLeft, bottomRight);\n-    }\n-\n-    Rectangle (Point.val topLeft, Point.val bottomRight) {\n-        this.topLeft = topLeft;\n-        this.bottomRight = bottomRight;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/Rectangle.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8244982\n- * @summary Javac has trouble compiling method references\n- * @run main StreamsTest\n- *\/\n-\n-import java.util.Arrays;\n-\n-public class StreamsTest {\n-\n-    public static primitive class X.val {\n-\n-        String data;\n-\n-        X(String data) {\n-            this.data = data;\n-        }\n-\n-        String data() { return data; }\n-\n-        static String accumulate = \"\";\n-\n-        static void accumulate(String s) {\n-            accumulate += s;\n-        }\n-\n-        static String streamedData() {\n-\n-            X.val [] xs = new X.val[] {\n-                                 new X(\"Streams \"),\n-                                 new X(\"test \"),\n-                                 new X(\"passed OK!\")\n-                      };\n-\n-            Arrays.stream(xs)\n-                        .map(X.ref::data)\n-                        .filter(p -> p != null)\n-                        .forEach(X::accumulate);\n-\n-            return accumulate;\n-        }\n-    }\n-\n-    public static void main(String [] args) {\n-        if (!X.streamedData().equals(\"Streams test passed OK!\"))\n-            throw new AssertionError(\"Unexpected data in stream\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/StreamsTest.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244231\n- * @summary Test that tree copier is able to handle reference and value projection types.\n- * @compile\/fail\/ref=TreeCopierTest.out -XDrawDiagnostics TreeCopierTest.java\n- *\/\n-\n-\n-final class TreeCopierTest {\n-\n-    static primitive class RefDefault.val {}\n-    static primitive class GenericRefDefault.val<T> {}\n-\n-    static primitive class ValDefault {}\n-    static primitive class GenericValDefault<T> {}\n-\n-    public static void main(String[] args) {\n-\n-        var v1 = (RefDefault.val) new RefDefault();\n-        var v2 = (GenericRefDefault.val<Object>) new GenericRefDefault<>();\n-        v1 = v2;\n-\n-        var v3 = (ValDefault.ref) new ValDefault();\n-        var v4 = (GenericValDefault.ref<Object>) new GenericValDefault<>();\n-        v3 = v4;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/TreeCopierTest.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-TreeCopierTest.java:21:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TreeCopierTest.GenericRefDefault.val<java.lang.Object>, TreeCopierTest.RefDefault.val)\n-TreeCopierTest.java:25:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TreeCopierTest.GenericValDefault.ref<java.lang.Object>, TreeCopierTest.ValDefault.ref)\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/TreeCopierTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8222792\n- * @summary Javac should enforce the latest relationship rules between an inline type and its nullable projection\n- * @compile\/fail\/ref=TypeRelationsNegativeTest.out -XDrawDiagnostics TypeRelationsNegativeTest.java\n- *\/\n-\n-final primitive class TypeRelationsNegativeTest.val {\n-\n-    void foo() {\n-        TypeRelationsNegativeTest.val x = null; \/\/ error\n-        TypeRelationsNegativeTest xq = null;\n-\n-        xq = x;\n-        xq = (TypeRelationsNegativeTest) x;\n-        xq = (TypeRelationsNegativeTest.val) x;\n-        x = xq;\n-        x = (TypeRelationsNegativeTest) xq;\n-        x = (TypeRelationsNegativeTest.val) xq;\n-\n-        TypeRelationsNegativeTest.val [] xa = new TypeRelationsNegativeTest.val[] { null }; \/\/ error\n-        TypeRelationsNegativeTest [] xqa = new TypeRelationsNegativeTest.ref[] { null };\n-\n-        xqa = xa;\n-        xqa = (TypeRelationsNegativeTest[]) xa;\n-        xa = xqa;\/\/ error\n-        xa = (TypeRelationsNegativeTest.val []) xqa;\n-    }\n-    int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/TypeRelationsNegativeTest.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-TypeRelationsNegativeTest.java:11:43: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest.val)\n-TypeRelationsNegativeTest.java:21:85: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest.val)\n-TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest[], TypeRelationsNegativeTest.val[])\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/TypeRelationsNegativeTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222792\n- * @summary Javac should enforce the latest relationship rules between an inline type and its nullable projection\n- * @run main\/othervm TypeRelationsTest\n- *\/\n-\n-public primitive class TypeRelationsTest.val {\n-\n-    int x = 42;\n-\n-    static boolean foo(TypeRelationsTest.val x, TypeRelationsTest xq, boolean nullPassed) {\n-        TypeRelationsTest.val xl;\n-        TypeRelationsTest xql;\n-        boolean npe = false;\n-\n-        xl = x;\n-        xl = (TypeRelationsTest.val) x;\n-        try {\n-            xl = (TypeRelationsTest.val) xq;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-\n-        xql = x;\n-        xql = (TypeRelationsTest) x;\n-        xql = xq;\n-        xql = (TypeRelationsTest) xq;\n-        return npe;\n-    }\n-\n-    static String foo(Object o) {\n-        return \"Object\";\n-    }\n-\n-    static String foo(TypeRelationsTest.val x) {\n-        return \"TypeRelationsTest.val\";\n-    }\n-\n-    static String foo(TypeRelationsTest xq) {\n-        return \"TypeRelationsTest.ref\";\n-    }\n-\n-    public static void main(String [] args) {\n-       if (foo(new TypeRelationsTest(), new TypeRelationsTest(), false))\n-            throw new AssertionError(\"Unexpected NPE\");\n-       if (!foo(new TypeRelationsTest(), null, true))\n-            throw new AssertionError(\"Missing NPE\");\n-\n-       TypeRelationsTest.val x = new TypeRelationsTest();\n-       TypeRelationsTest xq = null;\n-       if (!foo(x).equals(\"TypeRelationsTest.val\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       if (!foo(xq).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       if (!foo((TypeRelationsTest) x).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-\n-       boolean npe = false;\n-       try  {\n-           foo((TypeRelationsTest.val) xq);\n-       } catch (NullPointerException e) {\n-            npe = true;\n-       }\n-       if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-       }\n-       xq = x;\n-       if (!foo((TypeRelationsTest) xq).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       checkArrays();\n-    }\n-\n-    static void checkArrays() {\n-        TypeRelationsTest.val [] xa = new TypeRelationsTest.val[10];\n-        TypeRelationsTest [] xqa;\n-        Object [] oa;\n-        Object o;\n-\n-        o = oa = xqa = xa;\n-        xa = (TypeRelationsTest.val []) (xqa = (TypeRelationsTest[]) (oa = (Object []) o));\n-        xa[0] = new TypeRelationsTest(); \/\/ OK, after round trip back and forth.\n-\n-\n-        xqa = (TypeRelationsTest[]) xa;\n-        boolean npe = false;\n-        try {\n-            xqa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-           throw new AssertionError(\"Missing NPE\");\n-        }\n-        npe = false;\n-\n-        oa = xa;\n-        try {\n-            oa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-           throw new AssertionError(\"Missing NPE\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/TypeRelationsTest.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @run main UnifiedPrimitiveClassBytecodeTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class UnifiedPrimitiveClassBytecodeTest {\n-\n-    public primitive class X.val {\n-\n-        X xr = null;\n-\n-        public void foo(X[] xra, X.val[] xa) {\n-            xa = new X.val[10];\n-            xra = new X[10];\n-            xra[0] = xa[0];\n-            xa[1] = xra[0];\n-            Class<?> c = X.val.class;\n-            c = X.class;\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new UnifiedPrimitiveClassBytecodeTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"UnifiedPrimitiveClassBytecodeTest$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \/\/ check field\n-        \"final UnifiedPrimitiveClassBytecodeTest$X xr;\",\n-        \"descriptor: LUnifiedPrimitiveClassBytecodeTest$X;\",\n-        \"flags: (0x0010) ACC_FINAL\",\n-\n-        \/\/ check method\n-        \"public void foo(UnifiedPrimitiveClassBytecodeTest$X[], UnifiedPrimitiveClassBytecodeTest$X[]);\",\n-        \"descriptor: ([LUnifiedPrimitiveClassBytecodeTest$X;[QUnifiedPrimitiveClassBytecodeTest$X;)V\",\n-        \" 0: bipush        10\",\n-        \" 2: anewarray     #11                 \/\/ class \\\"QUnifiedPrimitiveClassBytecodeTest$X;\\\"\",\n-        \" 5: astore_2\",\n-        \" 6: bipush        10\",\n-        \" 8: anewarray     #1                  \/\/ class UnifiedPrimitiveClassBytecodeTest$X\",\n-        \"11: astore_1\",\n-        \"12: aload_1\",\n-        \"13: iconst_0\",\n-        \"14: aload_2\",\n-        \"15: iconst_0\",\n-        \"16: aaload\",\n-        \"17: checkcast     #1                  \/\/ class UnifiedPrimitiveClassBytecodeTest$X\",\n-        \"20: aastore\",\n-        \"21: aload_2\",\n-        \"22: iconst_1\",\n-        \"23: aload_1\",\n-        \"24: iconst_0\",\n-        \"25: aaload\",\n-        \"26: checkcast     #11                 \/\/ class \\\"QUnifiedPrimitiveClassBytecodeTest$X;\\\"\",\n-        \"29: aastore\",\n-        \"30: ldc           #11                 \/\/ class \\\"QUnifiedPrimitiveClassBytecodeTest$X;\\\"\",\n-        \"32: astore_3\",\n-        \"33: ldc           #1                  \/\/ class UnifiedPrimitiveClassBytecodeTest$X\",\n-        \"35: astore_3\",\n-        \"36: return\",\n-         });\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/UnifiedPrimitiveClassBytecodeTest.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test value bootstrap methods\n- * @run main\/othervm -Dvalue.bsm.salt=1 ValueBootstrapMethodsTest\n- *\/\n-\n-import java.util.List;\n-import java.util.Objects;\n-\n-public class ValueBootstrapMethodsTest {\n-\n-    public static final primitive class Value.val {\n-        private final int i;\n-        private final double d;\n-        private final String s;\n-        private final List<String> l;\n-        Value(int i, double d, String s, String... items) {\n-            this.i = i;\n-            this.d = d;\n-            this.s = s;\n-            this.l = List.of(items);\n-        }\n-\n-        private List<Object> values() {\n-            return List.of(Value.val.class, i, d, s, l);\n-        }\n-\n-        public int localHashCode() {\n-            return values().hashCode();\n-        }\n-\n-        public String localToString() {\n-            System.out.println(l);\n-            return String.format(\"%s@%s\", Value.class.getName(), Integer.toHexString(localHashCode()));\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (obj instanceof Value) {\n-                Value v = (Value)obj;\n-                return this.i == v.i && this.d == v.d &&\n-                        Objects.equals(this.s, v.s) &&\n-                        Objects.equals(this.l, this.l);\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static void assertEquals(Object o1, Object expected) {\n-        if (!Objects.equals(o1, expected)) {\n-            throw new RuntimeException(o1 + \" expected: \" + expected);\n-        }\n-    }\n-\n-    public static void main(String... args) throws Throwable {\n-\n-        Value.val value = new Value(10, 5.03, \"foo\", \"bar\", \"goo\");\n-\n-        assertEquals(value.localHashCode(), value.hashCode());\n-        assertEquals(value.localToString(), value.toString());\n-\n-        \/\/ verify ifacmp and the overridden equals method\n-\n-        \/\/ same instance\n-        if (value != value || !value.equals(value)) {\n-            throw new RuntimeException(\"expected == and equals\");\n-        }\n-\n-        \/\/ value and v2 are of different values\n-        Value.val v2 = new Value(20, 5.03, \"foo\", \"bar\", \"goo\");\n-        if (value == v2 || value.equals(v2)) {\n-            throw new RuntimeException(\"expected != and unequals\");\n-        }\n-\n-        \/\/ v2 and v3 are of different values but Value::equals\n-        \/\/ returns true because v2::l and v3::l field contain the same elements\n-        Value.val v3 = new Value(20, 5.03, \"foo\", \"bar\", \"goo\");\n-        if (v2 == v3 || !v2.equals(v3)) {\n-            throw new RuntimeException(\"expected != and equals\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ValueBootstrapMethodsTest.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check code generation for value creation ops\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile ValueCreationTest.java\n- * @run main\/othervm -Xverify:none ValueCreationTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class ValueCreationTest {\n-\n-    primitive\n-    static final class Point.val {\n-\n-        final int x;\n-        final int y;\n-\n-        Point (int x, int y) {\n-            this.x = x;\n-            this.y = y;\n-        }\n-\n-        public static void main(String [] args) {\n-            Point.val p = new Point(10, 20);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new ValueCreationTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"ValueCreationTest$Point.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-         \"0: defaultvalue  #1                  \/\/ class ValueCreationTest$Point\",\n-         \"3: astore_2\",\n-         \"4: iload_0\",\n-         \"5: aload_2\",\n-         \"6: swap\",\n-         \"7: withfield     #3                  \/\/ Field x:I\",\n-        \"10: astore_2\",\n-        \"11: iload_1\",\n-        \"12: aload_2\",\n-        \"13: swap\",\n-        \"14: withfield     #7                  \/\/ Field y:I\",\n-        \"17: astore_2\",\n-        \"18: aload_2\",\n-        \"19: areturn\"\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ValueCreationTest.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Value types cannot parameterize generic types (except under experimental mode)\n- * @compile\/fail\/ref=ValueOverGenericsTest.out -XDrawDiagnostics ValueOverGenericsTest.java\n- *\n- *\/\n-\n-import java.util.ArrayList;\n-import java.io.Serializable;\n-\n-primitive class ValueOverGenericsTest.val {\n-    int x = 10;\n-    ArrayList<ValueOverGenericsTest.val> ax = null;\n-    void foo(ArrayList<? extends ValueOverGenericsTest.val> p) {\n-        new <ValueOverGenericsTest.val> ArrayList<Object>();\n-        this.<ValueOverGenericsTest.val>foo(null);\n-        Object o = (ValueOverGenericsTest.val & Serializable) null;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ValueOverGenericsTest.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-ValueOverGenericsTest.java:13:36: compiler.err.type.found.req: ValueOverGenericsTest.val, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:14:24: compiler.err.type.found.req: ValueOverGenericsTest.val, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:15:35: compiler.err.type.found.req: ValueOverGenericsTest.val, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:16:36: compiler.err.type.found.req: ValueOverGenericsTest.val, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:17:42: compiler.err.type.found.req: ValueOverGenericsTest.val, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:17:63: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, ValueOverGenericsTest.val&java.io.Serializable)\n-6 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ValueOverGenericsTest.out","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8251116\n- * @summary Test that values code like a class - i.e are accepted in some places where only references used be, when suitable reference projection is used.\n-   @compile  ValuesAsRefs.java\n- * @run main\/othervm ValuesAsRefs\n- *\/\n-import java.util.ArrayList;\n-\n-public final primitive class ValuesAsRefs.val {\n-\n-    final ArrayList<? extends ValuesAsRefs> ao = null; \/\/ values can be wildcard bounds.\n-\n-    final primitive class I.val implements java.io.Serializable {\n-        final int y = 42;\n-    }\n-\n-    void foo() {\n-        I.val i = this.new I();  \/\/ values can be enclosing instances.\n-        i = ValuesAsRefs.I.val.default;\n-        Object o = (I & java.io.Serializable) i; \/\/ values can be used in intersection casts\n-    }\n-    <T> void goo() {\n-        this.<ValuesAsRefs>goo(); \/\/ values can be type arguments to generic method calls\n-    }\n-\n-    public static void main(String [] args) {\n-        Object o = null;\n-        ArrayList<ValuesAsRefs.I> aloi = new ArrayList<>(); \/\/ values can be type arguments.\n-        boolean OK = false;\n-        try {\n-            aloi.add((ValuesAsRefs.I.val) o);\n-        } catch (NullPointerException npe) {\n-            OK = true;\n-        }\n-        if (!OK)\n-            throw new AssertionError(\"Missing NPE\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/ValuesAsRefs.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8206147\n- * @summary WithField operation on a private inner field should be enclosed in a suitable accessor method.\n- * @compile -XDallowWithFieldOperator WithFieldAccessorTest.java\n- * @run main\/othervm WithFieldAccessorTest\n- *\/\n-\n-public class WithFieldAccessorTest {\n-\n-    public static final primitive class V.val {\n-        private final int i;\n-        V() {\n-            this.i = 0;\n-        }\n-\n-        public static V.val make(int i) {\n-            V.val v = V.val.default;\n-            v = __WithField(v.i, i);\n-            return v;\n-        }\n-    }\n-\n-    public static void main(String... args) throws Throwable {\n-        V.val v = __WithField(V.make(10).i, 20);\n-        if (v.i != 20)\n-            throw new AssertionError(\"Withfield didn't work!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldAccessorTest.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check code generation for value creation ops\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDallowWithFieldOperator WithFieldOfExplicitSelector.java\n- * @run main\/othervm -Xverify:none WithFieldOfExplicitSelector\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class WithFieldOfExplicitSelector {\n-\n-    final primitive class X.val {\n-\n-        final int i;\n-\n-        X() {\n-            i = 10;\n-        }\n-        \n-        X.val getX(int i, Integer in) {\n-            X.val xl = __WithField(this.i, i);\n-            xl = __WithField(xl.i, in);\n-            return xl;\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new WithFieldOfExplicitSelector().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"WithFieldOfExplicitSelector$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-         \"0: iload_1\",\n-         \"1: aload_0\",\n-         \"2: swap\",\n-         \"3: withfield     #7                  \/\/ Field i:I\",\n-         \"6: astore_3\",\n-         \"7: aload_2\",\n-         \"8: invokevirtual #11                 \/\/ Method java\/lang\/Integer.intValue:()I\",\n-        \"11: aload_3\",\n-        \"12: swap\",\n-        \"13: withfield     #7                  \/\/ Field i:I\",\n-        \"16: astore_3\",\n-        \"17: aload_3\",\n-        \"18: areturn\"\n-         });\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldOfExplicitSelector.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDrawDiagnostics -XDdev -XDallowWithFieldOperator WithFieldOfGenericType.java\n- * @run main\/othervm WithFieldOfGenericType\n- *\/\n-\n-public final primitive class WithFieldOfGenericType.val<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType.val<E> create() {\n-    WithFieldOfGenericType.val<E> bug = WithFieldOfGenericType.val.default;\n-    bug = __WithField(bug.value, true);\n-    return bug;\n-  }\n-\n-  private WithFieldOfGenericType() {\n-    value = false;\n-    throw new AssertionError();\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType.val<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldOfGenericType.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check code generation for value creation ops\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDallowWithFieldOperator WithFieldOfImplicitThis.java\n- * @run main\/othervm -Xverify:none WithFieldOfImplicitThis\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class WithFieldOfImplicitThis {\n-\n-    final primitive class X.val {\n-\n-        final int x;\n-\n-        X() {\n-            x = 10;\n-        }\n-        \n-        X.val getX(Integer xVal, int xi) {\n-            X.val xl = X.val.default;\n-            xl = __WithField(x, xi);\n-            xl = __WithField(x, xVal);\n-            return xl;\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new WithFieldOfImplicitThis().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"WithFieldOfImplicitThis$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-         \"0: defaultvalue  #1                  \/\/ class WithFieldOfImplicitThis$X\",\n-         \"3: astore_3\",\n-         \"4: aload_0\",\n-         \"5: iload_2\",\n-         \"6: withfield     #7                  \/\/ Field x:I\",\n-         \"9: astore_3\",\n-        \"10: aload_0\",\n-        \"11: aload_1\",\n-        \"12: invokevirtual #11                 \/\/ Method java\/lang\/Integer.intValue:()I\",\n-        \"15: withfield     #7                  \/\/ Field x:I\",\n-        \"18: astore_3\",\n-        \"19: aload_3\",\n-        \"20: areturn\"\n-         });\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldOfImplicitThis.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Verify that various errors related to __WithField operator are caught.\n- * @compile\/fail\/ref=WithFieldOperatorTest.out -XDallowWithFieldOperator -XDrawDiagnostics -XDdev WithFieldOperatorTest.java\n- *\/\n-\n-public class WithFieldOperatorTest {\n-    static int xs;\n-    int ifld;\n-    class Y {}\n-    public final primitive class V.val { int x = 10; }\n-\n-    public final primitive class X.val {\n-\n-        final int x;\n-        final V.val v;\n-\n-        X() {\n-            x = 10;\n-            v = V.val.default;\n-        }\n-\n-        X.val getX(int xVal, WithFieldOperatorTest wfot) {\n-            X.val x = X.val.default;\n-            x = __WithField(new Y(), null);  \/\/ not a variable at all.\n-            x = __WithField(wfot.xs, 10); \/\/ not an instance field.\n-            x = __WithField(wfot.ifld, 10); \/\/ not a field of value type\n-            x = __WithField(xVal, xVal); \/\/ not a field\n-            x = __WithField(this, this); \/\/ not a field\n-            x = __WithField(X.this, this); \/\/ not a field\n-            x = __WithField(x.x, 12.0); \/\/ float cannot be assigned to int\n-            x = __WithField(x.v, null); \/\/ null cannot be assigned to value\n-            return x;\n-        }\n-    }\n-}\n-\n-class WithFieldOperatorTest_aux {\n-    void foo(WithFieldOperatorTest.X.val x) {\n-        x = __WithField(x.x, 10); \/\/ outside the nest\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldOperatorTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-WithFieldOperatorTest.java:25:29: compiler.err.unexpected.type: kindname.variable, kindname.value\n-WithFieldOperatorTest.java:26:33: compiler.err.primitive.class.instance.field.expected.here\n-WithFieldOperatorTest.java:27:33: compiler.err.primitive.class.instance.field.expected.here\n-WithFieldOperatorTest.java:28:29: compiler.err.primitive.class.instance.field.expected.here\n-WithFieldOperatorTest.java:29:29: compiler.err.cant.assign.val.to.this\n-WithFieldOperatorTest.java:30:30: compiler.err.cant.assign.val.to.this\n-WithFieldOperatorTest.java:31:34: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, int)\n-WithFieldOperatorTest.java:32:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, WithFieldOperatorTest.V.val)\n-WithFieldOperatorTest.java:40:26: compiler.err.cant.assign.val.to.final.var: x\n-9 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldOperatorTest.out","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test withfield behavior at runtime.\n- * @compile -XDallowWithFieldOperator WithFieldRuntimeTest.java\n- * @run main\/othervm WithFieldRuntimeTest\n- *\/\n-\n-public final primitive class WithFieldRuntimeTest.val {\n-\n-    final int x = 10;\n-\n-    static void foo(WithFieldRuntimeTest.val x) {\n-        if (x.x != 0)\n-            throw new AssertionError(\"Expected default value, found something else.\");\n-        x = __WithField(x.x, 20);\n-        if (x.x != 20)\n-            throw new AssertionError(\"Expected updated value, found something else.\");\n-    }\n-\n-    public static void main(String [] args) {\n-        WithFieldRuntimeTest.val x = WithFieldRuntimeTest.val.default;\n-        foo(x);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDefault\/WithFieldRuntimeTest.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-    static primitive class RefDefault.val {}\n@@ -40,12 +39,0 @@\n-        if (RefDefault.class != new RefDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (RefDefault.ref.class != new RefDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (RefDefault.val.class != new RefDefault().getClass().asValueType()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n@@ -64,12 +51,0 @@\n-        if (TestReflectiveMirrors.RefDefault.class != new RefDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.RefDefault.ref.class != new RefDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.RefDefault.val.class != new RefDefault().getClass().asValueType()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TestReflectiveMirrors.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8271583\n- * @summary [lworld] primitive records can't be reference favoring\n- * @run main\/othervm RefFlavoredRecord\n- *\/\n-\n-public primitive record RefFlavoredRecord.val(int theInteger, String theString) {\n-    public static void main(String[] args) {\n-        RefFlavoredRecord rec = RefFlavoredRecord.default;\n-        if (rec != null) {\n-            throw new AssertionError(\"Ref-favoring record .default should be null?\");\n-        }\n-\n-        if (! new RefFlavoredRecord(42, \"Fortytwo\").equals(new RefFlavoredRecord(42, \"Fortytwo\"))) {\n-            throw new AssertionError(\"Records should be equal\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/records\/RefFlavoredRecord.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"}]}