{"files":[{"patch":"@@ -608,0 +608,1 @@\n+        if (!isPrimitiveClass()) return Optional.of(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -142,1 +142,3 @@\n-            defc.getDeclaredMethod(name, params);\n+            \/\/ TODO: methods are in the reference projection\n+            Class<?> declaringClass = defc \/* defc.referenceType().get() *\/;\n+            declaringClass.getDeclaredMethod(name, params);\n","filename":"test\/jdk\/valhalla\/valuetypes\/QTypeDescriptorTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -36,0 +37,1 @@\n+import java.lang.reflect.Modifier;\n@@ -55,1 +57,4 @@\n-        test.staticField();\n+        test.checkStaticField(\"STATIC_FIELD\", Object.class);\n+        \/\/ TODO: static field is in the reference projection\n+        Class<?> declaringClass = Point.class;\n+        test.testSetAccessible(declaringClass.getDeclaredField(\"STATIC_FIELD\"));\n@@ -62,4 +67,4 @@\n-        test.checkField(\"public final Point Line.p1\", \"p1\", Point.class);\n-        test.checkField(\"public final Point Line.p2\", \"p2\", Point.class);\n-        test.checkMethod(\"public Point Line.p1()\",           \"p1\", Point.class);\n-        test.checkMethod(\"public Point Line.p2()\",           \"p2\", Point.class);\n+        test.checkInstanceField(\"p1\", Point.class);\n+        test.checkInstanceField(\"p2\", Point.class);\n+        test.checkInstanceMethod(\"p1\", Point.class);\n+        test.checkInstanceMethod(\"p2\", Point.class);\n@@ -72,4 +77,4 @@\n-        test.checkField(\"final Point$ref NonFlattenValue.nfp\", \"nfp\", Point.ref.class);\n-        test.checkMethod(\"public Point NonFlattenValue.pointValue()\", \"pointValue\", Point.class);\n-        test.checkMethod(\"public Point$ref NonFlattenValue.point()\", \"point\", Point.ref.class);\n-        test.checkMethod(\"public boolean NonFlattenValue.has(Point,Point$ref)\", \"has\", boolean.class, Point.class, Point.ref.class);\n+        test.checkInstanceField(\"nfp\", Point.ref.class);\n+        test.checkInstanceMethod(\"pointValue\", Point.class);\n+        test.checkInstanceMethod(\"point\", Point.ref.class);\n+        test.checkInstanceMethod(\"has\", boolean.class, Point.class, Point.ref.class);\n@@ -201,2 +206,1 @@\n-    void staticField() throws Exception {\n-        Field f = c.getDeclaredField(\"STATIC_FIELD\");\n+    void testSetAccessible(Field f) throws Exception {\n@@ -207,1 +211,4 @@\n-    void checkField(String source, String name, Class<?> type) throws Exception {\n+    \/*\n+     * Fields are in the value projection\n+     *\/\n+    void checkInstanceField(String name, Class<?> type) throws Exception {\n@@ -209,2 +216,50 @@\n-        assertEquals(f.getType(), type);\n-        assertEquals(f.toString(), source);\n+        assertTrue(f.getType() == type);\n+        checkToString(f);\n+    }\n+\n+    \/*\n+     * Static members are in the reference projection\n+     *\/\n+    void checkStaticField(String name, Class<?> type) throws Exception {\n+        Class<?> declaringClass = c;\n+        \/\/ TODO: methods are in the reference projection\n+        \/\/ Class<?> declaringClass = c.referenceType().get();\n+        Field f = declaringClass.getDeclaredField(name);\n+        assertTrue(f.getType() == type);\n+        checkToString(f);\n+    }\n+\n+    \/*\n+     * Methods are in the reference projection\n+     *\/\n+    void checkInstanceMethod(String name, Class<?> returnType, Class<?>... params) throws Exception {\n+        Class<?> declaringClass = c;\n+        \/\/ TODO: methods are in the reference projection\n+        \/\/ Class<?> declaringClass = c.referenceType().get();\n+        Method m = declaringClass.getDeclaredMethod(name, params);\n+        assertTrue(m.getReturnType() == returnType);\n+        checkToString(m);\n+    }\n+\n+    void checkToString(Field f) {\n+        StringBuilder sb = new StringBuilder();\n+        int mods = f.getModifiers();\n+        if (Modifier.isPublic(mods)) {\n+            sb.append(\"public\").append(\" \");\n+        }\n+        if (Modifier.isStatic(mods)) {\n+            sb.append(\"static\").append(\" \");\n+        }\n+        if (Modifier.isFinal(mods)) {\n+            sb.append(\"final\").append(\" \");\n+        }\n+        \/\/ instance fields are in the value projection\n+        \/\/ whereas static fields are in the reference projection\n+        Class<?> declaringClass = c;\n+        \/\/ TODO: static members are in the reference projection\n+        \/\/ if (Modifier.isStatic(mods)) {\n+        \/\/    declaringClass = c.referenceType().get();\n+        \/\/ }\n+        sb.append(displayName(f.getType())).append(\" \");\n+        sb.append(declaringClass.getName()).append(\".\").append(f.getName());\n+        assertEquals(f.toString(), sb.toString());\n@@ -213,3 +268,35 @@\n-    void checkMethod(String source, String name, Class<?> returnType, Class<?>... params) throws Exception {\n-        Method m = c.getDeclaredMethod(name, params);\n-        assertEquals(m.toString(), source);\n+    void checkToString(Method m) {\n+        StringBuilder sb = new StringBuilder();\n+        int mods = m.getModifiers();\n+        if (Modifier.isPublic(mods)) {\n+            sb.append(\"public\").append(\" \");\n+        }\n+        if (Modifier.isStatic(mods)) {\n+            sb.append(\"static\").append(\" \");\n+        }\n+        if (Modifier.isFinal(mods)) {\n+            sb.append(\"final\").append(\" \");\n+        }\n+        sb.append(displayName(m.getReturnType())).append(\" \");\n+        \/\/ TODO: methods are in the reference projection\n+        \/\/ Class<?> declaringClass = c.referenceType().get();\n+        Class<?> declaringClass = c;\n+        sb.append(declaringClass.getName()).append(\".\").append(m.getName());\n+        sb.append(\"(\");\n+        int count = m.getParameterCount();\n+        for (Class<?> ptype : m.getParameterTypes()) {\n+            sb.append(displayName(ptype));\n+            if (--count > 0) {\n+                sb.append(\",\");\n+            }\n+        }\n+        sb.append(\")\");\n+        assertEquals(m.toString(), sb.toString());\n+    }\n+\n+    static String displayName(Class<?> type) {\n+        if (type.isPrimitive()) {\n+            ClassDesc classDesc = type.describeConstable().get();\n+            return classDesc.displayName();\n+        }\n+        return type.getName();\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":104,"deletions":17,"binary":false,"changes":121,"status":"modified"}]}