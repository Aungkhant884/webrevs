{"files":[{"patch":"@@ -70,0 +70,1 @@\n+ * input.build_osenv_version\n@@ -1091,3 +1092,17 @@\n-    var makeBinDir = (input.build_os == \"windows\"\n-        ? input.get(\"gnumake\", \"install_path\") + \"\/cygwin\/bin\"\n-        : input.get(\"gnumake\", \"install_path\") + \"\/bin\");\n+    var makeRevision = \"4.0+1.0\";\n+    var makeBinSubDir = \"\/bin\";\n+    var makeModule = \"gnumake-\" + input.build_platform;\n+    if (input.build_os == \"windows\") {\n+        makeModule = \"gnumake-\" + input.build_osenv_platform;\n+        if (input.build_osenv == \"cygwin\") {\n+            var versionArray = input.build_osenv_version.split(\/\\.\/);\n+            var majorVer = parseInt(versionArray[0]);\n+            var minorVer = parseInt(versionArray[1]);\n+            if (majorVer > 3 || (majorVer == 3 && minorVer >= 3)) {\n+                makeRevision = \"4.3+1.0\";\n+            } else {\n+                makeBinSubDir = \"\/cygwin\/bin\";\n+            }\n+        }\n+    }\n+    var makeBinDir = input.get(\"gnumake\", \"install_path\") + makeBinSubDir;\n@@ -1158,6 +1173,2 @@\n-            revision: \"4.0+1.0\",\n-\n-            module: (input.build_os == \"windows\"\n-                ? \"gnumake-\" + input.build_osenv_platform\n-                : \"gnumake-\" + input.build_platform),\n-\n+            revision: makeRevision,\n+            module: makeModule,\n@@ -1165,1 +1176,0 @@\n-\n@@ -1169,1 +1179,0 @@\n-\n","filename":"make\/conf\/jib-profiles.js","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -4947,1 +4947,1 @@\n-  \/\/match(iRegP_R5);\n+  match(iRegP_R5);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1281,4 +1281,65 @@\n-\/\/ defined in stubGenerator_aarch64.cpp\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n+\/\/ on exit, sp points to the ContinuationEntry\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  stack_slots += (int)ContinuationEntry::size()\/wordSize;\n+  __ sub(sp, sp, (int)ContinuationEntry::size()); \/\/ place Continuation metadata\n+\n+  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize)\/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+  __ str(rscratch1, Address(sp, ContinuationEntry::parent_offset()));\n+  __ mov(rscratch1, sp); \/\/ we can't use sp as the source in str\n+  __ str(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+\n+  return map;\n+}\n+\n+\/\/ on entry c_rarg1 points to the continuation\n+\/\/          sp points to ContinuationEntry\n+\/\/          c_rarg3 -- isVirtualThread\n+static void fill_continuation_entry(MacroAssembler* masm) {\n+#ifdef ASSERT\n+  __ movw(rscratch1, ContinuationEntry::cookie_value());\n+  __ strw(rscratch1, Address(sp, ContinuationEntry::cookie_offset()));\n+#endif\n+\n+  __ str (c_rarg1, Address(sp, ContinuationEntry::cont_offset()));\n+  __ strw(c_rarg3, Address(sp, ContinuationEntry::flags_offset()));\n+  __ str (zr,      Address(sp, ContinuationEntry::chunk_offset()));\n+  __ strw(zr,      Address(sp, ContinuationEntry::argsize_offset()));\n+  __ strw(zr,      Address(sp, ContinuationEntry::pin_count_offset()));\n+\n+  __ ldr(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n+  __ str(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n+  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n+\n+  __ str(zr, Address(rthread, JavaThread::cont_fastpath_offset()));\n+  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n+}\n+\n+\/\/ on entry, sp points to the ContinuationEntry\n+\/\/ on exit, rfp points to the spilled rfp in the entry frame\n+static void continuation_enter_cleanup(MacroAssembler* masm) {\n+#ifndef PRODUCT\n+  Label OK;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+  __ cmp(sp, rscratch1);\n+  __ br(Assembler::EQ, OK);\n+  __ stop(\"incorrect sp1\");\n+  __ bind(OK);\n+#endif\n+\n+  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ str(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n+  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n+  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  __ ldr(rscratch2, Address(sp, ContinuationEntry::parent_offset()));\n+  __ str(rscratch2, Address(rthread, JavaThread::cont_entry_offset()));\n+  __ add(rfp, sp, (int)ContinuationEntry::size());\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -79,4 +79,0 @@\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -8198,72 +8194,0 @@\n-\n-\n-#undef __\n-#define __ masm->\n-\n-\/\/ on exit, sp points to the ContinuationEntry\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n-  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n-\n-  stack_slots += (int)ContinuationEntry::size()\/wordSize;\n-  __ sub(sp, sp, (int)ContinuationEntry::size()); \/\/ place Continuation metadata\n-\n-  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize)\/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n-  ContinuationEntry::setup_oopmap(map);\n-\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_offset()));\n-  __ mov(rscratch1, sp); \/\/ we can't use sp as the source in str\n-  __ str(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-\n-  return map;\n-}\n-\n-\/\/ on entry c_rarg1 points to the continuation\n-\/\/          sp points to ContinuationEntry\n-\/\/          c_rarg3 -- isVirtualThread\n-void fill_continuation_entry(MacroAssembler* masm) {\n-#ifdef ASSERT\n-  __ movw(rscratch1, ContinuationEntry::cookie_value());\n-  __ strw(rscratch1, Address(sp, ContinuationEntry::cookie_offset()));\n-#endif\n-\n-  __ str (c_rarg1, Address(sp, ContinuationEntry::cont_offset()));\n-  __ strw(c_rarg3, Address(sp, ContinuationEntry::flags_offset()));\n-  __ str (zr,      Address(sp, ContinuationEntry::chunk_offset()));\n-  __ strw(zr,      Address(sp, ContinuationEntry::argsize_offset()));\n-  __ strw(zr,      Address(sp, ContinuationEntry::pin_count_offset()));\n-\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-\n-  __ str(zr, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-\/\/ on entry, sp points to the ContinuationEntry\n-\/\/ on exit, rfp points to the spilled rfp in the entry frame\n-void continuation_enter_cleanup(MacroAssembler* masm) {\n-#ifndef PRODUCT\n-  Label OK;\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ cmp(sp, rscratch1);\n-  __ br(Assembler::EQ, OK);\n-  __ stop(\"incorrect sp1\");\n-  __ bind(OK);\n-#endif\n-\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-  __ ldr(rscratch2, Address(sp, ContinuationEntry::parent_offset()));\n-  __ str(rscratch2, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ add(rfp, sp, (int)ContinuationEntry::size());\n-}\n-\n-#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2054,4 +2054,0 @@\n-\n-  OopMap* continuation_enter_setup(int& stack_slots);\n-  void fill_continuation_entry(Register reg_cont_obj, Register reg_flags);\n-  void continuation_enter_cleanup();\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1553,0 +1553,94 @@\n+\n+\/\/---------------------------- continuation_enter_setup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   None.\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to blank ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n+  __ subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n+\n+  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n+  OopMap* map = new OopMap(frame_size, 0);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  __ movptr(rax, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  __ movptr(Address(rsp, ContinuationEntry::parent_offset()), rax);\n+  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rsp);\n+\n+  return map;\n+}\n+\n+\/\/---------------------------- fill_continuation_entry ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to blank Continuation entry\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to filled out ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n+static void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(rax, reg_cont_obj, reg_flags);\n+#ifdef ASSERT\n+  __ movl(Address(rsp, ContinuationEntry::cookie_offset()), ContinuationEntry::cookie_value());\n+#endif\n+  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n+  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n+  __ movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n+  __ movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n+  __ movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n+\n+  __ movptr(rax, Address(r15_thread, JavaThread::cont_fastpath_offset()));\n+  __ movptr(Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()), rax);\n+  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n+  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n+\n+  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), 0);\n+  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n+}\n+\n+\/\/---------------------------- continuation_enter_cleanup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to the ContinuationEntry\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to the spilled rbp in the entry frame\n+\/\/\n+\/\/ Kills:\n+\/\/   rbx\n+\/\/\n+void static continuation_enter_cleanup(MacroAssembler* masm) {\n+#ifdef ASSERT\n+  Label L_good_sp;\n+  __ cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  __ jcc(Assembler::equal, L_good_sp);\n+  __ stop(\"Incorrect rsp at continuation_enter_cleanup\");\n+  __ bind(L_good_sp);\n+#endif\n+\n+  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), rbx);\n+  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n+  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n+\n+  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n+  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n+  __ addptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n+}\n+\n@@ -1612,1 +1706,1 @@\n-    OopMap* map = __ continuation_enter_setup(stack_slots);\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n@@ -1618,1 +1712,1 @@\n-    __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n@@ -1647,1 +1741,1 @@\n-  OopMap* map = __ continuation_enter_setup(stack_slots);\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n@@ -1654,1 +1748,1 @@\n-  __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n+  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n@@ -1697,1 +1791,1 @@\n-  __ continuation_enter_cleanup();\n+  continuation_enter_cleanup(masm);\n@@ -1705,1 +1799,1 @@\n-  __ continuation_enter_cleanup();\n+  continuation_enter_cleanup(masm);\n@@ -1769,1 +1863,1 @@\n-  __ continuation_enter_cleanup();\n+  continuation_enter_cleanup(masm);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":101,"deletions":7,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2994,0 +2994,16 @@\n+  \/\/ Protection key features.\n+  if (_cpuid_info.sef_cpuid7_ecx.bits.pku != 0) {\n+    result |= CPU_PKU;\n+  }\n+  if (_cpuid_info.sef_cpuid7_ecx.bits.ospke != 0) {\n+    result |= CPU_OSPKE;\n+  }\n+\n+  \/\/ Control flow enforcement (CET) features.\n+  if (_cpuid_info.sef_cpuid7_ecx.bits.cet_ss != 0) {\n+    result |= CPU_CET_SS;\n+  }\n+  if (_cpuid_info.sef_cpuid7_edx.bits.cet_ibt != 0) {\n+    result |= CPU_CET_IBT;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -462,0 +462,4 @@\n+    _consts.initialize_outer(this, SECT_CONSTS);\n+    _insts.initialize_outer(this,  SECT_INSTS);\n+    _stubs.initialize_outer(this,  SECT_STUBS);\n+\n@@ -476,3 +480,0 @@\n-    _consts.initialize_outer(this,  SECT_CONSTS);\n-    _insts.initialize_outer(this,   SECT_INSTS);\n-    _stubs.initialize_outer(this,   SECT_STUBS);\n@@ -762,1 +763,1 @@\n-  if (CodeBuffer::SECT_STUBS) {\n+  if (section == CodeBuffer::SECT_STUBS) {\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2259,1 +2259,1 @@\n-  assert(expected == obj_args->max_length() || real_target->is_method_handle_intrinsic(), \"missed on arg?\");\n+  assert(expected == obj_args->capacity() || real_target->is_method_handle_intrinsic(), \"missed on arg?\");\n@@ -2270,1 +2270,1 @@\n-  int s = obj_args->max_length();\n+  int s = obj_args->capacity();\n@@ -4366,1 +4366,1 @@\n-        int s = obj_args->max_length();\n+        int s = obj_args->capacity();\n@@ -4368,1 +4368,1 @@\n-        for (int i = args_base+start, j = 0; j < obj_args->max_length() && i < state()->stack_size(); ) {\n+        for (int i = args_base+start, j = 0; j < obj_args->capacity() && i < state()->stack_size(); ) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-                                                 do_stub(opAllocObj->_stub);\n+      if (opAllocObj->_stub != nullptr)          do_stub(opAllocObj->_stub);\n@@ -874,1 +874,1 @@\n-                                                  do_stub(opTypeCheck->_stub);\n+      if (opTypeCheck->_stub != nullptr)          do_stub(opTypeCheck->_stub);\n@@ -886,1 +886,2 @@\n-                                                     do_stub(opFlattenedArrayCheck->_stub);\n+\n+      do_stub(opFlattenedArrayCheck->_stub);\n@@ -918,2 +919,3 @@\n-                                                                do_info(opSubstitutabilityCheck->_info);\n-                                                                do_stub(opSubstitutabilityCheck->_stub);\n+\n+      do_info(opSubstitutabilityCheck->_info);\n+      do_stub(opSubstitutabilityCheck->_stub);\n@@ -928,1 +930,1 @@\n-      LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;\n+      LIR_OpCompareAndSwap* opCmpAndSwap = (LIR_OpCompareAndSwap*)op;\n@@ -930,13 +932,10 @@\n-      assert(opCompareAndSwap->_addr->is_valid(),      \"used\");\n-      assert(opCompareAndSwap->_cmp_value->is_valid(), \"used\");\n-      assert(opCompareAndSwap->_new_value->is_valid(), \"used\");\n-      if (opCompareAndSwap->_info)                    do_info(opCompareAndSwap->_info);\n-                                                      do_input(opCompareAndSwap->_addr);\n-                                                      do_temp(opCompareAndSwap->_addr);\n-                                                      do_input(opCompareAndSwap->_cmp_value);\n-                                                      do_temp(opCompareAndSwap->_cmp_value);\n-                                                      do_input(opCompareAndSwap->_new_value);\n-                                                      do_temp(opCompareAndSwap->_new_value);\n-      if (opCompareAndSwap->_tmp1->is_valid())        do_temp(opCompareAndSwap->_tmp1);\n-      if (opCompareAndSwap->_tmp2->is_valid())        do_temp(opCompareAndSwap->_tmp2);\n-      if (opCompareAndSwap->_result->is_valid())      do_output(opCompareAndSwap->_result);\n+      if (opCmpAndSwap->_info)                              do_info(opCmpAndSwap->_info);\n+      assert(opCmpAndSwap->_addr->is_valid(), \"used\");      do_input(opCmpAndSwap->_addr);\n+                                                            do_temp(opCmpAndSwap->_addr);\n+      assert(opCmpAndSwap->_cmp_value->is_valid(), \"used\"); do_input(opCmpAndSwap->_cmp_value);\n+                                                            do_temp(opCmpAndSwap->_cmp_value);\n+      assert(opCmpAndSwap->_new_value->is_valid(), \"used\"); do_input(opCmpAndSwap->_new_value);\n+                                                            do_temp(opCmpAndSwap->_new_value);\n+      if (opCmpAndSwap->_tmp1->is_valid())                  do_temp(opCmpAndSwap->_tmp1);\n+      if (opCmpAndSwap->_tmp2->is_valid())                  do_temp(opCmpAndSwap->_tmp2);\n+      if (opCmpAndSwap->_result->is_valid())                do_output(opCmpAndSwap->_result);\n@@ -954,2 +953,6 @@\n-      if (opAllocArray->_klass->is_valid())           do_input(opAllocArray->_klass); do_temp(opAllocArray->_klass);\n-      if (opAllocArray->_len->is_valid())             do_input(opAllocArray->_len);   do_temp(opAllocArray->_len);\n+      if (opAllocArray->_klass->is_valid()) {         do_input(opAllocArray->_klass);\n+                                                      do_temp(opAllocArray->_klass);\n+                                            }\n+      if (opAllocArray->_len->is_valid())   {         do_input(opAllocArray->_len);\n+                                                      do_temp(opAllocArray->_len);\n+                                            }\n@@ -961,1 +964,1 @@\n-                                                      do_stub(opAllocArray->_stub);\n+      if (opAllocArray->_stub != nullptr)             do_stub(opAllocArray->_stub);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":25,"deletions":22,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+  size_t longest_common_prefix_size = 0;\n@@ -289,0 +290,4 @@\n+  ResourceMark rm;\n+  GrowableArray<const char*>* app_cp_array = create_dumptime_app_classpath_array();\n+  int len = app_cp_array->length();\n+  longest_common_prefix_size = longest_common_app_classpath_prefix_len(len, app_cp_array);\n@@ -295,1 +300,2 @@\n-                    base_archive_name_offset);\n+                    base_archive_name_offset,\n+                    longest_common_prefix_size);\n@@ -300,1 +306,1 @@\n-                             size_t base_archive_name_offset) {\n+                             size_t base_archive_name_offset, size_t common_app_classpath_prefix_size) {\n@@ -307,0 +313,1 @@\n+  set_common_app_classpath_prefix_size((unsigned int)common_app_classpath_prefix_size);\n@@ -380,0 +387,1 @@\n+  st->print_cr(\"- common_app_classpath_size:      \" UINT32_FORMAT, common_app_classpath_prefix_size());\n@@ -878,0 +886,11 @@\n+GrowableArray<const char*>* FileMapInfo::create_dumptime_app_classpath_array() {\n+  Arguments::assert_is_dumping_archive();\n+  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n+  ClassPathEntry* cpe = ClassLoader::app_classpath_entries();\n+  while (cpe != NULL) {\n+    path_array->append(cpe->name());\n+    cpe = cpe->next();\n+  }\n+  return path_array;\n+}\n+\n@@ -912,1 +931,23 @@\n-bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray<const char*>* rp_array) {\n+unsigned int FileMapInfo::longest_common_app_classpath_prefix_len(int num_paths,\n+                                                                  GrowableArray<const char*>* rp_array) {\n+  if (num_paths == 0) {\n+    return 0;\n+  }\n+  unsigned int pos;\n+  for (pos = 0; ; pos++) {\n+    for (int i = 0; i < num_paths; i++) {\n+      if (rp_array->at(i)[pos] != '\\0' && rp_array->at(i)[pos] == rp_array->at(0)[pos]) {\n+        continue;\n+      }\n+\n+      \/\/ search backward for the pos before the file separator char\n+      while (pos > 0 && rp_array->at(0)[--pos] != *os::file_separator());\n+      \/\/ return the file separator char position\n+      return pos + 1;\n+    }\n+  }\n+  return 0;\n+}\n+\n+bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray<const char*>* rp_array,\n+                              unsigned int dumptime_prefix_len, unsigned int runtime_prefix_len) {\n@@ -915,2 +956,1 @@\n-  bool mismatch = false;\n-  while (i < num_paths && !mismatch) {\n+  while (i < num_paths) {\n@@ -922,2 +962,6 @@\n-    if (!os::same_files(shared_path(j)->name(), rp_array->at(i))) {\n-      mismatch = true;\n+    assert(strlen(shared_path(j)->name()) > (size_t)dumptime_prefix_len, \"sanity\");\n+    const char* dumptime_path = shared_path(j)->name() + dumptime_prefix_len;\n+    assert(strlen(rp_array->at(i)) > (size_t)runtime_prefix_len, \"sanity\");\n+    const char* runtime_path = rp_array->at(i)  + runtime_prefix_len;\n+    if (!os::same_files(dumptime_path, runtime_path)) {\n+      return true;\n@@ -928,1 +972,1 @@\n-  return mismatch;\n+  return false;\n@@ -982,1 +1026,1 @@\n-      mismatch = check_paths(1, num, rp_array);\n+      mismatch = check_paths(1, num, rp_array, 0, 0);\n@@ -1031,1 +1075,1 @@\n-    mismatch = check_paths(j, shared_app_paths_len, rp_array);\n+    mismatch = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n@@ -1033,1 +1077,12 @@\n-      return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n+      \/\/ To facilitate app deployment, we allow the JAR files to be moved *together* to\n+      \/\/ a different location, as long as they are still stored under the same directory\n+      \/\/ structure. E.g., the following is OK.\n+      \/\/     java -Xshare:dump -cp \/a\/Foo.jar:\/a\/b\/Bar.jar  ...\n+      \/\/     java -Xshare:auto -cp \/x\/y\/Foo.jar:\/x\/y\/b\/Bar.jar  ...\n+      unsigned int dumptime_prefix_len = header()->common_app_classpath_prefix_size();\n+      unsigned int runtime_prefix_len = longest_common_app_classpath_prefix_len(shared_app_paths_len, rp_array);\n+      mismatch = check_paths(j, shared_app_paths_len, rp_array,\n+                             dumptime_prefix_len, runtime_prefix_len);\n+      if (mismatch) {\n+        return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n+      }\n@@ -1061,1 +1116,1 @@\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array);\n+  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array, 0, 0);\n@@ -1275,0 +1330,4 @@\n+    if (!check_common_app_classpath_prefix_len()) {\n+      return false;\n+    }\n+\n@@ -1352,0 +1411,10 @@\n+\n+    return true;\n+  }\n+\n+  bool check_common_app_classpath_prefix_len() {\n+    int common_path_size = _header->_common_app_classpath_prefix_size;\n+    if (common_path_size < 0) {\n+      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n+      return false;\n+    }\n@@ -1434,2 +1503,3 @@\n-      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, base_offset);\n+      log_info(cds)(\"common_app_classpath_size: \" UINT32_FORMAT, header()->common_app_classpath_prefix_size());\n+      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n+      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":84,"deletions":14,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -278,0 +278,1 @@\n+  unsigned int common_app_classpath_prefix_size() const { return _generic_header._common_app_classpath_prefix_size; }\n@@ -285,0 +286,1 @@\n+  void set_common_app_classpath_prefix_size(unsigned int s) { _generic_header._common_app_classpath_prefix_size = s; }\n@@ -344,1 +346,2 @@\n-                size_t base_archive_name_size, size_t base_archive_name_offset);\n+                size_t base_archive_name_size, size_t base_archive_name_offset,\n+                size_t common_app_classpath_size);\n@@ -593,0 +596,1 @@\n+  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(NULL);\n@@ -595,0 +599,3 @@\n+  unsigned int longest_common_app_classpath_prefix_len(int num_paths,\n+                                                       GrowableArray<const char*>* rp_array)\n+                                                       NOT_CDS_RETURN_(0);\n@@ -596,1 +603,3 @@\n-                    GrowableArray<const char*>* rp_array) NOT_CDS_RETURN_(false);\n+                    GrowableArray<const char*>* rp_array,\n+                    unsigned int dumptime_prefix_len,\n+                    unsigned int runtime_prefix_len) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -639,7 +640,1 @@\n-\n-  if (DumpSharedSpaces) {\n-    \/\/ The following function is used to resolve all Strings in the statically\n-    \/\/ dumped classes to archive all the Strings. The archive heap is not supported\n-    \/\/ for the dynamic archive.\n-    ik->constants()->resolve_class_constants(CHECK_(false)); \/\/ may throw OOM when interning strings.\n-  }\n+  ClassPrelinker::dumptime_resolve_constants(ik, CHECK_(false));\n@@ -650,0 +645,2 @@\n+  ClassPrelinker::initialize();\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3926,1 +3926,3 @@\n-  if (!ik->is_initialized())  ik->initialize(CHECK_NULL);\n+  if (!ik->is_initialized()) {\n+    ik->initialize(CHECK_NULL);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2096,1 +2096,4 @@\n-  if (PrintCompilation) {\n+  elapsedTimer time;\n+\n+  DirectiveSet* directive = task->directive();\n+  if (directive->PrintCompilationOption) {\n@@ -2100,1 +2103,0 @@\n-  elapsedTimer time;\n@@ -2117,2 +2119,0 @@\n-\n-  DirectiveSet* directive;\n@@ -2125,4 +2125,1 @@\n-    assert(!method->is_native(), \"no longer compile natives\");\n-    \/\/ Look up matching directives\n-    directive = DirectivesStack::getMatchingDirective(method, comp);\n-    task->set_directive(directive);\n+    assert(!method->is_native(), \"no longer compile natives\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -36,0 +38,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n@@ -41,0 +44,1 @@\n+\/\/ Prints the current bytecode and its attributes using bytecode-specific information.\n@@ -42,4 +46,1 @@\n-\/\/ Standard closure for BytecodeTracer: prints the current bytecode\n-\/\/ and its attributes using bytecode-specific information.\n-\n-class BytecodePrinter: public BytecodeClosure {\n+class BytecodePrinter {\n@@ -55,0 +56,1 @@\n+  int       _flags;\n@@ -72,9 +74,13 @@\n-  bool      check_index(int i, int& cp_index, outputStream* st = tty);\n-  bool      check_cp_cache_index(int i, int& cp_index, outputStream* st = tty);\n-  bool      check_obj_index(int i, int& cp_index, outputStream* st = tty);\n-  bool      check_invokedynamic_index(int i, int& cp_index, outputStream* st = tty);\n-  void      print_constant(int i, outputStream* st = tty);\n-  void      print_field_or_method(int i, outputStream* st = tty);\n-  void      print_field_or_method(int orig_i, int i, outputStream* st = tty);\n-  void      print_attributes(int bci, outputStream* st = tty);\n-  void      bytecode_epilog(int bci, outputStream* st = tty);\n+  bool      check_index(int i, int& cp_index, outputStream* st);\n+  bool      check_cp_cache_index(int i, int& cp_index, outputStream* st);\n+  bool      check_obj_index(int i, int& cp_index, outputStream* st);\n+  bool      check_invokedynamic_index(int i, int& cp_index, outputStream* st);\n+  void      print_constant(int i, outputStream* st);\n+  void      print_constant_nocheck(int i, outputStream* st);\n+  void      print_cpcache_entry(int cpc_index, outputStream* st);\n+  void      print_dynamic(int orig_i, int i, constantTag tag, outputStream* st);\n+  void      print_field_or_method(int i, outputStream* st);\n+  void      print_field_or_method(int orig_i, int i, outputStream* st);\n+  void      print_invoke_handle(int i, outputStream* st);\n+  void      print_attributes(int bci, outputStream* st);\n+  void      bytecode_epilog(int bci, outputStream* st);\n@@ -83,1 +89,1 @@\n-  BytecodePrinter() {\n+  BytecodePrinter(int flags = 0) {\n@@ -86,0 +92,1 @@\n+    _flags = flags;\n@@ -123,1 +130,1 @@\n-    print_attributes(bci);\n+    print_attributes(bci, st);\n@@ -144,0 +151,3 @@\n+    if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_BYTECODE_ADDR)) {\n+      st->print(INTPTR_FORMAT \" \", p2i(bcp));\n+    }\n@@ -145,1 +155,1 @@\n-      st->print(\"%d %s_w\", bci, Bytecodes::name(code));\n+      st->print(\"%4d %s_w\", bci, Bytecodes::name(code));\n@@ -147,1 +157,1 @@\n-      st->print(\"%d %s\", bci, Bytecodes::name(code));\n+      st->print(\"%4d %s\", bci, Bytecodes::name(code));\n@@ -155,0 +165,3 @@\n+\/\/ We need a global instance to keep track of the states when the bytecodes\n+\/\/ are executed. Access by multiple threads are controlled by ttyLocker.\n+static BytecodePrinter _interpreter_printer;\n@@ -156,21 +169,1 @@\n-\/\/ Implementation of BytecodeTracer\n-\n-\/\/ %%% This set_closure thing seems overly general, given that\n-\/\/ nobody uses it.  Also, if BytecodePrinter weren't hidden\n-\/\/ then Method* could use instances of it directly and it\n-\/\/ would be easier to remove races on _current_method and bcp.\n-\/\/ Since this is not product functionality, we can defer cleanup.\n-\n-BytecodeClosure* BytecodeTracer::_closure = NULL;\n-\n-static BytecodePrinter std_closure;\n-BytecodeClosure* BytecodeTracer::std_closure() {\n-  return &::std_closure;\n-}\n-\n-\n-void BytecodeTracer::trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {\n-  if (_closure == NULL) {\n-    return;\n-  }\n-\n+void BytecodeTracer::trace_interpreter(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {\n@@ -181,3 +174,0 @@\n-    \/\/ Using the ttyLocker prevents the system from coming to\n-    \/\/ a safepoint within this code, which is sensitive to Method*\n-    \/\/ movement.\n@@ -187,5 +177,1 @@\n-    \/\/\n-    \/\/ We put the locker on the static trace method, not the\n-    \/\/ virtual one, because the clients of this module go through\n-    \/\/ the static method.\n-    _closure->trace(method, bcp, tos, tos2, st);\n+    _interpreter_printer.trace(method, bcp, tos, tos2, st);\n@@ -195,4 +181,4 @@\n-void BytecodeTracer::trace(const methodHandle& method, address bcp, outputStream* st) {\n-  if (_closure == NULL) {\n-    return;\n-  }\n+void BytecodeTracer::print_method_codes(const methodHandle& method, int from, int to, outputStream* st, int flags) {\n+  BytecodePrinter method_printer(flags);\n+  BytecodeStream s(method);\n+  s.set_interval(from, to);\n@@ -200,2 +186,4 @@\n-  ttyLocker ttyl;  \/\/ 5065316: keep the following output coherent\n-  _closure->trace(method, bcp, st);\n+  ttyLocker ttyl;  \/\/ keep the following output coherent\n+  while (s.next() >= 0) {\n+    method_printer.trace(method, s.bcp(), st);\n+  }\n@@ -327,0 +315,4 @@\n+  print_constant_nocheck(i, st);\n+}\n+\n+void BytecodePrinter::print_constant_nocheck(int i, outputStream* st) {\n@@ -399,0 +391,43 @@\n+\n+  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC) &&\n+      (tag.is_dynamic_constant() || tag.is_invoke_dynamic())) {\n+    print_dynamic(orig_i, i, tag, st);\n+  }\n+}\n+\n+void BytecodePrinter::print_dynamic(int orig_i, int bsm_cpindex, constantTag tag, outputStream* st) {\n+  ConstantPool* constants = method()->constants();\n+  int bsm = constants->bootstrap_method_ref_index_at(bsm_cpindex);\n+  const char* ref_kind = \"\";\n+  switch (constants->method_handle_ref_kind_at(bsm)) {\n+  case JVM_REF_getField         : ref_kind = \"REF_getField\"; break;\n+  case JVM_REF_getStatic        : ref_kind = \"REF_getStatic\"; break;\n+  case JVM_REF_putField         : ref_kind = \"REF_putField\"; break;\n+  case JVM_REF_putStatic        : ref_kind = \"REF_putStatic\"; break;\n+  case JVM_REF_invokeVirtual    : ref_kind = \"REF_invokeVirtual\"; break;\n+  case JVM_REF_invokeStatic     : ref_kind = \"REF_invokeStatic\"; break;\n+  case JVM_REF_invokeSpecial    : ref_kind = \"REF_invokeSpecial\"; break;\n+  case JVM_REF_newInvokeSpecial : ref_kind = \"REF_newInvokeSpecial\"; break;\n+  case JVM_REF_invokeInterface  : ref_kind = \"REF_invokeInterface\"; break;\n+  default                       : ShouldNotReachHere();\n+  }\n+  st->print(\"  BSM: %s\", ref_kind);\n+  print_field_or_method(-1, constants->method_handle_index_at(bsm), st);\n+  int argc = constants->bootstrap_argument_count_at(bsm_cpindex);\n+  st->print(\"  arguments[%d] = {\", argc);\n+  if (argc > 0) {\n+    st->cr();\n+    for (int arg_i = 0; arg_i < argc; arg_i++) {\n+      int arg = constants->bootstrap_argument_index_at(bsm_cpindex, arg_i);\n+      st->print(\"    \");\n+      print_constant_nocheck(arg, st);\n+    }\n+  }\n+  st->print_cr(\"  }\");\n+  if (tag.is_invoke_dynamic()) {\n+    int indy_index = orig_i;\n+    int cpc_index = constants->invokedynamic_cp_cache_index(indy_index);\n+    print_cpcache_entry(cpc_index, st);\n+  } else {\n+    \/\/ TODO: print info for tag.is_dynamic_constant()\n+  }\n@@ -401,0 +436,10 @@\n+void BytecodePrinter::print_invoke_handle(int i, outputStream* st) {\n+  print_cpcache_entry(ConstantPool::decode_cpcache_index(i), st);\n+}\n+\n+void BytecodePrinter::print_cpcache_entry(int cpc_index, outputStream* st) {\n+  ConstantPool* constants = method()->constants();\n+  ConstantPoolCacheEntry* cpce = constants->cache()->entry_at(cpc_index);\n+  st->print(\"  ConstantPoolCacheEntry: \");\n+  cpce->print(st, cpc_index, constants->cache());\n+}\n@@ -563,1 +608,8 @@\n-      print_field_or_method(get_index_u2_cpcache(), st);\n+      {\n+        int i = get_index_u2_cpcache();\n+        print_field_or_method(i, st);\n+        if (raw_code() == Bytecodes::_invokehandle &&\n+            ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_METHOD_HANDLE)) {\n+          print_invoke_handle(i, st);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":105,"deletions":53,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/bytecodeTracer.hpp\"\n@@ -1784,1 +1785,1 @@\n-  BytecodeTracer::trace(mh, last_frame.bcp(), tos, tos2);\n+  BytecodeTracer::trace_interpreter(mh, last_frame.bcp(), tos, tos2);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n-  friend class BytecodeClosure; \/\/ for method and bcp\n-  friend class PrintingClosure; \/\/ for method and bcp\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/classPrelinker.hpp\"\n@@ -304,17 +306,0 @@\n-void ConstantPool::resolve_class_constants(TRAPS) {\n-  assert(DumpSharedSpaces, \"used during dump time only\");\n-  \/\/ The _cache may be NULL if the _pool_holder klass fails verification\n-  \/\/ at dump time due to missing dependencies.\n-  if (cache() == NULL || reference_map() == NULL) {\n-    return; \/\/ nothing to do\n-  }\n-\n-  constantPoolHandle cp(THREAD, this);\n-  for (int index = 1; index < length(); index++) { \/\/ Index 0 is unused\n-    if (tag_at(index).is_string()) {\n-      int cache_index = cp->cp_to_object_index(index);\n-      string_at_impl(cp, index, cache_index, CHECK);\n-    }\n-  }\n-}\n-\n@@ -393,1 +378,1 @@\n-  int num_klasses = 0;\n+  bool archived = false;\n@@ -395,4 +380,8 @@\n-    jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n-    if (tag_at(index).is_unresolved_klass_in_error()) {\n-      tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n-    } else if (tag_at(index).is_method_handle_in_error()) {\n+    switch (tag_at(index).value()) {\n+    case JVM_CONSTANT_UnresolvedClassInError:\n+      {\n+        jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n+        tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n+      }\n+      break;\n+    case JVM_CONSTANT_MethodHandleInError:\n@@ -400,1 +389,2 @@\n-    } else if (tag_at(index).is_method_type_in_error()) {\n+      break;\n+    case JVM_CONSTANT_MethodTypeInError:\n@@ -402,1 +392,2 @@\n-    } else if (tag_at(index).is_dynamic_constant_in_error()) {\n+      break;\n+    case JVM_CONSTANT_DynamicInError:\n@@ -404,21 +395,5 @@\n-    }\n-    if (tag_at(index).is_klass()) {\n-      \/\/ This class was resolved as a side effect of executing Java code\n-      \/\/ during dump time. We need to restore it back to an UnresolvedClass,\n-      \/\/ so that the proper class loading and initialization can happen\n-      \/\/ at runtime.\n-      bool clear_it = true;\n-      if (pool_holder()->is_hidden() && index == pool_holder()->this_class_index()) {\n-        \/\/ All references to a hidden class's own field\/methods are through this\n-        \/\/ index. We cannot clear it. See comments in ClassFileParser::fill_instance_klass.\n-        clear_it = false;\n-      }\n-      if (clear_it) {\n-        CPKlassSlot kslot = klass_slot_at(index);\n-        int resolved_klass_index = kslot.resolved_klass_index();\n-        int name_index = kslot.name_index();\n-        assert(tag_at(name_index).is_symbol(), \"sanity\");\n-        resolved_klasses()->at_put(resolved_klass_index, NULL);\n-        tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n-        assert(klass_name_at(index) == symbol_at(name_index), \"sanity\");\n-      }\n+      break;\n+    case JVM_CONSTANT_Class:\n+      archived = maybe_archive_resolved_klass_at(index);\n+      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(archived);\n+      break;\n@@ -427,0 +402,1 @@\n+\n@@ -432,0 +408,37 @@\n+\n+bool ConstantPool::maybe_archive_resolved_klass_at(int cp_index) {\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(this), \"must be\");\n+  assert(tag_at(cp_index).is_klass(), \"must be resolved\");\n+\n+  if (pool_holder()->is_hidden() && cp_index == pool_holder()->this_class_index()) {\n+    \/\/ All references to a hidden class's own field\/methods are through this\n+    \/\/ index, which was resolved in ClassFileParser::fill_instance_klass. We\n+    \/\/ must preserve it.\n+    return true;\n+  }\n+\n+  CPKlassSlot kslot = klass_slot_at(cp_index);\n+  int resolved_klass_index = kslot.resolved_klass_index();\n+  Klass* k = resolved_klasses()->at(resolved_klass_index);\n+  \/\/ k could be NULL if the referenced class has been excluded via\n+  \/\/ SystemDictionaryShared::is_excluded_class().\n+\n+  if (k != NULL) {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    if (ClassPrelinker::can_archive_resolved_klass(src_cp, cp_index)) {\n+      if (log_is_enabled(Debug, cds, resolve)) {\n+        ResourceMark rm;\n+        log_debug(cds, resolve)(\"Resolved klass CP entry [%d]: %s => %s\", cp_index,\n+                                pool_holder()->external_name(), k->external_name());\n+      }\n+      return true;\n+    }\n+  }\n+\n+  \/\/ This referenced class cannot be archived. Revert the tag to UnresolvedClass,\n+  \/\/ so that the proper class loading and initialization can happen at runtime.\n+  resolved_klasses()->at_put(resolved_klass_index, NULL);\n+  jbyte qdesc_bit = tag_at(cp_index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n+  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":58,"deletions":45,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  friend class ClassPrelinker;       \/\/ CDS\n@@ -707,1 +708,1 @@\n-  void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  bool maybe_archive_resolved_klass_at(int cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-    this->print(log_stream, 0);\n+    this->print(log_stream, 0, cpool->cache());\n@@ -489,1 +489,1 @@\n-Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle& cpool) {\n+Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle& cpool) const {\n@@ -536,1 +536,1 @@\n-oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle& cpool) {\n+oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle& cpool) const {\n@@ -629,1 +629,1 @@\n-void ConstantPoolCacheEntry::print(outputStream* st, int index) const {\n+void ConstantPoolCacheEntry::print(outputStream* st, int index, const ConstantPoolCache* cache) const {\n@@ -639,0 +639,19 @@\n+\n+  if ((bytecode_1() == Bytecodes::_invokehandle ||\n+       bytecode_1() == Bytecodes::_invokedynamic)) {\n+    constantPoolHandle cph(Thread::current(), cache->constant_pool());\n+    Method* m = method_if_resolved(cph);\n+    oop appendix = appendix_if_resolved(cph);\n+    ResourceMark rm;\n+    if (m != NULL) {\n+      st->print_cr(\"  Method%s: \" INTPTR_FORMAT \" %s.%s%s\",\n+                   m->is_native() ? \" (native)\" : \"\",\n+                   p2i(m),\n+                   m->method_holder()->name()->as_C_string(),\n+                   m->name()->as_C_string(), m->signature()->as_C_string());\n+    }\n+    if (appendix != NULL) {\n+      st->print(\"  appendix: \");\n+      appendix->print_on(st);\n+    }\n+  }\n@@ -793,1 +812,1 @@\n-      entry_at(i)->print(tty, i);\n+      entry_at(i)->print(tty, i, this);\n@@ -810,1 +829,1 @@\n-  for (int i = 0; i < length(); i++) entry_at(i)->print(st, i);\n+  for (int i = 0; i < length(); i++) entry_at(i)->print(st, i, this);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -301,2 +301,2 @@\n-  Method*      method_if_resolved(const constantPoolHandle& cpool);\n-  oop        appendix_if_resolved(const constantPoolHandle& cpool);\n+  Method*      method_if_resolved(const constantPoolHandle& cpool) const;\n+  oop        appendix_if_resolved(const constantPoolHandle& cpool) const;\n@@ -392,1 +392,1 @@\n-  void print (outputStream* st, int index) const;\n+  void print (outputStream* st, int index, const ConstantPoolCache* cache) const;\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1319,19 +1319,0 @@\n-address Method::from_compiled_entry_no_trampoline(bool caller_is_c1) const {\n-  CompiledMethod *code = Atomic::load_acquire(&_code);\n-  if (caller_is_c1) {\n-    \/\/ C1 - inline type arguments are passed as objects\n-    if (code) {\n-      return code->verified_inline_entry_point();\n-    } else {\n-      return adapter()->get_c2i_inline_entry();\n-    }\n-  } else {\n-    \/\/ C2 - inline type arguments may be passed as fields\n-    if (code) {\n-      return code->verified_entry_point();\n-    } else {\n-      return adapter()->get_c2i_entry();\n-    }\n-  }\n-}\n-\n@@ -1897,2 +1878,2 @@\n-void Method::print_codes_on(outputStream* st) const {\n-  print_codes_on(0, code_size(), st);\n+void Method::print_codes_on(outputStream* st, int flags) const {\n+  print_codes_on(0, code_size(), st, flags);\n@@ -1901,1 +1882,1 @@\n-void Method::print_codes_on(int from, int to, outputStream* st) const {\n+void Method::print_codes_on(int from, int to, outputStream* st, int flags) const {\n@@ -1905,4 +1886,1 @@\n-  BytecodeStream s(mh);\n-  s.set_interval(from, to);\n-  BytecodeTracer::set_closure(BytecodeTracer::std_closure());\n-  while (s.next() >= 0) BytecodeTracer::trace(mh, s.bcp(), st);\n+  BytecodeTracer::print_method_codes(mh, from, to, st, flags);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-  address from_compiled_entry_no_trampoline(bool caller_is_c1) const;\n@@ -550,3 +549,3 @@\n-  void print_codes() const            { print_codes_on(tty); }\n-  void print_codes_on(outputStream* st) const;\n-  void print_codes_on(int from, int to, outputStream* st) const;\n+  void print_codes(int flags = 0) const { print_codes_on(tty, flags); }\n+  void print_codes_on(outputStream* st, int flags = 0) const;\n+  void print_codes_on(int from, int to, outputStream* st, int flags = 0) const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -221,0 +222,9 @@\n+bool Symbol::is_star_match(const char* pattern) const {\n+  if (strchr(pattern, '*') == NULL) {\n+    return equals(pattern);\n+  } else {\n+    ResourceMark rm;\n+    char* buf = as_C_string();\n+    return StringUtils::is_star_match(pattern, buf);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+  bool is_star_match(const char* pattern) const;\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -722,0 +722,2 @@\n+  JvmtiTagMap::flush_all_object_free_events();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,0 +554,8 @@\n+  { \"PrintSharedDictionary\",          JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n+\n+  { \"G1ConcRefinementGreenZone\",    JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementYellowZone\",   JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementRedZone\",      JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementThresholdStep\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1UseAdaptiveConcRefinement\",  JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementServiceIntervalMillis\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n@@ -1953,0 +1961,8 @@\n+#if INCLUDE_JFR\n+  if (status && (FlightRecorderOptions || StartFlightRecording)) {\n+    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.jfr\", addmods_count++)) {\n+      return false;\n+    }\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2181,2 +2181,5 @@\n-  CodeBlob* cb = CodeCache::find_blob(caller_pc);\n-  if (cb == NULL || !cb->is_compiled()) {\n+  \/\/ Result from nmethod::is_unloading is not stable across safepoints.\n+  NoSafepointVerifier nsv;\n+\n+  CompiledMethod* callee = moop->code();\n+  if (callee == NULL) {\n@@ -2185,2 +2188,3 @@\n-  address entry_point = moop->from_compiled_entry_no_trampoline(cb->is_compiled_by_c1());\n-  if (entry_point == moop->get_c2i_entry()) {\n+\n+  CodeBlob* cb = CodeCache::find_blob(caller_pc);\n+  if (cb == NULL || !cb->is_compiled() || callee->is_unloading()) {\n@@ -2244,0 +2248,1 @@\n+      address entry_point = cb->is_compiled_by_c1() ? callee->verified_inline_entry_point() : callee->verified_entry_point();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"interpreter\/bytecodeTracer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-  nonstatic_field(GrowableArrayBase,           _max,                                          int)                                   \\\n+  nonstatic_field(GrowableArrayBase,           _capacity,                                     int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  int _max;\n+  int _capacity;\n@@ -83,1 +83,1 @@\n-  GrowableArrayBase(int initial_max, int initial_len) :\n+  GrowableArrayBase(int capacity, int initial_len) :\n@@ -85,2 +85,2 @@\n-      _max(initial_max) {\n-    assert(_len >= 0 && _len <= _max, \"initial_len too big\");\n+      _capacity(capacity) {\n+    assert(_len >= 0 && _len <= _capacity, \"initial_len too big\");\n@@ -93,1 +93,1 @@\n-  int   max_length() const      { return _max; }\n+  int   capacity() const        { return _capacity; }\n@@ -97,1 +97,1 @@\n-  bool  is_full() const         { return _len == _max; }\n+  bool  is_full() const         { return _len == _capacity; }\n@@ -123,2 +123,2 @@\n-  GrowableArrayView<E>(E* data, int initial_max, int initial_len) :\n-      GrowableArrayBase(initial_max, initial_len), _data(data) {}\n+  GrowableArrayView<E>(E* data, int capacity, int initial_len) :\n+      GrowableArrayBase(capacity, initial_len), _data(data) {}\n@@ -162,1 +162,1 @@\n-    assert(_len > 0, \"empty list\");\n+    assert(_len > 0, \"empty\");\n@@ -167,1 +167,1 @@\n-    assert(_len > 0, \"empty list\");\n+    assert(_len > 0, \"empty\");\n@@ -342,1 +342,1 @@\n-    tty->print(\": length %d (_max %d) { \", _len, _max);\n+    tty->print(\": length %d (capacity %d) { \", _len, _capacity);\n@@ -365,0 +365,1 @@\n+  void expand_to(int j);\n@@ -368,3 +369,3 @@\n-  GrowableArrayWithAllocator(E* data, int initial_max) :\n-      GrowableArrayView<E>(data, initial_max, 0) {\n-    for (int i = 0; i < initial_max; i++) {\n+  GrowableArrayWithAllocator(E* data, int capacity) :\n+      GrowableArrayView<E>(data, capacity, 0) {\n+    for (int i = 0; i < capacity; i++) {\n@@ -375,2 +376,2 @@\n-  GrowableArrayWithAllocator(E* data, int initial_max, int initial_len, const E& filler) :\n-      GrowableArrayView<E>(data, initial_max, initial_len) {\n+  GrowableArrayWithAllocator(E* data, int capacity, int initial_len, const E& filler) :\n+      GrowableArrayView<E>(data, capacity, initial_len) {\n@@ -381,1 +382,1 @@\n-    for (; i < initial_max; i++) {\n+    for (; i < capacity; i++) {\n@@ -390,1 +391,1 @@\n-    if (this->_len == this->_max) grow(this->_len);\n+    if (this->_len == this->_capacity) grow(this->_len);\n@@ -408,1 +409,1 @@\n-      if (i >= this->_max) grow(i);\n+      if (i >= this->_capacity) grow(i);\n@@ -419,1 +420,1 @@\n-      if (i >= this->_max) grow(i);\n+      if (i >= this->_capacity) grow(i);\n@@ -430,1 +431,1 @@\n-    if (this->_len == this->_max) grow(this->_len);\n+    if (this->_len == this->_capacity) grow(this->_len);\n@@ -442,1 +443,1 @@\n-    if (new_len >= this->_max) grow(new_len);\n+    if (new_len >= this->_capacity) grow(new_len);\n@@ -492,1 +493,1 @@\n-    ::swap(this->_max, other->_max);\n+    ::swap(this->_capacity, other->_capacity);\n@@ -495,0 +496,6 @@\n+  \/\/ Ensure capacity is at least new_capacity.\n+  void reserve(int new_capacity);\n+\n+  \/\/ Reduce capacity to length.\n+  void shrink_to_fit();\n+\n@@ -499,5 +506,5 @@\n-void GrowableArrayWithAllocator<E, Derived>::grow(int j) {\n-  int old_max = this->_max;\n-  \/\/ grow the array by increasing _max to the first power of two larger than the size we need\n-  this->_max = next_power_of_2((uint32_t)j);\n-  \/\/ j < _max\n+void GrowableArrayWithAllocator<E, Derived>::expand_to(int new_capacity) {\n+  int old_capacity = this->_capacity;\n+  assert(new_capacity > old_capacity,\n+         \"expected growth but %d <= %d\", new_capacity, old_capacity);\n+  this->_capacity = new_capacity;\n@@ -507,2 +514,2 @@\n-  for (     ; i < this->_max; i++) ::new ((void*)&newData[i]) E();\n-  for (i = 0; i < old_max; i++) this->_data[i].~E();\n+  for (     ; i < this->_capacity; i++) ::new ((void*)&newData[i]) E();\n+  for (i = 0; i < old_capacity; i++) this->_data[i].~E();\n@@ -516,7 +523,9 @@\n-void GrowableArrayWithAllocator<E, Derived>::clear_and_deallocate() {\n-  if (this->_data != NULL) {\n-    for (int i = 0; i < this->_max; i++) {\n-      this->_data[i].~E();\n-    }\n-    static_cast<Derived*>(this)->deallocate(this->_data);\n-    this->_data = NULL;\n+void GrowableArrayWithAllocator<E, Derived>::grow(int j) {\n+  \/\/ grow the array by increasing _capacity to the first power of two larger than the size we need\n+  expand_to(next_power_of_2((uint32_t)j));\n+}\n+\n+template <typename E, typename Derived>\n+void GrowableArrayWithAllocator<E, Derived>::reserve(int new_capacity) {\n+  if (new_capacity > this->_capacity) {\n+    expand_to(new_capacity);\n@@ -524,2 +533,34 @@\n-  this->_len = 0;\n-  this->_max = 0;\n+}\n+\n+template <typename E, typename Derived>\n+void GrowableArrayWithAllocator<E, Derived>::shrink_to_fit() {\n+  int old_capacity = this->_capacity;\n+  int len = this->_len;\n+  assert(len <= old_capacity, \"invariant\");\n+\n+  \/\/ If already at full capacity, nothing to do.\n+  if (len == old_capacity) {\n+    return;\n+  }\n+\n+  \/\/ If not empty, allocate new, smaller, data, and copy old data to it.\n+  E* old_data = this->_data;\n+  E* new_data = nullptr;\n+  this->_capacity = len;        \/\/ Must preceed allocate().\n+  if (len > 0) {\n+    new_data = static_cast<Derived*>(this)->allocate();\n+    for (int i = 0; i < len; ++i) ::new (&new_data[i]) E(old_data[i]);\n+  }\n+  \/\/ Destroy contents of old data, and deallocate it.\n+  for (int i = 0; i < old_capacity; ++i) old_data[i].~E();\n+  if (old_data != nullptr) {\n+    static_cast<Derived*>(this)->deallocate(old_data);\n+  }\n+  \/\/ Install new data, which might be nullptr.\n+  this->_data = new_data;\n+}\n+\n+template <typename E, typename Derived>\n+void GrowableArrayWithAllocator<E, Derived>::clear_and_deallocate() {\n+  this->clear();\n+  this->shrink_to_fit();\n@@ -672,1 +713,1 @@\n-      return allocate(this->_max);\n+      return allocate(this->_capacity);\n@@ -676,1 +717,1 @@\n-      return allocate(this->_max, _metadata.memflags());\n+      return allocate(this->_capacity, _metadata.memflags());\n@@ -680,1 +721,1 @@\n-    return allocate(this->_max, _metadata.arena());\n+    return allocate(this->_capacity, _metadata.arena());\n@@ -690,1 +731,1 @@\n-  GrowableArray(int initial_max = 2, MEMFLAGS memflags = mtNone) :\n+  GrowableArray(int initial_capacity = 2, MEMFLAGS memflags = mtNone) :\n@@ -692,2 +733,2 @@\n-          allocate(initial_max, memflags),\n-          initial_max),\n+          allocate(initial_capacity, memflags),\n+          initial_capacity),\n@@ -698,1 +739,1 @@\n-  GrowableArray(int initial_max, int initial_len, const E& filler, MEMFLAGS memflags = mtNone) :\n+  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags = mtNone) :\n@@ -700,2 +741,2 @@\n-          allocate(initial_max, memflags),\n-          initial_max, initial_len, filler),\n+          allocate(initial_capacity, memflags),\n+          initial_capacity, initial_len, filler),\n@@ -706,1 +747,1 @@\n-  GrowableArray(Arena* arena, int initial_max, int initial_len, const E& filler) :\n+  GrowableArray(Arena* arena, int initial_capacity, int initial_len, const E& filler) :\n@@ -708,2 +749,2 @@\n-          allocate(initial_max, arena),\n-          initial_max, initial_len, filler),\n+          allocate(initial_capacity, arena),\n+          initial_capacity, initial_len, filler),\n@@ -739,1 +780,1 @@\n-    return allocate(this->_max, F);\n+    return allocate(this->_capacity, F);\n@@ -747,1 +788,1 @@\n-  GrowableArrayCHeap(int initial_max = 0) :\n+  GrowableArrayCHeap(int initial_capacity = 0) :\n@@ -749,2 +790,2 @@\n-          allocate(initial_max, F),\n-          initial_max) {}\n+          allocate(initial_capacity, F),\n+          initial_capacity) {}\n@@ -752,1 +793,1 @@\n-  GrowableArrayCHeap(int initial_max, int initial_len, const E& filler) :\n+  GrowableArrayCHeap(int initial_capacity, int initial_len, const E& filler) :\n@@ -754,2 +795,2 @@\n-          allocate(initial_max, F),\n-          initial_max, initial_len, filler) {}\n+          allocate(initial_capacity, F),\n+          initial_capacity, initial_len, filler) {}\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":100,"deletions":59,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,18 +288,0 @@\n-    List<Object> classDataValues() {\n-        final List<ClassData> cd = classData;\n-        return switch(cd.size()) {\n-            case 0 -> List.of();\n-            case 1 -> List.of(cd.get(0).value);\n-            case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n-            case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n-            case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n-            default -> {\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n-                    data[i] = classData.get(i).value;\n-                }\n-                yield List.of(data);\n-            }\n-        };\n-    }\n-\n@@ -363,0 +345,26 @@\n+    \/**\n+     * Returns the class data object that will be passed to `Lookup.defineHiddenClassWithClassData`.\n+     * The classData is loaded in the <clinit> method of the generated class.\n+     * If the class data contains only one single object, this method returns  that single object.\n+     * If the class data contains more than one objects, this method returns a List.\n+     *\n+     * This method returns null if no class data.\n+     *\/\n+    private Object classDataValues() {\n+        final List<ClassData> cd = classData;\n+        return switch (cd.size()) {\n+            case 0 -> null;             \/\/ special case (classData is not used by <clinit>)\n+            case 1 -> cd.get(0).value;  \/\/ special case (single object)\n+            case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n+            case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n+            case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n+            default -> {\n+                Object[] data = new Object[classData.size()];\n+                for (int i = 0; i < classData.size(); i++) {\n+                    data[i] = classData.get(i).value;\n+                }\n+                yield List.of(data);\n+            }\n+        };\n+    }\n+\n@@ -382,10 +390,2 @@\n-        \/\/ we should optimize one single element case that does not need to create a List\n-        mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n-        mv.visitVarInsn(Opcodes.ASTORE, 0);\n-        int index = 0;\n-        for (ClassData p : classData) {\n-            \/\/ initialize the static field\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\n-            emitIconstInsn(mv, index++);\n-            mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n-                               \"get\", \"(I)Ljava\/lang\/Object;\", true);\n+        if (classData.size() == 1) {\n+            ClassData p = classData.get(0);\n@@ -394,0 +394,13 @@\n+        } else {\n+            mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n+            mv.visitVarInsn(Opcodes.ASTORE, 0);\n+            int index = 0;\n+            for (ClassData p : classData) {\n+                \/\/ initialize the static field\n+                mv.visitVarInsn(Opcodes.ALOAD, 0);\n+                emitIconstInsn(mv, index++);\n+                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n+                                   \"get\", \"(I)Ljava\/lang\/Object;\", true);\n+                mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n+                mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":42,"deletions":29,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1930,1 +1930,1 @@\n-                        return visit(elemtype(t), elemtype(s));\n+                        return isCastable(elemtype(t), elemtype(s), warnStack.head);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2284,2 +2284,7 @@\n-                        log.error(pos, Errors.TypesIncompatible(t1, t2,\n-                                Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));\n+                        if (types.isSameType(t1, t2)) {\n+                            log.error(pos, Errors.IncompatibleDiffRetSameType(t1,\n+                                    s2.name, types.memberType(t2, s2).getParameterTypes()));\n+                        } else {\n+                            log.error(pos, Errors.TypesIncompatible(t1, t2,\n+                                    Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -699,1 +699,1 @@\n-            if (!tree.hasUnconditionalPattern) {\n+            if (!tree.hasUnconditionalPattern && !exhaustiveSwitch) {\n@@ -2347,1 +2347,2 @@\n-                    boolean isCompactConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;\n+                    boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                            (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n@@ -2357,1 +2358,1 @@\n-                                if (isSynthesized && !isCompactConstructor) {\n+                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n@@ -2360,1 +2361,1 @@\n-                                } else if (isCompactConstructor) {\n+                                } else if (isCompactOrGeneratedRecordConstructor) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2788,1 +2788,2 @@\n-        if (names.isInitOrVNew(tree.name) && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+        if (names.isInitOrVNew(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                (tree.sym.flags_field & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3739,1 +3739,3 @@\n-                this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata(), site.getFlavor());\n+                this.site = new ClassType(site.getEnclosingType(),\n+                        !(site.tsym.isInner() && site.getEnclosingType().isRaw()) ?\n+                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1478,1 +1478,1 @@\n-            csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;\n+            csym.flags_field |= GENERATEDCONSTR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1250,0 +1250,4 @@\n+# 0: type, 1: name, 2: list of type\n+compiler.err.incompatible.diff.ret.same.type=\\\n+    type {0} defines {1}({2}) more than once with unrelated return types\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}