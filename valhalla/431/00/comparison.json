{"files":[{"patch":"@@ -516,4 +516,2 @@\n-\n-  ciType* return_type = method->return_type();\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype()) {\n-    ciInlineKlass* vk = return_type->as_inline_klass();\n+  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -534,3 +534,2 @@\n-  ciType* return_type = method->return_type();\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype() && return_type->is_null_free()) {\n-    ciInlineKlass* vk = return_type->as_inline_klass();\n+  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -665,1 +665,1 @@\n-      if (!is_interface && klass->is_subtype_of(x->klass())) {\n+      if (!is_interface && klass->is_subtype_of(x->klass()) && (!x->is_null_free() || obj->is_null_free())) {\n@@ -671,3 +671,2 @@\n-    \/\/ checkcast of null returns null for non-inline klasses\n-    if (!x->klass()->is_inlinetype() && x->is_null_free()\n-        && obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    \/\/ checkcast of null returns null for non null-free klasses\n+    if (!x->is_null_free() && obj->is_null_obj()) {\n@@ -687,1 +686,1 @@\n-    if (obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    if (obj->as_Constant() && obj->is_null_obj()) {\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1847,1 +1847,1 @@\n-      } else if (field_type == T_INLINE_TYPE && field->type()->is_null_free() && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n+      } else if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1849,1 +1849,1 @@\n-        constant = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n+        constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1872,1 +1872,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1890,1 +1890,1 @@\n-        if (field_type == T_INLINE_TYPE && field->type()->is_null_free() && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n+        if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1893,1 +1893,1 @@\n-          constant = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n+          constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1899,1 +1899,1 @@\n-              if (field->signature()->is_Q_signature() && field_value.is_null_or_zero()) {\n+              if (field->is_null_free() && field_value.is_null_or_zero()) {\n@@ -1901,1 +1901,1 @@\n-                constant = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n+                constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1988,1 +1988,1 @@\n-            ciInlineKlass* inline_klass = field->type()->unwrap()->as_inline_klass();\n+            ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n@@ -2045,1 +2045,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->is_null_free() && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -2056,1 +2056,1 @@\n-        ciInlineKlass* inline_klass = field->type()->unwrap()->as_inline_klass();\n+        ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n@@ -2132,1 +2132,1 @@\n-    ciInlineKlass* vk = field_modify->type()->unwrap()->as_inline_klass();\n+    ciInlineKlass* vk = field_modify->type()->as_inline_klass();\n@@ -2481,1 +2481,1 @@\n-                              declared_signature->return_type()->is_null_free());\n+                              declared_signature->returns_null_free_inline_type());\n@@ -3582,1 +3582,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false, type->is_null_free()));\n+    state->store_local(idx, new Local(type, vt, idx, false, sig->is_null_free_at(i)));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ciType* t =  declared_type();\n+  ciType* t = declared_type();\n@@ -141,2 +141,2 @@\n-      if (type->is_obj_array_klass()) {\n-        \/\/ Due to array covariance, the runtime type might be a flattened array.\n+      if (type->is_obj_array_klass() && !type->as_obj_array_klass()->is_elem_null_free()) {\n+        \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n@@ -148,2 +148,0 @@\n-        ciKlass* element_klass = type->as_flat_array_klass()->element_klass();\n-        assert(!element_klass->is_loaded() || element_klass->flatten_array(), \"must be flattened\");\n@@ -169,2 +167,1 @@\n-      ciKlass* element_klass = type->as_obj_array_klass()->element_klass();\n-      if (element_klass->can_be_inline_klass()) {\n+      if (type->as_obj_array_klass()->can_be_inline_array_klass()) {\n@@ -271,1 +268,1 @@\n-    ciKlass* actual_klass = value()->declared_type()->unwrap()->as_klass();\n+    ciKlass* actual_klass = value()->declared_type()->as_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -869,1 +869,1 @@\n-    set_null_free(field->signature()->is_Q_signature());\n+    set_null_free(field->is_null_free());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1750,2 +1750,2 @@\n-  if (field->signature()->is_Q_signature()) {\n-    assert(field->type()->unwrap()->as_inline_klass()->is_loaded(), \"Must be\");\n+  if (field->is_null_free()) {\n+    assert(field->type()->as_inline_klass()->is_loaded(), \"Must be\");\n@@ -1756,1 +1756,1 @@\n-    Constant* default_value = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n+    Constant* default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1776,1 +1776,1 @@\n-    elem_klass = field->type()->unwrap()->as_inline_klass();\n+    elem_klass = field->type()->as_inline_klass();\n@@ -2049,1 +2049,1 @@\n-  if (!field->signature()->is_Q_signature()) {\n+  if (!field->is_null_free()) {\n@@ -2058,1 +2058,1 @@\n-  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->unwrap()->is_loaded();\n+  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->is_loaded();\n@@ -2137,1 +2137,1 @@\n-  if (field->signature()->is_Q_signature()) {\n+  if (field->is_null_free()) {\n@@ -2140,1 +2140,1 @@\n-    ciInlineKlass* inline_klass = field->type()->unwrap()->as_inline_klass();\n+    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n@@ -3056,5 +3056,0 @@\n-  \/\/ Inline types can't be null\n-  if (exact_klass != NULL && exact_klass->is_inlinetype()) {\n-    do_null = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-ciArrayKlass* ciArrayKlass::make(ciType* element_type) {\n+ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool null_free) {\n@@ -109,17 +109,12 @@\n-    return make(element_type->as_klass(), element_type->is_null_free());\n-  }\n-}\n-\n-ciArrayKlass* ciArrayKlass::make(ciKlass* klass, bool null_free) {\n-  if (null_free && klass->is_loaded()) {\n-    GUARDED_VM_ENTRY(\n-      EXCEPTION_CONTEXT;\n-      Klass* ak = InlineKlass::cast(klass->get_Klass())->null_free_inline_array_klass(THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-      } else if (ak != NULL && ak->is_flatArray_klass()) {\n-        return ciFlatArrayKlass::make(klass);\n-      }\n-    )\n-    return ciObjArrayKlass::make(klass, true);\n-  } else {\n+    ciKlass* klass = element_type->as_klass();\n+    if (null_free && klass->is_loaded()) {\n+      GUARDED_VM_ENTRY(\n+        EXCEPTION_CONTEXT;\n+        Klass* ak = InlineKlass::cast(klass->get_Klass())->null_free_inline_array_klass(THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+        } else if (ak != NULL && ak->is_flatArray_klass()) {\n+          return ciFlatArrayKlass::make(klass);\n+        }\n+      )\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-  static ciArrayKlass* make(ciType* element_type);\n-  static ciArrayKlass* make(ciKlass* klass, bool null_free);\n+  static ciArrayKlass* make(ciType* klass, bool null_free = false);\n@@ -67,0 +66,2 @@\n+\n+  virtual bool is_elem_null_free() const { return false; }\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,6 +101,1 @@\n-    ciType* type = ciEnv::current(THREAD)->get_klass_by_index(cpool, sig_index, ignore, klass);\n-    if (signature->is_Q_signature()) {\n-      _type = ciEnv::current(THREAD)->make_null_free_wrapper(type);\n-    } else {\n-      _type = type;\n-    }\n+    _type = ciEnv::current(THREAD)->get_klass_by_index(cpool, sig_index, ignore, klass);\n@@ -384,6 +379,0 @@\n-  ciType* rtype;\n-  if (_signature->is_Q_signature()) {\n-    rtype = CURRENT_ENV->make_null_free_wrapper(type);\n-  } else {\n-    rtype = type;\n-  }\n@@ -401,3 +390,2 @@\n-    if (!type_is_also_shared) {\n-      return rtype;              \/\/ Bummer.\n-    }\n+    if (!type_is_also_shared)\n+      return type;              \/\/ Bummer.\n@@ -405,2 +393,2 @@\n-  _type = rtype;\n-  return rtype;\n+  _type = type;\n+  return type;\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+\n+  virtual bool is_elem_null_free() const { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  _null_free = k->name()->is_Q_array_signature() && k->name()->char_at(1) == JVM_SIGNATURE_INLINE_TYPE;\n@@ -68,9 +69,10 @@\n-    _base_element_klass = base_element_klass;\n-    assert(_base_element_klass->is_instance_klass() ||\n-           _base_element_klass->is_type_array_klass() ||\n-           _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n-    if (dimension == 1) {\n-      _element_klass = base_element_klass;\n-    } else {\n-      _element_klass = NULL;\n-    }\n+  _base_element_klass = base_element_klass;\n+  assert(_base_element_klass->is_instance_klass() ||\n+         _base_element_klass->is_type_array_klass() ||\n+         _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n+  if (dimension == 1) {\n+    _element_klass = base_element_klass;\n+  } else {\n+    _element_klass = NULL;\n+  }\n+  _null_free = array_name->is_Q_array_signature() && array_name->char_at(1) == JVM_SIGNATURE_INLINE_TYPE;\n@@ -177,0 +179,4 @@\n+  \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+  if (!is_elem_null_free() && (!is_loaded() || element_klass()->is_inlinetype())) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  bool     _null_free;\n@@ -82,0 +83,2 @@\n+\n+  virtual bool is_elem_null_free() const { return _null_free; }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-\/\/ ciSignature::returns_inline_type\n+\/\/ ciSignature::returns_null_free_inline_type\n@@ -82,0 +82,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciSignature::is_null_free_at\n+\/\/\n+\/\/ True if we know that the argument at 'index' is null-free.\n+bool ciSignature::is_null_free_at(int index) const {\n+  return _types.at(index)->is_null_free();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciType.hpp\"\n@@ -59,1 +60,1 @@\n-  ciType*   type_at(int index) const             { return _types.at(index); }\n+  ciType*   type_at(int index) const             { return _types.at(index)->unwrap(); }\n@@ -61,0 +62,1 @@\n+  bool      is_null_free_at(int index) const;\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -294,0 +294,8 @@\n+  bool is_null_free() {\n+    if (at_return_type()) {\n+      return _sig->returns_null_free_inline_type();\n+    } else {\n+      return _sig->is_null_free_at(_pos);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-bool ciSymbol::is_Q_signature() {\n+bool ciSymbol::is_Q_signature() const {\n@@ -122,0 +122,6 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciSymbol::is_Q_array_signature\n+bool ciSymbol::is_Q_array_signature() const {\n+  GUARDED_VM_ENTRY(return get_symbol()->is_Q_array_signature();)\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  bool        is_Q_signature();\n+  bool is_Q_signature() const;\n+  bool is_Q_array_signature() const;\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  virtual bool is_null_free() const        { return false; }\n+  virtual bool is_null_free() const         { return false; }\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,11 @@\n-  } else if (t1->is_primitive_type() || t2->is_primitive_type()) {\n+  }\n+  \/\/ Unwrap after saving nullness information and handling top meets\n+  bool null_free1 = t1->is_null_free();\n+  bool null_free2 = t2->is_null_free();\n+  if (t1->unwrap() == t2->unwrap() && null_free1 == null_free2) {\n+    return t1;\n+  }\n+  t1 = t1->unwrap();\n+  t2 = t2->unwrap();\n+\n+  if (t1->is_primitive_type() || t2->is_primitive_type()) {\n@@ -280,1 +290,1 @@\n-    \/\/ is T (except for inline types).  null_type meet null_type is null_type.\n+    \/\/ is T. null_type meet null_type is null_type.\n@@ -282,4 +292,1 @@\n-      if (t2->is_inlinetype()) {\n-        \/\/ Inline types are null-free, return the super type\n-        return t2->as_inline_klass()->super();\n-      } else if (!t2->is_primitive_type() || t2->equals(null_type())) {\n+      if (!t2->is_primitive_type() || t2->equals(null_type())) {\n@@ -289,4 +296,1 @@\n-      if (t1->is_inlinetype()) {\n-        \/\/ Inline types are null-free, return the super type\n-        return t1->as_inline_klass()->super();\n-      } else if (!t1->is_primitive_type()) {\n+      if (!t1->is_primitive_type()) {\n@@ -323,0 +327,2 @@\n+      bool null_free = k1->as_array_klass()->is_elem_null_free() &&\n+                       k2->as_array_klass()->is_elem_null_free();\n@@ -330,2 +336,2 @@\n-      if (elem == elem1) {\n-        assert(k1 == ciArrayKlass::make(elem), \"shortcut is OK\");\n+      if (elem == elem1 && !elem->is_inlinetype()) {\n+        assert(k1 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n@@ -333,2 +339,2 @@\n-      } else if (elem == elem2) {\n-        assert(k2 == ciArrayKlass::make(elem), \"shortcut is OK\");\n+      } else if (elem == elem2 && !elem->is_inlinetype()) {\n+        assert(k2 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n@@ -337,1 +343,1 @@\n-        return ciArrayKlass::make(elem);\n+        return ciArrayKlass::make(elem, null_free);\n@@ -346,1 +352,5 @@\n-    return k1->least_common_ancestor(k2);\n+    ciType* result = k1->least_common_ancestor(k2);\n+    if (null_free1 && null_free2) {\n+      result = analyzer->mark_as_null_free(result);\n+    }\n+    return result;\n@@ -408,1 +418,6 @@\n-    state->push(method()->holder());\n+    ciType* holder = method()->holder();\n+    if (holder->is_inlinetype()) {\n+      \/\/ The receiver is null-free\n+      holder = mark_as_null_free(holder);\n+    }\n+    state->push(holder);\n@@ -414,1 +429,5 @@\n-    state->push_translate(str.type());\n+    ciType* arg = str.type();\n+    if (str.is_null_free()) {\n+      arg = mark_as_null_free(arg);\n+    }\n+    state->push_translate(arg);\n@@ -590,1 +609,5 @@\n-    push_object(element_klass);\n+    if (array_klass->is_elem_null_free()) {\n+      push(outer()->mark_as_null_free(element_klass));\n+    } else {\n+      push_object(element_klass);\n+    }\n@@ -600,0 +623,1 @@\n+  bool null_free = str->has_Q_signature();\n@@ -601,1 +625,1 @@\n-    if (str->has_Q_signature()) {\n+    if (null_free) {\n@@ -615,2 +639,6 @@\n-    pop_object();\n-    push_object(klass);\n+    ciType* type = pop_value();\n+    if (klass->is_inlinetype() && (null_free || type->is_null_free())) {\n+      push(outer()->mark_as_null_free(klass));\n+    } else {\n+      push_object(klass);\n+    }\n@@ -658,0 +686,3 @@\n+      if (field->is_null_free()) {\n+        field_type = outer()->mark_as_null_free(field_type);\n+      }\n@@ -725,0 +756,3 @@\n+        if (sigstr.is_null_free()) {\n+          return_type = outer()->mark_as_null_free(return_type);\n+        }\n@@ -749,1 +783,5 @@\n-        push_object(obj->klass());\n+        ciType* type = obj->klass();\n+        if (type->is_inlinetype()) {\n+          type = outer()->mark_as_null_free(type);\n+        }\n+        push(type);\n@@ -802,1 +840,1 @@\n-    push_object(klass);\n+    push(outer()->mark_as_null_free(klass));\n@@ -823,2 +861,1 @@\n-    assert(klass->is_inlinetype(), \"should be inline type\");\n-    push_object(klass);\n+    push(outer()->mark_as_null_free(klass));\n@@ -961,1 +998,2 @@\n-        push_object(ciArrayKlass::make(element_klass));\n+        bool null_free = str->has_Q_signature();\n+        push_object(ciArrayKlass::make(element_klass, null_free));\n@@ -3039,0 +3077,5 @@\n+ciType* ciTypeFlow::mark_as_null_free(ciType* type) {\n+  \/\/ Wrap the type to carry the information that it is null-free\n+  return env()->make_null_free_wrapper(type);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":70,"deletions":27,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -842,0 +842,2 @@\n+  ciType* mark_as_null_free(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1171,1 +1171,1 @@\n-static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit) {\n+static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit, bool null_free) {\n@@ -1176,1 +1176,1 @@\n-  if (t->as_klass()->is_inlinetype()) {\n+  if (t->as_klass()->is_inlinetype() && null_free) {\n@@ -1284,1 +1284,1 @@\n-          cast_argument(nargs, 0, signature->accessing_klass(), kit);\n+          cast_argument(nargs, 0, signature->accessing_klass(), kit, false);\n@@ -1290,1 +1290,2 @@\n-            cast_argument(nargs, receiver_skip + j, t, kit);\n+            bool null_free = signature->is_null_free_at(i);\n+            cast_argument(nargs, receiver_skip + j, t, kit, null_free);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4554,0 +4554,7 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Perform a full test.\n+  if (superk->is_obj_array_klass() && !superk->as_array_klass()->is_elem_null_free() &&\n+      superk->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return SSC_full_test;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-            if (ct == T_INLINE_TYPE) {\n+            if (declared_signature->returns_null_free_inline_type()) {\n@@ -745,1 +745,2 @@\n-    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType()) {\n+    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType() &&\n+        !gvn().type(peek())->maybe_null() && rtype->as_inline_klass()->is_scalarizable()) {\n@@ -747,4 +748,1 @@\n-      assert(!gvn().type(retnode)->maybe_null(), \"should never be null\");\n-      if (rtype->as_inline_klass()->is_scalarizable()) {\n-        retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n-      }\n+      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3452,1 +3452,1 @@\n-Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control) {\n+Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control, bool null_free) {\n@@ -3456,2 +3456,0 @@\n-\n-  \/\/ Check if inline types are involved\n@@ -3459,1 +3457,1 @@\n-  bool to_inline = tk->klass()->is_inlinetype();\n+  assert(!null_free || toop->is_inlinetypeptr(), \"must be an inline type pointer\");\n@@ -3485,1 +3483,1 @@\n-          if (to_inline) {\n+          if (null_free) {\n@@ -3487,3 +3485,3 @@\n-            if (toop->inline_klass()->is_scalarizable()) {\n-              obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n-            }\n+          }\n+          if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(obj)->maybe_null()) {\n+            obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n@@ -3494,1 +3492,1 @@\n-        if (from_inline || to_inline) {\n+        if (from_inline || null_free) {\n@@ -3498,1 +3496,1 @@\n-          \/\/ Inline type is never null. Always throw an exception.\n+          \/\/ Inline type is null-free. Always throw an exception.\n@@ -3547,1 +3545,1 @@\n-  } else if (to_inline) {\n+  } else if (null_free) {\n@@ -3679,2 +3677,1 @@\n-    if (to_inline && toop->inline_klass()->is_scalarizable()) {\n-      assert(!gvn().type(res)->maybe_null(), \"Inline types are null-free\");\n+    if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(res)->maybe_null()) {\n@@ -3743,2 +3740,1 @@\n-  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n-  if (val_t == TypePtr::NULL_PTR && !ary_t->is_not_null_free()) {\n+  if (val_t == TypePtr::NULL_PTR) {\n@@ -3746,0 +3742,1 @@\n+    const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n@@ -3938,1 +3935,2 @@\n-    if (UseFlatArray && klass->is_obj_array_klass()) {\n+    if (UseFlatArray && klass->is_obj_array_klass() && !klass->as_obj_array_klass()->is_elem_null_free()) {\n+      \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n@@ -3942,1 +3940,1 @@\n-    if (xklass || (klass->is_array_klass() && !can_be_flattened)) {\n+    if (!can_be_flattened && (xklass || klass->is_array_klass())) {\n@@ -4326,3 +4324,3 @@\n-  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue$ref\")\n-  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue$val\")\n-  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue$val\")\n+  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue\")\n+  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue\")\n+  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n@@ -4335,3 +4333,2 @@\n-    ciKlass* elem_klass = ary_ptr->klass()->as_array_klass()->element_klass();\n-    if (elem_klass != NULL && elem_klass->is_inlinetype()) {\n-      ciInlineKlass* vk = elem_klass->as_inline_klass();\n+    if (ary_ptr->klass()->as_array_klass()->is_elem_null_free()) {\n+      ciInlineKlass* vk = ary_ptr->klass()->as_array_klass()->element_klass()->as_inline_klass();\n@@ -4711,1 +4708,1 @@\n-    } else if (con_type->is_zero_type() && field->type()->is_inlinetype()) {\n+    } else if (con_type->is_zero_type() && field->is_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL);\n+  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL, bool null_free = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,0 +195,7 @@\n+bool InlineTypeBaseNode::field_is_null_free(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n+  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  return field->is_null_free();\n+}\n+\n@@ -276,0 +283,1 @@\n+    bool is_null_free = field_is_null_free(i);\n@@ -296,2 +304,1 @@\n-        if (con_type->is_inlinetypeptr()) {\n-          assert(!con_type->is_zero_type(), \"Inline types are null-free\");\n+        if (con_type->is_inlinetypeptr() && !con_type->is_zero_type()) {\n@@ -299,0 +306,1 @@\n+          is_null_free = true;\n@@ -312,1 +320,1 @@\n-      if (ft->is_inlinetype()) {\n+      if (is_null_free) {\n@@ -542,1 +550,1 @@\n-    if (field_type->is_inlinetype()) {\n+    if (vt->field_is_null_free(i)) {\n@@ -798,1 +806,1 @@\n-      if (type->is_inlinetype()) {\n+      if (field_is_null_free(i)) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  bool          field_is_null_free(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2400,1 +2400,6 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          if (t->is_inlinetype()) {\n+            \/\/ TODO fix with JDK-8267932\n+            return LoadNode::Value(phase);\n+          } else {\n+            return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          }\n@@ -2452,1 +2457,3 @@\n-          if (!ik->is_interface() && !ik->has_subklass()) {\n+          \/\/ Do not fold klass loads from [LMyValue. The runtime type might be [QMyValue due to [QMyValue <: [LMyValue\n+          \/\/ and the klass for [QMyValue is not equal to the klass for [LMyValue.\n+          if (!ik->is_interface() && !ik->has_subklass() && (!ik->is_inlinetype() || ak->is_elem_null_free())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-    if (tp->klass()->is_inlinetype()) {\n+    if (tp->is_inlinetypeptr() && !tp->maybe_null()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-        ciArrayKlass* array_klass = ciArrayKlass::make(vk);\n+        ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n@@ -347,1 +347,1 @@\n-          ciArrayKlass* array_klass = ciArrayKlass::make(vk);\n+          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  if (bt == T_INLINE_TYPE && field_klass->as_inline_klass()->is_empty()) {\n+  if (field->is_null_free() && field_klass->as_inline_klass()->is_empty()) {\n@@ -170,1 +170,1 @@\n-        if (bt == T_INLINE_TYPE && field->is_static()) {\n+        if (field->is_null_free() && field->is_static()) {\n@@ -187,1 +187,1 @@\n-    if (bt == T_INLINE_TYPE) {\n+    if (field->is_null_free()) {\n@@ -234,2 +234,2 @@\n-  assert(bt != T_INLINE_TYPE || val->is_InlineType() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n-  if (bt == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+  assert(!field->is_null_free() || val->is_InlineType() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n+  if (field->is_null_free() && field->type()->as_inline_klass()->is_empty()) {\n@@ -299,0 +299,1 @@\n+  bool null_free = iter().has_Q_signature();\n@@ -305,1 +306,1 @@\n-  ciArrayKlass* array_klass = ciArrayKlass::make(klass);\n+  ciArrayKlass* array_klass = ciArrayKlass::make(klass, null_free);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  bool null_free = iter().has_Q_signature();\n@@ -79,1 +80,1 @@\n-    assert(!iter().has_Q_signature(), \"Inline type should be loaded\");\n+    assert(!null_free, \"Inline type should be loaded\");\n@@ -96,1 +97,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)), NULL, null_free);\n@@ -260,2 +261,1 @@\n-  \/\/ Handle inline type arrays\n-  if (elemtype->isa_inlinetype() != NULL || (elemtype->is_inlinetypeptr() && !elemtype->maybe_null())) {\n+  if (elemtype->isa_inlinetype() != NULL || elemtype->is_inlinetypeptr()) {\n@@ -349,1 +349,1 @@\n-  if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n+  if (!val->is_InlineType() && field->is_null_free()) {\n@@ -353,1 +353,1 @@\n-  } else if (val->is_InlineType() && !field->type()->is_inlinetype()) {\n+  } else if (val->is_InlineType() && !field->is_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -998,2 +998,2 @@\n-        } else if ((r0->is_not_null_free() && klass1->is_obj_array_klass() && klass1->as_obj_array_klass()->element_klass()->is_inlinetype()) ||\n-                   (r1->is_not_null_free() && klass0->is_obj_array_klass() && klass0->as_obj_array_klass()->element_klass()->is_inlinetype())) {\n+        } else if ((r0->is_not_null_free() && klass1->is_array_klass() && klass1->as_array_klass()->is_elem_null_free()) ||\n+                   (r1->is_not_null_free() && klass0->is_array_klass() && klass0->as_array_klass()->is_elem_null_free())) {\n@@ -1161,0 +1161,8 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Do not bypass the klass load from the primary supertype array.\n+  if (superklass->is_obj_array_klass() && !superklass->as_array_klass()->is_elem_null_free() &&\n+      superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                 superk->is_obj_array_klass() && superk->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n+                 superk->is_array_klass() && superk->as_array_klass()->is_elem_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,2 +271,3 @@\n-    ciInlineKlass* vk = type->as_inline_klass();\n-    if (vk->is_scalarizable()) {\n+    bool is_null_free = type->is_null_free();\n+    ciInlineKlass* vk = type->unwrap()->as_inline_klass();\n+    if (vk->is_scalarizable() && is_null_free) {\n@@ -275,1 +276,1 @@\n-      return TypeOopPtr::make_from_klass(vk)->join_speculative(TypePtr::NOTNULL);\n+      return TypeOopPtr::make_from_klass(vk)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2088,1 +2089,1 @@\n-      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(TypePtr::NOTNULL);\n+      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2148,1 +2149,2 @@\n-      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields()) {\n+      bool is_null_free = sig->is_null_free_at(i);\n+      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields() && is_null_free) {\n@@ -2151,1 +2153,1 @@\n-        field_array[pos++] = get_const_type(type)->join_speculative(TypePtr::NOTNULL);\n+        field_array[pos++] = get_const_type(type)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2449,2 +2451,10 @@\n-  if (tinst)\n-    return tklass->as_instance_klass()->is_final();\n+  if (tinst) {\n+    if (tklass->as_instance_klass()->is_final()) {\n+      \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+      if (tinst->is_inlinetypeptr() && (tinst->ptr() == TypePtr::BotPTR || tinst->ptr() == TypePtr::TopPTR)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -3566,1 +3576,2 @@\n-    if (etype->is_inlinetypeptr()) {\n+    bool null_free = klass->as_array_klass()->is_elem_null_free();\n+    if (null_free) {\n@@ -3578,1 +3589,2 @@\n-    bool xk = etype->klass_is_exact();\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    bool xk = etype->klass_is_exact() && (!etype->is_inlinetypeptr() || null_free);\n@@ -3624,1 +3636,1 @@\n-    if (etype->is_inlinetypeptr()) {\n+    if (klass->as_array_klass()->is_elem_null_free()) {\n@@ -5512,1 +5524,2 @@\n-    k_ary = ciArrayKlass::make(el->is_oopptr()->klass());\n+    bool null_free = el->is_inlinetypeptr() && el->isa_instptr()->ptr() != TypePtr::TopPTR && !el->isa_instptr()->maybe_null();\n+    k_ary = ciArrayKlass::make(el->is_oopptr()->klass(), null_free);\n@@ -5516,1 +5529,1 @@\n-      k_ary = ciArrayKlass::make(el->inline_klass());\n+      k_ary = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n@@ -5875,1 +5888,2 @@\n-  bool has_scalar_ret = sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  bool has_scalar_ret = sig->returns_null_free_inline_type() && sig->return_type()->is_inlinetype() &&\n+                        sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1354,1 +1354,1 @@\n-  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr()); }\n+  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr() && !_ary->_elem->make_ptr()->maybe_null()); }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1338,1 +1338,1 @@\n-        if (field._type == T_INLINE_TYPE) {\n+        if (fs.signature()->is_Q_signature()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}