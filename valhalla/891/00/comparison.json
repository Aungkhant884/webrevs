{"files":[{"patch":"@@ -102,0 +102,7 @@\n+    \/** Marks a type as a primitive class. We can't reuse the class file encoding (ACC_PRIMITIVE)\n+     * since the latter shares its value (0x800) with ACC_STRICT (javac speak: STRICT_FP) and while\n+     * STRICT_FP is not a valid flag for a class in the class file level, javac's ASTs flag a class\n+     * as being STRICT_FP so as to propagate the FP strictness to methods of the class thereby causing\n+     * a clash *\/\n+    public static final int PRIMITIVE_CLASS  = 1<<16;\n+\n@@ -114,0 +121,1 @@\n+    public static final int ACC_PRIMITIVE = 0x0800;\n@@ -545,0 +553,2 @@\n+        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n+        VALUE(Flags.VALUE_CLASS),\n@@ -549,1 +559,0 @@\n-        VALUE(Flags.VALUE_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -359,0 +359,6 @@\n+        if (isValueObjectFactory()) {\n+            \/\/ this is a hack just for the experimental patch\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }\n@@ -1702,1 +1708,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -238,0 +238,4 @@\n+    public boolean hasImplicitConstructor() {\n+        return false;\n+    }\n+\n@@ -1047,0 +1051,34 @@\n+    public static class ConstantPoolQType implements PoolConstant {\n+\n+        public final Type type;\n+        final Types types;\n+\n+        public ConstantPoolQType(Type type, Types types) {\n+            this.type = type;\n+            this.types = types;\n+        }\n+\n+        @Override\n+        public Object poolKey(Types types) {\n+            return this;\n+        }\n+\n+        @Override\n+        public int poolTag() {\n+            return ClassFile.CONSTANT_Class;\n+        }\n+\n+        public int hashCode() {\n+            return types.hashCode(type);\n+        }\n+\n+        public boolean equals(Object obj) {\n+            return (obj instanceof ConstantPoolQType) &&\n+                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n+        }\n+\n+        public String toString() {\n+            return type.toString();\n+        }\n+    }\n+\n@@ -1252,0 +1290,5 @@\n+        @Override\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).getImplicitConstructor() != null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+    private boolean emitQDesc;\n+\n@@ -127,0 +129,2 @@\n+        Options options = Options.instance(context);\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -1828,1 +1832,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && !t.isNonNullable())\n@@ -5252,1 +5256,4 @@\n-                    append('L');\n+                    if (types.emitQDesc && type.hasImplicitConstructor() && type.isNonNullable())\n+                        append('Q');\n+                    else\n+                        append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final boolean emitQDesc;\n@@ -136,0 +137,1 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -4215,1 +4217,1 @@\n-        if (tree.elemtype == null || !originalElemType.type.isNonNullable()) {\n+        if (emitQDesc || tree.elemtype == null || !originalElemType.type.isNonNullable()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,0 +140,4 @@\n+    \/** Switch: emit Q descriptors\n+     *\/\n+    private boolean emitQDesc;\n+\n@@ -307,0 +311,2 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n+\n@@ -513,0 +519,1 @@\n+        case 'Q':\n@@ -516,0 +523,4 @@\n+                if ((char) signature[sigp] == 'Q' && !emitQDesc) {\n+                    throw badClassFile(\"bad.class.signature\",\n+                                       quoteBadSignature());\n+                }\n@@ -574,1 +585,1 @@\n-        if (prefix != 'L')\n+        if (prefix != 'L' && (!emitQDesc || prefix != 'Q'))\n@@ -2652,0 +2663,5 @@\n+        if ((flags & PRIMITIVE_CLASS) != 0) {\n+            if (!emitQDesc || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n+                throw badClassFile(\"bad.access.flags\", Flags.toString(flags));\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    \/** Switch: emit Q descriptors\n+     *\/\n+    private boolean emitQDesc;\n+\n@@ -198,0 +202,1 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -845,1 +850,1 @@\n-            int flags = adjustFlags(inner.flags_field);\n+            int flags = adjustFlags(inner, inner.flags_field);\n@@ -1010,1 +1015,1 @@\n-        int flags = adjustFlags(v.flags());\n+        int flags = adjustFlags(v, v.flags());\n@@ -1039,1 +1044,1 @@\n-        int flags = adjustFlags(m.flags());\n+        int flags = adjustFlags(m, m.flags());\n@@ -1326,1 +1331,1 @@\n-                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n+                databuf.appendChar(emitQDesc && t.hasImplicitConstructor() && t.isNonNullable() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n@@ -1639,1 +1644,1 @@\n-            flags = adjustFlags(c.flags() & ~(DEFAULT | STRICTFP));\n+            flags = adjustFlags(c, c.flags() & ~(DEFAULT | STRICTFP));\n@@ -1806,1 +1811,1 @@\n-    int adjustFlags(final long flags) {\n+    int adjustFlags(Symbol sym, final long flags) {\n@@ -1819,0 +1824,6 @@\n+        if (emitQDesc && sym.kind == TYP) {\n+            ClassSymbol csym = (ClassSymbol)sym;\n+            if (csym.isValueClass() && csym.getImplicitConstructor() != null) {\n+                result |= ACC_PRIMITIVE;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-            Type t = types.erasure((Type)data);\n+            Type t = types.erasure(data instanceof  ConstantPoolQType ? ((ConstantPoolQType)data).type: (Type)data);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -148,0 +149,1 @@\n+    private final boolean emitQDesc;\n@@ -277,0 +279,4 @@\n+        return makeRef(pos, type, false);\n+    }\n+\n+    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n@@ -278,1 +284,5 @@\n-        return poolWriter.putClass(type);\n+        if (emitQtype) {\n+            return poolWriter.putClass(new ConstantPoolQType(type, types));\n+        } else {\n+            return poolWriter.putClass(type);\n+        }\n@@ -915,1 +925,1 @@\n-            if (pts.head.isNonNullable()) {\n+            if (pts.head.isNonNullable() && !l.head.type.isNonNullable()) {\n@@ -1069,0 +1079,2 @@\n+                boolean shouldBeQDesc = emitQDesc && selfType.hasImplicitConstructor();\n+                selfType = shouldBeQDesc ? selfType.addMetadata(new TypeMetadata.NullMarker(JCNullableTypeExpression.NullMarker.NOT_NULL)) : selfType;\n@@ -1073,1 +1085,3 @@\n-                            new VarSymbol(FINAL, names._this, selfType, meth.owner)));\n+                            new VarSymbol(FINAL, names._this,\n+                                    selfType,\n+                                    meth.owner)));\n@@ -1101,1 +1115,1 @@\n-                if (tree.type.isNonNullable()) {\n+                if (tree.type.isNonNullable() && !tree.init.type.isNonNullable()) {\n@@ -2110,1 +2124,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype), type);\n+                code.emitAnewarray(makeRef(pos, elemtype, emitQDesc && elemtype.hasImplicitConstructor() && elemtype.isNonNullable()), type);\n@@ -2126,1 +2140,1 @@\n-        if (tree.lhs.type.isNonNullable()) {\n+        if (tree.lhs.type.isNonNullable() && !tree.rhs.type.isNonNullable()) {\n@@ -2335,1 +2349,1 @@\n-        if (tree.clazz.type.isNonNullable()) {\n+        if (tree.clazz.type.isNonNullable() && !tree.expr.type.isNonNullable()) {\n@@ -2347,1 +2361,6 @@\n-            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);\n+            checkDimension(tree.pos(), tree.clazz.type);\n+            if (emitQDesc && tree.clazz.type.hasImplicitConstructor() && tree.clazz.type.isNonNullable()) {\n+                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n+            } else {\n+                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n+            }\n@@ -2409,1 +2428,2 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type,\n+                    emitQDesc && tree.selected.type.hasImplicitConstructor() && tree.selected.type.isNonNullable()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.code.Type.ConstantPoolQType;\n@@ -130,0 +131,8 @@\n+    \/**\n+     * Puts a type into the pool and return its index. The type could be either a class, a type variable\n+     * or an array type.\n+     *\/\n+    int putClass(ConstantPoolQType t) {\n+        return pool.writeIfNeeded(t);\n+    }\n+\n@@ -388,1 +397,1 @@\n-                    Type ct = (Type)c;\n+                    Type ct = c instanceof ConstantPoolQType ? ((ConstantPoolQType)c).type : (Type)c;\n@@ -391,1 +400,1 @@\n-                            externalize(ct.tsym.flatName());\n+                      c instanceof ConstantPoolQType ? names.fromString(\"Q\" + externalize(ct.tsym.flatName()) + \";\") : externalize(ct.tsym.flatName());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.code.TypeMetadata;\n@@ -57,0 +58,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -93,0 +95,2 @@\n+    private boolean emitQDesc;\n+\n@@ -124,0 +128,2 @@\n+        Options options = Options.instance(context);\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -195,1 +201,7 @@\n-                VarSymbol product = currentMethod.factoryProduct = new VarSymbol(0, names.dollarValue, currentClass.sym.type, currentMethod.sym); \/\/ TODO: owner needs rewiring\n+                boolean emitQ = emitQDesc && currentClass.sym.type.hasImplicitConstructor();\n+                VarSymbol product = currentMethod.factoryProduct =\n+                        new VarSymbol(0, names.dollarValue,\n+                                emitQ ?\n+                                        currentClass.sym.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n+                                        currentClass.sym.type,\n+                                currentMethod.sym); \/\/ TODO: owner needs rewiring\n@@ -203,1 +215,5 @@\n-                    final JCExpression type = make.Type(currentClass.type);\n+                    final JCExpression type = make.Type(\n+                            emitQ ?\n+                                    currentClass.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n+                                    currentClass.type\n+                            );\n@@ -205,1 +221,3 @@\n-                    rhs.type = currentClass.type;\n+                    rhs.type = emitQ ?\n+                            currentClass.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n+                            currentClass.type;\n@@ -224,1 +242,3 @@\n-                currentMethod.setType(factorySym.type);\n+                MethodType mt = (MethodType) factorySym.type;\n+                mt.restype = mt.restype.addMetadata((new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)));\n+                currentMethod.setType(mt);\n@@ -277,1 +297,5 @@\n-                result = make.Assign(facHandle, make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type)).setType(currentClass.type);\n+                JCTree.JCWithField withField = (JCTree.JCWithField) make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type);\n+                if (emitQDesc && withField.type.hasImplicitConstructor()) {\n+                    withField.type = withField.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+                }\n+                result = make.Assign(facHandle, withField).setType(currentClass.type);\n@@ -353,0 +377,1 @@\n+            \/\/apply.type = apply.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -5761,1 +5761,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8212175\n+ * @summary Trouble creating an anonymous value class with diamond syntax\n+ * @compile -XDemitQDesc AnonymousValue.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AnonymousValue\n+ *\/\n+\n+import java.util.function.Function;\n+\n+public class AnonymousValue {\n+    static Function<String, String> capitalizer() {\n+        return new value Function<>() {\n+            int x = 10;\n+            @Override\n+            public String apply(String t) {\n+                return t.toUpperCase();\n+            }\n+        };\n+    }\n+    public static void main(String[] args) {\n+        if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n+            throw new AssertionError(\"Failed\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValue.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ * @compile -XDemitQDesc AnonymousValueType.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xverify:none AnonymousValueType\n+ *\/\n+\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValueType.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8222634\n+ * @summary Check array creation with V and V.ref\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDemitQDesc ArrayCreationWithQuestion.java\n+ * @run main\/othervm -Xverify:none -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ArrayCreationWithQuestion\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+public class ArrayCreationWithQuestion {\n+\n+    static value class VT {\n+        VT[] a1;\n+        VT[] a2;\n+        VT![] a3;\n+        VT![] a4;\n+\n+        public implicit VT();\n+\n+        VT(boolean non_implicit) {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+            a3 = new VT![42];\n+            a4 = new VT![42];\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new ArrayCreationWithQuestion().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"ArrayCreationWithQuestion$VT.class\").toString() };\n+        runCheck(params, new String [] {\n+        \"         6: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        17: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        28: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n+        \"        39: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayCreationWithQuestion.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8222402\n+ * @summary LW2 array support in javac\n+ * @compile -XDemitQDesc ArrayRelationsTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ArrayRelationsTest\n+ *\/\n+\n+public value class ArrayRelationsTest {\n+\n+    int x;\n+\n+    public implicit ArrayRelationsTest();\n+\n+    public static void main(String [] args) {\n+        ArrayRelationsTest [] la = new ArrayRelationsTest[10];\n+        ArrayRelationsTest! [] qa = new ArrayRelationsTest![10];\n+        boolean cce = false;\n+        try {\n+            qa = (ArrayRelationsTest[]) (Object []) (new String [10]);\n+        } catch (ClassCastException e) {\n+            cce = true;\n+        }\n+        if (!cce) {\n+            throw new AssertionError(\"Missing CCE\");\n+        }\n+        la = qa;\n+        ArrayRelationsTest[] la2 = qa;\n+        ArrayRelationsTest! [] qa2 = (ArrayRelationsTest! []) la2;\n+        boolean npe = false;\n+        try {\n+            la2[0] = null;\n+        } catch (NullPointerException e) {\n+            npe = true;\n+        }\n+        if (!npe) {\n+            throw new AssertionError(\"Missing NPE\");\n+        }\n+        npe = false;\n+        Object [] oa = qa;\n+        try {\n+            oa[0] = null;\n+        } catch (NullPointerException e) {\n+            npe = true;\n+        }\n+        if (!npe) {\n+            throw new AssertionError(\"Missing NPE\");\n+        }\n+\n+        \/\/ round trip;\n+        Object o = oa = la = qa;\n+        qa = (ArrayRelationsTest![]) (la = (ArrayRelationsTest []) (oa = (Object []) o));\n+        qa [0] = new ArrayRelationsTest();\n+\n+        npe = false;\n+        try {\n+            la[0] = null;\n+        } catch (NullPointerException e) {\n+            npe = true;\n+        }\n+        if (!npe) {\n+            throw new AssertionError(\"Missing NPE\");\n+        }\n+\n+        la = new ArrayRelationsTest [10];\n+\n+        cce = false;\n+        try {\n+            qa = (ArrayRelationsTest![]) la;\n+        } catch (ClassCastException c) {\n+            cce = true;\n+        }\n+        if (!cce) {\n+            throw new AssertionError(\"Unexpected CCE behavior\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -31,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses AsSuperTests.java\n+ * @compile -XDemitQDesc AsSuperTests.java\n@@ -53,1 +52,1 @@\n-       String m(Foo f);\n+        String m(Foo! f);\n@@ -62,1 +61,3 @@\n-    static primitive class Foo<X> extends Base {}\n+    static value class Foo<X> extends Base {\n+        public implicit Foo();\n+    }\n@@ -65,1 +66,2 @@\n-primitive class X extends Base implements I {\n+value class X extends Base implements I {\n+    public implicit X();\n@@ -74,1 +76,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AsSuperTests.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8222634\n+ * @summary Check various code snippets that were incorrectly failing to compile.\n+ * @compile -XDemitQDesc AssortedTests.java\n+ *\/\n+\n+value class MyValue1 {\n+    final int x;\n+    public implicit MyValue1();\n+}\n+\n+class X {\n+    static final MyValue1! vField = new MyValue1();\n+\n+    static value class MyValue2 {\n+        final MyValue1! vBoxField;\n+        public implicit MyValue2();\n+    }\n+\n+    public static void main(String[] args) { }\n+}\n+\n+value class MyValue3 {\n+    final int x;\n+    public implicit MyValue3();\n+    public int hash() { return 0; }\n+}\n+\n+class Y {\n+\n+    value class MyValue4 {\n+        final MyValue3 vBoxField = null;\n+\n+        public int test() {\n+            return vBoxField.hash();\n+        }\n+    }\n+\n+    public static void main(String[] args) { }\n+}\n+\n+interface MyInterface {\n+    public void test(MyValue5 vt);\n+}\n+\n+value class MyValue5 implements MyInterface {\n+    final int x;\n+\n+    public implicit MyValue5();\n+\n+    @Override\n+    public void test(MyValue5 vt) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AssortedTests.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary V.ref class should not inadvertently carry over attributes from V.class\n+ * @bug 8244713\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDemitQDesc AttributesTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AttributesTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+public class AttributesTest {\n+\n+    void foo() {\n+        @Deprecated\n+        static value class V<T> {\n+            public implicit V();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(AttributesTest.class.getResourceAsStream(\"AttributesTest$1V.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of inner class attribute *\/\n+        InnerClasses_attribute inners = (InnerClasses_attribute) cls.attributes.get(Attribute.InnerClasses);\n+        if (inners == null) {\n+            throw new AssertionError(\"Missing inner class attribute\");\n+        }\n+        if (inners.number_of_classes != 1) {\n+            throw new AssertionError(\"Unexpected inner class attribute\");\n+        }\n+        String name = inners.classes[0].getInnerName(cls.constant_pool);\n+        if (!name.equals(\"V\")) {\n+            throw new AssertionError(\"Unexpected inner class \" + name);\n+        }\n+\n+        \/\/ Test emission of nest host attribute. Nest members attribute tested in InlineNesting*\n+        NestHost_attribute nestHost = (NestHost_attribute)cls.attributes.get(Attribute.NestHost);\n+        CONSTANT_Class_info host = nestHost != null ? nestHost.getNestTop(cls.constant_pool) : null;\n+        if (host == null || !host.getName().equals(\"AttributesTest\")) {\n+            throw new RuntimeException(\"Wrong Nest host \" + host.getName());\n+        }\n+\n+        \/\/ Test signature attribute\n+        Signature_attribute signature = (Signature_attribute)cls.attributes.get(Attribute.Signature);\n+        String sign =  signature.getSignature(cls.constant_pool);\n+        if (sign == null || !sign.equals(\"<T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\")) {\n+            throw new RuntimeException(\"Wrong signature \" + sign);\n+        }\n+\n+        \/\/ Test SourceFile attribute\n+        SourceFile_attribute source = (SourceFile_attribute)cls.attributes.get(Attribute.SourceFile);\n+        String src =  source.getSourceFile(cls.constant_pool);\n+        if (src == null || !src.equals(\"AttributesTest.java\")) {\n+            throw new RuntimeException(\"Wrong source \" + src);\n+        }\n+\n+        \/\/ Test Deprecated attribute\n+        Deprecated_attribute depr = (Deprecated_attribute) cls.attributes.get(Attribute.Deprecated);\n+        if (depr == null) {\n+            throw new RuntimeException(\"Missing deprecated annotation\");\n+        }\n+\n+        \/\/ Test EnclosingMethod attribute\n+        EnclosingMethod_attribute meth = (EnclosingMethod_attribute) cls.attributes.get(Attribute.EnclosingMethod);\n+        if (meth == null) {\n+            throw new RuntimeException(\"Missing enclosing method attribute\");\n+        }\n+        String mName = meth.getMethodName(cls.constant_pool);\n+        if (mName == null || !mName.equals(\"foo\")) {\n+            throw new RuntimeException(\"Wrong enclosing method \" + mName);\n+        }\n+\n+        \/\/ The following attributes should not be present in the projection file.\n+        String [] shouldBeAbsent = {\n+                                        \"SourceDebugExtension\",\n+                                        \"BootstrapMethods\",\n+                                        \"Module\",\n+                                        \"ModulePackages\",\n+                                        \"ModuleMainClass\",\n+                                        \"Synthetic\",\n+                                   };\n+        for (String attr : shouldBeAbsent) {\n+            if (cls.getAttribute(attr) != null) {\n+                throw new RuntimeException(\"Unexpected attribute: \" + attr);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AttributesTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -30,2 +30,1 @@\n- * @ignore\n- * @compile -XDenablePrimitiveClasses AutoCloseableTest.java\n+ * @compile -XDemitQDesc AutoCloseableTest.java\n@@ -37,1 +36,1 @@\n-    primitive static class Foo implements AutoCloseable {\n+    value static class Foo implements AutoCloseable {\n@@ -39,1 +38,7 @@\n-        String s = \"Exception while closing AutoCloseable\";\n+        String s;\n+\n+        public implicit Foo();\n+\n+        public Foo(boolean dummy) {\n+            s = \"Exception while closing AutoCloseable\";\n+        }\n@@ -51,1 +56,1 @@\n-        try (Foo foo = new Foo()) {\n+        try (Foo! foo = new Foo(false)) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AutoCloseableTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @ignore\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n+ * @compile -XDemitQDesc BogusIncompatibility.java\n+ * @compile -XDemitQDesc BogusIncompatibility.java\n@@ -34,2 +33,2 @@\n-  MyValue.ref field = MyValue.create();\n-  MyValue.ref field2 = MyValue.create();\n+  MyValue field = MyValue.create();\n+  MyValue field2 = MyValue.create();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BogusIncompatibility.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -30,1 +29,1 @@\n- * @compile -XDenablePrimitiveClasses BoxValCastTest.java\n+ * @compile -XDemitQDesc BoxValCastTest.java\n@@ -41,7 +40,7 @@\n-    static primitive class VT {\n-        int f = 0;\n-        static final VT.ref vtbox = (VT.ref) new VT(); \/\/ no binary cast\n-        static VT vt = (VT) vtbox; \/\/ binary cast\n-        static VT.ref box = vt; \/\/ no binary cast\n-        static VT.ref box2 = (VT) box; \/\/ binary cast\n-        static VT.ref box3 = id(new VT()); \/\/ no binary cast + no binary cast\n+    static value class VT {\n+        int f;\n+        static final VT vtbox = (VT) new VT(); \/\/ no binary cast\n+        static VT! vt = (VT!) vtbox; \/\/ binary cast\n+        static VT box = vt; \/\/ no binary cast\n+        static VT box2 = (VT!) box; \/\/ binary cast\n+        static VT box3 = id(new VT!()); \/\/ no binary cast + no binary cast\n@@ -49,2 +48,4 @@\n-        static VT id(VT.ref vtb) {\n-            return (VT) vtb; \/\/ binary\n+        public implicit VT();\n+\n+        static VT! id(VT vtb) {\n+            return (VT!) vtb; \/\/ binary\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BoxValCastTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8208067\n+ * @summary Verify that instance methods are callable from ctor after all instance fields are DA.\n+ * @compile -XDemitQDesc CanonicalCtorTest.java\n+ * @run main\/othervm -ea -XX:+EnableValhalla -XX:+EnablePrimitiveClasses CanonicalCtorTest\n+ *\/\n+\n+public value class CanonicalCtorTest {\n+\n+    private final int x, ymx;\n+\n+    public implicit CanonicalCtorTest();\n+\n+    CanonicalCtorTest(int x, int y) {\n+\n+        ymx = y - x;\n+        this.x = x;\n+\n+        \/\/ ALL fields are assigned now.\n+\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        CanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n+\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n+\n+    int x() {\n+        return x;\n+    }\n+\n+    int y() {\n+        return ymx + x;\n+    }\n+\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n+\n+    public static void main(String... av) {\n+        CanonicalCtorTest! z = new CanonicalCtorTest(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CanonicalCtorTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNoNullCheckTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -39,2 +38,7 @@\n-    final primitive class XX {\n-        final int x = 10;\n+    static final value class XX {\n+        final int x;\n+\n+        public implicit XX();\n+        XX(boolean dummy) {\n+            x = 10;\n+        }\n@@ -48,1 +52,1 @@\n-            XX x = (XX) o;\n+            XX! x = (XX!) o;\n@@ -54,1 +58,1 @@\n-            Point p = (Point) o;\n+            Point! p = (Point!) o;\n@@ -61,1 +65,1 @@\n-            Point p = (Point) o;\n+            Point! p = (Point!) o;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNullCheckTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -35,1 +34,1 @@\n-    static primitive class Point {\n+    static value class Point {\n@@ -38,1 +37,2 @@\n-        Point() {\n+        public implicit Point();\n+        Point(boolean foo) {\n@@ -43,1 +43,1 @@\n-    static primitive class LongPoint {\n+    static value class LongPoint {\n@@ -46,1 +46,2 @@\n-        LongPoint() {\n+        public implicit LongPoint();\n+        LongPoint(boolean foo) {\n@@ -51,1 +52,1 @@\n-        Point p = new Point();\n+        Point! p = new Point(false);\n@@ -55,1 +56,1 @@\n-        LongPoint lp = new LongPoint();\n+        LongPoint! lp = new LongPoint(false);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ChainedAssignmentTest.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8237067\n+ * @summary [lworld] Check good and bad selectors on a type name\n+ * @compile\/fail\/ref=CheckBadSelector.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckBadSelector.java\n+ *\/\n+\n+value final class Point {\n+    public implicit Point();\n+    void badSelector() {\n+        Class<?> c = int.class;\n+        int i = int.default;\n+        int x = int.whatever;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckBadSelector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckBadSelector.java:13:21: compiler.err.expected2: class, default\n+1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckBadSelector.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -3,1 +3,0 @@\n- * @ignore\n@@ -8,1 +7,1 @@\n-final primitive class CheckCyclicMembership {\n+final value class CheckCyclicMembership {\n@@ -12,2 +11,20 @@\n-    primitive final class InnerValue {\n-        final CheckCyclicMembership ccm = CheckCyclicMembership.default; \/\/ Error.\n+    static value final class InnerValue {\n+        final CheckCyclicMembership! ccm;\n+        public implicit InnerValue();\n+        InnerValue(boolean dummy) {\n+            ccm = CheckCyclicMembership.default;  \/\/ Error.\n+        }\n+    }\n+    final CheckCyclicMembership! ccm;\n+    final int i;\n+    final String s;\n+    final InnerRef ir;\n+    final InnerValue! iv;\n+\n+    public implicit CheckCyclicMembership();\n+    CheckCyclicMembership(boolean foo) {\n+        ccm = CheckCyclicMembership.default; \/\/ Error.\n+        i = 10;\n+        s = \"blah\";\n+        ir = new InnerRef(); \/\/ OK.\n+        iv = InnerValue.default; \/\/ Error\n@@ -15,5 +32,0 @@\n-    final CheckCyclicMembership ccm = CheckCyclicMembership.default; \/\/ Error.\n-    final int i = 10;\n-    final String s = \"blah\";\n-    final InnerRef ir = new InnerRef(); \/\/ OK.\n-    final InnerValue iv = InnerValue.default; \/\/ Error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-CheckCyclicMembership.java:12:37: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership.InnerValue\n-CheckCyclicMembership.java:14:33: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n-CheckCyclicMembership.java:18:22: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n+CheckCyclicMembership.java:12:38: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership.InnerValue\n+CheckCyclicMembership.java:18:34: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n+CheckCyclicMembership.java:22:23: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8237067\n+ * @summary Check that feature gated constructs are not allowed in previous versions.\n+ * @compile\/fail\/ref=CheckFeatureGate1.out --release=13 -XDrawDiagnostics CheckFeatureGate1.java\n+ *\/\n+\n+public class CheckFeatureGate1 {\n+\n+    static value class Val {\n+        public int v = 42;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFeatureGate1.java:10:12: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.value.classes), 13, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -38,3 +37,1 @@\n-public primitive class CheckFieldDescriptors {\n-\n-    int x = 10;\n+public value class CheckFieldDescriptors {\n@@ -42,0 +39,1 @@\n+    public implicit CheckFieldDescriptors();\n@@ -87,3 +85,3 @@\n-    CheckFieldDescriptors f1;\n-    CheckFieldDescriptors.ref f2;\n-    CheckFieldDescriptors.ref f3;\n+    CheckFieldDescriptors! f1;\n+    CheckFieldDescriptors f2;\n+    CheckFieldDescriptors f3;\n@@ -91,4 +89,4 @@\n-    CheckFieldDescriptors.ref[] a1 = new CheckFieldDescriptors.ref[42];\n-    CheckFieldDescriptors.ref[] a2 = new CheckFieldDescriptors.ref[42];\n-    CheckFieldDescriptors[] a3 = new CheckFieldDescriptors[42];\n-    CheckFieldDescriptors[] a4 = new CheckFieldDescriptors[42];\n+    CheckFieldDescriptors[] a1 = new CheckFieldDescriptors[42];\n+    CheckFieldDescriptors[] a2 = new CheckFieldDescriptors[42];\n+    CheckFieldDescriptors![] a3 = new CheckFieldDescriptors![42];\n+    CheckFieldDescriptors![] a4 = new CheckFieldDescriptors![42];\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFieldDescriptors.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -8,1 +8,1 @@\n-primitive class CheckFinal { \/\/ implicitly final\n+value class CheckFinal { \/\/ implicitly final\n@@ -11,0 +11,1 @@\n+    public implicit CheckFinal();\n@@ -19,1 +20,1 @@\n-        CheckFinal cf = new CheckFinal() {}; \/\/ Error, final class cannot be extended.\n+        CheckFinal! cf = new CheckFinal!() {}; \/\/ Error, final class cannot be extended.\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,6 +1,7 @@\n-CheckFinal.java:14:13: compiler.err.cant.assign.val.to.var: final, fi\n-CheckFinal.java:15:13: compiler.err.cant.assign.val.to.var: final, fe\n-CheckFinal.java:17:13: compiler.err.cant.assign.val.to.var: static final, xsf\n-CheckFinal.java:19:29: compiler.err.cant.inherit.from.final: CheckFinal\n-CheckFinal.java:19:42: compiler.err.identity.type.has.value.super.type: compiler.misc.anonymous.class: CheckFinal, CheckFinal\n-5 errors\n+CheckFinal.java:8:7: compiler.err.value.class.with.implicit.instance.field.initializer: CheckFinal\n+CheckFinal.java:15:13: compiler.err.cant.assign.val.to.var: final, fi\n+CheckFinal.java:16:13: compiler.err.cant.assign.val.to.var: final, fe\n+CheckFinal.java:18:13: compiler.err.cant.assign.val.to.var: static final, xsf\n+CheckFinal.java:20:30: compiler.err.cant.inherit.from.final: CheckFinal\n+CheckFinal.java:20:44: compiler.err.identity.type.has.value.super.type: compiler.misc.anonymous.class: CheckFinal, CheckFinal\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.out","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlags.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -8,1 +8,1 @@\n-final primitive class CheckFlattenableCycles {\n+final value class CheckFlattenableCycles {\n@@ -12,2 +12,3 @@\n-    primitive final class InnerValue {\n-        final CheckFlattenableCycles     cfc = CheckFlattenableCycles.default; \/\/ Error.\n+    static final value class InnerValue {\n+        final CheckFlattenableCycles! cfc; \/\/ Error.\n+        public implicit InnerValue();\n@@ -15,5 +16,4 @@\n-    final CheckFlattenableCycles cfc = CheckFlattenableCycles.default; \/\/ Error.\n-    final int i = 10;\n-    final String s = \"blah\";\n-    final InnerRef ir = new InnerRef(); \/\/ OK.\n-    final InnerValue     iv = InnerValue.default; \/\/ Error\n+    final CheckFlattenableCycles! cfc; \/\/ Error.\n+    final InnerValue! iv; \/\/ Error\n+\n+    public implicit CheckFlattenableCycles();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-CheckFlattenableCycles.java:13:42: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles.InnerValue\n-CheckFlattenableCycles.java:15:34: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n-CheckFlattenableCycles.java:19:26: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n+CheckFlattenableCycles.java:13:39: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles.InnerValue\n+CheckFlattenableCycles.java:16:35: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n+CheckFlattenableCycles.java:17:23: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n@@ -11,1 +10,1 @@\n-    void foo(FlattenableFlagFromClass f) {\n+    void foo(FlattenableFlagFromClass! f) {\n@@ -13,1 +12,1 @@\n-        f.va[0] = null; \/\/ Error.\n+        f.va = null; \/\/f.va[0] = null; \/\/ Error.  we currently can't represent that elements inside an array are non-nullable\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-CheckFlattenableFlagFromClass.java:12:19: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableFlagFromClass.V)\n+CheckFlattenableFlagFromClass.java:12:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableFlagFromClass.V[])\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -40,1 +39,1 @@\n-        primitive  class Inner {\n+        static value class Inner {\n@@ -42,0 +41,1 @@\n+            public implicit Inner();\n@@ -47,3 +47,4 @@\n-    public primitive class ValueOuter {\n-        int x = 10;\n-        primitive  class Inner {\n+    static public value class ValueOuter {\n+        int x; \/\/10\n+        public implicit ValueOuter();\n+        static value class Inner {\n@@ -51,0 +52,1 @@\n+            public implicit Inner();\n@@ -73,1 +75,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableSyntheticFields.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -32,2 +31,3 @@\n-final primitive class CheckIdentityHash {\n-    int identityHashCode(CheckIdentityHash x) {\n+final value class CheckIdentityHash {\n+    public implicit CheckIdentityHash();\n+    int identityHashCode(CheckIdentityHash! x) {\n@@ -36,1 +36,1 @@\n-    void test(CheckIdentityHash v) {\n+    void test(CheckIdentityHash! v) {\n@@ -43,1 +43,1 @@\n-    int x = 10;\n+    int x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,3 +32,3 @@\n-public final primitive class CheckIdentityHash01 {\n-    void test(CheckIdentityHash01 v) {\n-\n+public final value class CheckIdentityHash01 {\n+    public implicit CheckIdentityHash01();\n+    void test(CheckIdentityHash01! v) {\n@@ -49,1 +48,0 @@\n-    int x = 10;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash01.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -42,1 +41,1 @@\n-            primitive  class Inner {\n+            value class Inner {\n@@ -51,2 +50,2 @@\n-    public primitive class ValueOuter {\n-        int x = 10;\n+    static public value class ValueOuter {\n+        public implicit ValueOuter();\n@@ -54,2 +53,2 @@\n-            ValueOuter o = new ValueOuter();\n-            primitive class Inner {\n+            ValueOuter! o = new ValueOuter();\n+            value class Inner {\n@@ -68,2 +67,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n+        \/*if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n+            throw new Exception(\"Value flag not set\");*\/\n@@ -76,2 +75,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n+        \/*if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n+            throw new Exception(\"Value flag not set\");*\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckLocalClasses.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -7,4 +7,3 @@\n-primitive final class Point {\n-\n-    primitive interface I { int x = 10; } \/\/ Error\n-    primitive abstract class A { int x = 10; } \/\/ Error\n+value final class Point {\n+    value interface I { int x = 10; } \/\/ Error\n+    value abstract class A { int x = 10; } \/\/ Error\n@@ -17,1 +16,2 @@\n-    primitive static final class SinnerValue {\n+    value static final class SinnerValue {\n+        public implicit SinnerValue();\n@@ -20,1 +20,1 @@\n-        } int x = 10;\n+        }\n@@ -26,10 +26,10 @@\n-    final int nonbool = boolean.default;\n-    final boolean nonbyte = byte.default;\n-    final boolean nonchar = char.default;\n-    final boolean nonint = int.default;\n-    final boolean nonshort = short.default;\n-    final boolean nonlong = long.default;\n-    final boolean nonfloat = float.default;\n-    final boolean nondouble = double.default;\n-    final int nonString = String.default;\n-    final int nonbyteArray = byte[].default;\n+    final int nonbool;\n+    final boolean nonbyte;\n+    final boolean nonchar;\n+    final boolean nonint;\n+    final boolean nonshort;\n+    final boolean nonlong;\n+    final boolean nonfloat;\n+    final boolean nondouble;\n+    final int nonString;\n+    final int nonbyteArray;\n@@ -37,2 +37,13 @@\n-    Point() {}\n-    Point (int x, int y) {}\n+    public implicit Point();\n+    Point (int x, int y) {\n+        final int nonbool = boolean.default;\n+        final boolean nonbyte = byte.default;\n+        final boolean nonchar = char.default;\n+        final boolean nonint = int.default;\n+        final boolean nonshort = short.default;\n+        final boolean nonlong = long.default;\n+        final boolean nonfloat = float.default;\n+        final boolean nondouble = double.default;\n+        final int nonString = String.default;\n+        final int nonbyteArray = byte[].default;\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.java","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,13 +1,12 @@\n-CheckMakeDefault.java:9:15: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckMakeDefault.java:10:24: compiler.err.illegal.combination.of.modifiers: abstract, primitive\n-CheckMakeDefault.java:26:32: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n-CheckMakeDefault.java:27:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte, boolean)\n-CheckMakeDefault.java:28:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: char, boolean)\n-CheckMakeDefault.java:29:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, boolean)\n-CheckMakeDefault.java:30:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: short, boolean)\n-CheckMakeDefault.java:31:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, boolean)\n-CheckMakeDefault.java:32:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, boolean)\n-CheckMakeDefault.java:33:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, boolean)\n-CheckMakeDefault.java:34:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-CheckMakeDefault.java:35:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte[], int)\n-12 errors\n+CheckMakeDefault.java:9:20: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.abstract.value.class: Point.A)\n+CheckMakeDefault.java:39:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n+CheckMakeDefault.java:40:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte, boolean)\n+CheckMakeDefault.java:41:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: char, boolean)\n+CheckMakeDefault.java:42:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, boolean)\n+CheckMakeDefault.java:43:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: short, boolean)\n+CheckMakeDefault.java:44:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, boolean)\n+CheckMakeDefault.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, boolean)\n+CheckMakeDefault.java:46:41: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, boolean)\n+CheckMakeDefault.java:47:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+CheckMakeDefault.java:48:40: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte[], int)\n+11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.out","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n@@ -9,2 +8,2 @@\n-    primitive final class V {\n-        final int x = 10;\n+    static value final class V {\n+        public implicit V();\n@@ -12,2 +11,3 @@\n-            V [][][] va = new V[][][] {{{ null }}};\n-            V [][] va2 =  {{ null }};\n+            V! []![]![]! va = new V![][][] {{{ null }}};\n+            V! []![]![]! vb = new V[][][] {{{ null }}};  \/\/ OK?\n+            V! []![]! va2 =  {{ null }};\n@@ -15,1 +15,1 @@\n-                va = new V[][][] {{{ null }}};\n+                va = new V![][][] {{{ null }}};\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-CheckMultiDimensionalArrayStore.java:11:43: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:12:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:14:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:15:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:11:48: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:13:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:15:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:16:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -8,2 +8,2 @@\n-final primitive class CheckNullAssign {\n-    CheckNullAssign foo(CheckNullAssign cna) {\n+final value class CheckNullAssign {\n+    CheckNullAssign! foo(CheckNullAssign! cna) {\n@@ -13,1 +13,1 @@\n-        if (null instanceof CheckNullAssign) {}\n+        if (null instanceof CheckNullAssign!) {}\n@@ -16,1 +16,1 @@\n-    int x = 10;\n+    public implicit CheckNullAssign();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullAssign.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -8,3 +8,3 @@\n-primitive final class CheckNullCastable {\n-    void foo(CheckNullCastable cnc) {\n-        CheckNullCastable cncl = (CheckNullCastable) null;\n+value final class CheckNullCastable {\n+    void foo(CheckNullCastable! cnc) {\n+        CheckNullCastable! cncl = (CheckNullCastable!) null;\n@@ -14,1 +14,1 @@\n-    int x = 10;\n+    public implicit CheckNullCastable();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckNullCastable.java:10:54: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullCastable)\n+CheckNullCastable.java:10:56: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullCastable)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -34,2 +33,2 @@\n-primitive class CheckNullWithQuestion {\n-    final int x = 0;\n+value class CheckNullWithQuestion {\n+    public implicit CheckNullWithQuestion();\n@@ -37,1 +36,1 @@\n-        CheckNullWithQuestion.ref vBox = null;\n+        CheckNullWithQuestion vBox = null;\n@@ -39,1 +38,1 @@\n-        CheckNullWithQuestion.ref val = flag ? vBox : null;\n+        CheckNullWithQuestion val = flag ? vBox : null;\n@@ -45,1 +44,1 @@\n-        CheckNullWithQuestion.ref vBox = null;\n+        CheckNullWithQuestion vBox = null;\n@@ -47,1 +46,1 @@\n-        CheckNullWithQuestion.ref val = flag ? vBox : null;\n+        CheckNullWithQuestion val = flag ? vBox : null;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullWithQuestion.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @ignore\n+ *\n@@ -11,3 +11,6 @@\n-primitive class X {\n-    List<X.ref> ls = new Object();\n-    X.ref[] xa = new Object[10];  \/\/ no support for Object.ref yet, but they are the same.\n+value class X {\n+    void m() {\n+        List<X> ls = new Object();\n+        X[] xa = new Object[10];  \/\/ no support for Object.ref yet, but they are the same.\n+    }\n+    public implicit X();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-CheckQuestionInMessages.java:12:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X.ref>)\n-CheckQuestionInMessages.java:13:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X.ref[])\n+CheckQuestionInMessages.java:13:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X>)\n+CheckQuestionInMessages.java:14:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X[])\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -35,1 +34,1 @@\n-        if (new CheckSeparateCompile0().new O().new M().new I().foo().i != 890)\n+        if (new CheckSeparateCompile0.O.M.I(false).foo().i != 890)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,4 +34,5 @@\n-            public primitive class I {\n-                int i = 890;\n-                I() {\n-\n+            static public value class I {\n+                int i;\n+                public implicit I();\n+                public I(boolean dummy) {\n+                    this.i = 890;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile0.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n@@ -8,1 +7,1 @@\n-primitive final class CheckStaticFinalAssign {\n+value final class CheckStaticFinalAssign {\n@@ -19,1 +18,1 @@\n-    int ix = 10;\n+    public implicit CheckStaticFinalAssign();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckStaticFinalAssign.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @ignore\n+ *\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSuperCompileOnly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -8,1 +8,1 @@\n-primitive final class CheckSynchronized implements java.io.Serializable {\n+value final class CheckSynchronized implements java.io.Serializable {\n@@ -18,1 +18,1 @@\n-        CheckSynchronized.ref csr = cs;\n+        CheckSynchronized csr = cs;\n@@ -38,1 +38,1 @@\n-    primitive record CheckSynchronizedRecord(int x, int y) {\n+    value record CheckSynchronizedRecord(int x, int y) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized.ref, (compiler.misc.type.req.identity)\n+CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n@@ -9,1 +8,1 @@\n-primitive class V {\n+value class V {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,14 +1,14 @@\n-CheckThisLeak.java:17:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:18:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:19:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:21:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:22:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:24:23: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:25:22: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:33:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:34:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:35:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:37:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:38:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:40:21: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:41:22: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:17:17: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:18:9: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:19:10: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:21:28: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:22:29: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:24:15: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:25:14: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:33:17: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:34:9: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:35:10: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:37:28: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:38:29: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:40:13: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:41:14: compiler.err.this.exposed.prematurely\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.out","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ *\n@@ -15,2 +15,2 @@\n-   primitive int x;\n-   primitive int foo() {\n+   value int x;\n+   value int foo() {\n@@ -18,4 +18,4 @@\n-   primitive interface IFace {}\n-   primitive @interface Annot {}\n-   primitive enum Enum {}\n-   primitive abstract class Inner {}\n+   value interface IFace {}\n+   value @interface Annot {}\n+   value enum Enum {}\n+   value abstract class Inner {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,7 +1,6 @@\n-CheckValueModifier.java:18:14: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckValueModifier.java:19:15: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckValueModifier.java:20:14: compiler.err.mod.not.allowed.here: primitive\n-CheckValueModifier.java:21:23: compiler.err.illegal.combination.of.modifiers: abstract, primitive\n-CheckValueModifier.java:15:18: compiler.err.mod.not.allowed.here: primitive\n-CheckValueModifier.java:16:18: compiler.err.mod.not.allowed.here: primitive\n-6 errors\n+CheckValueModifier.java:19:11: compiler.err.illegal.combination.of.modifiers: value, annotation\n+CheckValueModifier.java:20:10: compiler.err.mod.not.allowed.here: value\n+CheckValueModifier.java:15:14: compiler.err.mod.not.allowed.here: value\n+CheckValueModifier.java:16:14: compiler.err.mod.not.allowed.here: value\n+CheckValueModifier.java:21:19: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.abstract.value.class: CheckValueModifier.Inner)\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.out","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n@@ -6,1 +5,1 @@\n- * @compile\/fail\/ref=ClassLiteralNegativeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ClassLiteralNegativeTest.java\n+ * @compile -XDenablePrimitiveClasses ClassLiteralNegativeTest.java\n@@ -9,4 +8,4 @@\n-final primitive class ClassLiteralNegativeTest {\n-    Class<ClassLiteralNegativeTest> c1 = null; \/\/ error\n-    Class<? extends ClassLiteralNegativeTest> c2 = null; \/\/ error\n-    Class<? super ClassLiteralNegativeTest> c3 = null; \/\/ error\n+final value class ClassLiteralNegativeTest {\n+    Class<ClassLiteralNegativeTest> c1 = null; \/\/ OK\n+    Class<? extends ClassLiteralNegativeTest> c2 = null; \/\/ OK\n+    Class<? super ClassLiteralNegativeTest> c3 = null; \/\/ OK\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-ClassLiteralNegativeTest.java:9:11: compiler.err.type.found.req: ClassLiteralNegativeTest, (compiler.misc.type.req.ref)\n-ClassLiteralNegativeTest.java:10:11: compiler.err.type.found.req: ClassLiteralNegativeTest, (compiler.misc.type.req.ref)\n-ClassLiteralNegativeTest.java:11:11: compiler.err.type.found.req: ClassLiteralNegativeTest, (compiler.misc.type.req.ref)\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -48,2 +47,2 @@\n-    static primitive class V implements I {\n-        int x = 42;\n+    static value class V implements I {\n+        public implicit V();\n@@ -53,2 +52,2 @@\n-        if (size(V.class) != 0 || size(new V().getClass()) != 0 ||\n-             foo(V.class) != 1 ||  foo(new V().getClass()) != 1)\n+        if (size(V.class) != 0 || size(new V!().getClass()) != 0 ||\n+             foo(V.class) != 1 ||  foo(new V!().getClass()) != 1)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -37,1 +36,1 @@\n-    static primitive class Point {\n+    static value class Point {\n@@ -41,0 +40,1 @@\n+        public implicit Point();\n@@ -48,1 +48,1 @@\n-    static void testCastingFromBoxToVal(Point.ref p) {\n+    static void testCastingFromBoxToVal(Point p) {\n@@ -51,1 +51,1 @@\n-            Point pv = (Point) p;\n+            Point! pv = (Point!) p;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilerNoBogusAssert.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -36,1 +35,1 @@\n-    static Point.ref nfspQm;\n+    static Point nfspQm;\n@@ -42,1 +41,1 @@\n-primitive final class Point {\n+value final class Point {\n@@ -46,4 +45,1 @@\n-    Point() {\n-        x = 0;\n-        y = 0;\n-    }\n+    public implicit Point();\n@@ -54,2 +50,4 @@\n-    static final primitive class Value {\n-        final PointBug2.ref nfpQm;\n+    static final value class Value {\n+        final PointBug2 nfpQm;\n+\n+        public implicit Value();\n@@ -57,1 +55,1 @@\n-        private Value() {\n+        private Value(boolean dummy){\n@@ -62,1 +60,1 @@\n-primitive final class PointBug2 {\n+value final class PointBug2 {\n@@ -66,0 +64,2 @@\n+    public implicit PointBug2();\n+\n@@ -71,1 +71,1 @@\n-    public static PointBug2 createPoint(int x, int y) {\n+    public static PointBug2! createPoint(int x, int y) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilesJustFine.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -37,1 +36,3 @@\n-    static primitive class V {}\n+    static value class V {\n+        public implicit V();\n+    }\n@@ -44,1 +45,1 @@\n-        var r2 = args.length == 0 ? (V.ref) new V() : (V.ref) new V();\n+        var r2 = args.length == 0 ? (V) new V!() : (V) new V!();\n@@ -49,1 +50,1 @@\n-            var r3 = args.length != 0 ? new V() : (V.ref) null;\n+            var r3 = args.length != 0 ? new V!() : (V) null;\n@@ -55,1 +56,1 @@\n-            var r4 = args.length == 0 ? (V.ref) null : new V();\n+            var r4 = args.length == 0 ? (V) null : new V!();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalInlineTypeTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -40,1 +39,1 @@\n-    static final primitive class X {\n+    static final value class X {\n@@ -42,1 +41,5 @@\n-        final int ifif = 9999;\n+        final int ifif;\n+        public implicit X();\n+        X(boolean dummy) {\n+            ifif = 9999;\n+        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConstantPropagationTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @ignore\n- * @summary Enhance javac to consume unified primitive class files\n+ * @summary Enhance javac to consume unified primitive class files, also see that we lose nullability information with separate compilation\n+ * @compile\/fail\/ref=ConsumeUnifiedClass.out -XDrawDiagnostics -XDenablePrimitiveClasses Point.java Rectangle.java ConsumeUnifiedClass.java\n@@ -32,1 +32,1 @@\n- * @compile\/fail\/ref=ConsumeUnifiedClass.out -XDrawDiagnostics -XDenablePrimitiveClasses ConsumeUnifiedClass.java\n+ * @compile\/fail\/ref=ConsumeUnifiedClass2.out -XDrawDiagnostics -XDenablePrimitiveClasses ConsumeUnifiedClass.java\n@@ -35,1 +35,2 @@\n-public primitive class ConsumeUnifiedClass {\n+public value class ConsumeUnifiedClass {\n+    public implicit ConsumeUnifiedClass();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-ConsumeUnifiedClass.java:36:23: compiler.err.cant.apply.symbol: kindname.constructor, Rectangle, Point,Point, compiler.misc.type.null,compiler.misc.type.null, kindname.class, Rectangle, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point))\n-ConsumeUnifiedClass.java:38:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n+ConsumeUnifiedClass.java:38:23: compiler.err.cant.apply.symbols: kindname.constructor, Rectangle, compiler.misc.type.null,compiler.misc.type.null,{(compiler.misc.inapplicable.method: kindname.constructor, Rectangle, Rectangle(), (compiler.misc.arg.length.mismatch)),(compiler.misc.inapplicable.method: kindname.constructor, Rectangle, Rectangle(Point,Point), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)))}\n+ConsumeUnifiedClass.java:40:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+ConsumeUnifiedClass.java:40:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public primitive class CtorChain {\n+public value class CtorChain {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CtorChain.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -35,2 +34,4 @@\n-    static primitive class Val {\n-        public int v = 42;\n+    static value class Val {\n+        public int v;\n+        public implicit Val();\n+        Val(int v) { this.v = v; }\n@@ -49,1 +50,1 @@\n-        while ((new Val()).v != 42)\n+        while ((new Val(42)).v != 42)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultNonInlines.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8268671\n- * @ignore\n- * @summary Wrong code generated for PrimitiveClass.ref.default\n- * @compile -XDenablePrimitiveClasses DefaultOfPrimitiveReference.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses DefaultOfPrimitiveReference\n- *\/\n-\n-public primitive class DefaultOfPrimitiveReference {\n-    public static void main(String [] args) {\n-        Object o = DefaultOfPrimitiveReference.ref.default;\n-        if (o != null)\n-            throw new AssertionError(\"Expected NPE is missing\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultOfPrimitiveReference.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8210122\n- * @ignore\n- * @summary [lworld] javac issues bogus \"no comment\" doclint warning while compiling primitive class\n- * @compile -Xdoclint:all -Werror -XDenablePrimitiveClasses DocLintSyntheticsTest.java\n- *\/\n-\n-\/**\n- * NOTE: This test is not relevant as we don't inject synthetic methods into primitive\n- *       classes anymore, but is still left in just the same.\n- *\/\n-public primitive class DocLintSyntheticsTest {\n-  \/** field *\/\n-  private final int value;\n-  \/**\n-   * Constructor\n-   *\/\n-  public DocLintSyntheticsTest() { this.value = 0; }\n-\n-  \/**\n-   * test method\n-   *\/\n-  public static void test() {\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DocLintSyntheticsTest.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n@@ -9,1 +8,1 @@\n-public primitive class DualNonDuplicateErrors {\n+public value class DualNonDuplicateErrors {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualNonDuplicateErrors.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public final primitive class EmptyValueTest {\n+public final value class EmptyValueTest {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EmptyValueTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -49,1 +48,1 @@\n-    static primitive class PrimitiveIterator<V> implements Iterator<V> {\n+    static value class PrimitiveIterator<V> implements Iterator<V> {\n@@ -69,1 +68,1 @@\n-    primitive static class Foo<V> implements Iterable<V> {\n+    value static class Foo<V> implements Iterable<V> {\n@@ -81,1 +80,1 @@\n-       public PrimitiveIterator<V> iterator() {\n+        public PrimitiveIterator<V> iterator() {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EnhancedForLoopTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -38,1 +37,1 @@\n-primitive class OptionalInt {\n+value class OptionalInt {\n@@ -81,1 +80,1 @@\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n+       List<OptionalInt> opts = new ArrayList<>();\n@@ -89,1 +88,1 @@\n-           .map((OptionalInt.ref o) -> {\n+           .map((OptionalInt o) -> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -39,2 +38,1 @@\n-primitive class OptionalInt {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n+value class OptionalInt {\n@@ -82,1 +80,1 @@\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n+       List<OptionalInt> opts = new ArrayList<>();\n@@ -89,2 +87,2 @@\n-       Stream<OptionalInt.ref> soi = opts.stream();\n-       ToIntFunction<OptionalInt.ref> f = (OptionalInt.ref o) -> {\n+       Stream<OptionalInt> soi = opts.stream();\n+       ToIntFunction<OptionalInt> f = (OptionalInt o) -> {\n@@ -92,1 +90,1 @@\n-            OptionalInt op = (OptionalInt)o;\n+            OptionalInt! op = (OptionalInt!)o;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes2.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -39,3 +38,1 @@\n-primitive class OptionalInt {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n-\n+value class OptionalInt {\n@@ -82,1 +79,1 @@\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n+       List<OptionalInt> opts = new ArrayList<>();\n@@ -89,2 +86,2 @@\n-       Stream<OptionalInt.ref> soi = opts.stream();\n-       ToIntFunction<OptionalInt.ref> f = o -> {\n+       Stream<OptionalInt> soi = opts.stream();\n+       ToIntFunction<OptionalInt> f = o -> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes3.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n-    public primitive final class V {\n-        final int x = 10;\n+    static public value final class V {\n+        final int x;\n+        public implicit V();\n@@ -30,2 +31,2 @@\n-    public V v;\n-    public V[] va;\n+    public V! v;\n+    public V[]! va;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FlattenableFlagFromClass.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -35,1 +34,1 @@\n-   static primitive class Entry<E> {\n+   static value class Entry<E> {\n@@ -37,1 +36,1 @@\n-\n+     public implicit Entry();\n@@ -42,2 +41,2 @@\n-     public static <E> Entry<E>[] of() {\n-       return (Entry<E>[])new Entry<?>[0];\n+     public static <E> Entry!<E>[] of() {\n+       return (Entry!<E>[])new Entry!<?>[0];\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayRegression.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -34,1 +33,1 @@\n- primitive class Foo implements Comparable<Foo.ref>{\n+value class Foo implements Comparable<Foo>{\n@@ -42,1 +41,1 @@\n-    public int compareTo(Foo.ref o) {\n+    public int compareTo(Foo o) {\n@@ -45,1 +44,1 @@\n- }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues1.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -36,1 +35,1 @@\n-  primitive class CaptureBug {\n+value class CaptureBug {\n@@ -43,1 +42,1 @@\n-    private static void accept(Consumer<? super CaptureBug.ref> consumer) {\n+    private static void accept(Consumer<? super CaptureBug> consumer) {\n@@ -50,2 +49,1 @@\n-  }\n-\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues2.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @ignore\n@@ -36,1 +35,1 @@\n-primitive class StreamBug {\n+value class StreamBug {\n@@ -44,2 +43,0 @@\n-    \/\/var bug = new StreamBug?(7);\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues3.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -34,1 +33,1 @@\n-primitive class InlineType<E> {\n+value class InlineType<E> {\n@@ -38,1 +37,1 @@\n-        void doesNotCompile(java.util.Map.Entry<InlineType.ref<? extends K>, ? extends V> arg);\n+        void doesNotCompile(java.util.Map.Entry<InlineType<? extends K>, ? extends V> arg);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues4.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -41,1 +40,1 @@\n-primitive class Optional<T> {\n+value class Optional<T> {\n@@ -91,1 +90,1 @@\n-       List<Optional.ref<Integer>> opts = new ArrayList<>();\n+       List<Optional<Integer>> opts = new ArrayList<>();\n@@ -94,1 +93,1 @@\n-           opts.add((Optional.ref<Integer>)oi);\n+           opts.add((Optional<Integer>)oi);\n@@ -96,1 +95,1 @@\n-           opts.add((Optional.ref<Integer>)oe);\n+           opts.add((Optional<Integer>)oe);\n@@ -100,1 +99,1 @@\n-           .map((Optional.ref<Integer> o) -> {\n+           .map((Optional<Integer> o) -> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues5.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -37,1 +36,1 @@\n-    static primitive class Primitive {}\n+    static value class Primitive {}\n@@ -39,1 +38,1 @@\n-    static void foo(Class<? extends Primitive.ref> c) {}\n+    static void foo(Class<? extends Primitive> c) {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GetClassTypingTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @test\n@@ -27,1 +28,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ImplicitIdentityTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -32,1 +31,0 @@\n- *\n@@ -40,3 +38,2 @@\n-public primitive class InferredValueParameterizationTest {\n-    int x = 10;\n-\n+public value class InferredValueParameterizationTest {\n+    public implicit InferredValueParameterizationTest();\n@@ -52,4 +49,4 @@\n-       var list = List.of(new InferredValueParameterizationTest());\n-       Object o = new Y<>(new InferredValueParameterizationTest());\n-       o = new Y<>(new InferredValueParameterizationTest()) {};\n-       foo(new InferredValueParameterizationTest());\n+       var list = List.of(new InferredValueParameterizationTest!());\n+       Object o = new Y<>(new InferredValueParameterizationTest!());\n+       o = new Y<>(new InferredValueParameterizationTest!()) {};\n+       foo(new InferredValueParameterizationTest!());\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InferredValueParameterizationTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222745\n- * @ignore\n- * @summary Test inline modifier\n- * @compile -XDenablePrimitiveClasses InlineClassTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses InlineClassTest\n- *\/\n-\n-public primitive class InlineClassTest {\n-    int x = 42;\n-    public static void main(String [] args) {\n-        if (new InlineClassTest().x != 42)\n-            throw new AssertionError(\"Unexpected state\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineClassTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -36,1 +35,0 @@\n-\n@@ -44,2 +42,3 @@\n-    private primitive class Y<U> implements I<U> {\n-        int x = 42;\n+    private static value class Y<U> implements I<U> {\n+        int x;\n+        public implicit Y();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineDiamondTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -38,1 +37,1 @@\n-    static primitive class Inner {\n+    static value class Inner {\n@@ -40,1 +39,1 @@\n-        private Inner() { f=0; }\n+        public implicit Inner();\n@@ -48,2 +47,2 @@\n-        public static final Inner.ref ZERO = Inner.create(0);\n-        public static final Inner.ref ZERO2 = Inner.create(0);\n+        public static final Inner ZERO = Inner.create(0);\n+        public static final Inner ZERO2 = Inner.create(0);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerClassAttributeValuenessTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -35,1 +34,1 @@\n-    final primitive class Y {\n+    final value class Y {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerValueNew.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -35,1 +34,1 @@\n-public primitive class InstanceofProjectionArray {\n+public value class InstanceofProjectionArray {\n@@ -41,2 +40,2 @@\n-        InstanceofProjectionArray.ref[] foos = new InstanceofProjectionArray.ref[1];\n-        if (!(foos instanceof InstanceofProjectionArray.ref[])) {\n+        InstanceofProjectionArray[] foos = new InstanceofProjectionArray[1];\n+        if (!(foos instanceof InstanceofProjectionArray[])) {\n@@ -45,2 +44,2 @@\n-        InstanceofProjectionArray.ref[][] xx = null;\n-        if (xx instanceof InstanceofProjectionArray.ref[][]) {}\n+        InstanceofProjectionArray[][] xx = null;\n+        if (xx instanceof InstanceofProjectionArray[][]) {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InstanceofProjectionArray.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public primitive class IntercastTest {\n+public value class IntercastTest {\n@@ -37,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -47,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -60,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -68,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -77,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -89,1 +88,1 @@\n-        IntercastTest.ref xbox = (IntercastTest.ref) x;\n+        IntercastTest xbox = (IntercastTest) x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public primitive class IntercastTest2 {\n+public value class IntercastTest2 {\n@@ -37,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -47,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -60,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -68,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -77,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -89,1 +88,1 @@\n-        IntercastTest2.ref xbox = (IntercastTest2.ref) x;\n+        IntercastTest2 xbox = (IntercastTest2) x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest2.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -38,1 +37,1 @@\n-        final primitive class Y {\n+        final value class Y {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LocalValueNew.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public primitive class LookupOnLoxTest {\n+public value class LookupOnLoxTest {\n@@ -37,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -47,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -60,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -68,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -77,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -89,1 +88,1 @@\n-        LookupOnLoxTest.ref xbox = x;\n+        LookupOnLoxTest xbox = x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public primitive class LookupOnLoxTest2 {\n+public value class LookupOnLoxTest2 {\n@@ -37,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -47,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -60,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -68,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -77,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -89,1 +88,1 @@\n-        LookupOnLoxTest2.ref xbox = x;\n+        LookupOnLoxTest2 xbox = x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest2.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n@@ -43,1 +42,1 @@\n-    static primitive class XNodeWrapper implements I {\n+    static value class XNodeWrapper implements I {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LubWithInlines.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,2 +24,3 @@\n-primitive public final class MyValue {\n-  final int f = 0;\n+value public final class MyValue {\n+  final int f;\n+  public implicit MyValue();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/MyValue.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -40,1 +39,3 @@\n-    static primitive final class V implements I { int x = 0; }\n+    static value final class V implements I {\n+        public implicit V();\n+    }\n@@ -42,1 +43,1 @@\n-    static void triggerNPE(V.ref [] vra) {\n+    static void triggerNPE(V [] vra) {\n@@ -46,1 +47,2 @@\n-    static String foo(V[] va) {\n+    \/*\n+    static String foo(V![] va) {\n@@ -53,0 +55,1 @@\n+    *\/\n@@ -61,1 +64,1 @@\n-        triggerNPE(new V.ref[1]); \/\/ NO NPE.\n+        triggerNPE(new V[1]); \/\/ NO NPE.\n@@ -63,1 +66,1 @@\n-            triggerNPE(new V[1]);\n+            triggerNPE(new V![1]);\n@@ -68,3 +71,3 @@\n-\n-        V [] v = new V[0];\n-        if (!foo((V.ref []) v).equals(\"array of nullable o's\"))\n+\/*\n+        V! [] v = new V![0];  \/\/nullability is not considered during overload resolution\n+        if (!foo((V []) v).equals(\"array of nullable o's\"))\n@@ -72,0 +75,1 @@\n+ *\/\n@@ -73,1 +77,1 @@\n-        ArrayList<V.ref> vList = new ArrayList<V.ref>(Arrays.asList(new V.ref[10]));\n+        ArrayList<V> vList = new ArrayList<V>(Arrays.asList(new V[10]));\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoCrashTest.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -53,2 +52,3 @@\n-    static primitive class Point {\n-        int x = 0, y = 0;\n+    static value class Point {\n+        int x, y;\n+        public implicit Point();\n@@ -56,1 +56,1 @@\n-            Point p0 = new Point();\n+            Point! p0 = new Point();\n@@ -59,1 +59,1 @@\n-            Point.ref p1 = null;\n+            Point p1 = null;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoUnnecessaryCast.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -38,1 +37,1 @@\n-    static primitive class X {\n+    static value class X {\n@@ -42,1 +41,1 @@\n-        static int m(X.ref xr, A a) {\n+        static int m(X xr, A a) {\n@@ -46,1 +45,1 @@\n-        static int m(X.ref xr, B b) {\n+        static int m(X xr, B b) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest2.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,1 +32,1 @@\n-public primitive class ParameterizedDefault<E> {\n+public value class ParameterizedDefault<E> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ParameterizedDefault.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @ignore\n+ *\n@@ -33,3 +33,3 @@\n-primitive class Point {\n-    static final Point.ref origin = makePoint(10, 20);\n-    static final Point.ref origin2 = makePoint(10, 20);\n+value class Point {\n+    static final Point origin = makePoint(10, 20);\n+    static final Point origin2 = makePoint(10, 20);\n@@ -38,0 +38,3 @@\n+\n+    public implicit Point();\n+\n@@ -42,1 +45,1 @@\n-    static Point makePoint(int x, int y) {\n+    static Point! makePoint(int x, int y) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Point.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -39,8 +38,8 @@\n-    public primitive class P1 {}\n-    public primitive class P2 {}\n-    public primitive class P3 {}\n-    public primitive class P4 {}\n-    public primitive class P5 {}\n-    public primitive class P6 {}\n-    public primitive class P7 {}\n-    public primitive class P8 {}\n+    public value class P1 {}\n+    public value class P2 {}\n+    public value class P3 {}\n+    public value class P4 {}\n+    public value class P5 {}\n+    public value class P6 {}\n+    public value class P7 {}\n+    public value class P8 {}\n@@ -49,4 +48,4 @@\n-    P1 p1;\n-    P2 foo(P3 p3) {\n-        P4 p4;\n-        return new P2();\n+    P1! p1;\n+    P2! foo(P3! p3) {\n+        P4! p4;\n+        return new P2!();\n@@ -56,3 +55,3 @@\n-    P5.ref p5;\n-    P6.ref foo(P7.ref p7) {\n-        P8.ref p8;\n+    P5 p5;\n+    P6 foo(P7 p7) {\n+        P8 p8;\n@@ -74,1 +73,1 @@\n-        if (preloads.number_of_classes != 4) {\n+        if (preloads.number_of_classes != 8) {\n@@ -77,1 +76,1 @@\n-\n+        \/*\n@@ -98,0 +97,1 @@\n+        *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PreloadAttributeTest.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n@@ -33,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectedArrayDotClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionRelationsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProperTypeApplySelectTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QPointConsumer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-public primitive class Rectangle {\n+public value class Rectangle {\n@@ -28,1 +28,1 @@\n-    Point topLeft, bottomRight;\n+    Point! topLeft, bottomRight;\n@@ -30,1 +30,1 @@\n-    static Point origin;\n+    static Point! origin;\n@@ -32,1 +32,1 @@\n-    static Rectangle from (Point.ref topLeft, Point.ref bottomRight) {\n+    static Rectangle! from (Point topLeft, Point bottomRight) {\n@@ -36,1 +36,2 @@\n-    Rectangle (Point topLeft, Point bottomRight) {\n+    public implicit Rectangle();\n+    Rectangle (Point! topLeft, Point! bottomRight) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Rectangle.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileGenerics.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest01.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSetTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StaticSelectedThroughProjection.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/T8279655.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestReflectiveMirrors.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeVarSynchronize.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnannotatedProjection.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassBytecodeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassInnerClassesTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnrelatedThisLeak.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAsEnclosingClass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueCreationTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        \"        17: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        22: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}