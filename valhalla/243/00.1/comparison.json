{"files":[{"patch":"@@ -3361,0 +3361,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -1373,0 +1373,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1468,0 +1470,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1660,0 +1674,2 @@\n+  _restricted_field_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1690,0 +1706,1 @@\n+\n@@ -1722,0 +1739,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1731,0 +1750,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1765,0 +1786,9 @@\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1768,1 +1798,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1770,0 +1800,3 @@\n+    _restricted_field_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1772,3 +1805,2 @@\n-    \/\/ Remember how many oops we encountered and compute allocation type\n-    const FieldAllocationType atype = fac->update(is_static, type, type == T_INLINE_TYPE);\n-    field->set_allocation_type(atype);\n+    \/\/ \/\/ Remember how many oops we encountered\n+    fac->update(is_static, type, type == T_INLINE_TYPE);\n@@ -1817,3 +1849,2 @@\n-      \/\/ Remember how many oops we encountered and compute allocation type\n-      const FieldAllocationType atype = fac->update(false, type, false);\n-      field->set_allocation_type(atype);\n+      \/\/ Remember how many oops we encountered\n+      fac->update(false, type, false);\n@@ -1821,0 +1852,1 @@\n+      _restricted_field_info->append(0);\n@@ -1824,0 +1856,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1831,2 +1864,2 @@\n-    const FieldAllocationType atype = fac->update(true, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(true, type, false);\n@@ -1834,0 +1867,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1836,0 +1870,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1844,2 +1881,2 @@\n-    const FieldAllocationType atype = fac->update(false, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(false, type, false);\n@@ -1847,0 +1884,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5917,0 +5955,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_erased_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _restricted_field_info->at(i);\n+    }\n+  }\n+\n@@ -6115,0 +6161,1 @@\n+  _restricted_field_info(NULL),\n@@ -6154,0 +6201,1 @@\n+  _has_restricted_fields(false),\n@@ -6732,0 +6780,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6734,1 +6783,0 @@\n-      \/\/ Pre-load inline class\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":61,"deletions":13,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  GrowableArray<u2>* _restricted_field_info;\n@@ -216,0 +217,1 @@\n+  bool _has_restricted_fields;\n@@ -285,0 +287,2 @@\n+                              u2* restricted_field_info,\n+                              bool* has_restricted_type,\n@@ -630,0 +634,2 @@\n+  void set_has_restricted_fields() { _has_restricted_fields = true; }\n+  bool has_restricted_fields() const { return _has_restricted_fields; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -485,1 +485,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -1662,4 +1663,13 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        Symbol* f_sig2 = fs.secondary_signature();\n+        if (f_name == name && f_sig2 == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2261,1 +2261,3 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_MASK\", FIELDINFO_TAG_MASK) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}