{"files":[{"patch":"@@ -2487,1 +2487,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n@@ -4681,2 +4681,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n-  Label has_identity;\n+  Label is_inline_type;\n@@ -4684,7 +4683,1 @@\n-  __ andptr(rbx, is_inline_type_mask);\n-  __ cmpl(rbx, is_inline_type_mask);\n-  __ jcc(Assembler::notEqual, has_identity);\n-  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n-                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n-  __ should_not_reach_here();\n-  __ bind(has_identity);\n+  __ test_markword_is_inline_type(rbx, is_inline_type);\n@@ -4781,0 +4774,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -4791,1 +4789,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3309,0 +3309,74 @@\n+\/\/ Find index of the InnerClasses entry for the specified inner_class_info_index.\n+\/\/ Return -1 if none is found.\n+static int inner_classes_find_index(const Array<u2>* inner_classes, int inner, const ConstantPool* cp, int length) {\n+  Symbol* cp_klass_name =  cp->klass_name_at(inner);\n+  for (int idx = 0; idx < length; idx += InstanceKlass::inner_class_next_offset) {\n+    int idx_inner = inner_classes->at(idx + InstanceKlass::inner_class_inner_class_info_offset);\n+    if (cp->klass_name_at(idx_inner) == cp_klass_name) {\n+      return idx;\n+    }\n+  }\n+  return -1;\n+}\n+\n+\/\/ Return the outer_class_info_index for the InnerClasses entry containing the\n+\/\/ specified inner_class_info_index.  Return -1 if no InnerClasses entry is found.\n+static int inner_classes_jump_to_outer(const Array<u2>* inner_classes, int inner, const ConstantPool* cp, int length) {\n+  if (inner == 0) return -1;\n+  int idx = inner_classes_find_index(inner_classes, inner, cp, length);\n+  if (idx == -1) return -1;\n+  int result = inner_classes->at(idx + InstanceKlass::inner_class_outer_class_info_offset);\n+  return result;\n+}\n+\n+\/\/ Return true if circularity is found, false if no circularity is found.\n+\/\/ Use Floyd's cycle finding algorithm.\n+static bool inner_classes_check_loop_through_outer(const Array<u2>* inner_classes, int idx, const ConstantPool* cp, int length) {\n+  int slow = inner_classes->at(idx + InstanceKlass::inner_class_inner_class_info_offset);\n+  int fast = inner_classes->at(idx + InstanceKlass::inner_class_outer_class_info_offset);\n+  while (fast != -1 && fast != 0) {\n+    if (slow != 0 && (cp->klass_name_at(slow) == cp->klass_name_at(fast))) {\n+      return true;  \/\/ found a circularity\n+    }\n+    fast = inner_classes_jump_to_outer(inner_classes, fast, cp, length);\n+    if (fast == -1) return false;\n+    fast = inner_classes_jump_to_outer(inner_classes, fast, cp, length);\n+    if (fast == -1) return false;\n+    slow = inner_classes_jump_to_outer(inner_classes, slow, cp, length);\n+    assert(slow != -1, \"sanity check\");\n+  }\n+  return false;\n+}\n+\n+\/\/ Loop through each InnerClasses entry checking for circularities and duplications\n+\/\/ with other entries.  If duplicate entries are found then throw CFE.  Otherwise,\n+\/\/ return true if a circularity or entries with duplicate inner_class_info_indexes\n+\/\/ are found.\n+bool ClassFileParser::check_inner_classes_circularity(const ConstantPool* cp, int length, TRAPS) {\n+  \/\/ Loop through each InnerClasses entry.\n+  for (int idx = 0; idx < length; idx += InstanceKlass::inner_class_next_offset) {\n+    \/\/ Return true if there are circular entries.\n+    if (inner_classes_check_loop_through_outer(_inner_classes, idx, cp, length)) {\n+      return true;\n+    }\n+    \/\/ Check if there are duplicate entries or entries with the same inner_class_info_index.\n+    for (int y = idx + InstanceKlass::inner_class_next_offset; y < length;\n+         y += InstanceKlass::inner_class_next_offset) {\n+\n+      \/\/ To maintain compatibility, throw an exception if duplicate inner classes\n+      \/\/ entries are found.\n+      guarantee_property((_inner_classes->at(idx) != _inner_classes->at(y) ||\n+                          _inner_classes->at(idx+1) != _inner_classes->at(y+1) ||\n+                          _inner_classes->at(idx+2) != _inner_classes->at(y+2) ||\n+                          _inner_classes->at(idx+3) != _inner_classes->at(y+3)),\n+                         \"Duplicate entry in InnerClasses attribute in class file %s\",\n+                         CHECK_(true));\n+      \/\/ Return true if there are two entries with the same inner_class_info_index.\n+      if (_inner_classes->at(y) == _inner_classes->at(idx)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -3311,0 +3385,1 @@\n+                                                            const ConstantPool* cp,\n@@ -3334,1 +3409,1 @@\n-  Array<u2>* const inner_classes = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  Array<u2>* inner_classes = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n@@ -3391,0 +3466,2 @@\n+  \/\/ Also, check for circular entries.\n+  bool has_circularity = false;\n@@ -3392,8 +3469,10 @@\n-    for(int i = 0; i < length * 4; i += 4) {\n-      for(int j = i + 4; j < length * 4; j += 4) {\n-        guarantee_property((inner_classes->at(i)   != inner_classes->at(j) ||\n-                            inner_classes->at(i+1) != inner_classes->at(j+1) ||\n-                            inner_classes->at(i+2) != inner_classes->at(j+2) ||\n-                            inner_classes->at(i+3) != inner_classes->at(j+3)),\n-                            \"Duplicate entry in InnerClasses in class file %s\",\n-                            CHECK_0);\n+    has_circularity = check_inner_classes_circularity(cp, length * 4, CHECK_0);\n+    if (has_circularity) {\n+      \/\/ If circularity check failed then ignore InnerClasses attribute.\n+      MetadataFactory::free_array<u2>(_loader_data, _inner_classes);\n+      index = 0;\n+      if (parsed_enclosingmethod_attribute) {\n+        inner_classes = MetadataFactory::new_array<u2>(_loader_data, 2, CHECK_0);\n+        _inner_classes = inner_classes;\n+      } else {\n+        _inner_classes = Universe::the_empty_short_array();\n@@ -3403,1 +3482,0 @@\n-\n@@ -3409,1 +3487,1 @@\n-  assert(index == size, \"wrong size\");\n+  assert(index == size || has_circularity, \"wrong size\");\n@@ -4101,0 +4179,1 @@\n+                            cp,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":90,"deletions":11,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -346,0 +346,3 @@\n+  \/\/ Check for circularity in InnerClasses attribute.\n+  bool check_inner_classes_circularity(const ConstantPool* cp, int length, TRAPS);\n+\n@@ -347,0 +350,1 @@\n+                                               const ConstantPool* cp,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/classListWriter.hpp\"\n@@ -3163,0 +3164,13 @@\n+\n+static bool is_prohibited_package_slow(Symbol* class_name) {\n+  \/\/ Caller has ResourceMark\n+  int length;\n+  jchar* unicode = class_name->as_unicode(length);\n+  return (length >= 5 &&\n+          unicode[0] == 'j' &&\n+          unicode[1] == 'a' &&\n+          unicode[2] == 'v' &&\n+          unicode[3] == 'a' &&\n+          unicode[4] == '\/');\n+}\n+\n@@ -3169,1 +3183,1 @@\n-      class_name != NULL) {\n+      class_name != NULL && class_name->utf8_length() >= 5) {\n@@ -3171,2 +3185,9 @@\n-    char* name = class_name->as_C_string();\n-    if (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '\/') {\n+    bool prohibited;\n+    const u1* base = class_name->base();\n+    if ((base[0] | base[1] | base[2] | base[3] | base[4]) & 0x80) {\n+      prohibited = is_prohibited_package_slow(class_name);\n+    } else {\n+      char* name = class_name->as_C_string();\n+      prohibited = (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '\/');\n+    }\n+    if (prohibited) {\n@@ -3175,1 +3196,1 @@\n-      name = pkg_name->as_C_string();\n+      char* name = pkg_name->as_C_string();\n@@ -4391,1 +4412,1 @@\n-  if (DumpLoadedClassList && classlist_file->is_open()) {\n+  if (ClassListWriter::is_enabled()) {\n@@ -4404,0 +4425,5 @@\n+      if (is_hidden()) {\n+        \/\/ Don't include archived lambda proxy class in the classlist.\n+        assert(!is_non_strong_hidden(), \"unexpected non-strong hidden class\");\n+        return;\n+      }\n@@ -4431,2 +4457,3 @@\n-      classlist_file->print_cr(\"%s\", name()->as_C_string());\n-      classlist_file->flush();\n+      ClassListWriter w;\n+      w.stream()->print_cr(\"%s\", name()->as_C_string());\n+      w.stream()->flush();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include \"memory\/metaspace\/metablock.hpp\"\n@@ -907,1 +906,1 @@\n-  c2_nonstatic_field(Node,                     _flags,                                        jushort)                               \\\n+  c2_nonstatic_field(Node,                     _flags,                                        juint)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}