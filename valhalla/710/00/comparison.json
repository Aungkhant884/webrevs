{"files":[{"patch":"@@ -3893,22 +3893,0 @@\n-    Node* original_kls = load_object_klass(original);\n-    \/\/ ArrayCopyNode:Ideal may transform the ArrayCopyNode to\n-    \/\/ loads\/stores but it is legal only if we're sure the\n-    \/\/ Arrays.copyOf would succeed. So we need all input arguments\n-    \/\/ to the copyOf to be validated, including that the copy to the\n-    \/\/ new array won't trigger an ArrayStoreException. That subtype\n-    \/\/ check can be optimized if we know something on the type of\n-    \/\/ the input array from type speculation.\n-    if (_gvn.type(klass_node)->singleton() && !stopped()) {\n-      ciKlass* subk   = _gvn.type(original_kls)->is_klassptr()->klass();\n-      ciKlass* superk = _gvn.type(klass_node)->is_klassptr()->klass();\n-\n-      int test = C->static_subtype_check(superk, subk);\n-      if (test != Compile::SSC_always_true && test != Compile::SSC_always_false) {\n-        const TypeOopPtr* t_original = _gvn.type(original)->is_oopptr();\n-        if (t_original->speculative_type() != NULL) {\n-          original = maybe_cast_profiled_obj(original, t_original->speculative_type(), true);\n-          original_kls = load_object_klass(original);\n-        }\n-      }\n-    }\n-\n@@ -3948,1 +3926,1 @@\n-        generate_fair_guard(flat_array_test(original_kls), bailout);\n+        generate_fair_guard(flat_array_test(load_object_klass(original)), bailout);\n@@ -3981,0 +3959,20 @@\n+      \/\/ ArrayCopyNode:Ideal may transform the ArrayCopyNode to\n+      \/\/ loads\/stores but it is legal only if we're sure the\n+      \/\/ Arrays.copyOf would succeed. So we need all input arguments\n+      \/\/ to the copyOf to be validated, including that the copy to the\n+      \/\/ new array won't trigger an ArrayStoreException. That subtype\n+      \/\/ check can be optimized if we know something on the type of\n+      \/\/ the input array from type speculation.\n+      if (_gvn.type(klass_node)->singleton()) {\n+        ciKlass* subk   = _gvn.type(load_object_klass(original))->is_klassptr()->klass();\n+        ciKlass* superk = _gvn.type(klass_node)->is_klassptr()->klass();\n+\n+        int test = C->static_subtype_check(superk, subk);\n+        if (test != Compile::SSC_always_true && test != Compile::SSC_always_false) {\n+          const TypeOopPtr* t_original = _gvn.type(original)->is_oopptr();\n+          if (t_original->speculative_type() != NULL) {\n+            original = maybe_cast_profiled_obj(original, t_original->speculative_type(), true);\n+          }\n+        }\n+      }\n+\n@@ -4001,1 +3999,1 @@\n-                                                original_kls, klass_node);\n+                                                load_object_klass(original), klass_node);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -77,2 +77,0 @@\n-compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java 8283777 generic-all\n-compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java#id1 8283777 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}