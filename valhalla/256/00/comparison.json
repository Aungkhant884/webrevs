{"files":[{"patch":"@@ -1993,1 +1993,0 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -1995,4 +1994,9 @@\n-  __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n-  __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n-  __ testl(klass, Klass::_lh_array_tag_vt_value_bit_inplace);\n-  __ jcc(Assembler::notZero, *op->stub()->entry());\n+  if (UseArrayMarkWordCheck) {\n+    __ test_flattened_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n+    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ testl(klass, Klass::_lh_array_tag_vt_value_bit_inplace);\n+    __ jcc(Assembler::notZero, *op->stub()->entry());\n+  }\n@@ -2005,2 +2009,6 @@\n-    __ testl(klass, Klass::_lh_null_free_bit_inplace);\n-    __ jcc(Assembler::notZero, *op->stub()->entry());\n+    if (UseArrayMarkWordCheck) {\n+      __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+    } else {\n+      __ testl(klass, Klass::_lh_null_free_bit_inplace);\n+      __ jcc(Assembler::notZero, *op->stub()->entry());\n+    }\n@@ -2014,5 +2022,16 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  Register klass = op->tmp()->as_register();\n-  __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n-  __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n-  __ testl(klass, Klass::_lh_null_free_bit_inplace);\n+  if (UseArrayMarkWordCheck) {\n+    Label test_mark_word;\n+    Register tmp = op->tmp()->as_register();\n+    __ movptr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n+    __ testl(tmp, markWord::unlocked_value);\n+    __ jccb(Assembler::notZero, test_mark_word);\n+    __ load_prototype_header(tmp, op->array()->as_register(), rscratch1);\n+    __ bind(test_mark_word);\n+    __ testl(tmp, markWord::nullfree_array_bit_in_place);\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    Register klass = op->tmp()->as_register();\n+    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n+    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ testl(klass, Klass::_lh_null_free_bit_inplace);\n+  }\n@@ -3255,7 +3274,6 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(tmp, obj, tmp_load_klass);\n-  __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));\n-  if (is_dest) {\n-    \/\/ We also take slow path if it's a null_free destination array, just in case the source array\n-    \/\/ contains NULLs.\n-    __ testl(tmp, Klass::_lh_null_free_bit_inplace);\n+  if (UseArrayMarkWordCheck) {\n+    if (is_dest) {\n+      __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n+    } else {\n+      __ test_flattened_array_oop(obj, tmp, *slow_path->entry());\n+    }\n@@ -3263,1 +3281,10 @@\n-    __ testl(tmp, Klass::_lh_array_tag_vt_value_bit_inplace);\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(tmp, obj, tmp_load_klass);\n+    __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));\n+    if (is_dest) {\n+      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains NULLs.\n+      __ testl(tmp, Klass::_lh_null_free_bit_inplace);\n+    } else {\n+      __ testl(tmp, Klass::_lh_array_tag_vt_value_bit_inplace);\n+    }\n+    __ jcc(Assembler::notZero, *slow_path->entry());\n@@ -3265,1 +3292,0 @@\n-  __ jcc(Assembler::notZero, *slow_path->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -852,1 +852,2 @@\n-             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck()) {\n+             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck() ||\n+             cmp1->is_FlatArrayCheck() || cmp2->is_FlatArrayCheck()) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-  bool is_non_flattened_array_check(PhaseTransform* phase, Node** array = NULL);\n+  bool is_flat_array_check(PhaseTransform* phase, Node** array = NULL);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+macro(FlatArrayCheck)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1688,1 +1688,9 @@\n-        if (add_edge(field, null_obj)) {\n+        if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+          \/\/ Non-flattened inline type arrays are initialized with the\n+          \/\/ default value instead of null. Add corresponding edge.\n+          if (add_edge(field, phantom_obj)) {\n+            add_field_uses_to_worklist(field->as_Field());\n+            add_java_object_edges(phantom_obj, false);\n+            visited_bottom_offset = true;\n+          }\n+        } else if (add_edge(field, null_obj)) {\n@@ -1771,1 +1779,8 @@\n-          if (add_edge(field, null_obj)) {\n+          if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+            \/\/ Non-flattened inline type arrays are initialized with the\n+            \/\/ default value instead of null. Add corresponding edge.\n+            if (add_edge(field, phantom_obj)) {\n+              add_field_uses_to_worklist(field->as_Field());\n+              add_java_object_edges(phantom_obj, false);\n+            }\n+          } else if (add_edge(field, null_obj)) {\n@@ -3499,1 +3514,1 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {\n+              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar || op == Op_FlatArrayCheck)) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3520,1 +3520,1 @@\n-          iff->is_non_flattened_array_check(&_gvn, &array);\n+          iff->is_flat_array_check(&_gvn, &array);\n@@ -3551,2 +3551,2 @@\n-  Node* mark_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-  Node* mark = make_load(NULL, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  Node* mark_adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n+  Node* mark = make_load(NULL, mark_adr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n@@ -3569,2 +3569,6 @@\n-  Node* klass = load_object_klass(ary);\n-  return array_lh_test(klass, Klass::_lh_array_tag_vt_value_bit_inplace, 0, !flat);\n+  \/\/ We can't use immutable memory here because the mark word is mutable.\n+  \/\/ PhaseIdealLoop::move_flat_array_check_out_of_loop will make sure the\n+  \/\/ check is moved out of loops (mainly to enable loop unswitching).\n+  Node* mem = UseArrayMarkWordCheck ? memory(Compile::AliasIdxRaw) : immutable_memory();\n+  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, mem, ary));\n+  return _gvn.transform(new BoolNode(cmp, flat ? BoolTest::eq : BoolTest::ne));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1184,1 +1184,1 @@\n-\/\/ Returns true if this IfNode belongs to a non-flattened array check\n+\/\/ Returns true if this IfNode belongs to a flat array check\n@@ -1186,1 +1186,1 @@\n-bool IfNode::is_non_flattened_array_check(PhaseTransform* phase, Node** array) {\n+bool IfNode::is_flat_array_check(PhaseTransform* phase, Node** array) {\n@@ -1192,35 +1192,5 @@\n-  if (cmp->Opcode() != Op_CmpI) {\n-    return false;\n-  }\n-  Node* cmp_in1 = cmp->in(1);\n-  Node* cmp_in2 = cmp->in(2);\n-  if (cmp_in2->find_int_con(-1) != 0) {\n-    return false;\n-  }\n-  if (cmp_in1->Opcode() != Op_AndI) {\n-    return false;\n-  }\n-  Node* and_in1 = cmp_in1->in(1);\n-  Node* and_in2 = cmp_in1->in(2);\n-  if (and_in2->find_int_con(0) != Klass::_lh_array_tag_vt_value_bit_inplace) {\n-    return false;\n-  }\n-  if (and_in1->Opcode() != Op_LoadI) {\n-    return false;\n-  }\n-  intptr_t offset;\n-  Node* ptr = and_in1->in(MemNode::Address);\n-  Node* addr = AddPNode::Ideal_base_and_offset(ptr, phase, offset);\n-  if (addr == NULL || offset != in_bytes(Klass::layout_helper_offset())) {\n-    return false;\n-  }\n-  if (!phase->type(addr)->isa_klassptr()) {\n-    return false;\n-  }\n-  Node* klass_load = ptr->as_AddP()->in(AddPNode::Base)->uncast();\n-  if (klass_load->is_DecodeNKlass()) {\n-    klass_load = klass_load->in(1);\n-  }\n-  if (array != NULL && klass_load->is_Load()) {\n-    Node* address = klass_load->in(MemNode::Address);\n-    *array = address->as_AddP()->in(AddPNode::Base);\n+  if (cmp->isa_FlatArrayCheck()) {\n+    if (array != NULL) {\n+      *array = cmp->in(FlatArrayCheckNode::Array);\n+    }\n+    return true;\n@@ -1228,1 +1198,1 @@\n-  return true;\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":8,"deletions":38,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  if (unswitch_iff == NULL || unswitch_iff->is_non_flattened_array_check(&_igvn)) {\n+  if (unswitch_iff == NULL || unswitch_iff->is_flat_array_check(&_igvn)) {\n@@ -130,1 +130,1 @@\n-      if (n != NULL && n != unswitch_iff && n->is_non_flattened_array_check(&_igvn) &&\n+      if (n != NULL && n != unswitch_iff && n->is_flat_array_check(&_igvn) &&\n@@ -234,5 +234,4 @@\n-    \/\/ Adjust condition such that the true proj points to non-flat array\n-    bol = new BoolNode(bol->in(1), bol->_test.negate());\n-    register_new_node(bol, invar_iff->in(0));\n-    Node* cmp = bol->in(1)->clone();\n-    register_new_node(cmp, invar_iff->in(0));\n+    bol = bol->clone()->as_Bool();\n+    register_new_node(bol, invar_iff_c);\n+    FlatArrayCheckNode* cmp = bol->in(1)->clone()->as_FlatArrayCheck();\n+    register_new_node(cmp, invar_iff_c);\n@@ -241,1 +240,2 @@\n-    Node* lhs = NULL;\n+    assert(cmp->req() == 3, \"unexpected number of inputs for FlatArrayCheck\");\n+    cmp->add_req_batch(C->top(), unswitch_iffs.size() - 1);\n@@ -243,7 +243,2 @@\n-      Node* lh = unswitch_iffs.at(i)->in(1)->in(1)->in(1)->in(1);\n-      if (lhs == NULL) {\n-        lhs = lh;\n-      } else {\n-        lhs = new OrINode(lhs, lh);\n-        register_new_node(lhs, invar_iff->in(0));\n-      }\n+      Node* array = unswitch_iffs.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::Array);\n+      cmp->set_req(FlatArrayCheckNode::Array + i, array);\n@@ -251,3 +246,0 @@\n-    Node* masked = new AndINode(lhs, _igvn.intcon(Klass::_lh_array_tag_vt_value_bit_inplace));\n-    register_new_node(masked, invar_iff->in(0));\n-    cmp->set_req(1, masked);\n@@ -270,1 +262,1 @@\n-      ProjNode* invar_proj = invar_iff->proj_out(flat_array_checks ? (1-proj->_con) : proj->_con)->as_Proj();\n+      ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();\n@@ -290,1 +282,1 @@\n-    dominated_by(proj_true, iff, \/* flip = *\/ flat_array_checks, false);\n+    dominated_by(proj_true, iff);\n@@ -296,1 +288,1 @@\n-    dominated_by(proj_false, unswitch_iff_clone, false, false);\n+    dominated_by(proj_false, unswitch_iff_clone);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1378,0 +1378,1 @@\n+  void move_flat_array_check_out_of_loop(Node* n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -971,0 +971,50 @@\n+\/\/ If UseArrayMarkWordCheck is enabled, we can't use immutable memory for the flat array check\n+\/\/ because we are loading the mark word which is mutable. Although the bits we are interested in\n+\/\/ are immutable (we check for markWord::unlocked_value), we need to use raw memory to not break\n+\/\/ anti dependency analysis. Below code will attempt to still move flat array checks out of loops,\n+\/\/ mainly to enable loop unswitching.\n+void PhaseIdealLoop::move_flat_array_check_out_of_loop(Node* n) {\n+  \/\/ Skip checks for more than one array\n+  if (n->req() > 3) {\n+    return;\n+  }\n+  Node* mem = n->in(FlatArrayCheckNode::Memory);\n+  Node* array = n->in(FlatArrayCheckNode::Array)->uncast();\n+  IdealLoopTree* check_loop = get_loop(get_ctrl(n));\n+  IdealLoopTree* ary_loop = get_loop(get_ctrl(array));\n+\n+  \/\/ Check if array is loop invariant\n+  if (!check_loop->is_member(ary_loop)) {\n+    \/\/ Walk up memory graph from the check until we leave the loop\n+    ResourceMark rm;\n+    VectorSet wq;\n+    wq.set(mem->_idx);\n+    while (check_loop->is_member(get_loop(ctrl_or_self(mem)))) {\n+      if (mem->is_Phi()) {\n+        mem = mem->in(1);\n+      } else if (mem->is_MergeMem()) {\n+        mem = mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw);\n+      } else if (mem->is_Proj()) {\n+        mem = mem->in(0);\n+      } else if (mem->is_MemBar() || mem->is_SafePoint()) {\n+        mem = mem->in(TypeFunc::Memory);\n+      } else if (mem->is_Store() || mem->is_LoadStore() || mem->is_ClearArray()) {\n+        mem = mem->in(MemNode::Memory);\n+      } else {\n+#ifdef ASSERT\n+        mem->dump();\n+#endif\n+        ShouldNotReachHere();\n+      }\n+      if (wq.test_set(mem->_idx)) {\n+        return;\n+      }\n+    }\n+    \/\/ Replace memory input and re-compute ctrl to move the check out of the loop\n+    _igvn.replace_input_of(n, 1, mem);\n+    set_ctrl_and_loop(n, get_early_ctrl(n));\n+    Node* bol = n->unique_out();\n+    set_ctrl_and_loop(bol, get_early_ctrl(bol));\n+  }\n+}\n+\n@@ -983,0 +1033,6 @@\n+\n+  if (UseArrayMarkWordCheck && n->isa_FlatArrayCheck()) {\n+    move_flat_array_check_out_of_loop(n);\n+    return n;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2906,0 +2906,96 @@\n+\/\/ FlatArrayCheckNode (array1 array2 ...) is expanded into:\n+\/\/\n+\/\/ long mark = array1.mark | array2.mark | ...;\n+\/\/ long locked_bit = markWord::unlocked_value & array1.mark & array2.mark & ...;\n+\/\/ if (locked_bit == 0) {\n+\/\/   \/\/ One array is locked, load prototype header from the klass\n+\/\/   mark = array1.klass.proto | array2.klass.proto | ...\n+\/\/ }\n+\/\/ if ((mark & markWord::flat_array_bit_in_place) == 0) {\n+\/\/    ...\n+\/\/ }\n+void PhaseMacroExpand::expand_flatarraycheck_node(FlatArrayCheckNode* check) {\n+  if (UseArrayMarkWordCheck) {\n+    Node* mark = MakeConX(0);\n+    Node* locked_bit = MakeConX(markWord::unlocked_value);\n+    Node* mem = check->in(FlatArrayCheckNode::Memory);\n+    for (uint i = FlatArrayCheckNode::Array; i < check->req(); ++i) {\n+      Node* ary = check->in(i);\n+      if (ary->is_top()) continue;\n+      const TypeAryPtr* t = _igvn.type(ary)->isa_aryptr();\n+      assert(!t->is_flat() && !t->is_not_flat(), \"Should have been optimized out\");\n+      Node* mark_adr = basic_plus_adr(ary, oopDesc::mark_offset_in_bytes());\n+      Node* mark_load = _igvn.transform(LoadNode::make(_igvn, NULL, mem, mark_adr, mark_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+      mark = _igvn.transform(new OrXNode(mark, mark_load));\n+      locked_bit = _igvn.transform(new AndXNode(locked_bit, mark_load));\n+    }\n+    assert(!mark->is_Con(), \"Should have been optimized out\");\n+    Node* cmp = _igvn.transform(new CmpXNode(locked_bit, MakeConX(0)));\n+    Node* is_unlocked = _igvn.transform(new BoolNode(cmp, BoolTest::ne));\n+\n+    \/\/ BoolNode might be shared, replace each if user\n+    Node* old_bol = check->unique_out();\n+    assert(old_bol->is_Bool() && old_bol->as_Bool()->_test._test == BoolTest::ne, \"unexpected condition\");\n+    for (DUIterator_Last imin, i = old_bol->last_outs(imin); i >= imin; --i) {\n+      IfNode* old_iff = old_bol->last_out(i)->as_If();\n+      Node* ctrl = old_iff->in(0);\n+      RegionNode* region = new RegionNode(3);\n+      Node* mark_phi = new PhiNode(region, TypeX_X);\n+\n+      \/\/ Check if array is unlocked\n+      IfNode* iff = _igvn.transform(new IfNode(ctrl, is_unlocked, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+\n+      \/\/ Unlocked: Use bits from mark word\n+      region->init_req(1, _igvn.transform(new IfTrueNode(iff)));\n+      mark_phi->init_req(1, mark);\n+\n+      \/\/ Locked: Load prototype header from klass\n+      ctrl = _igvn.transform(new IfFalseNode(iff));\n+      Node* proto = MakeConX(0);\n+      for (uint i = FlatArrayCheckNode::Array; i < check->req(); ++i) {\n+        Node* ary = check->in(i);\n+        if (ary->is_top()) continue;\n+        \/\/ Make loads control dependent to make sure they are only executed if array is locked\n+        Node* klass_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());\n+        Node* klass = _igvn.transform(LoadKlassNode::make(_igvn, ctrl, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+        Node* proto_adr = basic_plus_adr(klass, in_bytes(Klass::prototype_header_offset()));\n+        Node* proto_load = _igvn.transform(LoadNode::make(_igvn, ctrl, C->immutable_memory(), proto_adr, proto_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+        proto = _igvn.transform(new OrXNode(proto, proto_load));\n+      }\n+      region->init_req(2, ctrl);\n+      mark_phi->init_req(2, proto);\n+\n+      \/\/ Check if flat array bits are set\n+      Node* mask = MakeConX(markWord::flat_array_bit_in_place);\n+      Node* masked = _igvn.transform(new AndXNode(_igvn.transform(mark_phi), mask));\n+      cmp = _igvn.transform(new CmpXNode(masked, MakeConX(0)));\n+      Node* is_not_flat = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n+\n+      ctrl = _igvn.transform(region);\n+      iff = _igvn.transform(new IfNode(ctrl, is_not_flat, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+      _igvn.replace_node(old_iff, iff);\n+    }\n+    _igvn.replace_node(check, C->top());\n+  } else {\n+    \/\/ Fall back to layout helper check\n+    Node* lhs = intcon(0);\n+    for (uint i = FlatArrayCheckNode::Array; i < check->req(); ++i) {\n+      Node* ary = check->in(i);\n+      if (ary->is_top()) continue;\n+      const TypeAryPtr* t = _igvn.type(ary)->isa_aryptr();\n+      assert(!t->is_flat() && !t->is_not_flat(), \"Should have been optimized out\");\n+      Node* klass_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());\n+      Node* klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+      Node* lh_addr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+      Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+      lhs = _igvn.transform(new OrINode(lhs, lh_val));\n+    }\n+    Node* masked = transform_later(new AndINode(lhs, intcon(Klass::_lh_array_tag_vt_value_bit_inplace)));\n+    Node* cmp = transform_later(new CmpINode(masked, intcon(0)));\n+    Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n+    Node* old_bol = check->unique_out();\n+    _igvn.replace_node(old_bol, bol);\n+    _igvn.replace_node(check, C->top());\n+  }\n+}\n+\n@@ -2970,0 +3066,2 @@\n+      case Node::Class_FlatArrayCheck:\n+        break;\n@@ -3108,0 +3206,4 @@\n+    case Node::Class_FlatArrayCheck:\n+      expand_flatarraycheck_node(n->as_FlatArrayCheck());\n+      assert(C->macro_count() == (old_macro_count - 1), \"expansion must have deleted one node from macro list\");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -203,0 +203,2 @@\n+  void expand_flatarraycheck_node(FlatArrayCheckNode* check);\n+\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+class FlatArrayCheckNode;\n@@ -722,3 +723,4 @@\n-        DEFINE_CLASS_ID(FastLock,   Cmp, 0)\n-        DEFINE_CLASS_ID(FastUnlock, Cmp, 1)\n-        DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)\n+        DEFINE_CLASS_ID(FastLock,       Cmp, 0)\n+        DEFINE_CLASS_ID(FastUnlock,     Cmp, 1)\n+        DEFINE_CLASS_ID(SubTypeCheck,   Cmp, 2)\n+        DEFINE_CLASS_ID(FlatArrayCheck, Cmp, 3)\n@@ -846,0 +848,1 @@\n+  DEFINE_CLASS_QUERY(FlatArrayCheck)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-      assert(ideal.ctrl()->in(0)->as_If()->is_non_flattened_array_check(&_gvn), \"Should be found\");\n+      assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n@@ -309,1 +309,1 @@\n-        assert(ideal.ctrl()->in(0)->as_If()->is_non_flattened_array_check(&_gvn), \"Should be found\");\n+        assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1269,0 +1269,37 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* FlatArrayCheckNode::Value(PhaseGVN* phase) const {\n+  bool all_not_flat = true;\n+  for (uint i = Array; i < req(); ++i) {\n+    Node* array = in(i);\n+    if (!array->is_top()) {\n+      const TypeAryPtr* t = phase->type(array)->isa_aryptr();\n+      if (t != NULL && t->is_flat()) {\n+        \/\/ One of the input arrays is flat, check always passes\n+        return TypeInt::CC_EQ;\n+      } else if (t == NULL || !t->is_not_flat()) {\n+        \/\/ One of the input arrays might be flat\n+        all_not_flat = false;\n+      }\n+    }\n+  }\n+  if (all_not_flat) {\n+    \/\/ None of the input arrays can be flat, check always fails\n+    return TypeInt::CC_GT;\n+  }\n+  return TypeInt::CC;\n+}\n+\n+\/\/------------------------------Ideal------------------------------------------\n+Node* FlatArrayCheckNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool changed = false;\n+  \/\/ Remove array inputs that are known to be non-flat\n+  for (uint i = Array; i < req(); ++i) {\n+    const TypeAryPtr* t = phase->type(in(i))->isa_aryptr();\n+    if (t != NULL && t->is_not_flat()) {\n+      set_req(i, phase->C->top());\n+      changed = true;\n+    }\n+  }\n+  return changed ? this : NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -280,0 +280,19 @@\n+\/\/--------------------------FlatArrayCheckNode---------------------------------\n+\/\/ Returns true if one of the input arrays (there can be multiple) is flat.\n+class FlatArrayCheckNode : public CmpNode {\n+public:\n+  enum {\n+    Control,\n+    Memory,\n+    Array\n+  };\n+  FlatArrayCheckNode(Compile* C, Node* mem, Node* array) : CmpNode(mem, array) {\n+    init_class_id(Class_FlatArrayCheck);\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n+  virtual int Opcode() const;\n+  virtual const Type* sub(const Type*, const Type*) const { ShouldNotReachHere(); return NULL; }\n+  const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2530,0 +2530,3 @@\n+  product(bool, UseArrayMarkWordCheck, NOT_LP64(false) LP64_ONLY(true),     \\\n+          \"Use bits in the mark word to check for flat\/null-free arrays\")   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3093,0 +3093,268 @@\n+\n+    \/\/ Test accessing a locked (inline type) array\n+    @Test()\n+    public Object test135(Object[] array, Object val) {\n+        array[0] = val;\n+        return array[1];\n+    }\n+\n+    @DontCompile\n+    public void test135_verifier(boolean warmup) {\n+        MyValue1[] array1 = new MyValue1[2];\n+        array1[1] = MyValue1.createWithFieldsInline(rI, rL);\n+        synchronized (array1) {\n+            Object res = test135(array1, array1[1]);\n+            Asserts.assertEquals(((MyValue1)res).hash(), array1[1].hash());\n+            Asserts.assertEquals(array1[0].hash(), array1[1].hash());\n+        }\n+        Integer[] array2 = new Integer[2];\n+        array2[1] = rI;\n+        synchronized (array2) {\n+            Object res = test135(array2, array2[1]);\n+            Asserts.assertEquals(res, array2[1]);\n+            Asserts.assertEquals(array2[0], array2[1]);\n+        }\n+    }\n+\n+    \/\/ Same as test135 but with locking in compiled method\n+    @Test()\n+    public Object test136(Object[] array, Object val) {\n+        Object res = null;\n+        synchronized (array) {\n+            array[0] = val;\n+            res = array[1];\n+        }\n+        return res;\n+    }\n+\n+    @DontCompile\n+    public void test136_verifier(boolean warmup) {\n+        MyValue1[] array1 = new MyValue1[2];\n+        array1[1] = MyValue1.createWithFieldsInline(rI, rL);\n+        Object res = test136(array1, array1[1]);\n+        Asserts.assertEquals(((MyValue1)res).hash(), array1[1].hash());\n+        Asserts.assertEquals(array1[0].hash(), array1[1].hash());\n+        Integer[] array2 = new Integer[2];\n+        array2[1] = rI;\n+        res = test136(array2, array2[1]);\n+        Asserts.assertEquals(res, array2[1]);\n+        Asserts.assertEquals(array2[0], array2[1]);\n+    }\n+\n+    Object oFld1, oFld2;\n+\n+    \/\/ Test loop unwswitching with locked (inline type) array accesses\n+    @Test()\n+    public void test137(Object[] array1, Object[] array2) {\n+        for (int i = 0; i < array1.length; i++) {\n+            oFld1 = array1[i];\n+            oFld2 = array2[i];\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test137_verifier(boolean warmup) {\n+        MyValue1[] array1 = new MyValue1[100];\n+        Arrays.fill(array1, MyValue1.createWithFieldsInline(rI, rL));\n+        Integer[] array2 = new Integer[100];\n+        Arrays.fill(array2, rI);\n+        synchronized (array1) {\n+            test137(array1, array1);\n+            Asserts.assertEquals(oFld1, array1[0]);\n+            Asserts.assertEquals(oFld2, array1[0]);\n+            test137(array1, array2);\n+            Asserts.assertEquals(oFld1, array1[0]);\n+            Asserts.assertEquals(oFld2, array2[0]);\n+            test137(array2, array1);\n+            Asserts.assertEquals(oFld1, array2[0]);\n+            Asserts.assertEquals(oFld2, array1[0]);\n+        }\n+        synchronized (array2) {\n+            test137(array2, array2);\n+            Asserts.assertEquals(oFld1, array2[0]);\n+            Asserts.assertEquals(oFld2, array2[0]);\n+            test137(array1, array2);\n+            Asserts.assertEquals(oFld1, array1[0]);\n+            Asserts.assertEquals(oFld2, array2[0]);\n+            test137(array2, array1);\n+            Asserts.assertEquals(oFld1, array2[0]);\n+            Asserts.assertEquals(oFld2, array1[0]);\n+        }\n+    }\n+\n+    \/\/ Same as test137 but with locking in loop\n+    @Test()\n+    public void test138(Object[] array1, Object[] array2) {\n+        for (int i = 0; i < array1.length; i++) {\n+            synchronized (array1) {\n+                oFld1 = array1[i];\n+            }\n+            synchronized (array2) {\n+                oFld2 = array2[i];\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test138_verifier(boolean warmup) {\n+        MyValue1[] array1 = new MyValue1[100];\n+        Arrays.fill(array1, MyValue1.createWithFieldsInline(rI, rL));\n+        Integer[] array2 = new Integer[100];\n+        Arrays.fill(array2, rI);\n+        test138(array1, array1);\n+        Asserts.assertEquals(oFld1, array1[0]);\n+        Asserts.assertEquals(oFld2, array1[0]);\n+        test138(array1, array2);\n+        Asserts.assertEquals(oFld1, array1[0]);\n+        Asserts.assertEquals(oFld2, array2[0]);\n+        test138(array2, array1);\n+        Asserts.assertEquals(oFld1, array2[0]);\n+        Asserts.assertEquals(oFld2, array1[0]);\n+        test138(array2, array2);\n+        Asserts.assertEquals(oFld1, array2[0]);\n+        Asserts.assertEquals(oFld2, array2[0]);\n+        Asserts.assertEquals(oFld2, array2[0]);\n+    }\n+\n+    \/\/ Test load from array that is only known to be non-inline after parsing\n+    @Test(failOn = ALLOC + ALLOCA + ALLOC_G + ALLOCA_G + LOOP + LOAD + STORE + TRAP + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)\n+    public Object test139() {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = varray;\n+            varray = iarray;\n+        }\n+        return array[0];\n+    }\n+\n+    @DontCompile\n+    public void test139_verifier(boolean warmup) {\n+        Object res = test139();\n+        Asserts.assertEquals(res, null);\n+    }\n+\n+    \/\/ Test store to array that is only known to be non-inline after parsing\n+    @Test(failOn = ALLOC + ALLOCA + ALLOC_G + LOOP + LOAD + STORE + TRAP + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)\n+    public Object[] test140(Object val) {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = varray;\n+            varray = iarray;\n+        }\n+        array[0] = val;\n+        return array;\n+    }\n+\n+    @DontCompile\n+    public void test140_verifier(boolean warmup) {\n+        Object[] res = test140(rI);\n+        Asserts.assertEquals(res[0], rI);\n+        res = test140(null);\n+        Asserts.assertEquals(res[0], null);\n+    }\n+\n+    \/\/ Test load from array that is only known to be inline after parsing\n+    \/\/ TODO 8255938\n+    \/\/ @Test(failOn = ALLOC + ALLOCA + ALLOC_G + ALLOCA_G + LOOP + LOAD + STORE + TRAP + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)\n+    @Test\n+    public Object test141() {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = iarray;\n+            iarray = varray;\n+        }\n+        return array[0];\n+    }\n+\n+    @DontCompile\n+    public void test141_verifier(boolean warmup) {\n+        Object res = test141();\n+        Asserts.assertEquals(res, MyValue1.default);\n+    }\n+\n+    \/\/ Test store to array that is only known to be inline after parsing\n+    \/\/ TODO 8255938\n+    \/\/ @Test(failOn = ALLOC + ALLOCA + ALLOC_G + LOOP + LOAD + STORE + TRAP + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)\n+    @Test\n+    public Object[] test142(Object val) {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = iarray;\n+            iarray = varray;\n+        }\n+        array[0] = val;\n+        return array;\n+    }\n+\n+    @DontCompile\n+    public void test142_verifier(boolean warmup) {\n+        Object[] res = test142(MyValue1.default);\n+        Asserts.assertEquals(res[0], MyValue1.default);\n+        if (!warmup) {\n+            try {\n+                test142(null);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    static interface MyInterface143 {\n+        public int hash();\n+    }\n+\n+    static class MyObject143 implements MyInterface143 {\n+        public int hash() { return 42; }\n+    }\n+\n+    volatile MyInterface143[] array143 = new MyObject143[1];\n+    int len143 = 0;\n+\n+    volatile int vf = 0;\n+\n+    \/\/ Test that triggers an anti dependency failure when array mark word is loaded from immutable memory\n+    @Test\n+    @Warmup(0)\n+    public void test143() {\n+        MyInterface143[] arr = array143;\n+        int tmp = arr.length;\n+        for (int i = 0; i < len143; i++) {\n+            if (arr[i].hash() > 0) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test143_verifier(boolean warmup) {\n+        test143();\n+    }\n+\n+    \/\/ Same as test143 but with two flat array checks that are unswitched\n+    @Test\n+    @Warmup(0)\n+    public void test144() {\n+        MyInterface143[] arr1 = array143;\n+        MyInterface143[] arr2 = array143;\n+        int tmp1 = arr1.length;\n+        int tmp2 = arr2.length;\n+        for (int i = 0; i < len143; i++) {\n+            if (arr1[i].hash() > 0 && arr2[i].hash() > 0) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test144_verifier(boolean warmup) {\n+        test144();\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -1050,0 +1050,28 @@\n+\n+    \/\/ Test OptimizePtrCompare part of Escape Analysis\n+    @Test()\n+    public void test56(int idx) {\n+        Object[] va = (Object[])Array.newInstance(MyValue1.val.class, 1);\n+        if (va[idx] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test56_verifier(boolean warmup) {\n+        test56(0);\n+    }\n+\n+    \/\/ Same as test56 but with load from known array index\n+    @Test()\n+    public void test57() {\n+        Object[] va = (Object[])Array.newInstance(MyValue1.val.class, 1);\n+        if (va[0] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test57_verifier(boolean warmup) {\n+        test57();\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}