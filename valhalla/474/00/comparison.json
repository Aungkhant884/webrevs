{"files":[{"patch":"@@ -59,1 +59,0 @@\n-  case T_INLINE_TYPE:\n","filename":"src\/hotspot\/share\/ci\/ciConstant.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -696,1 +696,1 @@\n-    if (tag.is_unresolved_klass()) {\n+    if (!klass->is_loaded()) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,0 +124,14 @@\n+ciInstance* ciInlineKlass::ref_instance() const {\n+  GUARDED_VM_ENTRY(\n+    oop ref_mirror = to_InlineKlass()->ref_mirror();\n+    return CURRENT_ENV->get_instance(ref_mirror);\n+  )\n+}\n+\n+ciInstance* ciInlineKlass::val_instance() const {\n+  GUARDED_VM_ENTRY(\n+    oop val_mirror = to_InlineKlass()->val_mirror();\n+    return CURRENT_ENV->get_instance(val_mirror);\n+  )\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+  ciInstance* ref_instance() const;\n+  ciInstance* val_instance() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-ciType* ciInstance::java_mirror_type() {\n+ciType* ciInstance::java_mirror_type(bool* is_val_mirror) {\n@@ -55,0 +55,3 @@\n+    if (is_val_mirror != NULL) {\n+      *is_val_mirror = java_lang_Class::is_secondary_mirror(m);\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  ciType* java_mirror_type();\n+  ciType* java_mirror_type(bool* is_val_mirror = NULL);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -633,1 +633,1 @@\n-  ciWrapper* wrapper = new (arena()) ciWrapper(type, \/* null_free *\/ true);\n+  ciWrapper* wrapper = new (arena()) ciWrapper(type);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  virtual ciType*     unwrap()              { return this; }\n+  virtual ciType* unwrap()                  { return this; }\n@@ -115,2 +115,2 @@\n-\/\/ This class wraps another type to carry additional information like nullability.\n-\/\/ Should only be instantiated and used by ciTypeFlow and ciSignature.\n+\/\/ This class wraps another type to carry additional information.\n+\/\/ Currently it is only used to mark inline klasses as null-free.\n@@ -122,1 +122,0 @@\n-  bool _null_free;\n@@ -124,1 +123,1 @@\n-  ciWrapper(ciType* type, bool null_free) : ciType(type->basic_type()) {\n+  ciWrapper(ciType* type) : ciType(type->basic_type()) {\n@@ -130,1 +129,0 @@\n-    _null_free = null_free;\n@@ -138,4 +136,3 @@\n-  bool    is_wrapper() const { return true; }\n-\n-  ciType*     unwrap()       { return _type; }\n-  bool is_null_free() const { return _null_free; }\n+  bool is_wrapper()   const { return true; }\n+  ciType* unwrap()          { return _type; }\n+  bool is_null_free() const { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-    if (null_free1 && null_free2) {\n+    if (null_free1 && null_free2 && result->is_inlinetype()) {\n@@ -640,0 +640,4 @@\n+    if (type->unwrap() != klass && type->unwrap()->is_subtype_of(klass)) {\n+      \/\/ Useless cast, propagate more precise type of object\n+      klass = type->unwrap()->as_klass();\n+    }\n@@ -1582,1 +1586,1 @@\n-  ciType* type = type_at(c);\n+  ciType* type = type_at(c)->unwrap();\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -348,0 +348,2 @@\n+  static int primary_mirror_offset()       { CHECK_INIT(_primary_mirror_offset); }\n+  static int secondary_mirror_offset()     { CHECK_INIT(_secondary_mirror_offset); }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,0 +270,3 @@\n+    } else if (ary_ptr->is_flat()) {\n+      \/\/ Clone flat inline type array\n+      bt = T_LONG;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-  const TypeTuple *range_cc = tf()->range_cc();\n+  const TypeTuple* range_cc = tf()->range_cc();\n@@ -738,1 +738,7 @@\n-    if (is_CallRuntime()) {\n+    if (tf()->returns_inline_type_as_fields()) {\n+      \/\/ The call returns multiple values (inline type fields): we\n+      \/\/ create one projection per returned value.\n+      assert(con <= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, \"only for multi value return\");\n+      uint ideal_reg = range_cc->field_at(con)->ideal_reg();\n+      return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);\n+    } else {\n@@ -766,6 +772,0 @@\n-    } else {\n-      \/\/ The Call may return multiple values (inline type fields): we\n-      \/\/ create one projection per returned value.\n-      assert(con <= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, \"only for multi value return\");\n-      uint ideal_reg = range_cc->field_at(con)->ideal_reg();\n-      return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3683,0 +3683,7 @@\n+Node* GraphKit::is_val_mirror(Node* mirror) {\n+  Node* p = basic_plus_adr(mirror, java_lang_Class::secondary_mirror_offset());\n+  Node* secondary_mirror = access_load_at(mirror, p, _gvn.type(p)->is_ptr(), TypeInstPtr::MIRROR->cast_to_ptr_type(TypePtr::BotPTR), T_OBJECT, IN_HEAP);\n+  Node* cmp = _gvn.transform(new CmpPNode(mirror, secondary_mirror));\n+  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -872,0 +872,1 @@\n+  Node* is_val_mirror(Node* mirror);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2519,1 +2519,1 @@\n-    if (field != NULL && field->type()->is_inlinetype() && !field->is_flattened()) {\n+    if (field != NULL && field->is_null_free() && !field->is_flattened()) {\n@@ -3158,4 +3158,0 @@\n-Node* LibraryCallKit::generate_value_guard(Node* kls, RegionNode* region) {\n-  return generate_access_flags_guard(kls, JVM_ACC_INLINE, 0, region);\n-}\n-\n@@ -3370,1 +3366,3 @@\n-  ciType* tm = mirror_con->java_mirror_type();\n+  ciType* tm = mirror_con->java_mirror_type(&requires_null_check);\n+  \/\/ Check for null if casting to QMyValue\n+  requires_null_check &= !obj->is_InlineType();\n@@ -3376,3 +3374,0 @@\n-      \/\/ Check for null if casting to .val\n-      requires_null_check = !obj->is_InlineType() && tm->as_klass()->is_inlinetype();\n-\n@@ -3427,3 +3422,3 @@\n-      \/\/ Check if we are casting to .val\n-      Node* is_val_kls = generate_value_guard(kls, NULL);\n-      if (is_val_kls != NULL) {\n+      \/\/ Check if we are casting to QMyValue\n+      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), NULL);\n+      if (ctrl_val_mirror != NULL) {\n@@ -3434,7 +3429,9 @@\n-        \/\/ Casting to .val, check for null\n-        set_control(is_val_kls);\n-        Node* null_ctr = top();\n-        null_check_oop(obj, &null_ctr);\n-        region->init_req(_npe_path, null_ctr);\n-        r->init_req(2, control());\n-\n+        \/\/ Casting to QMyValue, check for null\n+        set_control(ctrl_val_mirror);\n+        { \/\/ PreserveJVMState because null check replaces obj in map\n+          PreserveJVMState pjvms(this);\n+          Node* null_ctr = top();\n+          null_check_oop(obj, &null_ctr);\n+          region->init_req(_npe_path, null_ctr);\n+          r->init_req(2, control());\n+        }\n@@ -3531,0 +3528,3 @@\n+    \/\/ If superc is an inline mirror, we also need to check if superc == subc because LMyValue\n+    \/\/ is not a subtype of QMyValue but due to subk == superk the subtype check will pass.\n+    generate_fair_guard(is_val_mirror(args[0]), prim_region);\n@@ -4543,1 +4543,1 @@\n-      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing) &&\n+      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Expansion) &&\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-  Node* generate_value_guard(Node* kls, RegionNode* region);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-RegMask* Matcher::return_values_mask(const TypeTuple *range) {\n+RegMask* Matcher::return_values_mask(const TypeTuple* range) {\n@@ -194,0 +194,2 @@\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, cnt);\n+  VMRegPair* vm_parm_regs = NEW_RESOURCE_ARRAY(VMRegPair, cnt);\n@@ -195,19 +197,3 @@\n-  if (!InlineTypeReturnedAsFields) {\n-    \/\/ Get ideal-register return type\n-    uint ireg = range->field_at(TypeFunc::Parms)->ideal_reg();\n-    \/\/ Get machine return register\n-    OptoRegPair regs = return_value(ireg);\n-\n-    \/\/ And mask for same\n-    mask[0].Clear();\n-    mask[0].Insert(regs.first());\n-    if (OptoReg::is_valid(regs.second())) {\n-      mask[0].Insert(regs.second());\n-    }\n-  } else {\n-    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, cnt);\n-    VMRegPair* vm_parm_regs = NEW_RESOURCE_ARRAY(VMRegPair, cnt);\n-\n-    for (uint i = 0; i < cnt; i++) {\n-      sig_bt[i] = range->field_at(i+TypeFunc::Parms)->basic_type();\n-    }\n+  for (uint i = 0; i < cnt; i++) {\n+    sig_bt[i] = range->field_at(i+TypeFunc::Parms)->basic_type();\n+  }\n@@ -215,4 +201,4 @@\n-    int regs = SharedRuntime::java_return_convention(sig_bt, vm_parm_regs, cnt);\n-    assert(regs > 0, \"should have been tested during graph construction\");\n-    for (uint i = 0; i < cnt; i++) {\n-      mask[i].Clear();\n+  int regs = SharedRuntime::java_return_convention(sig_bt, vm_parm_regs, cnt);\n+  assert(regs > 0, \"should have been tested during graph construction\");\n+  for (uint i = 0; i < cnt; i++) {\n+    mask[i].Clear();\n@@ -220,8 +206,7 @@\n-      OptoReg::Name reg1 = OptoReg::as_OptoReg(vm_parm_regs[i].first());\n-      if (OptoReg::is_valid(reg1)) {\n-        mask[i].Insert(reg1);\n-      }\n-      OptoReg::Name reg2 = OptoReg::as_OptoReg(vm_parm_regs[i].second());\n-      if (OptoReg::is_valid(reg2)) {\n-        mask[i].Insert(reg2);\n-      }\n+    OptoReg::Name reg1 = OptoReg::as_OptoReg(vm_parm_regs[i].first());\n+    if (OptoReg::is_valid(reg1)) {\n+      mask[i].Insert(reg1);\n+    }\n+    OptoReg::Name reg2 = OptoReg::as_OptoReg(vm_parm_regs[i].second());\n+    if (OptoReg::is_valid(reg2)) {\n+      mask[i].Insert(reg2);\n@@ -230,0 +215,1 @@\n+\n@@ -1129,1 +1115,1 @@\n-              if (n->in(0)->is_Call()) {\n+              if (n->in(0)->is_Call() && n->in(0)->as_Call()->tf()->returns_inline_type_as_fields()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":19,"deletions":33,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-  RegMask* return_values_mask(const TypeTuple *range);\n+  RegMask* return_values_mask(const TypeTuple* range);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2026,5 +2026,14 @@\n-      if (mirror_type != NULL && mirror_type->is_inlinetype()) {\n-        ciInlineKlass* vk = mirror_type->as_inline_klass();\n-        if (off == vk->default_value_offset()) {\n-          \/\/ Loading a special hidden field that contains the oop of the default inline type\n-          const Type* const_oop = TypeInstPtr::make(vk->default_instance());\n+      if (mirror_type != NULL) {\n+        const Type* const_oop = NULL;\n+        ciInlineKlass* vk = mirror_type->is_inlinetype() ? mirror_type->as_inline_klass() : NULL;\n+        \/\/ Fold default value loads\n+        if (vk != NULL && off == vk->default_value_offset()) {\n+          const_oop = TypeInstPtr::make(vk->default_instance());\n+        }\n+        \/\/ Fold class mirror loads\n+        if (off == java_lang_Class::primary_mirror_offset()) {\n+          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n+        } else if (off == java_lang_Class::secondary_mirror_offset()) {\n+          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n+        }\n+        if (const_oop != NULL) {\n@@ -2390,1 +2399,2 @@\n-      ciType* t = tinst->java_mirror_type();\n+      bool null_free = false;\n+      ciType* t = tinst->java_mirror_type(&null_free);\n@@ -2400,6 +2410,1 @@\n-          if (t->is_inlinetype()) {\n-            \/\/ TODO fix with JDK-8267932\n-            return LoadNode::Value(phase);\n-          } else {\n-            return TypeKlassPtr::make(ciArrayKlass::make(t));\n-          }\n+          return TypeKlassPtr::make(ciArrayKlass::make(t, null_free));\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3325,1 +3325,1 @@\n-        if (str.type()->is_inlinetype() && str.type()->as_inline_klass()->can_be_passed_as_fields()) {\n+        if (str.is_null_free() && str.type()->as_inline_klass()->can_be_passed_as_fields()) {\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4352,1 +4352,1 @@\n-ciType* TypeInstPtr::java_mirror_type() const {\n+ciType* TypeInstPtr::java_mirror_type(bool* is_val_mirror) const {\n@@ -4358,1 +4358,1 @@\n-  return const_oop()->as_instance()->java_mirror_type();\n+  return const_oop()->as_instance()->java_mirror_type(is_val_mirror);\n@@ -5889,2 +5889,1 @@\n-  bool has_scalar_ret = sig->returns_null_free_inline_type() && sig->return_type()->is_inlinetype() &&\n-                        sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  bool has_scalar_ret = sig->returns_null_free_inline_type() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1268,1 +1268,1 @@\n-  ciType* java_mirror_type() const;\n+  ciType* java_mirror_type(bool* is_val_mirror = NULL) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2887,1 +2887,1 @@\n-  \/\/ TODO: Reimplement JDK-8266015, dropped from jdk->lworld merge\n+  \/\/ TODO 8268946: Reimplement JDK-8266015, dropped from jdk->lworld merge\n@@ -2994,1 +2994,2 @@\n-      if (VerifyAdapterSharing) {\n+      \/\/ TODO fix with 8268946\n+      if (false && VerifyAdapterSharing) {\n@@ -2996,3 +2997,0 @@\n-          if (!shared_entry->compare_code(buf->code_begin(), buffer.insts_size())) {\n-            method->print();\n-          }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1256,1 +1256,0 @@\n-        \/\/ TODO 8244562: Remove cast as workaround once javac is fixed\n@@ -1276,1 +1275,0 @@\n-        \/\/ TODO 8244562: Remove cast as workaround once javac is fixed\n@@ -1292,1 +1290,0 @@\n-        \/\/ TODO 8244562: Remove cast as workaround once javac is fixed\n@@ -1342,1 +1339,0 @@\n-        \/\/ TODO 8244562: Remove cast as workaround once javac is fixed\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        case 4: return new String[] {\"-XX:-MonomorphicArrayCheck\"};\n+        case 4: return new String[] {\"-XX:-MonomorphicArrayCheck\", \"-XX:PerMethodSpecTrapLimit=0\", \"-XX:PerMethodTrapLimit=0\"};\n@@ -115,1 +115,1 @@\n-        Asserts.assertTrue(test3(MyValue1.val.class) == MyValue1.ref.class, \"test3_3 failed\");\n+        Asserts.assertTrue(test3(MyValue1.val.class) == MyAbstract.class, \"test3_3 failed\");\n@@ -123,4 +123,2 @@\n-        \/\/ TODO 8244562: Remove cast as workaround once javac is fixed\n-        boolean check2 = (Class<?>)MyValue1.ref.class.getSuperclass() == MyAbstract.class;\n-        \/\/ TODO 8244562: Remove cast as workaround once javac is fixed\n-        boolean check3 = (Class<?>)MyValue1.val.class.getSuperclass() == MyValue1.ref.class;\n+        boolean check2 = MyValue1.ref.class.getSuperclass() == MyAbstract.class;\n+        boolean check3 = MyValue1.val.class.getSuperclass() == MyAbstract.class;\n@@ -472,1 +470,1 @@\n-    MyValue1.ref test27_vt = MyValue1.createWithFieldsInline(rI, rL);\n+    MyValue1.ref test27_vt;\n@@ -484,2 +482,2 @@\n-    public MyValue1 test27() {\n-        return (MyValue1)U.getReference(this, TEST27_OFFSET);\n+    public MyValue1.ref test27() {\n+        return (MyValue1.ref)U.getReference(this, TEST27_OFFSET);\n@@ -490,1 +488,5 @@\n-        MyValue1 res = test27();\n+        test27_vt = null;\n+        MyValue1.ref res = test27();\n+        Asserts.assertEQ(res, null);\n+        test27_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        res = test27();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3783,0 +3783,20 @@\n+\n+    \/\/ Test that virtual calls on inline type receivers are properly inlined\n+    @Test(failOn = ALLOC + LOAD + STORE)\n+    public long test142() {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        return val.hash();\n+    }\n+\n+    @DontCompile\n+    public void test142_verifier(boolean warmup) {\n+        long res = test142();\n+        Asserts.assertEquals(res, testValue2.hash());\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}