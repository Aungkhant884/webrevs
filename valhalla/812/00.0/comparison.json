{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=20\n+version=21\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+    -taglet build.tools.taglet.SealedGraph \\\n@@ -104,0 +105,4 @@\n+# Allow overriding on the command line\n+# (intentionally sharing name with the javac option)\n+JAVA_WARNINGS_ARE_ERRORS ?= -Werror\n+\n@@ -191,1 +196,1 @@\n-# GenGraphs tool.\n+# GenGraphs tool for a module.\n@@ -195,2 +200,2 @@\n-define setup_gengraph_dot_to_svg\n-  $1_$2_DOT_SRC :=  $$($1_GENGRAPHS_DIR)\/$2.dot\n+define setup_module_graph_dot_to_svg\n+  $1_$2_DOT_SRC :=  $$($1_MODULE_GRAPHS_DIR)\/$2.dot\n@@ -201,1 +206,1 @@\n-    $$(eval $$(call SetupExecute, gengraphs_svg_$1_$2, \\\n+    $$(eval $$(call SetupExecute, module_graphs_svg_$1_$2, \\\n@@ -203,1 +208,31 @@\n-        DEPS := $$(gengraphs_$1_TARGET), \\\n+        DEPS := $$(module_graphs_dot_$1_TARGET), \\\n+        OUTPUT_FILE := $$($1_$2_SVG_TARGET), \\\n+        SUPPORT_DIR := $$($1_MODULE_GRAPHS_DIR), \\\n+        COMMAND := $$(DOT) -Tsvg -o $$($1_$2_SVG_TARGET) $$($1_$2_DOT_SRC), \\\n+    ))\n+\n+  $1_GRAPHS_TARGETS += $$($1_$2_SVG_TARGET)\n+endef\n+\n+# Helper function for creating a svg file for a class for which the SealedGraph\n+# taglet has generated a dot file. The dot file has a special name which\n+# encodes the module and class the graph belongs to.\n+#\n+# param 1: SetupJavadocGeneration namespace ($1)\n+# param 2: dot file name\n+#\n+define setup_sealed_graph_dot_to_svg\n+  $1_$2_DOT_SRC :=  $$($1_SEALED_GRAPHS_DIR)\/$2.dot\n+  $1_$2_TARGET_CLASS := $$(word 2, $$(subst _, , $2))\n+  $1_$2_SLASHED_NAME := $$(subst .,\/, $$($1_$2_TARGET_CLASS))\n+  $1_$2_TARGET_MODULE := $$(word 1, $$(subst _, , $2))\n+  $1_$2_TARGET_PATH := $$($1_TARGET_DIR)\/$$($1_$2_TARGET_MODULE)\/$$(dir $$($1_$2_SLASHED_NAME))\n+  $1_$2_TARGET_NAME := $$(notdir $$($1_$2_SLASHED_NAME))\n+  $1_$2_SVG_TARGET := $$($1_$2_TARGET_PATH)\/$$($1_$2_TARGET_NAME)-sealed-graph.svg\n+  $$(call MakeDir, $$($1_$2_TARGET_PATH))\n+\n+    # For each class needing a graph, create a svg file from the dot file\n+    # generated by the SealedGraph taglet and store it in the target dir.\n+    $$(eval $$(call SetupExecute, sealed_graphs_svg_$1_$2, \\\n+        INFO := Running dot for sealed graphs for $$($1_$2_TARGET_MODULE)\/$$($1_$2_TARGET_CLASS), \\\n+        DEPS := $$($1_$2_DOT_SRC), \\\n@@ -205,1 +240,1 @@\n-        SUPPORT_DIR := $$($1_GENGRAPHS_DIR), \\\n+        SUPPORT_DIR := $$($1_SEALED_GRAPHS_DIR), \\\n@@ -209,1 +244,1 @@\n-  $1_MODULEGRAPH_TARGETS += $$($1_$2_SVG_TARGET)\n+  $1_GRAPHS_TARGETS += $$($1_$2_SVG_TARGET)\n@@ -257,1 +292,1 @@\n-# $1_MODULEGRAPH_TARGETS. Note that the index.html file will work as a \"touch\n+# $1_GRAPHS_TARGETS. Note that the index.html file will work as a \"touch\n@@ -280,3 +315,6 @@\n-    # Tell the ModuleGraph taglet to generate html links to soon-to-be-created\n-    # svg files with module graphs.\n-    $1_JAVA_ARGS += -DenableModuleGraph=true\n+    $1_SEALED_GRAPHS_DIR := $$(SUPPORT_OUTPUTDIR)\/docs\/$1-sealed-graphs\n+\n+    # Tell the ModuleGraph and SealedGraph taglets to generate html links to\n+    # soon-to-be-created svg files with module\/sealed graphs.\n+    $1_JAVA_ARGS += -DenableModuleGraph=true -DsealedDotOutputDir=$$($1_SEALED_GRAPHS_DIR)\n+    $$(call MakeDir, $$($1_SEALED_GRAPHS_DIR))\n@@ -303,0 +341,1 @@\n+  $1_OPTIONS += $$(JAVA_WARNINGS_ARE_ERRORS)\n@@ -388,1 +427,1 @@\n-    GENGRAPHS_PROPS := \\\n+    MODULE_GRAPHS_PROPS := \\\n@@ -391,1 +430,1 @@\n-    $1_GENGRAPHS_DIR := $$(SUPPORT_OUTPUTDIR)\/docs\/$1-gengraphs\n+    $1_MODULE_GRAPHS_DIR := $$(SUPPORT_OUTPUTDIR)\/docs\/$1-module-graphs\n@@ -393,6 +432,6 @@\n-    $$(eval $$(call SetupExecute, gengraphs_$1, \\\n-        INFO := Running gengraphs for $1 documentation, \\\n-        DEPS := $$(BUILD_JIGSAW_TOOLS) $$(GENGRAPHS_PROPS), \\\n-        OUTPUT_DIR := $$($1_GENGRAPHS_DIR), \\\n-        COMMAND := $$(TOOL_GENGRAPHS) --spec --output $$($1_GENGRAPHS_DIR) \\\n-            --dot-attributes $$(GENGRAPHS_PROPS), \\\n+    $$(eval $$(call SetupExecute, module_graphs_dot_$1, \\\n+        INFO := Generating module graphs for $1 documentation, \\\n+        DEPS := $$(BUILD_JIGSAW_TOOLS) $$(MODULE_GRAPHS_PROPS), \\\n+        OUTPUT_DIR := $$($1_MODULE_GRAPHS_DIR), \\\n+        COMMAND := $$(TOOL_GENGRAPHS) --spec --output $$($1_MODULE_GRAPHS_DIR) \\\n+            --dot-attributes $$(MODULE_GRAPHS_PROPS), \\\n@@ -403,1 +442,2 @@\n-    # They will depend on gengraphs_$1_TARGET, and will be added to $1.\n+    # They will depend on module_graphs_dot_$1_TARGET, and will be added to\n+    # $1_GRAPHS_TARGETS.\n@@ -405,1 +445,16 @@\n-      $$(eval $$(call setup_gengraph_dot_to_svg,$1,$$m)) \\\n+      $$(eval $$(call setup_module_graph_dot_to_svg,$1,$$m)) \\\n+    )\n+\n+    # We have asked SealedGraph to generate dot files and links to svg files.\n+    # Now we must produce the svg files from the dot files.\n+\n+    # Get a list of classes for which SealedGraph has generated dot files\n+    $1_SEALED_CLASSES := $$(patsubst %.dot,%,$$(patsubst \\\n+        $$($1_SEALED_GRAPHS_DIR)\/%,%, \\\n+        $$(wildcard $$($1_SEALED_GRAPHS_DIR)\/*.dot)))\n+\n+    # For each class needing a graph, create a svg file from the dot file\n+    # generated by the SealedGraph taglet and store it in the target dir.\n+    # They will will be added to $1_GRAPHS_TARGETS.\n+    $$(foreach c, $$($1_SEALED_CLASSES), \\\n+      $$(eval $$(call setup_sealed_graph_dot_to_svg,$1,$$c)) \\\n@@ -411,1 +466,1 @@\n-# Setup generation of the JDK API documentation (javadoc + modulegraph)\n+# Setup generation of the JDK API documentation (javadoc + graphs)\n@@ -460,1 +515,1 @@\n-# JDK_API_MODULEGRAPH_TARGETS.\n+# JDK_API_GRAPHS_TARGETS.\n@@ -463,1 +518,1 @@\n-# Setup generation of the Java SE API documentation (javadoc + modulegraph)\n+# Setup generation of the Java SE API documentation (javadoc + graphs)\n@@ -477,1 +532,1 @@\n-# JAVASE_API_MODULEGRAPH_TARGETS.\n+# JAVASE_API_GRAPHS_TARGETS.\n@@ -480,1 +535,1 @@\n-# Setup generation of the reference Java SE API documentation (javadoc + modulegraph)\n+# Setup generation of the reference Java SE API documentation (javadoc + graphs)\n@@ -498,1 +553,1 @@\n-# REFERENCE_API_MODULEGRAPH_TARGETS.\n+# REFERENCE_API_GRAPHS_TARGETS.\n@@ -597,0 +652,3 @@\n+  # Unset the following to suppress the link to the tool guides\n+  NAV_LINK_GUIDES := --nav-link-guides\n+  HEADER_RIGHT_SIDE_INFO := <strong>$(subst &amp;,&,$(JDK_SHORT_NAME))$(DRAFT_MARKER_STR)<\/strong>\n@@ -613,1 +671,2 @@\n-            POST_PROCESS := $(TOOL_FIXUPPANDOC), \\\n+            POST_PROCESS := $(TOOL_FIXUPPANDOC) --insert-nav --nav-right-info '$(HEADER_RIGHT_SIDE_INFO)' \\\n+                --nav-subdirs $($m_$f_NOF_SUBDIRS) $(NAV_LINK_GUIDES), \\\n@@ -647,1 +706,2 @@\n-            POST_PROCESS := $(TOOL_FIXUPPANDOC), \\\n+            POST_PROCESS := $(TOOL_FIXUPPANDOC) --insert-nav --nav-right-info '$(HEADER_RIGHT_SIDE_INFO)' \\\n+                --nav-subdirs 1 --nav-link-guides, \\\n@@ -662,0 +722,10 @@\n+SPEC_HEADER_BLOCK := \\\n+<header id=\"title-block-header\"> \\\n+    <div class=\"navbar\"> \\\n+        <div>$(HEADER_RIGHT_SIDE_INFO)<\/div> \\\n+        <nav><ul><li><a href=\"PATH_TO_SPECS\/..\/api\/index.html\">API<\/a> \\\n+        <li><a href=\"PATH_TO_SPECS\/index.html\">OTHER SPECIFICATIONS \\\n+        <li><a href=\"PATH_TO_SPECS\/man\/index.html\">TOOL GUIDES<\/a><\/ul><\/nav> \\\n+    <\/div> \\\n+<\/header>\n+\n@@ -664,0 +734,1 @@\n+  JDWP_HEADER_BLOCK := $(subst PATH_TO_SPECS,..,$(SPEC_HEADER_BLOCK))\n@@ -668,1 +739,2 @@\n-          <body> => <body>$(SPECS_TOP) ; \\\n+          <style> => <link rel=\"stylesheet\" href=\"..\/..\/resources\/jdk-default.css\"\/><style> ; \\\n+          <body> => <body>$(SPECS_TOP)$(JDWP_HEADER_BLOCK) ; \\\n@@ -677,0 +749,1 @@\n+  JVMTI_HEADER_BLOCK := $(subst PATH_TO_SPECS,.,$(SPEC_HEADER_BLOCK))\n@@ -681,1 +754,2 @@\n-          <body> => <body>$(SPECS_TOP) ; \\\n+          <style> => <link rel=\"stylesheet\" href=\"..\/resources\/jdk-default.css\"\/><style> ; \\\n+          <body> => <body>$(SPECS_TOP)$(JVMTI_HEADER_BLOCK) ; \\\n@@ -696,1 +770,1 @@\n-    EXTRA_DEPS := $(JDK_API_JAVADOC_TARGETS) $(JDK_API_MODULEGRAPH_TARGETS) \\\n+    EXTRA_DEPS := $(JDK_API_JAVADOC_TARGETS) $(JDK_API_GRAPHS_TARGETS) \\\n@@ -724,1 +798,1 @@\n-docs-jdk-api-modulegraph: $(JDK_API_MODULEGRAPH_TARGETS)\n+docs-jdk-api-graphs: $(JDK_API_GRAPHS_TARGETS)\n@@ -728,1 +802,1 @@\n-docs-javase-api-modulegraph: $(JAVASE_API_MODULEGRAPH_TARGETS)\n+docs-javase-api-graphs: $(JAVASE_API_GRAPHS_TARGETS)\n@@ -732,1 +806,1 @@\n-docs-reference-api-modulegraph: $(REFERENCE_API_MODULEGRAPH_TARGETS)\n+docs-reference-api-graphs: $(REFERENCE_API_GRAPHS_TARGETS)\n@@ -742,3 +816,3 @@\n-all: docs-jdk-api-javadoc docs-jdk-api-modulegraph docs-javase-api-javadoc \\\n-    docs-javase-api-modulegraph docs-reference-api-javadoc \\\n-    docs-reference-api-modulegraph docs-jdk-specs docs-jdk-index docs-zip \\\n+all: docs-jdk-api-javadoc docs-jdk-api-graphs docs-javase-api-javadoc \\\n+    docs-javase-api-graphs docs-reference-api-javadoc \\\n+    docs-reference-api-graphs docs-jdk-specs docs-jdk-index docs-zip \\\n@@ -747,3 +821,3 @@\n-.PHONY: default all docs-jdk-api-javadoc docs-jdk-api-modulegraph \\\n-    docs-javase-api-javadoc docs-javase-api-modulegraph \\\n-    docs-reference-api-javadoc docs-reference-api-modulegraph docs-jdk-specs \\\n+.PHONY: default all docs-jdk-api-javadoc docs-jdk-api-graphs \\\n+    docs-javase-api-javadoc docs-javase-api-graphs \\\n+    docs-reference-api-javadoc docs-reference-api-graphs docs-jdk-specs \\\n","filename":"make\/Docs.gmk","additions":116,"deletions":42,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -1081,11 +1081,0 @@\n-    var pandoc_version;\n-    if (input.build_cpu == \"aarch64\") {\n-        if (input.build_os == \"macosx\") {\n-            pandoc_version = \"2.14.0.2+1.0\";\n-        } else {\n-            pandoc_version = \"2.5+1.0\";\n-        }\n-    } else {\n-        pandoc_version = \"2.3.1+1.0\";\n-    }\n-\n@@ -1149,1 +1138,1 @@\n-            version: \"7\",\n+            version: \"7.1.1\",\n@@ -1151,1 +1140,1 @@\n-            file: \"bundles\/jtreg-7+1.zip\",\n+            file: \"bundles\/jtreg-7.1.1+1.zip\",\n@@ -1205,1 +1194,1 @@\n-            revision: pandoc_version,\n+            revision: \"2.19.2+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=20\n+DEFAULT_VERSION_FEATURE=21\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2023-03-21\n-DEFAULT_VERSION_CLASSFILE_MAJOR=64  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2023-09-19\n+DEFAULT_VERSION_CLASSFILE_MAJOR=65  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=20\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20 21\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=21\n","filename":"make\/conf\/version-numbers.conf","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -199,2 +199,0 @@\n-JVM_ExtentLocalCache\n-JVM_SetExtentLocalCache\n@@ -230,0 +228,6 @@\n+\n+# Scoped values\n+JVM_EnsureMaterializedForStackWalk_func\n+JVM_FindScopedValueBindings\n+JVM_ScopedValueCache\n+JVM_SetScopedValueCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3382,1 +3382,2 @@\n-        if (con < (address)(uintptr_t)os::vm_page_size()) {\n+        if (! __ is_valid_AArch64_address(con) ||\n+            con < (address)(uintptr_t)os::vm_page_size()) {\n@@ -3636,0 +3637,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ nop();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -3675,1 +3681,0 @@\n-    _masm.clear_inst_mark();\n@@ -3909,1 +3914,1 @@\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n@@ -14636,0 +14641,26 @@\n+instruct convF2HF_reg_reg(iRegINoSp dst, vRegF src, vRegF tmp) %{\n+  match(Set dst (ConvF2HF src));\n+  format %{ \"fcvt $tmp, $src\\t# convert single to half precision\\n\\t\"\n+            \"smov $dst, $tmp\\t# move result from $tmp to $dst\"\n+  %}\n+  effect(TEMP tmp);\n+  ins_encode %{\n+      __ fcvtsh($tmp$$FloatRegister, $src$$FloatRegister);\n+      __ smov($dst$$Register, $tmp$$FloatRegister, __ H, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convHF2F_reg_reg(vRegF dst, iRegINoSp src, vRegF tmp) %{\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"mov $tmp, $src\\t# move source from $src to $tmp\\n\\t\"\n+            \"fcvt $dst, $tmp\\t# convert half to single precision\"\n+  %}\n+  effect(TEMP tmp);\n+  ins_encode %{\n+      __ mov($tmp$$FloatRegister, __ H, 0, $src$$Register);\n+      __ fcvths($dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -104,0 +104,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jvm.h\"\n@@ -34,0 +33,2 @@\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n@@ -43,2 +44,1 @@\n-#include \"compiler\/compileTask.hpp\"\n-#include \"compiler\/disassembler.hpp\"\n+#include \"jvm.h\"\n@@ -1729,2 +1729,2 @@\n-  ldrw(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n-  andr(temp_reg, temp_reg, InstanceKlass::misc_flag_is_empty_inline_type());\n+  ldrw(temp_reg, Address(klass, InstanceKlass::misc_status_offset()));\n+  andr(temp_reg, temp_reg, InstanceKlassMiscStatus::is_empty_inline_type_value());\n@@ -4142,1 +4142,5 @@\n-  _masm->cbzw(rscratch1, _label);\n+  if (value) {\n+    _masm->cbnzw(rscratch1, _label);\n+  } else {\n+    _masm->cbzw(rscratch1, _label);\n+  }\n@@ -4562,1 +4566,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -4575,1 +4579,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-    code_section()->relocate(inst_mark(), a.rspec());\n@@ -1242,1 +1241,1 @@\n-  \/\/ Check if branches to the the non nmethod section require a far jump\n+  \/\/ Check if branches to the non nmethod section require a far jump\n@@ -1534,0 +1533,7 @@\n+  \/\/ ChaCha20 functions support block\n+  void cc20_quarter_round(FloatRegister aVec, FloatRegister bVec,\n+          FloatRegister cVec, FloatRegister dVec, FloatRegister scratch,\n+          FloatRegister tbl);\n+  void cc20_shift_lane_org(FloatRegister bVec, FloatRegister cVec,\n+          FloatRegister dVec, bool colToDiag);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1291,1 +1291,0 @@\n-  ContinuationEntry::setup_oopmap(map);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-#define TIMES_OOP Address::sxtw(exact_log2(UseCompressedOops ? 4 : 8))\n@@ -640,2 +639,0 @@\n-  void array_overlap_test(Label& L_no_overlap, Address::sxtw sf) { __ b(L_no_overlap); }\n-\n@@ -1829,1 +1826,1 @@\n-      array_overlap_test(L, TIMES_OOP);\n+      __ b(L);                  \/\/ conjoint check not yet implemented\n@@ -3853,2 +3850,2 @@\n-  \/\/   c_rarg1   - byte[]   SHA.state\n-  \/\/   c_rarg2   - int     digest_length\n+  \/\/   c_rarg1   - byte[]  SHA.state\n+  \/\/   c_rarg2   - int     block_size\n@@ -3876,1 +3873,1 @@\n-    Register digest_length = c_rarg2;\n+    Register block_size    = c_rarg2;\n@@ -3881,1 +3878,1 @@\n-    Label sha3_512, sha3_384_or_224, sha3_256;\n+    Label sha3_512_or_sha3_384, shake128;\n@@ -3917,2 +3914,2 @@\n-    \/\/ digest_length == 64, SHA3-512\n-    __ tbnz(digest_length, 6, sha3_512);\n+    \/\/ block_size == 72, SHA3-512; block_size == 104, SHA3-384\n+    __ tbz(block_size, 7, sha3_512_or_sha3_384);\n@@ -3921,1 +3918,1 @@\n-    __ ld1(v29, v30, __ T8B, __ post(buf, 16));\n+    __ ld1(v29, v30, v31, __ T8B, __ post(buf, 24));\n@@ -3928,0 +3925,1 @@\n+    __ eor(v13, __ T8B, v13, v31);\n@@ -3929,10 +3927,4 @@\n-    \/\/ digest_length == 28, SHA3-224;  digest_length == 48, SHA3-384\n-    __ tbnz(digest_length, 4, sha3_384_or_224);\n-\n-    \/\/ SHA3-256\n-    __ ld1(v25, v26, v27, v28, __ T8B, __ post(buf, 32));\n-    __ eor(v13, __ T8B, v13, v25);\n-    __ eor(v14, __ T8B, v14, v26);\n-    __ eor(v15, __ T8B, v15, v27);\n-    __ eor(v16, __ T8B, v16, v28);\n-    __ b(rounds24_loop);\n+    __ ld1(v25, v26, v27,  __ T8B, __ post(buf, 24));\n+    __ eor(v14, __ T8B, v14, v25);\n+    __ eor(v15, __ T8B, v15, v26);\n+    __ eor(v16, __ T8B, v16, v27);\n@@ -3940,2 +3932,3 @@\n-    __ BIND(sha3_384_or_224);\n-    __ tbz(digest_length, 2, rounds24_loop); \/\/ bit 2 cleared? SHA-384\n+    \/\/ block_size == 136, bit4 == 0 and bit5 == 0, SHA3-256 or SHAKE256\n+    __ andw(c_rarg5, block_size, 48);\n+    __ cbzw(c_rarg5, rounds24_loop);\n@@ -3943,8 +3936,4 @@\n-    \/\/ SHA3-224\n-    __ ld1(v25, v26, v27, v28, __ T8B, __ post(buf, 32));\n-    __ ld1(v29, __ T8B, __ post(buf, 8));\n-    __ eor(v13, __ T8B, v13, v25);\n-    __ eor(v14, __ T8B, v14, v26);\n-    __ eor(v15, __ T8B, v15, v27);\n-    __ eor(v16, __ T8B, v16, v28);\n-    __ eor(v17, __ T8B, v17, v29);\n+    __ tbnz(block_size, 5, shake128);\n+    \/\/ block_size == 144, bit5 == 0, SHA3-244\n+    __ ldrd(v28, __ post(buf, 8));\n+    __ eor(v17, __ T8B, v17, v28);\n@@ -3953,1 +3942,9 @@\n-    __ BIND(sha3_512);\n+    __ BIND(shake128);\n+    __ ld1(v28, v29, v30, v31, __ T8B, __ post(buf, 32));\n+    __ eor(v17, __ T8B, v17, v28);\n+    __ eor(v18, __ T8B, v18, v29);\n+    __ eor(v19, __ T8B, v19, v30);\n+    __ eor(v20, __ T8B, v20, v31);\n+    __ b(rounds24_loop); \/\/ block_size == 168, SHAKE128\n+\n+    __ BIND(sha3_512_or_sha3_384);\n@@ -3957,0 +3954,8 @@\n+    __ tbz(block_size, 5, rounds24_loop); \/\/ SHA3-512\n+\n+    \/\/ SHA3-384\n+    __ ld1(v27, v28, v29, v30, __ T8B, __ post(buf, 32));\n+    __ eor(v9,  __ T8B, v9,  v27);\n+    __ eor(v10, __ T8B, v10, v28);\n+    __ eor(v11, __ T8B, v11, v29);\n+    __ eor(v12, __ T8B, v12, v30);\n@@ -4041,4 +4046,1 @@\n-      \/\/ block_size =  200 - 2 * digest_length, ofs += block_size\n-      __ add(ofs, ofs, 200);\n-      __ sub(ofs, ofs, digest_length, Assembler::LSL, 1);\n-\n+      __ add(ofs, ofs, block_size);\n@@ -4108,0 +4110,126 @@\n+  \/\/ ChaCha20 block function.  This version parallelizes by loading\n+  \/\/ individual 32-bit state elements into vectors for four blocks\n+  \/\/ (e.g. all four blocks' worth of state[0] in one register, etc.)\n+  \/\/\n+  \/\/ state (int[16]) = c_rarg0\n+  \/\/ keystream (byte[1024]) = c_rarg1\n+  \/\/ return - number of bytes of keystream (always 256)\n+  address generate_chacha20Block_blockpar() {\n+    Label L_twoRounds, L_cc20_const;\n+    \/\/ The constant data is broken into two 128-bit segments to be loaded\n+    \/\/ onto FloatRegisters.  The first 128 bits are a counter add overlay\n+    \/\/ that adds +0\/+1\/+2\/+3 to the vector holding replicated state[12].\n+    \/\/ The second 128-bits is a table constant used for 8-bit left rotations.\n+    __ BIND(L_cc20_const);\n+    __ emit_int64(0x0000000100000000UL);\n+    __ emit_int64(0x0000000300000002UL);\n+    __ emit_int64(0x0605040702010003UL);\n+    __ emit_int64(0x0E0D0C0F0A09080BUL);\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    int i, j;\n+    const Register state = c_rarg0;\n+    const Register keystream = c_rarg1;\n+    const Register loopCtr = r10;\n+    const Register tmpAddr = r11;\n+\n+    const FloatRegister stateFirst = v0;\n+    const FloatRegister stateSecond = v1;\n+    const FloatRegister stateThird = v2;\n+    const FloatRegister stateFourth = v3;\n+    const FloatRegister origCtrState = v28;\n+    const FloatRegister scratch = v29;\n+    const FloatRegister lrot8Tbl = v30;\n+\n+    \/\/ Organize SIMD registers in an array that facilitates\n+    \/\/ putting repetitive opcodes into loop structures.  It is\n+    \/\/ important that each grouping of 4 registers is monotonically\n+    \/\/ increasing to support the requirements of multi-register\n+    \/\/ instructions (e.g. ld4r, st4, etc.)\n+    const FloatRegister workSt[16] = {\n+         v4,  v5,  v6,  v7, v16, v17, v18, v19,\n+        v20, v21, v22, v23, v24, v25, v26, v27\n+    };\n+\n+    \/\/ Load from memory and interlace across 16 SIMD registers,\n+    \/\/ With each word from memory being broadcast to all lanes of\n+    \/\/ each successive SIMD register.\n+    \/\/      Addr(0) -> All lanes in workSt[i]\n+    \/\/      Addr(4) -> All lanes workSt[i + 1], etc.\n+    __ mov(tmpAddr, state);\n+    for (i = 0; i < 16; i += 4) {\n+      __ ld4r(workSt[i], workSt[i + 1], workSt[i + 2], workSt[i + 3], __ T4S,\n+          __ post(tmpAddr, 16));\n+    }\n+\n+    \/\/ Pull in constant data.  The first 16 bytes are the add overlay\n+    \/\/ which is applied to the vector holding the counter (state[12]).\n+    \/\/ The second 16 bytes is the index register for the 8-bit left\n+    \/\/ rotation tbl instruction.\n+    __ adr(tmpAddr, L_cc20_const);\n+    __ ldpq(origCtrState, lrot8Tbl, Address(tmpAddr));\n+    __ addv(workSt[12], __ T4S, workSt[12], origCtrState);\n+\n+    \/\/ Set up the 10 iteration loop and perform all 8 quarter round ops\n+    __ mov(loopCtr, 10);\n+    __ BIND(L_twoRounds);\n+\n+    __ cc20_quarter_round(workSt[0], workSt[4], workSt[8], workSt[12],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[1], workSt[5], workSt[9], workSt[13],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[2], workSt[6], workSt[10], workSt[14],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[3], workSt[7], workSt[11], workSt[15],\n+        scratch, lrot8Tbl);\n+\n+    __ cc20_quarter_round(workSt[0], workSt[5], workSt[10], workSt[15],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[1], workSt[6], workSt[11], workSt[12],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[2], workSt[7], workSt[8], workSt[13],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[3], workSt[4], workSt[9], workSt[14],\n+        scratch, lrot8Tbl);\n+\n+    \/\/ Decrement and iterate\n+    __ sub(loopCtr, loopCtr, 1);\n+    __ cbnz(loopCtr, L_twoRounds);\n+\n+    __ mov(tmpAddr, state);\n+\n+    \/\/ Add the starting state back to the post-loop keystream\n+    \/\/ state.  We read\/interlace the state array from memory into\n+    \/\/ 4 registers similar to what we did in the beginning.  Then\n+    \/\/ add the counter overlay onto workSt[12] at the end.\n+    for (i = 0; i < 16; i += 4) {\n+      __ ld4r(stateFirst, stateSecond, stateThird, stateFourth, __ T4S,\n+          __ post(tmpAddr, 16));\n+      __ addv(workSt[i], __ T4S, workSt[i], stateFirst);\n+      __ addv(workSt[i + 1], __ T4S, workSt[i + 1], stateSecond);\n+      __ addv(workSt[i + 2], __ T4S, workSt[i + 2], stateThird);\n+      __ addv(workSt[i + 3], __ T4S, workSt[i + 3], stateFourth);\n+    }\n+    __ addv(workSt[12], __ T4S, workSt[12], origCtrState);    \/\/ Add ctr mask\n+\n+    \/\/ Write to key stream, storing the same element out of workSt[0..15]\n+    \/\/ to consecutive 4-byte offsets in the key stream buffer, then repeating\n+    \/\/ for the next element position.\n+    for (i = 0; i < 4; i++) {\n+      for (j = 0; j < 16; j += 4) {\n+        __ st4(workSt[j], workSt[j + 1], workSt[j + 2], workSt[j + 3], __ S, i,\n+            __ post(keystream, 16));\n+      }\n+    }\n+\n+    __ mov(r0, 256);             \/\/ Return length of output keystream\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8081,0 +8209,4 @@\n+    if (UseChaCha20Intrinsics) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block_blockpar();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":168,"deletions":36,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-void TemplateTable::ldc(bool wide)\n+void TemplateTable::ldc(LdcType type)\n@@ -318,1 +318,1 @@\n-  if (wide) {\n+  if (is_ldc_wide(type)) {\n@@ -348,1 +348,1 @@\n-  __ mov(c_rarg1, wide);\n+  __ mov(c_rarg1, is_ldc_wide(type) ? 1 : 0);\n@@ -381,1 +381,1 @@\n-void TemplateTable::fast_aldc(bool wide)\n+void TemplateTable::fast_aldc(LdcType type)\n@@ -389,1 +389,1 @@\n-  int index_size = wide ? sizeof(u2) : sizeof(u1);\n+  int index_size = is_ldc_wide(type) ? sizeof(u2) : sizeof(u1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -580,1 +580,1 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : NULL;\n+      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -604,1 +604,1 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : NULL;\n+      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -668,0 +668,1 @@\n+  __ post_call_nop();\n@@ -695,0 +696,1 @@\n+  __ post_call_nop();\n@@ -2879,0 +2881,1 @@\n+    __ post_call_nop();\n@@ -2886,0 +2889,1 @@\n+  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-define_pd_global(bool,  VMContinuations, false);\n+define_pd_global(bool,  VMContinuations, true);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -897,0 +897,1 @@\n+  pop_cont_fastpath();\n@@ -930,1 +931,1 @@\n-    Label done;\n+    Label count_locking, done;\n@@ -975,1 +976,1 @@\n-    b(done);\n+    b(count_locking);\n@@ -997,1 +998,1 @@\n-    b(done);\n+    b(count_locking);\n@@ -1007,0 +1008,1 @@\n+    b(done);\n@@ -1009,0 +1011,2 @@\n+    bind(count_locking);\n+    inc_held_monitor_count(current_header \/*tmp*\/);\n@@ -1098,0 +1102,1 @@\n+    dec_held_monitor_count(current_header \/*tmp*\/);\n@@ -1772,1 +1777,1 @@\n-      add(R28_mdx, off_to_args, R28_mdx);\n+      addi(R28_mdx, R28_mdx, off_to_args);\n@@ -2167,1 +2172,1 @@\n-void InterpreterMacroAssembler::restore_interpreter_state(Register scratch, bool bcp_and_mdx_only) {\n+void InterpreterMacroAssembler::restore_interpreter_state(Register scratch, bool bcp_and_mdx_only, bool restore_top_frame_sp) {\n@@ -2169,0 +2174,9 @@\n+  if (restore_top_frame_sp) {\n+    \/\/ After thawing the top frame of a continuation we reach here with frame::abi_minframe.\n+    \/\/ therefore we have to restore top_frame_sp before the assertion below.\n+    assert(!bcp_and_mdx_only, \"chose other registers\");\n+    Register tfsp = R18_locals;\n+    Register scratch2 = R26_monitor;\n+    ld(tfsp, _ijava_state_neg(top_frame_sp), scratch);\n+    resize_frame_absolute(tfsp, scratch2, R0);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3658,1 +3658,1 @@\n-    __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));\n+    __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,0 @@\n-  jcc(Assembler::zero, done);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -736,5 +736,0 @@\n-  \/\/ DONE_LABEL is a hot target - we'd really like to place it at the\n-  \/\/ start of cache line by padding with NOPs.\n-  \/\/ See the AMD and Intel software optimization manuals for the\n-  \/\/ most efficient \"long\" NOP encodings.\n-  \/\/ Unfortunately none of our alignment mechanisms suffice.\n@@ -802,1 +797,1 @@\n-  Label DONE_LABEL, Stacked, CheckSucc, COUNT, NO_COUNT;\n+  Label DONE_LABEL, Stacked, COUNT, NO_COUNT;\n@@ -861,2 +856,0 @@\n-  get_thread (boxReg);\n-\n@@ -872,1 +865,1 @@\n-  jccb  (Assembler::notZero, CheckSucc);\n+  jccb  (Assembler::notZero, DONE_LABEL);\n@@ -875,18 +868,0 @@\n-\n-  bind (Stacked);\n-  \/\/ It's not inflated and it's not recursively stack-locked.\n-  \/\/ It must be stack-locked.\n-  \/\/ Try to reset the header to displaced header.\n-  \/\/ The \"box\" value on the stack is stable, so we can reload\n-  \/\/ and be assured we observe the same value as above.\n-  movptr(tmpReg, Address(boxReg, 0));\n-  lock();\n-  cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n-  \/\/ Intention fall-thru into DONE_LABEL\n-\n-  \/\/ DONE_LABEL is a hot target - we'd really like to place it at the\n-  \/\/ start of cache line by padding with NOPs.\n-  \/\/ See the AMD and Intel software optimization manuals for the\n-  \/\/ most efficient \"long\" NOP encodings.\n-  \/\/ Unfortunately none of our alignment mechanisms suffice.\n-  bind (CheckSucc);\n@@ -895,1 +870,1 @@\n-  Label LNotRecursive, LSuccess, LGoSlowPath;\n+  Label CheckSucc, LNotRecursive, LSuccess, LGoSlowPath;\n@@ -968,0 +943,1 @@\n+#endif\n@@ -973,0 +949,1 @@\n+    \/\/ Intentional fall-thru into DONE_LABEL\n@@ -974,1 +951,0 @@\n-#endif\n@@ -5311,1 +5287,1 @@\n-    vpandq(dst, xtmp2, src, vec_enc);\n+    evpandq(dst, xtmp2, src, vec_enc);\n@@ -5322,1 +5298,1 @@\n-    vporq(xtmp2, dst, xtmp2, vec_enc);\n+    evporq(xtmp2, dst, xtmp2, vec_enc);\n@@ -5377,1 +5353,1 @@\n-  vpandq(dst, xtmp1, src, vec_enc);\n+  evpandq(dst, xtmp1, src, vec_enc);\n@@ -5381,1 +5357,1 @@\n-  vporq(dst, dst, xtmp1, vec_enc);\n+  evporq(dst, dst, xtmp1, vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -100,1 +100,9 @@\n-    \/\/ compiled frame alignment, in bytes\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n+    \/\/ size, in words, of frame metadata at the frame top that needs\n+    \/\/ to be reserved for callee functions in the runtime\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  product(intx, UseSSE, 99,                                                 \\\n+  product(int, UseSSE, 4,                                                   \\\n@@ -114,1 +114,1 @@\n-          range(0, 99)                                                      \\\n+          range(0, 4)                                                       \\\n@@ -116,1 +116,1 @@\n-  product(intx, UseAVX, 3,                                                  \\\n+  product(int, UseAVX, 3,                                                   \\\n@@ -118,1 +118,1 @@\n-          range(0, 99)                                                      \\\n+          range(0, 3)                                                       \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -32,0 +31,1 @@\n+#include \"crc32c.h\"\n@@ -38,0 +38,1 @@\n+#include \"jvm.h\"\n@@ -58,1 +59,0 @@\n-#include \"crc32c.h\"\n@@ -1226,0 +1226,13 @@\n+#ifdef _LP64\n+void MacroAssembler::andq(Register dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    andq(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    andq(dst, Address(rscratch, 0));\n+  }\n+}\n+#endif\n+\n@@ -2897,2 +2910,2 @@\n-  movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n-  testl(temp_reg, InstanceKlass::misc_flag_is_empty_inline_type());\n+  movl(temp_reg, Address(klass, InstanceKlass::misc_status_offset()));\n+  testl(temp_reg, InstanceKlassMiscStatus::is_empty_inline_type_value());\n@@ -5433,1 +5446,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -5445,1 +5458,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -9881,0 +9894,34 @@\n+\n+void MacroAssembler::evpandq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    evpandq(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    evpandq(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+void MacroAssembler::evporq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    evporq(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    evporq(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+void MacroAssembler::vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, AddressLiteral src3, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src3), \"missing\");\n+\n+  if (reachable(src3)) {\n+    vpternlogq(dst, imm8, src2, as_Address(src3), vector_len);\n+  } else {\n+    lea(rscratch, src3);\n+    vpternlogq(dst, imm8, src2, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -793,0 +793,5 @@\n+#ifdef _LP64\n+  using Assembler::andq;\n+  void andq(Register dst, AddressLiteral src, Register rscratch = noreg);\n+#endif\n+\n@@ -1817,0 +1822,9 @@\n+  using Assembler::evpandq;\n+  void evpandq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::evporq;\n+  void evporq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::vpternlogq;\n+  void vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, AddressLiteral src3, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -33,0 +32,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1575,1 +1575,0 @@\n-  ContinuationEntry::setup_oopmap(map);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2540,1 +2540,1 @@\n-    __ vporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n+    __ evporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n@@ -3356,1 +3356,1 @@\n-      StubRoutines::_dtan = generate_libmTan();\n+      StubRoutines::_dtan = generate_libmTan(); \/\/ from stubGenerator_x86_64_tan.cpp\n@@ -3359,1 +3359,1 @@\n-      StubRoutines::_dexp = generate_libmExp();\n+      StubRoutines::_dexp = generate_libmExp(); \/\/ from stubGenerator_x86_64_exp.cpp\n@@ -3362,1 +3362,1 @@\n-      StubRoutines::_dpow = generate_libmPow();\n+      StubRoutines::_dpow = generate_libmPow(); \/\/ from stubGenerator_x86_64_pow.cpp\n@@ -3365,1 +3365,1 @@\n-      StubRoutines::_dlog = generate_libmLog();\n+      StubRoutines::_dlog = generate_libmLog(); \/\/ from stubGenerator_x86_64_log.cpp\n@@ -3368,1 +3368,1 @@\n-      StubRoutines::_dlog10 = generate_libmLog10();\n+      StubRoutines::_dlog10 = generate_libmLog10(); \/\/ from stubGenerator_x86_64_log.cpp\n@@ -3740,0 +3740,4 @@\n+  if (UsePolyIntrinsics) {\n+    StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+  }\n+\n@@ -3750,0 +3754,2 @@\n+\n+  generate_libm_stubs();\n@@ -3978,0 +3984,2 @@\n+  generate_chacha_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -390,0 +390,30 @@\n+  \/\/ ChaCha20 stubs and helper functions\n+  void generate_chacha_stubs();\n+  address generate_chacha20Block_avx();\n+  address generate_chacha20Block_avx512();\n+  void cc20_quarter_round_avx(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, XMMRegister scratch,\n+    XMMRegister lrot8, XMMRegister lrot16, int vector_len);\n+  void cc20_shift_lane_org(XMMRegister bVec, XMMRegister cVec,\n+    XMMRegister dVec, int vector_len, bool colToDiag);\n+  void cc20_keystream_collate_avx512(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, Register baseAddr, int baseOffset);\n+\n+  \/\/ Poly1305 multiblock using IFMA instructions\n+  address generate_poly1305_processBlocks();\n+  void poly1305_process_blocks_avx512(const Register input, const Register length,\n+                                      const Register A0, const Register A1, const Register A2,\n+                                      const Register R0, const Register R1, const Register C1);\n+  void poly1305_multiply_scalar(const Register a0, const Register a1, const Register a2,\n+                                const Register r0, const Register r1, const Register c1, bool only128,\n+                                const Register t0, const Register t1, const Register t2,\n+                                const Register mulql, const Register mulqh);\n+  void poly1305_multiply8_avx512(const XMMRegister A0, const XMMRegister A1, const XMMRegister A2,\n+                                 const XMMRegister R0, const XMMRegister R1, const XMMRegister R2, const XMMRegister R1P, const XMMRegister R2P,\n+                                 const XMMRegister P0L, const XMMRegister P0H, const XMMRegister P1L, const XMMRegister P1H, const XMMRegister P2L, const XMMRegister P2H,\n+                                 const XMMRegister TMP, const Register rscratch);\n+  void poly1305_limbs(const Register limbs, const Register a0, const Register a1, const Register a2, const Register t0, const Register t1);\n+  void poly1305_limbs_out(const Register a0, const Register a1, const Register a2, const Register limbs, const Register t0, const Register t1);\n+  void poly1305_limbs_avx512(const XMMRegister D0, const XMMRegister D1,\n+                             const XMMRegister L0, const XMMRegister L1, const XMMRegister L2, bool padMSG,\n+                             const XMMRegister TMP, const Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-void TemplateTable::ldc(bool wide) {\n+void TemplateTable::ldc(LdcType type) {\n@@ -360,1 +360,1 @@\n-  if (wide) {\n+  if (is_ldc_wide(type)) {\n@@ -389,1 +389,1 @@\n-  __ movl(rarg, wide);\n+  __ movl(rarg, is_ldc_wide(type) ? 1 : 0);\n@@ -421,1 +421,1 @@\n-void TemplateTable::fast_aldc(bool wide) {\n+void TemplateTable::fast_aldc(LdcType type) {\n@@ -427,1 +427,1 @@\n-  int index_size = wide ? sizeof(u2) : sizeof(u1);\n+  int index_size = is_ldc_wide(type) ? sizeof(u2) : sizeof(u1);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -31,0 +30,1 @@\n+#include \"jvm.h\"\n@@ -407,2 +407,2 @@\n-    intx saved_useavx = UseAVX;\n-    intx saved_usesse = UseSSE;\n+    int saved_useavx = UseAVX;\n+    int saved_usesse = UseSSE;\n@@ -857,3 +857,0 @@\n-  \/\/ If the OS doesn't support SSE, we can't use this feature even if the HW does\n-  if (!os::supports_sse())\n-    _features &= ~(CPU_SSE|CPU_SSE2|CPU_SSE3|CPU_SSSE3|CPU_SSE4A|CPU_SSE4_1|CPU_SSE4_2);\n@@ -883,0 +880,24 @@\n+  \/\/ UseSSE is set to the smaller of what hardware supports and what\n+  \/\/ the command line requires.  I.e., you cannot set UseSSE to 2 on\n+  \/\/ older Pentiums which do not support it.\n+  int use_sse_limit = 0;\n+  if (UseSSE > 0) {\n+    if (UseSSE > 3 && supports_sse4_1()) {\n+      use_sse_limit = 4;\n+    } else if (UseSSE > 2 && supports_sse3()) {\n+      use_sse_limit = 3;\n+    } else if (UseSSE > 1 && supports_sse2()) {\n+      use_sse_limit = 2;\n+    } else if (UseSSE > 0 && supports_sse()) {\n+      use_sse_limit = 1;\n+    } else {\n+      use_sse_limit = 0;\n+    }\n+  }\n+  if (FLAG_IS_DEFAULT(UseSSE)) {\n+    FLAG_SET_DEFAULT(UseSSE, use_sse_limit);\n+  } else if (UseSSE > use_sse_limit) {\n+    warning(\"UseSSE=%d is not supported on this CPU, setting it to UseSSE=%d\", UseSSE, use_sse_limit);\n+    FLAG_SET_DEFAULT(UseSSE, use_sse_limit);\n+  }\n+\n@@ -886,1 +907,4 @@\n-    if (UseAVX > 2 && supports_evex()) {\n+    if (UseSSE < 4) {\n+      \/\/ Don't use AVX if SSE is unavailable or has been disabled.\n+      use_avx_limit = 0;\n+    } else if (UseAVX > 2 && supports_evex()) {\n@@ -905,1 +929,5 @@\n-    warning(\"UseAVX=%d is not supported on this CPU, setting it to UseAVX=%d\", (int) UseAVX, use_avx_limit);\n+    if (UseSSE < 4) {\n+      warning(\"UseAVX=%d requires UseSSE=4, setting it to UseAVX=0\", UseAVX);\n+    } else {\n+      warning(\"UseAVX=%d is not supported on this CPU, setting it to UseAVX=%d\", UseAVX, use_avx_limit);\n+    }\n@@ -907,3 +935,0 @@\n-  } else if (UseAVX < 0) {\n-    warning(\"UseAVX=%d is not valid, setting it to UseAVX=0\", (int) UseAVX);\n-    FLAG_SET_DEFAULT(UseAVX, 0);\n@@ -925,0 +950,1 @@\n+    _features &= ~CPU_AVX512_IFMA;\n@@ -933,0 +959,1 @@\n+    _features &= ~CPU_F16C;\n@@ -956,0 +983,1 @@\n+      _features &= ~CPU_AVX512_IFMA;\n@@ -965,1 +993,1 @@\n-  char buf[512];\n+  char buf[1024];\n@@ -976,27 +1004,0 @@\n-  \/\/ UseSSE is set to the smaller of what hardware supports and what\n-  \/\/ the command line requires.  I.e., you cannot set UseSSE to 2 on\n-  \/\/ older Pentiums which do not support it.\n-  int use_sse_limit = 0;\n-  if (UseSSE > 0) {\n-    if (UseSSE > 3 && supports_sse4_1()) {\n-      use_sse_limit = 4;\n-    } else if (UseSSE > 2 && supports_sse3()) {\n-      use_sse_limit = 3;\n-    } else if (UseSSE > 1 && supports_sse2()) {\n-      use_sse_limit = 2;\n-    } else if (UseSSE > 0 && supports_sse()) {\n-      use_sse_limit = 1;\n-    } else {\n-      use_sse_limit = 0;\n-    }\n-  }\n-  if (FLAG_IS_DEFAULT(UseSSE)) {\n-    FLAG_SET_DEFAULT(UseSSE, use_sse_limit);\n-  } else if (UseSSE > use_sse_limit) {\n-    warning(\"UseSSE=%d is not supported on this CPU, setting it to UseSSE=%d\", (int) UseSSE, use_sse_limit);\n-    FLAG_SET_DEFAULT(UseSSE, use_sse_limit);\n-  } else if (UseSSE < 0) {\n-    warning(\"UseSSE=%d is not valid, setting it to UseSSE=0\", (int) UseSSE);\n-    FLAG_SET_DEFAULT(UseSSE, 0);\n-  }\n-\n@@ -1125,0 +1126,16 @@\n+  \/\/ ChaCha20 Intrinsics\n+  \/\/ As long as the system supports AVX as a baseline we can do a\n+  \/\/ SIMD-enabled block function.  StubGenerator makes the determination\n+  \/\/ based on the VM capabilities whether to use an AVX2 or AVX512-enabled\n+  \/\/ version.\n+  if (UseAVX >= 1) {\n+      if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+          UseChaCha20Intrinsics = true;\n+      }\n+  } else if (UseChaCha20Intrinsics) {\n+      if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+          warning(\"ChaCha20 intrinsic requires AVX instructions\");\n+      }\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n+\n@@ -1335,0 +1352,12 @@\n+#ifdef _LP64\n+  if (supports_avx512ifma() && supports_avx512vlbw() && MaxVectorSize >= 64) {\n+    if (FLAG_IS_DEFAULT(UsePolyIntrinsics)) {\n+      FLAG_SET_DEFAULT(UsePolyIntrinsics, true);\n+    }\n+  } else\n+#endif\n+  if (UsePolyIntrinsics) {\n+    warning(\"Intrinsics for Poly1305 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UsePolyIntrinsics, false);\n+  }\n+\n@@ -1862,1 +1891,1 @@\n-    log->print(\"UseSSE=%d\", (int) UseSSE);\n+    log->print(\"UseSSE=%d\", UseSSE);\n@@ -1864,1 +1893,1 @@\n-      log->print(\"  UseAVX=%d\", (int) UseAVX);\n+      log->print(\"  UseAVX=%d\", UseAVX);\n@@ -2899,0 +2928,2 @@\n+      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512ifma != 0)\n+        result |= CPU_AVX512_IFMA;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":72,"deletions":41,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -1690,0 +1690,6 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex()) {\n+        return false;\n+      }\n+      break;\n@@ -1904,0 +1910,8 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() &&\n+         ((!VM_Version::supports_evex() ||\n+         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+        return false;\n+      }\n+      break;\n@@ -3712,0 +3726,20 @@\n+instruct vconvF2HF(vec dst, vec src) %{\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"vector_conv_F2HF $dst $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvF2HF_mem_reg(memory mem, vec src) %{\n+  match(Set mem (StoreVector mem (VectorCastF2HF src)));\n+  format %{ \"vcvtps2ph $mem,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($mem$$Address, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -3722,0 +3756,21 @@\n+instruct vconvHF2F_reg_mem(vec dst, memory mem) %{\n+  match(Set dst (VectorCastHF2F (LoadVector mem)));\n+  format %{ \"vcvtph2ps $dst,$mem\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvHF2F(vec dst, vec src) %{\n+  match(Set dst (VectorCastHF2F src));\n+  ins_cost(125);\n+  format %{ \"vector_conv_HF2F $dst,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8914,6 +8969,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n@@ -8950,12 +8999,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n-      if (VM_Version::supports_avx512vl()) {\n-        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(VM_Version::supports_avx2(), \"\");\n-        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      }\n-    }\n@@ -8978,1 +9015,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -8981,6 +9017,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountTrailingZerosV\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (bt == T_LONG && rbt == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n@@ -9032,1 +9062,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9035,8 +9064,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (bt == T_LONG && rbt == T_INT) {\n-      assert(VM_Version::supports_avx2(), \"\");\n-      __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-    }\n@@ -9447,1 +9468,0 @@\n-     BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9450,6 +9470,0 @@\n-     \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n-     \/\/ should be succeeded by its corresponding vector IR and following\n-     \/\/ special handling should be removed.\n-     if (rbt == T_INT && bt == T_LONG) {\n-       __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n@@ -9530,1 +9544,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9533,6 +9546,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (rbt == T_INT && bt == T_LONG) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":55,"deletions":48,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2172,1 +2172,0 @@\n-    $$$emit8$primary;\n@@ -2175,0 +2174,1 @@\n+      $$$emit8$primary;\n@@ -2178,0 +2178,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ addr_nop_5();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -2179,0 +2184,1 @@\n+      $$$emit8$primary;\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4227,1 +4227,1 @@\n-    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\",\n+    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\", \"VectorCastF2HF\", \"VectorCastHF2F\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -266,2 +267,1 @@\n-  static int alignment(int section);\n-  int alignment() { return alignment(_index); }\n+  int alignment() const;\n@@ -272,5 +272,1 @@\n-  static csize_t align_at_start(csize_t off, int section) {\n-    return (csize_t) align_up(off, alignment(section));\n-  }\n-\n-    return align_at_start(off, _index);\n+    return (csize_t) align_up(off, alignment());\n@@ -394,1 +390,1 @@\n-  void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }\n+  void* operator new(size_t size) throw() { return resource_allocate_bytes(size); }\n@@ -441,0 +437,2 @@\n+  int          _const_section_alignment;\n+\n@@ -466,0 +464,4 @@\n+    \/\/ Default is to align on 8 bytes. A compiler can change this\n+    \/\/ if larger alignment (e.g., 32-byte vector masks) is required.\n+    _const_section_alignment = (int) sizeof(jdouble);\n+\n@@ -719,0 +721,4 @@\n+  void set_const_section_alignment(int align) {\n+    _const_section_alignment = align_up(align, HeapWordSize);\n+  }\n+\n@@ -756,15 +762,0 @@\n-inline int CodeSection::alignment(int section) {\n-  if (section == CodeBuffer::SECT_CONSTS) {\n-    return (int) sizeof(jdouble);\n-  }\n-  if (section == CodeBuffer::SECT_INSTS) {\n-    return (int) CodeEntryAlignment;\n-  }\n-  if (section == CodeBuffer::SECT_STUBS) {\n-    \/\/ CodeBuffer installer expects sections to be HeapWordSize aligned\n-    return HeapWordSize;\n-  }\n-  ShouldNotReachHere();\n-  return 0;\n-}\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1451,2 +1451,2 @@\n-void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n+void LIRGenerator::do_scopedValueCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::scopedValueCache_offset());\n@@ -3463,1 +3463,1 @@\n-  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n+  case vmIntrinsics::_scopedValueCache: do_scopedValueCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  void do_extentLocalCache(Intrinsic* x);\n+  void do_scopedValueCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2514,6 +2514,6 @@\n-ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);\n-ConstantIntValue*      LinearScan::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);\n-ConstantIntValue*      LinearScan::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);\n-ConstantIntValue*      LinearScan::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);\n-ConstantIntValue*      LinearScan::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);\n-LocationValue*         _illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());\n+ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (mtCompiler) ConstantOopWriteValue(NULL);\n+ConstantIntValue*      LinearScan::_int_m1_scope_value = new (mtCompiler) ConstantIntValue(-1);\n+ConstantIntValue*      LinearScan::_int_0_scope_value =  new (mtCompiler) ConstantIntValue((jint)0);\n+ConstantIntValue*      LinearScan::_int_1_scope_value =  new (mtCompiler) ConstantIntValue(1);\n+ConstantIntValue*      LinearScan::_int_2_scope_value =  new (mtCompiler) ConstantIntValue(2);\n+LocationValue*         _illegal_value = new (mtCompiler) LocationValue(Location());\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -895,0 +895,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-ArchiveBuilder::SourceObjList::SourceObjList() : _ptrmap(16 * K) {\n+ArchiveBuilder::SourceObjList::SourceObjList() : _ptrmap(16 * K, mtClassShared) {\n@@ -63,1 +63,1 @@\n-  _objs = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<SourceObjInfo*>(128 * K, mtClassShared);\n+  _objs = new (mtClassShared) GrowableArray<SourceObjInfo*>(128 * K, mtClassShared);\n@@ -158,0 +158,1 @@\n+  _ptrmap(mtClassShared),\n@@ -167,3 +168,3 @@\n-  _klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<Klass*>(4 * K, mtClassShared);\n-  _symbols = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<Symbol*>(256 * K, mtClassShared);\n-  _special_refs = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<SpecialRefInfo>(24 * K, mtClassShared);\n+  _klasses = new (mtClassShared) GrowableArray<Klass*>(4 * K, mtClassShared);\n+  _symbols = new (mtClassShared) GrowableArray<Symbol*>(256 * K, mtClassShared);\n+  _special_refs = new (mtClassShared) GrowableArray<SpecialRefInfo>(24 * K, mtClassShared);\n@@ -1235,2 +1236,2 @@\n-  const size_t bitmap_used = mapinfo->space_at(MetaspaceShared::bm)->used();\n-  const size_t bitmap_reserved = mapinfo->space_at(MetaspaceShared::bm)->used_aligned();\n+  const size_t bitmap_used = mapinfo->region_at(MetaspaceShared::bm)->used();\n+  const size_t bitmap_reserved = mapinfo->region_at(MetaspaceShared::bm)->used_aligned();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-  ResizeableResourceHashtable<address, SourceObjInfo, ResourceObj::C_HEAP, mtClassShared> _src_obj_table;\n-  ResizeableResourceHashtable<address, address, ResourceObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n+  ResizeableResourceHashtable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n+  ResizeableResourceHashtable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"jvm.h\"\n-#include \"jimage.hpp\"\n@@ -43,0 +41,2 @@\n+#include \"jimage.hpp\"\n+#include \"jvm.h\"\n@@ -76,2 +76,2 @@\n-  _interfaces = new (ResourceObj::C_HEAP, mtClass) GrowableArray<int>(10, mtClass);\n-  _indy_items = new (ResourceObj::C_HEAP, mtClass) GrowableArray<const char*>(9, mtClass);\n+  _interfaces = new (mtClass) GrowableArray<int>(10, mtClass);\n+  _indy_items = new (mtClass) GrowableArray<const char*>(9, mtClass);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -45,0 +44,1 @@\n+#include \"jvm.h\"\n@@ -114,0 +114,12 @@\n+  fail_continue_impl(LogLevel::Info, msg, ap);\n+  va_end(ap);\n+}\n+\n+void FileMapInfo::fail_continue(LogLevelType level, const char *msg, ...) {\n+  va_list ap;\n+  va_start(ap, msg);\n+  fail_continue_impl(level, msg, ap);\n+  va_end(ap);\n+}\n+\n+void FileMapInfo::fail_continue_impl(LogLevelType level, const char *msg, va_list ap) {\n@@ -125,5 +137,2 @@\n-      if (log_is_enabled(Info, cds)) {\n-        LogStream ls(Log(cds)::info());\n-        ls.print(\"UseSharedSpaces: \");\n-        ls.vprint_cr(msg, ap);\n-      }\n+      LogMessage(cds) lm;\n+      lm.vwrite(level, msg, ap);\n@@ -132,1 +141,0 @@\n-  va_end(ap);\n@@ -392,2 +400,2 @@\n-    FileMapRegion* si = space_at(i);\n-    si->print(st, i);\n+    FileMapRegion* r = region_at(i);\n+    r->print(st, i);\n@@ -713,1 +721,1 @@\n-    _non_existent_class_paths = new (ResourceObj::C_HEAP, mtClass)GrowableArray<const char*>(10, mtClass);\n+    _non_existent_class_paths = new (mtClass) GrowableArray<const char*>(10, mtClass);\n@@ -1187,5 +1195,4 @@\n-      const char* mismatch_msg = \"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n-      fail_continue(\"%s\", mismatch_msg);\n-      if (!log_is_enabled(Info, cds) && !log_is_enabled(Info, class, path)) {\n-        log_warning(cds)(\"%s\", mismatch_msg);\n-      }\n+      const char* mismatch_msg = \"shared class paths mismatch\";\n+      const char* hint_msg = log_is_enabled(Info, class, path) ?\n+          \"\" : \" (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n+      fail_continue(LogLevel::Warning, \"%s%s\", mismatch_msg, hint_msg);\n@@ -1330,4 +1337,0 @@\n-    if (!check_common_app_classpath_prefix_len()) {\n-      return false;\n-    }\n-\n@@ -1414,9 +1417,0 @@\n-\n-  bool check_common_app_classpath_prefix_len() {\n-    int common_path_size = _header->_common_app_classpath_prefix_size;\n-    if (common_path_size < 0) {\n-      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n-      return false;\n-    }\n-    return true;\n-  }\n@@ -1497,0 +1491,6 @@\n+  int common_path_size = header()->common_app_classpath_prefix_size();\n+  if (common_path_size < 0) {\n+      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n+      return false;\n+  }\n+\n@@ -1533,2 +1533,2 @@\n-    FileMapRegion* si = space_at(i);\n-    if (si->file_offset() > len || len - si->file_offset() < si->used()) {\n+    FileMapRegion* r = region_at(i);\n+    if (r->file_offset() > len || len - r->file_offset() < r->used()) {\n@@ -1690,1 +1690,1 @@\n-  FileMapRegion* si = space_at(region);\n+  FileMapRegion* r = region_at(region);\n@@ -1703,1 +1703,2 @@\n-      mapping_offset = (size_t)CompressedOops::encode_not_null(cast_to_oop(base));\n+      mapping_offset = (size_t)((address)base - CompressedOops::base());\n+      assert((mapping_offset >> CompressedOops::shift()) << CompressedOops::shift() == mapping_offset, \"must be\");\n@@ -1709,1 +1710,0 @@\n-    assert(mapping_offset == (size_t)(uint32_t)mapping_offset, \"must be 32-bit only\");\n@@ -1717,1 +1717,1 @@\n-  si->set_file_offset(_file_offset);\n+  r->set_file_offset(_file_offset);\n@@ -1726,1 +1726,1 @@\n-  si->init(region, mapping_offset, size, read_only, allow_exec, crc);\n+  r->init(region, mapping_offset, size, read_only, allow_exec, crc);\n@@ -1834,2 +1834,2 @@\n-      space_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n-                                         bitmaps->at(ptrmap_idx));\n+      region_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n+                                          bitmaps->at(ptrmap_idx));\n@@ -1903,2 +1903,2 @@\n-  FileMapRegion* si = space_at(idx);\n-  if (!si->read_only()) {\n+  FileMapRegion* r = region_at(idx);\n+  if (!r->read_only()) {\n@@ -1908,1 +1908,1 @@\n-  size_t size = si->used_aligned();\n+  size_t size = r->used_aligned();\n@@ -1913,1 +1913,1 @@\n-  char *base = os::remap_memory(_fd, _full_path, si->file_offset(),\n+  char *base = os::remap_memory(_fd, _full_path, r->file_offset(),\n@@ -1915,1 +1915,1 @@\n-                                si->allow_exec());\n+                                r->allow_exec());\n@@ -1926,1 +1926,1 @@\n-  si->set_read_only(false);\n+  r->set_read_only(false);\n@@ -1942,2 +1942,2 @@\n-  for (int r = 0; r < num_regions; r++) {\n-    int idx = regions[r];\n+  for (int i = 0; i < num_regions; i++) {\n+    int idx = regions[i];\n@@ -1948,1 +1948,1 @@\n-    FileMapRegion* si = space_at(idx);\n+    FileMapRegion* r = region_at(idx);\n@@ -1952,1 +1952,1 @@\n-        assert(si->mapped_base() == last_region->mapped_end(), \"must have no gaps\");\n+        assert(r->mapped_base() == last_region->mapped_end(), \"must have no gaps\");\n@@ -1954,1 +1954,1 @@\n-      last_region = si;)\n+      last_region = r;)\n@@ -1956,1 +1956,1 @@\n-                  idx, p2i(si->mapped_base()), p2i(si->mapped_end()),\n+                  idx, p2i(r->mapped_base()), p2i(r->mapped_end()),\n@@ -1970,1 +1970,1 @@\n-  FileMapRegion* si = space_at(i);\n+  FileMapRegion* r = region_at(i);\n@@ -1974,2 +1974,2 @@\n-                  shared_region_name[i], si->allow_exec() ? \" exec\" : \"\");\n-    if (!os::commit_memory(base, size, si->allow_exec())) {\n+                  shared_region_name[i], r->allow_exec() ? \" exec\" : \"\");\n+    if (!os::commit_memory(base, size, r->allow_exec())) {\n@@ -1981,1 +1981,1 @@\n-  if (os::lseek(_fd, (long)si->file_offset(), SEEK_SET) != (int)si->file_offset() ||\n+  if (os::lseek(_fd, (long)r->file_offset(), SEEK_SET) != (int)r->file_offset() ||\n@@ -1986,1 +1986,1 @@\n-  if (VerifySharedSpaces && !region_crc_check(base, si->used(), si->crc())) {\n+  if (VerifySharedSpaces && !region_crc_check(base, r->used(), r->crc())) {\n@@ -1995,4 +1995,4 @@\n-  FileMapRegion* si = space_at(i);\n-  size_t size = si->used_aligned();\n-  char *requested_addr = mapped_base_address + si->mapping_offset();\n-  assert(si->mapped_base() == NULL, \"must be not mapped yet\");\n+  FileMapRegion* r = region_at(i);\n+  size_t size = r->used_aligned();\n+  char *requested_addr = mapped_base_address + r->mapping_offset();\n+  assert(r->mapped_base() == NULL, \"must be not mapped yet\");\n@@ -2001,1 +2001,1 @@\n-  si->set_mapped_from_file(false);\n+  r->set_mapped_from_file(false);\n@@ -2006,1 +2006,1 @@\n-    si->set_read_only(false);\n+    r->set_read_only(false);\n@@ -2010,1 +2010,1 @@\n-    si->set_read_only(false);\n+    r->set_read_only(false);\n@@ -2012,1 +2012,1 @@\n-    si->set_read_only(false); \/\/ Need to patch the pointers\n+    r->set_read_only(false); \/\/ Need to patch the pointers\n@@ -2029,3 +2029,3 @@\n-    char* base = os::map_memory(_fd, _full_path, si->file_offset(),\n-                                requested_addr, size, si->read_only(),\n-                                si->allow_exec(), mtClassShared);\n+    char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n+                                requested_addr, size, r->read_only(),\n+                                r->allow_exec(), mtClassShared);\n@@ -2038,1 +2038,1 @@\n-    si->set_mapped_from_file(true);\n+    r->set_mapped_from_file(true);\n@@ -2040,1 +2040,1 @@\n-  si->set_mapped_base(requested_addr);\n+  r->set_mapped_base(requested_addr);\n@@ -2051,3 +2051,3 @@\n-  FileMapRegion* si = space_at(MetaspaceShared::bm);\n-  if (si->mapped_base() != NULL) {\n-    return si->mapped_base();\n+  FileMapRegion* r = region_at(MetaspaceShared::bm);\n+  if (r->mapped_base() != NULL) {\n+    return r->mapped_base();\n@@ -2057,2 +2057,2 @@\n-  char* bitmap_base = os::map_memory(_fd, _full_path, si->file_offset(),\n-                                     requested_addr, si->used_aligned(), read_only, allow_exec, mtClassShared);\n+  char* bitmap_base = os::map_memory(_fd, _full_path, r->file_offset(),\n+                                     requested_addr, r->used_aligned(), read_only, allow_exec, mtClassShared);\n@@ -2064,1 +2064,1 @@\n-  if (VerifySharedSpaces && !region_crc_check(bitmap_base, si->used(), si->crc())) {\n+  if (VerifySharedSpaces && !region_crc_check(bitmap_base, r->used(), r->crc())) {\n@@ -2066,1 +2066,1 @@\n-    if (!os::unmap_memory(bitmap_base, si->used_aligned())) {\n+    if (!os::unmap_memory(bitmap_base, r->used_aligned())) {\n@@ -2072,2 +2072,2 @@\n-  si->set_mapped_base(bitmap_base);\n-  si->set_mapped_from_file(true);\n+  r->set_mapped_base(bitmap_base);\n+  r->set_mapped_from_file(true);\n@@ -2076,1 +2076,1 @@\n-                MetaspaceShared::bm, p2i(si->mapped_base()), p2i(si->mapped_end()),\n+                MetaspaceShared::bm, p2i(r->mapped_base()), p2i(r->mapped_end()),\n@@ -2134,10 +2134,0 @@\n-address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {\n-  size_t offset = spc->mapping_offset();\n-  narrowOop n = CompressedOops::narrow_oop_cast(offset);\n-  if (with_current_oop_encoding_mode) {\n-    return cast_from_oop<address>(CompressedOops::decode_raw_not_null(n));\n-  } else {\n-    return cast_from_oop<address>(ArchiveHeapLoader::decode_from_archive(n));\n-  }\n-}\n-\n@@ -2151,1 +2141,1 @@\n-  return (space_at(MetaspaceShared::first_closed_heap_region)->used() > 0);\n+  return (region_at(MetaspaceShared::first_closed_heap_region)->used() > 0);\n@@ -2158,1 +2148,1 @@\n-MemRegion FileMapInfo::get_heap_regions_range_with_current_oop_encoding_mode() {\n+MemRegion FileMapInfo::get_heap_regions_requested_range() {\n@@ -2165,2 +2155,2 @@\n-    FileMapRegion* si = space_at(i);\n-    size_t size = si->used();\n+    FileMapRegion* r = region_at(i);\n+    size_t size = r->used();\n@@ -2168,1 +2158,1 @@\n-      address s = start_address_as_decoded_with_current_oop_encoding_mode(si);\n+      address s = heap_region_requested_address(r);\n@@ -2170,0 +2160,2 @@\n+      log_info(cds)(\"Heap region %s = \" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" = \"  SIZE_FORMAT_W(8) \" bytes\",\n+                    region_name(i), p2i(s), p2i(e), size);\n@@ -2179,0 +2171,4 @@\n+\n+  start = align_down(start, HeapRegion::GrainBytes);\n+  end = align_up(end, HeapRegion::GrainBytes);\n+\n@@ -2191,1 +2187,6 @@\n-      log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+      if (!UseCompressedOops && !ArchiveHeapLoader::can_map()) {\n+        \/\/ TODO - remove implicit knowledge of G1\n+        log_info(cds)(\"Cannot use CDS heap data. UseG1GC is required for -XX:-UseCompressedOops\");\n+      } else {\n+        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+      }\n@@ -2246,3 +2247,2 @@\n-\/\/ The address where the bottom of this shared heap region should be mapped\n-\/\/ at runtime\n-address FileMapInfo::heap_region_runtime_start_address(FileMapRegion* spc) {\n+\/\/ The actual address of this region during dump time.\n+address FileMapInfo::heap_region_dumptime_address(FileMapRegion* r) {\n@@ -2250,1 +2250,2 @@\n-  spc->assert_is_heap_region();\n+  r->assert_is_heap_region();\n+  assert(is_aligned(r->mapping_offset(), sizeof(HeapWord)), \"must be\");\n@@ -2252,1 +2253,1 @@\n-    return start_address_as_decoded_from_archive(spc);\n+    return \/*dumptime*\/ narrow_oop_base() + r->mapping_offset();\n@@ -2254,2 +2255,1 @@\n-    assert(is_aligned(spc->mapping_offset(), sizeof(HeapWord)), \"must be\");\n-    return header()->heap_begin() + spc->mapping_offset() + ArchiveHeapLoader::runtime_delta();\n+    return heap_region_requested_address(r);\n@@ -2259,1 +2259,7 @@\n-void FileMapInfo::set_shared_heap_runtime_delta(ptrdiff_t delta) {\n+\/\/ The address where this region can be mapped into the runtime heap without\n+\/\/ patching any of the pointers that are embedded in this region.\n+address FileMapInfo::heap_region_requested_address(FileMapRegion* r) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+  r->assert_is_heap_region();\n+  assert(is_aligned(r->mapping_offset(), sizeof(HeapWord)), \"must be\");\n+  assert(ArchiveHeapLoader::can_map(), \"cannot be used by ArchiveHeapLoader::can_load() mode\");\n@@ -2261,1 +2267,13 @@\n-    ArchiveHeapLoader::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());\n+    \/\/ We can avoid relocation if each region's offset from the runtime CompressedOops::base()\n+    \/\/ is the same as its offset from the CompressedOops::base() during dumptime.\n+    \/\/ Note that CompressedOops::base() may be different between dumptime and runtime.\n+    \/\/\n+    \/\/ Example:\n+    \/\/ Dumptime base = 0x1000 and shift is 0. We have a region at address 0x2000. There's a\n+    \/\/ narrowOop P stored in this region that points to an object at address 0x2200.\n+    \/\/ P's encoded value is 0x1200.\n+    \/\/\n+    \/\/ Runtime base = 0x4000 and shift is also 0. If we map this region at 0x5000, then\n+    \/\/ the value P can remain 0x1200. The decoded address = (0x4000 + (0x1200 << 0)) = 0x5200,\n+    \/\/ which is the runtime location of the referenced object.\n+    return \/*runtime*\/ CompressedOops::base() + r->mapping_offset();\n@@ -2263,1 +2281,3 @@\n-    ArchiveHeapLoader::set_runtime_delta(delta);\n+    \/\/ We can avoid relocation if each region is mapped into the exact same address\n+    \/\/ where it was at dump time.\n+    return \/*dumptime*\/header()->heap_begin() + r->mapping_offset();\n@@ -2267,0 +2287,9 @@\n+\/\/ The address where this shared heap region is actually mapped at runtime. This function\n+\/\/ can be called only after we have determined the value for ArchiveHeapLoader::mapped_heap_delta().\n+address FileMapInfo::heap_region_mapped_address(FileMapRegion* r) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+  r->assert_is_heap_region();\n+  assert(ArchiveHeapLoader::can_map(), \"cannot be used by ArchiveHeapLoader::can_load() mode\");\n+  return heap_region_requested_address(r) + ArchiveHeapLoader::mapped_heap_delta();\n+}\n+\n@@ -2282,3 +2311,16 @@\n-  if (narrow_oop_mode() != CompressedOops::mode() ||\n-      narrow_oop_base() != CompressedOops::base() ||\n-      narrow_oop_shift() != CompressedOops::shift()) {\n+  \/\/ G1 -- always map at the very top of the heap to avoid fragmentation.\n+  assert(UseG1GC, \"the following code assumes G1\");\n+  _heap_pointers_need_patching = false;\n+\n+  MemRegion heap_range = G1CollectedHeap::heap()->reserved();\n+  MemRegion archive_range = get_heap_regions_requested_range();\n+\n+  address heap_end = (address)heap_range.end();\n+  address archive_end = (address)archive_range.end();\n+\n+  assert(is_aligned(heap_end, HeapRegion::GrainBytes), \"must be\");\n+  assert(is_aligned(archive_end, HeapRegion::GrainBytes), \"must be\");\n+\n+  if (UseCompressedOops &&\n+      (narrow_oop_mode() != CompressedOops::mode() ||\n+       narrow_oop_shift() != CompressedOops::shift())) {\n@@ -2287,0 +2329,5 @@\n+  } else if (!heap_range.contains(archive_range)) {\n+    log_info(cds)(\"CDS heap data needs to be relocated because\");\n+    log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(archive_range.start()), p2i(archive_range.end()));\n+    log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(heap_range.start()), p2i(heap_range.end()));\n+    _heap_pointers_need_patching = true;\n@@ -2288,23 +2335,4 @@\n-    if (UseCompressedOops) {\n-      MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();\n-      if (!CompressedOops::is_in(range)) {\n-        log_info(cds)(\"CDS heap data needs to be relocated because\");\n-        log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(range.start()), p2i(range.end()));\n-        log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(CompressedOops::begin()), p2i(CompressedOops::end()));\n-        _heap_pointers_need_patching = true;\n-      } else if (header()->heap_end() != CompressedOops::end()) {\n-        log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n-        _heap_pointers_need_patching = true;\n-      }\n-    } else {\n-      MemRegion range((HeapWord*)header()->heap_begin(), (HeapWord*)header()->heap_end());\n-      if (!G1CollectedHeap::heap()->reserved().contains(range)) {\n-        log_info(cds)(\"CDS heap data needs to be relocated because\");\n-        log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(range.start()), p2i(range.end()));\n-        log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT,\n-            p2i((address)G1CollectedHeap::heap()->reserved().start()), p2i((address)G1CollectedHeap::heap()->reserved().end()));\n-        _heap_pointers_need_patching = true;\n-      } else if (header()->heap_end() != (address)G1CollectedHeap::heap()->reserved().end()) {\n-        log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n-        _heap_pointers_need_patching = true;\n-      }\n+    assert(heap_end >= archive_end, \"must be\");\n+    if (heap_end != archive_end) {\n+      log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n+      _heap_pointers_need_patching = true;\n@@ -2316,23 +2344,1 @@\n-    \/\/   dumptime heap end  ------------v\n-    \/\/   [      |archived heap regions| ]         run time heap end -----v\n-    \/\/                                       [   |archived heap regions| ]\n-    \/\/          ^\n-    \/\/          D                                ^\n-    \/\/                                           R\n-    \/\/                                  |<-----delta-------------------->|\n-    \/\/\n-    \/\/ At dump time, the archived heap regions were near the top of the heap.\n-    \/\/ At run time, if the heap ends at a different address, we need to\n-    \/\/ move them near to top of the run time heap. This can be done by\n-    \/\/ the simple math of adding the delta as shown above.\n-    \/\/\n-    \/\/ Also: D = bottom of a heap region at dump time\n-    \/\/       R = bottom of a heap region at run time\n-    \/\/\n-    \/\/ FileMapRegion* spc = ...;\n-    \/\/   address D = header()->heap_begin() + spc->mapping_offset();\n-    \/\/   address R = D + delta;\n-    address dumptime_heap_end = header()->heap_end();\n-    address runtime_heap_end = UseCompressedOops ? CompressedOops::end() :\n-                                                   (address)G1CollectedHeap::heap()->reserved().end();\n-    delta = runtime_heap_end - dumptime_heap_end;\n+    delta = heap_end - archive_end;\n@@ -2343,4 +2349,2 @@\n-  set_shared_heap_runtime_delta(delta);\n-\n-  FileMapRegion* si = space_at(MetaspaceShared::first_closed_heap_region);\n-  address relocated_closed_heap_region_bottom = heap_region_runtime_start_address(si);\n+  FileMapRegion* r = region_at(MetaspaceShared::first_closed_heap_region);\n+  address relocated_closed_heap_region_bottom = heap_region_requested_address(r) + delta;\n@@ -2358,2 +2362,0 @@\n-    set_shared_heap_runtime_delta(delta);\n-    relocated_closed_heap_region_bottom = heap_region_runtime_start_address(si);\n@@ -2362,0 +2364,4 @@\n+\n+  ArchiveHeapLoader::init_mapped_heap_relocation(delta, narrow_oop_shift());\n+  relocated_closed_heap_region_bottom = heap_region_mapped_address(r);\n+\n@@ -2419,1 +2425,1 @@\n-  FileMapRegion* si;\n+  FileMapRegion* r;\n@@ -2424,2 +2430,2 @@\n-    si = space_at(i);\n-    size_t size = si->used();\n+    r = region_at(i);\n+    size_t size = r->used();\n@@ -2427,1 +2433,1 @@\n-      HeapWord* start = (HeapWord*)heap_region_runtime_start_address(si);\n+      HeapWord* start = (HeapWord*)heap_region_mapped_address(r);\n@@ -2456,1 +2462,1 @@\n-    si = space_at(first + i);\n+    r = region_at(first + i);\n@@ -2458,3 +2464,3 @@\n-    char* base = os::map_memory(_fd, _full_path, si->file_offset(),\n-                                addr, regions[i].byte_size(), si->read_only(),\n-                                si->allow_exec());\n+    char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n+                                addr, regions[i].byte_size(), r->read_only(),\n+                                r->allow_exec());\n@@ -2470,1 +2476,1 @@\n-    if (VerifySharedSpaces && !region_crc_check(addr, regions[i].byte_size(), si->crc())) {\n+    if (VerifySharedSpaces && !region_crc_check(addr, regions[i].byte_size(), r->crc())) {\n@@ -2477,1 +2483,1 @@\n-    si->set_mapped_base(base);\n+    r->set_mapped_base(base);\n@@ -2492,1 +2498,0 @@\n-  log_info(cds)(\"patching heap embedded pointers\");\n@@ -2507,1 +2512,18 @@\n-    FileMapRegion* si = space_at(i + first_region_idx);\n+    int region_idx = i + first_region_idx;\n+    FileMapRegion* r = region_at(region_idx);\n+    if (UseCompressedOops) {\n+      \/\/ These are the encoded values for the bottom of this region at dump-time vs run-time:\n+      narrowOop dt_encoded_bottom = CompressedOops::narrow_oop_cast(r->mapping_offset() >> narrow_oop_shift());\n+      narrowOop rt_encoded_bottom = CompressedOops::encode_not_null(cast_to_oop(regions[i].start()));\n+      log_info(cds)(\"patching heap embedded pointers for %s: narrowOop 0x%8x -> 0x%8x\",\n+                    region_name(region_idx), (uint)dt_encoded_bottom, (uint)rt_encoded_bottom);\n+      \/\/ TODO JDK-8269736: if we have the same narrow_oop_shift between dumptime and runtime,\n+      \/\/ Each embedded pointer P can be updated by:\n+      \/\/     P += (rt_encoded_bottom - dt_encoded_bottom)\n+      \/\/\n+      \/\/ TODO:\n+      \/\/ if (dt_encoded_bottom == rt_encoded_bottom && narrow_oop_shift() == CompressedOops::shift()) {\n+      \/\/   \/\/nothing to do\n+      \/\/   return;\n+      \/\/ }\n+    }\n@@ -2510,2 +2532,2 @@\n-      (address)(space_at(MetaspaceShared::bm)->mapped_base()) + si->oopmap_offset(),\n-      si->oopmap_size_in_bits());\n+      (address)(region_at(MetaspaceShared::bm)->mapped_base()) + r->oopmap_offset(),\n+      r->oopmap_size_in_bits());\n@@ -2568,1 +2590,1 @@\n-  size_t sz = space_at(i)->used();\n+  size_t sz = region_at(i)->used();\n@@ -2573,1 +2595,1 @@\n-    return region_crc_check(region_addr(i), sz, space_at(i)->crc());\n+    return region_crc_check(region_addr(i), sz, region_at(i)->crc());\n@@ -2588,3 +2610,3 @@\n-  FileMapRegion* si = space_at(i);\n-  char* mapped_base = si->mapped_base();\n-  size_t size = si->used_aligned();\n+  FileMapRegion* r = region_at(i);\n+  char* mapped_base = r->mapped_base();\n+  size_t size = r->used_aligned();\n@@ -2593,1 +2615,1 @@\n-    if (size > 0 && si->mapped_from_file()) {\n+    if (size > 0 && r->mapped_from_file()) {\n@@ -2600,1 +2622,1 @@\n-    si->set_mapped_base(NULL);\n+    r->set_mapped_base(NULL);\n@@ -2673,8 +2695,3 @@\n-  FileMapRegion* si = space_at(idx);\n-  if (HeapShared::is_heap_region(idx)) {\n-    assert(DumpSharedSpaces, \"The following doesn't work at runtime\");\n-    return si->used() > 0 ?\n-          (char*)start_address_as_decoded_with_current_oop_encoding_mode(si) : NULL;\n-  } else {\n-    return si->mapped_base();\n-  }\n+  assert(UseSharedSpaces, \"must be\");\n+  FileMapRegion* r = region_at(idx);\n+  return r->mapped_base();\n@@ -2684,2 +2701,2 @@\n-FileMapRegion* FileMapInfo::first_core_space() const {\n-  return space_at(MetaspaceShared::rw);\n+FileMapRegion* FileMapInfo::first_core_region() const {\n+  return region_at(MetaspaceShared::rw);\n@@ -2688,2 +2705,2 @@\n-FileMapRegion* FileMapInfo::last_core_space() const {\n-  return space_at(MetaspaceShared::ro);\n+FileMapRegion* FileMapInfo::last_core_region() const {\n+  return region_at(MetaspaceShared::ro);\n@@ -2800,11 +2817,0 @@\n-\/\/ Check if a given address is within one of the shared regions\n-bool FileMapInfo::is_in_shared_region(const void* p, int idx) {\n-  assert(idx == MetaspaceShared::ro ||\n-         idx == MetaspaceShared::rw, \"invalid region index\");\n-  char* base = region_addr(idx);\n-  if (p >= base && p < base + space_at(idx)->used()) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":208,"deletions":202,"binary":false,"changes":410,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"logging\/logLevel.hpp\"\n@@ -220,15 +221,17 @@\n-  size_t _core_region_alignment;    \/\/ how shared archive should be aligned\n-  int    _obj_alignment;            \/\/ value of ObjectAlignmentInBytes\n-  address _narrow_oop_base;         \/\/ compressed oop encoding base\n-  int    _narrow_oop_shift;         \/\/ compressed oop encoding shift\n-  bool   _compact_strings;          \/\/ value of CompactStrings\n-  uintx  _max_heap_size;            \/\/ java max heap size during dumping\n-  CompressedOops::Mode _narrow_oop_mode; \/\/ compressed oop encoding mode\n-  int     _narrow_klass_shift;      \/\/ save narrow klass base and shift\n-  bool    _compressed_oops;         \/\/ save the flag UseCompressedOops\n-  bool    _compressed_class_ptrs;   \/\/ save the flag UseCompressedClassPointers\n-  size_t  _cloned_vtables_offset;   \/\/ The address of the first cloned vtable\n-  size_t  _serialized_data_offset;  \/\/ Data accessed using {ReadClosure,WriteClosure}::serialize()\n-  address _heap_begin;              \/\/ heap begin at dump time.\n-  address _heap_end;                \/\/ heap end at dump time.\n-  bool _has_non_jar_in_classpath;   \/\/ non-jar file entry exists in classpath\n+  size_t _core_region_alignment;                  \/\/ how shared archive should be aligned\n+  int    _obj_alignment;                          \/\/ value of ObjectAlignmentInBytes\n+  address _narrow_oop_base;                       \/\/ compressed oop encoding base\n+  int    _narrow_oop_shift;                       \/\/ compressed oop encoding shift\n+  bool   _compact_strings;                        \/\/ value of CompactStrings\n+  uintx  _max_heap_size;                          \/\/ java max heap size during dumping\n+  CompressedOops::Mode _narrow_oop_mode;          \/\/ compressed oop encoding mode\n+  int     _narrow_klass_shift;                    \/\/ save narrow klass base and shift\n+  bool    _compressed_oops;                       \/\/ save the flag UseCompressedOops\n+  bool    _compressed_class_ptrs;                 \/\/ save the flag UseCompressedClassPointers\n+  size_t  _cloned_vtables_offset;                 \/\/ The address of the first cloned vtable\n+  size_t  _serialized_data_offset;                \/\/ Data accessed using {ReadClosure,WriteClosure}::serialize()\n+  address _heap_begin;                            \/\/ heap begin at dump time.\n+  address _heap_end;                              \/\/ heap end at dump time.\n+  bool _has_non_jar_in_classpath;                 \/\/ non-jar file entry exists in classpath\n+  unsigned int _common_app_classpath_prefix_size; \/\/ size of the common prefix of app class paths\n+                                                  \/\/    0 if no common prefix exists\n@@ -272,15 +275,15 @@\n-  unsigned int magic()                    const { return _generic_header._magic;    }\n-  int crc()                               const { return _generic_header._crc;      }\n-  int version()                           const { return _generic_header._version;  }\n-  unsigned int header_size()              const { return _generic_header._header_size;              }\n-  unsigned int base_archive_name_offset() const { return _generic_header._base_archive_name_offset; }\n-  unsigned int base_archive_name_size()   const { return _generic_header._base_archive_name_size;   }\n-  unsigned int common_app_classpath_prefix_size() const { return _generic_header._common_app_classpath_prefix_size; }\n-\n-  void set_magic(unsigned int m)                    { _generic_header._magic = m;       }\n-  void set_crc(int crc_value)                       { _generic_header._crc = crc_value; }\n-  void set_version(int v)                           { _generic_header._version = v;     }\n-  void set_header_size(unsigned int s)              { _generic_header._header_size = s;              }\n-  void set_base_archive_name_offset(unsigned int s) { _generic_header._base_archive_name_offset = s; }\n-  void set_base_archive_name_size(unsigned int s)   { _generic_header._base_archive_name_size = s;   }\n-  void set_common_app_classpath_prefix_size(unsigned int s) { _generic_header._common_app_classpath_prefix_size = s; }\n+  unsigned int magic()                            const { return _generic_header._magic;                    }\n+  int crc()                                       const { return _generic_header._crc;                      }\n+  int version()                                   const { return _generic_header._version;                  }\n+  unsigned int header_size()                      const { return _generic_header._header_size;              }\n+  unsigned int base_archive_name_offset()         const { return _generic_header._base_archive_name_offset; }\n+  unsigned int base_archive_name_size()           const { return _generic_header._base_archive_name_size;   }\n+  unsigned int common_app_classpath_prefix_size() const { return _common_app_classpath_prefix_size;         }\n+\n+  void set_magic(unsigned int m)                            { _generic_header._magic = m;                    }\n+  void set_crc(int crc_value)                               { _generic_header._crc = crc_value;              }\n+  void set_version(int v)                                   { _generic_header._version = v;                  }\n+  void set_header_size(unsigned int s)                      { _generic_header._header_size = s;              }\n+  void set_base_archive_name_offset(unsigned int s)         { _generic_header._base_archive_name_offset = s; }\n+  void set_base_archive_name_size(unsigned int s)           { _generic_header._base_archive_name_size = s;   }\n+  void set_common_app_classpath_prefix_size(unsigned int s) { _common_app_classpath_prefix_size = s;         }\n@@ -340,1 +343,1 @@\n-  FileMapRegion* space_at(int i) {\n+  FileMapRegion* region_at(int i) {\n@@ -342,1 +345,1 @@\n-    return FileMapRegion::cast(&_space[i]);\n+    return FileMapRegion::cast(&_regions[i]);\n@@ -415,1 +418,1 @@\n-  int    space_crc(int i)      const { return space_at(i)->crc(); }\n+  int    region_crc(int i)     const { return region_at(i)->crc(); }\n@@ -502,1 +505,1 @@\n-  MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n+  MemRegion get_heap_regions_requested_range() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n@@ -518,0 +521,2 @@\n+  static void fail_continue(LogLevelType level, const char *msg, ...) ATTRIBUTE_PRINTF(2, 3);\n+  static void fail_continue_impl(LogLevelType level, const char *msg, va_list ap) ATTRIBUTE_PRINTF(2, 0);\n@@ -522,1 +527,0 @@\n-  bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n@@ -564,1 +568,1 @@\n-  size_t mapping_base_offset() const { return first_core_space()->mapping_offset(); }\n+  size_t mapping_base_offset() const { return first_core_region()->mapping_offset();    }\n@@ -566,1 +570,1 @@\n-  size_t mapping_end_offset()  const { return last_core_space()->mapping_end_offset(); }\n+  size_t mapping_end_offset()  const { return last_core_region()->mapping_end_offset(); }\n@@ -568,2 +572,2 @@\n-  char* mapped_base()    const { return first_core_space()->mapped_base(); }\n-  char* mapped_end()     const { return last_core_space()->mapped_end();   }\n+  char* mapped_base()    const { return first_core_region()->mapped_base(); }\n+  char* mapped_end()     const { return last_core_region()->mapped_end();   }\n@@ -576,2 +580,2 @@\n-  FileMapRegion* first_core_space() const;\n-  FileMapRegion* last_core_space() const;\n+  FileMapRegion* first_core_region() const;\n+  FileMapRegion* last_core_region()  const;\n@@ -579,2 +583,2 @@\n-  FileMapRegion* space_at(int i) const {\n-    return header()->space_at(i);\n+  FileMapRegion* region_at(int i) const {\n+    return header()->region_at(i);\n@@ -615,2 +619,0 @@\n-  address heap_region_runtime_start_address(FileMapRegion* spc) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  void set_shared_heap_runtime_delta(ptrdiff_t delta) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -623,10 +625,3 @@\n-  address decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode);\n-\n-  \/\/ The starting address of spc, as calculated with CompressedOop::decode_non_null()\n-  address start_address_as_decoded_with_current_oop_encoding_mode(FileMapRegion* spc) {\n-    return decode_start_address(spc, true);\n-  }\n-  \/\/ The starting address of spc, as calculated with HeapShared::decode_from_archive()\n-  address start_address_as_decoded_from_archive(FileMapRegion* spc) {\n-    return decode_start_address(spc, false);\n-  }\n+  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":50,"deletions":55,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -626,1 +626,1 @@\n-      new(ResourceObj::C_HEAP, mtClass) GrowableArray<int>(10, mtClass);\n+      new (mtClass) GrowableArray<int>(10, mtClass);\n@@ -640,1 +640,1 @@\n-      new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(50, mtClass);\n+      new (mtClass) GrowableArray<Klass*>(50, mtClass);\n@@ -838,1 +838,1 @@\n-void HeapShared::serialize(SerializeClosure* soc) {\n+void HeapShared::serialize_root(SerializeClosure* soc) {\n@@ -854,0 +854,3 @@\n+}\n+\n+void HeapShared::serialize_tables(SerializeClosure* soc) {\n@@ -1592,1 +1595,1 @@\n-  _dump_time_subgraph_info_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeKlassSubGraphInfoTable();\n+  _dump_time_subgraph_info_table = new (mtClass)DumpTimeKlassSubGraphInfoTable();\n@@ -1664,1 +1667,1 @@\n-    _dumped_interned_strings = new (ResourceObj::C_HEAP, mtClass)DumpedInternedStrings();\n+    _dumped_interned_strings = new (mtClass)DumpedInternedStrings();\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -56,0 +55,1 @@\n+#include \"jvm_io.h\"\n@@ -161,1 +161,1 @@\n-                              ResourceObj::C_HEAP, mtClassShared> _dumped_classes;\n+                              AnyObj::C_HEAP, mtClassShared> _dumped_classes;\n@@ -380,0 +380,1 @@\n+  HeapShared::serialize_root(soc);\n@@ -390,1 +391,1 @@\n-  HeapShared::serialize(soc);\n+  HeapShared::serialize_tables(soc);\n@@ -960,5 +961,0 @@\n-\/\/ Return true if given address is in the misc data region\n-bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {\n-  return UseSharedSpaces && FileMapInfo::current_info()->is_in_shared_region(p, idx);\n-}\n-\n@@ -1504,0 +1500,2 @@\n+  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -56,0 +55,1 @@\n+#include \"jvm.h\"\n@@ -364,8 +364,2 @@\n-  _dtrace_extended_probes = ExtendedDTraceProbes;\n-  if (_dtrace_extended_probes) {\n-    _dtrace_method_probes   = true;\n-    _dtrace_alloc_probes    = true;\n-  } else {\n-    _dtrace_method_probes   = DTraceMethodProbes;\n-    _dtrace_alloc_probes    = DTraceAllocProbes;\n-  }\n+  _dtrace_method_probes = DTraceMethodProbes;\n+  _dtrace_alloc_probes  = DTraceAllocProbes;\n@@ -1121,2 +1115,1 @@\n-        ( (!dtrace_extended_probes() && ExtendedDTraceProbes) ||\n-          (!dtrace_method_probes() && DTraceMethodProbes) ||\n+        ( (!dtrace_method_probes() && DTraceMethodProbes) ||\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool  _dtrace_extended_probes;\n@@ -367,1 +366,0 @@\n-  bool  dtrace_extended_probes() const { return _dtrace_extended_probes; }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-      holder->is_in_package(\"jdk\/internal\/foreign\") || holder->is_in_package(\"java\/lang\/foreign\") ||\n+      holder->is_in_package(\"jdk\/internal\/foreign\/layout\") || holder->is_in_package(\"jdk\/internal\/foreign\") ||\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class ciField : public ResourceObj {\n+class ciField : public ArenaObj {\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"jvm_constants.h\"\n+#include \"jvm_constants.h\"\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -618,0 +618,4 @@\n+ciParametersTypeData* ciMethodData::parameters_type_data() const {\n+  return _parameters != NULL ? new ciParametersTypeData(_parameters) : NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -602,3 +602,1 @@\n-  ciParametersTypeData* parameters_type_data() const {\n-    return _parameters != NULL ? new ciParametersTypeData(_parameters) : NULL;\n-  }\n+  ciParametersTypeData* parameters_type_data() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class ciObjectFactory : public ResourceObj {\n+class ciObjectFactory : public ArenaObj {\n@@ -59,1 +59,1 @@\n-  struct NonPermObject : public ResourceObj {\n+  struct NonPermObject : public ArenaObj {\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -39,0 +38,1 @@\n+#include \"jvm.h\"\n@@ -828,2 +828,1 @@\n-    \/\/ method to be rewritten (number of arguments at a call for\n-    \/\/ instance)\n+    \/\/ method to be rewritten (number of arguments at a call for instance)\n@@ -831,11 +830,4 @@\n-    \/\/ Method::build_profiling_method_data(method, CHECK);\n-    {\n-      \/\/ Grab a lock here to prevent multiple\n-      \/\/ MethodData*s from being created.\n-      MutexLocker ml(THREAD, MethodData_lock);\n-      if (method->method_data() == NULL) {\n-        ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-        MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);\n-        method->set_method_data(method_data);\n-      }\n-    }\n+    assert(method->method_data() == NULL, \"Should only be initialized once\");\n+    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n+    MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);\n+    method->set_method_data(method_data);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class ciSignature : public ResourceObj {\n+class ciSignature : public ArenaObj {\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3232,0 +3232,2 @@\n+void ciTypeFlow::print() const       { print_on(tty); }\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class ciTypeFlow : public ResourceObj {\n+class ciTypeFlow : public ArenaObj {\n@@ -69,1 +69,1 @@\n-  class JsrRecord : public ResourceObj {\n+  class JsrRecord : public ArenaObj {\n@@ -100,1 +100,1 @@\n-  class JsrSet : public ResourceObj {\n+  class JsrSet : public AnyObj {\n@@ -156,1 +156,1 @@\n-  class StateVector : public ResourceObj {\n+  class StateVector : public AnyObj {\n@@ -519,1 +519,1 @@\n-  class Block : public ResourceObj {\n+  class Block : public ArenaObj {\n@@ -713,1 +713,1 @@\n-  class Loop : public ResourceObj {\n+  class Loop : public ArenaObj {\n@@ -934,0 +934,1 @@\n+  void print() const PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -43,0 +42,1 @@\n+#include \"jvm.h\"\n@@ -89,1 +89,0 @@\n-\n@@ -149,1 +148,3 @@\n-#define CONSTANT_CLASS_DESCRIPTORS        64\n+#define JAVA_21_VERSION                   65\n+\n+#define CONSTANT_CLASS_DESCRIPTORS        65\n@@ -173,1 +174,0 @@\n-  assert(cfs->allocated_on_stack_or_embedded(), \"should be local\");\n@@ -907,1 +907,1 @@\n-    _local_interface_indexes = new GrowableArray<u2>(itfs_len, mtNone);\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n@@ -2227,1 +2227,1 @@\n-                            256, ResourceObj::RESOURCE_AREA, mtInternal,\n+                            256, AnyObj::RESOURCE_AREA, mtInternal,\n@@ -4498,2 +4498,2 @@\n-  return _major_version > JAVA_20_VERSION ||\n-         (_major_version == JAVA_20_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+  return _major_version > JAVA_21_VERSION ||\n+         (_major_version == JAVA_21_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"jvm.h\"\n-#include \"jimage.hpp\"\n@@ -48,0 +46,2 @@\n+#include \"jimage.hpp\"\n+#include \"jvm.h\"\n@@ -240,0 +240,4 @@\n+ClassPathDirEntry::~ClassPathDirEntry() {\n+  FREE_C_HEAP_ARRAY(char, _dir);\n+}\n+\n@@ -254,1 +258,1 @@\n-      u1* buffer = NEW_RESOURCE_ARRAY(u1, st.st_size);\n+      u1* buffer = NEW_RESOURCE_ARRAY_IN_THREAD(current, u1, st.st_size);\n@@ -263,1 +267,5 @@\n-        FREE_RESOURCE_ARRAY(char, path, path_len);\n+#ifdef ASSERT\n+        \/\/ Freeing path is a no-op here as buffer prevents it from being reclaimed. But we keep it for\n+        \/\/ debug builds so that we guard against use-after-free bugs.\n+        FREE_RESOURCE_ARRAY_IN_THREAD(current, char, path, path_len);\n+#endif\n@@ -272,1 +280,1 @@\n-  FREE_RESOURCE_ARRAY(char, path, path_len);\n+  FREE_RESOURCE_ARRAY_IN_THREAD(current, char, path, path_len);\n@@ -570,1 +578,1 @@\n-  _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray<ModuleClassPathList*>(num_of_entries, mtModule);\n+  _patch_mod_entries = new (mtModule) GrowableArray<ModuleClassPathList*>(num_of_entries, mtModule);\n@@ -652,4 +660,1 @@\n-        } else {\n-          \/\/ It's an exploded build.\n-          ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n-        }\n+        } \/\/ else it's an exploded build.\n@@ -669,0 +674,12 @@\n+\/\/ Gets the exploded path for the named module. The memory for the path\n+\/\/ is allocated on the C heap if `c_heap` is true otherwise in the resource area.\n+static const char* get_exploded_module_path(const char* module_name, bool c_heap) {\n+  const char *home = Arguments::get_java_home();\n+  const char file_sep = os::file_separator()[0];\n+  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n+  size_t len = strlen(home) + strlen(module_name) + 10;\n+  char *path = c_heap ? NEW_C_HEAP_ARRAY(char, len, mtModule) : NEW_RESOURCE_ARRAY(char, len);\n+  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  return path;\n+}\n+\n@@ -678,6 +695,1 @@\n-  const char *home = Arguments::get_java_home();\n-  const char file_sep = os::file_separator()[0];\n-  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n-  size_t len = strlen(home) + strlen(module_name) + 10;\n-  char *path = NEW_RESOURCE_ARRAY(char, len);\n-  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  const char *path = get_exploded_module_path(module_name, false);\n@@ -1413,0 +1425,14 @@\n+bool ClassLoader::is_module_observable(const char* module_name) {\n+  assert(JImageOpen != NULL, \"jimage library should have been opened\");\n+  if (JImage_file == NULL) {\n+    struct stat st;\n+    const char *path = get_exploded_module_path(module_name, true);\n+    bool res = os::stat(path, &st) == 0;\n+    FREE_C_HEAP_ARRAY(char, path);\n+    return res;\n+  }\n+  jlong size;\n+  const char *jimage_version = get_jimage_version_string();\n+  return (*JImageFindResource)(JImage_file, module_name, jimage_version, \"module-info.class\", &size) != 0;\n+}\n+\n@@ -1510,1 +1536,1 @@\n-    _exploded_entries = new (ResourceObj::C_HEAP, mtModule)\n+    _exploded_entries = new (mtModule)\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-      _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(100, mtClass);\n+      _deallocate_list = new (mtClass) GrowableArray<Metadata*>(100, mtClass);\n@@ -840,0 +840,1 @@\n+    ResourceMark rm;\n@@ -992,0 +993,2 @@\n+    case _claim_stw_fullgc_mark:            out->print_cr(\"stw full gc mark\"); break;\n+    case _claim_stw_fullgc_adjust:          out->print_cr(\"stw full gc adjust\"); break;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -206,4 +206,6 @@\n-    _claim_none         = 0,\n-    _claim_finalizable  = 2,\n-    _claim_strong       = 3,\n-    _claim_other        = 4\n+    _claim_none              = 0,\n+    _claim_finalizable       = 2,\n+    _claim_strong            = 3,\n+    _claim_stw_fullgc_mark   = 4,\n+    _claim_stw_fullgc_adjust = 8,\n+    _claim_other             = 16\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -31,0 +30,1 @@\n+#include \"jvm.h\"\n@@ -102,1 +102,1 @@\n-    _oop_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+    _oop_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -129,1 +129,1 @@\n-    _small_primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+    _small_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -136,1 +136,1 @@\n-    _big_primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+    _big_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -48,0 +47,1 @@\n+#include \"jvm.h\"\n@@ -972,1 +972,1 @@\n-    new (ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(40, mtClass);\n+    new (mtClass) GrowableArray<Klass*>(40, mtClass);\n@@ -976,1 +976,1 @@\n-    new (ResourceObj::C_HEAP, mtModule) GrowableArray<Klass*>(500, mtModule);\n+    new (mtModule) GrowableArray<Klass*>(500, mtModule);\n@@ -1165,2 +1165,3 @@\n-    oop m = Universe::_mirrors[t].resolve();\n-    if (m != NULL) {\n+    if (!is_reference_type(bt)) {\n+      oop m = Universe::java_mirror(bt);\n+      assert(m != NULL, \"sanity\");\n@@ -1181,1 +1182,1 @@\n-      Universe::replace_mirror(bt, archived_m);\n+      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n@@ -1762,1 +1763,1 @@\n-int java_lang_Thread::_extentLocalBindings_offset;\n+int java_lang_Thread::_scopedValueBindings_offset;\n@@ -1775,1 +1776,1 @@\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+  macro(_scopedValueBindings_offset, k, \"scopedValueBindings\", object_signature, false);\n@@ -1808,2 +1809,3 @@\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+void java_lang_Thread::clear_scopedValueBindings(oop java_thread) {\n+  assert(java_thread != NULL, \"need a java_lang_Thread pointer here\");\n+  java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n@@ -1988,1 +1990,1 @@\n-        if (ce == nullptr || ce->cont_oop() != java_lang_VirtualThread::continuation(_java_thread())) {\n+        if (ce == nullptr || ce->cont_oop(thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n@@ -2000,2 +2002,2 @@\n-      _methods = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n-      _bcis = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(init_length, mtInternal);\n+      _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n+      _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n@@ -2075,4 +2077,0 @@\n-int java_lang_ThreadGroup::_ngroups_offset;\n-int java_lang_ThreadGroup::_groups_offset;\n-int java_lang_ThreadGroup::_nweaks_offset;\n-int java_lang_ThreadGroup::_weaks_offset;\n@@ -2106,22 +2104,0 @@\n-int java_lang_ThreadGroup::ngroups(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->int_field(_ngroups_offset);\n-}\n-\n-objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {\n-  oop groups = java_thread_group->obj_field(_groups_offset);\n-  assert(groups == NULL || groups->is_objArray(), \"just checking\"); \/\/ Todo: Add better type checking code\n-  return objArrayOop(groups);\n-}\n-\n-int java_lang_ThreadGroup::nweaks(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->int_field(_nweaks_offset);\n-}\n-\n-objArrayOop java_lang_ThreadGroup::weaks(oop java_thread_group) {\n-  oop weaks = java_thread_group->obj_field(_weaks_offset);\n-  assert(weaks == NULL || weaks->is_objArray(), \"just checking\");\n-  return objArrayOop(weaks);\n-}\n-\n@@ -2132,5 +2108,1 @@\n-  macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,                false); \\\n-  macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,                 false); \\\n-  macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature,   false); \\\n-  macro(_nweaks_offset,      k, vmSymbols::nweaks_name(),      int_signature,                 false); \\\n-  macro(_weaks_offset,       k, vmSymbols::weaks_name(),       weakreference_array_signature, false);\n+  macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,                false);\n@@ -4240,2 +4212,2 @@\n-int jdk_internal_foreign_abi_ABIDescriptor::_targetAddrStorage_offset;\n-int jdk_internal_foreign_abi_ABIDescriptor::_retBufAddrStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch1_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch2_offset;\n@@ -4244,7 +4216,7 @@\n-  macro(_inputStorage_offset,      k, \"inputStorage\",      jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_outputStorage_offset,     k, \"outputStorage\",     jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_volatileStorage_offset,   k, \"volatileStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_stackAlignment_offset,    k, \"stackAlignment\",    int_signature, false); \\\n-  macro(_shadowSpace_offset,       k, \"shadowSpace\",       int_signature, false); \\\n-  macro(_targetAddrStorage_offset, k, \"targetAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false); \\\n-  macro(_retBufAddrStorage_offset, k, \"retBufAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false);\n+  macro(_inputStorage_offset,    k, \"inputStorage\",    jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_outputStorage_offset,   k, \"outputStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_volatileStorage_offset, k, \"volatileStorage\", jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_stackAlignment_offset,  k, \"stackAlignment\",  int_signature, false); \\\n+  macro(_shadowSpace_offset,     k, \"shadowSpace\",     int_signature, false); \\\n+  macro(_scratch1_offset,        k, \"scratch1\",        jdk_internal_foreign_abi_VMStorage_signature, false); \\\n+  macro(_scratch2_offset,        k, \"scratch2\",        jdk_internal_foreign_abi_VMStorage_signature, false);\n@@ -4287,2 +4259,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(oop entry) {\n-  return entry->obj_field(_targetAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch1(oop entry) {\n+  return entry->obj_field(_scratch1_offset);\n@@ -4291,2 +4263,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(oop entry) {\n-  return entry->obj_field(_retBufAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch2(oop entry) {\n+  return entry->obj_field(_scratch2_offset);\n@@ -4296,1 +4268,2 @@\n-int jdk_internal_foreign_abi_VMStorage::_index_offset;\n+int jdk_internal_foreign_abi_VMStorage::_indexOrOffset_offset;\n+int jdk_internal_foreign_abi_VMStorage::_segmentMaskOrSize_offset;\n@@ -4300,3 +4273,4 @@\n-  macro(_type_offset,      k, \"type\",      int_signature, false); \\\n-  macro(_index_offset,     k, \"index\",     int_signature, false); \\\n-  macro(_debugName_offset, k, \"debugName\", string_signature, false); \\\n+  macro(_type_offset,              k, \"type\",              byte_signature, false); \\\n+  macro(_indexOrOffset_offset,     k, \"indexOrOffset\",     int_signature, false); \\\n+  macro(_segmentMaskOrSize_offset, k, \"segmentMaskOrSize\", short_signature, false); \\\n+  macro(_debugName_offset,         k, \"debugName\",         string_signature, false); \\\n@@ -4319,2 +4293,6 @@\n-jint jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n-  return entry->int_field(_type_offset);\n+jbyte jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n+  return entry->byte_field(_type_offset);\n+}\n+\n+jint jdk_internal_foreign_abi_VMStorage::index_or_offset(oop entry) {\n+  return entry->int_field(_indexOrOffset_offset);\n@@ -4323,2 +4301,2 @@\n-jint jdk_internal_foreign_abi_VMStorage::index(oop entry) {\n-  return entry->int_field(_index_offset);\n+jshort jdk_internal_foreign_abi_VMStorage::segment_mask_or_size(oop entry) {\n+  return entry->short_field(_segmentMaskOrSize_offset);\n@@ -4779,0 +4757,5 @@\n+oop java_lang_ClassLoader::parent_no_keepalive(oop loader) {\n+  assert(is_instance(loader), \"loader must be oop\");\n+  return loader->obj_field_access<AS_NO_KEEPALIVE>(_parent_offset);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":48,"deletions":65,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-  static int _extentLocalBindings_offset;\n+  static int _scopedValueBindings_offset;\n@@ -414,2 +414,2 @@\n-  \/\/ Clear all extent local bindings on error\n-  static void clear_extentLocalBindings(oop java_thread);\n+  \/\/ Clear all scoped value bindings on error\n+  static void clear_scopedValueBindings(oop java_thread);\n@@ -495,6 +495,0 @@\n-  static int _ngroups_offset;\n-  static int _groups_offset;\n-  static int _nweaks_offset;\n-  static int _weaks_offset;\n-\n-\n@@ -514,9 +508,0 @@\n-  \/\/ Number of strongly reachable thread groups\n-  static int ngroups(oop java_thread_group);\n-  \/\/ Strongly reachable thread groups\n-  static objArrayOop groups(oop java_thread_group);\n-  \/\/ Number of weakly reachable thread groups\n-  static int nweaks(oop java_thread_group);\n-  \/\/ Weakly reachable thread groups\n-  static objArrayOop weaks(oop java_thread_group);\n-\n@@ -1152,2 +1137,2 @@\n-  static int _targetAddrStorage_offset;\n-  static int _retBufAddrStorage_offset;\n+  static int _scratch1_offset;\n+  static int _scratch2_offset;\n@@ -1166,2 +1151,2 @@\n-  static oop         targetAddrStorage(oop entry);\n-  static oop         retBufAddrStorage(oop entry);\n+  static oop         scratch1(oop entry);\n+  static oop         scratch2(oop entry);\n@@ -1182,1 +1167,2 @@\n-  static int _index_offset;\n+  static int _indexOrOffset_offset;\n+  static int _segmentMaskOrSize_offset;\n@@ -1191,3 +1177,4 @@\n-  static jint        type(oop entry);\n-  static jint        index(oop entry);\n-  static oop         debugName(oop entry);\n+  static jbyte  type(oop entry);\n+  static jint   index_or_offset(oop entry);\n+  static jshort segment_mask_or_size(oop entry);\n+  static oop    debugName(oop entry);\n@@ -1508,0 +1495,1 @@\n+  static oop parent_no_keepalive(oop loader);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, ResourceObj::C_HEAP, mtClass,\n+ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n@@ -143,1 +143,1 @@\n-  assert(action != PlaceholderTable::LOAD_INSTANCE || seen == NULL,\n+  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == NULL,\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -52,0 +51,1 @@\n+#include \"jvm.h\"\n@@ -119,1 +119,1 @@\n-ResourceHashtable<InvokeMethodKey, Method*, 139, ResourceObj::C_HEAP, mtClass,\n+ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n@@ -121,1 +121,1 @@\n-ResourceHashtable<SymbolHandle, OopHandle, 139, ResourceObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _invoke_method_type_table;\n+ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _invoke_method_type_table;\n@@ -566,0 +566,3 @@\n+  assert(EnableWaitForParallelLoad,\n+         \"Only called when enabling legacy parallel class loading logic \"\n+         \"for non-parallel capable class loaders\");\n@@ -600,3 +603,5 @@\n-\/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n-\/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n-static bool should_wait_for_loading(Handle class_loader) {\n+\/\/ Bootstrap and non-parallel capable class loaders use the LOAD_INSTANCE placeholder to\n+\/\/ wait for parallel class loading and to check for circularity error for Xcomp when loading\n+\/\/ signature classes.\n+\/\/ parallelCapable class loaders do NOT wait for parallel loads to complete\n+static bool needs_load_placeholder(Handle class_loader) {\n@@ -639,1 +644,0 @@\n-        oldprobe = NULL;  \/\/ Other thread could delete this placeholder entry\n@@ -643,1 +647,1 @@\n-        } else {\n+        } else if (EnableWaitForParallelLoad) {\n@@ -645,0 +649,2 @@\n+        } else {\n+          return NULL;\n@@ -770,1 +776,1 @@\n-      if (should_wait_for_loading(class_loader)) {\n+      if (needs_load_placeholder(class_loader)) {\n@@ -784,2 +790,3 @@\n-        } else if (should_wait_for_loading(class_loader)) {\n-          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n+        } else if (needs_load_placeholder(class_loader)) {\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread,\n+          \/\/ and check for ClassCircularityError with -Xcomp.\n@@ -1223,6 +1230,0 @@\n-  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n-  ik->set_nest_host(shared_nest_host);\n-\n@@ -1236,0 +1237,6 @@\n+  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n+  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n+  ik->set_nest_host(shared_nest_host);\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -40,0 +39,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"jvm_constants.h\"\n-#include \"jvm_io.h\"\n@@ -31,0 +29,2 @@\n+#include \"jvm_constants.h\"\n+#include \"jvm_io.h\"\n@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n@@ -130,2 +130,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -272,2 +272,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -486,0 +486,3 @@\n+  case vmIntrinsics::_chacha20Block:\n+    if (!UseChaCha20Intrinsics) return true;\n+    break;\n@@ -490,0 +493,3 @@\n+  case vmIntrinsics::_poly1305_processBlocks:\n+    if (!UsePolyIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                                                                                                                       \\\n+                                                                                                                        \\\n@@ -289,6 +289,9 @@\n-  do_intrinsic(_extentLocalCache,          java_lang_Thread,       extentLocalCache_name, extentLocalCache_signature, F_SN) \\\n-   do_name(     extentLocalCache_name,                            \"extentLocalCache\")                                     \\\n-   do_signature(extentLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n-  do_intrinsic(_setExtentLocalCache,       java_lang_Thread,       setExtentLocalCache_name, setExtentLocalCache_signature, F_SN) \\\n-   do_name(     setExtentLocalCache_name,                         \"setExtentLocalCache\")                                  \\\n-   do_signature(setExtentLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_scopedValueCache,         java_lang_Thread,       scopedValueCache_name, scopedValueCache_signature, F_SN) \\\n+   do_name(     scopedValueCache_name,                           \"scopedValueCache\")                                    \\\n+   do_signature(scopedValueCache_signature,                      \"()[Ljava\/lang\/Object;\")                               \\\n+  do_intrinsic(_setScopedValueCache,      java_lang_Thread,       setScopedValueCache_name, setScopedValueCache_signature, F_SN) \\\n+   do_name(     setScopedValueCache_name,                        \"setScopedValueCache\")                                 \\\n+   do_signature(setScopedValueCache_signature,                   \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_findScopedValueBindings,  java_lang_Thread,       findScopedValueBindings_name, void_object_signature, F_SN) \\\n+   do_name(     findScopedValueBindings_name,                    \"findScopedValueBindings\")                             \\\n+                                                                                                                        \\\n@@ -340,0 +343,3 @@\n+  do_intrinsic(_ensureMaterializedForStackWalk, java_lang_Thread, ensureMaterializedForStackWalk_name, object_void_signature, F_SN)  \\\n+   do_name(     ensureMaterializedForStackWalk_name,              \"ensureMaterializedForStackWalk\")                     \\\n+                                                                                                                        \\\n@@ -528,1 +534,1 @@\n-   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                   \\\n+   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                  \\\n@@ -536,0 +542,11 @@\n+  \/* support for com.sun.crypto.provider.Poly1305 *\/                                                                    \\\n+  do_class(com_sun_crypto_provider_Poly1305, \"com\/sun\/crypto\/provider\/Poly1305\")                                        \\\n+  do_intrinsic(_poly1305_processBlocks, com_sun_crypto_provider_Poly1305, processMultipleBlocks_name, ghash_processBlocks_signature, F_R) \\\n+   do_name(processMultipleBlocks_name, \"processMultipleBlocks\")                                                         \\\n+                                                                                                                        \\\n+  \/* support for com.sun.crypto.provider.ChaCha20Cipher *\/                                                              \\\n+  do_class(com_sun_crypto_provider_chacha20cipher,      \"com\/sun\/crypto\/provider\/ChaCha20Cipher\")                       \\\n+  do_intrinsic(_chacha20Block, com_sun_crypto_provider_chacha20cipher, chacha20Block_name, chacha20Block_signature, F_S) \\\n+   do_name(chacha20Block_name,                                 \"implChaCha20Block\")                                         \\\n+   do_signature(chacha20Block_signature, \"([I[B)I\")                                                                    \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -159,0 +159,2 @@\n+  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n+  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n@@ -401,0 +403,1 @@\n+  template(runWith_method_name,                       \"runWith\")                                  \\\n@@ -405,4 +408,0 @@\n-  template(ngroups_name,                              \"ngroups\")                                  \\\n-  template(groups_name,                               \"groups\")                                   \\\n-  template(nweaks_name,                               \"nweaks\")                                   \\\n-  template(weaks_name,                                \"weaks\")                                    \\\n@@ -613,0 +612,1 @@\n+  template(runnable_void_signature,                   \"(Ljava\/lang\/Runnable;)V\")                                   \\\n@@ -615,0 +615,1 @@\n+  template(void_threadgroup_array_signature,          \"()[Ljava\/lang\/ThreadGroup;\")                               \\\n@@ -753,0 +754,4 @@\n+  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n+  template(encodeThrowable_name,                       \"encodeThrowable\")                                         \\\n+  template(encodeThrowable_signature,                  \"(Ljava\/lang\/Throwable;JI)I\")                              \\\n+  template(decodeAndThrowThrowable_name,               \"decodeAndThrowThrowable\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -36,0 +35,1 @@\n+#include \"jvm.h\"\n@@ -824,0 +824,1 @@\n+  Disassembler::decode((RuntimeBlob*)this, st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  int        _frame_size;                        \/\/ size of stack frame\n+  int        _frame_size;                        \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-class ScopeValue: public ResourceObj {\n+class ScopeValue: public AnyObj {\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -48,0 +47,1 @@\n+#include \"jvm.h\"\n@@ -454,0 +454,36 @@\n+#ifdef ASSERT\n+class CheckForOopsClosure : public OopClosure {\n+  bool _found_oop = false;\n+ public:\n+  virtual void do_oop(oop* o) { _found_oop = true; }\n+  virtual void do_oop(narrowOop* o) { _found_oop = true; }\n+  bool found_oop() { return _found_oop; }\n+};\n+class CheckForMetadataClosure : public MetadataClosure {\n+  bool _found_metadata = false;\n+  Metadata* _ignore = nullptr;\n+ public:\n+  CheckForMetadataClosure(Metadata* ignore) : _ignore(ignore) {}\n+  virtual void do_metadata(Metadata* md) { if (md != _ignore) _found_metadata = true; }\n+  bool found_metadata() { return _found_metadata; }\n+};\n+\n+static void assert_no_oops_or_metadata(nmethod* nm) {\n+  if (nm == nullptr) return;\n+  assert(nm->oop_maps() == nullptr, \"expectation\");\n+\n+  CheckForOopsClosure cfo;\n+  nm->oops_do(&cfo);\n+  assert(!cfo.found_oop(), \"no oops allowed\");\n+\n+  \/\/ We allow an exception for the own Method, but require its class to be permanent.\n+  Method* own_method = nm->method();\n+  CheckForMetadataClosure cfm(\/* ignore reference to own Method *\/ own_method);\n+  nm->metadata_do(&cfm);\n+  assert(!cfm.found_metadata(), \"no metadata allowed\");\n+\n+  assert(own_method->method_holder()->class_loader_data()->is_permanent_class_loader_data(),\n+         \"Method's class needs to be permanent\");\n+}\n+#endif\n+\n@@ -477,1 +513,5 @@\n-    nm = new (native_nmethod_size, CompLevel_none)\n+\n+    \/\/ MH intrinsics are dispatch stubs which are compatible with NonNMethod space.\n+    \/\/ IsUnloadingBehaviour::is_unloading needs to handle them separately.\n+    bool allow_NonNMethod_space = method->can_be_allocated_in_NonNMethod_space();\n+    nm = new (native_nmethod_size, allow_NonNMethod_space)\n@@ -484,1 +524,2 @@\n-    NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));\n+    DEBUG_ONLY( if (allow_NonNMethod_space) assert_no_oops_or_metadata(nm); )\n+    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n@@ -725,0 +766,8 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, bool allow_NonNMethod_space) throw () {\n+  \/\/ Try MethodNonProfiled and MethodProfiled.\n+  void* return_value = CodeCache::allocate(nmethod_size, CodeBlobType::MethodNonProfiled);\n+  if (return_value != nullptr || !allow_NonNMethod_space) return return_value;\n+  \/\/ Try NonNMethod or give up.\n+  return CodeCache::allocate(nmethod_size, CodeBlobType::NonNMethod);\n+}\n+\n@@ -1667,5 +1716,16 @@\n-  state = IsUnloadingState::create(state_is_unloading, state_unloading_cycle);\n-\n-  RawAccess<MO_RELAXED>::store(&_is_unloading_state, state);\n-\n-  return state_is_unloading;\n+  uint8_t new_state = IsUnloadingState::create(state_is_unloading, state_unloading_cycle);\n+\n+  \/\/ Note that if an nmethod has dead oops, everyone will agree that the\n+  \/\/ nmethod is_unloading. However, the is_cold heuristics can yield\n+  \/\/ different outcomes, so we guard the computed result with a CAS\n+  \/\/ to ensure all threads have a shared view of whether an nmethod\n+  \/\/ is_unloading or not.\n+  uint8_t found_state = Atomic::cmpxchg(&_is_unloading_state, state, new_state, memory_order_relaxed);\n+\n+  if (found_state == state) {\n+    \/\/ First to change state, we win\n+    return state_is_unloading;\n+  } else {\n+    \/\/ State already set, so use it\n+    return IsUnloadingState::is_unloading(found_state);\n+  }\n@@ -2094,1 +2154,1 @@\n-                            ResourceObj::RESOURCE_AREA, mtInternal,\n+                            AnyObj::RESOURCE_AREA, mtInternal,\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":69,"deletions":9,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -305,0 +305,4 @@\n+  \/\/ For method handle intrinsics: Try MethodNonProfiled, MethodProfiled and NonNMethod.\n+  \/\/ Attention: Only allow NonNMethod space for special nmethods which don't need to be\n+  \/\/ findable by nmethod iterators! In particular, they must not contain oops!\n+  void* operator new(size_t size, int nmethod_size, bool allow_NonNMethod_space) throw();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -42,0 +41,1 @@\n+#include \"jvm.h\"\n@@ -79,0 +79,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/c2compiler.hpp\"\n+#endif\n@@ -83,3 +86,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/c2compiler.hpp\"\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -248,2 +248,1 @@\n-      \/\/ alias_idx correct??\n-      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);\n+      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx, false, MemNode::unordered, LoadNode::Pinned);\n@@ -615,1 +614,0 @@\n-  Node* load = CardTableBarrierSetC2::load_at_resolved(access, val_type);\n@@ -627,1 +625,1 @@\n-    return load;\n+    return CardTableBarrierSetC2::load_at_resolved(access, val_type);\n@@ -631,0 +629,1 @@\n+\n@@ -633,0 +632,13 @@\n+  Node* load;\n+\n+  Node* control =  kit->control();\n+  const TypePtr* adr_type = access.addr().type();\n+  MemNode::MemOrd mo = access.mem_node_mo();\n+  bool requires_atomic_access = (decorators & MO_UNORDERED) == 0;\n+  bool unaligned = (decorators & C2_UNALIGNED) != 0;\n+  bool unsafe = (decorators & C2_UNSAFE_ACCESS) != 0;\n+  \/\/ Pinned control dependency is the strictest. So it's ok to substitute it for any other.\n+  load = kit->make_load(control, adr, val_type, access.type(), adr_type, mo,\n+      LoadNode::Pinned, requires_atomic_access, unaligned, mismatched, unsafe,\n+      access.barrier_data());\n+\n@@ -667,0 +679,34 @@\n+bool G1BarrierSetC2::is_g1_pre_val_load(Node* n) {\n+  if (n->is_Load() && n->as_Load()->has_pinned_control_dependency()) {\n+    \/\/ Make sure the only users of it are: CmpP, StoreP, and a call to write_ref_field_pre_entry\n+\n+    \/\/ Skip possible decode\n+    if (n->outcnt() == 1 && n->unique_out()->is_DecodeN()) {\n+      n = n->unique_out();\n+    }\n+\n+    if (n->outcnt() == 3) {\n+      int found = 0;\n+      for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {\n+        Node* use = iter.get();\n+        if (use->is_Cmp() || use->is_Store()) {\n+          ++found;\n+        } else if (use->is_CallLeaf()) {\n+          CallLeafNode* call = use->as_CallLeaf();\n+          if (strcmp(call->_name, \"write_ref_field_pre_entry\") == 0) {\n+            ++found;\n+          }\n+        }\n+      }\n+      if (found == 3) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1BarrierSetC2::is_gc_pre_barrier_node(Node *node) const {\n+  return is_g1_pre_val_load(node);\n+}\n+\n@@ -668,50 +714,54 @@\n-  assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n-  assert(node->outcnt() <= 2, \"expects 1 or 2 users: Xor and URShift nodes\");\n-  \/\/ It could be only one user, URShift node, in Object.clone() intrinsic\n-  \/\/ but the new allocation is passed to arraycopy stub and it could not\n-  \/\/ be scalar replaced. So we don't check the case.\n-\n-  \/\/ An other case of only one user (Xor) is when the value check for NULL\n-  \/\/ in G1 post barrier is folded after CCP so the code which used URShift\n-  \/\/ is removed.\n-\n-  \/\/ Take Region node before eliminating post barrier since it also\n-  \/\/ eliminates CastP2X node when it has only one user.\n-  Node* this_region = node->in(0);\n-  assert(this_region != NULL, \"\");\n-\n-  \/\/ Remove G1 post barrier.\n-\n-  \/\/ Search for CastP2X->Xor->URShift->Cmp path which\n-  \/\/ checks if the store done to a different from the value's region.\n-  \/\/ And replace Cmp with #0 (false) to collapse G1 post barrier.\n-  Node* xorx = node->find_out_with(Op_XorX);\n-  if (xorx != NULL) {\n-    Node* shift = xorx->unique_out();\n-    Node* cmpx = shift->unique_out();\n-    assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-    cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-    \"missing region check in G1 post barrier\");\n-    igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n-\n-    \/\/ Remove G1 pre barrier.\n-\n-    \/\/ Search \"if (marking != 0)\" check and set it to \"false\".\n-    \/\/ There is no G1 pre barrier if previous stored value is NULL\n-    \/\/ (for example, after initialization).\n-    if (this_region->is_Region() && this_region->req() == 3) {\n-      for (int i = 1; i < 3; ++i) {\n-        if (this_region->in(i)->is_IfFalse() &&\n-            this_region->in(i)->in(0)->is_If() &&\n-            this_region->in(i)->in(0)->in(1)->is_Bool()) {\n-          Node* bol = this_region->in(i)->in(0)->in(1);\n-          cmpx = bol->in(1);\n-          if (bol->as_Bool()->_test._test == BoolTest::ne &&\n-              cmpx->is_Cmp() && cmpx->in(2) == igvn->intcon(0) &&\n-              cmpx->in(1)->is_Load()) {\n-            Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n-            const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-            if (adr->is_AddP() && adr->in(AddPNode::Base) == igvn->C->top() &&\n-                adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n-                adr->in(AddPNode::Offset) == igvn->MakeConX(marking_offset)) {\n-              igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+  if (is_g1_pre_val_load(node)) {\n+    igvn->replace_node(node, igvn->zerocon(node->as_Load()->bottom_type()->basic_type()));\n+  } else {\n+    assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n+    assert(node->outcnt() <= 2, \"expects 1 or 2 users: Xor and URShift nodes\");\n+    \/\/ It could be only one user, URShift node, in Object.clone() intrinsic\n+    \/\/ but the new allocation is passed to arraycopy stub and it could not\n+    \/\/ be scalar replaced. So we don't check the case.\n+\n+    \/\/ An other case of only one user (Xor) is when the value check for NULL\n+    \/\/ in G1 post barrier is folded after CCP so the code which used URShift\n+    \/\/ is removed.\n+\n+    \/\/ Take Region node before eliminating post barrier since it also\n+    \/\/ eliminates CastP2X node when it has only one user.\n+    Node* this_region = node->in(0);\n+    assert(this_region != NULL, \"\");\n+\n+    \/\/ Remove G1 post barrier.\n+\n+    \/\/ Search for CastP2X->Xor->URShift->Cmp path which\n+    \/\/ checks if the store done to a different from the value's region.\n+    \/\/ And replace Cmp with #0 (false) to collapse G1 post barrier.\n+    Node* xorx = node->find_out_with(Op_XorX);\n+    if (xorx != NULL) {\n+      Node* shift = xorx->unique_out();\n+      Node* cmpx = shift->unique_out();\n+      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n+          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n+          \"missing region check in G1 post barrier\");\n+      igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+\n+      \/\/ Remove G1 pre barrier.\n+\n+      \/\/ Search \"if (marking != 0)\" check and set it to \"false\".\n+      \/\/ There is no G1 pre barrier if previous stored value is NULL\n+      \/\/ (for example, after initialization).\n+      if (this_region->is_Region() && this_region->req() == 3) {\n+        for (int i = 1; i < 3; ++i) {\n+          if (this_region->in(i)->is_IfFalse() &&\n+              this_region->in(i)->in(0)->is_If() &&\n+              this_region->in(i)->in(0)->in(1)->is_Bool()) {\n+            Node* bol = this_region->in(i)->in(0)->in(1);\n+            cmpx = bol->in(1);\n+            if (bol->as_Bool()->_test._test == BoolTest::ne &&\n+                cmpx->is_Cmp() && cmpx->in(2) == igvn->intcon(0) &&\n+                cmpx->in(1)->is_Load()) {\n+              Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n+              const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n+              if (adr->is_AddP() && adr->in(AddPNode::Base) == igvn->C->top() &&\n+                  adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n+                  adr->in(AddPNode::Offset) == igvn->MakeConX(marking_offset)) {\n+                igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+              }\n@@ -722,0 +772,16 @@\n+    } else {\n+      assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n+      \/\/ This is a G1 post barrier emitted by the Object.clone() intrinsic.\n+      \/\/ Search for the CastP2X->URShiftX->AddP->LoadB->Cmp path which checks if the card\n+      \/\/ is marked as young_gen and replace the Cmp with 0 (false) to collapse the barrier.\n+      Node* shift = node->find_out_with(Op_URShiftX);\n+      assert(shift != NULL, \"missing G1 post barrier\");\n+      Node* addp = shift->unique_out();\n+      Node* load = addp->find_out_with(Op_LoadB);\n+      assert(load != NULL, \"missing G1 post barrier\");\n+      Node* cmpx = load->unique_out();\n+      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n+          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n+          \"missing card value check in G1 post barrier\");\n+      igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+      \/\/ There is no G1 pre barrier in this case\n@@ -723,16 +789,4 @@\n-  } else {\n-    assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n-    \/\/ This is a G1 post barrier emitted by the Object.clone() intrinsic.\n-    \/\/ Search for the CastP2X->URShiftX->AddP->LoadB->Cmp path which checks if the card\n-    \/\/ is marked as young_gen and replace the Cmp with 0 (false) to collapse the barrier.\n-    Node* shift = node->find_out_with(Op_URShiftX);\n-    assert(shift != NULL, \"missing G1 post barrier\");\n-    Node* addp = shift->unique_out();\n-    Node* load = addp->find_out_with(Op_LoadB);\n-    assert(load != NULL, \"missing G1 post barrier\");\n-    Node* cmpx = load->unique_out();\n-    assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-           cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-           \"missing card value check in G1 post barrier\");\n-    igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n-    \/\/ There is no G1 pre barrier in this case\n+    \/\/ Now CastP2X can be removed since it is used only on dead path\n+    \/\/ which currently still alive until igvn optimize it.\n+    assert(node->outcnt() == 0 || node->unique_out()->Opcode() == Op_URShiftX, \"\");\n+    igvn->replace_node(node, igvn->C->top());\n@@ -740,4 +794,0 @@\n-  \/\/ Now CastP2X can be removed since it is used only on dead path\n-  \/\/ which currently still alive until igvn optimize it.\n-  assert(node->outcnt() == 0 || node->unique_out()->Opcode() == Op_URShiftX, \"\");\n-  igvn->replace_node(node, igvn->C->top());\n@@ -782,0 +832,129 @@\n+bool G1BarrierSetC2::has_cas_in_use_chain(Node *n) const {\n+  Unique_Node_List visited;\n+  Node_List worklist;\n+  worklist.push(n);\n+  while (worklist.size() > 0) {\n+    Node* x = worklist.pop();\n+    if (visited.member(x)) {\n+      continue;\n+    } else {\n+      visited.push(x);\n+    }\n+\n+    if (x->is_LoadStore()) {\n+      int op = x->Opcode();\n+      if (op == Op_CompareAndExchangeP || op == Op_CompareAndExchangeN ||\n+          op == Op_CompareAndSwapP     || op == Op_CompareAndSwapN     ||\n+          op == Op_WeakCompareAndSwapP || op == Op_WeakCompareAndSwapN) {\n+        return true;\n+      }\n+    }\n+    if (!x->is_CFG()) {\n+      for (SimpleDUIterator iter(x); iter.has_next(); iter.next()) {\n+        Node* use = iter.get();\n+        worklist.push(use);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+void G1BarrierSetC2::verify_pre_load(Node* marking_if, Unique_Node_List& loads \/*output*\/) const {\n+  assert(loads.size() == 0, \"Loads list should be empty\");\n+  Node* pre_val_if = marking_if->find_out_with(Op_IfTrue)->find_out_with(Op_If);\n+  if (pre_val_if != NULL) {\n+    Unique_Node_List visited;\n+    Node_List worklist;\n+    Node* pre_val = pre_val_if->in(1)->in(1)->in(1);\n+\n+    worklist.push(pre_val);\n+    while (worklist.size() > 0) {\n+      Node* x = worklist.pop();\n+      if (visited.member(x)) {\n+        continue;\n+      } else {\n+        visited.push(x);\n+      }\n+\n+      if (has_cas_in_use_chain(x)) {\n+        loads.clear();\n+        return;\n+      }\n+\n+      if (x->is_Con()) {\n+        continue;\n+      }\n+      if (x->is_EncodeP() || x->is_DecodeN()) {\n+        worklist.push(x->in(1));\n+        continue;\n+      }\n+      if (x->is_Load() || x->is_LoadStore()) {\n+        assert(x->in(0) != NULL, \"Pre-val load has to have a control\");\n+        loads.push(x);\n+        continue;\n+      }\n+      if (x->is_Phi()) {\n+        for (uint i = 1; i < x->req(); i++) {\n+          worklist.push(x->in(i));\n+        }\n+        continue;\n+      }\n+      assert(false, \"Pre-val anomaly\");\n+    }\n+  }\n+}\n+\n+void G1BarrierSetC2::verify_no_safepoints(Compile* compile, Node* marking_check_if, const Unique_Node_List& loads) const {\n+  if (loads.size() == 0) {\n+    return;\n+  }\n+\n+  if (loads.size() == 1) { \/\/ Handle the typical situation when there a single pre-value load\n+                           \/\/ that is dominated by the marking_check_if, that's true when the\n+                           \/\/ barrier itself does the pre-val load.\n+    Node *pre_val = loads.at(0);\n+    if (pre_val->in(0)->in(0) == marking_check_if) { \/\/ IfTrue->If\n+      return;\n+    }\n+  }\n+\n+  \/\/ All other cases are when pre-value loads dominate the marking check.\n+  Unique_Node_List controls;\n+  for (uint i = 0; i < loads.size(); i++) {\n+    Node *c = loads.at(i)->in(0);\n+    controls.push(c);\n+  }\n+\n+  Unique_Node_List visited;\n+  Unique_Node_List safepoints;\n+  Node_List worklist;\n+  uint found = 0;\n+\n+  worklist.push(marking_check_if);\n+  while (worklist.size() > 0 && found < controls.size()) {\n+    Node* x = worklist.pop();\n+    if (x == NULL || x == compile->top()) continue;\n+    if (visited.member(x)) {\n+      continue;\n+    } else {\n+      visited.push(x);\n+    }\n+\n+    if (controls.member(x)) {\n+      found++;\n+    }\n+    if (x->is_Region()) {\n+      for (uint i = 1; i < x->req(); i++) {\n+        worklist.push(x->in(i));\n+      }\n+    } else {\n+      if (!x->is_SafePoint()) {\n+        worklist.push(x->in(0));\n+      } else {\n+        safepoints.push(x);\n+      }\n+    }\n+  }\n+  assert(found == controls.size(), \"Pre-barrier structure anomaly or possible safepoint\");\n+}\n+\n@@ -836,0 +1015,4 @@\n+\n+              Unique_Node_List loads;\n+              verify_pre_load(iff, loads);\n+              verify_no_safepoints(compile, iff, loads);\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":257,"deletions":74,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -87,1 +87,9 @@\n- public:\n+#ifdef ASSERT\n+  bool has_cas_in_use_chain(Node* x) const;\n+  void verify_pre_load(Node* marking_check_if, Unique_Node_List& loads \/*output*\/) const;\n+  void verify_no_safepoints(Compile* compile, Node* marking_load, const Unique_Node_List& loads) const;\n+#endif\n+\n+  static bool is_g1_pre_val_load(Node* n);\n+public:\n+  virtual bool is_gc_pre_barrier_node(Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-                               _preserved_marks_set->get(worker_id),\n+                               _preserved_marks_set.get(worker_id),\n@@ -691,2 +691,0 @@\n-                                                 G1RedirtyCardsQueueSet* rdcqs,\n-                                                 PreservedMarksSet* preserved_marks_set,\n@@ -698,2 +696,2 @@\n-    _rdcqs(rdcqs),\n-    _preserved_marks_set(preserved_marks_set),\n+    _rdcqs(G1BarrierSet::dirty_card_queue_set().allocator()),\n+    _preserved_marks_set(true \/* in_c_heap *\/),\n@@ -707,0 +705,1 @@\n+  _preserved_marks_set.init(n_workers);\n@@ -717,0 +716,2 @@\n+  _preserved_marks_set.assert_empty();\n+  _preserved_marks_set.reclaim();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  _deferred_obj_array = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapWord*>(10, mtGC);\n+  _deferred_obj_array = new (mtGC) GrowableArray<HeapWord*>(10, mtGC);\n@@ -93,1 +93,1 @@\n-  _shadow_region_array = new (ResourceObj::C_HEAP, mtGC) GrowableArray<size_t >(10, mtGC);\n+  _shadow_region_array = new (mtGC) GrowableArray<size_t >(10, mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1037,0 +1037,3 @@\n+  \/\/ Need to clear claim bits for the next mark.\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n@@ -1969,1 +1972,1 @@\n-      CLDToOopClosure cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_strong);\n+      CLDToOopClosure cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n@@ -2020,3 +2023,1 @@\n-  \/\/ Need new claim bits before marking starts.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n-\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n@@ -2098,2 +2099,2 @@\n-    \/\/ Need new claim bits when tracing through and adjusting pointers.\n-    ClassLoaderDataGraph::clear_claimed_marks();\n+\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -2118,1 +2119,1 @@\n-      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_strong);\n+      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_stw_fullgc_adjust);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n@@ -95,0 +96,8 @@\n+static BarrierSetStackChunk* select_barrier_set_stack_chunk(BarrierSetStackChunk* barrier_set_stack_chunk) {\n+  if (barrier_set_stack_chunk != NULL) {\n+    return barrier_set_stack_chunk;\n+  } else {\n+    return new BarrierSetStackChunk();\n+  }\n+}\n+\n@@ -99,0 +108,1 @@\n+                       BarrierSetStackChunk* barrier_set_stack_chunk,\n@@ -104,1 +114,2 @@\n-    _barrier_set_nmethod(select_barrier_set_nmethod(barrier_set_nmethod)) {\n+    _barrier_set_nmethod(select_barrier_set_nmethod(barrier_set_nmethod)),\n+    _barrier_set_stack_chunk(select_barrier_set_stack_chunk(barrier_set_stack_chunk)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+class BarrierSetStackChunk;\n@@ -78,0 +79,1 @@\n+  BarrierSetStackChunk* _barrier_set_stack_chunk;\n@@ -102,0 +104,1 @@\n+             BarrierSetStackChunk* barrier_set_stack_chunk,\n@@ -172,0 +175,5 @@\n+  BarrierSetStackChunk* barrier_set_stack_chunk() {\n+    assert(_barrier_set_stack_chunk != NULL, \"should be set\");\n+    return _barrier_set_stack_chunk;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-  _decorators = AccessInternal::decorator_fixup(_decorators);\n+  _decorators = AccessInternal::decorator_fixup(_decorators, _type);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,0 +263,1 @@\n+  virtual bool is_gc_pre_barrier_node(Node* node) const { return false; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,2 +283,0 @@\n-  virtual uint32_t hash_oop(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-HeapWord* MemAllocator::allocate_outside_tlab(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_outside_tlab(Allocation& allocation) const {\n@@ -270,1 +270,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab(Allocation& allocation) const {\n@@ -274,1 +274,1 @@\n-  HeapWord* mem = allocate_inside_tlab_fast();\n+  HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -280,1 +280,1 @@\n-  return allocate_inside_tlab_slow(allocation);\n+  return mem_allocate_inside_tlab_slow(allocation);\n@@ -283,1 +283,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab_fast() const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab_fast() const {\n@@ -287,1 +287,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab_slow(Allocation& allocation) const {\n@@ -354,1 +354,5 @@\n-HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n+\n+HeapWord* MemAllocator::mem_allocate_slow(Allocation& allocation) const {\n+  \/\/ Allocation of an oop can always invoke a safepoint.\n+  debug_only(JavaThread::cast(_thread)->check_for_valid_safepoint_state());\n+\n@@ -356,3 +360,4 @@\n-    HeapWord* result = allocate_inside_tlab(allocation);\n-    if (result != NULL) {\n-      return result;\n+    \/\/ Try refilling the TLAB and allocating the object in it.\n+    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n+    if (mem != NULL) {\n+      return mem;\n@@ -362,1 +367,1 @@\n-  return allocate_outside_tlab(allocation);\n+  return mem_allocate_outside_tlab(allocation);\n@@ -365,5 +370,4 @@\n-oop MemAllocator::allocate() const {\n-  oop obj = NULL;\n-  {\n-    Allocation allocation(*this, &obj);\n-    HeapWord* mem = mem_allocate(allocation);\n+HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n+  if (UseTLAB) {\n+    \/\/ Try allocating from an existing TLAB.\n+    HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -371,5 +375,1 @@\n-      obj = initialize(mem);\n-    } else {\n-      \/\/ The unhandled oop detector will poison local variable obj,\n-      \/\/ so reset it to NULL if mem is NULL.\n-      obj = NULL;\n+      return mem;\n@@ -378,1 +378,2 @@\n-  return obj;\n+\n+  return mem_allocate_slow(allocation);\n@@ -381,1 +382,1 @@\n-oop MemAllocator::try_allocate_in_existing_tlab() {\n+oop MemAllocator::allocate() const {\n@@ -384,1 +385,2 @@\n-    HeapWord* mem = allocate_inside_tlab_fast();\n+    Allocation allocation(*this, &obj);\n+    HeapWord* mem = mem_allocate(allocation);\n@@ -455,17 +457,0 @@\n-\n-\/\/ Does the minimal amount of initialization needed for a TLAB allocation.\n-\/\/ We don't need to do a full initialization, as such an allocation need not be immediately walkable.\n-oop StackChunkAllocator::initialize(HeapWord* mem) const {\n-  assert(_stack_size > 0, \"\");\n-  assert(_stack_size <= max_jint, \"\");\n-  assert(_word_size > _stack_size, \"\");\n-\n-  \/\/ zero out fields (but not the stack)\n-  const size_t hs = oopDesc::header_size();\n-  Copy::fill_to_aligned_words(mem + hs, vmClasses::StackChunk_klass()->size_helper() - hs);\n-\n-  jdk_internal_vm_StackChunk::set_size(mem, (int)_stack_size);\n-  jdk_internal_vm_StackChunk::set_sp(mem, (int)_stack_size);\n-\n-  return finish(mem);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":26,"deletions":41,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+  \/\/ Allocate from the current thread's TLAB, without taking a new TLAB (no safepoint).\n+ HeapWord* mem_allocate_inside_tlab_fast() const;\n+\n@@ -46,5 +49,9 @@\n-  \/\/ Allocate from the current thread's TLAB, with broken-out slow path.\n-  HeapWord* allocate_inside_tlab(Allocation& allocation) const;\n-  HeapWord* allocate_inside_tlab_fast() const;\n-  HeapWord* allocate_inside_tlab_slow(Allocation& allocation) const;\n-  HeapWord* allocate_outside_tlab(Allocation& allocation) const;\n+  \/\/ Allocate in a TLAB. Could allocate a new TLAB, and therefore potentially safepoint.\n+  HeapWord* mem_allocate_inside_tlab(Allocation& allocation) const;\n+  HeapWord* mem_allocate_inside_tlab_slow(Allocation& allocation) const;\n+\n+  \/\/ Allocate outside a TLAB. Could safepoint.\n+  HeapWord* mem_allocate_outside_tlab(Allocation& allocation) const;\n+\n+  \/\/ Fast-path TLAB allocation failed. Takes a slow-path and potentially safepoint.\n+  HeapWord* mem_allocate_slow(Allocation& allocation) const;\n@@ -81,1 +88,0 @@\n-  oop try_allocate_in_existing_tlab();\n@@ -88,0 +94,1 @@\n+\n@@ -112,0 +119,1 @@\n+\n@@ -119,9 +127,0 @@\n-  virtual oop initialize(HeapWord* mem) const;\n-};\n-\n-class StackChunkAllocator : public MemAllocator {\n-  const size_t _stack_size;\n-public:\n-  StackChunkAllocator(Klass* klass, size_t word_size, size_t stack_size, Thread* thread = Thread::current())\n-    : MemAllocator(klass, word_size, thread),\n-      _stack_size(stack_size) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+                 NULL \/* barrier_set_stack_chunk *\/,\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -719,0 +719,5 @@\n+\n+bool ShenandoahBarrierSetC2::is_gc_pre_barrier_node(Node* node) const {\n+  return is_shenandoah_wb_pre_call(node);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class ShenandoahBarrierSetC2State : public ResourceObj {\n+class ShenandoahBarrierSetC2State : public ArenaObj {\n@@ -115,0 +115,1 @@\n+  virtual bool is_gc_pre_barrier_node(Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-class ZBarrierSetC2State : public ResourceObj {\n+class ZBarrierSetC2State : public ArenaObj {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-JVM_ExtentLocalCache(JNIEnv *env, jclass threadClass);\n+JVM_ScopedValueCache(JNIEnv *env, jclass threadClass);\n@@ -319,1 +319,4 @@\n-JVM_SetExtentLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetScopedValueCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+\n+JNIEXPORT jobject JNICALL\n+JVM_FindScopedValueBindings(JNIEnv *env, jclass threadClass);\n@@ -751,0 +754,2 @@\n+JNIEXPORT void JNICALL\n+JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -43,0 +42,1 @@\n+#include \"jvm_io.h\"\n@@ -625,0 +625,3 @@\n+  \/\/ Remove the ScopedValue bindings in case we got a StackOverflowError\n+  \/\/ while we were trying to manipulate ScopedValue bindings.\n+  current->clear_scopedValueBindings();\n@@ -636,0 +639,3 @@\n+  \/\/ Remove the ScopedValue bindings in case we got a StackOverflowError\n+  \/\/ while we were trying to manipulate ScopedValue bindings.\n+  current->clear_scopedValueBindings();\n@@ -1402,0 +1408,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -1554,2 +1561,2 @@\n-  _fingerprints = new(ResourceObj::C_HEAP, mtCode)GrowableArray<uint64_t>(32, mtCode);\n-  _handlers     = new(ResourceObj::C_HEAP, mtCode)GrowableArray<address>(32, mtCode);\n+  _fingerprints = new (mtCode) GrowableArray<uint64_t>(32, mtCode);\n+  _handlers     = new (mtCode) GrowableArray<address>(32, mtCode);\n@@ -1729,0 +1736,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -1782,0 +1790,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -40,0 +39,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,2 +206,2 @@\n-void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(bool arg    ), bool arg) {\n-  def(code, flags, in, out, (Template::generator)gen, (int)arg);\n+void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(LdcType ldct), LdcType ldct) {\n+  def(code, flags, in, out, (Template::generator)gen, (int)ldct);\n@@ -255,2 +255,2 @@\n-  def(Bytecodes::_ldc                 , ubcp|____|clvm|____, vtos, vtos, ldc                 ,  false       );\n-  def(Bytecodes::_ldc_w               , ubcp|____|clvm|____, vtos, vtos, ldc                 ,  true        );\n+  def(Bytecodes::_ldc                 , ubcp|____|clvm|____, vtos, vtos, ldc                 ,  ldc_normal  );\n+  def(Bytecodes::_ldc_w               , ubcp|____|clvm|____, vtos, vtos, ldc                 ,  ldc_wide    );\n@@ -494,2 +494,2 @@\n-  def(Bytecodes::_fast_aldc           , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  false       );\n-  def(Bytecodes::_fast_aldc_w         , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  true        );\n+  def(Bytecodes::_fast_aldc           , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  ldc_normal  );\n+  def(Bytecodes::_fast_aldc_w         , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  ldc_wide    );\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  enum LdcType   { ldc_normal = 0, ldc_wide = 1 }; \/\/ LDC type\n@@ -108,0 +109,5 @@\n+  static bool is_ldc_wide(LdcType type) {\n+    assert(type == ldc_wide || type == ldc_normal, \"sanity\");\n+    return (type == ldc_wide);\n+  }\n+\n@@ -131,1 +137,1 @@\n-  static void ldc(bool wide);\n+  static void ldc(LdcType type);\n@@ -133,1 +139,1 @@\n-  static void fast_aldc(bool wide);\n+  static void fast_aldc(LdcType type);\n@@ -332,1 +338,1 @@\n-  static void def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(bool arg    ), bool arg    );\n+  static void def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(LdcType ldct), LdcType ldct);\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/os.hpp\" \/\/ malloc\n+#include \"runtime\/os.hpp\"\n@@ -48,7 +48,7 @@\n-ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantOopWriteValue(NULL);\n-ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);\n-ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);\n-ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);\n-ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);\n-LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());\n-MarkerValue*           CodeInstaller::_virtual_byte_array_marker = new (ResourceObj::C_HEAP, mtJVMCI) MarkerValue();\n+ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (mtJVMCI) ConstantOopWriteValue(NULL);\n+ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (mtJVMCI) ConstantIntValue(-1);\n+ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (mtJVMCI) ConstantIntValue((jint)0);\n+ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (mtJVMCI) ConstantIntValue(1);\n+ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (mtJVMCI) ConstantIntValue(2);\n+LocationValue*         CodeInstaller::_illegal_value = new (mtJVMCI) LocationValue(Location());\n+MarkerValue*           CodeInstaller::_virtual_byte_array_marker = new (mtJVMCI) MarkerValue();\n@@ -690,1 +690,1 @@\n-  initialize_fields(stream, code_flags, method, JVMCI_CHECK_OK);\n+  initialize_fields(stream, code_flags, method, buffer, JVMCI_CHECK_OK);\n@@ -773,1 +773,1 @@\n-void CodeInstaller::initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, JVMCI_TRAPS) {\n+void CodeInstaller::initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, CodeBuffer& buffer, JVMCI_TRAPS) {\n@@ -800,0 +800,1 @@\n+  buffer.set_const_section_alignment(data_section_alignment);\n@@ -854,2 +855,2 @@\n-  int total_size = align_up(_constants_size, CodeSection::alignment(CodeBuffer::SECT_INSTS)) +\n-                   align_up(_code_size, CodeSection::alignment(CodeBuffer::SECT_STUBS)) +\n+  int total_size = align_up(_constants_size, buffer.insts()->alignment()) +\n+                   align_up(_code_size, buffer.stubs()->alignment()) +\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -156,2 +156,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -506,1 +506,1 @@\n-    JVMCIENV->runtime()->initialize(JVMCIENV);\n+    JVMCIENV->runtime()->initialize(JVMCI_CHECK_NULL);\n@@ -579,0 +579,10 @@\n+C2V_VMENTRY_NULL(jobject, getUncachedStringInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  constantTag tag = cp->tag_at(index);\n+  if (!tag.is_string()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(\"Unexpected constant pool tag at index %d: %d\", index, tag.value()));\n+  }\n+  oop obj = cp->uncached_string_at(index, CHECK_NULL);\n+  return JVMCIENV->get_jobject(JVMCIENV->get_object_constant(obj));\n+C2V_END\n+\n@@ -1602,1 +1612,1 @@\n-    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* scopedValues = cvf->scope()->locals();\n@@ -1607,1 +1617,1 @@\n-        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n@@ -1894,3 +1904,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n@@ -1924,3 +1931,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n@@ -2311,1 +2315,0 @@\n-  JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2314,0 +2317,1 @@\n+    JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2330,1 +2334,0 @@\n-  JVMCITraceMark jtm(\"getCurrentJavaThread\");\n@@ -2376,1 +2379,0 @@\n-  JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2380,0 +2382,1 @@\n+    JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2434,1 +2437,0 @@\n-  JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2438,0 +2440,1 @@\n+    JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2837,0 +2840,1 @@\n+  {CC \"getUncachedStringInPool\",                      CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(getUncachedStringInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  nonstatic_field(InstanceKlass,               _misc_flags,                                   u4)                                    \\\n+  nonstatic_field(InstanceKlass,               _misc_status._flags,                           u4)                                    \\\n@@ -177,0 +177,1 @@\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                             OopHandle)                             \\\n@@ -320,0 +321,1 @@\n+  static_field(StubRoutines,                _chacha20Block,                                   address)                               \\\n@@ -656,2 +658,2 @@\n-  declare_constant(InstanceKlass::_misc_has_nonstatic_concrete_methods)   \\\n-  declare_constant(InstanceKlass::_misc_declares_nonstatic_concrete_methods) \\\n+  declare_constant(InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods)   \\\n+  declare_constant(InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _subclasses = new  (ResourceObj::C_HEAP, mtServiceability) GrowableArray<KlassInfoEntry*>(4, mtServiceability);\n+    _subclasses = new (mtServiceability) GrowableArray<KlassInfoEntry*>(4, mtServiceability);\n@@ -285,1 +285,1 @@\n-  _elements = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<KlassInfoEntry*>(_histo_initial_size, mtServiceability);\n+  _elements = new (mtServiceability) GrowableArray<KlassInfoEntry*>(_histo_initial_size, mtServiceability);\n@@ -585,1 +585,1 @@\n-  GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+  GrowableArray<FieldDesc>* fields = new (mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n@@ -615,1 +615,1 @@\n-  GrowableArray<Klass*>* klasses = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<Klass*>(100, mtServiceability);\n+  GrowableArray<Klass*>* klasses = new (mtServiceability) GrowableArray<Klass*>(100, mtServiceability);\n@@ -628,1 +628,1 @@\n-    GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+    GrowableArray<FieldDesc>* fields = new (mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,2 +211,0 @@\n- private:\n-  void iterate_over_heap(KlassInfoTable* cit, BoolObjectClosure* filter = NULL);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,0 +128,6 @@\n+\/\/ Interface for applying an OopClosure to a set of oops.\n+class OopIterator {\n+public:\n+  virtual void oops_do(OopClosure* cl) = 0;\n+};\n+\n@@ -243,7 +249,0 @@\n-class CompactibleSpaceClosure : public StackObj {\n- public:\n-  \/\/ Called for each compactible space\n-  virtual void do_space(CompactibleSpace* s) = 0;\n-};\n-\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-  ResizeableResourceHashtable<address, bool, ResourceObj::C_HEAP,\n+  ResizeableResourceHashtable<address, bool, AnyObj::C_HEAP,\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,4 @@\n-OopHandle Universe::_mirrors[T_VOID+1];\n+OopHandle Universe::_basic_type_mirrors[T_VOID+1];\n+#if INCLUDE_CDS_JAVA_HEAP\n+int Universe::_archived_basic_type_mirror_indices[T_VOID+1];\n+#endif\n@@ -185,9 +188,9 @@\n-oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }\n-oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }\n-oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }\n-oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }\n-oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }\n-oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }\n-oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }\n-oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }\n-oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }\n+oop Universe::int_mirror()                        { return check_mirror(_basic_type_mirrors[T_INT].resolve()); }\n+oop Universe::float_mirror()                      { return check_mirror(_basic_type_mirrors[T_FLOAT].resolve()); }\n+oop Universe::double_mirror()                     { return check_mirror(_basic_type_mirrors[T_DOUBLE].resolve()); }\n+oop Universe::byte_mirror()                       { return check_mirror(_basic_type_mirrors[T_BYTE].resolve()); }\n+oop Universe::bool_mirror()                       { return check_mirror(_basic_type_mirrors[T_BOOLEAN].resolve()); }\n+oop Universe::char_mirror()                       { return check_mirror(_basic_type_mirrors[T_CHAR].resolve()); }\n+oop Universe::long_mirror()                       { return check_mirror(_basic_type_mirrors[T_LONG].resolve()); }\n+oop Universe::short_mirror()                      { return check_mirror(_basic_type_mirrors[T_SHORT].resolve()); }\n+oop Universe::void_mirror()                       { return check_mirror(_basic_type_mirrors[T_VOID].resolve()); }\n@@ -197,6 +200,2 @@\n-  return check_mirror(_mirrors[t].resolve());\n-}\n-\n-\/\/ Used by CDS dumping\n-void Universe::replace_mirror(BasicType t, oop new_mirror) {\n-  Universe::_mirrors[t].replace(new_mirror);\n+  assert(!is_reference_type(t), \"sanity\");\n+  return check_mirror(_basic_type_mirrors[t].resolve());\n@@ -243,5 +242,8 @@\n-\/\/ Serialize metadata and pointers to primitive type mirrors in and out of CDS archive\n-void Universe::serialize(SerializeClosure* f) {\n-\n-  {\n-    oop mirror_oop;\n+void Universe::set_archived_basic_type_mirror_index(BasicType t, int index) {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(!is_reference_type(t), \"sanity\");\n+  _archived_basic_type_mirror_indices[t] = index;\n+}\n+\n+void Universe::update_archived_basic_type_mirrors() {\n+  if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n@@ -250,14 +252,5 @@\n-      if (f->reading()) {\n-        f->do_oop(&mirror_oop); \/\/ read from archive\n-        assert(oopDesc::is_oop_or_null(mirror_oop), \"is oop\");\n-        \/\/ Only create an OopHandle for non-null mirrors\n-        if (mirror_oop != NULL) {\n-          _mirrors[i] = OopHandle(vm_global(), mirror_oop);\n-        }\n-      } else {\n-        if (HeapShared::can_write()) {\n-          mirror_oop = _mirrors[i].resolve();\n-        } else {\n-          mirror_oop = NULL;\n-        }\n-        f->do_oop(&mirror_oop); \/\/ write to archive\n+      int index = _archived_basic_type_mirror_indices[i];\n+      if (!is_reference_type((BasicType)i) && index >= 0) {\n+        oop mirror_oop = HeapShared::get_root(index);\n+        assert(mirror_oop != NULL, \"must be\");\n+        _basic_type_mirrors[i] = OopHandle(vm_global(), mirror_oop);\n@@ -267,0 +260,12 @@\n+}\n+#endif\n+\n+void Universe::serialize(SerializeClosure* f) {\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    f->do_u4((u4*)&_archived_basic_type_mirror_indices[i]);\n+    \/\/ if f->reading(): We can't call HeapShared::get_root() yet, as the heap\n+    \/\/ contents may need to be relocated. _basic_type_mirrors[i] will be\n+    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n+  }\n@@ -460,1 +465,1 @@\n-        _mirrors[T_INT].resolve() != NULL) {\n+        _basic_type_mirrors[T_INT].resolve() != NULL) {\n@@ -463,1 +468,1 @@\n-      \/\/ check that all mirrors are mapped also\n+      \/\/ check that all basic type mirrors are mapped also\n@@ -466,1 +471,1 @@\n-          oop m = _mirrors[i].resolve();\n+          oop m = _basic_type_mirrors[i].resolve();\n@@ -471,1 +476,1 @@\n-      \/\/ _mirror[T_INT} could be NULL if archived heap is not mapped.\n+      \/\/ _basic_type_mirrors[T_INT], etc, are NULL if archived heap is not mapped.\n@@ -478,1 +483,1 @@\n-          _mirrors[i] = OopHandle(vm_global(), m);\n+          _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n@@ -480,0 +485,1 @@\n+        CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -202,0 +202,10 @@\n+  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n+  \/\/ but including T_VOID, hence the index including T_VOID\n+  static OopHandle _basic_type_mirrors[T_VOID+1];\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ Each slot i stores an index that can be used to restore _basic_type_mirrors[i]\n+  \/\/ from the archive heap using HeapShared::get_root(int)\n+  static int _archived_basic_type_mirror_indices[T_VOID+1];\n+#endif\n+\n@@ -237,5 +247,5 @@\n-  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n-  \/\/ but including T_VOID, hence the index including T_VOID\n-  static OopHandle _mirrors[T_VOID+1];\n-\n-  static void replace_mirror(BasicType t, oop obj);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void set_archived_basic_type_mirror_index(BasicType t, int index);\n+  static void update_archived_basic_type_mirrors();\n+#endif\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -242,1 +242,3 @@\n-  inline DecoratorSet decorator_fixup(DecoratorSet input_decorators) {\n+  inline DecoratorSet decorator_fixup(DecoratorSet input_decorators, BasicType type) {\n+    \/\/ Some call-sites don't specify that the access is performed on oops\n+    DecoratorSet with_oop_decorators = input_decorators |= (is_reference_type(type) ? INTERNAL_VALUE_IS_OOP : 0);\n@@ -244,2 +246,2 @@\n-    DecoratorSet ref_strength_default = input_decorators |\n-      (((ON_DECORATOR_MASK & input_decorators) == 0 && (INTERNAL_VALUE_IS_OOP & input_decorators) != 0) ?\n+    DecoratorSet ref_strength_default = with_oop_decorators |\n+      (((ON_DECORATOR_MASK & with_oop_decorators) == 0 && (INTERNAL_VALUE_IS_OOP & input_decorators) != 0) ?\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -41,0 +40,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -900,1 +900,1 @@\n-    ResourceHashtable<const Symbol*, u2, 256, ResourceObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+    ResourceHashtable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -632,10 +632,8 @@\n-  \/\/ print entry\n-  st->print(\"%3d  (\" PTR_FORMAT \")  \", index, (intptr_t)this);\n-  st->print_cr(\"[%02x|%02x|%5d]\", bytecode_2(), bytecode_1(),\n-               constant_pool_index());\n-  st->print_cr(\"                 [   \" PTR_FORMAT \"]\", (intptr_t)_f1);\n-  st->print_cr(\"                 [   \" PTR_FORMAT \"]\", (intptr_t)_f2);\n-  st->print_cr(\"                 [   \" PTR_FORMAT \"]\", (intptr_t)_flags);\n-\n-  if ((bytecode_1() == Bytecodes::_invokehandle ||\n-       bytecode_1() == Bytecodes::_invokedynamic)) {\n+  \/\/ print universal entry info\n+  st->print_cr(\"%3d\", index);\n+  st->print_cr(\" - this: \" PTR_FORMAT, p2i(this));\n+  st->print_cr(\" - bytecode 1: %s %02x\", Bytecodes::name(bytecode_1()), bytecode_1());\n+  st->print_cr(\" - bytecode 2: %s %02x\", Bytecodes::name(bytecode_2()), bytecode_2());\n+  st->print_cr(\" - cp index: %5d\", constant_pool_index());\n+  if (is_method_entry()) {\n+    ResourceMark rm;\n@@ -644,12 +642,21 @@\n-    oop appendix = appendix_if_resolved(cph);\n-    ResourceMark rm;\n-    if (m != NULL) {\n-      st->print_cr(\"  Method%s: \" INTPTR_FORMAT \" %s.%s%s\",\n-                   m->is_native() ? \" (native)\" : \"\",\n-                   p2i(m),\n-                   m->method_holder()->name()->as_C_string(),\n-                   m->name()->as_C_string(), m->signature()->as_C_string());\n-    }\n-    if (appendix != NULL) {\n-      st->print(\"  appendix: \");\n-      appendix->print_on(st);\n+    st->print_cr(\" - F1:  [   \" PTR_FORMAT \"]\", (intptr_t)_f1);\n+    st->print_cr(\" - F2:  [   \" PTR_FORMAT \"]\", (intptr_t)_f2);\n+    st->print_cr(\" - method: \" INTPTR_FORMAT \" %s\", p2i(m), m != nullptr ? m->external_name() : nullptr);\n+    st->print_cr(\" - flag values: [%02x|0|0|%01x|%01x|%01x|%01x|0|%01x|%01x|00|00|%02x]\",\n+                 flag_state(), has_local_signature(), has_appendix(),\n+                 is_forced_virtual(), is_final(), is_vfinal(),\n+                 indy_resolution_failed(), parameter_size());\n+    st->print_cr(\" - tos: %s\\n - local signature: %01x\\n\"\n+                 \" - has appendix: %01x\\n - forced virtual: %01x\\n\"\n+                 \" - final: %01x\\n - virtual final: %01x\\n - resolution failed: %01x\\n\"\n+                 \" - num parameters: %02x\",\n+                 type2name(as_BasicType(flag_state())), has_local_signature(), has_appendix(),\n+                 is_forced_virtual(), is_final(), is_vfinal(),\n+                 indy_resolution_failed(), parameter_size());\n+    if (bytecode_1() == Bytecodes::_invokehandle ||\n+        bytecode_1() == Bytecodes::_invokedynamic) {\n+      oop appendix = appendix_if_resolved(cph);\n+      if (appendix != nullptr) {\n+        st->print(\"  appendix: \");\n+        appendix->print_on(st);\n+      }\n@@ -657,0 +664,8 @@\n+  } else {\n+    assert(is_field_entry(), \"must be a field entry\");\n+    st->print_cr(\" - F1:  [   \" PTR_FORMAT \"]\", (intptr_t)_f1);\n+    st->print_cr(\" - F2:  [   \" PTR_FORMAT \"]\", (intptr_t)_f2);\n+    st->print_cr(\" - flag values: [%02x|0|1|0|0|0|%01x|%01x|0|0|%04x]\",\n+                 flag_state(), is_final(), is_volatile(), field_index());\n+    st->print_cr(\" - tos: %s\\n - final: %d\\n - volatile: %d\\n - field index: %04x\",\n+                 type2name(as_BasicType(flag_state())), is_final(), is_volatile(), field_index());\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -49,0 +48,1 @@\n+#include \"jvm.h\"\n@@ -393,0 +393,1 @@\n+  assert(this_key != NULL, \"sanity\");\n@@ -1100,1 +1101,1 @@\n-ResourceHashtable<const InstanceKlass*, OopHandle, 107, ResourceObj::C_HEAP, mtClass>\n+ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>\n@@ -2844,30 +2845,0 @@\n-\n-void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {\n-  switch (loader_type) {\n-  case ClassLoader::BOOT_LOADER:\n-    _misc_flags |= _misc_is_shared_boot_class;\n-    break;\n-  case ClassLoader::PLATFORM_LOADER:\n-    _misc_flags |= _misc_is_shared_platform_class;\n-    break;\n-  case ClassLoader::APP_LOADER:\n-    _misc_flags |= _misc_is_shared_app_class;\n-    break;\n-  default:\n-    ShouldNotReachHere();\n-    break;\n-  }\n-}\n-\n-void InstanceKlass::assign_class_loader_type() {\n-  ClassLoaderData *cld = class_loader_data();\n-  if (cld->is_boot_class_loader_data()) {\n-    set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n-  }\n-  else if (cld->is_platform_class_loader_data()) {\n-    set_shared_class_loader_type(ClassLoader::PLATFORM_LOADER);\n-  }\n-  else if (cld->is_system_class_loader_data()) {\n-    set_shared_class_loader_type(ClassLoader::APP_LOADER);\n-  }\n-}\n@@ -2990,3 +2961,0 @@\n-  int hash_len = 0;\n-  char hash_buf[40];\n-\n@@ -2997,1 +2965,1 @@\n-  char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);\n+  char* dest = NEW_RESOURCE_ARRAY(char, src_length + 3);\n@@ -3017,5 +2985,0 @@\n-  \/\/ If we have a hash, append it\n-  for (int hash_index = 0; hash_index < hash_len; ) {\n-    dest[dest_index++] = hash_buf[hash_index++];\n-  }\n-\n@@ -3667,1 +3630,1 @@\n-  st->print(BULLET\"misc flags:        0x%x\", _misc_flags);                        st->cr();\n+  st->print(BULLET\"misc flags:        0x%x\", _misc_status.flags());               st->cr();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":42,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/instanceKlassMiscStatus.hpp\"\n@@ -247,1 +248,1 @@\n-  \/\/ _misc_flags.\n+  \/\/ _misc_status right now.\n@@ -254,34 +255,2 @@\n-  enum {\n-    _misc_rewritten                           = 1 << 0,  \/\/ methods rewritten.\n-    _misc_has_nonstatic_fields                = 1 << 1,  \/\/ for sizing with UseCompressedOops\n-    _misc_should_verify_class                 = 1 << 2,  \/\/ allow caching of preverification\n-    _misc_unused                              = 1 << 3,  \/\/ not currently used\n-    _misc_is_contended                        = 1 << 4,  \/\/ marked with contended annotation\n-    _misc_has_nonstatic_concrete_methods      = 1 << 5,  \/\/ class\/superclass\/implemented interfaces has non-static, concrete methods\n-    _misc_declares_nonstatic_concrete_methods = 1 << 6,  \/\/ directly declares non-static, concrete methods\n-    _misc_has_been_redefined                  = 1 << 7,  \/\/ class has been redefined\n-    _misc_shared_loading_failed               = 1 << 8,  \/\/ class has been loaded from shared archive\n-    _misc_is_scratch_class                    = 1 << 9,  \/\/ class is the redefined scratch class\n-    _misc_is_shared_boot_class                = 1 << 10, \/\/ defining class loader is boot class loader\n-    _misc_is_shared_platform_class            = 1 << 11, \/\/ defining class loader is platform class loader\n-    _misc_is_shared_app_class                 = 1 << 12, \/\/ defining class loader is app class loader\n-    _misc_has_contended_annotations           = 1 << 13, \/\/ has @Contended annotation\n-    _misc_has_inline_type_fields              = 1 << 14, \/\/ has inline fields and related embedded section is not empty\n-    _misc_is_empty_inline_type                = 1 << 15, \/\/ empty inline type (*)\n-    _misc_is_naturally_atomic                 = 1 << 16, \/\/ loaded\/stored in one instruction\n-    _misc_is_declared_atomic                  = 1 << 17, \/\/ implements jl.NonTearable\n-    \/\/ _misc_invalid_value_super                 = 1 << 18, \/\/ invalid super type for an value type\n-    \/\/ _misc_invalid_identity_super              = 1 << 19, \/\/ invalid super type for an identity type\n-    _misc_carries_value_modifier              = 1 << 20, \/\/ the class or one of its super types has the ACC_VALUE modifier\n-    _misc_carries_identity_modifier           = 1 << 21, \/\/ the class or one of its super types has the ACC_IDENTITY modifier\n-  };\n-\n-  \/\/ (*) An inline type is considered empty if it contains no non-static fields or\n-  \/\/ if it contains only empty inline fields. Note that JITs have a slightly different\n-  \/\/ definition: empty inline fields must be flattened otherwise the container won't\n-  \/\/ be considered empty\n-\n-  u2 shared_loader_type_bits() const {\n-    return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;\n-  }\n-  u4              _misc_flags;           \/\/ There is more space in access_flags for more flags.\n+  \/\/ State is set while executing, eventually atomically to not disturb other state\n+  InstanceKlassMiscStatus _misc_status;\n@@ -374,9 +343,3 @@\n-  bool is_shared_boot_class() const {\n-    return (_misc_flags & _misc_is_shared_boot_class) != 0;\n-  }\n-  bool is_shared_platform_class() const {\n-    return (_misc_flags & _misc_is_shared_platform_class) != 0;\n-  }\n-  bool is_shared_app_class() const {\n-    return (_misc_flags & _misc_is_shared_app_class) != 0;\n-  }\n+  bool is_shared_boot_class() const { return _misc_status.is_shared_boot_class(); }\n+  bool is_shared_platform_class() const { return _misc_status.is_shared_platform_class(); }\n+  bool is_shared_app_class() const {  return _misc_status.is_shared_app_class(); }\n@@ -384,3 +347,1 @@\n-  bool is_shared_unregistered_class() const {\n-    return (_misc_flags & shared_loader_type_bits()) == 0;\n-  }\n+  bool is_shared_unregistered_class() const { return _misc_status.is_shared_unregistered_class(); }\n@@ -391,7 +352,1 @@\n-  bool shared_loading_failed() const {\n-    return (_misc_flags & _misc_shared_loading_failed) != 0;\n-  }\n-\n-  void set_shared_loading_failed() {\n-    _misc_flags |= _misc_shared_loading_failed;\n-  }\n+  bool shared_loading_failed() const { return _misc_status.shared_loading_failed(); }\n@@ -399,1 +354,1 @@\n-  void set_shared_class_loader_type(s2 loader_type);\n+  void set_shared_loading_failed() { _misc_status.set_shared_loading_failed(true); }\n@@ -401,1 +356,4 @@\n-  void assign_class_loader_type();\n+#if INCLUDE_CDS\n+  void set_shared_class_loader_type(s2 loader_type) { _misc_status.set_shared_class_loader_type(loader_type); }\n+  void assign_class_loader_type() { _misc_status.assign_class_loader_type(_class_loader_data); }\n+#endif\n@@ -403,9 +361,2 @@\n-  bool has_nonstatic_fields() const        {\n-    return (_misc_flags & _misc_has_nonstatic_fields) != 0;\n-  }\n-  void set_has_nonstatic_fields(bool b)    {\n-    assert(!has_nonstatic_fields(), \"set once\");\n-    if (b) {\n-      _misc_flags |= _misc_has_nonstatic_fields;\n-    }\n-  }\n+  bool has_nonstatic_fields() const        { return _misc_status.has_nonstatic_fields(); }\n+  void set_has_nonstatic_fields(bool b)    { _misc_status.set_has_nonstatic_fields(b); }\n@@ -413,6 +364,2 @@\n-  bool has_inline_type_fields() const          {\n-    return (_misc_flags & _misc_has_inline_type_fields) != 0;\n-  }\n-  void set_has_inline_type_fields()  {\n-    _misc_flags |= _misc_has_inline_type_fields;\n-  }\n+  bool has_inline_type_fields() const { return _misc_status.has_inline_type_fields(); }\n+  void set_has_inline_type_fields()   { _misc_status.set_has_inline_type_fields(true); }\n@@ -420,6 +367,2 @@\n-  bool is_empty_inline_type() const {\n-    return (_misc_flags & _misc_is_empty_inline_type) != 0;\n-  }\n-  void set_is_empty_inline_type() {\n-    _misc_flags |= _misc_is_empty_inline_type;\n-  }\n+  bool is_empty_inline_type() const   { return _misc_status.is_empty_inline_type(); }\n+  void set_is_empty_inline_type()     { _misc_status.set_is_empty_inline_type(true); }\n@@ -432,7 +375,2 @@\n-  bool is_naturally_atomic() const {\n-    return (_misc_flags & _misc_is_naturally_atomic) != 0;\n-  }\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_is_naturally_atomic() {\n-    _misc_flags |= _misc_is_naturally_atomic;\n-  }\n+  bool is_naturally_atomic() const  { return _misc_status.is_naturally_atomic(); }\n+  void set_is_naturally_atomic()    { _misc_status.set_is_naturally_atomic(true); }\n@@ -445,16 +383,2 @@\n-  bool is_declared_atomic() const {\n-    return (_misc_flags & _misc_is_declared_atomic) != 0;\n-  }\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_is_declared_atomic() {\n-    _misc_flags |= _misc_is_declared_atomic;\n-  }\n-\n-  bool carries_value_modifier() const {\n-    return (_misc_flags &  _misc_carries_value_modifier) != 0;\n-  }\n-\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_carries_value_modifier() {\n-    _misc_flags |= _misc_carries_value_modifier;\n-  }\n+  bool is_declared_atomic() const { return _misc_status.is_declared_atomic(); }\n+  void set_is_declared_atomic()   { _misc_status.set_is_declared_atomic(true); }\n@@ -462,3 +386,2 @@\n-  bool carries_identity_modifier() const {\n-    return (_misc_flags & _misc_carries_identity_modifier) != 0;\n-  }\n+  bool carries_value_modifier() const { return _misc_status.carries_value_modifier(); }\n+  void set_carries_value_modifier()   { _misc_status.set_carries_value_modifier(true); }\n@@ -466,4 +389,2 @@\n-  \/\/ Initialized in the class file parser, not changed later.\n-  void set_carries_identity_modifier() {\n-    _misc_flags |= _misc_carries_identity_modifier;\n-  }\n+  bool carries_identity_modifier() const  { return _misc_status.carries_identity_modifier(); }\n+  void set_carries_identity_modifier()    { _misc_status.set_carries_identity_modifier(true); }\n@@ -651,1 +572,1 @@\n-  bool is_rewritten() const                { return (_misc_flags & _misc_rewritten) != 0; }\n+  bool is_rewritten() const                { return _misc_status.rewritten(); }\n@@ -672,9 +593,2 @@\n-  bool should_verify_class() const         {\n-    return (_misc_flags & _misc_should_verify_class) != 0;\n-  }\n-  void set_should_verify_class(bool value) {\n-    assert(!should_verify_class(), \"set once\");\n-    if (value) {\n-      _misc_flags |= _misc_should_verify_class;\n-    }\n-  }\n+  bool should_verify_class() const         { return _misc_status.should_verify_class(); }\n+  void set_should_verify_class(bool value) { _misc_status.set_should_verify_class(value); }\n@@ -687,2 +601,1 @@\n-  static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }\n-  static u4 misc_flag_is_empty_inline_type() { return _misc_is_empty_inline_type; }\n+  static ByteSize misc_status_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_status)); }\n@@ -800,9 +713,2 @@\n-  bool is_contended() const                {\n-    return (_misc_flags & _misc_is_contended) != 0;\n-  }\n-  void set_is_contended(bool value)        {\n-    assert(!is_contended(), \"set once\");\n-    if (value) {\n-      _misc_flags |= _misc_is_contended;\n-    }\n-  }\n+  bool is_contended() const                { return _misc_status.is_contended(); }\n+  void set_is_contended(bool value)        { _misc_status.set_is_contended(value); }\n@@ -837,9 +743,2 @@\n-  bool has_contended_annotations() const {\n-    return ((_misc_flags & _misc_has_contended_annotations) != 0);\n-  }\n-  void set_has_contended_annotations(bool value)  {\n-    assert(!has_contended_annotations(), \"set once\");\n-    if (value) {\n-      _misc_flags |= _misc_has_contended_annotations;\n-    }\n-  }\n+  bool has_contended_annotations() const { return _misc_status.has_contended_annotations(); }\n+  void set_has_contended_annotations(bool value)  { _misc_status.set_has_contended_annotations(value); }\n@@ -880,6 +779,2 @@\n-  bool has_been_redefined() const {\n-    return (_misc_flags & _misc_has_been_redefined) != 0;\n-  }\n-  void set_has_been_redefined() {\n-    _misc_flags |= _misc_has_been_redefined;\n-  }\n+  bool has_been_redefined() const { return _misc_status.has_been_redefined(); }\n+  void set_has_been_redefined() { _misc_status.set_has_been_redefined(true); }\n@@ -887,7 +782,2 @@\n-  bool is_scratch_class() const {\n-    return (_misc_flags & _misc_is_scratch_class) != 0;\n-  }\n-\n-  void set_is_scratch_class() {\n-    _misc_flags |= _misc_is_scratch_class;\n-  }\n+  bool is_scratch_class() const { return _misc_status.is_scratch_class(); }\n+  void set_is_scratch_class() { _misc_status.set_is_scratch_class(true); }\n@@ -949,9 +839,2 @@\n-  bool has_nonstatic_concrete_methods() const {\n-    return (_misc_flags & _misc_has_nonstatic_concrete_methods) != 0;\n-  }\n-  void set_has_nonstatic_concrete_methods(bool b) {\n-    assert(!has_nonstatic_concrete_methods(), \"set once\");\n-    if (b) {\n-      _misc_flags |= _misc_has_nonstatic_concrete_methods;\n-    }\n-  }\n+  bool has_nonstatic_concrete_methods() const { return _misc_status.has_nonstatic_concrete_methods(); }\n+  void set_has_nonstatic_concrete_methods(bool b) { _misc_status.set_has_nonstatic_concrete_methods(b); }\n@@ -959,9 +842,2 @@\n-  bool declares_nonstatic_concrete_methods() const {\n-    return (_misc_flags & _misc_declares_nonstatic_concrete_methods) != 0;\n-  }\n-  void set_declares_nonstatic_concrete_methods(bool b) {\n-    assert(!declares_nonstatic_concrete_methods(), \"set once\");\n-    if (b) {\n-      _misc_flags |= _misc_declares_nonstatic_concrete_methods;\n-    }\n-  }\n+  bool declares_nonstatic_concrete_methods() const { return _misc_status.declares_nonstatic_concrete_methods(); }\n+  void set_declares_nonstatic_concrete_methods(bool b) { _misc_status.set_declares_nonstatic_concrete_methods(b); }\n@@ -1277,1 +1153,1 @@\n-  void set_rewritten()                  { _misc_flags |= _misc_rewritten; }\n+  void set_rewritten()                  { _misc_status.set_rewritten(true); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":45,"deletions":169,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_INSTANCEKLASSMISCSTATUS_HPP\n+#define SHARE_OOPS_INSTANCEKLASSMISCSTATUS_HPP\n+\n+class ClassLoaderData;\n+\n+class InstanceKlassMiscStatus {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+#define IK_FLAGS_DO(flag)  \\\n+    flag(rewritten                          , 1 << 0) \/* methods rewritten. *\/ \\\n+    flag(has_nonstatic_fields               , 1 << 1) \/* for sizing with UseCompressedOops *\/ \\\n+    flag(should_verify_class                , 1 << 2) \/* allow caching of preverification *\/ \\\n+    flag(unused                             , 1 << 3) \/* not currently used *\/ \\\n+    flag(is_contended                       , 1 << 4) \/* marked with contended annotation *\/ \\\n+    flag(has_nonstatic_concrete_methods     , 1 << 5) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n+    flag(declares_nonstatic_concrete_methods, 1 << 6) \/* directly declares non-static, concrete methods *\/ \\\n+    flag(has_been_redefined                 , 1 << 7) \/* class has been redefined *\/ \\\n+    flag(shared_loading_failed              , 1 << 8) \/* class has been loaded from shared archive *\/ \\\n+    flag(is_scratch_class                   , 1 << 9) \/* class is the redefined scratch class *\/ \\\n+    flag(is_shared_boot_class               , 1 << 10) \/* defining class loader is boot class loader *\/ \\\n+    flag(is_shared_platform_class           , 1 << 11) \/* defining class loader is platform class loader *\/ \\\n+    flag(is_shared_app_class                , 1 << 12) \/* defining class loader is app class loader *\/ \\\n+    flag(has_contended_annotations          , 1 << 13) \/* has @Contended annotation *\/ \\\n+    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(is_empty_inline_type               , 1 << 15) \/* empty inline type (*) *\/ \\\n+    flag(is_naturally_atomic                , 1 << 16) \/* loaded\/stored in one instruction *\/ \\\n+    flag(is_declared_atomic                 , 1 << 17) \/* Listed -XX:ForceNonTearable=clist option *\/ \\\n+    flag(carries_value_modifier             , 1 << 18) \/* the class or one of its super types has the ACC_VALUE modifier *\/ \\\n+    flag(carries_identity_modifier          , 1 << 19) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/\n+\n+  \/* (*) An inline type is considered empty if it contains no non-static fields or\n+     if it contains only empty inline fields. Note that JITs have a slightly different\n+     definition: empty inline fields must be flattened otherwise the container won't\n+     be considered empty *\/\n+\n+#define IK_FLAGS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    IK_FLAGS_DO(IK_FLAGS_ENUM_NAME)\n+  };\n+#undef IK_FLAGS_ENUM_NAME\n+\n+  u2 shared_loader_type_bits() const {\n+    return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;\n+  }\n+\n+  \/\/ These flags are write-once before the class is published and then read-only so don't require atomic updates.\n+  u4 _flags;\n+\n+ public:\n+\n+  InstanceKlassMiscStatus() : _flags(0) {}\n+\n+  \/\/ Create getters and setters for the flag values.\n+#define IK_FLAGS_GET(name, ignore)          \\\n+  bool name() const { return (_flags & _misc_##name) != 0; }\n+  IK_FLAGS_DO(IK_FLAGS_GET)\n+#undef IK_FLAGS_GET\n+\n+#define IK_FLAGS_SET(name, ignore)   \\\n+  void set_##name(bool b) {         \\\n+    assert(!name(), \"set once\");    \\\n+    if (b) _flags |= _misc_##name; \\\n+  }\n+  IK_FLAGS_DO(IK_FLAGS_SET)\n+#undef IK_FLAGS_SET\n+\n+  bool is_shared_unregistered_class() const {\n+    return (_flags & shared_loader_type_bits()) == 0;\n+  }\n+\n+  void set_shared_class_loader_type(s2 loader_type);\n+\n+  void assign_class_loader_type(const ClassLoaderData* cld);\n+\n+  u4 flags() const { return _flags; }\n+\n+  static u4 is_empty_inline_type_value() {\n+    return _misc_is_empty_inline_type;\n+  }\n+};\n+\n+#endif \/\/ SHARE_OOPS_INSTANCEKLASSMISCSTATUS_HPP\n","filename":"src\/hotspot\/share\/oops\/instanceKlassMiscStatus.hpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -31,1 +30,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"jvm_io.h\"\n@@ -68,4 +68,0 @@\n-void Klass::replace_java_mirror(oop mirror) {\n-  _java_mirror.replace(mirror);\n-}\n-\n@@ -794,1 +790,1 @@\n-    guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), \"should be instance\");\n+    guarantee(java_lang_Class::is_instance(java_mirror_no_keepalive()), \"should be instance\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,1 +275,2 @@\n-  void replace_java_mirror(oop mirror);\n+  OopHandle java_mirror_handle() const { return _java_mirror; }\n+  void swap_java_mirror_handle(OopHandle& mirror) { _java_mirror.swap(mirror); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -33,0 +32,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,11 +603,7 @@\n-  \/\/ Grab a lock here to prevent multiple\n-  \/\/ MethodData*s from being created.\n-  MutexLocker ml(THREAD, MethodData_lock);\n-  if (method->method_data() == NULL) {\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      CompileBroker::log_metaspace_failure();\n-      ClassLoaderDataGraph::set_metaspace_oom(true);\n-      return;   \/\/ return the exception (which is cleared)\n-    }\n+  ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n+  MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CompileBroker::log_metaspace_failure();\n+    ClassLoaderDataGraph::set_metaspace_oom(true);\n+    return;   \/\/ return the exception (which is cleared)\n+  }\n@@ -615,8 +611,11 @@\n-    method->set_method_data(method_data);\n-    if (PrintMethodData && (Verbose || WizardMode)) {\n-      ResourceMark rm(THREAD);\n-      tty->print(\"build_profiling_method_data for \");\n-      method->print_name(tty);\n-      tty->cr();\n-      \/\/ At the end of the run, the MDO, full of data, will be dumped.\n-    }\n+  if (!Atomic::replace_if_null(&method->_method_data, method_data)) {\n+    MetadataFactory::free_metadata(loader_data, method_data);\n+    return;\n+  }\n+\n+  if (PrintMethodData && (Verbose || WizardMode)) {\n+    ResourceMark rm(THREAD);\n+    tty->print(\"build_profiling_method_data for \");\n+    method->print_name(tty);\n+    tty->cr();\n+    \/\/ At the end of the run, the MDO, full of data, will be dumped.\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -747,1 +747,2 @@\n-\n+  \/\/ Some special methods don't need to be findable by nmethod iterators and are permanent.\n+  bool can_be_allocated_in_NonNMethod_space() const { return is_method_handle_intrinsic(); }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+  assert(!THREAD->owns_locks(), \"Should not own any locks\");\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,4 +102,1 @@\n-  ResetNoHandleMark rnm; \/\/ Might be called from LEAF\/QUICK ENTRY\n-  HandleMark hm(current);\n-  Handle object(current, this);\n-  return ObjectSynchronizer::FastHashCode(current, object());\n+  return ObjectSynchronizer::FastHashCode(current, this);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  inline bool fast_no_hash_check();\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -374,0 +374,8 @@\n+\/\/ This checks fast simple case of whether the oop has_no_hash,\n+\/\/ to optimize JVMTI table lookup.\n+bool oopDesc::fast_no_hash_check() {\n+  markWord mrk = mark_acquire();\n+  assert(!mrk.is_marked(), \"should never be marked\");\n+  return mrk.is_unlocked() && mrk.has_no_hash();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-struct OopFlow : public ResourceObj {\n+struct OopFlow : public ArenaObj {\n@@ -347,4 +347,20 @@\n-      if( t->isa_rawptr() && C->cfg()->_raw_oops.member(def) ) {\n-        def->dump();\n-        n->dump();\n-        assert(false, \"there should be a oop in OopMap instead of a live raw oop at safepoint\");\n+      if (t->isa_rawptr()) {\n+        ResourceMark rm;\n+        Unique_Node_List worklist;\n+        worklist.push(def);\n+        for (uint i = 0; i < worklist.size(); i++) {\n+          Node* m = worklist.at(i);\n+          if (C->cfg()->_raw_oops.member(m)) {\n+            def->dump();\n+            m->dump();\n+            n->dump();\n+            assert(false, \"there should be an oop in OopMap instead of a live raw oop at safepoint\");\n+          }\n+          \/\/ Check users as well because def might be spilled\n+          for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n+            Node* u = m->fast_out(j);\n+            if ((u->is_SpillCopy() && u->in(1) == m) || u->is_Phi()) {\n+              worklist.push(u);\n+            }\n+          }\n+        }\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -636,7 +636,0 @@\n-  product(intx, AliasLevel,     3,                                          \\\n-          \"(Deprecated) 0 for no aliasing, \"                                \\\n-          \"1 for oop\/field\/static\/array split, \"                            \\\n-          \"2 for class split, 3 for unique instances\")                      \\\n-          range(0, 3)                                                       \\\n-          constraint(AliasLevelConstraintFunc,AfterErgo)                    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -687,2 +687,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -748,0 +748,1 @@\n+  case vmIntrinsics::_chacha20Block:\n@@ -750,0 +751,1 @@\n+  case vmIntrinsics::_poly1305_processBlocks:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class CallGenerator : public ResourceObj {\n+class CallGenerator : public ArenaObj {\n@@ -98,1 +98,1 @@\n-    return ResourceObj::operator new(size, C->comp_arena());\n+    return ArenaObj::operator new(size, C->comp_arena());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"opto\/regalloc.hpp\"\n@@ -628,1 +629,1 @@\n-          assert(opaq->Opcode() == Op_Opaque1, \"\");\n+          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n@@ -2947,3 +2948,2 @@\n-  return ( in(0)->is_CatchProj() && in(0)->in(0)->in(1) == in(1) )\n-    ? this\n-    : call->in(TypeFunc::Parms);\n+  return (in(0)->is_CatchProj() && in(0)->in(0)->is_Catch() &&\n+          in(0)->in(0)->in(1) == in(1)) ? this : call->in(TypeFunc::Parms);\n@@ -2980,0 +2980,22 @@\n+\n+#ifndef PRODUCT\n+void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  st->print(\"blackhole \");\n+  bool first = true;\n+  for (uint i = 0; i < req(); i++) {\n+    Node* n = in(i);\n+    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        st->print(\", \");\n+      }\n+      char buf[128];\n+      ra->dump_register(n, buf);\n+      st->print(\"%s\", buf);\n+    }\n+  }\n+  st->cr();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class     BlackholeNode;\n@@ -611,0 +612,24 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MultiNode {\n+public:\n+  BlackholeNode(Node* ctrl) : MultiNode(1) {\n+    init_req(TypeFunc::Control, ctrl);\n+  }\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  virtual const Type* bottom_type() const { return TypeTuple::MEMBAR; }\n+\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid any redundant register moves\n+    \/\/ for blackhole inputs.\n+    return RegMask::All;\n+  }\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+#endif\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-macro(Opaque2)\n+macro(OpaqueZeroTripGuard)\n@@ -511,0 +511,2 @@\n+macro(VectorCastF2HF)\n+macro(VectorCastHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -25,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -39,0 +39,1 @@\n+#include \"jvm_io.h\"\n@@ -85,1 +86,0 @@\n-\n@@ -711,2 +711,1 @@\n-  Init(::AliasLevel);\n-\n+  Init(\/*do_aliasing=*\/ true);\n@@ -963,1 +962,1 @@\n-  Init(\/*AliasLevel=*\/ 0);\n+  Init(\/*do_aliasing=*\/ false);\n@@ -985,1 +984,2 @@\n-void Compile::Init(int aliaslevel) {\n+void Compile::Init(bool aliasing) {\n+  _do_aliasing = aliasing;\n@@ -1082,10 +1082,0 @@\n-  \/\/ \/\/ -- Initialize types before each compile --\n-  \/\/ \/\/ Update cached type information\n-  \/\/ if( _method && _method->constants() )\n-  \/\/   Type::update_loaded_types(_method, _method->constants());\n-\n-  \/\/ Init alias_type map.\n-  if (!do_escape_analysis() && aliaslevel == 3) {\n-    aliaslevel = 2;  \/\/ No unique types without escape analysis\n-  }\n-  _AliasLevel = aliaslevel;\n@@ -1328,0 +1318,1 @@\n+  assert(do_aliasing(), \"Aliasing should be enabled\");\n@@ -1369,1 +1360,1 @@\n-  } else if( ta && _AliasLevel >= 2 ) {\n+  } else if (ta) {\n@@ -1447,1 +1438,1 @@\n-  if( to && _AliasLevel >= 2 && to != TypeOopPtr::BOTTOM ) {\n+  if (to && to != TypeOopPtr::BOTTOM) {\n@@ -1550,25 +1541,0 @@\n-  \/\/ Flatten all to bottom for now\n-  switch( _AliasLevel ) {\n-  case 0:\n-    tj = TypePtr::BOTTOM;\n-    break;\n-  case 1:                       \/\/ Flatten to: oop, static, field or array\n-    switch (tj->base()) {\n-    \/\/case Type::AryPtr: tj = TypeAryPtr::RANGE;    break;\n-    case Type::RawPtr:   tj = TypeRawPtr::BOTTOM;   break;\n-    case Type::AryPtr:   \/\/ do not distinguish arrays at all\n-    case Type::InstPtr:  tj = TypeInstPtr::BOTTOM;  break;\n-    case Type::KlassPtr:\n-    case Type::AryKlassPtr:\n-    case Type::InstKlassPtr: tj = TypeInstKlassPtr::OBJECT; break;\n-    case Type::AnyPtr:   tj = TypePtr::BOTTOM;      break;  \/\/ caller checks it\n-    default: ShouldNotReachHere();\n-    }\n-    break;\n-  case 2:                       \/\/ No collapsing at level 2; keep all splits\n-  case 3:                       \/\/ No collapsing at level 3; keep all splits\n-    break;\n-  default:\n-    Unimplemented();\n-  }\n-\n@@ -1681,1 +1647,1 @@\n-  if (_AliasLevel == 0)\n+  if (!do_aliasing()) {\n@@ -1683,0 +1649,1 @@\n+  }\n@@ -3698,1 +3665,0 @@\n-  case Op_Opaque2:              \/\/ Remove Opaque Nodes before matching\n@@ -4758,0 +4724,55 @@\n+\/\/------------------------------verify_bidirectional_edges---------------------\n+\/\/ For each input edge to a node (ie - for each Use-Def edge), verify that\n+\/\/ there is a corresponding Def-Use edge.\n+void Compile::verify_bidirectional_edges(Unique_Node_List &visited) {\n+  \/\/ Allocate stack of size C->live_nodes()\/16 to avoid frequent realloc\n+  uint stack_size = live_nodes() >> 4;\n+  Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n+  nstack.push(_root);\n+\n+  while (nstack.size() > 0) {\n+    Node* n = nstack.pop();\n+    if (visited.member(n)) {\n+      continue;\n+    }\n+    visited.push(n);\n+\n+    \/\/ Walk over all input edges, checking for correspondence\n+    uint length = n->len();\n+    for (uint i = 0; i < length; i++) {\n+      Node* in = n->in(i);\n+      if (in != NULL && !visited.member(in)) {\n+        nstack.push(in); \/\/ Put it on stack\n+      }\n+      if (in != NULL && !in->is_top()) {\n+        \/\/ Count instances of `next`\n+        int cnt = 0;\n+        for (uint idx = 0; idx < in->_outcnt; idx++) {\n+          if (in->_out[idx] == n) {\n+            cnt++;\n+          }\n+        }\n+        assert(cnt > 0, \"Failed to find Def-Use edge.\");\n+        \/\/ Check for duplicate edges\n+        \/\/ walk the input array downcounting the input edges to n\n+        for (uint j = 0; j < length; j++) {\n+          if (n->in(j) == in) {\n+            cnt--;\n+          }\n+        }\n+        assert(cnt == 0, \"Mismatched edge count.\");\n+      } else if (in == NULL) {\n+        assert(i == 0 || i >= n->req() ||\n+               n->is_Region() || n->is_Phi() || n->is_ArrayCopy() ||\n+               (n->is_Allocate() && i >= AllocateNode::InlineType) ||\n+               (n->is_Unlock() && i == (n->req() - 1)) ||\n+               (n->is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n+              \"only region, phi, arraycopy, allocate, unlock or membar nodes have null data edges\");\n+      } else {\n+        assert(in->is_top(), \"sanity\");\n+        \/\/ Nothing to check.\n+      }\n+    }\n+  }\n+}\n+\n@@ -4764,2 +4785,3 @@\n-    \/\/ Call recursive graph walk to check edges\n-    _root->verify_edges(visited);\n+\n+    \/\/ Call graph walk to check edges\n+    verify_bidirectional_edges(visited);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":69,"deletions":47,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  int                   _AliasLevel;            \/\/ Locally-adjusted version of AliasLevel flag.\n+  bool                  _do_aliasing;           \/\/ True if we intend to do aliasing\n@@ -625,1 +625,1 @@\n-  int               AliasLevel() const           { return _AliasLevel; }\n+  bool              do_aliasing() const          { return _do_aliasing; }\n@@ -1129,3 +1129,1 @@\n-  void Init(int aliaslevel);                     \/\/ Prepare for a single compilation\n-  int  Inline_Warm();                            \/\/ Find more inlining work.\n-  void Finish_Warm();                            \/\/ Give up on further inlines.\n+  void Init(bool aliasing);                      \/\/ Prepare for a single compilation\n@@ -1192,0 +1190,3 @@\n+  \/\/ Verify bi-directional correspondence of edges\n+  void verify_bidirectional_edges(Unique_Node_List &visited);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -295,0 +295,1 @@\n+  GrowableArray<JavaObjectNode*> jobj_worklist;\n@@ -296,0 +297,1 @@\n+  bool found_nsr_alloc = false;\n@@ -306,1 +308,3 @@\n-        alloc_worklist.append(ptn->ideal_node());\n+        jobj_worklist.push(ptn);\n+      } else {\n+        found_nsr_alloc = true;\n@@ -311,0 +315,12 @@\n+  \/\/ Propagate NSR (Not Scalar Replaceable) state.\n+  if (found_nsr_alloc) {\n+    find_scalar_replaceable_allocs(jobj_worklist);\n+  }\n+\n+  for (int next = 0; next < jobj_worklist.length(); ++next) {\n+    JavaObjectNode* jobj = jobj_worklist.at(next);\n+    if (jobj->scalar_replaceable()) {\n+      alloc_worklist.append(jobj->ideal_node());\n+    }\n+  }\n+\n@@ -353,2 +369,2 @@\n-  if (has_scalar_replaceable_candidates &&\n-      C->AliasLevel() >= 3 && EliminateAllocations) {\n+  if (has_scalar_replaceable_candidates && EliminateAllocations) {\n+    assert(C->do_aliasing(), \"Aliasing should be enabled\");\n@@ -372,2 +388,0 @@\n-    } else if(C->AliasLevel() < 3) {\n-      tty->print(\" since AliasLevel < 3 ===\");\n@@ -1185,0 +1199,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"poly1305_processBlocks\") == 0 ||\n@@ -1186,0 +1201,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"chacha20Block\") == 0 ||\n@@ -1907,9 +1923,13 @@\n-      \/\/ 2. An object is not scalar replaceable if the field into which it is\n-      \/\/ stored has multiple bases one of which is null.\n-      if (field->base_count() > 1) {\n-        for (BaseIterator i(field); i.has_next(); i.next()) {\n-          PointsToNode* base = i.get();\n-          if (base == null_obj) {\n-            set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with potentially null base\"));\n-            return;\n-          }\n+      for (BaseIterator i(field); i.has_next(); i.next()) {\n+        PointsToNode* base = i.get();\n+        \/\/ 2. An object is not scalar replaceable if the field into which it is\n+        \/\/ stored has multiple bases one of which is null.\n+        if ((base == null_obj) && (field->base_count() > 1)) {\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with potentially null base\"));\n+          return;\n+        }\n+        \/\/ 2.5. An object is not scalar replaceable if the field into which it is\n+        \/\/ stored has NSR base.\n+        if (!base->scalar_replaceable()) {\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with NSR base\"));\n+          return;\n@@ -2005,0 +2025,30 @@\n+\/\/ Propagate NSR (Not scalar replaceable) state.\n+void ConnectionGraph::find_scalar_replaceable_allocs(GrowableArray<JavaObjectNode*>& jobj_worklist) {\n+  int jobj_length = jobj_worklist.length();\n+  bool found_nsr_alloc = true;\n+  while (found_nsr_alloc) {\n+    found_nsr_alloc = false;\n+    for (int next = 0; next < jobj_length; ++next) {\n+      JavaObjectNode* jobj = jobj_worklist.at(next);\n+      for (UseIterator i(jobj); (jobj->scalar_replaceable() && i.has_next()); i.next()) {\n+        PointsToNode* use = i.get();\n+        if (use->is_Field()) {\n+          FieldNode* field = use->as_Field();\n+          assert(field->is_oop() && field->scalar_replaceable(), \"sanity\");\n+          assert(field->offset() != Type::OffsetBot, \"sanity\");\n+          for (BaseIterator i(field); i.has_next(); i.next()) {\n+            PointsToNode* base = i.get();\n+            \/\/ An object is not scalar replaceable if the field into which\n+            \/\/ it is stored has NSR base.\n+            if ((base != null_obj) && !base->scalar_replaceable()) {\n+              set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with NSR base\"));\n+              found_nsr_alloc = true;\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":64,"deletions":14,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-  if (load_alias_idx == Compile::AliasIdxBot && C->AliasLevel() > 0 &&\n+  if (load_alias_idx == Compile::AliasIdxBot && C->do_aliasing() &&\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,1 +357,2 @@\n-                     MemNode::MemOrd mo) {\n+                     MemNode::MemOrd mo,\n+                     LoadNode::ControlDependency control_dependency) {\n@@ -363,1 +364,1 @@\n-  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, LoadNode::DependsOnlyOnTest, require_atomic_access);\n+  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, require_atomic_access);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -224,1 +224,3 @@\n-             bool require_atomic_access = false, MemNode::MemOrd mo = MemNode::unordered);\n+             bool require_atomic_access = false,\n+             MemNode::MemOrd mo = MemNode::unordered,\n+             LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -736,0 +736,1 @@\n+    ctrl->in(0)->in(1)->in(1)->in(1) != igvn->C->top() &&\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -480,2 +480,2 @@\n-  case vmIntrinsics::_extentLocalCache:          return inline_native_extentLocalCache();\n-  case vmIntrinsics::_setExtentLocalCache:       return inline_native_setExtentLocalCache();\n+  case vmIntrinsics::_scopedValueCache:          return inline_native_scopedValueCache();\n+  case vmIntrinsics::_setScopedValueCache:       return inline_native_setScopedValueCache();\n@@ -621,0 +621,2 @@\n+  case vmIntrinsics::_chacha20Block:\n+    return inline_chacha20Block();\n@@ -625,0 +627,2 @@\n+  case vmIntrinsics::_poly1305_processBlocks:\n+    return inline_poly1305_processBlocks();\n@@ -1801,2 +1805,0 @@\n-#define FN_PTR(f) CAST_FROM_FN_PTR(address, f)\n-    \/\/ These intrinsics are not properly supported on all hardware\n@@ -1807,1 +1809,1 @@\n-      runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   \"SIN\");\n+      runtime_math(OptoRuntime::Math_D_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dsin),   \"SIN\");\n@@ -1811,1 +1813,1 @@\n-      runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   \"COS\");\n+      runtime_math(OptoRuntime::Math_D_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dcos),   \"COS\");\n@@ -1815,1 +1817,5 @@\n-      runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), \"TAN\");\n+      runtime_math(OptoRuntime::Math_D_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dtan), \"TAN\");\n+  case vmIntrinsics::_dexp:\n+    return StubRoutines::dexp() != NULL ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  \"dexp\") :\n+      runtime_math(OptoRuntime::Math_D_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dexp),  \"EXP\");\n@@ -1819,1 +1825,1 @@\n-      runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   \"LOG\");\n+      runtime_math(OptoRuntime::Math_D_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dlog),   \"LOG\");\n@@ -1823,1 +1829,1 @@\n-      runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), \"LOG10\");\n+      runtime_math(OptoRuntime::Math_D_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), \"LOG10\");\n@@ -1825,1 +1831,0 @@\n-    \/\/ These intrinsics are supported on all hardware\n@@ -1839,6 +1844,0 @@\n-  case vmIntrinsics::_dexp:\n-    return StubRoutines::dexp() != NULL ?\n-      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  \"dexp\") :\n-      runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  \"EXP\");\n-#undef FN_PTR\n-\n@@ -3570,1 +3569,1 @@\n-Node* LibraryCallKit::extentLocalCache_helper() {\n+Node* LibraryCallKit::scopedValueCache_helper() {\n@@ -3577,3 +3576,7 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::extentLocalCache_offset()));\n-  return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n-        TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopedValueCache_offset()));\n+  \/\/ We cannot use immutable_memory() because we might flip onto a\n+  \/\/ different carrier thread, at which point we'll need to use that\n+  \/\/ carrier thread's cache.\n+  \/\/ return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+  \/\/       TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  return make_load(NULL, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered);\n@@ -3582,2 +3585,2 @@\n-\/\/------------------------inline_native_extentLocalCache------------------\n-bool LibraryCallKit::inline_native_extentLocalCache() {\n+\/\/------------------------inline_native_scopedValueCache------------------\n+bool LibraryCallKit::inline_native_scopedValueCache() {\n@@ -3588,1 +3591,1 @@\n-  \/\/ Because we create the extentLocal cache lazily we have to make the\n+  \/\/ Because we create the scopedValue cache lazily we have to make the\n@@ -3592,1 +3595,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -3598,2 +3601,2 @@\n-\/\/------------------------inline_native_setExtentLocalCache------------------\n-bool LibraryCallKit::inline_native_setExtentLocalCache() {\n+\/\/------------------------inline_native_setScopedValueCache------------------\n+bool LibraryCallKit::inline_native_setScopedValueCache() {\n@@ -3601,1 +3604,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -5689,1 +5692,1 @@\n-  if (C->AliasLevel() == 0)  return NULL;  \/\/ no MergeMems around\n+  if (!C->do_aliasing())     return NULL;  \/\/ no MergeMems around\n@@ -7287,0 +7290,30 @@\n+\/\/------------------------------inline_chacha20Block\n+bool LibraryCallKit::inline_chacha20Block() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseChaCha20Intrinsics, \"need ChaCha20 intrinsics support\");\n+\n+  stubAddr = StubRoutines::chacha20Block();\n+  stubName = \"chacha20Block\";\n+\n+  Node* state          = argument(0);\n+  Node* result         = argument(1);\n+\n+  state = must_be_not_null(state, true);\n+  result = must_be_not_null(result, true);\n+\n+  Node* state_start  = array_element_address(state, intcon(0), T_INT);\n+  assert(state_start, \"state is NULL\");\n+  Node* result_start  = array_element_address(result, intcon(0), T_BYTE);\n+  assert(result_start, \"result is NULL\");\n+\n+  Node* cc20Blk = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::chacha20Block_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  state_start, result_start);\n+  \/\/ return key stream length (int)\n+  Node* retvalue = _gvn.transform(new ProjNode(cc20Blk, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n@@ -7354,0 +7387,36 @@\n+bool LibraryCallKit::inline_poly1305_processBlocks() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UsePolyIntrinsics, \"need Poly intrinsics support\");\n+  assert(callee()->signature()->size() == 5, \"poly1305_processBlocks has %d parameters\", callee()->signature()->size());\n+  stubAddr = StubRoutines::poly1305_processBlocks();\n+  stubName = \"poly1305_processBlocks\";\n+\n+  if (!stubAddr) return false;\n+  null_check_receiver();  \/\/ null-check receiver\n+  if (stopped())  return true;\n+\n+  Node* input = argument(1);\n+  Node* input_offset = argument(2);\n+  Node* len = argument(3);\n+  Node* alimbs = argument(4);\n+  Node* rlimbs = argument(5);\n+\n+  input = must_be_not_null(input, true);\n+  alimbs = must_be_not_null(alimbs, true);\n+  rlimbs = must_be_not_null(rlimbs, true);\n+\n+  Node* input_start = array_element_address(input, input_offset, T_BYTE);\n+  assert(input_start, \"input array is NULL\");\n+  Node* acc_start = array_element_address(alimbs, intcon(0), T_LONG);\n+  assert(acc_start, \"acc array is NULL\");\n+  Node* r_start = array_element_address(rlimbs, intcon(0), T_LONG);\n+  assert(r_start, \"r array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::poly1305_processBlocks_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 input_start, len, acc_start, r_start);\n+  return true;\n+}\n+\n@@ -7393,1 +7462,1 @@\n-  Node* digest_length = NULL;\n+  Node* block_size = NULL;\n@@ -7427,2 +7496,2 @@\n-    digest_length = get_digest_length_from_digest_object(digestBase_obj);\n-    if (digest_length == NULL) return false;\n+    block_size = get_block_size_from_digest_object(digestBase_obj);\n+    if (block_size == NULL) return false;\n@@ -7441,1 +7510,1 @@\n-  if (digest_length == NULL) {\n+  if (block_size == NULL) {\n@@ -7448,1 +7517,1 @@\n-                             src_start, state, digest_length);\n+                             src_start, state, block_size);\n@@ -7560,1 +7629,1 @@\n-  Node* digest_length = NULL;\n+  Node* block_size = NULL;\n@@ -7562,2 +7631,2 @@\n-    digest_length = get_digest_length_from_digest_object(digest_obj);\n-    if (digest_length == NULL) return false;\n+    block_size = get_block_size_from_digest_object(digest_obj);\n+    if (block_size == NULL) return false;\n@@ -7568,1 +7637,1 @@\n-  if (digest_length == NULL) {\n+  if (block_size == NULL) {\n@@ -7577,1 +7646,1 @@\n-                             src_start, state, digest_length, ofs, limit);\n+                             src_start, state, block_size, ofs, limit);\n@@ -7734,5 +7803,5 @@\n-\/\/------------------------------get_digest_length_from_sha3_object----------------------------------\n-Node * LibraryCallKit::get_digest_length_from_digest_object(Node *digest_object) {\n-  Node* digest_length = load_field_from_object(digest_object, \"digestLength\", \"I\");\n-  assert (digest_length != NULL, \"sanity\");\n-  return digest_length;\n+\/\/------------------------------get_block_size_from_sha3_object----------------------------------\n+Node * LibraryCallKit::get_block_size_from_digest_object(Node *digest_object) {\n+  Node* block_size = load_field_from_object(digest_object, \"blockSize\", \"I\");\n+  assert (block_size != NULL, \"sanity\");\n+  return block_size;\n@@ -8163,0 +8232,8 @@\n+  \/\/ Blackhole node pinches only the control, not memory. This allows\n+  \/\/ the blackhole to be pinned in the loop that computes blackholed\n+  \/\/ values, but have no other side effects, like breaking the optimizations\n+  \/\/ across the blackhole.\n+\n+  Node* bh = _gvn.transform(new BlackholeNode(control()));\n+  set_control(_gvn.transform(new ProjNode(bh, TypeFunc::Control)));\n+\n@@ -8164,1 +8241,0 @@\n-  Node* bh = insert_mem_bar(Op_Blackhole);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":120,"deletions":44,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -264,3 +264,3 @@\n-  bool inline_native_extentLocalCache();\n-  Node* extentLocalCache_helper();\n-  bool inline_native_setExtentLocalCache();\n+  bool inline_native_scopedValueCache();\n+  Node* scopedValueCache_helper();\n+  bool inline_native_setScopedValueCache();\n@@ -317,0 +317,1 @@\n+  bool inline_chacha20Block();\n@@ -319,0 +320,1 @@\n+  bool inline_poly1305_processBlocks();\n@@ -325,1 +327,1 @@\n-  Node* get_digest_length_from_digest_object(Node *digestBase_object);\n+  Node* get_block_size_from_digest_object(Node *digestBase_object);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1315,8 +1315,0 @@\n-\n-  \/\/ Enum to determine the action to be performed in create_new_if_for_predicate() when processing phis of UCT regions.\n-  enum class UnswitchingAction {\n-    None,            \/\/ No special action.\n-    FastLoopCloning, \/\/ Need to clone nodes for the fast loop.\n-    SlowLoopRewiring \/\/ Need to rewire nodes for the slow loop.\n-  };\n-\n@@ -1325,2 +1317,2 @@\n-                                        int opcode, bool if_cont_is_true_proj = true, Node_List* old_new = NULL,\n-                                        UnswitchingAction unswitching_action = UnswitchingAction::None);\n+                                        int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n+                                        bool if_cont_is_true_proj = true);\n@@ -1328,2 +1320,9 @@\n-  \/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate.\n-  Node* clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new);\n+ private:\n+  \/\/ Helper functions for create_new_if_for_predicate()\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Unique_Node_List find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl);\n+  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Dict clone_nodes(const Node_List& list_to_clone);\n+  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n+                                   const Dict& old_new_mapping);\n+  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n@@ -1331,0 +1330,1 @@\n+ public:\n@@ -1529,6 +1529,0 @@\n-  \/\/ Reorganize offset computations to lower register pressure.\n-  \/\/ Mostly prevent loop-fallout uses of the pre-incremented trip counter\n-  \/\/ (which are then alive with the post-incremented trip counter\n-  \/\/ forcing an extra register move)\n-  void reorg_offsets( IdealLoopTree *loop );\n-\n@@ -1655,2 +1649,2 @@\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                               Node_List* old_new = NULL);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n+                                               Deoptimization::DeoptReason reason, bool slow_loop);\n@@ -1665,4 +1659,2 @@\n-#ifdef ASSERT\n-  void dump_real_LCA(Node* early, Node* wrong_lca);\n-  bool check_idom_chains_intersection(const Node* n, uint& idom_idx_new, uint& idom_idx_other, const Node_List* nodes_seen) const;\n-#endif\n+  DEBUG_ONLY(void dump_idoms(Node* early, Node* wrong_lca);)\n+  NOT_PRODUCT(void dump_idoms_in_reverse(const Node* n, const Node_List& idom_list) const;)\n@@ -1681,1 +1673,3 @@\n-  void dump_idom(Node* n) const;\n+  void dump_idom(Node* n) const { dump_idom(n, 1000); } \/\/ For debugging\n+  void dump_idom(Node* n, uint count) const;\n+  void get_idoms(Node* n, uint count, Unique_Node_List& idoms) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1088,2 +1088,1 @@\n-  if (n->is_Opaque1() ||     \/\/ Opaque nodes cannot be mod'd\n-      n_op == Op_Opaque2) {\n+  if (n->is_Opaque1()) { \/\/ Opaque nodes cannot be mod'd\n@@ -1596,8 +1595,0 @@\n-\n-  \/\/ Check for Opaque2's who's loop has disappeared - who's input is in the\n-  \/\/ same loop nest as their output.  Remove 'em, they are no longer useful.\n-  if( n_op == Op_Opaque2 &&\n-      n->in(1) != NULL &&\n-      get_loop(get_ctrl(n)) == get_loop(get_ctrl(n->in(1))) ) {\n-    _igvn.replace_node( n, n->in(1) );\n-  }\n@@ -1742,3 +1733,0 @@\n-  bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n-                            n->in(1)->bottom_type()->isa_rawptr() &&\n-                            !n->bottom_type()->isa_rawptr();\n@@ -1751,1 +1739,0 @@\n-      !is_raw_to_oop_cast && \/\/ don't extend live ranges of raw oops\n@@ -2334,3 +2321,3 @@\n-static void clone_outer_loop_helper(Node* n, const IdealLoopTree *loop, const IdealLoopTree* outer_loop,\n-                                    const Node_List &old_new, Unique_Node_List& wq, PhaseIdealLoop* phase,\n-                                    bool check_old_new) {\n+static void collect_nodes_in_outer_loop_not_reachable_from_sfpt(Node* n, const IdealLoopTree *loop, const IdealLoopTree* outer_loop,\n+                                                                const Node_List &old_new, Unique_Node_List& wq, PhaseIdealLoop* phase,\n+                                                                bool check_old_new) {\n@@ -2343,11 +2330,13 @@\n-      assert(!loop->is_member(u_loop), \"can be in outer loop or out of both loops only\");\n-      if (outer_loop->is_member(u_loop)) {\n-        wq.push(u);\n-      } else {\n-        \/\/ nodes pinned with control in the outer loop but not referenced from the safepoint must be moved out of\n-        \/\/ the outer loop too\n-        Node* u_c = u->in(0);\n-        if (u_c != NULL) {\n-          IdealLoopTree* u_c_loop = phase->get_loop(u_c);\n-          if (outer_loop->is_member(u_c_loop) && !loop->is_member(u_c_loop)) {\n-            wq.push(u);\n+      assert(!loop->is_member(u_loop) || !loop->_body.contains(u), \"can be in outer loop or out of both loops only\");\n+      if (!loop->is_member(u_loop)) {\n+        if (outer_loop->is_member(u_loop)) {\n+          wq.push(u);\n+        } else {\n+          \/\/ nodes pinned with control in the outer loop but not referenced from the safepoint must be moved out of\n+          \/\/ the outer loop too\n+          Node* u_c = u->in(0);\n+          if (u_c != NULL) {\n+            IdealLoopTree* u_c_loop = phase->get_loop(u_c);\n+            if (outer_loop->is_member(u_c_loop) && !loop->is_member(u_c_loop)) {\n+              wq.push(u);\n+            }\n@@ -2472,1 +2461,6 @@\n-      clone_outer_loop_helper(old, loop, outer_loop, old_new, wq, this, true);\n+      collect_nodes_in_outer_loop_not_reachable_from_sfpt(old, loop, outer_loop, old_new, wq, this, true);\n+    }\n+\n+    for (uint i = 0; i < loop->_body.size(); i++) {\n+      Node* old = loop->_body.at(i);\n+      collect_nodes_in_outer_loop_not_reachable_from_sfpt(old, loop, outer_loop, old_new, wq, this, true);\n@@ -2477,1 +2471,1 @@\n-      clone_outer_loop_helper(inner_out, loop, outer_loop, old_new, wq, this, true);\n+      collect_nodes_in_outer_loop_not_reachable_from_sfpt(inner_out, loop, outer_loop, old_new, wq, this, true);\n@@ -2488,1 +2482,1 @@\n-      clone_outer_loop_helper(n, loop, outer_loop, old_new, wq, this, false);\n+      collect_nodes_in_outer_loop_not_reachable_from_sfpt(n, loop, outer_loop, old_new, wq, this, false);\n@@ -4281,86 +4275,0 @@\n-\n-\/\/------------------------------reorg_offsets----------------------------------\n-\/\/ Reorganize offset computations to lower register pressure.  Mostly\n-\/\/ prevent loop-fallout uses of the pre-incremented trip counter (which are\n-\/\/ then alive with the post-incremented trip counter forcing an extra\n-\/\/ register move):\n-\/\/\n-\/\/     iv Phi            iv Phi\n-\/\/       |                 |\n-\/\/       |                AddI (+stride)\n-\/\/       |                 |\n-\/\/       |              Opaque2  # Blocks IGVN from folding these nodes until loop opts are over.\n-\/\/       |     ====>       |\n-\/\/       |                AddI (-stride)\n-\/\/       |                 |\n-\/\/       |               CastII  # Preserve type of iv Phi\n-\/\/       |                 |\n-\/\/   Outside Use       Outside Use\n-\/\/\n-void PhaseIdealLoop::reorg_offsets(IdealLoopTree *loop) {\n-  \/\/ Perform it only for canonical counted loops.\n-  \/\/ Loop's shape could be messed up by iteration_split_impl.\n-  if (!loop->_head->is_CountedLoop())\n-    return;\n-  if (!loop->_head->as_Loop()->is_valid_counted_loop(T_INT))\n-    return;\n-\n-  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n-  CountedLoopEndNode *cle = cl->loopexit();\n-  Node *exit = cle->proj_out(false);\n-  Node *phi = cl->phi();\n-\n-  \/\/ Check for the special case when using the pre-incremented trip-counter on\n-  \/\/ the fall-out  path (forces the pre-incremented  and post-incremented trip\n-  \/\/ counter to be live  at the same time).  Fix this by  adjusting to use the\n-  \/\/ post-increment trip counter.\n-\n-  bool progress = true;\n-  while (progress) {\n-    progress = false;\n-    for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n-      Node* use = phi->fast_out(i);   \/\/ User of trip-counter\n-      if (!has_ctrl(use))  continue;\n-      Node *u_ctrl = get_ctrl(use);\n-      if (use->is_Phi()) {\n-        u_ctrl = NULL;\n-        for (uint j = 1; j < use->req(); j++)\n-          if (use->in(j) == phi)\n-            u_ctrl = dom_lca(u_ctrl, use->in(0)->in(j));\n-      }\n-      IdealLoopTree *u_loop = get_loop(u_ctrl);\n-      \/\/ Look for loop-invariant use\n-      if (u_loop == loop) continue;\n-      if (loop->is_member(u_loop)) continue;\n-      \/\/ Check that use is live out the bottom.  Assuming the trip-counter\n-      \/\/ update is right at the bottom, uses of of the loop middle are ok.\n-      if (dom_lca(exit, u_ctrl) != exit) continue;\n-      \/\/ Hit!  Refactor use to use the post-incremented tripcounter.\n-      \/\/ Compute a post-increment tripcounter.\n-      Node* c = exit;\n-      if (cl->is_strip_mined()) {\n-        IdealLoopTree* outer_loop = get_loop(cl->outer_loop());\n-        if (!outer_loop->is_member(u_loop)) {\n-          c = cl->outer_loop_exit();\n-        }\n-      }\n-      Node *opaq = new Opaque2Node(C, cle->incr());\n-      register_new_node(opaq, c);\n-      Node *neg_stride = _igvn.intcon(-cle->stride_con());\n-      set_ctrl(neg_stride, C->root());\n-      Node *post = new AddINode(opaq, neg_stride);\n-      register_new_node(post, c);\n-      post = new CastIINode(post, phi->bottom_type()); \/\/ preserve the iv phi's type\n-      register_new_node(post, c);\n-      _igvn.rehash_node_delayed(use);\n-      for (uint j = 1; j < use->req(); j++) {\n-        if (use->in(j) == phi)\n-          use->set_req(j, post);\n-      }\n-      \/\/ Since DU info changed, rerun loop\n-      progress = true;\n-      break;\n-    }\n-  }\n-\n-}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":25,"deletions":117,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -64,3 +64,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-#include \"gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp\"\n-#endif\n@@ -644,0 +641,1 @@\n+    BarrierSetC2 *bs = BarrierSet::barrier_set()->barrier_set_c2();\n@@ -660,2 +658,1 @@\n-          if (!n->is_Store() && n->Opcode() != Op_CastP2X\n-              SHENANDOAHGC_ONLY(&& (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {\n+          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n)) {\n@@ -2892,1 +2889,0 @@\n-               n->Opcode() == Op_Opaque2   ||\n@@ -2938,1 +2934,1 @@\n-      } else if (n->is_Opaque1() || n->Opcode() == Op_Opaque2) {\n+      } else if (n->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -239,0 +239,1 @@\n+  Node* zerocon(BasicType bt)   const { return _igvn.zerocon(bt); }\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+      _parm_regs[i].set_bad();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -826,1 +826,1 @@\n-  return true;\n+  return !has_pinned_control_dependency();\n@@ -844,1 +844,11 @@\n-    st->print(\" (does not depend only on test)\");\n+    st->print(\" (does not depend only on test, \");\n+    if (control_dependency() == UnknownControl) {\n+      st->print(\"unknown control\");\n+    } else if (control_dependency() == Pinned) {\n+      st->print(\"pinned\");\n+    } else if (adr_type() == TypeRawPtr::BOTTOM) {\n+      st->print(\"raw access\");\n+    } else {\n+      st->print(\"unknown reason\");\n+    }\n+    st->print(\")\");\n@@ -861,1 +871,1 @@\n-      in_bytes(JavaThread::extentLocalCache_offset()),\n+      in_bytes(JavaThread::scopedValueCache_offset()),\n@@ -1246,1 +1256,5 @@\n-    return value;\n+    if (!has_pinned_control_dependency() || value->is_Con()) {\n+      return value;\n+    } else {\n+      return this;\n+    }\n@@ -1249,0 +1263,3 @@\n+  if (has_pinned_control_dependency()) {\n+    return this;\n+  }\n@@ -1731,0 +1748,3 @@\n+  if (has_pinned_control_dependency()) {\n+    return NULL;\n+  }\n@@ -2446,1 +2466,1 @@\n-  \/\/ Take apart the address into an oop and and offset.\n+  \/\/ Take apart the address into an oop and offset.\n@@ -2547,1 +2567,1 @@\n-  \/\/ Take apart the address into an oop and and offset.\n+  \/\/ Take apart the address into an oop and offset.\n@@ -2579,1 +2599,1 @@\n-  \/\/ Take apart the address into an oop and and offset.\n+  \/\/ Take apart the address into an oop and offset.\n@@ -3347,1 +3367,0 @@\n-  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n@@ -3587,20 +3606,0 @@\n-#ifndef PRODUCT\n-void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n-  st->print(\"blackhole \");\n-  bool first = true;\n-  for (uint i = 0; i < req(); i++) {\n-    Node* n = in(i);\n-    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n-      if (first) {\n-        first = false;\n-      } else {\n-        st->print(\", \");\n-      }\n-      char buf[128];\n-      ra->dump_register(n, buf);\n-      st->print(\"%s\", buf);\n-    }\n-  }\n-  st->cr();\n-}\n-#endif\n@@ -5004,1 +5003,1 @@\n-         alias_idx == Compile::AliasIdxBot && Compile::current()->AliasLevel() == 0,\n+         alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing(),\n@@ -5017,1 +5016,1 @@\n-           || Compile::current()->AliasLevel() == 0,\n+           || !Compile::current()->do_aliasing(),\n@@ -5019,1 +5018,1 @@\n-    \/\/ AliasLevel == 0 if we are organizing the memory states manually.\n+    \/\/ do_aliasing == false if we are organizing the memory states manually.\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":30,"deletions":31,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -292,3 +292,3 @@\n-  ControlDependency control_dependency() {return _control_dependency; }\n-\n-  bool has_unknown_control_dependency() const { return _control_dependency == UnknownControl; }\n+  ControlDependency control_dependency() const { return _control_dependency; }\n+  bool has_unknown_control_dependency() const  { return _control_dependency == UnknownControl; }\n+  bool has_pinned_control_dependency() const   { return _control_dependency == Pinned; }\n@@ -791,1 +791,1 @@\n-           _oop_alias_idx == Compile::AliasIdxBot && Compile::current()->AliasLevel() == 0,\n+           _oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing(),\n@@ -1310,22 +1310,0 @@\n-\/\/------------------------------BlackholeNode----------------------------\n-\/\/ Blackhole all arguments. This node would survive through the compiler\n-\/\/ the effects on its arguments, and would be finally matched to nothing.\n-class BlackholeNode : public MemBarNode {\n-public:\n-  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n-    : MemBarNode(C, alias_idx, precedent) {\n-    init_class_id(Class_Blackhole);\n-  }\n-  virtual int   Opcode() const;\n-  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n-  const RegMask &in_RegMask(uint idx) const {\n-    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n-    \/\/ and all stack slots. This would avoid any redundant register moves\n-    \/\/ for blackhole inputs.\n-    return RegMask::All;\n-  }\n-#ifndef PRODUCT\n-  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -438,0 +438,14 @@\n+\/\/------------------------------Ideal---------------------------------------\n+\/\/ Check to see if we are multiplying by a constant 2 and convert to add, then try the regular MulNode::Ideal\n+Node* MulFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeF *t2 = phase->type(in(2))->isa_float_constant();\n+\n+  \/\/ x * 2 -> x + x\n+  if (t2 != NULL && t2->getf() == 2) {\n+    Node* base = in(1);\n+    return new AddFNode(base, base);\n+  }\n+\n+  return MulNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -447,0 +461,14 @@\n+\/\/------------------------------Ideal---------------------------------------\n+\/\/ Check to see if we are multiplying by a constant 2 and convert to add, then try the regular MulNode::Ideal\n+Node* MulDNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeD *t2 = phase->type(in(2))->isa_double_constant();\n+\n+  \/\/ x * 2 -> x + x\n+  if (t2 != NULL && t2->getd() == 2) {\n+    Node* base = in(1);\n+    return new AddDNode(base, base);\n+  }\n+\n+  return MulNode::Ideal(phase, can_reshape);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2689,47 +2689,0 @@\n-\/\/ For each input edge to a node (ie - for each Use-Def edge), verify that\n-\/\/ there is a corresponding Def-Use edge.\n-\/\/------------------------------verify_edges-----------------------------------\n-void Node::verify_edges(Unique_Node_List &visited) {\n-  uint i, j, idx;\n-  int  cnt;\n-  Node *n;\n-\n-  \/\/ Recursive termination test\n-  if (visited.member(this))  return;\n-  visited.push(this);\n-\n-  \/\/ Walk over all input edges, checking for correspondence\n-  for( i = 0; i < len(); i++ ) {\n-    n = in(i);\n-    if (n != NULL && !n->is_top()) {\n-      \/\/ Count instances of (Node *)this\n-      cnt = 0;\n-      for (idx = 0; idx < n->_outcnt; idx++ ) {\n-        if (n->_out[idx] == (Node *)this)  cnt++;\n-      }\n-      assert( cnt > 0,\"Failed to find Def-Use edge.\" );\n-      \/\/ Check for duplicate edges\n-      \/\/ walk the input array downcounting the input edges to n\n-      for( j = 0; j < len(); j++ ) {\n-        if( in(j) == n ) cnt--;\n-      }\n-      assert( cnt == 0,\"Mismatched edge count.\");\n-    } else if (n == NULL) {\n-      assert(i >= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() ||\n-             (is_Allocate() && i >= AllocateNode::InlineType) ||\n-             (is_Unlock() && i == req()-1)\n-              || (is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n-             \"only region, phi, arraycopy, allocate or unlock nodes have null data edges\");\n-    } else {\n-      assert(n->is_top(), \"sanity\");\n-      \/\/ Nothing to check.\n-    }\n-  }\n-  \/\/ Recursive walk over all input edges\n-  for( i = 0; i < len(); i++ ) {\n-    n = in(i);\n-    if( n != NULL )\n-      in(i)->verify_edges(visited);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1234,1 +1234,0 @@\n-  void verify_edges(Unique_Node_List &visited); \/\/ Verify bi-directional edges\n@@ -1533,1 +1532,1 @@\n-class Node_Array : public ResourceObj {\n+class Node_Array : public AnyObj {\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-  C->print_method(CompilerPhaseType::PHASE_MACHANALYSIS, 4);\n+  C->print_method(CompilerPhaseType::PHASE_MACH_ANALYSIS, 4);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  struct C2SafepointPollStub: public ResourceObj {\n+  struct C2SafepointPollStub: public ArenaObj {\n@@ -118,1 +118,1 @@\n-class C2EntryBarrierStub: public ResourceObj {\n+class C2EntryBarrierStub: public ArenaObj {\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-class InlineTree : public ResourceObj {\n+class InlineTree : public AnyObj {\n@@ -271,1 +271,1 @@\n-  class BytecodeParseHistogram : public ResourceObj {\n+  class BytecodeParseHistogram : public ArenaObj {\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -32,0 +31,1 @@\n+#include \"jvm_io.h\"\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1892,0 +1892,1 @@\n+  push_cast_ii(worklist, parent, use);\n@@ -2007,0 +2008,16 @@\n+\/\/ CastII::Value() optimizes CmpI\/If patterns if the right input of the CmpI has a constant type. If the CastII input is\n+\/\/ the same node as the left input into the CmpI node, the type of the CastII node can be improved accordingly. Add the\n+\/\/ CastII node back to the worklist to re-apply Value() to either not miss this optimization or to undo it because it\n+\/\/ cannot be applied anymore. We could have optimized the type of the CastII before but now the type of the right input\n+\/\/ of the CmpI (i.e. 'parent') is no longer constant. The type of the CastII must be widened in this case.\n+void PhaseCCP::push_cast_ii(Unique_Node_List& worklist, const Node* parent, const Node* use) const {\n+  if (use->Opcode() == Op_CmpI && use->in(2) == parent) {\n+    Node* other_cmp_input = use->in(1);\n+    for (DUIterator_Fast imax, i = other_cmp_input->fast_outs(imax); i < imax; i++) {\n+      Node* cast_ii = other_cmp_input->fast_out(i);\n+      if (cast_ii->is_CastII()) {\n+        push_if_not_bottom_type(worklist, cast_ii);\n+      }\n+    }\n+  }\n+}\n@@ -2156,1 +2173,0 @@\n-  case Op_Opaque2:\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -601,0 +601,1 @@\n+  void push_cast_ii(Unique_Node_List& worklist, const Node* parent, const Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+  flags(INCREMENTAL_INLINE_STEP,      \"Incremental Inline Step\") \\\n+  flags(INCREMENTAL_INLINE_CLEANUP,   \"Incremental Inline Cleanup\") \\\n+  flags(INCREMENTAL_INLINE,           \"Incremental Inline\") \\\n+  flags(INCREMENTAL_BOXING_INLINE,    \"Incremental Boxing Inline\") \\\n@@ -39,2 +43,7 @@\n-  flags(PHASEIDEAL_BEFORE_EA,         \"PhaseIdealLoop before EA\") \\\n-  flags(ITER_GVN_AFTER_VECTOR,        \"Iter GVN after vector box elimination\") \\\n+  flags(ITER_GVN_AFTER_VECTOR,        \"Iter GVN after vector box elimination\") \\\n+  flags(BEFORE_BEAUTIFY_LOOPS,        \"Before beautify loops\") \\\n+  flags(AFTER_BEAUTIFY_LOOPS,         \"After beautify loops\") \\\n+  flags(BEFORE_CLOOPS,                \"Before CountedLoop\") \\\n+  flags(AFTER_CLOOPS,                 \"After CountedLoop\") \\\n+  flags(PHASEIDEAL_BEFORE_EA,         \"PhaseIdealLoop before EA\") \\\n+  flags(AFTER_EA,                     \"After Escape Analysis\") \\\n@@ -50,0 +59,2 @@\n+  flags(MACRO_EXPANSION,              \"Macro expand\") \\\n+  flags(BARRIER_EXPANSION,            \"Barrier expand\") \\\n@@ -51,7 +62,0 @@\n-  flags(GLOBAL_CODE_MOTION,           \"Global code motion\") \\\n-  flags(FINAL_CODE,                   \"Final Code\") \\\n-  flags(AFTER_EA,                     \"After Escape Analysis\") \\\n-  flags(BEFORE_CLOOPS,                \"Before CountedLoop\") \\\n-  flags(AFTER_CLOOPS,                 \"After CountedLoop\") \\\n-  flags(BEFORE_BEAUTIFY_LOOPS,        \"Before beautify loops\") \\\n-  flags(AFTER_BEAUTIFY_LOOPS,         \"After beautify loops\") \\\n@@ -60,8 +64,3 @@\n-  flags(MACHANALYSIS,                 \"After mach analysis\") \\\n-  flags(INCREMENTAL_INLINE,           \"Incremental Inline\") \\\n-  flags(INCREMENTAL_INLINE_STEP,      \"Incremental Inline Step\") \\\n-  flags(INCREMENTAL_INLINE_CLEANUP,   \"Incremental Inline Cleanup\") \\\n-  flags(INCREMENTAL_BOXING_INLINE,    \"Incremental Boxing Inline\") \\\n-  flags(CALL_CATCH_CLEANUP,           \"Call catch cleanup\") \\\n-  flags(MACRO_EXPANSION,              \"Macro expand\") \\\n-  flags(BARRIER_EXPANSION,            \"Barrier expand\") \\\n+  flags(GLOBAL_CODE_MOTION,           \"Global code motion\") \\\n+  flags(MACH_ANALYSIS,                \"After mach analysis\") \\\n+  flags(FINAL_CODE,                   \"Final Code\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1028,1 +1028,1 @@\n-  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ digest_length\n+  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ block_size\n@@ -1050,1 +1050,1 @@\n-  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ digest_length\n+  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ block_size\n@@ -1232,0 +1232,20 @@\n+\n+\/\/ ChaCha20 Block function\n+const TypeFunc* OptoRuntime::chacha20Block_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1276,0 +1296,20 @@\n+\/\/ Poly1305 processMultipleBlocks function\n+const TypeFunc* OptoRuntime::poly1305_processBlocks_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ input array\n+  fields[argp++] = TypeInt::INT;        \/\/ input length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ accumulator array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ r array\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -283,0 +283,1 @@\n+  static const TypeFunc* chacha20Block_Type();\n@@ -285,0 +286,1 @@\n+  static const TypeFunc* poly1305_processBlocks_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -224,0 +225,18 @@\n+  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n+    \/\/ 1- it can't be shared\n+    \/\/ 2- the zero trip guard can't be the if that's being split\n+    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n+    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n+    Node* cmp = n->unique_out();\n+    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+    Node* bol = cmp->unique_out();\n+    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n+    Node* iff = bol->unique_out();\n+    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n+    set_ctrl(n, iff->in(0));\n+    set_ctrl(cmp, iff->in(0));\n+    set_ctrl(bol, iff->in(0));\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                                       \/\/ SB.toString or or String.<init>(SB.toString)\n+                                       \/\/ SB.toString or String.<init>(SB.toString)\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,9 +73,0 @@\n-\n-    \/\/ Also catch: \"(X + Opaque2(Y)) - Y\".  In this case, 'Y' is a loop-varying\n-    \/\/ trip counter and X is likely to be loop-invariant (that's how O2 Nodes\n-    \/\/ are originally used, although the optimizer sometimes jiggers things).\n-    \/\/ This folding through an O2 removes a loop-exit use of a loop-varying\n-    \/\/ value and generally lowers register pressure in and around the loop.\n-    if (in(1)->in(2)->Opcode() == Op_Opaque2 && in(1)->in(2)->in(1) == in(2)) {\n-      return in(1)->in(1);\n-    }\n@@ -1556,1 +1547,1 @@\n-  if( con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_Opaque1 &&\n+  if (con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"jni.h\"\n-#include \"jni.h\"\n-#include \"jvm.h\"\n@@ -52,0 +49,2 @@\n+#include \"jni.h\"\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"jni.h\"\n-#include \"jvm.h\"\n@@ -31,0 +29,2 @@\n+#include \"jni.h\"\n+#include \"jvm.h\"\n@@ -49,3 +49,0 @@\n-\/\/ Complain every extra number of unplanned local refs\n-#define CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD 32\n-\n@@ -205,11 +202,0 @@\n-\/**\n- * Add to the planned number of handles. I.e. plus current live & warning threshold\n- *\/\n-static inline void\n-add_planned_handle_capacity(JNIHandleBlock* handles, size_t capacity) {\n-  handles->set_planned_capacity(capacity +\n-                                handles->get_number_of_live_handles() +\n-                                CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD);\n-}\n-\n-\n@@ -247,12 +233,1 @@\n-  JNIHandleBlock* handles = thr->active_handles();\n-  size_t planned_capacity = handles->get_planned_capacity();\n-  size_t live_handles = handles->get_number_of_live_handles();\n-  if (live_handles > planned_capacity) {\n-    IN_VM(\n-      tty->print_cr(\"WARNING: JNI local refs: \" SIZE_FORMAT \", exceeds capacity: \" SIZE_FORMAT,\n-                    live_handles, planned_capacity);\n-      thr->print_stack();\n-    )\n-    \/\/ Complain just the once, reset to current + warn threshold\n-    add_planned_handle_capacity(handles, 0);\n-  }\n+  \/\/ No checks at this time\n@@ -751,3 +726,0 @@\n-    if (result == JNI_OK) {\n-      add_planned_handle_capacity(thr->active_handles(), capacity);\n-    }\n@@ -855,6 +827,0 @@\n-    if (result == JNI_OK) {\n-      \/\/ increase local ref capacity if needed\n-      if ((size_t)capacity > thr->active_handles()->get_planned_capacity()) {\n-        add_planned_handle_capacity(thr->active_handles(), capacity);\n-      }\n-    }\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -51,0 +50,1 @@\n+#include \"jvm.h\"\n@@ -1404,0 +1404,48 @@\n+class ScopedValueBindingsResolver {\n+public:\n+  InstanceKlass* Carrier_klass;\n+  ScopedValueBindingsResolver(JavaThread* THREAD) {\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Carrier_klass = InstanceKlass::cast(k);\n+  }\n+};\n+\n+JVM_ENTRY(jobject, JVM_FindScopedValueBindings(JNIEnv *env, jclass cls))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n+  JvmtiVMObjectAllocEventCollector oam;\n+\n+  static ScopedValueBindingsResolver resolver(THREAD);\n+\n+  \/\/ Iterate through Java frames\n+  vframeStream vfst(thread);\n+  for(; !vfst.at_end(); vfst.next()) {\n+    int loc = -1;\n+    \/\/ get method of frame\n+    Method* method = vfst.method();\n+\n+    Symbol *name = method->name();\n+\n+    InstanceKlass* holder = method->method_holder();\n+    if (name == vmSymbols::runWith_method_name()) {\n+      if ((holder == resolver.Carrier_klass\n+           || holder == vmClasses::VirtualThread_klass()\n+           || holder == vmClasses::Thread_klass())) {\n+        loc = 1;\n+      }\n+    }\n+\n+    if (loc != -1) {\n+      javaVFrame *frame = vfst.asJavaVFrame();\n+      StackValueCollection* locals = frame->locals();\n+      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      Handle result = head_sv->get_obj();\n+      assert(!head_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n+      if (result() != NULL) {\n+        return JNIHandles::make_local(THREAD, result());\n+      }\n+    }\n+  }\n+\n+  return NULL;\n+JVM_END\n@@ -3198,6 +3246,2 @@\n-JVM_ENTRY(jobject, JVM_ExtentLocalCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->extentLocalCache();\n-  if (theCache) {\n-    arrayOop objs = arrayOop(theCache);\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n+JVM_ENTRY(jobject, JVM_ScopedValueCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->scopedValueCache();\n@@ -3207,1 +3251,1 @@\n-JVM_ENTRY(void, JVM_SetExtentLocalCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetScopedValueCache(JNIEnv* env, jclass threadClass,\n@@ -3210,4 +3254,1 @@\n-  if (objs != NULL) {\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n-  thread->set_extentLocalCache(objs);\n+  thread->set_scopedValueCache(objs);\n@@ -4107,0 +4148,9 @@\n+\n+\/*\n+ * Ensure that code doing a stackwalk and using javaVFrame::locals() to\n+ * get the value will see a materialized value and not a scalar-replaced\n+ * null value.\n+ *\/\n+JVM_ENTRY(void, JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value))\n+  JVM_EnsureMaterializedForStackWalk(env, value);\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -718,3 +718,1 @@\n-    \/\/ lock the loader\n-    Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());\n-    ObjectLocker ol(loader, THREAD);\n+    Handle loader(THREAD, SystemDictionary::java_system_loader());\n@@ -1361,1 +1359,1 @@\n-      new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+      new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n@@ -1434,1 +1432,1 @@\n-         new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+         new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n@@ -1673,1 +1671,1 @@\n-  Handle *group_objs  = NULL;\n+  objArrayHandle group_objs;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -201,6 +202,2 @@\n-    JvmtiThreadState* state = thread->jvmti_thread_state();\n-    if (state != NULL && state->is_virtual()) {\n-      _jthread = to_jobject(thread->vthread());\n-    } else {\n-      _jthread = to_jobject(thread->threadObj());\n-    }\n+    assert(thread->vthread() != NULL || thread->threadObj() == NULL, \"sanity check\");\n+    _jthread = to_jobject(thread->vthread());\n@@ -386,0 +383,4 @@\n+    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n+      ThreadInVMfromNative __tiv(JavaThread::current());\n+      java_lang_VirtualThread::init_static_notify_jvmti_events();\n+    }\n@@ -1967,0 +1968,5 @@\n+  \/\/ The KeepStackGCProcessedMark below keeps the target thread and its stack fully\n+  \/\/ GC processed across this scope. This is needed because there is a stack walk\n+  \/\/ below with safepoint polls inside of it. After such safepoints, we have to\n+  \/\/ ensure the stack is sufficiently processed.\n+  KeepStackGCProcessedMark ksgcpm(thread);\n@@ -3127,1 +3133,1 @@\n-   _code_blobs = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<JvmtiCodeBlobDesc*>(1, mtServiceability);\n+   _code_blobs = new (mtServiceability) GrowableArray<JvmtiCodeBlobDesc*>(1, mtServiceability);\n@@ -3156,1 +3162,1 @@\n-    _allocated = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<OopHandle>(1, mtServiceability);\n+    _allocated = new (mtServiceability) GrowableArray<OopHandle>(1, mtServiceability);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  _elements       = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<GrowableElement*>(5, mtServiceability);\n+  _elements       = new (mtServiceability) GrowableArray<GrowableElement*>(5, mtServiceability);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    redef_classes = new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(1, mtClass);\n+    redef_classes = new (mtClass) GrowableArray<Klass*>(1, mtClass);\n@@ -1344,1 +1344,1 @@\n-  Handle            _scratch_mirror;\n+  OopHandle         _scratch_mirror;\n@@ -1352,2 +1352,2 @@\n-    _scratch_mirror = Handle(_state->get_thread(), _scratch_class->java_mirror());\n-    _scratch_class->replace_java_mirror(the_class->java_mirror());\n+    _scratch_mirror = the_class->java_mirror_handle();  \/\/ this is a copy that is swapped\n+    _scratch_class->swap_java_mirror_handle(_scratch_mirror);\n@@ -1359,1 +1359,1 @@\n-    _scratch_class->replace_java_mirror(_scratch_mirror());\n+    _scratch_class->swap_java_mirror_handle(_scratch_mirror);\n@@ -4444,1 +4444,3 @@\n-  the_class->set_has_been_redefined();\n+  if (!the_class->has_been_redefined()) {\n+    the_class->set_has_been_redefined();\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -38,0 +37,1 @@\n+#include \"jvm_io.h\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"jni.h\"\n-#include \"jvm.h\"\n@@ -35,0 +33,2 @@\n+#include \"jni.h\"\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include <new>\n@@ -34,0 +33,1 @@\n+#include \"classfile\/classLoaderStats.hpp\"\n@@ -118,1 +118,0 @@\n-\n@@ -1827,0 +1826,6 @@\n+WB_ENTRY(void, WB_ForceClassLoaderStatsSafepoint(JNIEnv* env, jobject wb))\n+  nullStream dev_null;\n+  ClassLoaderStatsVMOperation force_op(&dev_null);\n+  VMThread::execute(&force_op);\n+WB_END\n+\n@@ -2770,0 +2775,1 @@\n+  {CC\"forceClassLoaderStatsSafepoint\", CC\"()V\",       (void*)&WB_ForceClassLoaderStatsSafepoint },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -39,0 +38,1 @@\n+#include \"jvm.h\"\n@@ -70,0 +70,1 @@\n+\n@@ -541,0 +542,1 @@\n+  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -1955,2 +1957,4 @@\n-    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n-      return false;\n+    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+        return false;\n+      }\n@@ -2849,20 +2853,1 @@\n-    } else if (match_option(option, \"-XX:+ExtendedDTraceProbes\")) {\n-#if defined(DTRACE_ENABLED)\n-      warning(\"Option ExtendedDTraceProbes was deprecated in version 19 and will likely be removed in a future release.\");\n-      warning(\"Use the combination of -XX:+DTraceMethodProbes, -XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\");\n-      if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-#else \/\/ defined(DTRACE_ENABLED)\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"ExtendedDTraceProbes flag is not applicable for this configuration\\n\");\n-      return JNI_EINVAL;\n+#if !defined(DTRACE_ENABLED)\n@@ -2881,1 +2866,1 @@\n-#endif \/\/ defined(DTRACE_ENABLED)\n+#endif \/\/ !defined(DTRACE_ENABLED)\n@@ -2978,1 +2963,1 @@\n-    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n+    _patch_mod_prefix = new (mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n@@ -4206,32 +4191,0 @@\n-const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {\n-  int count = 0;\n-  const char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->key();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n-char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {\n-  int count = 0;\n-  char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->value();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":57,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -42,0 +41,1 @@\n+#include \"jvm.h\"\n@@ -104,2 +104,0 @@\n-bool DeoptimizationMarker::_is_active = false;\n-\n@@ -132,1 +130,0 @@\n-\n@@ -139,8 +136,0 @@\n-\n-intptr_t* Deoptimization::UnrollBlock::value_addr_at(int register_number) const {\n-  assert(register_number < RegisterMap::reg_count, \"checking register number\");\n-  return &_register_block[register_number * 2];\n-}\n-\n-\n-\n@@ -156,1 +145,0 @@\n-\n@@ -170,1 +158,0 @@\n-\n@@ -488,5 +475,2 @@\n-    \/\/ FIXME: This very crudely destroys all ExtentLocal bindings. This\n-    \/\/ is better than a bound value escaping, but far from ideal.\n-    oop java_thread = current->threadObj();\n-    current->set_extentLocalCache(NULL);\n-    java_lang_Thread::clear_extentLocalBindings(java_thread);\n+    \/\/ This destroys all ScopedValue bindings.\n+    current->clear_scopedValueBindings();\n@@ -778,0 +762,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n@@ -966,1 +951,0 @@\n-  DeoptimizationMarker dm;\n@@ -1754,1 +1738,0 @@\n-  DeoptimizationMarker dm;\n@@ -1833,0 +1816,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -232,3 +232,0 @@\n-    \/\/ Returns where a register is located.\n-    intptr_t* value_addr_at(int register_number) const;\n-\n@@ -238,2 +235,0 @@\n-    address*  frame_pcs()   const { return _frame_pcs ; }\n-    int  unpack_kind()   const { return _unpack_kind; }\n@@ -255,2 +250,0 @@\n-    static int register_block_offset_in_bytes()            { return offset_of(UnrollBlock, _register_block);            }\n-    static int return_type_offset_in_bytes()               { return offset_of(UnrollBlock, _return_type);               }\n@@ -478,9 +471,0 @@\n-\n-class DeoptimizationMarker : StackObj {  \/\/ for profiling\n-  static bool _is_active;\n-public:\n-  DeoptimizationMarker()  { _is_active = true; }\n-  ~DeoptimizationMarker() { _is_active = false; }\n-  static bool is_active() { return _is_active; }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-\n-oop fieldDescriptor::loader() const {\n-  return _cp->pool_holder()->class_loader();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-  oop loader()                    const;\n-  \/\/ Offset (in words) of field from start of instanceOop \/ Klass*\n+  \/\/ Offset (in bytes) of field from start of instanceOop \/ Klass*\n@@ -86,1 +85,0 @@\n-  bool is_public()                const    { return access_flags().is_public(); }\n@@ -89,1 +87,0 @@\n-  bool is_package_private()       const    { return !is_public() && !is_private() && !is_protected(); }\n@@ -94,2 +91,0 @@\n-  bool is_volatile()              const    { return access_flags().is_volatile(); }\n-  bool is_transient()             const    { return access_flags().is_transient(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -803,2 +803,0 @@\n-\n-  int max_locals()  { return _max_locals; }\n@@ -1297,4 +1295,4 @@\n-    _oops = new (ResourceObj::C_HEAP, mtThread) GrowableArray<oop*>(100, mtThread);\n-    _narrow_oops = new (ResourceObj::C_HEAP, mtThread) GrowableArray<narrowOop*>(100, mtThread);\n-    _base = new (ResourceObj::C_HEAP, mtThread) GrowableArray<oop*>(100, mtThread);\n-    _derived = new (ResourceObj::C_HEAP, mtThread) GrowableArray<derived_pointer*>(100, mtThread);\n+    _oops = new (mtThread) GrowableArray<oop*>(100, mtThread);\n+    _narrow_oops = new (mtThread) GrowableArray<narrowOop*>(100, mtThread);\n+    _base = new (mtThread) GrowableArray<oop*>(100, mtThread);\n+    _derived = new (mtThread) GrowableArray<derived_pointer*>(100, mtThread);\n@@ -1673,1 +1671,8 @@\n-          && (strncmp(fv.description, \"interpreter_frame_\", 18) == 0 || strstr(fv.description, \" method \"))) {\n+#if !defined(PPC64)\n+          && (strncmp(fv.description, \"interpreter_frame_\", 18) == 0 || strstr(fv.description, \" method \"))\n+#else  \/\/ !defined(PPC64)\n+          && (strcmp(fv.description, \"sender_sp\") == 0 || strcmp(fv.description, \"top_frame_sp\") == 0 ||\n+              strcmp(fv.description, \"esp\") == 0 || strcmp(fv.description, \"monitors\") == 0 ||\n+              strcmp(fv.description, \"locals\") == 0 || strstr(fv.description, \" method \"))\n+#endif \/\/!defined(PPC64)\n+          ) {\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -213,3 +213,0 @@\n-  \/\/ the number of oops in the frame for non-interpreted frames\n-  inline int num_oops() const;\n-\n@@ -238,1 +235,0 @@\n-  frame sender_for_native_frame(RegisterMap* map) const;\n@@ -258,14 +254,0 @@\n-  \/\/ accessors for locals\n-  oop obj_at(int offset) const                   { return *obj_at_addr(offset);  }\n-  void obj_at_put(int offset, oop value)         { *obj_at_addr(offset) = value; }\n-\n-  jint int_at(int offset) const                  { return *int_at_addr(offset);  }\n-  void int_at_put(int offset, jint value)        { *int_at_addr(offset) = value; }\n-\n-  oop*      obj_at_addr(int offset) const        { return (oop*)     addr_at(offset); }\n-\n-  oop*      adjusted_obj_at_addr(Method* method, int index) { return obj_at_addr(adjust_offset(method, index)); }\n-\n- private:\n-  jint*    int_at_addr(int offset) const         { return (jint*)    addr_at(offset); }\n-\n@@ -469,1 +451,0 @@\n-  int adjust_offset(Method* method, int index); \/\/ helper for above fn\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -241,0 +241,3 @@\n+  product(bool, UsePolyIntrinsics, false, DIAGNOSTIC,                       \\\n+          \"Use intrinsics for sun.security.util.math.intpoly\")              \\\n+                                                                            \\\n@@ -323,0 +326,3 @@\n+  product(bool, UseChaCha20Intrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for the vectorized version of ChaCha20\")          \\\n+                                                                            \\\n@@ -452,4 +458,0 @@\n-  develop(bool, UseMallocOnly, false,                                       \\\n-          \"Use only malloc\/free for allocation (no resource area\/arena). \"  \\\n-          \"Used to help diagnose memory stomping bugs.\")                    \\\n-                                                                            \\\n@@ -514,0 +516,3 @@\n+  product(bool, ErrorLogSecondaryErrorDetails, false, DIAGNOSTIC,           \\\n+          \"If enabled, show details on secondary crashes in the error log\") \\\n+                                                                            \\\n@@ -683,0 +688,4 @@\n+  product(bool, EnableWaitForParallelLoad, false,                           \\\n+          \"(Deprecated) Enable legacy parallel classloading logic for \"     \\\n+          \"class loaders not registered as parallel capable\")               \\\n+                                                                            \\\n@@ -1840,5 +1849,0 @@\n-  product(bool, ExtendedDTraceProbes,    false,                             \\\n-          \"(Deprecated) Enable performance-impacting dtrace probes. \"       \\\n-          \"Use the combination of -XX:+DTraceMethodProbes, \"                \\\n-          \"-XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\")   \\\n-                                                                            \\\n@@ -1964,5 +1968,0 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                   \\\n-          \"Size of the cache for scoped values\")                            \\\n-           range(0, max_intx)                                               \\\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n-                                                                            \\\n@@ -2027,3 +2026,0 @@\n-                                                                            \\\n-  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n-                \"Trace optimized upcall stub generation\")                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -201,1 +201,0 @@\n-    \/\/ Ignore UseMallocOnly by allocating only in arena.\n@@ -218,3 +217,0 @@\n-  \/\/ Number of handles in use\n-  size_t used() const     { return Arena::used() \/ oopSize; }\n-\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-#if INCLUDE_JVMCI\n-#include \"jvmci\/jvmci.hpp\"\n-#endif\n@@ -51,1 +48,3 @@\n-\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-#if INCLUDE_JVMCI\n-#include \"jvmci\/jvmciJavaClasses.hpp\"\n-#endif\n@@ -53,0 +50,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jvm.h\"\n@@ -43,0 +42,1 @@\n+#include \"jvm.h\"\n@@ -161,1 +161,1 @@\n-  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n@@ -190,2 +190,2 @@\n-oop JavaThread::extentLocalCache() const {\n-  return _extentLocalCache.resolve();\n+oop JavaThread::scopedValueCache() const {\n+  return _scopedValueCache.resolve();\n@@ -194,3 +194,16 @@\n-void JavaThread::set_extentLocalCache(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _extentLocalCache.replace(p);\n+void JavaThread::set_scopedValueCache(oop p) {\n+  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+    _scopedValueCache.replace(p);\n+  } else {\n+    assert(p == NULL, \"not yet initialized\");\n+  }\n+}\n+\n+void JavaThread::clear_scopedValueBindings() {\n+  set_scopedValueCache(NULL);\n+  oop vthread_oop = vthread();\n+  \/\/ vthread may be null here if we get a VM error during startup,\n+  \/\/ before the java.lang.Thread instance has been created.\n+  if (vthread_oop != NULL) {\n+    java_lang_Thread::clear_scopedValueBindings(vthread_oop);\n+  }\n@@ -387,1 +400,0 @@\n-  _in_asgct(false),\n@@ -603,4 +615,2 @@\n-  \/\/ Ask ServiceThread to release the threadObj OopHandle\n-  ServiceThread::add_oop_handle_release(_threadObj);\n-  ServiceThread::add_oop_handle_release(_vthread);\n-  ServiceThread::add_oop_handle_release(_jvmti_vthread);\n+  \/\/ Enqueue OopHandles for release by the service thread.\n+  add_oop_handles_for_release();\n@@ -987,24 +997,0 @@\n-bool JavaThread::is_lock_owned_current(address adr) const {\n-  address stack_end = _stack_base - _stack_size;\n-  const ContinuationEntry* ce = vthread_continuation();\n-  address stack_base = ce != nullptr ? (address)ce->entry_sp() : _stack_base;\n-  if (stack_base > adr && adr >= stack_end) {\n-    return true;\n-  }\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-}\n-\n-bool JavaThread::is_lock_owned_carrier(address adr) const {\n-  assert(is_vthread_mounted(), \"\");\n-  address stack_end = _stack_base - _stack_size;\n-  address stack_base = (address)vthread_continuation()->entry_sp();\n-  return stack_base > adr && adr >= stack_end;\n-}\n-\n@@ -1071,5 +1057,1 @@\n-  \/\/ Clear any extent-local bindings\n-  set_extentLocalCache(NULL);\n-  oop threadOop = threadObj();\n-  assert(threadOop != NULL, \"must be\");\n-  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+  clear_scopedValueBindings();\n@@ -1388,0 +1370,11 @@\n+\n+  \/\/ The continuation oops are really on the stack. But there is typically at most\n+  \/\/ one of those per thread, so we handle them here in the oops_do_no_frames part\n+  \/\/ so that we don't have to sprinkle as many stack watermark checks where these\n+  \/\/ oops are used. We just need to make sure the thread has started processing.\n+  ContinuationEntry* entry = _cont_entry;\n+  while (entry != nullptr) {\n+    f->do_oop((oop*)entry->cont_addr());\n+    f->do_oop((oop*)entry->chunk_addr());\n+    entry = entry->parent();\n+  }\n@@ -1466,4 +1459,0 @@\n-const char* JavaThread::thread_state_name() const {\n-  return _get_thread_state_name(_thread_state);\n-}\n-\n@@ -1904,5 +1893,0 @@\n-oop JavaThread::get_continuation() const {\n-  assert(threadObj() != nullptr, \"must be set\");\n-  return java_lang_Thread::continuation(threadObj());\n-}\n-\n@@ -2076,0 +2060,54 @@\n+\n+\/\/ Deferred OopHandle release support.\n+\n+class OopHandleList : public CHeapObj<mtInternal> {\n+  static const int _count = 4;\n+  OopHandle _handles[_count];\n+  OopHandleList* _next;\n+  int _index;\n+ public:\n+  OopHandleList(OopHandleList* next) : _next(next), _index(0) {}\n+  void add(OopHandle h) {\n+    assert(_index < _count, \"too many additions\");\n+    _handles[_index++] = h;\n+  }\n+  ~OopHandleList() {\n+    assert(_index == _count, \"usage error\");\n+    for (int i = 0; i < _index; i++) {\n+      _handles[i].release(JavaThread::thread_oop_storage());\n+    }\n+  }\n+  OopHandleList* next() const { return _next; }\n+};\n+\n+OopHandleList* JavaThread::_oop_handle_list = nullptr;\n+\n+\/\/ Called by the ServiceThread to do the work of releasing\n+\/\/ the OopHandles.\n+void JavaThread::release_oop_handles() {\n+  OopHandleList* list;\n+  {\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    list = _oop_handle_list;\n+    _oop_handle_list = nullptr;\n+  }\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"cannot be called at a safepoint\");\n+\n+  while (list != nullptr) {\n+    OopHandleList* l = list;\n+    list = l->next();\n+    delete l;\n+  }\n+}\n+\n+\/\/ Add our OopHandles for later release.\n+void JavaThread::add_oop_handles_for_release() {\n+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  OopHandleList* new_head = new OopHandleList(_oop_handle_list);\n+  new_head->add(_threadObj);\n+  new_head->add(_vthread);\n+  new_head->add(_jvmti_vthread);\n+  new_head->add(_scopedValueCache);\n+  _oop_handle_list = new_head;\n+  Service_lock->notify_all();\n+}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":88,"deletions":50,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+class OopHandleList;\n@@ -84,0 +85,1 @@\n+  friend class ServiceThread; \/\/ for deferred OopHandle release access\n@@ -85,1 +87,4 @@\n-  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n+\n+  \/\/ All references to Java objects managed via OopHandles. These\n+  \/\/ have to be released by the ServiceThread after the JavaThread has\n+  \/\/ terminated - see add_oop_handles_for_release().\n@@ -90,1 +95,1 @@\n-  OopHandle      _extentLocalCache;\n+  OopHandle      _scopedValueCache;\n@@ -467,5 +472,0 @@\n- public:\n-  jlong _extentLocal_hash_table_shift;\n-\n-  void allocate_extentLocal_hash_table(int count);\n-\n@@ -524,2 +524,3 @@\n-  oop extentLocalCache() const;\n-  void set_extentLocalCache(oop p);\n+  oop scopedValueCache() const;\n+  void set_scopedValueCache(oop p);\n+  void clear_scopedValueBindings();\n@@ -593,1 +594,0 @@\n-  oop get_continuation() const;\n@@ -668,2 +668,0 @@\n-  bool is_lock_owned_current(address adr) const; \/\/ virtual if mounted, otherwise whole thread\n-  bool is_lock_owned_carrier(address adr) const;\n@@ -695,1 +693,1 @@\n-  void set_callee_target  (Method* x)          { _callee_target   = x; }\n+  void set_callee_target  (Method* x)            { _callee_target   = x; }\n@@ -701,2 +699,1 @@\n-  Metadata*    vm_result_2() const               { return _vm_result_2; }\n-  void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }\n+  void set_vm_result_2  (Metadata* x)            { _vm_result_2   = x; }\n@@ -711,2 +708,0 @@\n-  int  pending_deoptimization() const             { return _pending_deoptimization; }\n-  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n@@ -734,2 +729,0 @@\n-  address  exception_handler_pc() const          { return _exception_handler_pc; }\n-  bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }\n@@ -759,1 +752,1 @@\n-  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n+  static ByteSize scopedValueCache_offset()       { return byte_offset_of(JavaThread, _scopedValueCache); }\n@@ -789,1 +782,0 @@\n-  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n@@ -925,1 +917,0 @@\n-  const char* thread_state_name() const;\n@@ -1046,1 +1037,0 @@\n-  void clear_popframe_forcing_deopt_reexecution()     { _popframe_condition &= ~popframe_force_deopt_reexecution_bit; }\n@@ -1098,1 +1088,0 @@\n-  int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }\n@@ -1173,3 +1162,13 @@\n-  \/\/ AsyncGetCallTrace support\n-  inline bool in_asgct(void) {return _in_asgct;}\n-  inline void set_in_asgct(bool value) {_in_asgct = value;}\n+  \/\/ Deferred OopHandle release support\n+ private:\n+  \/\/ List of OopHandles to be released - guarded by the Service_lock.\n+  static OopHandleList* _oop_handle_list;\n+  \/\/ Add our OopHandles to the list for the service thread to release.\n+  void add_oop_handles_for_release();\n+  \/\/ Called by the ServiceThread to release the OopHandles.\n+  static void release_oop_handles();\n+  \/\/ Called by the ServiceThread to poll if there are any OopHandles to release.\n+  \/\/ Called when holding the Service_lock.\n+  static bool has_oop_handles_to_release() {\n+    return _oop_handle_list != nullptr;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -257,9 +257,0 @@\n-size_t JNIHandles::global_handle_memory_usage() {\n-  return global_handles()->total_memory_usage();\n-}\n-\n-size_t JNIHandles::weak_global_handle_memory_usage() {\n-  return weak_global_handles()->total_memory_usage();\n-}\n-\n-\n@@ -399,1 +390,0 @@\n-  block->_planned_capacity = block_size_in_oops;\n@@ -583,31 +573,0 @@\n-\n-\n-size_t JNIHandleBlock::length() const {\n-  size_t result = 1;\n-  for (JNIHandleBlock* current = _next; current != NULL; current = current->_next) {\n-    result++;\n-  }\n-  return result;\n-}\n-\n-class CountJNIHandleClosure: public OopClosure {\n-private:\n-  int _count;\n-public:\n-  CountJNIHandleClosure(): _count(0) {}\n-  virtual void do_oop(oop* ooph) { _count++; }\n-  virtual void do_oop(narrowOop* unused) { ShouldNotReachHere(); }\n-  int count() { return _count; }\n-};\n-\n-const size_t JNIHandleBlock::get_number_of_live_handles() {\n-  CountJNIHandleClosure counter;\n-  oops_do(&counter);\n-  return counter.count();\n-}\n-\n-\/\/ This method is not thread-safe, i.e., must be called while holding a lock on the\n-\/\/ structure.\n-size_t JNIHandleBlock::memory_usage() const {\n-  return length() * sizeof(JNIHandleBlock);\n-}\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -35,0 +34,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1028,0 +1028,1 @@\n+jlong     SafepointTracing::_max_cleanup_time = 0;\n@@ -1097,0 +1098,2 @@\n+  log_info(safepoint, stats)(\"Maximum cleanup time  \" INT64_FORMAT\" ns\",\n+                              (int64_t)(_max_cleanup_time));\n@@ -1135,0 +1138,3 @@\n+  if (_max_cleanup_time < (_last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns)) {\n+    _max_cleanup_time = _last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns;\n+  }\n@@ -1146,0 +1152,1 @@\n+     \"Cleanup: \" JLONG_FORMAT \" ns, \"\n@@ -1150,1 +1157,2 @@\n-      _last_safepoint_cleanup_time_ns - _last_safepoint_begin_time_ns,\n+      _last_safepoint_sync_time_ns    - _last_safepoint_begin_time_ns,\n+      _last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns,\n@@ -1155,1 +1163,1 @@\n-  RuntimeService::record_safepoint_end(_last_safepoint_end_time_ns - _last_safepoint_cleanup_time_ns);\n+  RuntimeService::record_safepoint_end(_last_safepoint_end_time_ns - _last_safepoint_sync_time_ns);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -45,0 +44,1 @@\n+#include \"jvm.h\"\n@@ -149,1 +149,0 @@\n-int64_t SharedRuntime::_nof_optimized_calls = 0;\n@@ -155,2 +154,0 @@\n-int64_t SharedRuntime::_nof_optimized_interface_calls = 0;\n-int64_t SharedRuntime::_nof_megamorphic_interface_calls = 0;\n@@ -456,1 +453,3 @@\n-  jint doppel = SharedRuntime::f2i(x);\n+  union {jfloat f; jint i;} bits;\n+  bits.f = x;\n+  jint doppel = bits.i;\n@@ -473,1 +472,1 @@\n-  jint exp = 0x7f800000 & doppel;\n+  jint exp = ((0x7f800000 & doppel) >> (24 - 1)) - 127;\n@@ -507,0 +506,1 @@\n+  union {jfloat f; jint i;} bits;\n@@ -522,3 +522,9 @@\n-  }else if (hf_exp == 16) {\n-    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n-           (hf_significand_bits << significand_shift)));\n+  } else if (hf_exp == 16) {\n+    if (hf_significand_bits == 0) {\n+      bits.i = 0x7f800000;\n+      return sign * bits.f;\n+    } else {\n+      bits.i = (hf_sign_bit << 16) | 0x7f800000 |\n+               (hf_significand_bits << significand_shift);\n+      return bits.f;\n+    }\n@@ -528,1 +534,1 @@\n-  int float_exp_bits = (hf_exp + 127) << (24 - 1);\n+  jint float_exp_bits = (hf_exp + 127) << (24 - 1);\n@@ -531,1 +537,4 @@\n-  return SharedRuntime::i2f((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+  bits.i = (hf_sign_bit << 16) | float_exp_bits |\n+           (hf_significand_bits << significand_shift);\n+\n+  return bits.f;\n@@ -674,11 +683,0 @@\n-\n-oop SharedRuntime::retrieve_receiver( Symbol* sig, frame caller ) {\n-  assert(caller.is_interpreted_frame(), \"\");\n-  int args_size = ArgumentSizeComputer(sig).size() + 1;\n-  assert(args_size <= caller.interpreter_frame_expression_stack_size(), \"receiver must be on interpreter stack\");\n-  oop result = cast_to_oop(*caller.interpreter_frame_tos_at(args_size - 1));\n-  assert(Universe::heap()->is_in(result) && oopDesc::is_oop(result), \"receiver must be an oop\");\n-  return result;\n-}\n-\n-\n@@ -892,3 +890,4 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n+  \/\/ Remove the ScopedValue bindings in case we got a\n+  \/\/ StackOverflowError while we were trying to remove ScopedValue\n+  \/\/ bindings.\n+  current->clear_scopedValueBindings();\n@@ -1118,0 +1117,2 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n+\n@@ -1132,0 +1133,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -2390,0 +2392,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -2437,4 +2440,0 @@\n-inline double percent(int x, int y) {\n-  return 100.0 * x \/ MAX2(y, 1);\n-}\n-\n@@ -2528,2 +2527,2 @@\n-  int64_t mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;\n-  int64_t mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;\n+  int64_t mono_c = _nof_normal_calls - _nof_megamorphic_calls;\n+  int64_t mono_i = _nof_interface_calls;\n@@ -2533,1 +2532,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));\n@@ -2538,2 +2536,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- megamorphic      \", _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));\n@@ -2782,1 +2778,1 @@\n-                  ResourceObj::C_HEAP, mtCode,\n+                  AnyObj::C_HEAP, mtCode,\n@@ -2831,4 +2827,0 @@\n-extern \"C\" void unexpected_adapter_call() {\n-  ShouldNotCallThis();\n-}\n-\n@@ -3160,1 +3152,1 @@\n-      GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(ces.sig_cc_ro().length(), mtInternal);\n+      GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc_ro().length(), mtInternal);\n@@ -3226,1 +3218,1 @@\n-    GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(ces.sig_cc().length(), mtInternal);\n+    GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc().length(), mtInternal);\n@@ -3380,1 +3372,1 @@\n-        buffer.initialize_stubs_size(128);\n+        buffer.initialize_stubs_size(192);\n@@ -3386,1 +3378,1 @@\n-#if defined(AARCH64)\n+#if defined(AARCH64) || defined(PPC64)\n@@ -3390,1 +3382,5 @@\n-      buffer.initialize_consts_size(8);\n+      \/\/ On PPC64 the continuation enter intrinsic needs the constant pool for the compiled\n+      \/\/ static java call that is resolved in the runtime.\n+      if (PPC64_ONLY(method->is_continuation_enter_intrinsic() &&) true) {\n+        buffer.initialize_consts_size(8 PPC64_ONLY(+ 24));\n+      }\n@@ -3534,0 +3530,2 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n+\n@@ -3677,0 +3675,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -276,2 +276,0 @@\n-  static oop retrieve_receiver(Symbol* sig, frame caller);\n-\n@@ -591,1 +589,0 @@\n-  static int64_t _nof_optimized_calls;            \/\/ total # of statically-bound calls\n@@ -597,2 +594,0 @@\n-  static int64_t _nof_optimized_interface_calls;  \/\/ total # of statically-bound interface calls\n-  static int64_t _nof_megamorphic_interface_calls;\/\/ total # of megamorphic interface calls\n@@ -603,1 +598,0 @@\n-  static address nof_optimized_calls_addr()             { return (address)&_nof_optimized_calls; }\n@@ -608,2 +602,0 @@\n-  static address nof_optimized_interface_calls_addr()   { return (address)&_nof_optimized_interface_calls; }\n-  static address nof_megamorphic_interface_calls_addr() { return (address)&_nof_megamorphic_interface_calls; }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -592,6 +592,0 @@\n-ResolvingSignatureStream::ResolvingSignatureStream(fieldDescriptor& field)\n-  : SignatureStream(field.signature(), false)\n-{\n-  initialize_load_origin(field.field_holder());\n-}\n-\n@@ -605,11 +599,0 @@\n-Klass* ResolvingSignatureStream::as_klass_if_loaded(TRAPS) {\n-  Klass* klass = as_klass(CachedOrNull, THREAD);\n-  \/\/ SD::find does not trigger loading, so there should be no throws\n-  \/\/ Still, bad things can happen, so we CHECK_NULL and ask callers\n-  \/\/ to do likewise.\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-  return klass;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -101,8 +101,0 @@\n-  \/\/ Assuming it is either a class name or signature,\n-  \/\/ determine if it in fact cannot be a class name.\n-  \/\/ This means it either starts with '[' or ends with ';'\n-  static bool not_class_name(const Symbol* signature) {\n-    return (signature->starts_with(JVM_SIGNATURE_ARRAY) ||\n-            signature->ends_with(JVM_SIGNATURE_ENDCLASS));\n-  }\n-\n@@ -234,4 +226,0 @@\n-  static bool fp_is_static(fingerprint_t fingerprint) {\n-    assert(fp_is_valid(fingerprint), \"invalid fingerprint\");\n-    return fingerprint & fp_is_static_bit;\n-  }\n@@ -515,1 +503,0 @@\n-  bool is_primitive() const { return is_java_primitive(_type); }\n@@ -665,6 +652,0 @@\n-  ResolvingSignatureStream(fieldDescriptor& field);\n-\n-  Klass* load_origin()       { return _load_origin; }\n-  Handle class_loader()      { need_handles(); return _class_loader; }\n-  Handle protection_domain() { need_handles(); return _protection_domain; }\n-  Klass* as_klass_if_loaded(TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -44,9 +44,32 @@\n-template <typename OopT>\n-static oop read_oop_local(OopT* p) {\n-  \/\/ We can't do a native access directly from p because load barriers\n-  \/\/ may self-heal. If that happens on a base pointer for compressed oops,\n-  \/\/ then there will be a crash later on. Only the stack watermark API is\n-  \/\/ allowed to heal oops, because it heals derived pointers before their\n-  \/\/ corresponding base pointers.\n-  oop obj = RawAccess<>::oop_load(p);\n-  return NativeAccess<>::oop_load(&obj);\n+static oop oop_from_oop_location(stackChunkOop chunk, void* addr) {\n+  if (addr == nullptr) {\n+    return nullptr;\n+  }\n+\n+  if (UseCompressedOops) {\n+    \/\/ When compressed oops is enabled, an oop location may\n+    \/\/ contain narrow oop values - we deal with that here\n+\n+    if (chunk != NULL && chunk->has_bitmap()) {\n+      \/\/ Transformed stack chunk with narrow oops\n+      return chunk->load_oop((narrowOop*)addr);\n+    }\n+\n+#ifdef _LP64\n+    if (CompressedOops::is_base(*(void**)addr)) {\n+      \/\/ Compiled code may produce decoded oop = narrow_oop_base\n+      \/\/ when a narrow oop implicit null check is used.\n+      \/\/ The narrow_oop_base could be NULL or be the address\n+      \/\/ of the page below heap. Use NULL value for both cases.\n+      return nullptr;\n+    }\n+#endif\n+  }\n+\n+  if (chunk != NULL) {\n+    \/\/ Load oop from chunk\n+    return chunk->load_oop((oop*)addr);\n+  }\n+\n+  \/\/ Load oop from stack\n+  return *(oop*)addr;\n@@ -56,0 +79,42 @@\n+static oop oop_from_narrowOop_location(stackChunkOop chunk, void* addr, bool is_register) {\n+  assert(UseCompressedOops, \"Narrow oops should not exist\");\n+  assert(addr != nullptr, \"Not expecting null address\");\n+  narrowOop* narrow_addr;\n+  if (is_register) {\n+    \/\/ The callee has no clue whether the register holds an int,\n+    \/\/ long or is unused.  He always saves a long.  Here we know\n+    \/\/ a long was saved, but we only want an int back.  Narrow the\n+    \/\/ saved long to the int that the JVM wants.  We can't just\n+    \/\/ use narrow_oop_cast directly, because we don't know what\n+    \/\/ the high bits of the value might be.\n+    narrow_addr = ((narrowOop*)addr) BIG_ENDIAN_ONLY(+ 1);\n+  } else {\n+    narrow_addr = (narrowOop*)addr;\n+  }\n+\n+  if (chunk != NULL) {\n+    \/\/ Load oop from chunk\n+    return chunk->load_oop(narrow_addr);\n+  }\n+\n+  \/\/ Load oop from stack\n+  return CompressedOops::decode(*narrow_addr);\n+}\n+\n+StackValue* StackValue::create_stack_value_from_oop_location(stackChunkOop chunk, void* addr) {\n+  oop val = oop_from_oop_location(chunk, addr);\n+  assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n+         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+  Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n+  return new StackValue(h);\n+}\n+\n+StackValue* StackValue::create_stack_value_from_narrowOop_location(stackChunkOop chunk, void* addr, bool is_register) {\n+  oop val = oop_from_narrowOop_location(chunk, addr, is_register);\n+  assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n+         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+  Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n+  return new StackValue(h);\n+}\n+\n+\n@@ -62,0 +127,1 @@\n+  stackChunkOop chunk = reg_map->stack_chunk()();\n@@ -107,22 +173,2 @@\n-    case Location::narrowoop: {\n-      assert(UseCompressedOops, \"\");\n-      union { intptr_t p; narrowOop noop;} value;\n-      value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-      if (loc.is_register()) {\n-        \/\/ The callee has no clue whether the register holds an int,\n-        \/\/ long or is unused.  He always saves a long.  Here we know\n-        \/\/ a long was saved, but we only want an int back.  Narrow the\n-        \/\/ saved long to the int that the JVM wants.  We can't just\n-        \/\/ use narrow_oop_cast directly, because we don't know what\n-        \/\/ the high bits of the value might be.\n-        static_assert(sizeof(narrowOop) == sizeof(juint), \"size mismatch\");\n-        juint narrow_value = (juint) *(julong*)value_addr;\n-        value.noop = CompressedOops::narrow_oop_cast(narrow_value);\n-      } else {\n-        value.noop = *(narrowOop*) value_addr;\n-      }\n-      \/\/ Decode narrowoop\n-      oop val = read_oop_local(&value.noop);\n-      Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n-      return new StackValue(h);\n-    }\n+    case Location::narrowoop:\n+      return create_stack_value_from_narrowOop_location(reg_map->stack_chunk()(), (void*)value_addr, loc.is_register());\n@@ -130,22 +176,2 @@\n-    case Location::oop: {\n-      oop val;\n-      if (reg_map->in_cont() && reg_map->stack_chunk()->has_bitmap() && UseCompressedOops) {\n-        val = CompressedOops::decode(*(narrowOop*)value_addr);\n-      } else {\n-        val = *(oop *)value_addr;\n-      }\n-#ifdef _LP64\n-      if (CompressedOops::is_base(val)) {\n-         \/\/ Compiled code may produce decoded oop = narrow_oop_base\n-         \/\/ when a narrow oop implicit null check is used.\n-         \/\/ The narrow_oop_base could be NULL or be the address\n-         \/\/ of the page below heap. Use NULL value for both cases.\n-         val = (oop)NULL;\n-      }\n-#endif\n-      val = read_oop_local(&val);\n-      assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n-        p2i(value_addr), reg_map->in_cont(), reg_map->in_cont() && reg_map->stack_chunk()->has_bitmap() && UseCompressedOops);\n-      Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n-      return new StackValue(h);\n-    }\n+    case Location::oop:\n+      return create_stack_value_from_oop_location(reg_map->stack_chunk()(), (void*)value_addr);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":79,"deletions":53,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-address StubRoutines::_atomic_xchg_long_entry                   = NULL;\n-address StubRoutines::_atomic_store_entry                       = NULL;\n-address StubRoutines::_atomic_cmpxchg_byte_entry                = NULL;\n@@ -76,1 +73,0 @@\n-address StubRoutines::_atomic_add_long_entry                    = NULL;\n@@ -131,0 +127,1 @@\n+address StubRoutines::_chacha20Block                       = NULL;\n@@ -133,0 +130,1 @@\n+address StubRoutines::_poly1305_processBlocks              = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,3 +146,0 @@\n-  static address _atomic_xchg_long_entry;\n-  static address _atomic_store_entry;\n-  static address _atomic_cmpxchg_byte_entry;\n@@ -152,1 +149,0 @@\n-  static address _atomic_add_long_entry;\n@@ -212,0 +208,1 @@\n+  static address _chacha20Block;\n@@ -214,0 +211,1 @@\n+  static address _poly1305_processBlocks;\n@@ -318,3 +316,0 @@\n-  static address atomic_xchg_long_entry()                  { return _atomic_xchg_long_entry; }\n-  static address atomic_store_entry()                      { return _atomic_store_entry; }\n-  static address atomic_cmpxchg_byte_entry()               { return _atomic_cmpxchg_byte_entry; }\n@@ -324,1 +319,0 @@\n-  static address atomic_add_long_entry()                   { return _atomic_add_long_entry; }\n@@ -390,0 +384,1 @@\n+  static address poly1305_processBlocks()               { return _poly1305_processBlocks; }\n@@ -392,0 +387,1 @@\n+  static address chacha20Block()         { return _chacha20Block; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                        ResourceObj::C_HEAP, mtThread,\n+                        AnyObj::C_HEAP, mtThread,\n@@ -87,1 +87,1 @@\n-    list = new (ResourceObj::C_HEAP, mtThread) ObjectMonitorsHashtable::PtrList;\n+    list = new (mtThread) ObjectMonitorsHashtable::PtrList;\n@@ -725,11 +725,0 @@\n-\/\/ No exception are possible in this case as we only use this internally when locking is\n-\/\/ correct and we have to wait until notified - so no interrupts or timeouts.\n-void ObjectSynchronizer::wait_uninterruptibly(Handle obj, JavaThread* current) {\n-  CHECK_THROW_NOSYNC_IMSE(obj);\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n-  monitor->wait(0 \/* wait-forever *\/, false \/* not interruptible *\/, current);\n-}\n-\n@@ -1016,1 +1005,0 @@\n-\n@@ -1043,1 +1031,0 @@\n-\/\/ FIXME: jvmti should call this\n@@ -1544,0 +1531,2 @@\n+  size_t unlinked_count = 0;\n+  size_t deleted_count = 0;\n@@ -1553,2 +1542,1 @@\n-    size_t unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer,\n-                                                         &delete_list);\n+    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, &delete_list);\n@@ -1580,1 +1568,0 @@\n-    size_t deleted_count = 0;\n@@ -1591,0 +1578,1 @@\n+    assert(unlinked_count == deleted_count, \"must be\");\n@@ -1595,3 +1583,3 @@\n-    if (deflated_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n-      ls->print_cr(\"deflated \" SIZE_FORMAT \" monitors in %3.7f secs\",\n-                   deflated_count, timer.seconds());\n+    if (deflated_count != 0 || unlinked_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n+      ls->print_cr(\"deflated_count=\" SIZE_FORMAT \", {unlinked,deleted}_count=\" SIZE_FORMAT \" monitors in %3.7f secs\",\n+                   deflated_count, unlinked_count, timer.seconds());\n@@ -1706,0 +1694,1 @@\n+  log_info(monitorinflation)(\"Starting the final audit.\");\n@@ -1708,1 +1697,1 @@\n-    \/\/ Do a deflation in order to reduce the in-use monitor population\n+    \/\/ Do deflations in order to reduce the in-use monitor population\n@@ -1711,1 +1700,1 @@\n-    while (ObjectSynchronizer::deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) >= (size_t)MonitorDeflationMax) {\n+    while (deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) > 0) {\n@@ -1716,1 +1705,1 @@\n-    ObjectSynchronizer::audit_and_print_stats(true \/* on_exit *\/);\n+    audit_and_print_stats(true \/* on_exit *\/);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  GrowableArray<ScopeValue*>* extentLocals = scope()->locals();\n+  GrowableArray<ScopeValue*>* scopedValues = scope()->locals();\n@@ -153,1 +153,1 @@\n-      if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+      if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n@@ -287,1 +287,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n+  GrowableArrayView<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -416,1 +416,1 @@\n-  _locals = new(ResourceObj::C_HEAP, mtCompiler) GrowableArray<jvmtiDeferredLocalVariable*> (1, mtCompiler);\n+  _locals = new(mtCompiler) GrowableArray<jvmtiDeferredLocalVariable*> (1, mtCompiler);\n@@ -539,7 +539,0 @@\n-\n-\n-#ifndef PRODUCT\n-void compiledVFrame::verify() const {\n-  Unimplemented();\n-}\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  DeoptimizationMarker dm;\n@@ -290,1 +289,1 @@\n-    while (ObjectSynchronizer::deflate_idle_monitors(tablep) >= (size_t)MonitorDeflationMax) {\n+    while (ObjectSynchronizer::deflate_idle_monitors(tablep) > 0) {\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,5 +114,0 @@\n-\n-#include CPU_HEADER(vmStructs)\n-#include OS_HEADER(vmStructs)\n-#include OS_CPU_HEADER(vmStructs)\n-\n@@ -147,0 +142,4 @@\n+#include CPU_HEADER(vmStructs)\n+#include OS_HEADER(vmStructs)\n+#include OS_CPU_HEADER(vmStructs)\n+\n@@ -241,1 +240,0 @@\n-  nonstatic_field(InstanceKlass,               _misc_flags,                                   u4)                                    \\\n@@ -548,0 +546,1 @@\n+     static_field(StubRoutines,                _chacha20Block,                                address)                               \\\n@@ -550,0 +549,1 @@\n+     static_field(StubRoutines,                _poly1305_processBlocks,                       address)                               \\\n@@ -715,1 +715,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                              OopHandle)                             \\\n@@ -1052,1 +1052,1 @@\n-  CDS_ONLY(nonstatic_field(FileMapHeader,      _space[0],                 CDSFileMapRegion))                                         \\\n+  CDS_ONLY(nonstatic_field(FileMapHeader,      _regions[0],               CDSFileMapRegion))                                         \\\n@@ -1076,1 +1076,0 @@\n-  nonstatic_field(vframeArray,                 _next,                                         vframeArray*)                          \\\n@@ -1573,1 +1572,1 @@\n-  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n+  declare_c2_type(BlackholeNode, MultiNode)                               \\\n@@ -1577,1 +1576,0 @@\n-  declare_c2_type(Opaque2Node, Node)                                      \\\n@@ -2292,18 +2290,0 @@\n-  \/***************************************\/                               \\\n-  \/* InstanceKlass enums for _misc_flags *\/                               \\\n-  \/***************************************\/                               \\\n-                                                                          \\\n-  declare_constant(InstanceKlass::_misc_rewritten)                        \\\n-  declare_constant(InstanceKlass::_misc_has_nonstatic_fields)             \\\n-  declare_constant(InstanceKlass::_misc_should_verify_class)              \\\n-  declare_constant(InstanceKlass::_misc_is_contended)                     \\\n-  declare_constant(InstanceKlass::_misc_has_nonstatic_concrete_methods)   \\\n-  declare_constant(InstanceKlass::_misc_declares_nonstatic_concrete_methods)\\\n-  declare_constant(InstanceKlass::_misc_has_been_redefined)               \\\n-  declare_constant(InstanceKlass::_misc_is_scratch_class)                 \\\n-  declare_constant(InstanceKlass::_misc_is_shared_boot_class)             \\\n-  declare_constant(InstanceKlass::_misc_is_shared_platform_class)         \\\n-  declare_constant(InstanceKlass::_misc_is_shared_app_class)              \\\n-  declare_constant(InstanceKlass::_misc_carries_identity_modifier)        \\\n-  declare_constant(InstanceKlass::_misc_carries_value_modifier)           \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -38,0 +37,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -37,0 +36,1 @@\n+#include \"jvm.h\"\n@@ -1915,1 +1915,1 @@\n-    _this->_inlined_field_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n+    _this->_inlined_field_map = new (mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n@@ -1969,1 +1969,1 @@\n-    _flat_arrays = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(100, mtServiceability);\n+    _flat_arrays = new (mtServiceability) GrowableArray<oop>(100, mtServiceability);\n@@ -2424,1 +2424,1 @@\n-    _klass_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<Klass*>(INITIAL_CLASS_COUNT, mtServiceability);\n+    _klass_map = new (mtServiceability) GrowableArray<Klass*>(INITIAL_CLASS_COUNT, mtServiceability);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -375,0 +375,3 @@\n+#define PROPERFMT             SIZE_FORMAT \"%s\"\n+#define PROPERFMTARGS(s)      byte_size_in_proper_unit(s), proper_unit_for_byte_size(s)\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-class GrowableArrayBase : public ResourceObj {\n+class GrowableArrayBase : public AnyObj {\n@@ -595,1 +595,1 @@\n-  GrowableArrayNestingCheck(bool on_stack);\n+  GrowableArrayNestingCheck(bool on_resource_area);\n@@ -597,1 +597,1 @@\n-  void on_stack_alloc() const;\n+  void on_resource_area_alloc() const;\n@@ -610,5 +610,4 @@\n-  uintptr_t bits(MEMFLAGS memflags) const {\n-    if (memflags == mtNone) {\n-      \/\/ Stack allocation\n-      return 0;\n-    }\n+  \/\/ Resource allocation\n+  static uintptr_t bits() {\n+    return 0;\n+  }\n@@ -616,1 +615,3 @@\n-    \/\/ CHeap allocation\n+  \/\/ CHeap allocation\n+  static uintptr_t bits(MEMFLAGS memflags) {\n+    assert(memflags != mtNone, \"Must provide a proper MEMFLAGS\");\n@@ -620,1 +621,3 @@\n-  uintptr_t bits(Arena* arena) const {\n+  \/\/ Arena allocation\n+  static uintptr_t bits(Arena* arena) {\n+    assert((uintptr_t(arena) & 1) == 0, \"Required for on_C_heap() to work\");\n@@ -625,0 +628,7 @@\n+  \/\/ Resource allocation\n+  GrowableArrayMetadata() :\n+      _bits(bits())\n+      debug_only(COMMA _nesting_check(true)) {\n+  }\n+\n+  \/\/ Arena allocation\n@@ -627,1 +637,1 @@\n-      debug_only(COMMA _nesting_check(on_stack())) {\n+      debug_only(COMMA _nesting_check(false)) {\n@@ -630,0 +640,1 @@\n+  \/\/ CHeap allocation\n@@ -632,1 +643,1 @@\n-      debug_only(COMMA _nesting_check(on_stack())) {\n+      debug_only(COMMA _nesting_check(false)) {\n@@ -652,1 +663,1 @@\n-  void on_stack_alloc_check() const;\n+  void on_resource_area_alloc_check() const;\n@@ -655,3 +666,3 @@\n-  bool on_C_heap() const { return (_bits & 1) == 1; }\n-  bool on_stack () const { return _bits == 0;      }\n-  bool on_arena () const { return (_bits & 1) == 0 && _bits != 0; }\n+  bool on_C_heap() const        { return (_bits & 1) == 1; }\n+  bool on_resource_area() const { return _bits == 0; }\n+  bool on_arena() const         { return (_bits & 1) == 0 && _bits != 0; }\n@@ -666,2 +677,2 @@\n-\/\/  - Resource stack allocation: if memflags == mtNone\n-\/\/  - CHeap allocation: if memflags != mtNone\n+\/\/  - Resource stack allocation: if no extra argument is provided\n+\/\/  - CHeap allocation: if memflags is provided\n@@ -690,5 +701,1 @@\n-    if (memflags != mtNone) {\n-      return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);\n-    }\n-\n-    return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));\n+    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);\n@@ -706,3 +713,3 @@\n-  bool on_C_heap() const { return _metadata.on_C_heap(); }\n-  bool on_stack () const { return _metadata.on_stack(); }\n-  bool on_arena () const { return _metadata.on_arena(); }\n+  bool on_C_heap() const        { return _metadata.on_C_heap(); }\n+  bool on_resource_area() const { return _metadata.on_resource_area(); }\n+  bool on_arena() const         { return _metadata.on_arena(); }\n@@ -711,2 +718,2 @@\n-    if (on_stack()) {\n-      debug_only(_metadata.on_stack_alloc_check());\n+    if (on_resource_area()) {\n+      debug_only(_metadata.on_resource_area_alloc_check());\n@@ -731,1 +738,11 @@\n-  GrowableArray(int initial_capacity = 2, MEMFLAGS memflags = mtNone) :\n+  GrowableArray() : GrowableArray(2 \/* initial_capacity *\/) {}\n+\n+  explicit GrowableArray(int initial_capacity) :\n+      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+          allocate(initial_capacity),\n+          initial_capacity),\n+      _metadata() {\n+    init_checks();\n+  }\n+\n+  GrowableArray(int initial_capacity, MEMFLAGS memflags) :\n@@ -739,1 +756,9 @@\n-  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags = mtNone) :\n+  GrowableArray(int initial_capacity, int initial_len, const E& filler) :\n+      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+          allocate(initial_capacity),\n+          initial_capacity, initial_len, filler),\n+      _metadata() {\n+    init_checks();\n+  }\n+\n+  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags) :\n@@ -803,1 +828,1 @@\n-    return ResourceObj::operator new(size, ResourceObj::C_HEAP, F);\n+    return AnyObj::operator new(size, F);\n@@ -807,1 +832,1 @@\n-    return ResourceObj::operator new(size, nothrow_constant, ResourceObj::C_HEAP, F);\n+    return AnyObj::operator new(size, nothrow_constant, F);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":57,"deletions":32,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"jvm_io.h\"\n+#include \"jvm_io.h\"\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -722,0 +722,1 @@\n+     * @throws  IndexOutOfBoundsException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1458,11 +1458,15 @@\n-     * <p> If the underlying class is an array class, then its\n-     * {@code public}, {@code private} and {@code protected}\n-     * modifiers are the same as those of its component type.  If this\n-     * {@code Class} object represents a primitive type or void, its\n-     * {@code public} modifier is always {@code true}, and its\n-     * {@code protected} and {@code private} modifiers are always\n-     * {@code false}. If this {@code Class} object represents an array class, a\n-     * primitive type or void, then its {@code final} modifier is always\n-     * {@code true} and its interface modifier is always\n-     * {@code false}. The values of its other modifiers are not determined\n-     * by this specification.\n+     * <p> If the underlying class is an array class:\n+     * <ul>\n+     * <li> its {@code public}, {@code private} and {@code protected}\n+     *      modifiers are the same as those of its component type\n+     * <li> its {@code abstract} and {@code final} modifiers are always\n+     *      {@code true}\n+     * <li> its interface modifier is always {@code false}, even when\n+     *      the component type is an interface\n+     * <\/ul>\n+     * If this {@code Class} object represents a primitive type or\n+     * void, its {@code public}, {@code abstract}, and {@code final}\n+     * modifiers are always {@code true}.\n+     * For {@code Class} objects representing void, primitive types, and\n+     * arrays, the values of other modifiers are {@code false} other\n+     * than as specified above.\n@@ -1482,0 +1486,1 @@\n+     * @jvms 4.1 The {@code ClassFile} Structure\n@@ -1490,11 +1495,13 @@\n-     * <p> If the underlying class is an array class, then its\n-     * {@code PUBLIC}, {@code PRIVATE} and {@code PROTECTED}\n-     * access flags are the same as those of its component type.  If this\n-     * {@code Class} object represents a primitive type or void, the\n-     * {@code PUBLIC} access flag is present, and the\n-     * {@code PROTECTED} and {@code PRIVATE} access flags are always\n-     * absent. If this {@code Class} object represents an array class, a\n-     * primitive type or void, then the {@code FINAL} access flag is always\n-     * present and the interface access flag is always\n-     * absent. The values of its other access flags are not determined\n-     * by this specification.\n+     * <p> If the underlying class is an array class:\n+     * <ul>\n+     * <li> its {@code PUBLIC}, {@code PRIVATE} and {@code PROTECTED}\n+     *      access flags are the same as those of its component type\n+     * <li> its {@code ABSTRACT} and {@code FINAL} flags are present\n+     * <li> its {@code INTERFACE} flag is absent, even when the\n+     *      component type is an interface\n+     * <\/ul>\n+     * If this {@code Class} object represents a primitive type or\n+     * void, the flags are {@code PUBLIC}, {@code ABSTRACT}, and\n+     * {@code FINAL}.\n+     * For {@code Class} objects representing void, primitive types, and\n+     * arrays, access flags are absent other than as specified above.\n@@ -4103,1 +4110,2 @@\n-                   IllegalAccessException ex) { return null; }\n+                   IllegalAccessException | NullPointerException |\n+                   ClassCastException ex) { return null; }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -191,0 +192,3 @@\n+    \/\/ Holder for the initial value of `in`, set within `initPhase1()`.\n+    private static InputStream initialIn;\n+\n@@ -2176,1 +2180,2 @@\n-        setIn0(new BufferedInputStream(fdIn));\n+        initialIn = new BufferedInputStream(fdIn);\n+        setIn0(initialIn);\n@@ -2247,0 +2252,6 @@\n+        \/\/ Emit a warning if java.io.tmpdir is set via the command line\n+        \/\/ to a directory that doesn't exist\n+        if (SystemProps.isBadIoTmpdir()) {\n+            System.err.println(\"WARNING: java.io.tmpdir directory does not exist\");\n+        }\n+\n@@ -2434,2 +2445,2 @@\n-            public void addEnableNativeAccessAllUnnamed() {\n-                Module.implAddEnableNativeAccessAllUnnamed();\n+            public void addEnableNativeAccessToAllUnnamed() {\n+                Module.implAddEnableNativeAccessToAllUnnamed();\n@@ -2437,2 +2448,2 @@\n-            public boolean isEnableNativeAccess(Module m) {\n-                return m.implIsEnableNativeAccess();\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n+                m.ensureNativeAccess(owner, methodName);\n@@ -2481,0 +2492,4 @@\n+            public InputStream initialSystemIn() {\n+                return initialIn;\n+            }\n+\n@@ -2575,2 +2590,10 @@\n-            public Object[] extentLocalCache() {\n-                return Thread.extentLocalCache();\n+            public Object[] scopedValueCache() {\n+                return Thread.scopedValueCache();\n+            }\n+\n+            public void setScopedValueCache(Object[] cache) {\n+                Thread.setScopedValueCache(cache);\n+            }\n+\n+            public Object scopedValueBindings() {\n+                return Thread.scopedValueBindings();\n@@ -2579,2 +2602,2 @@\n-            public void setExtentLocalCache(Object[] cache) {\n-                Thread.setExtentLocalCache(cache);\n+            public Object findScopedValueBindings() {\n+                return Thread.findScopedValueBindings();\n@@ -2583,2 +2606,2 @@\n-            public Object extentLocalBindings() {\n-                return Thread.extentLocalBindings();\n+            public void setScopedValueBindings(Object bindings) {\n+                Thread.setScopedValueBindings(bindings);\n@@ -2587,2 +2610,3 @@\n-            public void setExtentLocalBindings(Object bindings) {\n-                Thread.setExtentLocalBindings(bindings);\n+            @ForceInline\n+            public void ensureMaterializedForStackWalk(Object value) {\n+                Thread.ensureMaterializedForStackWalk(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        if (member.isObjectConstructor() && member.getReturnType() == void.class)\n+        if (member.isObjectConstructor() && member.getMethodType().returnType() == void.class)\n@@ -176,2 +176,2 @@\n-    String internalProperties() {\n-        return \"\\n& DMH.MN=\"+internalMemberName();\n+    String internalProperties(int indentLevel) {\n+        return \"\\n\" + debugPrefix(indentLevel) + \"& DMH.MN=\" + internalMemberName();\n@@ -616,1 +616,1 @@\n-        return member.getReturnType().cast(obj);\n+        return member.getMethodType().returnType().cast(obj);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1047,1 +1047,1 @@\n-        for (Class<?> ptype : mtype.parameterArray())\n+        for (Class<?> ptype : mtype.ptypes())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,10 +371,0 @@\n-    private static Name[] buildNames(Name[] formals, Name[] temps, Name result) {\n-        int arity = formals.length;\n-        int length = arity + temps.length + (result == null ? 0 : 1);\n-        Name[] names = Arrays.copyOf(formals, length);\n-        System.arraycopy(temps, 0, names, arity, temps.length);\n-        if (result != null)\n-            names[length - 1] = result;\n-        return names;\n-    }\n-\n@@ -1036,0 +1026,5 @@\n+        return debugString(-1);\n+    }\n+\n+    String debugString(int indentLevel) {\n+        String prefix = MethodHandle.debugPrefix(indentLevel);\n@@ -1037,1 +1032,2 @@\n-        StringBuilder buf = new StringBuilder(lambdaName + \"=Lambda(\");\n+        StringBuilder buf = new StringBuilder(lambdaName);\n+        buf.append(\"=Lambda(\");\n@@ -1041,1 +1037,1 @@\n-            if (i >= arity)  buf.append(\"\\n    \");\n+            if (i >= arity)  buf.append(\"\\n    \").append(prefix);\n@@ -1090,1 +1086,1 @@\n-        @Stable MethodHandle invoker;\n+        private @Stable MethodType type;\n@@ -1186,4 +1182,0 @@\n-                if (invoker == null) {\n-                    traceInterpreter(\"| getInvoker\", this);\n-                    invoker();\n-                }\n@@ -1205,3 +1197,1 @@\n-            if (invoker != null)  return invoker;\n-            \/\/ Get an invoker and cache it.\n-            return invoker = computeInvoker(methodType().form());\n+            return computeInvoker(methodType().form());\n@@ -1211,1 +1201,9 @@\n-            if (resolvedHandle != null)\n+            MethodType type = this.type;\n+            if (type == null) {\n+                this.type = type = calculateMethodType(member, resolvedHandle);\n+            }\n+            return type;\n+        }\n+\n+        private static MethodType calculateMethodType(MemberName member, MethodHandle resolvedHandle) {\n+            if (resolvedHandle != null) {\n@@ -1213,1 +1211,1 @@\n-            else\n+            } else {\n@@ -1216,0 +1214,1 @@\n+            }\n@@ -1336,0 +1335,2 @@\n+        private static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1342,1 +1343,1 @@\n-            assert(this.index == index);\n+            assert(this.index == index && typesMatch(function, this.arguments));\n@@ -1363,0 +1364,9 @@\n+        Name(NamedFunction function) {\n+            this(-1, function.returnType(), function, EMPTY_ARGS);\n+        }\n+        Name(NamedFunction function, Object arg) {\n+            this(-1, function.returnType(), function, new Object[] { arg });\n+        }\n+        Name(NamedFunction function, Object arg0, Object arg1) {\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+        }\n@@ -1364,2 +1374,1 @@\n-            this(-1, function.returnType(), function, arguments = Arrays.copyOf(arguments, arguments.length, Object[].class));\n-            assert(typesMatch(function, arguments));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n@@ -1532,0 +1541,4 @@\n+            if (arguments == null) {\n+                assert(function == null);\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":38,"deletions":25,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import sun.invoke.util.BytecodeDescriptor;\n@@ -37,4 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -78,1 +73,1 @@\n-};\n+}\n@@ -204,10 +199,0 @@\n-    \/** Utility method producing the parameter types of the method type. *\/\n-    public Class<?>[] getParameterTypes() {\n-        return getMethodType().parameterArray();\n-    }\n-\n-    \/** Utility method producing the return type of the method type. *\/\n-    public Class<?> getReturnType() {\n-        return getMethodType().returnType();\n-    }\n-\n@@ -255,16 +240,0 @@\n-    \/** Utility method to produce the signature of this member,\n-     *  used within the class file format to describe its type.\n-     *\/\n-    public String getSignature() {\n-        if (type == null) {\n-            expandFromVM();\n-            if (type == null) {\n-                return null;\n-            }\n-        }\n-        if (isInvocable())\n-            return BytecodeDescriptor.unparse(getMethodType());\n-        else\n-            return BytecodeDescriptor.unparse(getFieldType());\n-    }\n-\n@@ -362,2 +331,1 @@\n-        assert(getReferenceKind() == oldKind);\n-        assert(MethodHandleNatives.refKindIsValid(refKind));\n+        assert(getReferenceKind() == oldKind && MethodHandleNatives.refKindIsValid(refKind));\n@@ -368,2 +336,2 @@\n-    private boolean testFlags(int mask, int value) {\n-        return (flags & mask) == value;\n+    private boolean matchingFlagsSet(int mask, int flags) {\n+        return (this.flags & mask) == flags;\n@@ -371,2 +339,2 @@\n-    private boolean testAllFlags(int mask) {\n-        return testFlags(mask, mask);\n+    private boolean allFlagsSet(int flags) {\n+        return (this.flags & flags) == flags;\n@@ -374,2 +342,2 @@\n-    private boolean testAnyFlags(int mask) {\n-        return !testFlags(mask, 0);\n+    private boolean anyFlagSet(int flags) {\n+        return (this.flags & flags) != 0;\n@@ -383,2 +351,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == MethodHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == MethodHandle.class) {\n@@ -390,7 +357,4 @@\n-        switch (name) {\n-        case \"invoke\":\n-        case \"invokeExact\":\n-            return true;\n-        default:\n-            return false;\n-        }\n+        return switch (name) {\n+            case \"invoke\", \"invokeExact\" -> true;\n+            default -> false;\n+        };\n@@ -401,2 +365,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == VarHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == VarHandle.class) {\n@@ -466,1 +429,1 @@\n-        return testAllFlags(IS_METHOD | BRIDGE);\n+        return allFlagsSet(IS_METHOD | BRIDGE);\n@@ -470,1 +433,1 @@\n-        return testAllFlags(VARARGS) && isInvocable();\n+        return allFlagsSet(VARARGS) && isInvocable();\n@@ -474,1 +437,1 @@\n-        return testAllFlags(SYNTHETIC);\n+        return allFlagsSet(SYNTHETIC);\n@@ -507,2 +470,0 @@\n-    static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;\n-    static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;\n@@ -512,5 +473,1 @@\n-        return testAnyFlags(IS_INVOCABLE);\n-    }\n-    \/** Utility method to query whether this member is a method, constructor, or field. *\/\n-    public boolean isFieldOrMethod() {\n-        return testAnyFlags(IS_FIELD_OR_METHOD);\n+        return anyFlagSet(IS_INVOCABLE);\n@@ -520,1 +477,1 @@\n-        return testAllFlags(IS_METHOD);\n+        return allFlagsSet(IS_METHOD);\n@@ -524,1 +481,1 @@\n-        return testAllFlags(IS_OBJECT_CONSTRUCTOR);\n+        return allFlagsSet(IS_OBJECT_CONSTRUCTOR);\n@@ -533,1 +490,1 @@\n-        return testAllFlags(IS_FIELD);\n+        return allFlagsSet(IS_FIELD);\n@@ -537,1 +494,1 @@\n-        return testAllFlags(IS_TYPE);\n+        return allFlagsSet(IS_TYPE);\n@@ -541,1 +498,1 @@\n-        return !testAnyFlags(ALL_ACCESS);\n+        return !anyFlagSet(ALL_ACCESS);\n@@ -545,1 +502,1 @@\n-        return testAllFlags(CALLER_SENSITIVE);\n+        return allFlagsSet(CALLER_SENSITIVE);\n@@ -548,7 +505,2 @@\n-    public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }\n-\n-    \/** Utility method to query whether this member is accessible from a given lookup class. *\/\n-    public boolean isAccessibleFrom(Class<?> lookupClass) {\n-        int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);\n-        return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,\n-                                               lookupClass, null, mode);\n+    public boolean isTrustedFinalField() {\n+        return allFlagsSet(TRUSTED_FINAL | IS_FIELD);\n@@ -574,2 +526,1 @@\n-        assert(testAnyFlags(ALL_KINDS));\n-        assert(this.resolution == null);  \/\/ nobody should have touched this yet\n+        assert(anyFlagSet(ALL_KINDS) && this.resolution == null);  \/\/ nobody should have touched this yet\n@@ -595,3 +546,3 @@\n-        assert((flags & RECOGNIZED_MODIFIERS) == 0);\n-        assert((mods & ~RECOGNIZED_MODIFIERS) == 0);\n-        assert((refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n+        assert((flags & RECOGNIZED_MODIFIERS) == 0\n+                && (mods & ~RECOGNIZED_MODIFIERS) == 0\n+                && (refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n@@ -634,1 +585,1 @@\n-        assert(isResolved() && this.clazz != null);\n+        assert(isResolved());\n@@ -676,10 +627,6 @@\n-        byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n-        byte newRefKind = refKind;\n-        MemberName result = this;\n-        switch (refKind) {\n-        case REF_invokeInterface:\n-        case REF_invokeVirtual:\n-        case REF_invokeSpecial:\n-            newRefKind = normalVirtual;\n-            break;\n-        }\n+        byte newRefKind = switch (refKind) {\n+            case REF_invokeInterface,\n+                 REF_invokeVirtual,\n+                 REF_invokeSpecial -> clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n+            default -> refKind;\n+        };\n@@ -689,1 +636,1 @@\n-        result = clone().changeReferenceKind(newRefKind, refKind);\n+        MemberName result = clone().changeReferenceKind(newRefKind, refKind);\n@@ -714,0 +661,4 @@\n+    static {\n+        \/\/ the following MemberName constructor relies on these ranges matching up\n+        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n+    }\n@@ -722,1 +673,0 @@\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n@@ -735,7 +685,1 @@\n-    public MemberName asSetter() {\n-        byte refKind = getReferenceKind();\n-        assert(MethodHandleNatives.refKindIsGetter(refKind));\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n-        byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));\n-        return clone().changeReferenceKind(setterRefKind, refKind);\n-    }\n+\n@@ -877,5 +821,0 @@\n-    \/** Query whether this member name is resolved to a non-static, non-final method.\n-     *\/\n-    public boolean hasReceiverTypeDispatch() {\n-        return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());\n-    }\n@@ -963,1 +902,1 @@\n-        message = message + \": \"+ toString();\n+        message = message + \": \" + this;\n@@ -998,1 +937,1 @@\n-        String message = message() + \": \"+ toString();\n+        String message = message() + \": \" + this;\n@@ -1025,3 +964,1 @@\n-        static Factory INSTANCE = new Factory();\n-\n-        private static int ALLOWED_FLAGS = ALL_KINDS;\n+        static final Factory INSTANCE = new Factory();\n@@ -1029,60 +966,0 @@\n-        \/\/\/ Queries\n-        List<MemberName> getMembers(Class<?> defc,\n-                String matchName, Object matchType,\n-                int matchFlags, Class<?> lookupClass) {\n-            matchFlags &= ALLOWED_FLAGS;\n-            String matchSig = null;\n-            if (matchType != null) {\n-                matchSig = BytecodeDescriptor.unparse(matchType);\n-                if (matchSig.startsWith(\"(\"))\n-                    matchFlags &= ~(ALL_KINDS & ~IS_INVOCABLE);\n-                else\n-                    matchFlags &= ~(ALL_KINDS & ~IS_FIELD);\n-            }\n-            final int BUF_MAX = 0x2000;\n-            int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;\n-            MemberName[] buf = newMemberBuffer(len1);\n-            int totalCount = 0;\n-            ArrayList<MemberName[]> bufs = null;\n-            int bufCount = 0;\n-            for (;;) {\n-                bufCount = MethodHandleNatives.getMembers(defc,\n-                        matchName, matchSig, matchFlags,\n-                        lookupClass,\n-                        totalCount, buf);\n-                if (bufCount <= buf.length) {\n-                    if (bufCount < 0)  bufCount = 0;\n-                    totalCount += bufCount;\n-                    break;\n-                }\n-                \/\/ JVM returned to us with an intentional overflow!\n-                totalCount += buf.length;\n-                int excess = bufCount - buf.length;\n-                if (bufs == null)  bufs = new ArrayList<>(1);\n-                bufs.add(buf);\n-                int len2 = buf.length;\n-                len2 = Math.max(len2, excess);\n-                len2 = Math.max(len2, totalCount \/ 4);\n-                buf = newMemberBuffer(Math.min(BUF_MAX, len2));\n-            }\n-            ArrayList<MemberName> result = new ArrayList<>(totalCount);\n-            if (bufs != null) {\n-                for (MemberName[] buf0 : bufs) {\n-                    Collections.addAll(result, buf0);\n-                }\n-            }\n-            for (int i = 0; i < bufCount; i++) {\n-                result.add(buf[i]);\n-            }\n-            \/\/ Signature matching is not the same as type matching, since\n-            \/\/ one signature might correspond to several types.\n-            \/\/ So if matchType is a Class or MethodType, refilter the results.\n-            if (matchType != null && matchType != matchSig) {\n-                for (Iterator<MemberName> it = result.iterator(); it.hasNext();) {\n-                    MemberName m = it.next();\n-                    if (!matchType.equals(m.getType()))\n-                        it.remove();\n-                }\n-            }\n-            return result;\n-        }\n@@ -1164,64 +1041,0 @@\n-        \/** Return a list of all methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getMethods(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of matching methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned methods will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                String name, MethodType type, Class<?> lookupClass) {\n-            int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all object constructors defined by the given class.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getObjectConstructors(Class<?> defc, Class<?> lookupClass) {\n-            return getMembers(defc, null, null, IS_OBJECT_CONSTRUCTOR, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getFields(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned fields will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                String name, Class<?> type, Class<?> lookupClass) {\n-            int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all nested types defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getNestedTypes(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, null, null, matchFlags, lookupClass);\n-        }\n-        private static MemberName[] newMemberBuffer(int length) {\n-            MemberName[] buf = new MemberName[length];\n-            \/\/ fill the buffer with dummy structs for the JVM to fill in\n-            for (int i = 0; i < length; i++)\n-                buf[i] = new MemberName();\n-            return buf;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":46,"deletions":233,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -285,0 +285,6 @@\n+        if (TRACE_METHOD_LINKAGE) {\n+            MethodHandle target = callSite.getTarget();\n+            System.out.println(\"linkCallSite target class => \" + target.getClass().getName());\n+            System.out.println(\"linkCallSite target => \" + target.debugString(0));\n+        }\n+\n@@ -302,1 +308,1 @@\n-        System.out.println(\"linkCallSite \"+caller.getName()+\" \"+\n+        System.out.println(\"linkCallSite \"+getCallerInfo(caller)+\" \"+\n@@ -308,1 +314,1 @@\n-            System.out.println(\"linkCallSite => \"+res+\" + \"+appendixResult[0]);\n+            System.out.println(\"linkCallSite linkage => \"+res+\" + \"+appendixResult[0]);\n@@ -317,0 +323,14 @@\n+    \/**\n+     * Return a human-readable description of the caller. Something like\n+     * \"java.base\/java.security.Security.<clinit>(Security.java:82)\"\n+     *\/\n+    private static String getCallerInfo(Class<?> caller) {\n+        for (StackTraceElement e : Thread.currentThread().getStackTrace()) {\n+            if (e.getClassName().equals(caller.getName())) {\n+                return e.toString();\n+            }\n+        }\n+        \/\/ fallback if the caller is somehow missing from the stack.\n+        return caller.getName();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -3456,1 +3456,1 @@\n-                assert(ctor.getReturnType() == void.class);\n+                assert(ctor.getMethodType().returnType() == void.class);\n@@ -3460,1 +3460,1 @@\n-                assert(ctor.isMethod() && ctor.getReturnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n+                assert(ctor.isMethod() && ctor.getMethodType().returnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n@@ -7950,1 +7950,1 @@\n-     *     {@code float}, {@code double} or {@link MemoryAddress}.\n+     *     {@code float}, {@code double} or {@link MemorySegment}.\n@@ -7953,1 +7953,1 @@\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n@@ -7956,1 +7956,1 @@\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n@@ -7961,1 +7961,1 @@\n-     * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n+     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n@@ -7964,1 +7964,1 @@\n-     * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n+     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -610,1 +610,5 @@\n-    @Stable private Boolean callerSensitive;       \/\/ lazily initialize\n+    \/\/  0 = not initialized (@Stable contract)\n+    \/\/  1 = initialized, CS\n+    \/\/ -1 = initialized, not CS\n+    @Stable private byte callerSensitive;\n+\n@@ -612,3 +616,3 @@\n-        Boolean cs = callerSensitive;\n-        if (cs == null) {\n-            callerSensitive = cs = Reflection.isCallerSensitive(this);\n+        byte cs = callerSensitive;\n+        if (cs == 0) {\n+            callerSensitive = cs = (byte)(Reflection.isCallerSensitive(this) ? 1 : -1);\n@@ -616,1 +620,1 @@\n-        return cs;\n+        return (cs > 0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -273,1 +274,1 @@\n-    void addEnableNativeAccessAllUnnamed();\n+    void addEnableNativeAccessToAllUnnamed();\n@@ -276,1 +277,2 @@\n-     * Returns true if module m can access restricted methods.\n+     * Ensure that the given module has native access. If not, warn or\n+     * throw exception depending on the configuration.\n@@ -278,1 +280,1 @@\n-    boolean isEnableNativeAccess(Module m);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n@@ -365,0 +367,6 @@\n+    \/**\n+     * Returns the initial `System.in` to determine if it is replaced\n+     * with `System.setIn(newIn)` method\n+     *\/\n+    InputStream initialSystemIn();\n+\n@@ -478,1 +486,1 @@\n-     * Returns the current thread's extent locals cache\n+     * Returns the current thread's scoped values cache\n@@ -480,1 +488,1 @@\n-    Object[] extentLocalCache();\n+    Object[] scopedValueCache();\n@@ -483,1 +491,1 @@\n-     * Sets the current thread's extent locals cache\n+     * Sets the current thread's scoped values cache\n@@ -485,1 +493,1 @@\n-    void setExtentLocalCache(Object[] cache);\n+    void setScopedValueCache(Object[] cache);\n@@ -488,1 +496,1 @@\n-     * Return the current thread's extent local bindings.\n+     * Return the current thread's scoped value bindings.\n@@ -490,1 +498,1 @@\n-    Object extentLocalBindings();\n+    Object scopedValueBindings();\n@@ -493,1 +501,1 @@\n-     * Set the current thread's extent local bindings.\n+     * Set the current thread's scoped value bindings.\n@@ -495,1 +503,5 @@\n-    void setExtentLocalBindings(Object bindings);\n+    void setScopedValueBindings(Object bindings);\n+\n+    Object findScopedValueBindings();\n+\n+    void ensureMaterializedForStackWalk(Object value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V20) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V21) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+    int V21 = 0 << 16 | 65;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -168,1 +168,4 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.incubator.concurrent,\n+        jdk.sctp,\n+        jdk.crypto.cryptoki;\n@@ -173,0 +176,3 @@\n+    exports jdk.internal.io to\n+        jdk.internal.le,\n+        jdk.jshell;\n@@ -247,0 +253,1 @@\n+        jdk.incubator.concurrent,\n@@ -253,0 +260,1 @@\n+        jdk.incubator.concurrent,\n@@ -309,1 +317,2 @@\n-        jdk.crypto.ec;\n+        jdk.crypto.ec,\n+        jdk.incubator.concurrent;\n@@ -407,0 +416,1 @@\n+    uses jdk.internal.io.JdkConsoleProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -119,4 +119,0 @@\n-    public static String unparse(MethodType type) {\n-        return unparseMethod(type.returnType(), type.parameterArray());\n-    }\n-\n@@ -127,1 +123,1 @@\n-            return unparse((MethodType) type);\n+            return ((MethodType) type).toMethodDescriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-        R r = scan(node.getVariable(), p);\n+        R r = scan(node.getVariableOrRecordPattern(), p);\n@@ -868,1 +868,0 @@\n-        r = scanAndReduce(node.getVariable(), p, r);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,5 +109,0 @@\n-import com.sun.tools.javac.tree.DCTree.DCBlockTag;\n-import com.sun.tools.javac.tree.DCTree.DCComment;\n-import com.sun.tools.javac.tree.DCTree.DCEndPosTree;\n-import com.sun.tools.javac.tree.DCTree.DCEntity;\n-import com.sun.tools.javac.tree.DCTree.DCErroneous;\n@@ -118,1 +113,0 @@\n-import com.sun.tools.javac.tree.DCTree.DCText;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-      * 16, tbd\n+      * 16, records and pattern matching for instanceof\n@@ -113,1 +113,1 @@\n-      * 17, tbd\n+      * 17, sealed classes, restoration of always-strict floating-point\n@@ -118,1 +118,1 @@\n-      * 18, tbd\n+      * 18, no major changes\n@@ -123,1 +123,1 @@\n-      * 19, tbd\n+      * 19, no major changes\n@@ -128,1 +128,1 @@\n-      * 20, tbd\n+      * 20, no major changes\n@@ -130,1 +130,6 @@\n-    JDK20(\"20\");\n+    JDK20(\"20\"),\n+\n+    \/**\n+      * 21, tbd\n+      *\/\n+    JDK21(\"21\");\n@@ -182,0 +187,1 @@\n+        case JDK21  -> Target.JDK1_21;\n@@ -320,0 +326,1 @@\n+        case JDK21  -> RELEASE_21;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1568,1 +1568,1 @@\n-        public RecordComponent createRecordComponent(RecordComponent existing, JCVariableDecl var, List<JCAnnotation> annotations) {\n+        public RecordComponent createRecordComponent(RecordComponent existing, JCVariableDecl rcDecl, VarSymbol varSym) {\n@@ -1572,1 +1572,1 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, existing.originalAnnos, existing.isVarargs));\n+                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n@@ -1575,1 +1575,1 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, annotations));\n+                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, rcDecl));\n@@ -1836,3 +1836,1 @@\n-        \/* the original annotations applied to the record component\n-         *\/\n-        private final List<JCAnnotation> originalAnnos;\n+\n@@ -1846,0 +1844,2 @@\n+        private JCVariableDecl ast;\n+\n@@ -1852,1 +1852,1 @@\n-            originalAnnos = List.nil();\n+            ast = null;\n@@ -1856,2 +1856,2 @@\n-        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations) {\n-            this(field, annotations, field.type.hasTag(TypeTag.ARRAY) && ((ArrayType)field.type).isVarargs());\n+        public RecordComponent(VarSymbol field, JCVariableDecl ast) {\n+            this(field, ast, field.type.hasTag(TypeTag.ARRAY) && ((ArrayType)field.type).isVarargs());\n@@ -1860,1 +1860,1 @@\n-        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations, boolean isVarargs) {\n+        public RecordComponent(VarSymbol field, JCVariableDecl ast, boolean isVarargs) {\n@@ -1862,1 +1862,1 @@\n-            this.originalAnnos = annotations;\n+            this.ast = ast;\n@@ -1872,1 +1872,3 @@\n-        public List<JCAnnotation> getOriginalAnnos() { return originalAnnos; }\n+        public List<JCAnnotation> getOriginalAnnos() { return this.ast == null ? List.nil() : this.ast.mods.annotations; }\n+\n+        public JCVariableDecl declarationFor() { return this.ast; }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    public final Type nullPointerExceptionType;\n@@ -571,0 +572,1 @@\n+        nullPointerExceptionType = enterClass(\"java.lang.NullPointerException\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2333,0 +2333,5 @@\n+        public void setNormal() {\n+            Assert.check(this.kind == Kind.CAPTURED);\n+            this.kind = Kind.NORMAL;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n@@ -87,0 +88,1 @@\n+import static com.sun.tools.javac.code.Flags.RECORD;\n@@ -1087,1 +1089,5 @@\n-\n+                case DECONSTRUCTION_PATTERN: {\n+                    \/\/ TODO: Treat case labels as full type contexts for complete type annotation support in Record Patterns\n+                    \/\/    https:\/\/bugs.openjdk.org\/browse\/JDK-8298154\n+                    return TypeAnnotationPosition.unknown;\n+                }\n@@ -1305,0 +1311,10 @@\n+\n+            \/\/ Now that type and declaration annotations have been segregated into their own buckets ...\n+            if (sigOnly) {\n+                if (tree.sym != null && tree.sym.getKind() == ElementKind.FIELD && (tree.sym.flags_field & RECORD) != 0) {\n+                    RecordComponent rc = ((ClassSymbol)tree.sym.owner).getRecordComponent(tree.sym);\n+                    rc.setTypeAttributes(tree.sym.getRawTypeAttributes());\n+                    \/\/ to get all the type annotations applied to the type\n+                    rc.type = tree.sym.type;\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        qualifiedSymbolCache = new HashMap<>();\n@@ -3750,0 +3751,50 @@\n+    \/** Cache the symbol to reflect the qualifying type.\n+     *  key: corresponding type\n+     *  value: qualified symbol\n+     *\/\n+    private Map<Type, Symbol> qualifiedSymbolCache;\n+\n+    public void clearQualifiedSymbolCache() {\n+        qualifiedSymbolCache.clear();\n+    }\n+\n+    \/** Construct a symbol to reflect the qualifying type that should\n+     *  appear in the byte code as per JLS 13.1.\n+     *\n+     *  For {@literal target >= 1.2}: Clone a method with the qualifier as owner (except\n+     *  for those cases where we need to work around VM bugs).\n+     *\n+     *  For {@literal target <= 1.1}: If qualified variable or method is defined in a\n+     *  non-accessible class, clone it with the qualifier class as owner.\n+     *\n+     *  @param sym    The accessed symbol\n+     *  @param site   The qualifier's type.\n+     *\/\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n+\n+        if (site.hasTag(ARRAY)) {\n+            if (sym == syms.lengthVar ||\n+                    sym.owner != syms.arrayClass)\n+                return sym;\n+            \/\/ array clone can be qualified by the array type in later targets\n+            Symbol qualifier;\n+            if ((qualifier = qualifiedSymbolCache.get(site)) == null) {\n+                qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name, site, syms.noSymbol);\n+                qualifiedSymbolCache.put(site, qualifier);\n+            }\n+            return sym.clone(qualifier);\n+        }\n+\n+        if (sym.owner == site.tsym ||\n+                (sym.flags() & (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {\n+            return sym;\n+        }\n+\n+        \/\/ leave alone methods inherited from Object\n+        \/\/ JLS 13.1.\n+        if (sym.owner == syms.objectType.tsym)\n+            return sym;\n+\n+        return sym.clone(site.tsym);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -1532,0 +1533,1 @@\n+\n@@ -1538,2 +1540,2 @@\n-            Type elemtype = types.elemtype(exprType); \/\/ perhaps expr is an array?\n-            if (elemtype == null) {\n+            tree.elementType = types.elemtype(exprType); \/\/ perhaps expr is an array?\n+            if (tree.elementType == null) {\n@@ -1546,1 +1548,1 @@\n-                    elemtype = types.createErrorType(exprType);\n+                    tree.elementType = types.createErrorType(exprType);\n@@ -1549,1 +1551,1 @@\n-                    elemtype = iterableParams.isEmpty()\n+                    tree.elementType = iterableParams.isEmpty()\n@@ -1563,3 +1565,33 @@\n-            if (tree.var.isImplicitlyTyped()) {\n-                Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);\n-                setSyntheticVariableType(tree.var, inferredType);\n+            if (tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                if (jcVariableDecl.isImplicitlyTyped()) {\n+                    Type inferredType = chk.checkLocalVarType(jcVariableDecl, tree.elementType, jcVariableDecl.name);\n+                    setSyntheticVariableType(jcVariableDecl, inferredType);\n+                }\n+                attribStat(jcVariableDecl, loopEnv);\n+                chk.checkType(tree.expr.pos(), tree.elementType, jcVariableDecl.sym.type);\n+\n+                loopEnv.tree = tree; \/\/ before, we were not in loop!\n+                attribStat(tree.body, loopEnv);\n+            } else {\n+                Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN);\n+                JCRecordPattern jcRecordPattern = (JCRecordPattern) tree.varOrRecordPattern;\n+\n+                attribExpr(jcRecordPattern, loopEnv, tree.elementType);\n+\n+                \/\/ for(<pattern> x : xs) { y }\n+                \/\/ we include x's bindings when true in y\n+                \/\/ we don't do anything with x's bindings when false\n+\n+                MatchBindings forWithRecordPatternBindings = matchBindings;\n+                Env<AttrContext> recordPatternEnv = bindingEnv(loopEnv, forWithRecordPatternBindings.bindingsWhenTrue);\n+\n+                Type clazztype = jcRecordPattern.type;\n+\n+                checkCastablePattern(tree.expr.pos(), tree.elementType, clazztype);\n+\n+                recordPatternEnv.tree = tree; \/\/ before, we were not in loop!\n+                try {\n+                    attribStat(tree.body, recordPatternEnv);\n+                } finally {\n+                    recordPatternEnv.info.scope.leave();\n+                }\n@@ -1567,4 +1599,0 @@\n-            attribStat(tree.var, loopEnv);\n-            chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);\n-            loopEnv.tree = tree; \/\/ before, we were not in loop!\n-            attribStat(tree.body, loopEnv);\n@@ -1684,1 +1712,2 @@\n-                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL));\n+                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL) ||\n+                                                    TreeInfo.isNullCaseLabel(l));\n@@ -1696,1 +1725,0 @@\n-            MatchBindings prevBindings = null;\n@@ -1706,1 +1734,1 @@\n-                MatchBindings currentBindings = prevBindings;\n+                MatchBindings currentBindings = null;\n@@ -1770,1 +1798,1 @@\n-                        attribExpr(pat, switchEnv);\n+                        attribExpr(pat, switchEnv, seltype);\n@@ -1824,3 +1852,0 @@\n-\n-                prevBindings = c.caseKind == CaseTree.CaseKind.STATEMENT && c.completesNormally ? currentBindings\n-                                                                                                : null;\n@@ -4126,1 +4151,1 @@\n-            attribTree(tree.pattern, env, unknownExprInfo);\n+            attribExpr(tree.pattern, env, exprtype);\n@@ -4167,0 +4192,4 @@\n+        \/\/ if any type is erroneous, the problem is reported elsewhere\n+        if (exprType.isErroneous() || pattType.isErroneous()) {\n+            return false;\n+        }\n@@ -4190,2 +4219,1 @@\n-            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n-            type = attribTree(tree.var.vartype, env, varInfo);\n+            type = attribType(tree.var.vartype, env);\n@@ -4214,2 +4242,11 @@\n-        tree.type = attribType(tree.deconstructor, env);\n-        Type site = types.removeWildcards(tree.type);\n+        Type type = attribType(tree.deconstructor, env);\n+        if (type.isRaw() && type.tsym.getTypeParameters().nonEmpty()) {\n+            Type inferred = infer.instantiatePatternType(resultInfo.pt, type.tsym);\n+            if (inferred == null) {\n+                log.error(tree.pos(), Errors.PatternTypeCannotInfer);\n+            } else {\n+                type = inferred;\n+            }\n+        }\n+        tree.type = tree.deconstructor.type = type;\n+        Type site = types.capture(tree.type);\n@@ -4219,3 +4256,0 @@\n-            if (record.type.getTypeArguments().nonEmpty() && tree.type.isRaw()) {\n-                log.error(tree.pos(),Errors.RawDeconstructionPattern);\n-            }\n@@ -4224,1 +4258,3 @@\n-                                        .map(rc -> types.memberType(site, rc)).collect(List.collector());\n+                                        .map(rc -> types.memberType(site, rc))\n+                                        .map(t -> types.upward(t, types.captures(t)).baseType())\n+                                        .collect(List.collector());\n@@ -4228,1 +4264,1 @@\n-            expectedRecordTypes = Stream.generate(() -> Type.noType)\n+            expectedRecordTypes = Stream.generate(() -> types.createErrorType(tree.type))\n@@ -4231,0 +4267,1 @@\n+            tree.record = syms.errSymbol;\n@@ -4238,4 +4275,1 @@\n-                boolean nestedIsVarPattern = false;\n-                nestedIsVarPattern |= nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n-                                      ((JCBindingPattern) nestedPatterns.head).var.vartype == null;\n-                attribExpr(nestedPatterns.head, localEnv, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+                attribExpr(nestedPatterns.head, localEnv, recordTypes.head);\n@@ -4259,15 +4293,0 @@\n-            if (tree.var != null) {\n-                BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.type,\n-                                                    localEnv.info.scope.owner);\n-                v.pos = tree.pos;\n-                tree.var.sym = v;\n-                if (chk.checkUnique(tree.var.pos(), v, localEnv.info.scope)) {\n-                    chk.checkTransparentVar(tree.var.pos(), v, localEnv.info.scope);\n-                }\n-                if (tree.var.vartype != null) {\n-                    annotate.annotateLater(tree.var.mods.annotations, localEnv, v, tree.pos());\n-                    annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, localEnv, v, tree.var.pos());\n-                    annotate.flush();\n-                }\n-                outBindings.add(v);\n-            }\n@@ -4718,1 +4737,1 @@\n-                    return v.type = types.createErrorType(v.type);\n+                    return tree.type = v.type = types.createErrorType(v.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":67,"deletions":48,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -3262,3 +3262,19 @@\n-                    rc.setTypeAttributes(s.getRawTypeAttributes());\n-                    \/\/ to get all the type annotations applied to the type\n-                    rc.type = s.type;\n+\n+                    JCVariableDecl fieldAST = (JCVariableDecl) declarationTree;\n+                    for (JCAnnotation fieldAnnot : fieldAST.mods.annotations) {\n+                        for (JCAnnotation rcAnnot : rc.declarationFor().mods.annotations) {\n+                            if (rcAnnot.pos == fieldAnnot.pos) {\n+                                rcAnnot.setType(fieldAnnot.type);\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    \/* At this point, we used to carry over any type annotations from the VARDEF to the record component, but\n+                     * that is problematic, since we get here only when *some* annotation is applied to the SE5 (declaration)\n+                     * annotation location, inadvertently failing to carry over the type annotations when the VarDef has no\n+                     * annotations in the SE5 annotation location.\n+                     *\n+                     * Now type annotations are assigned to record components in a method that would execute irrespective of\n+                     * whether there are SE5 annotations on a VarDef viz com.sun.tools.javac.code.TypeAnnotations.TypeAnnotationPositions.visitVarDef\n+                     *\/\n@@ -4597,9 +4613,0 @@\n-        boolean wasConstant = false;          \/\/ Seen a constant in the same case label\n-        boolean wasDefault = false;           \/\/ Seen a default in the same case label\n-        boolean wasNullPattern = false;       \/\/ Seen a null pattern in the same case label,\n-                                              \/\/or fall through from a null pattern\n-        boolean wasPattern = false;           \/\/ Seen a pattern in the same case label\n-                                              \/\/or fall through from a pattern\n-        boolean wasTypePattern = false;       \/\/ Seen a pattern in the same case label\n-                                              \/\/or fall through from a type pattern\n-        boolean wasNonEmptyFallThrough = false;\n@@ -4608,11 +4615,9 @@\n-            for (JCCaseLabel label : c.labels) {\n-                if (label.hasTag(CONSTANTCASELABEL)) {\n-                    JCExpression expr = ((JCConstantCaseLabel) label).expr;\n-                    if (TreeInfo.isNull(expr)) {\n-                        if (wasPattern && !wasTypePattern && !wasNonEmptyFallThrough) {\n-                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n-                        }\n-                        wasNullPattern = true;\n-                    } else {\n-                        if (wasPattern && !wasNonEmptyFallThrough) {\n-                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n+            if (c.labels.head instanceof JCConstantCaseLabel constLabel) {\n+                if (TreeInfo.isNull(constLabel.expr)) {\n+                    if (c.labels.tail.nonEmpty()) {\n+                        if (c.labels.tail.head instanceof JCDefaultCaseLabel defLabel) {\n+                            if (c.labels.tail.tail.nonEmpty()) {\n+                                log.error(c.labels.tail.tail.head.pos(), Errors.InvalidCaseLabelCombination);\n+                            }\n+                        } else {\n+                            log.error(c.labels.tail.head.pos(), Errors.InvalidCaseLabelCombination);\n@@ -4620,14 +4625,5 @@\n-                        wasConstant = true;\n-                    }\n-                } else if (label.hasTag(DEFAULTCASELABEL)) {\n-                    if (wasPattern && !wasNonEmptyFallThrough) {\n-                        log.error(label.pos(), Errors.FlowsThroughFromPattern);\n-                    wasDefault = true;\n-                    JCPattern pat = ((JCPatternCaseLabel) label).pat;\n-                    while (pat instanceof JCParenthesizedPattern parenthesized) {\n-                        pat = parenthesized.pattern;\n-                    }\n-                    boolean isTypePattern = pat.hasTag(BINDINGPATTERN);\n-                    if (wasPattern || wasConstant || wasDefault ||\n-                        (wasNullPattern && (!isTypePattern || wasNonEmptyFallThrough))) {\n-                        log.error(label.pos(), Errors.FlowsThroughToPattern);\n+                    for (JCCaseLabel label : c.labels.tail) {\n+                        if (!(label instanceof JCConstantCaseLabel) || TreeInfo.isNullCaseLabel(label)) {\n+                            log.error(label.pos(), Errors.InvalidCaseLabelCombination);\n+                            break;\n+                        }\n@@ -4637,2 +4633,4 @@\n-                    wasPattern = true;\n-                    wasTypePattern = isTypePattern;\n+                }\n+            } else {\n+                if (c.labels.tail.nonEmpty()) {\n+                    log.error(c.labels.tail.head.pos(), Errors.FlowsThroughFromPattern);\n@@ -4641,0 +4639,1 @@\n+        }\n@@ -4642,2 +4641,25 @@\n-            boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? c.completesNormally\n-                                                                                  : false;\n+        boolean isCaseStatementGroup = cases.nonEmpty() &&\n+                                       cases.head.caseKind == CaseTree.CaseKind.STATEMENT;\n+\n+        if (isCaseStatementGroup) {\n+            boolean previousCompletessNormally = false;\n+            for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+                JCCase c = l.head;\n+                if (previousCompletessNormally &&\n+                    c.stats.nonEmpty() &&\n+                    c.labels.head instanceof JCPatternCaseLabel patternLabel &&\n+                    hasBindings(patternLabel.pat)) {\n+                    log.error(c.labels.head.pos(), Errors.FlowsThroughToPattern);\n+                } else if (c.stats.isEmpty() &&\n+                           c.labels.head instanceof JCPatternCaseLabel patternLabel &&\n+                           hasBindings(patternLabel.pat) &&\n+                           hasStatements(l.tail)) {\n+                    log.error(c.labels.head.pos(), Errors.FlowsThroughFromPattern);\n+                }\n+                previousCompletessNormally = c.completesNormally;\n+            }\n+        }\n+    }\n+\n+    boolean hasBindings(JCPattern p) {\n+        boolean[] bindings = new boolean[1];\n@@ -4645,6 +4667,5 @@\n-            if (c.stats.nonEmpty()) {\n-                wasConstant = false;\n-                wasDefault = false;\n-                wasNullPattern &= completesNormally;\n-                wasPattern &= completesNormally;\n-                wasTypePattern &= completesNormally;\n+        new TreeScanner() {\n+            @Override\n+            public void visitBindingPattern(JCBindingPattern tree) {\n+                bindings[0] = true;\n+                super.visitBindingPattern(tree);\n@@ -4652,0 +4673,1 @@\n+        }.scan(p);\n@@ -4653,2 +4675,1 @@\n-            wasNonEmptyFallThrough = c.stats.nonEmpty() && completesNormally;\n-        }\n+        return bindings[0];\n@@ -4657,0 +4678,9 @@\n+    boolean hasStatements(List<JCCase> cases) {\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            if (l.head.stats.nonEmpty()) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n@@ -4659,0 +4689,3 @@\n+        boolean seenDefault = false;\n+        boolean seenDefaultLabel = false;\n+        boolean warnDominatedByDefault = false;\n@@ -4662,1 +4695,4 @@\n-                if (label.hasTag(DEFAULTCASELABEL) || TreeInfo.isNullCaseLabel(label)) {\n+                if (label.hasTag(DEFAULTCASELABEL)) {\n+                    seenDefault = true;\n+                    seenDefaultLabel |=\n+                            TreeInfo.isNullCaseLabel(c.labels.head);\n@@ -4665,0 +4701,13 @@\n+                if (TreeInfo.isNullCaseLabel(label)) {\n+                    if (seenDefault) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                    }\n+                    continue;\n+                }\n+                if (seenDefault && !warnDominatedByDefault) {\n+                    if (label.hasTag(PATTERNCASELABEL) ||\n+                        (label instanceof JCConstantCaseLabel && seenDefaultLabel)) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                        warnDominatedByDefault = true;\n+                    }\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":99,"deletions":50,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.code.Types.UniqueType;\n@@ -649,1 +650,15 @@\n-            visitVarDef(tree.var);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+\n+                Set<Symbol> coveredSymbols =\n+                        coveredSymbols(jcRecordPattern.pos(), List.of(jcRecordPattern));\n+\n+                boolean isExhaustive =\n+                        isExhaustive(jcRecordPattern.pos(), tree.elementType, coveredSymbols);\n+\n+                if (!isExhaustive) {\n+                    log.error(tree, Errors.ForeachNotExhaustiveOnType(jcRecordPattern.type, tree.elementType));\n+                }\n+            }\n@@ -693,1 +708,1 @@\n-                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -728,1 +743,1 @@\n-            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -740,1 +755,1 @@\n-                                                   JCExpression selector, List<JCCase> cases) {\n+                                                   List<JCCase> cases) {\n@@ -748,1 +763,1 @@\n-            return coveredSymbols(pos, selector.type, labelValues);\n+            return coveredSymbols(pos, labelValues);\n@@ -751,1 +766,1 @@\n-        private Set<Symbol> coveredSymbols(DiagnosticPosition pos, Type targetType,\n+        private Set<Symbol> coveredSymbols(DiagnosticPosition pos,\n@@ -754,1 +769,1 @@\n-            Map<Symbol, List<JCRecordPattern>> deconstructionPatternsBySymbol = new HashMap<>();\n+            Map<UniqueType, List<JCRecordPattern>> deconstructionPatternsByType = new HashMap<>();\n@@ -766,1 +781,1 @@\n-                        Symbol type = dpat.record;\n+                        UniqueType type = new UniqueType(dpat.type, types);\n@@ -768,1 +783,1 @@\n-                                deconstructionPatternsBySymbol.getOrDefault(type, List.nil())\n+                                deconstructionPatternsByType.getOrDefault(type, List.nil())\n@@ -771,1 +786,1 @@\n-                        deconstructionPatternsBySymbol.put(type, augmentedPatterns);\n+                        deconstructionPatternsByType.put(type, augmentedPatterns);\n@@ -782,3 +797,5 @@\n-            for (Entry<Symbol, List<JCRecordPattern>> e : deconstructionPatternsBySymbol.entrySet()) {\n-                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), 0)) {\n-                    coveredSymbols.add(e.getKey());\n+            for (Entry<UniqueType, List<JCRecordPattern>> e : deconstructionPatternsByType.entrySet()) {\n+                if (e.getValue().stream().anyMatch(r -> r.nested.size() != r.record.getRecordComponents().size())) {\n+                    coveredSymbols.add(syms.errSymbol);\n+                } else if (coversDeconstructionFromComponent(pos, e.getKey().type, e.getValue(), 0)) {\n+                    coveredSymbols.add(e.getKey().type.tsym);\n@@ -791,1 +808,1 @@\n-                                                          Type targetType,\n+                                                          Type recordType,\n@@ -814,1 +831,1 @@\n-            Type instantiatedComponentType = types.memberType(targetType, components.get(component));\n+            Type instantiatedComponentType = types.memberType(recordType, components.get(component));\n@@ -816,1 +833,1 @@\n-            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos, instantiatedComponentType,\n+            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos,\n@@ -856,1 +873,1 @@\n-                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), component + 1)) {\n+                if (coversDeconstructionFromComponent(pos, recordType, e.getValue(), component + 1)) {\n@@ -937,1 +954,1 @@\n-                    yield covered.contains(seltype.tsym);\n+                    yield covered.contains(types.erasure(seltype).tsym);\n@@ -1360,1 +1377,5 @@\n-            visitVarDef(tree.var);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+            }\n@@ -2022,4 +2043,4 @@\n-                    if (!uninits.isMember(sym.adr)) {\n-                        \/\/assignment targeting an effectively final variable\n-                        \/\/makes the variable lose its status of effectively final\n-                        \/\/if the variable is _not_ definitively unassigned\n+                    if (inits.isMember(sym.adr) || !uninits.isMember(sym.adr)) {\n+                        \/\/assignment targeting an effectively final variable makes the\n+                        \/\/variable lose its status of effectively final if the variable\n+                        \/\/is definitely assigned or _not_ definitively unassigned\n@@ -2027,2 +2048,1 @@\n-                    } else {\n-                        uninit(sym);\n+                    uninit(sym);\n@@ -2214,4 +2234,0 @@\n-                if (tree.sym == null) {\n-                    return;\n-                }\n-\n@@ -2305,9 +2321,0 @@\n-                if (tree.body == null) {\n-                    return;\n-                }\n-                \/*  Ignore synthetic methods, except for translated lambda methods.\n-                 *\/\n-                if ((tree.sym.flags() & (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {\n-                    return;\n-                }\n-\n@@ -2563,2 +2570,0 @@\n-            visitVarDef(tree.var);\n-\n@@ -2573,1 +2578,7 @@\n-            letInit(tree.pos(), tree.var.sym);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+                letInit(tree.pos(), jcVariableDecl.sym);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+            }\n+\n@@ -3051,8 +3062,0 @@\n-        @Override\n-        public void visitRecordPattern(JCRecordPattern tree) {\n-            super.visitRecordPattern(tree);\n-            if (tree.var != null) {\n-                initParam(tree.var);\n-            }\n-        }\n-\n@@ -3233,1 +3236,0 @@\n-            scan(tree.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":52,"deletions":50,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-import java.util.HashMap;\n-import java.util.HashSet;\n+import java.util.LinkedHashMap;\n@@ -72,0 +71,1 @@\n+import java.util.Comparator;\n@@ -510,2 +510,5 @@\n-        List<Type> formals = vars;\n-        for (Type t : todo) {\n+        replaceTypeVarsInBounds(todo.toList(), inferenceContext);\n+    }\n+\n+    private void replaceTypeVarsInBounds(List<Type> vars, InferenceContext inferenceContext) {\n+        for (Type t : vars) {\n@@ -519,1 +522,0 @@\n-            formals = formals.tail;\n@@ -654,0 +656,116 @@\n+\n+    \/**\n+     * Infer record type for pattern matching. Given an expression type\n+     * (@code expressionType}), and a given record ({@code patternTypeSymbol}),\n+     * a parameterized type of {@code patternTypeSymbol} is inferred\n+     * according to JLS 18.5.5.\n+     *\n+     * @param expressionType\n+     * @param patternTypeSymbol\n+     * @return\n+     *\/\n+    public Type instantiatePatternType(Type expressionType, TypeSymbol patternTypeSymbol) {\n+        if (expressionType.tsym == patternTypeSymbol)\n+            return expressionType;\n+\n+        \/\/step 1:\n+        List<Type> expressionTypes = List.nil();\n+        List<Type> params = patternTypeSymbol.type.allparams();\n+        List<Type> capturedWildcards = List.nil();\n+        List<Type> todo = List.of(expressionType);\n+        while (todo.nonEmpty()) {\n+            Type current = todo.head;\n+            todo = todo.tail;\n+            switch (current.getTag()) {\n+                case CLASS -> {\n+                    if (current.isCompound()) {\n+                        todo = todo.prependList(types.directSupertypes(current));\n+                    } else {\n+                        Type captured = types.capture(current);\n+\n+                        for (Type ta : captured.getTypeArguments()) {\n+                            if (ta.hasTag(TYPEVAR) && ((TypeVar) ta).isCaptured()) {\n+                                params = params.prepend((TypeVar) ta);\n+                                capturedWildcards = capturedWildcards.prepend(ta);\n+                            }\n+                        }\n+                        expressionTypes = expressionTypes.prepend(captured);\n+                    }\n+                }\n+                case TYPEVAR -> {\n+                    todo = todo.prepend(types.skipTypeVars(current, false));\n+                }\n+                default -> expressionTypes = expressionTypes.prepend(current);\n+            }\n+        }\n+        \/\/add synthetic captured ivars\n+        InferenceContext c = new InferenceContext(this, params);\n+        Type patternType = c.asUndetVar(patternTypeSymbol.type);\n+        List<Type> exprTypes = expressionTypes.map(t -> c.asUndetVar(t));\n+\n+        capturedWildcards.forEach(s -> ((UndetVar) c.asUndetVar(s)).setNormal());\n+\n+        try {\n+            \/\/step 2:\n+            for (Type exprType : exprTypes) {\n+                if (exprType.isParameterized()) {\n+                    Type patternAsExpression =\n+                            types.asSuper(patternType, exprType.tsym);\n+                    if (patternAsExpression == null ||\n+                        !types.isSameType(patternAsExpression, exprType)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            doIncorporation(c, types.noWarnings);\n+\n+            \/\/step 3:\n+            List<Type> freshVars = instantiatePatternVars(params, c);\n+\n+            Type substituted = c.asInstType(patternTypeSymbol.type);\n+\n+            \/\/step 4:\n+            return types.upward(substituted, freshVars);\n+        } catch (Infer.InferenceException ex) {\n+            return null;\n+        }\n+    }\n+\n+    private List<Type> instantiatePatternVars(List<Type> vars, InferenceContext c) {\n+        ListBuffer<Type> freshVars = new ListBuffer<>();\n+        ListBuffer<Type> todo = new ListBuffer<>();\n+\n+        \/\/step 1 - create fresh tvars\n+        for (Type t : vars) {\n+            UndetVar undet = (UndetVar) c.asUndetVar(t);\n+            List<Type> bounds = InferenceStep.EQ.filterBounds(undet, c);\n+            if (bounds.nonEmpty()) {\n+                undet.setInst(bounds.head);\n+            } else {\n+                List<Type> upperBounds = undet.getBounds(InferenceBound.UPPER);\n+                Type upper;\n+                boolean recursive = Type.containsAny(upperBounds, vars);\n+                if (recursive) {\n+                    upper = types.makeIntersectionType(upperBounds);\n+                    todo.append(undet);\n+                } else if (upperBounds.nonEmpty()) {\n+                    upper = types.glb(upperBounds);\n+                } else {\n+                    upper = syms.objectType;\n+                }\n+                List<Type> lowerBounds = undet.getBounds(InferenceBound.LOWER);\n+                Type lower = lowerBounds.isEmpty() ? syms.botType\n+                                                   : lowerBounds.tail.isEmpty() ? lowerBounds.head\n+                                                                                : types.lub(lowerBounds);\n+                TypeVar vt = new TypeVar(syms.noSymbol, upper, lower);\n+                freshVars.add(vt);\n+                undet.setInst(vt);\n+            }\n+        }\n+\n+        \/\/step 2 - replace fresh tvars in their bounds\n+        replaceTypeVarsInBounds(todo.toList(), c);\n+\n+        return freshVars.toList();\n+    }\n@@ -1148,1 +1266,1 @@\n-    Map<IncorporationBinaryOp, Boolean> incorporationCache = new HashMap<>();\n+    Map<IncorporationBinaryOp, Boolean> incorporationCache = new LinkedHashMap<>();\n@@ -1310,1 +1428,1 @@\n-        final Map<Node, Pair<List<Node>, Integer>> treeCache = new HashMap<>();\n+        final Map<Node, Pair<List<Node>, Integer>> treeCache = new LinkedHashMap<>();\n@@ -1638,1 +1756,1 @@\n-                    Set<Node> closure = new HashSet<>();\n+                    Set<Node> closure = new LinkedHashSet<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":126,"deletions":8,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -522,0 +522,3 @@\n+        if (init != null) {\n+            refSym = (MethodSymbol) types.binaryQualifier(refSym, init.type);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -57,0 +58,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -104,0 +106,1 @@\n+    private final boolean useMatchException;\n@@ -132,0 +135,3 @@\n+        Preview preview = Preview.instance(context);\n+        useMatchException = Feature.PATTERN_SWITCH.allowedInSource(source) &&\n+                            (preview.isEnabled() || !preview.isPreview(Feature.PATTERN_SWITCH));\n@@ -3491,5 +3497,9 @@\n-            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  loopvarinit).setType(tree.var.type);\n-            loopvardef.sym = tree.var.sym;\n+\n+            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+            JCVariableDecl jcVariableDecl = (JCVariableDecl) tree.varOrRecordPattern;\n+\n+            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(jcVariableDecl.mods,\n+                    jcVariableDecl.name,\n+                    jcVariableDecl.vartype,\n+                    loopvarinit).setType(jcVariableDecl.type);\n+            loopvardef.sym = jcVariableDecl.sym;\n@@ -3497,1 +3507,2 @@\n-                Block(0, List.of(loopvardef, tree.body));\n+                    Block(0, List.of(loopvardef, tree.body));\n+\n@@ -3576,1 +3587,5 @@\n-            if (tree.var.type.isPrimitive())\n+\n+            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n+            JCVariableDecl var = (JCVariableDecl) tree.varOrRecordPattern;\n+            if (var.type.isPrimitive())\n@@ -3579,6 +3594,6 @@\n-                vardefinit = make.TypeCast(tree.var.type, vardefinit);\n-            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  vardefinit).setType(tree.var.type);\n-            indexDef.sym = tree.var.sym;\n+                vardefinit = make.TypeCast(var.type, vardefinit);\n+            JCVariableDecl indexDef = (JCVariableDecl) make.VarDef(var.mods,\n+                    var.name,\n+                    var.vartype,\n+                    vardefinit).setType(var.type);\n+            indexDef.sym = var.sym;\n@@ -3588,4 +3603,4 @@\n-                ForLoop(List.of(init),\n-                        cond,\n-                        List.nil(),\n-                        body));\n+                    ForLoop(List.of(init),\n+                            cond,\n+                            List.nil(),\n+                            body));\n@@ -3671,2 +3686,3 @@\n-        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n-        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(matchException, tree.cases)\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.patternSwitch,\n+                                                                     tree.wasEnumSelector,\n+                                                                     tree.cases)\n@@ -3679,2 +3695,1 @@\n-        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n-        List<JCCase> cases = addDefaultIfNeeded(matchException, tree.cases);\n+        List<JCCase> cases = addDefaultIfNeeded(tree.patternSwitch, tree.wasEnumSelector, tree.cases);\n@@ -3684,1 +3699,2 @@\n-    private List<JCCase> addDefaultIfNeeded(boolean matchException, List<JCCase> cases) {\n+    private List<JCCase> addDefaultIfNeeded(boolean patternSwitch, boolean wasEnumSelector,\n+                                            List<JCCase> cases) {\n@@ -3686,0 +3702,2 @@\n+            boolean matchException = useMatchException;\n+            matchException |= patternSwitch && !wasEnumSelector;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1227,0 +1227,4 @@\n+        \/\/java.base may not be completed yet and computeTransitiveClosure\n+        \/\/may not complete it either, make sure it is completed:\n+        syms.java_base.complete();\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3169,1 +3169,2 @@\n-        ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);\n+        boolean isStaticSelector = TreeInfo.isStaticSelector(referenceTree.expr, names);\n+        ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext, isStaticSelector);\n@@ -3185,1 +3186,1 @@\n-            unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);\n+            unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext, isStaticSelector);\n@@ -3296,2 +3297,2 @@\n-        ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {\n-            this(sym, staticKind(sym, resolutionContext));\n+        ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext, boolean isStaticSelector) {\n+            this(sym, staticKind(sym, resolutionContext, isStaticSelector));\n@@ -3305,11 +3306,11 @@\n-        private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {\n-            switch (sym.kind) {\n-                case MTH:\n-                case AMBIGUOUS:\n-                    return resolutionContext.candidates.stream()\n-                            .filter(c -> c.isApplicable() && c.step == resolutionContext.step)\n-                            .map(c -> StaticKind.from(c.sym))\n-                            .reduce(StaticKind::reduce)\n-                            .orElse(StaticKind.UNDEFINED);\n-                default:\n-                    return StaticKind.UNDEFINED;\n+        private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext, boolean isStaticSelector) {\n+            if (sym.kind == MTH && !isStaticSelector) {\n+                return StaticKind.from(sym);\n+            } else if (sym.kind == MTH || sym.kind == AMBIGUOUS) {\n+                return resolutionContext.candidates.stream()\n+                        .filter(c -> c.isApplicable() && c.step == resolutionContext.step)\n+                        .map(c -> StaticKind.from(c.sym))\n+                        .reduce(StaticKind::reduce)\n+                        .orElse(StaticKind.UNDEFINED);\n+            } else {\n+                return StaticKind.UNDEFINED;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-        tree.var = translate(tree.var, null);\n+        tree.varOrRecordPattern = translate(tree.varOrRecordPattern, null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1001,4 +1001,2 @@\n-                    sym.createRecordComponent(rc, field,\n-                            field.mods.annotations.isEmpty() ?\n-                                    List.nil() :\n-                                    new TreeCopier<JCTree>(make.at(field.pos)).copy(field.mods.annotations));\n+                    JCVariableDecl rcDecl = new TreeCopier<JCTree>(make.at(field.pos)).copy(field);\n+                    sym.createRecordComponent(rc, rcDecl, field.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-            sr.mergeWith(csp(tree.var));\n+            sr.mergeWith(csp(tree.varOrRecordPattern));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,2 @@\n-        V64(64, 0);   \/\/ JDK 20\n+        V64(64, 0),   \/\/ JDK 20\n+        V65(65, 0);   \/\/ JDK 21\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Set;\n@@ -136,1 +137,0 @@\n-        qualifiedSymbolCache = new HashMap<>();\n@@ -179,6 +179,2 @@\n-\n-    \/** Cache the symbol to reflect the qualifying type.\n-     *  key: corresponding type\n-     *  value: qualified symbol\n-     *\/\n-    Map<Type, Symbol> qualifiedSymbolCache;\n+    Set<JCMethodInvocation> invocationsWithPatternMatchingCatch = Set.of();\n+    ListBuffer<int[]> patternMatchingInvocationRanges;\n@@ -231,40 +227,0 @@\n-    \/** Construct a symbol to reflect the qualifying type that should\n-     *  appear in the byte code as per JLS 13.1.\n-     *\n-     *  For {@literal target >= 1.2}: Clone a method with the qualifier as owner (except\n-     *  for those cases where we need to work around VM bugs).\n-     *\n-     *  For {@literal target <= 1.1}: If qualified variable or method is defined in a\n-     *  non-accessible class, clone it with the qualifier class as owner.\n-     *\n-     *  @param sym    The accessed symbol\n-     *  @param site   The qualifier's type.\n-     *\/\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n-\n-        if (site.hasTag(ARRAY)) {\n-            if (sym == syms.lengthVar ||\n-                sym.owner != syms.arrayClass)\n-                return sym;\n-            \/\/ array clone can be qualified by the array type in later targets\n-            Symbol qualifier;\n-            if ((qualifier = qualifiedSymbolCache.get(site)) == null) {\n-                qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name, site, syms.noSymbol);\n-                qualifiedSymbolCache.put(site, qualifier);\n-            }\n-            return sym.clone(qualifier);\n-        }\n-\n-        if (sym.owner == site.tsym ||\n-            (sym.flags() & (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {\n-            return sym;\n-        }\n-\n-        \/\/ leave alone methods inherited from Object\n-        \/\/ JLS 13.1.\n-        if (sym.owner == syms.objectType.tsym)\n-            return sym;\n-\n-        return sym.clone(site.tsym);\n-    }\n-\n@@ -1128,0 +1084,23 @@\n+        if (tree.patternMatchingCatch != null) {\n+            Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n+            ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n+            State startState = code.state.dup();\n+            try {\n+                invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n+                patternMatchingInvocationRanges = new ListBuffer<>();\n+                doVisitBlock(tree);\n+            } finally {\n+                Chain skipCatch = code.branch(goto_);\n+                JCCatch handler = tree.patternMatchingCatch.handler();\n+                code.entryPoint(startState, handler.param.sym.type);\n+                genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+                code.resolve(skipCatch);\n+                invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n+                patternMatchingInvocationRanges = prevRanges;\n+            }\n+        } else {\n+            doVisitBlock(tree);\n+        }\n+    }\n+\n+    private void doVisitBlock(JCBlock tree) {\n@@ -1153,1 +1132,1 @@\n-                sym = binaryQualifier(sym, env.enclClass.type);\n+                sym = types.binaryQualifier(sym, env.enclClass.type);\n@@ -1169,1 +1148,1 @@\n-                sym = binaryQualifier(sym, fieldAccess.selected.type);\n+                sym = types.binaryQualifier(sym, fieldAccess.selected.type);\n@@ -1721,10 +1700,1 @@\n-                VarSymbol exparam = tree.param.sym;\n-                code.statBegin(tree.pos);\n-                code.markStatBegin();\n-                int limit = code.nextreg;\n-                code.newLocal(exparam);\n-                items.makeLocalItem(exparam).store();\n-                code.statBegin(TreeInfo.firstStatPos(tree.body));\n-                genStat(tree.body, env, CRT_BLOCK);\n-                code.endScopes(limit);\n-                code.statBegin(TreeInfo.endPos(tree.body));\n+                genCatchBlock(tree, env);\n@@ -1733,0 +1703,24 @@\n+        void genPatternMatchingCatch(JCCatch tree,\n+                                     Env<GenContext> env,\n+                                     List<int[]> ranges) {\n+            for (int[] range : ranges) {\n+                JCExpression subCatch = tree.param.vartype;\n+                int catchType = makeRef(tree.pos(), subCatch.type);\n+                registerCatch(tree.pos(),\n+                              range[0], range[1], code.curCP(),\n+                              catchType);\n+            }\n+            genCatchBlock(tree, env);\n+        }\n+        void genCatchBlock(JCCatch tree, Env<GenContext> env) {\n+            VarSymbol exparam = tree.param.sym;\n+            code.statBegin(tree.pos);\n+            code.markStatBegin();\n+            int limit = code.nextreg;\n+            code.newLocal(exparam);\n+            items.makeLocalItem(exparam).store();\n+            code.statBegin(TreeInfo.firstStatPos(tree.body));\n+            genStat(tree.body, env, CRT_BLOCK);\n+            code.endScopes(limit);\n+            code.statBegin(TreeInfo.endPos(tree.body));\n+        }\n@@ -1949,1 +1943,7 @@\n-        result = m.invoke();\n+        if (invocationsWithPatternMatchingCatch.contains(tree)) {\n+            int start = code.curCP();\n+            result = m.invoke();\n+            patternMatchingInvocationRanges.add(new int[] {start, code.curCP()});\n+        } else {\n+            result = m.invoke();\n+        }\n@@ -2351,1 +2351,1 @@\n-                sym = binaryQualifier(sym, env.enclClass.type);\n+                sym = types.binaryQualifier(sym, env.enclClass.type);\n@@ -2355,1 +2355,1 @@\n-            sym = binaryQualifier(sym, env.enclClass.type);\n+            sym = types.binaryQualifier(sym, env.enclClass.type);\n@@ -2408,1 +2408,1 @@\n-                sym = binaryQualifier(sym, tree.selected.type);\n+                sym = types.binaryQualifier(sym, tree.selected.type);\n@@ -2527,1 +2527,1 @@\n-            qualifiedSymbolCache.clear();\n+            types.clearQualifiedSymbolCache();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCBindingPattern;\n@@ -97,0 +98,3 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -1468,0 +1472,1 @@\n+            protected boolean hasPatterns;\n@@ -1478,0 +1483,1 @@\n+                            boolean prevHasPatterns = hasPatterns;\n@@ -1482,4 +1488,5 @@\n-                                 * ignore any updates to hasLambdas made during\n-                                 * the nested scan, this ensures an initialized\n-                                 * LambdaToMethod is available only to those\n-                                 * classes that contain lambdas\n+                                 * ignore any updates to hasLambdas and hasPatterns\n+                                 * made during the nested scan, this ensures an\n+                                 * initialized LambdaToMethod or TransPatterns is\n+                                 * available only to those classes that contain\n+                                 * lambdas or patterns, respectivelly\n@@ -1488,0 +1495,1 @@\n+                                hasPatterns = prevHasPatterns;\n@@ -1506,0 +1514,25 @@\n+            @Override\n+            public void visitBindingPattern(JCBindingPattern tree) {\n+                hasPatterns = true;\n+                super.visitBindingPattern(tree);\n+            }\n+            @Override\n+            public void visitRecordPattern(JCRecordPattern that) {\n+                hasPatterns = true;\n+                super.visitRecordPattern(that);\n+            }\n+            @Override\n+            public void visitParenthesizedPattern(JCTree.JCParenthesizedPattern tree) {\n+                hasPatterns = true;\n+                super.visitParenthesizedPattern(tree);\n+            }\n+            @Override\n+            public void visitSwitch(JCSwitch tree) {\n+                hasPatterns |= tree.patternSwitch;\n+                super.visitSwitch(tree);\n+            }\n+            @Override\n+            public void visitSwitchExpression(JCSwitchExpression tree) {\n+                hasPatterns |= tree.patternSwitch;\n+                super.visitSwitchExpression(tree);\n+            }\n@@ -1554,1 +1587,4 @@\n-            env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            if (scanner.hasPatterns) {\n+                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n@@ -791,1 +792,0 @@\n-\n@@ -828,12 +828,1 @@\n-                JCVariableDecl var;\n-                if (token.kind == IDENTIFIER) {\n-                    if (!checkGuard || token.name() != names.when) {\n-                        var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), e, null));\n-                        nextToken();\n-                    } else {\n-                        var = null;\n-                    }\n-                } else {\n-                    var = null;\n-                }\n-                pattern = toP(F.at(pos).RecordPattern(e, nested.toList(), var));\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n@@ -1581,0 +1570,1 @@\n+            boolean allowDefault = false;\n@@ -1582,1 +1572,1 @@\n-                JCCaseLabel label = parseCaseLabel();\n+                JCCaseLabel label = parseCaseLabel(allowDefault);\n@@ -1587,0 +1577,1 @@\n+                allowDefault = TreeInfo.isNullCaseLabel(label);\n@@ -2893,6 +2884,15 @@\n-            List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n-            if (inits.length() == 1 &&\n-                inits.head.hasTag(VARDEF) &&\n-                ((JCVariableDecl) inits.head).init == null &&\n-                token.kind == COLON) {\n-                JCVariableDecl var = (JCVariableDecl)inits.head;\n+            JCTree pattern;\n+\n+            ForInitResult initResult = analyzeForInit();\n+\n+            if (initResult == ForInitResult.RecordPattern) {\n+                int patternPos = token.pos;\n+                JCModifiers mods = optFinal(0);\n+                int typePos = token.pos;\n+                JCExpression type = unannotatedType(false);\n+\n+                pattern = parsePattern(patternPos, mods, type, false, false);\n+\n+                if (pattern != null) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                }\n@@ -2903,1 +2903,1 @@\n-                return F.at(pos).ForeachLoop(var, expr, body);\n+                return F.at(pos).ForeachLoop(pattern, expr, body);\n@@ -2905,7 +2905,20 @@\n-                accept(SEMI);\n-                JCExpression cond = token.kind == SEMI ? null : parseExpression();\n-                accept(SEMI);\n-                List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n-                accept(RPAREN);\n-                JCStatement body = parseStatementAsBlock();\n-                return F.at(pos).ForLoop(inits, cond, steps, body);\n+                List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n+                if (inits.length() == 1 &&\n+                        inits.head.hasTag(VARDEF) &&\n+                        ((JCVariableDecl) inits.head).init == null &&\n+                        token.kind == COLON) {\n+                    JCVariableDecl var = (JCVariableDecl) inits.head;\n+                    accept(COLON);\n+                    JCExpression expr = parseExpression();\n+                    accept(RPAREN);\n+                    JCStatement body = parseStatementAsBlock();\n+                    return F.at(pos).ForeachLoop(var, expr, body);\n+                } else {\n+                    accept(SEMI);\n+                    JCExpression cond = token.kind == SEMI ? null : parseExpression();\n+                    accept(SEMI);\n+                    List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n+                    accept(RPAREN);\n+                    JCStatement body = parseStatementAsBlock();\n+                    return F.at(pos).ForLoop(inits, cond, steps, body);\n+                }\n@@ -3028,0 +3041,85 @@\n+    private enum ForInitResult {\n+        LocalVarDecl,\n+        RecordPattern\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    ForInitResult analyzeForInit() {\n+        boolean inType = false;\n+        boolean inSelectionAndParenthesis = false;\n+        int typeParameterPossibleStart = -1;\n+        outer: for (int lookahead = 0; ; lookahead++) {\n+            TokenKind tk = S.token(lookahead).kind;\n+            switch (tk) {\n+                case DOT:\n+                    if (inType) break; \/\/ in qualified type\n+                case COMMA:\n+                    typeParameterPossibleStart = lookahead;\n+                    break;\n+                case QUES:\n+                    \/\/ \"?\" only allowed in a type parameter position - otherwise it's an expression\n+                    if (typeParameterPossibleStart == lookahead - 1) break;\n+                    else return ForInitResult.LocalVarDecl;\n+                case EXTENDS: case SUPER: case AMP:\n+                case GTGTGT: case GTGT: case GT:\n+                case FINAL: case ELLIPSIS:\n+                    break;\n+                case BYTE: case SHORT: case INT: case LONG: case FLOAT:\n+                case DOUBLE: case BOOLEAN: case CHAR: case VOID:\n+                    if (peekToken(lookahead, IDENTIFIER)) {\n+                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n+                                                         : ForInitResult.LocalVarDecl;\n+                    }\n+                    break;\n+                case LPAREN:\n+                    if (lookahead != 0 && inType) {\n+                        inSelectionAndParenthesis = true;\n+                        inType = false;\n+                    }\n+                    break;\n+                case RPAREN:\n+                    \/\/ a method call in the init part or a record pattern?\n+                    if (inSelectionAndParenthesis) {\n+                        if (peekToken(lookahead, DOT)  ||\n+                                peekToken(lookahead, SEMI) ||\n+                                peekToken(lookahead, ARROW)) {\n+                            return ForInitResult.LocalVarDecl;\n+                        }\n+                        else if(peekToken(lookahead, COLON)) {\n+                            return ForInitResult.RecordPattern;\n+                        }\n+                        break;\n+                    }\n+                case UNDERSCORE:\n+                case ASSERT:\n+                case ENUM:\n+                case IDENTIFIER:\n+                    if (lookahead == 0) {\n+                        inType = true;\n+                    }\n+                    break;\n+                case MONKEYS_AT: {\n+                    int prevLookahead = lookahead;\n+                    lookahead = skipAnnotation(lookahead);\n+                    if (typeParameterPossibleStart == prevLookahead - 1) {\n+                        \/\/ move possible start of type param after the anno\n+                        typeParameterPossibleStart = lookahead;\n+                    }\n+                    break;\n+                }\n+                case LBRACKET:\n+                    if (peekToken(lookahead, RBRACKET)) {\n+                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n+                                                         : ForInitResult.LocalVarDecl;\n+                    }\n+                    return ForInitResult.LocalVarDecl;\n+                case LT:\n+                    typeParameterPossibleStart = lookahead;\n+                    break;\n+                default:\n+                    \/\/this includes EOF\n+                    return ForInitResult.LocalVarDecl;\n+            }\n+        }\n+    }\n+\n@@ -3101,0 +3199,1 @@\n+            boolean allowDefault = false;\n@@ -3102,1 +3201,2 @@\n-                pats.append(parseCaseLabel());\n+                JCCaseLabel label = parseCaseLabel(allowDefault);\n+                pats.append(label);\n@@ -3106,0 +3206,1 @@\n+                allowDefault = TreeInfo.isNullCaseLabel(label);\n@@ -3158,1 +3259,1 @@\n-    private JCCaseLabel parseCaseLabel() {\n+    private JCCaseLabel parseCaseLabel(boolean allowDefault) {\n@@ -3164,0 +3265,4 @@\n+            if (!allowDefault) {\n+                reportSyntaxError(new SimpleDiagnosticPosition(token.pos),\n+                                  Errors.DefaultLabelNotAllowed);\n+            }\n@@ -3947,0 +4052,1 @@\n+                List<JCExpression> implNames;\n@@ -3949,3 +4055,1 @@\n-                    List<JCExpression> implNames = qualidentList(false);\n-                    accept(SEMI);\n-                    defs.append(toP(F.at(pos).Provides(serviceName, implNames)));\n+                    implNames = qualidentList(false);\n@@ -3954,1 +4058,1 @@\n-                    skip(false, false, false, false);\n+                    implNames = List.nil();\n@@ -3956,0 +4060,2 @@\n+                accept(SEMI);\n+                defs.append(toP(F.at(pos).Provides(serviceName, implNames)));\n@@ -4026,4 +4132,3 @@\n-            if (token.kind == IDENTIFIER && token.name() == names.record) {\n-                checkSourceLevel(Feature.RECORDS);\n-                JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);\n-                return toP(F.Exec(erroneousTree));\n+            if (LAX_IDENTIFIER.test(token.kind)) {\n+                errs = List.of(mods, toP(F.at(pos).Ident(ident())));\n+                setErrorEndPos(token.pos);\n@@ -4031,9 +4136,8 @@\n-                if (LAX_IDENTIFIER.test(token.kind)) {\n-                    errs = List.of(mods, toP(F.at(pos).Ident(ident())));\n-                    setErrorEndPos(token.pos);\n-                } else {\n-                    errs = List.of(mods);\n-                }\n-                final JCErroneous erroneousTree;\n-                if (parseModuleInfo) {\n-                    erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+                errs = List.of(mods);\n+            }\n+            final JCErroneous erroneousTree;\n+            if (parseModuleInfo) {\n+                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+            } else {\n+                if (allowRecords) {\n+                    erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n@@ -4041,5 +4145,1 @@\n-                    if (allowRecords) {\n-                        erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n-                    } else {\n-                        erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n-                    }\n+                    erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n@@ -4047,1 +4147,1 @@\n-                return toP(F.Exec(erroneousTree));\n+            return toP(F.Exec(erroneousTree));\n@@ -4528,4 +4628,1 @@\n-        if (token.kind == IDENTIFIER && token.name() == names.record &&\n-            (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||\n-             peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||\n-             peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {\n+        if (token.kind == IDENTIFIER && token.name() == names.record && peekToken(TokenKind.IDENTIFIER)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":154,"deletions":57,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -534,0 +534,9 @@\n+compiler.err.invalid.case.label.combination=\\\n+    invalid case label combination\n+\n+compiler.err.default.label.not.allowed=\\\n+    default label not allowed here\n+\n+compiler.err.pattern.type.cannot.infer=\\\n+    cannot infer pattern type\n+\n@@ -603,0 +612,4 @@\n+# 0: type, 1: type\n+compiler.err.foreach.not.exhaustive.on.type=\\\n+    Pattern {0} is not exhaustive on {1}\n+\n@@ -3789,3 +3802,0 @@\n-compiler.err.record.header.expected=\\\n-    record header expected\n-\n@@ -4016,3 +4026,0 @@\n-compiler.err.raw.deconstruction.pattern=\\\n-    raw deconstruction patterns are not allowed\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-    Check that API used is available in the specified profile\n+    Check that API used is available in the specified profile.\\n\\\n+    This option is deprecated and may be removed in a future release.\n@@ -128,2 +129,0 @@\n-javac.opt.arg.release=\\\n-    <release>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1092,0 +1092,6 @@\n+        \/** If this block contains record pattern, it is necessary to catch\n+         *  exceptions from the deconstructors and wrap them.\n+         * The {@code patternMatchingCatch} keeps the list of the deconstructor\n+         * invocations, and the additional catch block that wraps the exceptions.\n+         *\/\n+        public PatternMatchingCatch patternMatchingCatch;\n@@ -1116,0 +1122,2 @@\n+\n+        public record PatternMatchingCatch(JCCatch handler, Set<JCMethodInvocation> calls2Handle) {}\n@@ -1258,1 +1266,1 @@\n-        public JCVariableDecl var;\n+        public JCTree varOrRecordPattern;\n@@ -1261,2 +1269,4 @@\n-        protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n-            this.var = var;\n+        public Type elementType;\n+\n+        protected JCEnhancedForLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n+            this.varOrRecordPattern = varOrRecordPattern;\n@@ -1272,1 +1282,5 @@\n-        public JCVariableDecl getVariable() { return var; }\n+        public JCVariableDecl getVariable() {\n+            return varOrRecordPattern instanceof JCVariableDecl var ? var : null;\n+        }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCTree getVariableOrRecordPattern() { return varOrRecordPattern; }\n@@ -1285,0 +1299,4 @@\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public EnhancedForLoopTree.DeclarationKind getDeclarationKind() {\n+            return varOrRecordPattern.hasTag(VARDEF) ? DeclarationKind.VARIABLE : DeclarationKind.PATTERN;\n+        }\n@@ -2282,0 +2300,3 @@\n+        \/**{@code true} if this instanceof test should have\n+         * value {@code true} when the {@code expr} is {@code null}.*\/\n+        public boolean allowNull;\n@@ -2301,0 +2322,4 @@\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public TestKind getTestKind() {\n+            return pattern instanceof JCPatternCaseLabel ? TestKind.PATTERN : TestKind.TYPE;\n+        }\n@@ -2502,1 +2527,0 @@\n-        public JCVariableDecl var;\n@@ -2506,2 +2530,1 @@\n-        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                  JCVariableDecl var) {\n+        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested) {\n@@ -2510,1 +2533,0 @@\n-            this.var = var;\n@@ -2549,5 +2571,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public VariableTree getVariable() {\n-            return var;\n-        }\n-\n@@ -3488,1 +3505,1 @@\n-        JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);\n+        JCEnhancedForLoop ForeachLoop(JCTree var, JCExpression expr, JCStatement body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -825,1 +825,1 @@\n-            printExpr(tree.var);\n+            printExpr(tree.varOrRecordPattern);\n@@ -969,4 +969,0 @@\n-            if (tree.var != null) {\n-                print(\" \");\n-                print(tree.var.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-        JCVariableDecl var = copy(t.var, p);\n+        JCTree varOrRecordPattern = copy(t.varOrRecordPattern, p);\n@@ -236,1 +236,1 @@\n-        return M.at(t.pos).ForeachLoop(var, expr, body);\n+        return M.at(t.pos).ForeachLoop(varOrRecordPattern, expr, body);\n@@ -542,2 +542,1 @@\n-        JCVariableDecl var = copy(t.var, p);\n-        return M.at(t.pos).RecordPattern(deconstructor, nested, var);\n+        return M.at(t.pos).RecordPattern(deconstructor, nested);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n@@ -49,0 +50,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -812,0 +814,6 @@\n+            if (this.sym.getKind() == ElementKind.RECORD_COMPONENT) {\n+                if (thatSym != null && thatSym.getKind() == ElementKind.FIELD && (thatSym.flags_field & RECORD) != 0) {\n+                    RecordComponent rc = thatSym.enclClass().getRecordComponent((VarSymbol)thatSym);\n+                    return checkMatch(rc.declarationFor(), rc);\n+                }\n+            }\n@@ -858,0 +866,9 @@\n+    \/** Skip parens and return the enclosed expression\n+     *\/\n+    public static JCPattern skipParens(JCPattern tree) {\n+        while (tree.hasTag(PARENTHESIZEDPATTERN)) {\n+            tree = ((JCParenthesizedPattern) tree).pattern;\n+        }\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -282,2 +282,2 @@\n-    public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n-        JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);\n+    public JCEnhancedForLoop ForeachLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n+        JCEnhancedForLoop tree = new JCEnhancedForLoop(varOrRecordPattern, expr, body);\n@@ -527,3 +527,2 @@\n-    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                         JCVariableDecl var) {\n-        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested, var);\n+    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-        scan(tree.var);\n+        scan(tree.varOrRecordPattern);\n@@ -343,3 +343,0 @@\n-        if (that.var != null) {\n-            scan(that.var);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        tree.var = translate(tree.var);\n+        tree.varOrRecordPattern = translate(tree.varOrRecordPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  \/\/ C equivalent:   return &header->_space[index];\n+  \/\/ C equivalent:   return &header->_regions[index];\n@@ -75,8 +75,8 @@\n-    AddressField spaceField = FileMapHeader_type.getAddressField(\"_space[0]\");\n-\n-    \/\/ size_t offset = offsetof(FileMapHeader, _space[0]);\n-    \/\/ CDSFileMapRegion* space_0 = ((char*)header) + offset; \/\/ space_0 = &header->_space[index];\n-    \/\/ return ((char*)space_0) + index * sizeof(CDSFileMapRegion);\n-    long offset = spaceField.getOffset();\n-    Address space_0 = header.addOffsetTo(offset);\n-    return space_0.addOffsetTo(index * spaceField.getSize());\n+    AddressField regionsField = FileMapHeader_type.getAddressField(\"_regions[0]\");\n+\n+    \/\/ size_t offset = offsetof(FileMapHeader, _regions[0]);\n+    \/\/ CDSFileMapRegion* regions_0 = ((char*)header) + offset; \/\/ regions_0 = &header->_regions[index];\n+    \/\/ return ((char*)regions_0) + index * sizeof(CDSFileMapRegion);\n+    long offset = regionsField.getOffset();\n+    Address regions_0 = header.addOffsetTo(offset);\n+    return regions_0.addOffsetTo(index * regionsField.getSize());\n@@ -103,3 +103,3 @@\n-    \/\/ CDSFileMapRegion* rw_space = &header->_space[rw];\n-    \/\/ char* rwRegionBaseAddress = rw_space->_mapped_base;\n-    \/\/ size_t used = rw_space->_used;\n+    \/\/ CDSFileMapRegion* rw_region = &header->_region[rw];\n+    \/\/ char* rwRegionBaseAddress = rw_region->_mapped_base;\n+    \/\/ size_t used = rw_region->_used;\n@@ -107,3 +107,3 @@\n-    Address rw_space = get_CDSFileMapRegion(FileMapHeader_type, header, 0);\n-    rwRegionBaseAddress = get_AddressField(CDSFileMapRegion_type, rw_space, \"_mapped_base\");\n-    long used = get_CIntegerField(CDSFileMapRegion_type, rw_space, \"_used\");\n+    Address rw_region = get_CDSFileMapRegion(FileMapHeader_type, header, 0);\n+    rwRegionBaseAddress = get_AddressField(CDSFileMapRegion_type, rw_region, \"_mapped_base\");\n+    long used = get_CIntegerField(CDSFileMapRegion_type, rw_region, \"_used\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags\", Integer.class, \"u4\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_status._flags\", Integer.class, \"u4\");\n@@ -122,0 +122,1 @@\n+    final int fieldInfoConstantValueIndexOffset = getConstant(\"FieldInfo::initval_index_offset\", Integer.class);\n@@ -142,2 +143,2 @@\n-    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlass::_misc_has_nonstatic_concrete_methods\", Integer.class);\n-    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlass::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,3 @@\n-     * Returns the bytecode of this method, if the method has code. The returned byte array does not\n-     * contain breakpoints or non-Java bytecodes. This may return null if the\n-     * {@linkplain #getDeclaringClass() declaring class} is not\n-     * {@linkplain ResolvedJavaType#isLinked() linked}.\n+     * Returns the method's bytecode. The returned bytecode does not contain breakpoints or non-Java\n+     * bytecodes. This will return {@code null} if {@link #getCodeSize()} returns {@code <= 0} or if\n+     * {@link #hasBytecodes()} returns {@code false}.\n@@ -44,1 +43,1 @@\n-     * The contained constant pool indices may not be the ones found in the original class file but\n+     * The contained constant pool indexes may not be the ones found in the original class file but\n@@ -47,2 +46,2 @@\n-     * @return the bytecode of the method, or {@code null} if {@code getCodeSize() == 0} or if the\n-     *         code is not ready.\n+     * @return {@code null} if {@code getLinkedCodeSize() <= 0} otherwise the bytecode of the method\n+     *         whose length is guaranteed to be {@code > 0}\n@@ -53,2 +52,2 @@\n-     * Returns the size of the bytecode of this method, if the method has code. This is equivalent\n-     * to {@link #getCode()}. {@code length} if the method has code.\n+     * Returns the size of the method's bytecode. If this method returns a value {@code > 0} then\n+     * {@link #getCode()} will not return {@code null}.\n@@ -56,1 +55,4 @@\n-     * @return the size of the bytecode in bytes, or 0 if no bytecode is available\n+     * @return 0 if the method has no bytecode, {@code -1} if the method does have bytecode but its\n+     *         {@linkplain #getDeclaringClass() declaring class} is not\n+     *         {@linkplain ResolvedJavaType#isLinked() linked} otherwise the size of the bytecode in\n+     *         bytes (guaranteed to be {@code > 0})\n@@ -440,6 +442,2 @@\n-     * Checks whether the method has bytecodes associated with it. Note that even if this method\n-     * returns {@code true}, {@link #getCode} can return {@code null} if\n-     * {@linkplain #getDeclaringClass() declaring class} is not\n-     * {@linkplain ResolvedJavaType#isLinked() linked}.\n-     *\n-     * @return {@code this.getCodeSize() != 0}\n+     * @see #getCodeSize()\n+     * @return {@code getCodeSize() > 0}\n@@ -448,1 +446,1 @@\n-        return getCodeSize() != 0;\n+        return getCodeSize() > 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -225,2 +225,0 @@\n-        gdata->threadResume =\n-                getMethod(env, gdata->threadClass, \"resume\", \"()V\");\n@@ -280,1 +278,0 @@\n-            saveGlobalRef(env, localAgentProperties, &(gdata->agent_properties));\n@@ -286,0 +283,1 @@\n+            saveGlobalRef(env, localAgentProperties, &(gdata->agent_properties));\n@@ -1937,1 +1935,1 @@\n-    index2jvmti[EI_GC_FINISH          -EI_min] = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH;\n+    index2jvmti[EI_CLASS_UNLOAD       -EI_min] = 0; \/\/ No mapping to JVMTI event\n@@ -1960,1 +1958,1 @@\n-    index2jdwp[EI_GC_FINISH           -EI_min] = JDWP_EVENT(CLASS_UNLOAD);\n+    index2jdwp[EI_CLASS_UNLOAD        -EI_min] = JDWP_EVENT(CLASS_UNLOAD);\n@@ -1979,1 +1977,1 @@\n-eventIndex2jdwp(EventIndex i)\n+eventIndex2jdwp(EventIndex ei)\n@@ -1981,2 +1979,3 @@\n-    if ( i < EI_min || i > EI_max ) {\n-        EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,\"bad EventIndex\");\n+    jdwpEvent event = 0;\n+    if (ei >= EI_min && ei <= EI_max) {\n+        event = index2jdwp[ei - EI_min];\n@@ -1984,1 +1983,4 @@\n-    return index2jdwp[i-EI_min];\n+    if (event == 0) {\n+        EXIT_ERROR(AGENT_ERROR_INVALID_INDEX, \"bad EventIndex\");\n+    }\n+    return event;\n@@ -1988,1 +1990,1 @@\n-eventIndex2jvmti(EventIndex i)\n+eventIndex2jvmti(EventIndex ei)\n@@ -1990,2 +1992,6 @@\n-    if ( i < EI_min || i > EI_max ) {\n-        EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,\"bad EventIndex\");\n+    jvmtiEvent event = 0;\n+    if (ei >= EI_min && ei <= EI_max) {\n+        event = index2jvmti[ei - EI_min];\n+    }\n+    if (event == 0) {\n+        EXIT_ERROR(AGENT_ERROR_INVALID_INDEX, \"bad EventIndex\");\n@@ -1993,1 +1999,1 @@\n-    return index2jvmti[i-EI_min];\n+    return event;\n@@ -2016,2 +2022,2 @@\n-        case EI_GC_FINISH:\n-            return \"EI_GC_FINISH\";\n+        case EI_CLASS_UNLOAD:\n+            return \"EI_CLASS_UNLOAD\";\n@@ -2073,1 +2079,1 @@\n-            return EI_GC_FINISH;\n+            return EI_CLASS_UNLOAD;\n@@ -2129,2 +2135,0 @@\n-        case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:\n-            return EI_GC_FINISH;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-compiler\/jvmci\/compilerToVM\/GetFlagValueTest.java 8204459 generic-all\n-compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java 8262901 macosx-aarch64\n-compiler\/tiered\/LevelTransitionTest.java 8067651 generic-all\n@@ -56,11 +53,11 @@\n-compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64\n+compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n@@ -87,1 +84,1 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293 macosx-x64\n+gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293,8298073 macosx-x64,macosx-aarch64\n@@ -104,0 +101,2 @@\n+runtime\/vthread\/RedefineClass.java 8297286 generic-all\n+runtime\/vthread\/TestObjectAllocationSampleEvent.java 8297286 generic-all\n@@ -199,0 +198,2 @@\n+\n+vmTestbase\/nsk\/stress\/except\/except012.java 8297977 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n-import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.driver.irmatching.mapping.*;\n+import compiler.lib.ir_framework.shared.CheckedTestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -31,2 +33,2 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -35,1 +37,19 @@\n- * This class provides default regex strings that can be used in {@link IR @IR} annotations to specify IR constraints.\n+ * This class specifies IR node placeholder strings (also referred to as just \"IR nodes\") with mappings to regexes\n+ * depending on the selected compile phases. The mappings are stored in {@link #IR_NODE_MAPPINGS}. Each IR node\n+ * placeholder string is mapped to a {@link IRNodeMapEntry} instance defined in\n+ * {@link compiler.lib.ir_framework.driver.irmatching.mapping}.\n+ *\n+ * <p>\n+ * IR node placeholder strings can be used in {@link IR#failOn()} and\/or {@link IR#counts()} attributes to define IR\n+ * constraints. They usually represent a single C2 IR node or a group of them.\n+ *\n+ * <p>\n+ * Each IR node placeholder string is accompanied by a static block that defines an IR node placeholder to regex(es)\n+ * mapping. The IR framework will automatically replace each IR node placeholder string in a user defined test with a\n+ * regex depending on the selected compile phases in {@link IR#phase} and the provided mapping.\n+ *\n+ * <p>\n+ * Each mapping must define a default compile phase which is applied when the user does not explicitly set the\n+ * {@link IR#phase()} attribute or when directly using {@link CompilePhase#DEFAULT}. In this case, the IR framework\n+ * falls back on the default compile phase of any {@link IRNodeMapEntry}.\n+ *\n@@ -37,1 +57,1 @@\n- * There are two types of default regexes:\n+ * The IR framework reports a {@link TestFormatException} if:\n@@ -39,4 +59,3 @@\n- *     <li><p>Standalone regexes: Use them directly.<\/li>\n- *     <li><p>Composite regexes: Their names contain \"{@code _OF}\" and expect another string in a list in\n- *            {@link IR#failOn()} and {@link IR#counts()}. They cannot be use as standalone regex and will result in a\n- *            {@link TestFormatException} when doing so.<\/li>\n+ *     <li><p> A user test specifies a compile phase for which no mapping is defined in this class.<\/li>\n+ *     <li><p> An IR node placeholder string is either missing a mapping or does not provide a regex for a specified\n+ *             compile phase in {@link IR#phase}.\n@@ -45,1 +64,9 @@\n- * @see IR\n+ * <p>\n+ * There are two types of IR nodes:\n+ * <ul>\n+ *     <li><p>Normal IR nodes: The IR node placeholder string is directly replaced by a regex.<\/li>\n+ *     <li><p>Composite IR nodes:  The IR node placeholder string contains an additional {@link #COMPOSITE_PREFIX}.\n+ *                                 Using this IR node expects another user provided string in the constraint list of\n+ *                                 {@link IR#failOn()} and {@link IR#counts()}. They cannot be used as normal IR nodes.\n+ *                                 Trying to do so will result in a format violation error.<\/li>\n+ * <\/ul>\n@@ -48,0 +75,10 @@\n+    \/**\n+     * Prefix for normal IR nodes.\n+     *\/\n+    private static final String PREFIX = \"_#\";\n+    \/**\n+     * Prefix for composite IR nodes.\n+     *\/\n+    private static final String COMPOSITE_PREFIX = PREFIX + \"C#\";\n+    private static final String POSTFIX = \"#_\";\n+\n@@ -51,2 +88,0 @@\n-    private static final String COMPOSITE_PREFIX = \"#PRE#\"; \/\/ Prefix for regexes that require an additional user-defined string.\n-    private static final String IS_REPLACED = \"#IS_REPLACED#\"; \/\/ Is replaced by an additional user-defined string.\n@@ -56,4 +91,162 @@\n-    public static final String ALLOC = \"(.*precise .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_ARRAY = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n-    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+    public static final String IS_REPLACED = \"#IS_REPLACED#\"; \/\/ Is replaced by an additional user-defined string.\n+\n+\n+    \/**\n+     * IR placeholder string to regex-for-compile-phase map.\n+     *\/\n+    private static final Map<String, IRNodeMapEntry> IR_NODE_MAPPINGS = new HashMap<>();\n+\n+    \/*\n+     * Start of IR placeholder string definitions followed by a static block defining the regex-for-compile-phase mapping.\n+     * An IR node placeholder string must start with PREFIX for normal IR nodes or COMPOSITE_PREFIX for composite IR\n+     * nodes (see class description above).\n+     *\n+     * An IR node definition looks like this:\n+     *\n+     * public static final String IR_NODE = [PREFIX|COMPOSITE_PREFIX] + \"IR_NODE\" + POSTFIX;\n+     * static {\n+     *    \/\/ Define IR_NODE to regex-for-compile-phase mapping. Create a new IRNodeMapEntry object and add it to\n+     *    \/\/ IR_NODE_MAPPINGS. This can be done by using the helper methods defined after all IR node placeholder string\n+     *    \/\/ definitions.\n+     * }\n+     *\/\n+\n+    public static final String ABS_D = PREFIX + \"ABS_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_D, \"AbsD\");\n+    }\n+\n+    public static final String ABS_F = PREFIX + \"ABS_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_F, \"AbsF\");\n+    }\n+\n+    public static final String ABS_I = PREFIX + \"ABS_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_I, \"AbsI\");\n+    }\n+\n+    public static final String ABS_L = PREFIX + \"ABS_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_L, \"AbsL\");\n+    }\n+    public static final String ADD = PREFIX + \"ADD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD, \"Add(I|L|F|D|P)\");\n+    }\n+\n+    public static final String ADD_I = PREFIX + \"ADD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_I, \"AddI\");\n+    }\n+\n+    public static final String ADD_L = PREFIX + \"ADD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_L, \"AddL\");\n+    }\n+\n+    public static final String ADD_VD = PREFIX + \"ADD_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VD, \"AddVD\");\n+    }\n+\n+    public static final String ADD_VI = PREFIX + \"ADD_VI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VI, \"AddVI\");\n+    }\n+\n+    public static final String ADD_REDUCTION_VD = PREFIX + \"ADD_REDUCTION_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VD, \"AddReductionVD\");\n+    }\n+\n+    public static final String ADD_REDUCTION_VF = PREFIX + \"ADD_REDUCTION_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VF, \"AddReductionVF\");\n+    }\n+\n+    public static final String ALLOC = PREFIX + \"ALLOC\" + POSTFIX;\n+    static {\n+        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        allocNodes(ALLOC, \"Allocate\", optoRegex);\n+    }\n+\n+    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"ALLOC_OF\" + POSTFIX;\n+    static {\n+        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        optoOnly(ALLOC_OF, regex);\n+    }\n+\n+    public static final String ALLOC_ARRAY = PREFIX + \"ALLOC_ARRAY\" + POSTFIX;\n+    static {\n+        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        allocNodes(ALLOC_ARRAY, \"AllocateArray\", optoRegex);\n+    }\n+\n+    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"ALLOC_ARRAY_OF\" + POSTFIX;\n+    static {\n+        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        optoOnly(ALLOC_ARRAY_OF, regex);\n+    }\n+\n+    public static final String AND = PREFIX + \"AND\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND, \"And(I|L)\");\n+    }\n+\n+    public static final String AND_I = PREFIX + \"AND_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_I, \"AndI\");\n+    }\n+\n+    public static final String AND_L = PREFIX + \"AND_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_L, \"AndL\");\n+    }\n+\n+    public static final String AND_V = PREFIX + \"AND_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_V, \"AndV\");\n+    }\n+\n+    public static final String AND_V_MASK = PREFIX + \"AND_V_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_V_MASK, \"AndVMask\");\n+    }\n+\n+    public static final String CALL = PREFIX + \"CALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CALL, \"Call.*Java\");\n+    }\n+\n+    public static final String CALL_OF_METHOD = COMPOSITE_PREFIX + \"CALL_OF_METHOD\" + POSTFIX;\n+    static {\n+        callOfNodes(CALL_OF_METHOD, \"Call.*Java\");\n+    }\n+\n+    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + \"STATIC_CALL_OF_METHOD\" + POSTFIX;\n+    static {\n+        callOfNodes(STATIC_CALL_OF_METHOD, \"CallStaticJava\");\n+    }\n+\n+    public static final String CAST_II = PREFIX + \"CAST_II\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CAST_II, \"CastII\");\n+    }\n+\n+    public static final String CAST_LL = PREFIX + \"CAST_LL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CAST_LL, \"CastLL\");\n+    }\n+\n+    public static final String CHECKCAST_ARRAY = PREFIX + \"CHECKCAST_ARRAY\" + POSTFIX;\n+    static {\n+        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        optoOnly(CHECKCAST_ARRAY, regex);\n+    }\n+\n+    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"CHECKCAST_ARRAY_OF\" + POSTFIX;\n+    static {\n+        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        optoOnly(CHECKCAST_ARRAY_OF, regex);\n+    }\n@@ -61,74 +254,140 @@\n-    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n-    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n-    public static final String CHECKCAST_ARRAYCOPY = \"(.*((?i:call_leaf_nofp,runtime)|CALL,\\\\s?runtime leaf nofp|BCTRL.*.leaf call).*checkcast_arraycopy.*\" + END;\n-\n-    public static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n-\n-    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + END;\n-    public static final String STORE_B = START + \"StoreB\" + MID + END; \/\/ Store to boolean is also mapped to byte\n-    public static final String STORE_C = START + \"StoreC\" + MID + END;\n-    public static final String STORE_I = START + \"StoreI\" + MID + END; \/\/ Store to short is also mapped to int\n-    public static final String STORE_L = START + \"StoreL\" + MID + END;\n-    public static final String STORE_F = START + \"StoreF\" + MID + END;\n-    public static final String STORE_D = START + \"StoreD\" + MID + END;\n-    public static final String STORE_P = START + \"StoreP\" + MID + END;\n-    public static final String STORE_N = START + \"StoreN\" + MID + END;\n-    public static final String STORE_VECTOR = START + \"StoreVector\" + MID + END;\n-    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreB\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreC\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreI\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreL\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreF\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreD\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreP\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreN\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n-\n-    public static final String LOAD = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + END;\n-    public static final String LOAD_B = START + \"LoadB\" + MID + END;\n-    public static final String LOAD_UB = START + \"LoadUB\" + MID + END; \/\/ Load from boolean\n-    public static final String LOAD_S = START + \"LoadS\" + MID + END;\n-    public static final String LOAD_US = START + \"LoadUS\" + MID + END; \/\/ Load from char\n-    public static final String LOAD_I = START + \"LoadI\" + MID + END;\n-    public static final String LOAD_L = START + \"LoadL\" + MID + END;\n-    public static final String LOAD_F = START + \"LoadF\" + MID + END;\n-    public static final String LOAD_D = START + \"LoadD\" + MID + END;\n-    public static final String LOAD_P = START + \"LoadP\" + MID + END;\n-    public static final String LOAD_N = START + \"LoadN\" + MID + END;\n-    public static final String LOAD_VECTOR = START + \"LoadVector\" + MID + END;\n-    public static final String LOAD_OF_CLASS = COMPOSITE_PREFIX + START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + \"@\\\\S*\"+  IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_B_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadB\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_UB_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadUB\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_S_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadS\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_US_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadUS\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_I_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadI\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_L_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadL\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_F_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadF\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_D_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadD\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_P_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadP\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_N_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadN\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_OF_FIELD = COMPOSITE_PREFIX + START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n-    public static final String LOAD_KLASS  = START + \"LoadK\" + MID + END;\n-\n-    public static final String LOOP   = START + \"Loop\" + MID + END;\n-    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + END;\n-    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n-    public static final String OUTERSTRIPMINEDLOOP = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n-    public static final String LONGCOUNTEDLOOP = START + \"LongCountedLoop\\\\b\" + MID + END;\n-    public static final String IF = START + \"If\\\\b\" + MID + END;\n-\n-    public static final String CALL = START + \"Call.*Java\" + MID + END;\n-    public static final String CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"Call.*Java\" + MID + IS_REPLACED + \" \" +  END;\n-    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallDynamicJava\" + MID + IS_REPLACED + \" \" + END;\n-    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallStaticJava\" + MID + IS_REPLACED + \" \" +  END;\n-    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*reason\" + END;\n-    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n-    public static final String UNSTABLE_IF_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unstable_if\" + END;\n-    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n-    public static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n-    public static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n-    public static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n-    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n-    public static final String INTRINSIC_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic\" + END;\n-    public static final String DIV_BY_ZERO_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*div0_check\" + END;\n+    public static final String CHECKCAST_ARRAYCOPY = PREFIX + \"CHECKCAST_ARRAYCOPY\" + POSTFIX;\n+    static {\n+        String regex = \"(.*((?i:call_leaf_nofp,runtime)|CALL,\\\\s?runtime leaf nofp|BCTRL.*.leaf call).*checkcast_arraycopy.*\" + END;\n+        optoOnly(CHECKCAST_ARRAYCOPY, regex);\n+    }\n+\n+    public static final String CLASS_CHECK_TRAP = PREFIX + \"CLASS_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(CLASS_CHECK_TRAP, \"class_check\");\n+    }\n+\n+    public static final String CMOVE_I = PREFIX + \"CMOVE_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_I, \"CMoveI\");\n+    }\n+\n+    public static final String CMOVE_VD = PREFIX + \"CMOVE_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VD, \"CMoveVD\");\n+    }\n+\n+    public static final String CMOVE_VF = PREFIX + \"CMOVE_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VF, \"CMoveVF\");\n+    }\n+\n+    public static final String CMP_I = PREFIX + \"CMP_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_I, \"CmpI\");\n+    }\n+\n+    public static final String CMP_L = PREFIX + \"CMP_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_L, \"CmpL\");\n+    }\n+\n+    public static final String CMP_U = PREFIX + \"CMP_U\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+    }\n+\n+    public static final String CMP_U3 = PREFIX + \"CMP_U3\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_U3, \"CmpU3\");\n+    }\n+\n+    public static final String CMP_UL = PREFIX + \"CMP_UL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_UL, \"CmpUL\");\n+    }\n+\n+    public static final String CMP_UL3 = PREFIX + \"CMP_UL3\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_UL3, \"CmpUL3\");\n+    }\n+\n+    public static final String COMPRESS_BITS = PREFIX + \"COMPRESS_BITS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COMPRESS_BITS, \"CompressBits\");\n+    }\n+\n+    public static final String CONV_I2L = PREFIX + \"CONV_I2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_I2L, \"ConvI2L\");\n+    }\n+\n+    public static final String CONV_L2I = PREFIX + \"CONV_L2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_L2I, \"ConvL2I\");\n+    }\n+\n+    public static final String CON_I = PREFIX + \"CON_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_I, \"ConI\");\n+    }\n+\n+    public static final String CON_L = PREFIX + \"CON_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_L, \"ConL\");\n+    }\n+\n+    public static final String COUNTED_LOOP = PREFIX + \"COUNTED_LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"CountedLoop\\\\b\" + MID + END;\n+        fromAfterCountedLoops(COUNTED_LOOP, regex);\n+    }\n+\n+    public static final String COUNTED_LOOP_MAIN = PREFIX + \"COUNTED_LOOP_MAIN\" + POSTFIX;\n+    static {\n+        String regex = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+        fromAfterCountedLoops(COUNTED_LOOP_MAIN, regex);\n+    }\n+\n+    public static final String DIV = PREFIX + \"DIV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV, \"Div(I|L|F|D)\");\n+    }\n+\n+    public static final String DIV_BY_ZERO_TRAP = PREFIX + \"DIV_BY_ZERO_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(DIV_BY_ZERO_TRAP, \"div0_check\");\n+    }\n+\n+    public static final String DIV_L = PREFIX + \"DIV_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_L, \"DivL\");\n+    }\n+\n+    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + \"DYNAMIC_CALL_OF_METHOD\" + POSTFIX;\n+    static {\n+        callOfNodes(DYNAMIC_CALL_OF_METHOD, \"CallDynamicJava\");\n+    }\n+\n+    public static final String EXPAND_BITS = PREFIX + \"EXPAND_BITS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(EXPAND_BITS, \"ExpandBits\");\n+    }\n+\n+    public static final String FAST_LOCK = PREFIX + \"FAST_LOCK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FAST_LOCK, \"FastLock\");\n+    }\n+\n+    public static final String FAST_UNLOCK = PREFIX + \"FAST_UNLOCK\" + POSTFIX;\n+    static {\n+        String regex = START + \"FastUnlock\" + MID + END;\n+        fromMacroToBeforeMatching(FAST_UNLOCK, regex);\n+    }\n+\n+    public static final String FIELD_ACCESS = PREFIX + \"FIELD_ACCESS\" + POSTFIX;\n+    static {\n+        String regex = \"(.*Field: *\" + END;\n+        optoOnly(FIELD_ACCESS, regex);\n+    }\n+\n+    public static final String IF = PREFIX + \"IF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IF, \"If\\\\b\");\n+    }\n+\n@@ -137,97 +396,809 @@\n-    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic_or_type_checked_inlining\" + END;\n-\n-    public static final String SCOPE_OBJECT = \"(.*# ScObj.*\" + END;\n-    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n-    public static final String MEMBAR_STORESTORE = START + \"MemBarStoreStore\" + MID + END;\n-    public static final String SAFEPOINT = START + \"SafePoint\" + MID + END;\n-\n-    public static final String CMOVEI = START + \"CMoveI\" + MID + END;\n-    public static final String CMOVEVF = START + \"CMoveVF\" + MID + END;\n-    public static final String CMOVEVD = START + \"CMoveVD\" + MID + END;\n-    public static final String ABS_I = START + \"AbsI\" + MID + END;\n-    public static final String ABS_L = START + \"AbsL\" + MID + END;\n-    public static final String ABS_F = START + \"AbsF\" + MID + END;\n-    public static final String ABS_D = START + \"AbsD\" + MID + END;\n-    public static final String AND = START + \"And(I|L)\" + MID + END;\n-    public static final String AND_I = START + \"AndI\" + MID + END;\n-    public static final String AND_L = START + \"AndL\" + MID + END;\n-    public static final String XOR = START + \"Xor(I|L)\" + MID + END;\n-    public static final String XOR_I = START + \"XorI\" + MID + END;\n-    public static final String XOR_L = START + \"XorL\" + MID + END;\n-    public static final String LSHIFT = START + \"LShift(I|L)\" + MID + END;\n-    public static final String LSHIFT_I = START + \"LShiftI\" + MID + END;\n-    public static final String LSHIFT_L = START + \"LShiftL\" + MID + END;\n-    public static final String RSHIFT = START + \"RShift(I|L)\" + MID + END;\n-    public static final String RSHIFT_I = START + \"RShiftI\" + MID + END;\n-    public static final String RSHIFT_L = START + \"RShiftL\" + MID + END;\n-    public static final String RSHIFT_VB = START + \"RShiftVB\" + MID + END;\n-    public static final String RSHIFT_VS = START + \"RShiftVS\" + MID + END;\n-    public static final String URSHIFT = START + \"URShift(B|S|I|L)\" + MID + END;\n-    public static final String URSHIFT_I = START + \"URShiftI\" + MID + END;\n-    public static final String URSHIFT_L = START + \"URShiftL\" + MID + END;\n-    public static final String ADD = START + \"Add(I|L|F|D|P)\" + MID + END;\n-    public static final String ADD_I = START + \"AddI\" + MID + END;\n-    public static final String ADD_L = START + \"AddL\" + MID + END;\n-    public static final String ADD_VD = START + \"AddVD\" + MID + END;\n-    public static final String ADD_VI = START + \"AddVI\" + MID + END;\n-    public static final String SUB = START + \"Sub(I|L|F|D)\" + MID + END;\n-    public static final String SUB_I = START + \"SubI\" + MID + END;\n-    public static final String SUB_L = START + \"SubL\" + MID + END;\n-    public static final String SUB_F = START + \"SubF\" + MID + END;\n-    public static final String SUB_D = START + \"SubD\" + MID + END;\n-    public static final String CMP_U = START + \"CmpU\" + MID + END;\n-    public static final String CMP_UL = START + \"CmpUL\" + MID + END;\n-    public static final String CMP_U3 = START + \"CmpU3\" + MID + END;\n-    public static final String CMP_UL3 = START + \"CmpUL3\" + MID + END;\n-    public static final String CMP_I = START + \"CmpI\" + MID + END;\n-    public static final String MUL = START + \"Mul(I|L|F|D)\" + MID + END;\n-    public static final String MUL_I = START + \"MulI\" + MID + END;\n-    public static final String MUL_L = START + \"MulL\" + MID + END;\n-    public static final String MUL_F = START + \"MulF\" + MID + END;\n-    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n-    public static final String DIV_L = START + \"DivL\" + MID + END;\n-    public static final String CON_I = START + \"ConI\" + MID + END;\n-    public static final String CON_L = START + \"ConL\" + MID + END;\n-    public static final String CONV_I2L = START + \"ConvI2L\" + MID + END;\n-    public static final String CONV_L2I = START + \"ConvL2I\" + MID + END;\n-    public static final String CAST_II = START + \"CastII\" + MID + END;\n-    public static final String CAST_LL = START + \"CastLL\" + MID + END;\n-    public static final String POPCOUNT_L = START + \"PopCountL\" + MID + END;\n-    public static final String PHI = START + \"Phi\" + MID + END;\n-\n-    public static final String AND_V = START + \"AndV\" + MID + END;\n-    public static final String OR_V = START + \"OrV\" + MID + END;\n-    public static final String XOR_V = START + \"XorV\" + MID + END;\n-    public static final String AND_V_MASK = START + \"AndVMask\" + MID + END;\n-    public static final String OR_V_MASK = START + \"OrVMask\" + MID + END;\n-    public static final String XOR_V_MASK = START + \"XorVMask\" + MID + END;\n-\n-    public static final String VECTOR_MASK_CAST = START + \"VectorMaskCast\" + MID + END;\n-    public static final String VECTOR_CAST_B2X = START + \"VectorCastB2X\" + MID + END;\n-    public static final String VECTOR_CAST_S2X = START + \"VectorCastS2X\" + MID + END;\n-    public static final String VECTOR_CAST_I2X = START + \"VectorCastI2X\" + MID + END;\n-    public static final String VECTOR_CAST_L2X = START + \"VectorCastL2X\" + MID + END;\n-    public static final String VECTOR_CAST_F2X = START + \"VectorCastF2X\" + MID + END;\n-    public static final String VECTOR_CAST_D2X = START + \"VectorCastD2X\" + MID + END;\n-    public static final String VECTOR_UCAST_B2X = START + \"VectorUCastB2X\" + MID + END;\n-    public static final String VECTOR_UCAST_S2X = START + \"VectorUCastS2X\" + MID + END;\n-    public static final String VECTOR_UCAST_I2X = START + \"VectorUCastI2X\" + MID + END;\n-    public static final String VECTOR_REINTERPRET = START + \"VectorReinterpret\" + MID + END;\n-    public static final String VECTOR_BLEND = START + \"VectorBlend\" + MID + END;\n-    public static final String REVERSE_BYTES_V = START + \"ReverseBytesV\" + MID + END;\n-\n-    public static final String Min_I = START + \"MinI\" + MID + END;\n-    public static final String Max_I = START + \"MaxI\" + MID + END;\n-    public static final String Min_V = START + \"MinV\" + MID + END;\n-    public static final String Max_V = START + \"MaxV\" + MID + END;\n-    public static final String MUL_VL = START + \"MulVL\" + MID + END;\n-\n-    public static final String ADD_REDUCTION_VF = START + \"AddReductionVF\" + MID + END;\n-    public static final String ADD_REDUCTION_VD = START + \"AddReductionVD\" + MID + END;\n-    public static final String MUL_REDUCTION_VF = START + \"MulReductionVF\" + MID + END;\n-    public static final String MUL_REDUCTION_VD = START + \"MulReductionVD\" + MID + END;\n-\n-    public static final String FAST_LOCK   = START + \"FastLock\" + MID + END;\n-    public static final String FAST_UNLOCK = START + \"FastUnlock\" + MID + END;\n-\n-    public static final String POPULATE_INDEX = START + \"PopulateIndex\" + MID + END;\n+    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = PREFIX + \"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\"intrinsic_or_type_checked_inlining\");\n+    }\n+\n+    public static final String INTRINSIC_TRAP = PREFIX + \"INTRINSIC_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(INTRINSIC_TRAP,\"intrinsic\");\n+    }\n+\n+    \/\/ Is only supported on riscv64.\n+    public static final String IS_FINITE_D = PREFIX + \"IS_FINITE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_FINITE_D, \"IsFiniteD\");\n+    }\n+\n+    \/\/ Is only supported on riscv64.\n+    public static final String IS_FINITE_F = PREFIX + \"IS_FINITE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_FINITE_F, \"IsFiniteF\");\n+    }\n+\n+    public static final String IS_INFINITE_D = PREFIX + \"IS_INFINITE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_INFINITE_D, \"IsInfiniteD\");\n+    }\n+\n+    public static final String IS_INFINITE_F = PREFIX + \"IS_INFINITE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_INFINITE_F, \"IsInfiniteF\");\n+    }\n+\n+    public static final String LOAD = PREFIX + \"LOAD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD, \"Load(B|UB|S|US|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String LOAD_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_OF_CLASS, \"Load(B|UB|S|US|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String LOAD_B = PREFIX + \"LOAD_B\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_B, \"LoadB\");\n+    }\n+\n+    public static final String LOAD_B_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_B_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_B_OF_CLASS, \"LoadB\");\n+    }\n+\n+    public static final String LOAD_D = PREFIX + \"LOAD_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_D, \"LoadD\");\n+    }\n+\n+    public static final String LOAD_D_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_D_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_D_OF_CLASS, \"LoadD\");\n+    }\n+\n+    public static final String LOAD_F = PREFIX + \"LOAD_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_F, \"LoadF\");\n+    }\n+\n+    public static final String LOAD_F_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_F_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_F_OF_CLASS, \"LoadF\");\n+    }\n+\n+    public static final String LOAD_I = PREFIX + \"LOAD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_I, \"LoadI\");\n+    }\n+\n+    public static final String LOAD_I_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_I_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_I_OF_CLASS, \"LoadI\");\n+    }\n+\n+    public static final String LOAD_KLASS = PREFIX + \"LOAD_KLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_KLASS, \"LoadKlass\");\n+    }\n+\n+    public static final String LOAD_L = PREFIX + \"LOAD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_L, \"LoadL\");\n+    }\n+\n+    public static final String LOAD_L_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_L_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_L_OF_CLASS, \"LoadL\");\n+    }\n+\n+    public static final String LOAD_N = PREFIX + \"LOAD_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_N, \"LoadN\");\n+    }\n+\n+    public static final String LOAD_N_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_N_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_N_OF_CLASS, \"LoadN\");\n+    }\n+\n+    public static final String LOAD_OF_FIELD = COMPOSITE_PREFIX + \"LOAD_OF_FIELD\" + POSTFIX;\n+    static {\n+        String regex = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n+        beforeMatching(LOAD_OF_FIELD, regex);\n+    }\n+\n+    public static final String LOAD_P = PREFIX + \"LOAD_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_P, \"LoadP\");\n+    }\n+\n+    public static final String LOAD_P_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_P_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_P_OF_CLASS, \"LoadP\");\n+    }\n+\n+    public static final String LOAD_S = PREFIX + \"LOAD_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_S, \"LoadS\");\n+    }\n+\n+    public static final String LOAD_S_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_S_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_S_OF_CLASS, \"LoadS\");\n+    }\n+\n+    public static final String LOAD_UB = PREFIX + \"LOAD_UB\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_UB, \"LoadUB\");\n+    }\n+\n+    public static final String LOAD_UB_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_UB_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_UB_OF_CLASS, \"LoadUB\");\n+    }\n+\n+    public static final String LOAD_US = PREFIX + \"LOAD_US\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_US, \"LoadUS\");\n+    }\n+\n+    public static final String LOAD_US_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_US_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_US_OF_CLASS, \"LoadUS\");\n+    }\n+\n+    public static final String LOAD_VECTOR = PREFIX + \"LOAD_VECTOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR, \"LoadVector\");\n+    }\n+\n+    public static final String LOAD_VECTOR_GATHER = PREFIX + \"LOAD_VECTOR_GATHER\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR_GATHER, \"LoadVectorGather\");\n+    }\n+\n+    public static final String LOAD_VECTOR_GATHER_MASKED = PREFIX + \"LOAD_VECTOR_GATHER_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR_GATHER_MASKED, \"LoadVectorGatherMasked\");\n+    }\n+\n+    public static final String LONG_COUNTED_LOOP = PREFIX + \"LONG_COUNTED_LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"LongCountedLoop\\\\b\" + MID + END;\n+        fromAfterCountedLoops(LONG_COUNTED_LOOP, regex);\n+    }\n+\n+    public static final String LOOP = PREFIX + \"LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"Loop\" + MID + END;\n+        fromBeforeCountedLoops(LOOP, regex);\n+    }\n+\n+    public static final String LSHIFT = PREFIX + \"LSHIFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT, \"LShift(I|L)\");\n+    }\n+\n+    public static final String LSHIFT_I = PREFIX + \"LSHIFT_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT_I, \"LShiftI\");\n+    }\n+\n+    public static final String LSHIFT_L = PREFIX + \"LSHIFT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT_L, \"LShiftL\");\n+    }\n+\n+    public static final String MACRO_LOGIC_V = PREFIX + \"MACRO_LOGIC_V\" + POSTFIX;\n+    static {\n+        afterBarrierExpansionToBeforeMatching(MACRO_LOGIC_V, \"MacroLogicV\");\n+    }\n+\n+    public static final String MAX = PREFIX + \"MAX\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX, \"Max(I|L)\");\n+    }\n+\n+    public static final String MAX_I = PREFIX + \"MAX_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_I, \"MaxI\");\n+    }\n+\n+    public static final String MAX_V = PREFIX + \"MAX_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_V, \"MaxV\");\n+    }\n+\n+    public static final String MEMBAR = PREFIX + \"MEMBAR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR, \"MemBar\");\n+    }\n+\n+    public static final String MEMBAR_STORESTORE = PREFIX + \"MEMBAR_STORESTORE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_STORESTORE, \"MemBarStoreStore\");\n+    }\n+\n+    public static final String MIN = PREFIX + \"MIN\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN, \"Min(I|L)\");\n+    }\n+\n+    public static final String MIN_I = PREFIX + \"MIN_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_I, \"MinI\");\n+    }\n+\n+    public static final String MIN_V = PREFIX + \"MIN_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_V, \"MinV\");\n+    }\n+\n+    public static final String MUL = PREFIX + \"MUL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL, \"Mul(I|L|F|D)\");\n+    }\n+\n+    public static final String MUL_D = PREFIX + \"MUL_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_D, \"MulD\");\n+    }\n+\n+    public static final String MUL_F = PREFIX + \"MUL_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_F, \"MulF\");\n+    }\n+\n+    public static final String MUL_I = PREFIX + \"MUL_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_I, \"MulI\");\n+    }\n+\n+    public static final String MUL_L = PREFIX + \"MUL_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_L, \"MulL\");\n+    }\n+\n+    public static final String MUL_VL = PREFIX + \"MUL_VL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VL, \"MulVL\");\n+    }\n+\n+    public static final String MUL_REDUCTION_VD = PREFIX + \"MUL_REDUCTION_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VD, \"MulReductionVD\");\n+    }\n+\n+    public static final String MUL_REDUCTION_VF = PREFIX + \"MUL_REDUCTION_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VF, \"MulReductionVF\");\n+    }\n+\n+    public static final String NULL_ASSERT_TRAP = PREFIX + \"NULL_ASSERT_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(NULL_ASSERT_TRAP,\"null_assert\");\n+    }\n+\n+    public static final String NULL_CHECK_TRAP = PREFIX + \"NULL_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(NULL_CHECK_TRAP,\"null_check\");\n+    }\n+\n+    public static final String OR_V = PREFIX + \"OR_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR_V, \"OrV\");\n+    }\n+\n+    public static final String OR_V_MASK = PREFIX + \"OR_V_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR_V_MASK, \"OrVMask\");\n+    }\n+\n+    public static final String OUTER_STRIP_MINED_LOOP = PREFIX + \"OUTER_STRIP_MINED_LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n+        fromAfterCountedLoops(OUTER_STRIP_MINED_LOOP, regex);\n+    }\n+\n+    public static final String PHI = PREFIX + \"PHI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(PHI, \"Phi\");\n+    }\n+\n+    public static final String POPCOUNT_L = PREFIX + \"POPCOUNT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(POPCOUNT_L, \"PopCountL\");\n+    }\n+\n+    public static final String POPCOUNT_VL = PREFIX + \"POPCOUNT_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(POPCOUNT_VL, \"PopCountVL\");\n+    }\n+\n+    public static final String COUNTTRAILINGZEROS_VL = PREFIX + \"COUNTTRAILINGZEROS_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(COUNTTRAILINGZEROS_VL, \"CountTrailingZerosV\");\n+    }\n+\n+    public static final String COUNTLEADINGZEROS_VL = PREFIX + \"COUNTLEADINGZEROS_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(COUNTLEADINGZEROS_VL, \"CountLeadingZerosV\");\n+    }\n+\n+    public static final String POPULATE_INDEX = PREFIX + \"POPULATE_INDEX\" + POSTFIX;\n+    static {\n+        String regex = START + \"PopulateIndex\" + MID + END;\n+        IR_NODE_MAPPINGS.put(POPULATE_INDEX, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                       CompilePhase.AFTER_CLOOPS,\n+                                                                       CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String PREDICATE_TRAP = PREFIX + \"PREDICATE_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(PREDICATE_TRAP,\"predicate\");\n+    }\n+\n+    public static final String RANGE_CHECK_TRAP = PREFIX + \"RANGE_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(RANGE_CHECK_TRAP,\"range_check\");\n+    }\n+\n+    public static final String REVERSE_BYTES_V = PREFIX + \"REVERSE_BYTES_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_V, \"ReverseBytesV\");\n+    }\n+\n+    public static final String REVERSE_I = PREFIX + \"REVERSE_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_I, \"ReverseI\");\n+    }\n+\n+    public static final String REVERSE_L = PREFIX + \"REVERSE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_L, \"ReverseL\");\n+    }\n+\n+    public static final String REVERSE_V = PREFIX + \"REVERSE_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_V, \"ReverseV\");\n+    }\n+\n+    public static final String ROUND_VD = PREFIX + \"ROUND_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_VD, \"RoundVD\");\n+    }\n+\n+    public static final String ROUND_VF = PREFIX + \"ROUND_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_VF, \"RoundVF\");\n+    }\n+\n+    public static final String ROTATE_LEFT = PREFIX + \"ROTATE_LEFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROTATE_LEFT, \"RotateLeft\");\n+    }\n+\n+    public static final String ROTATE_RIGHT = PREFIX + \"ROTATE_RIGHT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROTATE_RIGHT, \"RotateRight\");\n+    }\n+\n+    public static final String RSHIFT = PREFIX + \"RSHIFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT, \"RShift(I|L)\");\n+    }\n+\n+    public static final String RSHIFT_I = PREFIX + \"RSHIFT_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_I, \"RShiftI\");\n+    }\n+\n+    public static final String RSHIFT_L = PREFIX + \"RSHIFT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_L, \"RShiftL\");\n+    }\n+\n+    public static final String RSHIFT_VB = PREFIX + \"RSHIFT_VB\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_VB, \"RShiftVB\");\n+    }\n+\n+    public static final String RSHIFT_VS = PREFIX + \"RSHIFT_VS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_VS, \"RShiftVS\");\n+    }\n+\n+    public static final String SAFEPOINT = PREFIX + \"SAFEPOINT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SAFEPOINT, \"SafePoint\");\n+    }\n+\n+    public static final String SCOPE_OBJECT = PREFIX + \"SCOPE_OBJECT\" + POSTFIX;\n+    static {\n+        String regex = \"(.*# ScObj.*\" + END;\n+        optoOnly(SCOPE_OBJECT, regex);\n+    }\n+\n+    public static final String SIGNUM_VD = PREFIX + \"SIGNUM_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SIGNUM_VD, \"SignumVD\");\n+    }\n+\n+    public static final String SIGNUM_VF = PREFIX + \"SIGNUM_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SIGNUM_VF, \"SignumVF\");\n+    }\n+\n+    public static final String STORE = PREFIX + \"STORE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE, \"Store(B|C|S|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String STORE_B = PREFIX + \"STORE_B\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_B, \"StoreB\");\n+    }\n+\n+    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + \"STORE_B_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_B_OF_CLASS, \"StoreB\");\n+    }\n+\n+    public static final String STORE_C = PREFIX + \"STORE_C\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_C, \"StoreC\");\n+    }\n+\n+    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + \"STORE_C_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_C_OF_CLASS, \"StoreC\");\n+    }\n+\n+    public static final String STORE_D = PREFIX + \"STORE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_D, \"StoreD\");\n+    }\n+\n+    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + \"STORE_D_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_D_OF_CLASS, \"StoreD\");\n+    }\n+\n+    public static final String STORE_F = PREFIX + \"STORE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_F, \"StoreF\");\n+    }\n+\n+    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + \"STORE_F_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_F_OF_CLASS, \"StoreF\");\n+    }\n+\n+    public static final String STORE_I = PREFIX + \"STORE_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_I, \"StoreI\");\n+    }\n+\n+    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + \"STORE_I_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_I_OF_CLASS, \"StoreI\");\n+    }\n+\n+    public static final String STORE_L = PREFIX + \"STORE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_L, \"StoreL\");\n+    }\n+\n+    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + \"STORE_L_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_L_OF_CLASS, \"StoreL\");\n+    }\n+\n+    public static final String STORE_N = PREFIX + \"STORE_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_N, \"StoreN\");\n+    }\n+\n+    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + \"STORE_N_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_N_OF_CLASS, \"StoreN\");\n+    }\n+\n+    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + \"STORE_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_OF_CLASS, \"Store(B|C|S|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + \"STORE_OF_FIELD\" + POSTFIX;\n+    static {\n+        String regex = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n+        beforeMatching(STORE_OF_FIELD, regex);\n+    }\n+\n+    public static final String STORE_P = PREFIX + \"STORE_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_P, \"StoreP\");\n+    }\n+\n+    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + \"STORE_P_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_P_OF_CLASS, \"StoreP\");\n+    }\n+\n+    public static final String STORE_VECTOR = PREFIX + \"STORE_VECTOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR, \"StoreVector\");\n+    }\n+\n+    public static final String STORE_VECTOR_SCATTER = PREFIX + \"STORE_VECTOR_SCATTER\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR_SCATTER, \"StoreVectorScatter\");\n+    }\n+\n+    public static final String STORE_VECTOR_SCATTER_MASKED = PREFIX + \"STORE_VECTOR_SCATTER_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR_SCATTER_MASKED, \"StoreVectorScatterMasked\");\n+    }\n+\n+    public static final String SUB = PREFIX + \"SUB\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB, \"Sub(I|L|F|D)\");\n+    }\n+\n+    public static final String SUB_D = PREFIX + \"SUB_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_D, \"SubD\");\n+    }\n+\n+    public static final String SUB_F = PREFIX + \"SUB_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_F, \"SubF\");\n+    }\n+\n+    public static final String SUB_I = PREFIX + \"SUB_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_I, \"SubI\");\n+    }\n+\n+    public static final String SUB_L = PREFIX + \"SUB_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_L, \"SubL\");\n+    }\n+\n+    public static final String TRAP = PREFIX + \"TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(TRAP,\"reason\");\n+    }\n+\n+    public static final String UDIV_I = PREFIX + \"UDIV_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_I, \"UDivI\");\n+    }\n+\n+    public static final String UDIV_L = PREFIX + \"UDIV_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_L, \"UDivL\");\n+    }\n+\n+    public static final String UDIV_MOD_I = PREFIX + \"UDIV_MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_MOD_I, \"UDivModI\");\n+    }\n+\n+    public static final String UDIV_MOD_L = PREFIX + \"UDIV_MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_MOD_L, \"UDivModL\");\n+    }\n+\n+    public static final String UMOD_I = PREFIX + \"UMOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMOD_I, \"UModI\");\n+    }\n+\n+    public static final String UMOD_L = PREFIX + \"UMOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMOD_L, \"UModL\");\n+    }\n+\n+    public static final String UNHANDLED_TRAP = PREFIX + \"UNHANDLED_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNHANDLED_TRAP,\"unhandled\");\n+    }\n+\n+    public static final String UNSTABLE_IF_TRAP = PREFIX + \"UNSTABLE_IF_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNSTABLE_IF_TRAP,\"unstable_if\");\n+    }\n+\n+    public static final String URSHIFT = PREFIX + \"URSHIFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT, \"URShift(B|S|I|L)\");\n+    }\n+\n+    public static final String URSHIFT_B = PREFIX + \"URSHIFT_B\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_B, \"URShiftB\");\n+    }\n+\n+    public static final String URSHIFT_I = PREFIX + \"URSHIFT_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_I, \"URShiftI\");\n+    }\n+\n+    public static final String URSHIFT_L = PREFIX + \"URSHIFT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_L, \"URShiftL\");\n+    }\n+\n+    public static final String URSHIFT_S = PREFIX + \"URSHIFT_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_S, \"URShiftS\");\n+    }\n+\n+    public static final String VAND_NOT_I = PREFIX + \"VAND_NOT_I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VAND_NOT_I, \"vand_notI\");\n+    }\n+\n+    public static final String VAND_NOT_L = PREFIX + \"VAND_NOT_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VAND_NOT_L, \"vand_notL\");\n+    }\n+\n+    public static final String VECTOR_BLEND = PREFIX + \"VECTOR_BLEND\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_BLEND, \"VectorBlend\");\n+    }\n+\n+    public static final String VECTOR_CAST_B2X = PREFIX + \"VECTOR_CAST_B2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_B2X, \"VectorCastB2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_D2X = PREFIX + \"VECTOR_CAST_D2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_D2X, \"VectorCastD2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_F2X = PREFIX + \"VECTOR_CAST_F2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2X, \"VectorCastF2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_I2X = PREFIX + \"VECTOR_CAST_I2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_I2X, \"VectorCastI2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_L2X = PREFIX + \"VECTOR_CAST_L2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_L2X, \"VectorCastL2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_S2X = PREFIX + \"VECTOR_CAST_S2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_S2X, \"VectorCastS2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_F2HF = PREFIX + \"VECTOR_CAST_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2HF, \"VectorCastF2HF\");\n+    }\n+\n+    public static final String VECTOR_CAST_HF2F = PREFIX + \"VECTOR_CAST_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_HF2F, \"VectorCastHF2F\");\n+    }\n+\n+    public static final String VECTOR_MASK_CAST = PREFIX + \"VECTOR_MASK_CAST\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_CAST, \"VectorMaskCast\");\n+    }\n+\n+    public static final String VECTOR_REINTERPRET = PREFIX + \"VECTOR_REINTERPRET\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_REINTERPRET, \"VectorReinterpret\");\n+    }\n+\n+    public static final String VECTOR_UCAST_B2X = PREFIX + \"VECTOR_UCAST_B2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_UCAST_B2X, \"VectorUCastB2X\");\n+    }\n+\n+    public static final String VECTOR_UCAST_I2X = PREFIX + \"VECTOR_UCAST_I2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_UCAST_I2X, \"VectorUCastI2X\");\n+    }\n+\n+    public static final String VECTOR_UCAST_S2X = PREFIX + \"VECTOR_UCAST_S2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_UCAST_S2X, \"VectorUCastS2X\");\n+    }\n+\n+    public static final String VFABD = PREFIX + \"VFABD\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFABD, \"vfabd\");\n+    }\n+\n+    public static final String VFABD_MASKED = PREFIX + \"VFABD_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFABD_MASKED, \"vfabd_masked\");\n+    }\n+\n+    public static final String VFMSB_MASKED = PREFIX + \"VFMSB_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFMSB_MASKED, \"vfmsb_masked\");\n+    }\n+\n+    public static final String VFNMAD_MASKED = PREFIX + \"VFNMAD_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFNMAD_MASKED, \"vfnmad_masked\");\n+    }\n+\n+    public static final String VFNMSB_MASKED = PREFIX + \"VFNMSB_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFNMSB_MASKED, \"vfnmsb_masked\");\n+    }\n+\n+    public static final String VMASK_AND_NOT_L = PREFIX + \"VMASK_AND_NOT_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMASK_AND_NOT_L, \"vmask_and_notL\");\n+    }\n+\n+    public static final String VMLA = PREFIX + \"VMLA\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLA, \"vmla\");\n+    }\n+\n+    public static final String VMLA_MASKED = PREFIX + \"VMLA_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLA_MASKED, \"vmla_masked\");\n+    }\n+\n+    public static final String VMLS = PREFIX + \"VMLS\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLS, \"vmls\");\n+    }\n+\n+    public static final String VMLS_MASKED = PREFIX + \"VMLS_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLS_MASKED, \"vmls_masked\");\n+    }\n+\n+    public static final String VNOT_I_MASKED = PREFIX + \"VNOT_I_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VNOT_I_MASKED, \"vnotI_masked\");\n+    }\n+\n+    public static final String VNOT_L_MASKED = PREFIX + \"VNOT_L_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VNOT_L_MASKED, \"vnotL_masked\");\n+    }\n+\n+    public static final String XOR = PREFIX + \"XOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR, \"Xor(I|L)\");\n+    }\n+\n+    public static final String XOR_I = PREFIX + \"XOR_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_I, \"XorI\");\n+    }\n+\n+    public static final String XOR_L = PREFIX + \"XOR_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_L, \"XorL\");\n+    }\n+\n+    public static final String XOR_V = PREFIX + \"XOR_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_V, \"XorV\");\n+    }\n+\n+    public static final String XOR_V_MASK = PREFIX + \"XOR_V_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_V_MASK, \"XorVMask\");\n+    }\n+\n+    \/*\n+     * Utility methods to set up IR_NODE_MAPPINGS.\n+     *\/\n@@ -236,1 +1207,2 @@\n-     * Called by {@link IRMatcher} to merge special composite nodes together with additional user-defined input.\n+     * Apply {@code regex} on all machine independent ideal graph phases up to and including\n+     * {@link CompilePhase#BEFORE_MATCHING}.\n@@ -238,14 +1210,139 @@\n-    public static List<String> mergeNodes(String[] nodes) {\n-        List<String> mergedNodes = new ArrayList<>();\n-        for (int i = 0; i < nodes.length; i += 2) {\n-            String node = nodes[i];\n-            if (node.startsWith(COMPOSITE_PREFIX)) {\n-                if (i + 1 == nodes.length) {\n-                    reportMissingCompositeValue(node, i);\n-                }\n-                \/\/ Replace placeholder with user defined string.\n-                node = node.substring(COMPOSITE_PREFIX.length()).replaceAll(IS_REPLACED, nodes[i + 1]);\n-            } else {\n-                i--; \/\/ No composite node, do not increment by 2.\n-            }\n-            mergedNodes.add(node);\n+    public static void beforeMatching(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    \/**\n+     * Apply {@code irNodeRegex} as regex for the IR node name on all machine independent ideal graph phases up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}.\n+     *\/\n+    private static void beforeMatchingNameRegex(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    private static void allocNodes(String irNode, String irNodeName, String optoRegex) {\n+        String idealIndependentRegex = START + irNodeName + \"\\\\b\" + MID + END;\n+        Map<PhaseInterval, String> intervalToRegexMap = new HashMap<>();\n+        intervalToRegexMap.put(new PhaseInterval(CompilePhase.BEFORE_REMOVEUSELESS, CompilePhase.PHASEIDEALLOOP_ITERATIONS),\n+                               idealIndependentRegex);\n+        intervalToRegexMap.put(new PhaseInterval(CompilePhase.PRINT_OPTO_ASSEMBLY), optoRegex);\n+        MultiPhaseRangeEntry entry = new MultiPhaseRangeEntry(CompilePhase.PRINT_OPTO_ASSEMBLY, intervalToRegexMap);\n+        IR_NODE_MAPPINGS.put(irNode, entry);\n+    }\n+\n+    private static void callOfNodes(String irNodePlaceholder, String callRegex) {\n+        String regex = START + callRegex + MID + IS_REPLACED + \" \" +  END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all machine dependant ideal graph phases (i.e. on the mach graph) starting from\n+     * {@link CompilePhase#MATCHING}.\n+     *\/\n+    public static void optoOnly(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.OPTO_ASSEMBLY, regex));\n+    }\n+\n+    private static void machOnly(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.MACH, regex));\n+    }\n+\n+    private static void machOnlyNameRegex(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.MACH, regex));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#AFTER_CLOOPS}.\n+     *\/\n+    private static void fromAfterCountedLoops(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.AFTER_CLOOPS,\n+                                                                          CompilePhase.FINAL_CODE));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_CLOOPS}.\n+     *\/\n+    private static void fromBeforeCountedLoops(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.BEFORE_CLOOPS,\n+                                                                          CompilePhase.FINAL_CODE));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_CLOOPS} up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}\n+     *\/\n+    private static void fromMacroToBeforeMatching(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.MACRO_EXPANSION,\n+                                                                          CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_CLOOPS} up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}\n+     *\/\n+    private static void afterBarrierExpansionToBeforeMatching(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.OPTIMIZE_FINISHED,\n+                                                                          CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    private static void trapNodes(String irNodePlaceholder, String trapReason) {\n+        String regex = START + \"CallStaticJava\" + MID + \"uncommon_trap.*\" + trapReason + END;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    private static void loadOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    private static void storeOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#PHASEIDEALLOOP1} which is the\n+     * first phase that could contain vector nodes from super word.\n+     *\/\n+    private static void superWordNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.PHASEIDEALLOOP1,\n+                                                                          CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+\n+    \/*\n+     * Methods used internally by the IR framework.\n+     *\/\n+\n+    \/**\n+     * Is {@code irNodeString} an IR node placeholder string?\n+     *\/\n+    public static boolean isIRNode(String irNodeString) {\n+        return irNodeString.startsWith(PREFIX);\n+    }\n+\n+    \/**\n+     * Is {@code irCompositeNodeString} an IR composite node placeholder string?\n+     *\/\n+    public static boolean isCompositeIRNode(String irCompositeNodeString) {\n+        return irCompositeNodeString.startsWith(COMPOSITE_PREFIX);\n+    }\n+\n+    \/**\n+     * Returns \"IRNode.XYZ\", where XYZ is one of the IR node placeholder variable names defined above.\n+     *\/\n+    public static String getIRNodeAccessString(String irNodeString) {\n+        int prefixLength;\n+        if (isCompositeIRNode(irNodeString)) {\n+            TestFramework.check(irNodeString.length() > COMPOSITE_PREFIX.length() + POSTFIX.length(),\n+                                \"Invalid composite node placeholder: \" + irNodeString);\n+            prefixLength = COMPOSITE_PREFIX.length();\n+        } else {\n+            prefixLength = PREFIX.length();\n@@ -253,1 +1350,1 @@\n-        return mergedNodes;\n+        return \"IRNode.\" + irNodeString.substring(prefixLength, irNodeString.length() - POSTFIX.length());\n@@ -257,2 +1354,2 @@\n-     * Is default regex supported on current platform, used VM build, etc.?\n-     * Throws a {@link CheckedTestFrameworkException} if the default regex is unsupported.\n+     * Is this IR node supported on current platform, used VM build, etc.?\n+     * Throws a {@link CheckedTestFrameworkException} if the IR node is unsupported.\n@@ -260,1 +1357,1 @@\n-    public static void checkDefaultRegexSupported(String node) throws CheckedTestFrameworkException {\n+    public static void checkIRNodeSupported(String node) throws CheckedTestFrameworkException {\n@@ -264,1 +1361,2 @@\n-                    throw new CheckedTestFrameworkException(\"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP is unsupported in builds without JVMCI.\");\n+                    throw new CheckedTestFrameworkException(\"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP is unsupported \" +\n+                                                            \"in builds without JVMCI.\");\n@@ -272,1 +1370,6 @@\n-            \/\/ default: do nothing -> default regex is supported\n+            case IS_FINITE_D, IS_FINITE_F -> {\n+                if (!Platform.isRISCV64()) {\n+                    throw new CheckedTestFrameworkException(\"IS_FINITE_* is only supported on riscv64.\");\n+                }\n+            }\n+            \/\/ default: do nothing -> IR node is supported and can be used by the user.\n@@ -277,1 +1380,26 @@\n-     * Mapping from string variable value to string variable name for better error reporting.\n+     * Get the regex of an IR node for a specific compile phase. If {@code irNode} is not an IR node placeholder string\n+     * or if there is no regex specified for {@code compilePhase}, a {@link TestFormatException} is reported.\n+     *\/\n+    public static String getRegexForCompilePhase(String irNode, CompilePhase compilePhase) {\n+        IRNodeMapEntry entry = IR_NODE_MAPPINGS.get(irNode);\n+        String failMsg = \"IR Node \\\"\" + irNode + \"\\\" defined in class IRNode has no regex\/compiler phase mapping \" +\n+                         \"(i.e. no static initializer block that adds a mapping entry to IRNode.IR_NODE_MAPPINGS).\" +\n+                         System.lineSeparator() +\n+                         \"   Have you just created the entry \\\"\" + irNode + \"\\\" in class IRNode and forgot to add a \" +\n+                         \"mapping?\" + System.lineSeparator() +\n+                         \"   Violation\";\n+        TestFormat.checkNoReport(entry != null, failMsg);\n+        String regex = entry.regexForCompilePhase(compilePhase);\n+        failMsg = \"IR Node \\\"\" + irNode + \"\\\" defined in class IRNode has no regex defined for compile phase \"\n+                  + compilePhase + \".\" + System.lineSeparator() +\n+                  \"   If you think this compile phase should be supported, update the mapping for \\\"\" + irNode +\n+                  \"\\\" in class IRNode (i.e the static initializer block immediately following the definition of \\\"\" +\n+                  irNode + \"\\\").\" + System.lineSeparator() +\n+                  \"   Violation\";\n+        TestFormat.checkNoReport(regex != null, failMsg);\n+        return regex;\n+    }\n+\n+    \/**\n+     * Get the default phase of an IR node. If {@code irNode} is not an IR node placeholder string, a\n+     * {@link TestFormatException} is reported.\n@@ -279,30 +1407,13 @@\n-    private static void reportMissingCompositeValue(String node, int i) {\n-        String varName = switch (node) {\n-            case ALLOC_OF -> \"ALLOC_OF\";\n-            case ALLOC_ARRAY_OF -> \"ALLOC_ARRAY_OF\";\n-            case CHECKCAST_ARRAY_OF -> \"CHECKCAST_ARRAY_OF\";\n-            case STORE_OF_CLASS -> \"STORE_OF_CLASS\";\n-            case STORE_B_OF_CLASS -> \"STORE_B_OF_CLASS\";\n-            case STORE_C_OF_CLASS -> \"STORE_C_OF_CLASS\";\n-            case STORE_D_OF_CLASS -> \"STORE_D_OF_CLASS\";\n-            case STORE_F_OF_CLASS -> \"STORE_F_OF_CLASS\";\n-            case STORE_I_OF_CLASS -> \"STORE_I_OF_CLASS\";\n-            case STORE_L_OF_CLASS -> \"STORE_L_OF_CLASS\";\n-            case STORE_N_OF_CLASS -> \"STORE_N_OF_CLASS\";\n-            case STORE_P_OF_CLASS -> \"STORE_P_OF_CLASS\";\n-            case STORE_OF_FIELD -> \"STORE_OF_FIELD\";\n-            case LOAD_OF_CLASS -> \"LOAD_OF_CLASS\";\n-            case LOAD_B_OF_CLASS -> \"LOAD_B_OF_CLASS\";\n-            case LOAD_UB_OF_CLASS -> \"LOAD_UB_OF_CLASS\";\n-            case LOAD_D_OF_CLASS -> \"LOAD_D_OF_CLASS\";\n-            case LOAD_F_OF_CLASS -> \"LOAD_F_OF_CLASS\";\n-            case LOAD_I_OF_CLASS -> \"LOAD_I_OF_CLASS\";\n-            case LOAD_L_OF_CLASS -> \"LOAD_L_OF_CLASS\";\n-            case LOAD_N_OF_CLASS -> \"LOAD_N_OF_CLASS\";\n-            case LOAD_P_OF_CLASS -> \"LOAD_P_OF_CLASS\";\n-            case LOAD_S_OF_CLASS -> \"LOAD_S_OF_CLASS\";\n-            case LOAD_US_OF_CLASS -> \"LOAD_US_OF_CLASS\";\n-            case LOAD_OF_FIELD -> \"LOAD_OF_FIELD\";\n-            default -> throw new TestFrameworkException(\"Missing variable mapping for \" + node);\n-        };\n-        TestFormat.fail(\"Must provide additional value at index \" + (i + 1) + \" right after \" + varName);\n+    public static CompilePhase getDefaultPhase(String irNode) {\n+        IRNodeMapEntry entry = IR_NODE_MAPPINGS.get(irNode);\n+        String failMsg = \"\\\"\" + irNode + \"\\\" is not an IR node defined in class IRNode and \" +\n+                         \"has therefore no default compile phase specified.\" + System.lineSeparator() +\n+                         \"   If your regex represents a C2 IR node, consider adding an entry to class IRNode together \" +\n+                         \"with a static initializer block that adds a mapping to IRNode.IR_NODE_MAPPINGS.\" +\n+                         System.lineSeparator() +\n+                         \"   Otherwise, set the @IR \\\"phase\\\" attribute to a compile phase different from \" +\n+                         \"CompilePhase.DEFAULT to explicitly tell the IR framework on which compile phase your rule\" +\n+                         \" should be applied on.\" + System.lineSeparator() +\n+                         \"   Violation\";\n+        TestFormat.checkNoReport(entry != null, failMsg);\n+        return entry.defaultCompilePhase();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1351,"deletions":240,"binary":false,"changes":1591,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n@@ -108,0 +110,1 @@\n+     * <p>\n@@ -139,0 +142,1 @@\n+                    \"UseZbb\",\n@@ -304,2 +308,2 @@\n-        TestFormat.check(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n-                         \"A scenario cannot be null\");\n+        TestFormat.checkAndReport(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n+                                  \"A scenario cannot be null\");\n@@ -313,1 +317,1 @@\n-            TestFormat.check(scenarioIndices.add(scenarioIndex),\n+            TestFormat.checkNoThrow(scenarioIndices.add(scenarioIndex),\n@@ -317,0 +321,1 @@\n+        TestFormat.throwIfAnyFailures();\n@@ -328,0 +333,1 @@\n+        checkIRRuleCompilePhasesFormat();\n@@ -337,1 +343,0 @@\n-                System.out.println(\"Compilation(s) of failed match(es):\");\n@@ -347,0 +352,11 @@\n+    private void checkIRRuleCompilePhasesFormat() {\n+        for (Method method : testClass.getDeclaredMethods()) {\n+            for (IR irAnno : method.getAnnotationsByType(IR.class)) {\n+                TestFormat.checkNoThrow(irAnno.phase().length > 0,\n+                                        \"@IR rule \" + irAnno + \" must specify a non-empty list of compile \" +\n+                                        \"phases \\\"phase\\\" at \" + method);\n+            }\n+        }\n+        TestFormat.throwIfAnyFailures();\n+    }\n+\n@@ -378,1 +394,1 @@\n-        TestFormat.check(defaultWarmup >= 0, \"Cannot specify a negative default warm-up\");\n+        TestFormat.checkAndReport(defaultWarmup >= 0, \"Cannot specify a negative default warm-up\");\n@@ -640,2 +656,3 @@\n-                System.out.println((scenario != null ? \"Scenario #\" + scenario.getIndex() + \" - \" : \"\")\n-                                   + \"Compilation(s) of failed matche(s):\");\n+                if (scenario != null) {\n+                    System.out.println(\"Scenario #\" + scenario.getIndex());\n+                }\n@@ -723,1 +740,1 @@\n-        return Arrays.stream(testClass.getDeclaredMethods()).anyMatch(m -> m.getAnnotationsByType(IR.class) != null);\n+        return Arrays.stream(testClass.getDeclaredMethods()).anyMatch(m -> m.getAnnotationsByType(IR.class).length > 0);\n@@ -744,1 +761,5 @@\n-                new IRMatcher(testVMProcess.getHotspotPidFileName(), testVMProcess.getIrEncoding(), testClass);\n+                MethodCompilationParser methodCompilationParser = new MethodCompilationParser(testClass);\n+                Matchable testClassMatchable = methodCompilationParser.parse(testVMProcess.getHotspotPidFileName(),\n+                                                                             testVMProcess.getIrEncoding());\n+                IRMatcher matcher = new IRMatcher(testClassMatchable);\n+                matcher.match();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -370,1 +370,3 @@\n-                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n+                                    + \"Make sure to provide any form of static initialization or remove the annotation. \"\n+                                    + \"For debugging purposes, -DIgnoreCompilerControls=true can be used to temporarly \"\n+                                    + \"ignore @ForceCompileClassInitializer annotations.\");\n@@ -510,1 +512,2 @@\n-                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class), \"Found @IR annotation on non-@Test method \" + m);\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class) && !m.isAnnotationPresent(IRs.class),\n+                                            \"Found @IR annotation on non-@Test method \" + m);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -165,1 +165,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -326,1 +326,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -477,1 +477,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -633,1 +633,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.IRNode;\n+\n+public class InlineTypeIRNode {\n+    private static final String PREFIX = \"_#\";\n+    private static final String POSTFIX = \"#I_\";\n+    public static final String ALLOC_G = PREFIX + \"ALLOC_G\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOC_G, InlineTypeRegexes.ALLOC_G);\n+    }\n+\n+    public static final String ALLOCA_G = PREFIX + \"ALLOCA_G\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOCA_G, InlineTypeRegexes.ALLOCA_G);\n+    }\n+\n+    public static final String MYVALUE_ARRAY_KLASS = PREFIX + \"MYVALUE_ARRAY_KLASS\" + POSTFIX;    static {\n+        IRNode.optoOnly(MYVALUE_ARRAY_KLASS, InlineTypeRegexes.MYVALUE_ARRAY_KLASS);\n+    }\n+\n+    public static final String ALLOC = PREFIX + \"ALLOC\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOC, InlineTypeRegexes.ALLOC);\n+    }\n+\n+    public static final String ALLOCA = PREFIX + \"ALLOCA\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOCA, InlineTypeRegexes.ALLOCA);\n+    }\n+\n+    public static final String LOAD = PREFIX + \"LOAD\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOAD, InlineTypeRegexes.LOAD);\n+    }\n+\n+    public static final String LOADK = PREFIX + \"LOADK\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOADK, InlineTypeRegexes.LOADK);\n+    }\n+\n+    public static final String STORE = PREFIX + \"STORE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(STORE, InlineTypeRegexes.STORE);\n+    }\n+\n+    public static final String LOOP = PREFIX + \"LOOP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOOP, InlineTypeRegexes.LOOP);\n+    }\n+\n+    public static final String COUNTEDLOOP = PREFIX + \"COUNTEDLOOP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(COUNTEDLOOP, InlineTypeRegexes.COUNTEDLOOP);\n+    }\n+\n+    public static final String COUNTEDLOOP_MAIN = PREFIX + \"COUNTEDLOOP_MAIN\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(COUNTEDLOOP_MAIN, InlineTypeRegexes.COUNTEDLOOP_MAIN);\n+    }\n+\n+    public static final String TRAP = PREFIX + \"TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(TRAP, InlineTypeRegexes.TRAP);\n+    }\n+\n+    public static final String LINKTOSTATIC = PREFIX + \"LINKTOSTATIC\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LINKTOSTATIC, InlineTypeRegexes.LINKTOSTATIC);\n+    }\n+\n+    public static final String NPE = PREFIX + \"NPE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(NPE, InlineTypeRegexes.NPE);\n+    }\n+\n+    public static final String CALL = PREFIX + \"CALL\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CALL, InlineTypeRegexes.CALL);\n+    }\n+\n+    public static final String CALL_LEAF = PREFIX + \"CALL_LEAF\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CALL_LEAF, InlineTypeRegexes.CALL_LEAF);\n+    }\n+\n+    public static final String CALL_LEAF_NOFP = PREFIX + \"CALL_LEAF_NOFP\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CALL_LEAF_NOFP, InlineTypeRegexes.CALL_LEAF_NOFP);\n+    }\n+\n+    public static final String CALL_UNSAFE = PREFIX + \"CALL_UNSAFE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CALL_UNSAFE, InlineTypeRegexes.CALL_UNSAFE);\n+    }\n+\n+    public static final String STORE_INLINE_FIELDS = PREFIX + \"STORE_INLINE_FIELDS\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(STORE_INLINE_FIELDS, InlineTypeRegexes.STORE_INLINE_FIELDS);\n+    }\n+\n+    public static final String SCOBJ = PREFIX + \"SCOBJ\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(SCOBJ, InlineTypeRegexes.SCOBJ);\n+    }\n+\n+    public static final String LOAD_UNKNOWN_INLINE = PREFIX + \"LOAD_UNKNOWN_INLINE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOAD_UNKNOWN_INLINE, InlineTypeRegexes.LOAD_UNKNOWN_INLINE);\n+    }\n+\n+    public static final String STORE_UNKNOWN_INLINE = PREFIX + \"STORE_UNKNOWN_INLINE\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(STORE_UNKNOWN_INLINE, InlineTypeRegexes.STORE_UNKNOWN_INLINE);\n+    }\n+\n+    public static final String INLINE_ARRAY_NULL_GUARD = PREFIX + \"INLINE_ARRAY_NULL_GUARD\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(INLINE_ARRAY_NULL_GUARD, InlineTypeRegexes.INLINE_ARRAY_NULL_GUARD);\n+    }\n+\n+    public static final String INTRINSIC_SLOW_PATH = PREFIX + \"INTRINSIC_SLOW_PATH\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(INTRINSIC_SLOW_PATH, InlineTypeRegexes.INTRINSIC_SLOW_PATH);\n+    }\n+\n+    public static final String CLONE_INTRINSIC_SLOW_PATH = PREFIX + \"CLONE_INTRINSIC_SLOW_PATH\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CLONE_INTRINSIC_SLOW_PATH, InlineTypeRegexes.CLONE_INTRINSIC_SLOW_PATH);\n+    }\n+\n+    public static final String CLASS_CHECK_TRAP = PREFIX + \"CLASS_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CLASS_CHECK_TRAP, InlineTypeRegexes.CLASS_CHECK_TRAP);\n+    }\n+\n+    public static final String NULL_CHECK_TRAP = PREFIX + \"NULL_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(NULL_CHECK_TRAP, InlineTypeRegexes.NULL_CHECK_TRAP);\n+    }\n+\n+    public static final String NULL_ASSERT_TRAP = PREFIX + \"NULL_ASSERT_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(NULL_ASSERT_TRAP, InlineTypeRegexes.NULL_ASSERT_TRAP);\n+    }\n+\n+    public static final String RANGE_CHECK_TRAP = PREFIX + \"RANGE_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(RANGE_CHECK_TRAP, InlineTypeRegexes.RANGE_CHECK_TRAP);\n+    }\n+\n+    public static final String UNHANDLED_TRAP = PREFIX + \"UNHANDLED_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(UNHANDLED_TRAP, InlineTypeRegexes.UNHANDLED_TRAP);\n+    }\n+\n+    public static final String PREDICATE_TRAP = PREFIX + \"PREDICATE_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(PREDICATE_TRAP, InlineTypeRegexes.PREDICATE_TRAP);\n+    }\n+\n+    public static final String MEMBAR = PREFIX + \"MEMBAR\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(MEMBAR, InlineTypeRegexes.MEMBAR);\n+    }\n+\n+    public static final String CHECKCAST_ARRAY = PREFIX + \"CHECKCAST_ARRAY\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CHECKCAST_ARRAY, InlineTypeRegexes.CHECKCAST_ARRAY);\n+    }\n+\n+    public static final String CHECKCAST_ARRAYCOPY = PREFIX + \"CHECKCAST_ARRAYCOPY\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CHECKCAST_ARRAYCOPY, InlineTypeRegexes.CHECKCAST_ARRAYCOPY);\n+    }\n+\n+    public static final String JLONG_ARRAYCOPY = PREFIX + \"JLONG_ARRAYCOPY\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(JLONG_ARRAYCOPY, InlineTypeRegexes.JLONG_ARRAYCOPY);\n+    }\n+\n+    public static final String FIELD_ACCESS = PREFIX + \"FIELD_ACCESS\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(FIELD_ACCESS, InlineTypeRegexes.FIELD_ACCESS);\n+    }\n+\n+    public static final String SUBSTITUTABILITY_TEST = PREFIX + \"SUBSTITUTABILITY_TEST\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(SUBSTITUTABILITY_TEST, InlineTypeRegexes.SUBSTITUTABILITY_TEST);\n+    }\n+\n+    public static final String CMPP = PREFIX + \"CMPP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CMPP, InlineTypeRegexes.CMPP);\n+    }\n+\n+    \/\/ Dummy method to call to force the static initializer blocks to be run before starting the IR framework.\n+    public static void forceStaticInitialization() {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+public class InlineTypeRegexes {\n+    \/\/ Regular expressions used to match nodes in the PrintIdeal output\n+    private static final String START = \"(\\\\d+ (.*\";\n+    private static final String MID = \".*)+ ===.*\";\n+    private static final String END = \")\";\n+    \/\/ Generic allocation\n+    public static final String ALLOC_G = \"(.*call,static.*wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOCA_G = \"(.*call,static.*wrapper for: _new_array_Java\" + END;\n+    \/\/ Inline type allocation\n+    public static final String MYVALUE_ARRAY_KLASS = \"\\\\[(precise )?compiler\/valhalla\/inlinetypes\/MyValue\";\n+    public static final String ALLOC = \"(.*precise compiler\/valhalla\/inlinetypes\/MyValue.*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*_new_instance_Java\" + END;\n+    public static final String ALLOCA = \"(.*\" + MYVALUE_ARRAY_KLASS + \".*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*_new_array_Java\" + END;\n+    public static final String LOAD = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n+    public static final String LOADK = START + \"LoadK\" + MID + END;\n+    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n+    public static final String LOOP = START + \"Loop\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*(unstable_if|predicate)\" + END;\n+    public static final String LINKTOSTATIC = START + \"CallStaticJava\" + MID + \"linkToStatic\" + END;\n+    public static final String NPE = START + \"CallStaticJava\" + MID + \"null_check\" + END;\n+    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n+    public static final String CALL_LEAF = \"(CALL, runtime leaf|call_leaf,runtime)\";\n+    public static final String CALL_LEAF_NOFP = \"(CALL, runtime leaf nofp|call_leaf_nofp,runtime)\";\n+    protected static final String CALL_UNSAFE = START + \"CallStaticJava\" + MID + \"# Static  jdk.internal.misc.Unsafe::\" + END;\n+    public static final String STORE_INLINE_FIELDS = START + \"CallStaticJava\" + MID + \"store_inline_type_fields\" + END;\n+    public static final String SCOBJ = \"(.*# ScObj.*\" + END;\n+    public static final String LOAD_UNKNOWN_INLINE = START + \"CallStaticJava\" + MID + \"_load_unknown_inline\" + END;\n+    public static final String STORE_UNKNOWN_INLINE = \"(.*\" + CALL_LEAF + \".*store_unknown_inline.*\" + END;\n+    public static final String INLINE_ARRAY_NULL_GUARD = \"(.*call,static.*wrapper for: uncommon_trap.*reason='null_check' action='none'.*\" + END;\n+    public static final String INTRINSIC_SLOW_PATH = \"(.*call,static.*wrapper for: uncommon_trap.*reason='intrinsic_or_type_checked_inlining'.*\" + END;\n+    public static final String CLONE_INTRINSIC_SLOW_PATH = \"(.*call,static.*java.lang.Object::clone.*\" + END;\n+    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n+    public static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n+    public static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n+    public static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n+    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n+    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n+    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n+    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    public static final String CHECKCAST_ARRAYCOPY = \"(.*\" + CALL_LEAF_NOFP + \".*checkcast_arraycopy.*\" + END;\n+    public static final String JLONG_ARRAYCOPY = \"(.*\" + CALL_LEAF_NOFP + \".*jlong_disjoint_arraycopy.*\" + END;\n+    public static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n+    public static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.runtime.ValueObjectMethods::isSubstitutable\" + END;\n+    public static final String CMPP = START + \"(CmpP|CmpN)\" + MID + \"\" + END;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,1 @@\n+        InlineTypeIRNode.forceStaticInitialization();\n@@ -125,46 +126,0 @@\n-\n-    static class IRNode {\n-        \/\/ Regular expressions used to match nodes in the PrintIdeal output\n-        protected static final String START = \"(\\\\d+ (.*\";\n-        protected static final String MID = \".*)+ ===.*\";\n-        protected static final String END = \")\";\n-        \/\/ Generic allocation\n-        protected static final String ALLOC_G  = \"(.*call,static.*wrapper for: _new_instance_Java\" + END;\n-        protected static final String ALLOCA_G = \"(.*call,static.*wrapper for: _new_array_Java\" + END;\n-        \/\/ Inline type allocation\n-        protected static final String MYVALUE_ARRAY_KLASS = \"\\\\[(precise )?compiler\/valhalla\/inlinetypes\/MyValue\";\n-        protected static final String ALLOC  = \"(.*precise compiler\/valhalla\/inlinetypes\/MyValue.*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*_new_instance_Java\" + END;\n-        protected static final String ALLOCA = \"(.*\" + MYVALUE_ARRAY_KLASS + \".*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*_new_array_Java\" + END;\n-        protected static final String LOAD   = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n-        protected static final String LOADK  = START + \"LoadK\" + MID + END;\n-        protected static final String STORE  = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n-        protected static final String LOOP   = START + \"Loop\" + MID + \"\" + END;\n-        protected static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + \"\" + END;\n-        protected static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n-        protected static final String TRAP   = START + \"CallStaticJava\" + MID + \"uncommon_trap.*(unstable_if|predicate)\" + END;\n-        protected static final String LINKTOSTATIC = START + \"CallStaticJava\" + MID + \"linkToStatic\" + END;\n-        protected static final String NPE = START + \"CallStaticJava\" + MID + \"null_check\" + END;\n-        protected static final String CALL = START + \"CallStaticJava\" + MID + END;\n-        protected static final String CALL_LEAF = \"(CALL, runtime leaf|call_leaf,runtime)\";\n-        protected static final String CALL_LEAF_NOFP = \"(CALL, runtime leaf nofp|call_leaf_nofp,runtime)\";\n-        protected static final String STORE_INLINE_FIELDS = START + \"CallStaticJava\" + MID + \"store_inline_type_fields\" + END;\n-        protected static final String SCOBJ = \"(.*# ScObj.*\" + END;\n-        protected static final String LOAD_UNKNOWN_INLINE = START + \"CallStaticJava\" + MID + \"_load_unknown_inline\" + END;\n-        protected static final String STORE_UNKNOWN_INLINE = \"(.*\" + CALL_LEAF + \".*store_unknown_inline.*\" + END;\n-        protected static final String INLINE_ARRAY_NULL_GUARD = \"(.*call,static.*wrapper for: uncommon_trap.*reason='null_check' action='none'.*\" + END;\n-        protected static final String INTRINSIC_SLOW_PATH = \"(.*call,static.*wrapper for: uncommon_trap.*reason='intrinsic_or_type_checked_inlining'.*\" + END;\n-        protected static final String CLONE_INTRINSIC_SLOW_PATH = \"(.*call,static.*java.lang.Object::clone.*\" + END;\n-        protected static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n-        protected static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n-        protected static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n-        protected static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n-        protected static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n-        protected static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n-        protected static final String MEMBAR = START + \"MemBar\" + MID + END;\n-        protected static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n-        protected static final String CHECKCAST_ARRAYCOPY = \"(.*\" + CALL_LEAF_NOFP + \".*checkcast_arraycopy.*\" + END;\n-        protected static final String JLONG_ARRAYCOPY = \"(.*\" + CALL_LEAF_NOFP + \".*jlong_disjoint_arraycopy.*\" + END;\n-        protected static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n-        protected static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.runtime.ValueObjectMethods::isSubstitutable\" + END;\n-        protected static final String CMPP = START + \"(CmpP|CmpN)\" + MID + \"\" + END;\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":2,"deletions":47,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n@@ -2714,1 +2714,1 @@\n-    @IR(counts = {INTRINSIC_SLOW_PATH + \"|\" + CLASS_CHECK_TRAP, \" = 1\"})\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n@@ -2727,1 +2727,1 @@\n-    @IR(counts = {INTRINSIC_SLOW_PATH + \"|\" + CLASS_CHECK_TRAP, \" = 1\"})\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n@@ -2788,1 +2788,1 @@\n-    @IR(counts = {INTRINSIC_SLOW_PATH + \"|\" + CLASS_CHECK_TRAP, \" = 1\"})\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n@@ -2800,1 +2800,1 @@\n-    @IR(counts = {INTRINSIC_SLOW_PATH + \"|\" + CLASS_CHECK_TRAP, \" = 1\"})\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    version 64:0\n+    version 65:0\n@@ -80,1 +80,1 @@\n-    version 64:0\n+    version 65:0\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBufferingClasses.jasm","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n@@ -392,2 +392,0 @@\n-    protected static final String CALL_Unsafe = START + \"CallStaticJava\" + MID + \"# Static  jdk.internal.misc.Unsafe::\" + END;\n-\n@@ -395,1 +393,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -409,1 +407,1 @@\n-    @IR(failOn = {CALL_Unsafe, ALLOC})\n+    @IR(failOn = {CALL_UNSAFE, ALLOC})\n@@ -425,1 +423,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -440,1 +438,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -504,1 +502,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -521,1 +519,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -539,1 +537,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -570,1 +568,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -600,1 +598,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -617,1 +615,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -648,1 +646,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -667,1 +665,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -687,1 +685,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -705,1 +703,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -723,1 +721,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -743,1 +741,1 @@\n-    @IR(counts = {CALL_Unsafe, \"= 1\"})\n+    @IR(counts = {CALL_UNSAFE, \"= 1\"})\n@@ -761,1 +759,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -1108,1 +1106,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -1463,1 +1461,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -1487,1 +1485,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -1514,1 +1512,1 @@\n-    @IR(failOn = {CALL_Unsafe})\n+    @IR(failOn = {CALL_UNSAFE})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n@@ -36,1 +33,1 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    version 64:0\n+    version 65:0\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1Classes.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.io.File;\n@@ -129,6 +130,2 @@\n-        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-        if (hs_err_file == null) {\n-            output.reportDiagnosticSummary();\n-            throw new RuntimeException(\"Did not find hs_err_pid file in output\");\n-        }\n-        Path hsErrPath = Paths.get(hs_err_file);\n+        File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output);\n+        Path hsErrPath = hs_err_file.toPath();\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTypeCheck.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    version 64:0\n+    version 65:0\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullabilityClasses.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-super public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClass version 64:0 {\n+super public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClass version 65:0 {\n@@ -45,1 +45,1 @@\n-super public final class runtime\/valhalla\/inlinetypes\/MyValue version 64:0 {\n+super public final class runtime\/valhalla\/inlinetypes\/MyValue version 65:0 {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClasses.jasm","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadClient1.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    version 64:0\n+    version 65:0\n@@ -109,1 +109,1 @@\n-    version 64:0\n+    version 65:0\n@@ -152,1 +152,1 @@\n-    version 64:0\n+    version 65:0\n@@ -194,1 +194,1 @@\n-    version 64:0\n+    version 65:0\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTestClasses.jasm","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    version 64:0\n+    version 65:0\n@@ -107,1 +107,1 @@\n-    version 64:0\n+    version 65:0\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldTestClasses.jasm","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -184,1 +184,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -326,1 +326,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -468,1 +468,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCCFETests.jcod","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -194,1 +194,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCICCETests.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -123,1 +123,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -214,1 +214,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -307,1 +307,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -398,1 +398,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -492,1 +492,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/PrimitiveUsers.jcod","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -207,1 +207,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -363,1 +363,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -519,1 +519,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -626,1 +626,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -881,1 +881,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -901,1 +901,1 @@\n-    Utf8 \"makeCirc\"; \/\/ #18     at 0x64\n+    Utf8 \"makeCirc\"; \/\/ #18     at 0x65\n@@ -1160,1 +1160,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1474,1 +1474,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1752,1 +1752,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -2039,1 +2039,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -2500,1 +2500,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -89,1 +89,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -150,1 +150,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -211,1 +211,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -275,1 +275,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -338,1 +338,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -404,1 +404,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -476,1 +476,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -551,1 +551,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -623,1 +623,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -711,1 +711,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -774,1 +774,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/ClassesWithInvalidModifiers.jcod","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -302,1 +302,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -562,1 +562,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -821,1 +821,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1082,1 +1082,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1342,1 +1342,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1602,1 +1602,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1862,1 +1862,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -2121,1 +2121,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -2382,1 +2382,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/InlineClassWithBadSupers.jcod","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -265,1 +265,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -366,1 +366,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -457,1 +457,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -547,1 +547,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -739,1 +739,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -830,1 +830,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1054,1 +1054,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1236,1 +1236,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -187,1 +187,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -344,1 +344,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -485,1 +485,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -613,1 +613,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -718,1 +718,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -807,1 +807,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -896,1 +896,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n@@ -1022,1 +1022,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/withfieldTests\/withfieldTests.jcod","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    :jdk_vector_sanity \\\n@@ -79,0 +80,1 @@\n+   -:jdk_vector_sanity \\\n@@ -373,0 +375,25 @@\n+jdk_vector_sanity = \\\n+    jdk\/incubator\/vector\/AddTest.java \\\n+    jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java \\\n+    jdk\/incubator\/vector\/ByteMaxVectorTests.java \\\n+    jdk\/incubator\/vector\/CovarOverrideTest.java \\\n+    jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java \\\n+    jdk\/incubator\/vector\/DoubleMaxVectorTests.java \\\n+    jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java \\\n+    jdk\/incubator\/vector\/FloatMaxVectorTests.java \\\n+    jdk\/incubator\/vector\/ImageTest.java \\\n+    jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java \\\n+    jdk\/incubator\/vector\/IntMaxVectorTests.java \\\n+    jdk\/incubator\/vector\/LoadJsvmlTest.java \\\n+    jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java \\\n+    jdk\/incubator\/vector\/LongMaxVectorTests.java \\\n+    jdk\/incubator\/vector\/MethodOverideTest.java \\\n+    jdk\/incubator\/vector\/MismatchTest.java \\\n+    jdk\/incubator\/vector\/PreferredSpeciesTest.java \\\n+    jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java \\\n+    jdk\/incubator\/vector\/ShortMaxVectorTests.java \\\n+    jdk\/incubator\/vector\/VectorHash.java \\\n+    jdk\/incubator\/vector\/VectorMaxConversionTests.java \\\n+    jdk\/incubator\/vector\/VectorReshapeTests.java \\\n+    jdk\/incubator\/vector\/VectorRuns.java\n+\n","filename":"test\/jdk\/TEST.groups","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-                    .withMajorVersion(64)\n+                    .withMajorVersion(65)\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  64; \/\/ version\n+  65; \/\/ version\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/ValueImpl.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670 8291734\n+ * @bug 8266670 8291734 8296743\n@@ -103,4 +103,3 @@\n-        var mustBePresent = Set.of(AccessFlag.PUBLIC, AccessFlag.FINAL);\n-        var mustBeAbsent = Set.of(AccessFlag.PRIVATE,\n-                                  AccessFlag.PROTECTED,\n-                                  AccessFlag.INTERFACE);\n+        var expected = Set.of(AccessFlag.PUBLIC,\n+                              AccessFlag.FINAL,\n+                              AccessFlag.ABSTRACT);\n@@ -109,10 +108,2 @@\n-            \/\/ PUBLIC must be present, PROTECTED and PRIVATE must be\n-            \/\/ absent.\n-            \/\/ FINAL must be present, INTERFACE must be absent.\n-            if (!accessFlags.containsAll(mustBePresent)) {\n-                throw new RuntimeException(\"Missing mandatory flags on \" +\n-                                           primClass);\n-            }\n-\n-            if (containsAny(accessFlags, mustBeAbsent)) {\n-                throw new RuntimeException(\"Unexpected flags present on \" +\n+            if (!accessFlags.equals(expected)) {\n+                throw new RuntimeException(\"Unexpected flags on \" +\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130 8282714 8289647\n+ * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130 8282714 8289647 8294020\n@@ -152,1 +152,1 @@\n-        assertFail(\"compiler.err.record.header.expected\", \"record R { }\");\n+        assertFail(\"compiler.err.expected\", \"record R { }\");\n@@ -1569,0 +1569,51 @@\n+    \/\/ JDK-8292159: TYPE_USE annotations on generic type arguments\n+    \/\/              of record components discarded\n+    public void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n+        String code =\n+                \"\"\"\n+                import java.lang.annotation.*;\n+                import java.util.List;\n+                @Target({ElementType.TYPE_USE})\n+                @Retention(RetentionPolicy.RUNTIME)\n+                @interface Anno { }\n+                record R(List<@Anno String> s) {}\n+                \"\"\";\n+\n+        File dir = assertOK(true, code);\n+\n+        ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n+\n+        \/\/ field first\n+        Assert.check(classFile.fields.length == 1);\n+        Field field = classFile.fields[0];\n+        checkTypeAnno(\n+                classFile,\n+                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                \"FIELD\",\n+                \"Anno\");\n+\n+        \/\/ checking for the annotation on the corresponding parameter of the canonical constructor\n+        Method init = findMethodOrFail(classFile, \"<init>\");\n+        checkTypeAnno(\n+                classFile,\n+                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                \"METHOD_FORMAL_PARAMETER\", \"Anno\");\n+\n+        \/\/ checking for the annotation in the accessor\n+        Method accessor = findMethodOrFail(classFile, \"s\");\n+        checkTypeAnno(\n+                classFile,\n+                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                \"METHOD_RETURN\", \"Anno\");\n+\n+        \/\/ checking for the annotation in the Record attribute\n+        Record_attribute record = (Record_attribute) findAttributeOrFail(classFile.attributes, Record_attribute.class);\n+        Assert.check(record.component_count == 1);\n+        checkTypeAnno(\n+                classFile,\n+                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(\n+                            record.component_info_arr[0].attributes,\n+                                RuntimeVisibleTypeAnnotations_attribute.class),\n+                        \"FIELD\", \"Anno\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+  public native void forceClassLoaderStatsSafepoint();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}