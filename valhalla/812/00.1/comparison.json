{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=valhalla\n@@ -7,5 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+error=author,committer,executable,symlink,whitespace\n@@ -21,7 +17,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n@@ -30,6 +19,0 @@\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-JAVADOC_OPTIONS := -use -keywords -notimestamp \\\n+JAVADOC_OPTIONS := -XDignore.symbol.file=true -use -keywords -notimestamp \\\n@@ -113,0 +113,1 @@\n+    -XDenableValueTypes \\\n","filename":"make\/Docs.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1423,0 +1423,1 @@\n+        args = concat(args, \"--with-version-pre=\" + version_numbers.get(\"DEFAULT_PROMOTED_VERSION_PRE\"));\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=lworld4ea\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+JVM_IsIdentityClass\n@@ -159,0 +160,1 @@\n+JVM_IsValhallaEnabled\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1648,0 +1648,3 @@\n+  } else if (_entry_point == NULL) {\n+    \/\/ See CallLeafNoFPIndirect\n+    return 1 * NativeInstruction::instruction_size;\n@@ -1759,3 +1762,0 @@\n-  \/\/ n.b. frame size includes space for return pc and rfp\n-  const int framesize = C->output()->frame_size_in_bytes();\n-\n@@ -1766,4 +1766,1 @@\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n+  __ verified_entry(C, 0);\n@@ -1771,8 +1768,2 @@\n-    __ mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n-    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-    __ bind(L_skip_barrier);\n-  }\n-\n-  if (C->max_vector_size() > 0) {\n-    __ reinitialize_ptrue();\n+  if (C->stub_function() == NULL) {\n+    __ entry_barrier();\n@@ -1781,26 +1772,2 @@\n-  int bangsize = C->output()->bang_size_in_bytes();\n-  if (C->output()->need_stack_bang(bangsize))\n-    __ generate_stack_overflow_check(bangsize);\n-\n-  __ build_frame(framesize);\n-\n-  if (C->stub_function() == NULL) {\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n-      \/\/ Dummy labels for just measuring the code size\n-      Label dummy_slow_path;\n-      Label dummy_continuation;\n-      Label dummy_guard;\n-      Label* slow_path = &dummy_slow_path;\n-      Label* continuation = &dummy_continuation;\n-      Label* guard = &dummy_guard;\n-      if (!Compile::current()->output()->in_scratch_emit_size()) {\n-        \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n-        continuation = &stub->continuation();\n-        guard = &stub->guard();\n-      }\n-      \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n-      bs->nmethod_entry_barrier(&_masm, slow_path, continuation, guard);\n-    }\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    __ bind(*_verified_entry);\n@@ -1823,6 +1790,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -1872,1 +1833,1 @@\n-  __ remove_frame(framesize);\n+  __ remove_frame(framesize, C->needs_stack_repair());\n@@ -1889,5 +1850,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {\n-  \/\/ Variable size. Determine dynamically.\n-  return MachNode::size(ra_);\n-}\n-\n@@ -2199,1 +2155,49 @@\n-\/\/=============================================================================\n+\/\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"# MachVEPNode\");\n+  if (!_verified) {\n+    st->print_cr(\"\\t load_class\");\n+  } else {\n+    st->print_cr(\"\\t unpack_inline_arg\");\n+  }\n+}\n+#endif\n+\n+void MachVEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+{\n+  C2_MacroAssembler _masm(&cbuf);\n+\n+  if (!_verified) {\n+    Label skip;\n+    __ cmp_klass(j_rarg0, rscratch2, rscratch1);\n+    __ br(Assembler::EQ, skip);\n+      __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+    __ bind(skip);\n+\n+  } else {\n+    \/\/ insert a nop at the start of the prolog so we can patch in a\n+    \/\/ branch if we need to invalidate the method later\n+    __ nop();\n+\n+    \/\/ TODO 8284443 Avoid creation of temporary frame\n+    if (ra_->C->stub_function() == NULL) {\n+      __ verified_entry(ra_->C, 0);\n+      __ entry_barrier();\n+      int framesize = ra_->C->output()->frame_slots() << LogBytesPerInt;\n+      __ remove_frame(framesize, false);\n+    }\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    if (Compile::current()->output()->in_scratch_emit_size()) {\n+      Label dummy_verified_entry;\n+      __ b(dummy_verified_entry);\n+    } else {\n+      __ b(*_verified_entry);\n+    }\n+  }\n+}\n@@ -2201,0 +2205,1 @@\n+\/\/=============================================================================\n@@ -2222,0 +2227,1 @@\n+  Label skip;\n@@ -2223,0 +2229,1 @@\n+  \/\/ UseCompressedClassPointers logic are inside cmp_klass\n@@ -2224,1 +2231,1 @@\n-  Label skip;\n+\n@@ -2232,5 +2239,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_);\n-}\n-\n@@ -3691,0 +3693,33 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+        uint con = (tf()->range_cc()->cnt() - 1);\n+        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = fast_out(i)->as_Proj();\n+          if (proj->_con == con) {\n+            \/\/ Set IsInit if r0 is non-null (a non-null value is returned buffered or scalarized)\n+            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+            __ cmp(r0, zr);\n+            __ cset(toReg, Assembler::NE);\n+            if (reg->is_stack()) {\n+              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+              __ str(toReg, Address(sp, st_off));\n+            }\n+            break;\n+          }\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ r0 &= (r0 & 1) - 1\n+        __ andr(rscratch1, r0, 0x1);\n+        __ sub(rscratch1, rscratch1, 0x1);\n+        __ andr(r0, r0, rscratch1);\n+      }\n+    }\n@@ -3785,0 +3820,5 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        __ andr(tmp, tmp, ~((int) markWord::inline_type_bit_in_place));\n+      }\n+\n@@ -7258,1 +7298,1 @@\n-    \"mov  $dst, $con\\t# ptr\\n\\t\"\n+    \"mov  $dst, $con\\t# ptr\"\n@@ -8459,0 +8499,15 @@\n+instruct castN2X(iRegLNoSp dst, iRegN src) %{\n+  match(Set dst (CastP2X src));\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"mov $dst, $src\\t# ptr -> long\" %}\n+\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ mov(as_Register($dst$$reg), as_Register($src$$reg));\n+    }\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -14935,1 +14990,1 @@\n-instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)\n+instruct clearArray_reg_reg_immL0(iRegL_R11 cnt, iRegP_R10 base, immL0 zero, Universe dummy, rFlagsReg cr)\n@@ -14937,1 +14992,1 @@\n-  match(Set dummy (ClearArray cnt base));\n+  match(Set dummy (ClearArray (Binary cnt base) zero));\n@@ -14954,0 +15009,16 @@\n+instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, iRegL val, Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->word_copy_only());\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, KILL cr);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ClearArray $cnt, $base, $val\" %}\n+\n+  ins_encode %{\n+    __ fill_words($base$$Register, $cnt$$Register, $val$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -14957,1 +15028,2 @@\n-            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord));\n+            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord)\n+            && !((ClearArrayNode*)n)->word_copy_only());\n@@ -16291,0 +16363,18 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPIndirect(iRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == NULL);\n+\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf nofp indirect $target\" %}\n+\n+  ins_encode %{\n+    __ blr($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -16293,0 +16383,2 @@\n+  predicate(n->as_Call()->entry_point() != NULL);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":156,"deletions":64,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -154,0 +154,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  intptr_t* repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"vmreg_aarch64.inline.hpp\"\n@@ -1115,0 +1118,35 @@\n+void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_default_value_oop from non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  Register offset = temp_reg;\n+  \/\/ Getting the offset of the pre-allocated default value\n+  ldr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n+  ldr(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));\n+\n+  \/\/ Getting the mirror\n+  ldr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n+  resolve_oop_handle(obj, inline_klass, temp_reg);\n+\n+  \/\/ Getting the pre-allocated default value from the mirror\n+  Address field(obj, offset);\n+  load_heap_oop(obj, field, temp_reg, rscratch2);\n+}\n+\n+void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_empty_value from non-empty inline klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  get_default_value_oop(inline_klass, temp_reg, obj);\n+}\n+\n@@ -1465,1 +1503,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -1498,1 +1540,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -1580,0 +1626,1 @@\n+  assert_different_registers(arg_1, c_rarg0);\n@@ -1587,0 +1634,2 @@\n+  assert_different_registers(arg_1, c_rarg0);\n+  assert_different_registers(arg_2, c_rarg0, c_rarg1);\n@@ -1593,0 +1642,4 @@\n+void MacroAssembler::super_call_VM_leaf(address entry_point) {\n+  MacroAssembler::call_VM_leaf_base(entry_point, 1);\n+}\n+\n@@ -1642,0 +1695,110 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  assert_different_registers(markword, rscratch2);\n+  andr(markword, markword, markWord::inline_type_mask_in_place);\n+  mov(rscratch2, markWord::inline_type_pattern);\n+  cmp(markword, rscratch2);\n+  br(Assembler::EQ, is_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n+  ldrw(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  andr(temp_reg, temp_reg, JVM_ACC_VALUE);\n+  cbnz(temp_reg, is_inline_type);\n+}\n+\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+  assert_different_registers(tmp, rscratch1);\n+  cbz(object, not_inline_type);\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  ldr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  mov(rscratch1, is_inline_type_mask);\n+  andr(tmp, tmp, rscratch1);\n+  cmp(tmp, rscratch1);\n+  br(Assembler::NE, not_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(klass, temp_reg, done_check);\n+    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  ldrw(temp_reg, Address(klass, InstanceKlass::misc_status_offset()));\n+  andr(temp_reg, temp_reg, InstanceKlassMiscStatus::is_empty_inline_type_value());\n+  cbnz(temp_reg, is_empty_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ConstantPoolCacheEntry::is_null_free_inline_type_shift, is_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbz(flags, ConstantPoolCacheEntry::is_null_free_inline_type_shift, not_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label& is_flattened) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ConstantPoolCacheEntry::is_inlined_shift, is_flattened);\n+}\n+\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  ldr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  tst(temp_reg, markWord::unlocked_value);\n+  br(Assembler::NE, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  load_prototype_header(temp_reg, oop);\n+\n+  bind(test_mark_word);\n+  andr(temp_reg, temp_reg, test_bit);\n+  if (jmp_set) {\n+    cbnz(temp_reg, jmp_label);\n+  } else {\n+    cbz(temp_reg, jmp_label);\n+  }\n+}\n+\n+void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg, Label& is_flattened_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+}\n+\n+void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,\n+                                                  Label&is_non_flattened_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n+}\n+\n+void MacroAssembler::test_flattened_array_layout(Register lh, Label& is_flattened_array) {\n+  tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  br(Assembler::NE, is_flattened_array);\n+}\n+\n+void MacroAssembler::test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array) {\n+  tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  br(Assembler::EQ, is_non_flattened_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_layout(Register lh, Label& is_null_free_array) {\n+  tst(lh, Klass::_lh_null_free_array_bit_inplace);\n+  br(Assembler::NE, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array) {\n+  tst(lh, Klass::_lh_null_free_array_bit_inplace);\n+  br(Assembler::EQ, is_non_null_free_array);\n+}\n+\n@@ -4030,0 +4193,8 @@\n+void MacroAssembler::load_metadata(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -4088,0 +4259,5 @@\n+void MacroAssembler::load_prototype_header(Register dst, Register src) {\n+  load_klass(dst, src);\n+  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n+}\n+\n@@ -4412,0 +4588,40 @@\n+void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,\n+                                       Register inline_klass) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->value_copy(this, decorators, src, dst, inline_klass);\n+}\n+\n+void MacroAssembler::first_field_offset(Register inline_klass, Register offset) {\n+  ldr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+  ldrw(offset, Address(offset, InlineKlass::first_field_offset_offset()));\n+}\n+\n+void MacroAssembler::data_for_oop(Register oop, Register data, Register inline_klass) {\n+  \/\/ ((address) (void*) o) + vk->first_field_offset();\n+  Register offset = (data == oop) ? rscratch1 : data;\n+  first_field_offset(inline_klass, offset);\n+  if (data == oop) {\n+    add(data, data, offset);\n+  } else {\n+    lea(data, Address(oop, offset));\n+  }\n+}\n+\n+void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,\n+                                                Register index, Register data) {\n+  assert_different_registers(array, array_klass, index);\n+  assert_different_registers(rscratch1, array, index);\n+\n+  \/\/ array->base() + (index << Klass::layout_helper_log2_element_size(lh));\n+  ldrw(rscratch1, Address(array_klass, Klass::layout_helper_offset()));\n+\n+  \/\/ Klass::layout_helper_log2_element_size(lh)\n+  \/\/ (lh >> _lh_log2_element_size_shift) & _lh_log2_element_size_mask;\n+  lsr(rscratch1, rscratch1, Klass::_lh_log2_element_size_shift);\n+  andr(rscratch1, rscratch1, Klass::_lh_log2_element_size_mask);\n+  lslv(index, index, rscratch1);\n+\n+  add(data, array, index);\n+  add(data, data, arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT));\n+}\n+\n@@ -4488,0 +4704,96 @@\n+\/\/ Object \/ value buffer allocation...\n+void MacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                       Register t1, Register t2,\n+                                       bool clear_fields, Label& alloc_failed)\n+{\n+  Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;\n+  Register layout_size = t1;\n+  assert(new_obj == r0, \"needs to be r0\");\n+  assert_different_registers(klass, new_obj, t1, t2);\n+\n+  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n+  ldrw(layout_size, Address(klass, Klass::layout_helper_offset()));\n+  \/\/ test to see if it has a finalizer or is malformed in some way\n+  tst(layout_size, Klass::_lh_instance_slow_path_bit);\n+  br(Assembler::NE, slow_case_no_pop);\n+\n+  \/\/ Allocate the instance:\n+  \/\/  If TLAB is enabled:\n+  \/\/    Try to allocate in the TLAB.\n+  \/\/    If fails, go to the slow path.\n+  \/\/    Initialize the allocation.\n+  \/\/    Exit.\n+  \/\/\n+  \/\/  Go to slow path.\n+\n+  if (UseTLAB) {\n+    push(klass);\n+    tlab_allocate(new_obj, layout_size, 0, klass, t2, slow_case);\n+    if (ZeroTLAB || (!clear_fields)) {\n+      \/\/ the fields have been already cleared\n+      b(initialize_header);\n+    } else {\n+      \/\/ initialize both the header and fields\n+      b(initialize_object);\n+    }\n+\n+    if (clear_fields) {\n+      \/\/ The object is initialized before the header.  If the object size is\n+      \/\/ zero, go directly to the header initialization.\n+      bind(initialize_object);\n+      subs(layout_size, layout_size, sizeof(oopDesc));\n+      br(Assembler::EQ, initialize_header);\n+\n+      \/\/ Initialize topmost object field, divide size by 8, check if odd and\n+      \/\/ test if zero.\n+\n+  #ifdef ASSERT\n+      \/\/ make sure instance_size was multiple of 8\n+      Label L;\n+      tst(layout_size, 7);\n+      br(Assembler::EQ, L);\n+      stop(\"object size is not multiple of 8 - adjust this code\");\n+      bind(L);\n+      \/\/ must be > 0, no extra check needed here\n+  #endif\n+\n+      lsr(layout_size, layout_size, LogBytesPerLong);\n+\n+      \/\/ initialize remaining object fields: instance_size was a multiple of 8\n+      {\n+        Label loop;\n+        Register base = t2;\n+\n+        bind(loop);\n+        add(rscratch1, new_obj, layout_size, Assembler::LSL, LogBytesPerLong);\n+        str(zr, Address(rscratch1, sizeof(oopDesc) - 1*oopSize));\n+        subs(layout_size, layout_size, 1);\n+        br(Assembler::NE, loop);\n+      }\n+    } \/\/ clear_fields\n+\n+    \/\/ initialize object header only.\n+    bind(initialize_header);\n+    pop(klass);\n+    Register mark_word = t2;\n+    ldr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+    str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes ()));\n+    store_klass_gap(new_obj, zr);  \/\/ zero klass gap for compressed oops\n+    mov(t2, klass);         \/\/ preserve klass\n+    store_klass(new_obj, t2);  \/\/ src klass reg is potentially compressed\n+\n+    \/\/ TODO: Valhalla removed SharedRuntime::dtrace_object_alloc from here ?\n+\n+    b(done);\n+  }\n+\n+  if (UseTLAB) {\n+    bind(slow_case);\n+    pop(klass);\n+  }\n+  bind(slow_case_no_pop);\n+  b(alloc_failed);\n+\n+  bind(done);\n+}\n+\n@@ -4527,0 +4839,13 @@\n+void MacroAssembler::get_inline_type_field_klass(Register klass, Register index, Register inline_klass) {\n+  ldr(inline_klass, Address(klass, InstanceKlass::inline_type_field_klasses_offset()));\n+#ifdef ASSERT\n+  {\n+    Label done;\n+    cbnz(inline_klass, done);\n+    stop(\"get_inline_type_field_klass contains no inline klass\");\n+    bind(done);\n+  }\n+#endif\n+  ldr(inline_klass, Address(inline_klass, index, Address::lsl(3)));\n+}\n+\n@@ -4652,0 +4977,51 @@\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair) {\n+  if (needs_stack_repair) {\n+    \/\/ Remove the extension of the caller's frame used for inline type unpacking\n+    \/\/\n+    \/\/ Right now the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP\n+    \/\/ | Saved LR #1               |\n+    \/\/ | Saved FP #1               |\n+    \/\/ |---------------------------|\n+    \/\/ | Extension space for       |\n+    \/\/ |   inline arg (un)packing  |\n+    \/\/ |---------------------------|  <-- start of this method's frame\n+    \/\/ | Saved LR #2               |\n+    \/\/ | Saved FP #2               |\n+    \/\/ |---------------------------|  <-- FP\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n+    \/\/\n+    \/\/ There are two copies of FP and LR on the stack. They will be identical\n+    \/\/ unless the caller has been deoptimized, in which case LR #1 will be patched\n+    \/\/ to point at the deopt blob, and LR #2 will still point into the old method.\n+    \/\/\n+    \/\/ The sp_inc stack slot holds the total size of the frame including the\n+    \/\/ extension space minus two words for the saved FP and LR.\n+\n+    int sp_inc_offset = initial_framesize - 3 * wordSize;  \/\/ Immediately below saved LR and FP\n+\n+    ldr(rscratch1, Address(sp, sp_inc_offset));\n+    add(sp, sp, rscratch1);\n+    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  } else {\n+    remove_frame(initial_framesize);\n+  }\n+}\n+\n+void MacroAssembler::save_stack_increment(int sp_inc, int frame_size) {\n+  int real_frame_size = frame_size + sp_inc;\n+  assert(sp_inc == 0 || sp_inc > 2*wordSize, \"invalid sp_inc value\");\n+  assert(real_frame_size >= 2*wordSize, \"frame size must include FP\/LR space\");\n+  assert((real_frame_size & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+\n+  int sp_inc_offset = frame_size - 3 * wordSize;  \/\/ Immediately below saved LR and FP\n+\n+  \/\/ Subtract two words for the saved FP and LR as these will be popped\n+  \/\/ separately. See remove_frame above.\n+  mov(rscratch1, real_frame_size - 2*wordSize);\n+  str(rscratch1, Address(sp, sp_inc_offset));\n+}\n@@ -5560,0 +5936,441 @@\n+#ifdef COMPILER2\n+\/\/ C2 compiled method's prolog code\n+\/\/ Moved here from aarch64.ad to support Valhalla code belows\n+void MacroAssembler::verified_entry(Compile* C, int sp_inc) {\n+  if (C->clinit_barrier_on_entry()) {\n+    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n+\n+    Label L_skip_barrier;\n+\n+    mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n+    clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n+    far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n+    bind(L_skip_barrier);\n+  }\n+\n+  if (C->max_vector_size() > 0) {\n+    reinitialize_ptrue();\n+  }\n+\n+  int bangsize = C->output()->bang_size_in_bytes();\n+  if (C->output()->need_stack_bang(bangsize))\n+    generate_stack_overflow_check(bangsize);\n+\n+  \/\/ n.b. frame size includes space for return pc and rfp\n+  const long framesize = C->output()->frame_size_in_bytes();\n+  build_frame(framesize);\n+\n+  if (C->needs_stack_repair()) {\n+    save_stack_increment(sp_inc, framesize);\n+  }\n+\n+  if (VerifyStackAtCalls) {\n+    Unimplemented();\n+  }\n+}\n+#endif \/\/ COMPILER2\n+\n+int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  \/\/ An inline type might be returned. If fields are in registers we\n+  \/\/ need to allocate an inline type instance and initialize it with\n+  \/\/ the value of the fields.\n+  Label skip;\n+  \/\/ We only need a new buffered inline type if a new one is not returned\n+  tbz(r0, 0, skip);\n+  int call_offset = -1;\n+\n+  \/\/ Be careful not to clobber r1-7 which hold returned fields\n+  \/\/ Also do not use callee-saved registers as these may be live in the interpreter\n+  Register tmp1 = r13, tmp2 = r14, klass = r15, r0_preserved = r12;\n+\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != NULL, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(r0_preserved, r0); \/\/ save r0 for slow_case since *_allocate may corrupt it when allocation failed\n+\n+  if (vk != NULL) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(klass, (intptr_t)vk->get_InlineKlass());\n+    jint obj_size = vk->layout_helper();\n+    assert(obj_size != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB) {\n+      tlab_allocate(r0, noreg, obj_size, tmp1, tmp2, slow_case);\n+    } else {\n+      b(slow_case);\n+    }\n+  } else {\n+    \/\/ Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)\n+    andr(klass, r0, -2);\n+    ldrw(tmp2, Address(klass, Klass::layout_helper_offset()));\n+    if (UseTLAB) {\n+      tlab_allocate(r0, tmp2, 0, tmp1, tmp2, slow_case);\n+    } else {\n+      b(slow_case);\n+    }\n+  }\n+  if (UseTLAB) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = r0;\n+    mov(rscratch1, (intptr_t)markWord::inline_type_prototype().value());\n+    str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+    store_klass_gap(buffer_obj, zr);\n+    if (vk == NULL) {\n+      \/\/ store_klass corrupts klass, so save it for later use (interpreter case only).\n+      mov(tmp1, klass);\n+    }\n+    store_klass(buffer_obj, klass);\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n+    if (vk != NULL) {\n+      far_call(RuntimeAddress(vk->pack_handler())); \/\/ no need for call info as this will not safepoint.\n+    } else {\n+      \/\/ tmp1 holds klass preserved above\n+      ldr(tmp1, Address(tmp1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      ldr(tmp1, Address(tmp1, InlineKlass::pack_handler_offset()));\n+      blr(tmp1);\n+    }\n+\n+    membar(Assembler::StoreStore);\n+    b(skip);\n+  } else {\n+    \/\/ Must have already branched to slow_case above.\n+    DEBUG_ONLY(should_not_reach_here());\n+  }\n+  bind(slow_case);\n+  \/\/ We failed to allocate a new inline type, fall back to a runtime\n+  \/\/ call. Some oop field may be live in some registers but we can't\n+  \/\/ tell. That runtime call will take care of preserving them\n+  \/\/ across a GC if there's one.\n+  mov(r0, r0_preserved);\n+\n+  if (from_interpreter) {\n+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());\n+  } else {\n+    far_call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n+    call_offset = offset();\n+  }\n+  membar(Assembler::StoreStore);\n+\n+  bind(skip);\n+  return call_offset;\n+}\n+\n+\/\/ Move a value between registers\/stack slots and update the reg_state\n+bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]) {\n+  assert(from->is_valid() && to->is_valid(), \"source and destination must be valid\");\n+  if (reg_state[to->value()] == reg_written) {\n+    return true; \/\/ Already written\n+  }\n+\n+  if (from != to && bt != T_VOID) {\n+    if (reg_state[to->value()] == reg_readonly) {\n+      return false; \/\/ Not yet writable\n+    }\n+    if (from->is_reg()) {\n+      if (to->is_reg()) {\n+        if (from->is_Register() && to->is_Register()) {\n+          mov(to->as_Register(), from->as_Register());\n+        } else if (from->is_FloatRegister() && to->is_FloatRegister()) {\n+          fmovd(to->as_FloatRegister(), from->as_FloatRegister());\n+        } else {\n+          ShouldNotReachHere();\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n+        Address to_addr = Address(sp, st_off);\n+        if (from->is_FloatRegister()) {\n+          if (bt == T_DOUBLE) {\n+             strd(from->as_FloatRegister(), to_addr);\n+          } else {\n+             assert(bt == T_FLOAT, \"must be float\");\n+             strs(from->as_FloatRegister(), to_addr);\n+          }\n+        } else {\n+          str(from->as_Register(), to_addr);\n+        }\n+      }\n+    } else {\n+      Address from_addr = Address(sp, from->reg2stack() * VMRegImpl::stack_slot_size);\n+      if (to->is_reg()) {\n+        if (to->is_FloatRegister()) {\n+          if (bt == T_DOUBLE) {\n+            ldrd(to->as_FloatRegister(), from_addr);\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            ldrs(to->as_FloatRegister(), from_addr);\n+          }\n+        } else {\n+          ldr(to->as_Register(), from_addr);\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(rscratch1, from_addr);\n+        str(rscratch1, Address(sp, st_off));\n+      }\n+    }\n+  }\n+\n+  \/\/ Update register states\n+  reg_state[from->value()] = reg_writable;\n+  reg_state[to->value()] = reg_written;\n+  return true;\n+}\n+\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  int sp_inc = args_on_stack * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  assert(sp_inc > 0, \"sanity\");\n+\n+  \/\/ Save a copy of the FP and LR here for deoptimization patching and frame walking\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+\n+  \/\/ Adjust the stack pointer. This will be repaired on return by MacroAssembler::remove_frame\n+  if (sp_inc < (1 << 9)) {\n+    sub(sp, sp, sp_inc);   \/\/ Fits in an immediate\n+  } else {\n+    mov(rscratch1, sp_inc);\n+    sub(sp, sp, rscratch1);\n+  }\n+\n+  return sp_inc + 2 * wordSize;  \/\/ Account for the FP\/LR space\n+}\n+\n+\/\/ Read all fields from an inline type oop and store the values in registers\/stack slots\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                                          VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                                          RegState reg_state[]) {\n+  assert(sig->at(sig_index)._bt == T_VOID, \"should be at end delimiter\");\n+  assert(from->is_valid(), \"source must be valid\");\n+  bool progress = false;\n+#ifdef ASSERT\n+  const int start_offset = offset();\n+#endif\n+\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r11;\n+  Register fromReg = noreg;\n+  ScalarizedInlineArgsStream stream(sig, sig_index, to, to_count, to_index, -1);\n+  bool done = true;\n+  bool mark_done = true;\n+  VMReg toReg;\n+  BasicType bt;\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n+  while (stream.next(toReg, bt)) {\n+    assert(toReg->is_valid(), \"destination must be valid\");\n+    int idx = (int)toReg->value();\n+    if (reg_state[idx] == reg_readonly) {\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n+    } else if (reg_state[idx] == reg_written) {\n+      continue;\n+    }\n+    assert(reg_state[idx] == reg_writable, \"must be writable\");\n+    reg_state[idx] = reg_written;\n+    progress = true;\n+\n+    if (fromReg == noreg) {\n+      if (from->is_reg()) {\n+        fromReg = from->as_Register();\n+      } else {\n+        int st_off = from->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(tmp1, Address(sp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        cbz(fromReg, L_null);\n+      }\n+    }\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        mov(tmp2, 1);\n+        str(tmp2, Address(sp, st_off));\n+      } else {\n+        mov(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n+    Address fromAddr = Address(fromReg, off);\n+    if (!toReg->is_FloatRegister()) {\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n+      if (is_reference_type(bt)) {\n+        load_heap_oop(dst, fromAddr, rscratch1, rscratch2);\n+      } else {\n+        bool is_signed = (bt != T_CHAR) && (bt != T_BOOLEAN);\n+        load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);\n+      }\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        str(dst, Address(sp, st_off));\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      ldrd(toReg->as_FloatRegister(), fromAddr);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      ldrs(toReg->as_FloatRegister(), fromAddr);\n+    }\n+  }\n+  if (progress && null_check) {\n+    if (done) {\n+      b(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+            str(zr, Address(sp, st_off));\n+          } else {\n+            mov(toReg->as_Register(), zr);\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n+  sig_index = stream.sig_index();\n+  to_index = stream.regs_index();\n+\n+  if (mark_done && reg_state[from->value()] != reg_written) {\n+    \/\/ This is okay because no one else will write to that slot\n+    reg_state[from->value()] = reg_writable;\n+  }\n+  from_index--;\n+  assert(progress || (start_offset == offset()), \"should not emit code\");\n+  return done;\n+}\n+\n+\/\/ Pack fields back into an inline type oop\n+bool MacroAssembler::pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                                        VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                                        RegState reg_state[], Register val_array) {\n+  assert(sig->at(sig_index)._bt == T_PRIMITIVE_OBJECT, \"should be at end delimiter\");\n+  assert(to->is_valid(), \"destination must be valid\");\n+\n+  if (reg_state[to->value()] == reg_written) {\n+    skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+    return true; \/\/ Already written\n+  }\n+\n+  \/\/ The GC barrier expanded by store_heap_oop below may call into the\n+  \/\/ runtime so use callee-saved registers for any values that need to be\n+  \/\/ preserved. The GC barrier assembler should take care of saving the\n+  \/\/ Java argument registers.\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n+  Register val_obj_tmp = r21;\n+  Register from_reg_tmp = r22;\n+  Register tmp1 = r14;\n+  Register tmp2 = r13;\n+  Register tmp3 = r12;\n+  Register val_obj = to->is_stack() ? val_obj_tmp : to->as_Register();\n+\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n+  if (reg_state[to->value()] == reg_readonly) {\n+    if (!is_reg_in_unpacked_fields(sig, sig_index, to, from, from_count, from_index)) {\n+      skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+      return false; \/\/ Not yet writable\n+    }\n+    val_obj = val_obj_tmp;\n+  }\n+\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_PRIMITIVE_OBJECT);\n+  load_heap_oop(val_obj, Address(val_array, index), tmp1, tmp2);\n+\n+  ScalarizedInlineArgsStream stream(sig, sig_index, from, from_count, from_index);\n+  VMReg fromReg;\n+  BasicType bt;\n+  Label L_null;\n+  while (stream.next(fromReg, bt)) {\n+    assert(fromReg->is_valid(), \"source must be valid\");\n+    reg_state[fromReg->value()] = reg_writable;\n+\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(tmp2, Address(sp, ld_off));\n+        cbnz(tmp2, L_notNull);\n+      } else {\n+        cbnz(fromReg->as_Register(), L_notNull);\n+      }\n+      mov(val_obj, 0);\n+      b(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n+    assert(off > 0, \"offset in object should be positive\");\n+    size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+\n+    \/\/ Pack the scalarized field into the value object.\n+    Address dst(val_obj, off);\n+\n+    if (!fromReg->is_FloatRegister()) {\n+      Register src;\n+      if (fromReg->is_stack()) {\n+        src = from_reg_tmp;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        load_sized_value(src, Address(sp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+      } else {\n+        src = fromReg->as_Register();\n+      }\n+      assert_different_registers(dst.base(), src, tmp1, tmp2, tmp3, val_array);\n+      if (is_reference_type(bt)) {\n+        store_heap_oop(dst, src, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        store_sized_value(dst, src, size_in_bytes);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      strd(fromReg->as_FloatRegister(), dst);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      strs(fromReg->as_FloatRegister(), dst);\n+    }\n+  }\n+  bind(L_null);\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+\n+  assert(reg_state[to->value()] == reg_writable, \"must have already been read\");\n+  bool success = move_helper(val_obj->as_VMReg(), to, T_OBJECT, reg_state);\n+  assert(success, \"to register must be writeable\");\n+\n+  return true;\n+}\n+\n+VMReg MacroAssembler::spill_reg_for(VMReg reg) {\n+  return (reg->is_FloatRegister()) ? v0->as_VMReg() : r14->as_VMReg();\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":819,"deletions":2,"binary":false,"changes":821,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -35,0 +36,4 @@\n+#include \"runtime\/signature.hpp\"\n+\n+\n+class ciInlineKlass;\n@@ -601,0 +606,31 @@\n+  \/\/ markWord tests, kills markWord reg\n+  void test_markword_is_inline_type(Register markword, Label& is_inline_type);\n+\n+  \/\/ inlineKlass queries, kills temp_reg\n+  void test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type);\n+  void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type);\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n+\n+  \/\/ Get the default value oop for the given InlineKlass\n+  void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);\n+  \/\/ The empty value oop, for the given InlineKlass (\"empty\" as in no instance fields)\n+  \/\/ get_default_value_oop with extra assertion for empty inline klass\n+  void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);\n+\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n+  void test_field_is_inlined(Register flags, Register temp_reg, Label& is_flattened);\n+\n+  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  void test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label);\n+  void test_flattened_array_oop(Register klass, Register temp_reg, Label& is_flattened_array);\n+  void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&is_non_flattened_array);\n+  void test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array);\n+  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array);\n+\n+  \/\/ Check array klass layout helper for flatten or null-free arrays...\n+  void test_flattened_array_layout(Register lh, Label& is_flattened_array);\n+  void test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array);\n+  void test_null_free_array_layout(Register lh, Label& is_null_free_array);\n+  void test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array);\n+\n@@ -834,0 +870,2 @@\n+  void load_metadata(Register dst, Register src);\n+\n@@ -848,0 +886,9 @@\n+  void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);\n+\n+  \/\/ inline type data payload offsets...\n+  void first_field_offset(Register inline_klass, Register offset);\n+  void data_for_oop(Register oop, Register data, Register inline_klass);\n+  \/\/ get data payload ptr a flat value array at index, kills rcx and index\n+  void data_for_value_array_index(Register array, Register array_klass,\n+                                  Register index, Register data);\n+\n@@ -861,0 +908,2 @@\n+  void load_prototype_header(Register dst, Register src);\n+\n@@ -908,0 +957,9 @@\n+\n+  \/\/ Object \/ value buffer allocation...\n+  \/\/ Allocate instance of klass, assumes klass initialized by caller\n+  \/\/ new_obj prefers to be rax\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+\n@@ -918,0 +976,3 @@\n+  \/\/ For field \"index\" within \"klass\", return inline_klass ...\n+  void get_inline_type_field_klass(Register klass, Register index, Register inline_klass);\n+\n@@ -1301,0 +1362,18 @@\n+  void verified_entry(Compile* C, int sp_inc);\n+\n+  \/\/ Inline type specific methods\n+  #include \"asm\/macroAssembler_common.hpp\"\n+\n+  int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);\n+  bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]);\n+  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                            VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                            RegState reg_state[]);\n+  bool pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                          VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                          RegState reg_state[], Register val_array);\n+  int extend_stack_for_inline_args(int args_on_stack);\n+  void remove_frame(int initial_framesize, bool needs_stack_repair);\n+  VMReg spill_reg_for(VMReg reg);\n+  void save_stack_increment(int sp_inc, int frame_size);\n+\n@@ -1365,0 +1444,2 @@\n+  void fill_words(Register base, uint64_t cnt, Register value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -340,0 +341,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -373,0 +375,80 @@\n+\n+const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j;\n+const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;\n+\n+int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {\n+\n+  \/\/ Create the mapping between argument positions and registers.\n+\n+  static const Register INT_ArgReg[java_return_convention_max_int] = {\n+    r0 \/* j_rarg7 *\/, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2, j_rarg1, j_rarg0\n+  };\n+\n+  static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {\n+    j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7\n+  };\n+\n+  uint int_args = 0;\n+  uint fp_args = 0;\n+\n+  for (int i = 0; i < total_args_passed; i++) {\n+    switch (sig_bt[i]) {\n+    case T_BOOLEAN:\n+    case T_CHAR:\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+      if (int_args < SharedRuntime::java_return_convention_max_int) {\n+        regs[i].set1(INT_ArgReg[int_args]->as_VMReg());\n+        int_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_VOID:\n+      \/\/ halves of T_LONG or T_DOUBLE\n+      assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+      regs[i].set_bad();\n+      break;\n+    case T_LONG:\n+      assert((i + 1) < total_args_passed && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      \/\/ fall through\n+    case T_OBJECT:\n+    case T_ARRAY:\n+    case T_ADDRESS:\n+      \/\/ Should T_METADATA be added to java_calling_convention as well ?\n+    case T_METADATA:\n+    case T_PRIMITIVE_OBJECT:\n+      if (int_args < SharedRuntime::java_return_convention_max_int) {\n+        regs[i].set2(INT_ArgReg[int_args]->as_VMReg());\n+        int_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_FLOAT:\n+      if (fp_args < SharedRuntime::java_return_convention_max_float) {\n+        regs[i].set1(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_DOUBLE:\n+      assert((i + 1) < total_args_passed && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      if (fp_args < SharedRuntime::java_return_convention_max_float) {\n+        regs[i].set2(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args ++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  return int_args + fp_args;\n+}\n+\n@@ -407,0 +489,109 @@\n+\/\/ For each inline type argument, sig includes the list of fields of\n+\/\/ the inline type. This utility function computes the number of\n+\/\/ arguments for the call if inline types are passed by reference (the\n+\/\/ calling convention the interpreter expects).\n+static int compute_total_args_passed_int(const GrowableArray<SigEntry>* sig_extended) {\n+  int total_args_passed = 0;\n+  if (InlineTypePassFieldsAsArgs) {\n+     for (int i = 0; i < sig_extended->length(); i++) {\n+       BasicType bt = sig_extended->at(i)._bt;\n+       if (bt == T_PRIMITIVE_OBJECT) {\n+         \/\/ In sig_extended, an inline type argument starts with:\n+         \/\/ T_PRIMITIVE_OBJECT, followed by the types of the fields of the\n+         \/\/ inline type and T_VOID to mark the end of the value\n+         \/\/ type. Inline types are flattened so, for instance, in the\n+         \/\/ case of an inline type with an int field and an inline type\n+         \/\/ field that itself has 2 fields, an int and a long:\n+         \/\/ T_PRIMITIVE_OBJECT T_INT T_PRIMITIVE_OBJECT T_INT T_LONG T_VOID (second\n+         \/\/ slot for the T_LONG) T_VOID (inner T_PRIMITIVE_OBJECT) T_VOID\n+         \/\/ (outer T_PRIMITIVE_OBJECT)\n+         total_args_passed++;\n+         int vt = 1;\n+         do {\n+           i++;\n+           BasicType bt = sig_extended->at(i)._bt;\n+           BasicType prev_bt = sig_extended->at(i-1)._bt;\n+           if (bt == T_PRIMITIVE_OBJECT) {\n+             vt++;\n+           } else if (bt == T_VOID &&\n+                      prev_bt != T_LONG &&\n+                      prev_bt != T_DOUBLE) {\n+             vt--;\n+           }\n+         } while (vt != 0);\n+       } else {\n+         total_args_passed++;\n+       }\n+     }\n+  } else {\n+    total_args_passed = sig_extended->length();\n+  }\n+\n+  return total_args_passed;\n+}\n+\n+\n+static void gen_c2i_adapter_helper(MacroAssembler* masm,\n+                                   BasicType bt,\n+                                   BasicType prev_bt,\n+                                   size_t size_in_bytes,\n+                                   const VMRegPair& reg_pair,\n+                                   const Address& to,\n+                                   Register tmp1,\n+                                   Register tmp2,\n+                                   Register tmp3,\n+                                   int extraspace,\n+                                   bool is_oop) {\n+  assert(bt != T_PRIMITIVE_OBJECT || !InlineTypePassFieldsAsArgs, \"no inline type here\");\n+  if (bt == T_VOID) {\n+    assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, \"missing half\");\n+    return;\n+  }\n+\n+  \/\/ Say 4 args:\n+  \/\/ i   st_off\n+  \/\/ 0   32 T_LONG\n+  \/\/ 1   24 T_VOID\n+  \/\/ 2   16 T_OBJECT\n+  \/\/ 3    8 T_BOOL\n+  \/\/ -    0 return address\n+  \/\/\n+  \/\/ However to make thing extra confusing. Because we can fit a Java long\/double in\n+  \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n+  \/\/ leaves one slot empty and only stores to a single slot. In this case the\n+  \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n+\n+  bool wide = (size_in_bytes == wordSize);\n+  VMReg r_1 = reg_pair.first();\n+  VMReg r_2 = reg_pair.second();\n+  assert(r_2->is_valid() == wide, \"invalid size\");\n+  if (!r_1->is_valid()) {\n+    assert(!r_2->is_valid(), \"\");\n+    return;\n+  }\n+\n+  if (!r_1->is_FloatRegister()) {\n+    Register val = r25;\n+    if (r_1->is_stack()) {\n+      \/\/ memory to memory use r25 (scratch registers is used by store_heap_oop)\n+      int ld_off = r_1->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+      __ load_sized_value(val, Address(sp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+    } else {\n+      val = r_1->as_Register();\n+    }\n+    assert_different_registers(to.base(), val, tmp1, tmp2, tmp3);\n+    if (is_oop) {\n+      __ store_heap_oop(to, val, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+    } else {\n+      __ store_sized_value(to, val, size_in_bytes);\n+    }\n+  } else {\n+    if (wide) {\n+      __ strd(r_1->as_FloatRegister(), to);\n+    } else {\n+      \/\/ only a float use just part of the slot\n+      __ strs(r_1->as_FloatRegister(), to);\n+    }\n+  }\n+}\n+\n@@ -408,3 +599,1 @@\n-                            int total_args_passed,\n-                            int comp_args_on_stack,\n-                            const BasicType *sig_bt,\n+                            const GrowableArray<SigEntry>* sig_extended,\n@@ -412,1 +601,28 @@\n-                            Label& skip_fixup) {\n+                            bool requires_clinit_barrier,\n+                            address& c2i_no_clinit_check_entry,\n+                            Label& skip_fixup,\n+                            address start,\n+                            OopMapSet* oop_maps,\n+                            int& frame_complete,\n+                            int& frame_size_in_words,\n+                            bool alloc_inline_receiver) {\n+  if (requires_clinit_barrier && VM_Version::supports_fast_class_init_checks()) {\n+    Label L_skip_barrier;\n+\n+    { \/\/ Bypass the barrier for non-static methods\n+      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n+      __ andsw(zr, rscratch1, JVM_ACC_STATIC);\n+      __ br(Assembler::EQ, L_skip_barrier); \/\/ non-static\n+    }\n+\n+    __ load_method_holder(rscratch2, rmethod);\n+    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n+    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n+\n+    __ bind(L_skip_barrier);\n+    c2i_no_clinit_check_entry = __ pc();\n+  }\n+\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->c2i_entry_barrier(masm);\n+\n@@ -422,1 +638,22 @@\n-  int words_pushed = 0;\n+  \/\/ Name some registers to be used in the following code. We can use\n+  \/\/ anything except r0-r7 which are arguments in the Java calling\n+  \/\/ convention, rmethod (r12), and r13 which holds the outgoing sender\n+  \/\/ SP for the interpreter.\n+  Register buf_array = r10;   \/\/ Array of buffered inline types\n+  Register buf_oop = r11;     \/\/ Buffered inline type oop\n+  Register tmp1 = r15;\n+  Register tmp2 = r16;\n+  Register tmp3 = r17;\n+\n+  if (InlineTypePassFieldsAsArgs) {\n+    \/\/ Is there an inline type argument?\n+    bool has_inline_argument = false;\n+    for (int i = 0; i < sig_extended->length() && !has_inline_argument; i++) {\n+      has_inline_argument = (sig_extended->at(i)._bt == T_PRIMITIVE_OBJECT);\n+    }\n+    if (has_inline_argument) {\n+      \/\/ There is at least an inline type argument: we're coming from\n+      \/\/ compiled code so we have no buffers to back the inline types\n+      \/\/ Allocate the buffers here with a runtime call.\n+      RegisterSaver reg_save(false \/* save_vectors *\/);\n+      OopMap* map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -424,2 +661,2 @@\n-  \/\/ Since all args are passed on the stack, total_args_passed *\n-  \/\/ Interpreter::stackElementSize is the space we need.\n+      frame_complete = __ offset();\n+      address the_pc = __ pc();\n@@ -427,1 +664,2 @@\n-  int extraspace = total_args_passed * Interpreter::stackElementSize;\n+      Label retaddr;\n+      __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);\n@@ -429,1 +667,3 @@\n-  __ mov(r19_sender_sp, sp);\n+      __ mov(c_rarg0, rthread);\n+      __ mov(c_rarg1, rmethod);\n+      __ mov(c_rarg2, (int64_t)alloc_inline_receiver);\n@@ -431,2 +671,3 @@\n-  \/\/ stack is aligned, keep it that way\n-  extraspace = align_up(extraspace, 2*wordSize);\n+      __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));\n+      __ blr(rscratch1);\n+      __ bind(retaddr);\n@@ -434,2 +675,2 @@\n-  if (extraspace)\n-    __ sub(sp, sp, extraspace);\n+      oop_maps->add_gc_map(__ pc() - start, map);\n+      __ reset_last_Java_frame(false);\n@@ -437,6 +678,1 @@\n-  \/\/ Now write the args into the outgoing interpreter space\n-  for (int i = 0; i < total_args_passed; i++) {\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n-      continue;\n-    }\n+      reg_save.restore_live_registers(masm);\n@@ -444,16 +680,3 @@\n-    \/\/ offset to start parameters\n-    int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;\n-    int next_off = st_off - Interpreter::stackElementSize;\n-\n-    \/\/ Say 4 args:\n-    \/\/ i   st_off\n-    \/\/ 0   32 T_LONG\n-    \/\/ 1   24 T_VOID\n-    \/\/ 2   16 T_OBJECT\n-    \/\/ 3    8 T_BOOL\n-    \/\/ -    0 return address\n-    \/\/\n-    \/\/ However to make thing extra confusing. Because we can fit a Java long\/double in\n-    \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n-    \/\/ leaves one slot empty and only stores to a single slot. In this case the\n-    \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n+      Label no_exception;\n+      __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+      __ cbz(rscratch1, no_exception);\n@@ -461,5 +684,9 @@\n-    VMReg r_1 = regs[i].first();\n-    VMReg r_2 = regs[i].second();\n-    if (!r_1->is_valid()) {\n-      assert(!r_2->is_valid(), \"\");\n-      continue;\n+      __ str(zr, Address(rthread, JavaThread::vm_result_offset()));\n+      __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));\n+      __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+      __ bind(no_exception);\n+\n+      \/\/ We get an array of objects from the runtime call\n+      __ get_vm_result(buf_array, rthread);\n+      __ get_vm_result_2(rmethod, rthread); \/\/ TODO: required to keep the callee Method live?\n@@ -467,9 +694,1 @@\n-    if (r_1->is_stack()) {\n-      \/\/ memory to memory use rscratch1\n-      int ld_off = (r_1->reg2stack() * VMRegImpl::stack_slot_size\n-                    + extraspace\n-                    + words_pushed * wordSize);\n-      if (!r_2->is_valid()) {\n-        \/\/ sign extend??\n-        __ ldrw(rscratch1, Address(sp, ld_off));\n-        __ str(rscratch1, Address(sp, st_off));\n+  }\n@@ -477,1 +696,8 @@\n-      } else {\n+  \/\/ Since all args are passed on the stack, total_args_passed *\n+  \/\/ Interpreter::stackElementSize is the space we need.\n+\n+  int total_args_passed = compute_total_args_passed_int(sig_extended);\n+  int extraspace = total_args_passed * Interpreter::stackElementSize;\n+\n+  \/\/ stack is aligned, keep it that way\n+  extraspace = align_up(extraspace, StackAlignmentInBytes);\n@@ -479,1 +705,2 @@\n-        __ ldr(rscratch1, Address(sp, ld_off));\n+  \/\/ set senderSP value\n+  __ mov(r19_sender_sp, sp);\n@@ -481,6 +708,28 @@\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ ld_off == LSW, ld_off+wordSize == MSW\n-          \/\/ st_off == MSW, next_off == LSW\n-          __ str(rscratch1, Address(sp, next_off));\n+  __ sub(sp, sp, extraspace);\n+\n+  \/\/ Now write the args into the outgoing interpreter space\n+\n+  \/\/ next_arg_comp is the next argument from the compiler point of\n+  \/\/ view (inline type fields are passed in registers\/on the stack). In\n+  \/\/ sig_extended, an inline type argument starts with: T_PRIMITIVE_OBJECT,\n+  \/\/ followed by the types of the fields of the inline type and T_VOID\n+  \/\/ to mark the end of the inline type. ignored counts the number of\n+  \/\/ T_PRIMITIVE_OBJECT\/T_VOID. next_vt_arg is the next inline type argument:\n+  \/\/ used to get the buffer for that argument from the pool of buffers\n+  \/\/ we allocated above and want to pass to the\n+  \/\/ interpreter. next_arg_int is the next argument from the\n+  \/\/ interpreter point of view (inline types are passed by reference).\n+  for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;\n+       next_arg_comp < sig_extended->length(); next_arg_comp++) {\n+    assert(ignored <= next_arg_comp, \"shouldn't skip over more slots than there are arguments\");\n+    assert(next_arg_int <= total_args_passed, \"more arguments for the interpreter than expected?\");\n+    BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+    int st_off = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;\n+    if (!InlineTypePassFieldsAsArgs || bt != T_PRIMITIVE_OBJECT) {\n+      int next_off = st_off - Interpreter::stackElementSize;\n+      const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;\n+      const VMRegPair reg_pair = regs[next_arg_comp-ignored];\n+      size_t size_in_bytes = reg_pair.second()->is_valid() ? 8 : 4;\n+      gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                             size_in_bytes, reg_pair, Address(sp, offset), tmp1, tmp2, tmp3, extraspace, false);\n+      next_arg_int++;\n@@ -488,7 +737,4 @@\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaaaull);\n-          __ str(rscratch1, Address(sp, st_off));\n-#endif \/* ASSERT *\/\n-        } else {\n-          __ str(rscratch1, Address(sp, st_off));\n-        }\n+      if (bt == T_LONG || bt == T_DOUBLE) {\n+        \/\/ Overwrite the unused slot with known junk\n+        __ mov(rscratch1, CONST64(0xdeadffffdeadaaaa));\n+        __ str(rscratch1, Address(sp, st_off));\n@@ -496,16 +742,24 @@\n-    } else if (r_1->is_Register()) {\n-      Register r = r_1->as_Register();\n-      if (!r_2->is_valid()) {\n-        \/\/ must be only an int (or less ) so move only 32bits to slot\n-        \/\/ why not sign extend??\n-        __ str(r, Address(sp, st_off));\n-      } else {\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ jlong\/double in gpr\n-#ifdef ASSERT\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaabull);\n-          __ str(rscratch1, Address(sp, st_off));\n-          __ str(r, Address(sp, next_off));\n+    } else {\n+      ignored++;\n+      \/\/ get the buffer from the just allocated pool of buffers\n+      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_PRIMITIVE_OBJECT);\n+      __ load_heap_oop(buf_oop, Address(buf_array, index), tmp1, tmp2);\n+      next_vt_arg++; next_arg_int++;\n+      int vt = 1;\n+      \/\/ write fields we get from compiled code in registers\/stack\n+      \/\/ slots to the buffer: we know we are done with that inline type\n+      \/\/ argument when we hit the T_VOID that acts as an end of inline\n+      \/\/ type delimiter for this inline type. Inline types are flattened\n+      \/\/ so we might encounter embedded inline types. Each entry in\n+      \/\/ sig_extended contains a field offset in the buffer.\n+      Label L_null;\n+      do {\n+        next_arg_comp++;\n+        BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+        BasicType prev_bt = sig_extended->at(next_arg_comp - 1)._bt;\n+        if (bt == T_PRIMITIVE_OBJECT) {\n+          vt++;\n+          ignored++;\n+        } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+          vt--;\n+          ignored++;\n@@ -514,1 +768,22 @@\n-          __ str(r, Address(sp, st_off));\n+          int off = sig_extended->at(next_arg_comp)._offset;\n+          if (off == -1) {\n+            \/\/ Nullable inline type argument, emit null check\n+            VMReg reg = regs[next_arg_comp-ignored].first();\n+            Label L_notNull;\n+            if (reg->is_stack()) {\n+              int ld_off = reg->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+              __ ldr(tmp1, Address(sp, ld_off));\n+              __ cbnz(tmp1, L_notNull);\n+            } else {\n+              __ cbnz(reg->as_Register(), L_notNull);\n+            }\n+            __ str(zr, Address(sp, st_off));\n+            __ b(L_null);\n+            __ bind(L_notNull);\n+            continue;\n+          }\n+          assert(off > 0, \"offset in object should be positive\");\n+          size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+          bool is_oop = is_reference_type(bt);\n+          gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                                 size_in_bytes, regs[next_arg_comp-ignored], Address(buf_oop, off), tmp1, tmp2, tmp3, extraspace, is_oop);\n@@ -516,14 +791,4 @@\n-      }\n-    } else {\n-      assert(r_1->is_FloatRegister(), \"\");\n-      if (!r_2->is_valid()) {\n-        \/\/ only a float use just part of the slot\n-        __ strs(r_1->as_FloatRegister(), Address(sp, st_off));\n-      } else {\n-#ifdef ASSERT\n-        \/\/ Overwrite the unused slot with known junk\n-        __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaacull);\n-        __ str(rscratch1, Address(sp, st_off));\n-#endif \/* ASSERT *\/\n-        __ strd(r_1->as_FloatRegister(), Address(sp, next_off));\n-      }\n+      } while (vt != 0);\n+      \/\/ pass the buffer to the interpreter\n+      __ str(buf_oop, Address(sp, st_off));\n+      __ bind(L_null);\n@@ -539,0 +804,1 @@\n+void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray<SigEntry>* sig, const VMRegPair *regs) {\n@@ -540,5 +806,0 @@\n-void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,\n-                                    int total_args_passed,\n-                                    int comp_args_on_stack,\n-                                    const BasicType *sig_bt,\n-                                    const VMRegPair *regs) {\n@@ -602,1 +863,1 @@\n-  int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)>>LogBytesPerWord;\n+  int comp_words_on_stack = 0;\n@@ -604,2 +865,3 @@\n-    __ sub(rscratch1, sp, comp_words_on_stack * wordSize);\n-    __ andr(sp, rscratch1, -16);\n+     comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) >> LogBytesPerWord;\n+     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);\n+     __ andr(sp, rscratch1, -16);\n@@ -610,1 +872,1 @@\n-  __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));\n+  __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_inline_offset())));\n@@ -624,0 +886,2 @@\n+  int total_args_passed = sig->length();\n+\n@@ -626,2 +890,5 @@\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n+    BasicType bt = sig->at(i)._bt;\n+\n+    assert(bt != T_PRIMITIVE_OBJECT, \"i2c adapter doesn't unpack inline typ args\");\n+    if (bt == T_VOID) {\n+      assert(i > 0 && (sig->at(i - 1)._bt == T_LONG || sig->at(i - 1)._bt == T_DOUBLE), \"missing half\");\n@@ -632,0 +899,1 @@\n+    assert(!regs[i].second()->is_valid() || regs[i].first()->next() == regs[i].second(), \"scrambled load targets?\");\n@@ -633,3 +901,1 @@\n-    assert(!regs[i].second()->is_valid() || regs[i].first()->next() == regs[i].second(),\n-            \"scrambled load targets?\");\n-    int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;\n+    int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;\n@@ -650,1 +916,1 @@\n-      int st_off = regs[i].first()->reg2stack()*VMRegImpl::stack_slot_size;\n+      int st_off = regs[i].first()->reg2stack() * VMRegImpl::stack_slot_size;\n@@ -667,2 +933,1 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n-                           next_off : ld_off;\n+        const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;\n@@ -671,11 +936,28 @@\n-        __ str(rscratch2, Address(sp, st_off));\n-      }\n-    } else if (r_1->is_Register()) {  \/\/ Register argument\n-      Register r = r_1->as_Register();\n-      if (r_2->is_valid()) {\n-        \/\/\n-        \/\/ We are using two VMRegs. This can be either T_OBJECT,\n-        \/\/ T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates\n-        \/\/ two slots but only uses one for thr T_LONG or T_DOUBLE case\n-        \/\/ So we must adjust where to pick up the data to match the\n-        \/\/ interpreter.\n+         __ str(rscratch2, Address(sp, st_off));\n+       }\n+     } else if (r_1->is_Register()) {  \/\/ Register argument\n+       Register r = r_1->as_Register();\n+       if (r_2->is_valid()) {\n+         \/\/\n+         \/\/ We are using two VMRegs. This can be either T_OBJECT,\n+         \/\/ T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates\n+         \/\/ two slots but only uses one for thr T_LONG or T_DOUBLE case\n+         \/\/ So we must adjust where to pick up the data to match the\n+         \/\/ interpreter.\n+\n+        const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;\n+\n+         \/\/ this can be a misaligned move\n+         __ ldr(r, Address(esp, offset));\n+       } else {\n+         \/\/ sign extend and use a full word?\n+         __ ldrw(r, Address(esp, ld_off));\n+       }\n+     } else {\n+       if (!r_2->is_valid()) {\n+         __ ldrs(r_1->as_FloatRegister(), Address(esp, ld_off));\n+       } else {\n+         __ ldrd(r_1->as_FloatRegister(), Address(esp, next_off));\n+       }\n+     }\n+   }\n@@ -683,17 +965,0 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n-                           next_off : ld_off;\n-\n-        \/\/ this can be a misaligned move\n-        __ ldr(r, Address(esp, offset));\n-      } else {\n-        \/\/ sign extend and use a full word?\n-        __ ldrw(r, Address(esp, ld_off));\n-      }\n-    } else {\n-      if (!r_2->is_valid()) {\n-        __ ldrs(r_1->as_FloatRegister(), Address(esp, ld_off));\n-      } else {\n-        __ ldrd(r_1->as_FloatRegister(), Address(esp, next_off));\n-      }\n-    }\n-  }\n@@ -716,1 +981,0 @@\n-\n@@ -720,13 +984,1 @@\n-\/\/ ---------------------------------------------------------------\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n-  address i2c_entry = __ pc();\n-\n-  gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);\n-\n-  address c2i_unverified_entry = __ pc();\n-  Label skip_fixup;\n+static void gen_inline_cache_check(MacroAssembler *masm, Label& skip_fixup) {\n@@ -767,0 +1019,1 @@\n+}\n@@ -768,5 +1021,12 @@\n-  address c2i_entry = __ pc();\n-  \/\/ Class initialization barrier for static methods\n-  address c2i_no_clinit_check_entry = NULL;\n-  if (VM_Version::supports_fast_class_init_checks()) {\n-    Label L_skip_barrier;\n+\/\/ ---------------------------------------------------------------\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n+                                                            int comp_args_on_stack,\n+                                                            const GrowableArray<SigEntry>* sig,\n+                                                            const VMRegPair* regs,\n+                                                            const GrowableArray<SigEntry>* sig_cc,\n+                                                            const VMRegPair* regs_cc,\n+                                                            const GrowableArray<SigEntry>* sig_cc_ro,\n+                                                            const VMRegPair* regs_cc_ro,\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n@@ -775,5 +1035,2 @@\n-    { \/\/ Bypass the barrier for non-static methods\n-      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n-      __ andsw(zr, rscratch1, JVM_ACC_STATIC);\n-      __ br(Assembler::EQ, L_skip_barrier); \/\/ non-static\n-    }\n+  address i2c_entry = __ pc();\n+  gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);\n@@ -781,3 +1038,3 @@\n-    __ load_method_holder(rscratch2, rmethod);\n-    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n-    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n+  address c2i_unverified_entry        = __ pc();\n+  address c2i_unverified_inline_entry = __ pc();\n+  Label skip_fixup;\n@@ -785,3 +1042,1 @@\n-    __ bind(L_skip_barrier);\n-    c2i_no_clinit_check_entry = __ pc();\n-  }\n+  gen_inline_cache_check(masm, skip_fixup);\n@@ -789,2 +1044,3 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  int frame_complete = CodeOffsets::frame_never_safe;\n+  int frame_size_in_words = 0;\n@@ -792,1 +1048,26 @@\n-  gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);\n+  \/\/ Scalarized c2i adapter with non-scalarized receiver (i.e., don't pack receiver)\n+  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_inline_ro_entry = __ pc();\n+  if (regs_cc != regs_cc_ro) {\n+    \/\/ No class init barrier needed because method is guaranteed to be non-static\n+    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, \/* requires_clinit_barrier = *\/ false, c2i_no_clinit_check_entry,\n+                    skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* alloc_inline_receiver = *\/ false);\n+    skip_fixup.reset();\n+  }\n+\n+  \/\/ Scalarized c2i adapter\n+  address c2i_entry        = __ pc();\n+  address c2i_inline_entry = __ pc();\n+  gen_c2i_adapter(masm, sig_cc, regs_cc, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                  skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* alloc_inline_receiver = *\/ true);\n+\n+  \/\/ Non-scalarized c2i adapter\n+  if (regs != regs_cc) {\n+    c2i_unverified_inline_entry = __ pc();\n+    Label inline_entry_skip_fixup;\n+    gen_inline_cache_check(masm, inline_entry_skip_fixup);\n+\n+    c2i_inline_entry = __ pc();\n+    gen_c2i_adapter(masm, sig, regs, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                    inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* alloc_inline_receiver = *\/ false);\n+  }\n@@ -795,1 +1076,9 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+\n+  \/\/ The c2i adapter might safepoint and trigger a GC. The caller must make sure that\n+  \/\/ the GC knows about the location of oop argument locations passed to the c2i adapter.\n+  if (allocate_code_blob) {\n+    bool caller_must_gc_arguments = (regs != regs_cc);\n+    new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  }\n+\n+  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -843,0 +1132,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1646,0 +1936,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1760,0 +2051,4 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        __ andr(swap_reg, swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+      }\n@@ -1825,0 +2120,1 @@\n+  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n@@ -3075,0 +3371,121 @@\n+\n+BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {\n+  BufferBlob* buf = BufferBlob::create(\"inline types pack\/unpack\", 16 * K);\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  MacroAssembler _masm(&buffer);\n+  MacroAssembler* masm = &_masm;\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  int pack_fields_jobject_off = __ offset();\n+  \/\/ Resolve pre-allocated buffer from JNI handle.\n+  \/\/ We cannot do this in generate_call_stub() because it requires GC code to be initialized.\n+  Register Rresult = r14;  \/\/ See StubGenerator::generate_call_stub().\n+  __ ldr(r0, Address(Rresult));\n+  __ resolve_jobject(r0 \/* value *\/,\n+                     rthread \/* thread *\/,\n+                     r12 \/* tmp *\/);\n+  __ str(r0, Address(Rresult));\n+\n+  int pack_fields_off = __ offset();\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address to(r0, off);\n+    if (bt == T_FLOAT) {\n+      __ strs(r_1->as_FloatRegister(), to);\n+    } else if (bt == T_DOUBLE) {\n+      __ strd(r_1->as_FloatRegister(), to);\n+    } else if (bt == T_OBJECT || bt == T_ARRAY) {\n+      Register val = r_1->as_Register();\n+      assert_different_registers(r0, val);\n+      \/\/ We don't need barriers because the destination is a newly allocated object.\n+      \/\/ Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.\n+      if (UseCompressedOops) {\n+        __ encode_heap_oop(val);\n+        __ str(val, to);\n+      } else {\n+        __ str(val, to);\n+      }\n+    } else {\n+      assert(is_java_primitive(bt), \"unexpected basic type\");\n+      assert_different_registers(r0, r_1->as_Register());\n+      size_t size_in_bytes = type2aelembytes(bt);\n+      __ store_sized_value(to, r_1->as_Register(), size_in_bytes);\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ ret(lr);\n+\n+  int unpack_fields_off = __ offset();\n+\n+  Label skip;\n+  __ cbz(r0, skip);\n+\n+  j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address from(r0, off);\n+    if (bt == T_FLOAT) {\n+      __ ldrs(r_1->as_FloatRegister(), from);\n+    } else if (bt == T_DOUBLE) {\n+      __ ldrd(r_1->as_FloatRegister(), from);\n+    } else if (bt == T_OBJECT || bt == T_ARRAY) {\n+      assert_different_registers(r0, r_1->as_Register());\n+      __ load_heap_oop(r_1->as_Register(), from, rscratch1, rscratch2);\n+    } else {\n+      assert(is_java_primitive(bt), \"unexpected basic type\");\n+      assert_different_registers(r0, r_1->as_Register());\n+\n+      size_t size_in_bytes = type2aelembytes(bt);\n+      __ load_sized_value(r_1->as_Register(), from, size_in_bytes, bt != T_CHAR && bt != T_BOOLEAN);\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ bind(skip);\n+\n+  __ ret(lr);\n+\n+  __ flush();\n+\n+  return BufferedInlineTypeBlob::create(&buffer, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":591,"deletions":174,"binary":false,"changes":765,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-    \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+    \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n@@ -318,4 +318,13 @@\n-    __ ldr(j_rarg2, result);\n-    Label is_long, is_float, is_double, exit;\n-    __ ldr(j_rarg1, result_type);\n-    __ cmp(j_rarg1, (u1)T_OBJECT);\n+    \/\/ All of j_rargN may be used to return inline type fields so be careful\n+    \/\/ not to clobber those.\n+    \/\/ SharedRuntime::generate_buffered_inline_type_adapter() knows the register\n+    \/\/ assignment of Rresult below.\n+    Register Rresult = r14, Rresult_type = r15;\n+    __ ldr(Rresult, result);\n+    Label is_long, is_float, is_double, check_prim, exit;\n+    __ ldr(Rresult_type, result_type);\n+    __ cmp(Rresult_type, (u1)T_OBJECT);\n+    __ br(Assembler::EQ, check_prim);\n+    __ cmp(Rresult_type, (u1)T_PRIMITIVE_OBJECT);\n+    __ br(Assembler::EQ, check_prim);\n+    __ cmp(Rresult_type, (u1)T_LONG);\n@@ -323,3 +332,1 @@\n-    __ cmp(j_rarg1, (u1)T_LONG);\n-    __ br(Assembler::EQ, is_long);\n-    __ cmp(j_rarg1, (u1)T_FLOAT);\n+    __ cmp(Rresult_type, (u1)T_FLOAT);\n@@ -327,1 +334,1 @@\n-    __ cmp(j_rarg1, (u1)T_DOUBLE);\n+    __ cmp(Rresult_type, (u1)T_DOUBLE);\n@@ -331,1 +338,1 @@\n-    __ strw(r0, Address(j_rarg2));\n+    __ strw(r0, Address(Rresult));\n@@ -379,0 +386,11 @@\n+    __ BIND(check_prim);\n+    if (InlineTypeReturnedAsFields) {\n+      \/\/ Check for scalarized return value\n+      __ tbz(r0, 0, is_long);\n+      \/\/ Load pack handler address\n+      __ andr(rscratch1, r0, -2);\n+      __ ldr(rscratch1, Address(rscratch1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      __ ldr(rscratch1, Address(rscratch1, InlineKlass::pack_handler_jobject_offset()));\n+      __ blr(rscratch1);\n+      __ b(exit);\n+    }\n@@ -381,1 +399,1 @@\n-    __ str(r0, Address(j_rarg2, 0));\n+    __ str(r0, Address(Rresult, 0));\n@@ -385,1 +403,1 @@\n-    __ strs(j_farg0, Address(j_rarg2, 0));\n+    __ strs(j_farg0, Address(Rresult, 0));\n@@ -389,1 +407,1 @@\n-    __ strd(j_farg0, Address(j_rarg2, 0));\n+    __ strd(j_farg0, Address(Rresult, 0));\n@@ -2112,0 +2130,8 @@\n+    \/\/ Check for flat inline type array -> return -1\n+    __ tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    __ br(Assembler::NE, L_failed);\n+\n+    \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n+    __ tst(lh, Klass::_lh_null_free_array_bit_inplace);\n+    __ br(Assembler::NE, L_failed);\n+\n@@ -7905,0 +7931,128 @@\n+  \/\/ Call here from the interpreter or compiled code to either load\n+  \/\/ multiple returned values from the inline type instance being\n+  \/\/ returned to registers or to store returned values to a newly\n+  \/\/ allocated inline type instance.\n+  address generate_return_value_stub(address destination, const char* name, bool has_res) {\n+    \/\/ We need to save all registers the calling convention may use so\n+    \/\/ the runtime calls read or update those registers. This needs to\n+    \/\/ be in sync with SharedRuntime::java_return_convention().\n+    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+    enum layout {\n+      j_rarg7_off = 0, j_rarg7_2,    \/\/ j_rarg7 is r0\n+      j_rarg6_off, j_rarg6_2,\n+      j_rarg5_off, j_rarg5_2,\n+      j_rarg4_off, j_rarg4_2,\n+      j_rarg3_off, j_rarg3_2,\n+      j_rarg2_off, j_rarg2_2,\n+      j_rarg1_off, j_rarg1_2,\n+      j_rarg0_off, j_rarg0_2,\n+\n+      j_farg7_off, j_farg7_2,\n+      j_farg6_off, j_farg6_2,\n+      j_farg5_off, j_farg5_2,\n+      j_farg4_off, j_farg4_2,\n+      j_farg3_off, j_farg3_2,\n+      j_farg2_off, j_farg2_2,\n+      j_farg1_off, j_farg1_2,\n+      j_farg0_off, j_farg0_2,\n+\n+      rfp_off, rfp_off2,\n+      return_off, return_off2,\n+\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    CodeBuffer code(name, 512, 64);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+    assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+    int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+    int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg7_off), j_rarg7->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg6_off), j_rarg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+    address start = __ pc();\n+\n+    __ enter(); \/\/ Save FP and LR before call\n+\n+    __ stpd(j_farg1, j_farg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg3, j_farg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg5, j_farg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg7, j_farg6, Address(__ pre(sp, -2 * wordSize)));\n+\n+    __ stp(j_rarg1, j_rarg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg3, j_rarg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg5, j_rarg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg7, j_rarg6, Address(__ pre(sp, -2 * wordSize)));\n+\n+    int frame_complete = __ offset();\n+\n+    \/\/ Set up last_Java_sp and last_Java_fp\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);\n+\n+    \/\/ Call runtime\n+    __ mov(c_rarg1, r0);\n+    __ mov(c_rarg0, rthread);\n+\n+    __ mov(rscratch1, destination);\n+    __ blr(rscratch1);\n+\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    __ reset_last_Java_frame(false);\n+\n+    __ ldp(j_rarg7, j_rarg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg5, j_rarg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg3, j_rarg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg1, j_rarg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ ldpd(j_farg7, j_farg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg5, j_farg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg3, j_farg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg1, j_farg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ leave();\n+\n+    \/\/ check for pending exceptions\n+    Label pending;\n+    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    __ cbnz(rscratch1, pending);\n+\n+    if (has_res) {\n+      __ get_vm_result(r0, rthread);\n+    }\n+\n+    __ ret(lr);\n+\n+    __ bind(pending);\n+    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+    \/\/ -------------\n+    \/\/ make sure all code is generated\n+    masm->flush();\n+\n+    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, frame_size_in_words, oop_maps, false);\n+    return stub->entry_point();\n+  }\n+\n@@ -7954,0 +8108,7 @@\n+\n+    if (InlineTypeReturnedAsFields) {\n+      StubRoutines::_load_inline_type_fields_in_regs =\n+         generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs), \"load_inline_type_fields_in_regs\", false);\n+      StubRoutines::_store_inline_type_fields_to_buf =\n+         generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf), \"store_inline_type_fields_to_buf\", true);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":174,"deletions":13,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  case Bytecodes::_fast_qputfield:\n@@ -331,0 +332,1 @@\n+  __ andr(r3, r3, ~JVM_CONSTANT_QDescBit);\n@@ -748,4 +750,4 @@\n-    \/\/ ??? convention: move array into r3 for exception message\n-  __ mov(r3, array);\n-  __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n-  __ br(rscratch1);\n+  \/\/ ??? convention: move array into r3 for exception message\n+   __ mov(r3, array);\n+   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n+   __ br(rscratch1);\n@@ -811,5 +813,17 @@\n-  __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n-  do_oop_load(_masm,\n-              Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),\n-              r0,\n-              IS_ARRAY);\n+  __ profile_array(r2, r0, r4);\n+  if (UseFlatArray) {\n+    Label is_flat_array, done;\n+\n+    __ test_flattened_array_oop(r0, r8 \/*temp*\/, is_flat_array);\n+    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n+    do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);\n+\n+    __ b(done);\n+    __ bind(is_flat_array);\n+    __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), r0, r1);\n+    __ bind(done);\n+  } else {\n+    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);\n+    do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);\n+  }\n+  __ profile_element(r2, r0, r4);\n@@ -1102,1 +1116,1 @@\n-  Label is_null, ok_is_subtype, done;\n+  Label is_null, is_flat_array, ok_is_subtype, done;\n@@ -1109,2 +1123,4 @@\n-  Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));\n-\n+\n+  __ profile_array(r4, r3, r5);\n+  __ profile_element(r4, r0, r5);\n+\n@@ -1113,0 +1129,2 @@\n+  Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));\n+  \/\/ Be careful not to clobber r4 below\n@@ -1117,0 +1135,8 @@\n+  \/\/ Move array class to r5\n+  __ load_klass(r5, r3);\n+\n+  if (UseFlatArray) {\n+    __ ldrw(r6, Address(r5, Klass::layout_helper_offset()));\n+    __ test_flattened_array_layout(r6, is_flat_array);\n+  }\n+\n@@ -1119,4 +1145,3 @@\n-  \/\/ Move superklass into r0\n-  __ load_klass(r0, r3);\n-  __ ldr(r0, Address(r0,\n-                     ObjArrayKlass::element_klass_offset()));\n+\n+  \/\/ Move array element superklass into r0\n+  __ ldr(r0, Address(r5, ObjArrayKlass::element_klass_offset()));\n@@ -1127,1 +1152,3 @@\n-  __ gen_subtype_check(r1, ok_is_subtype);\n+\n+  \/\/ is \"r1 <: r0\" ? (value subclass <: array element superclass)\n+  __ gen_subtype_check(r1, ok_is_subtype, false);\n@@ -1144,1 +1171,12 @@\n-  __ profile_null_seen(r2);\n+  if (EnablePrimitiveClasses) {\n+    Label is_null_into_value_array_npe, store_null;\n+\n+    \/\/ No way to store null in flat null-free array\n+    __ test_null_free_array_oop(r3, r8, is_null_into_value_array_npe);\n+    __ b(store_null);\n+\n+    __ bind(is_null_into_value_array_npe);\n+    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+\n+    __ bind(store_null);\n+  }\n@@ -1148,0 +1186,41 @@\n+  __ b(done);\n+\n+  if (UseFlatArray) {\n+     Label is_type_ok;\n+    __ bind(is_flat_array); \/\/ Store non-null value to flat\n+\n+    \/\/ Simplistic type check...\n+    \/\/ r0 - value, r2 - index, r3 - array.\n+\n+    \/\/ Profile the not-null value's klass.\n+    \/\/ Load value class\n+     __ load_klass(r1, r0);\n+\n+    \/\/ Move element klass into r7\n+     __ ldr(r7, Address(r5, ArrayKlass::element_klass_offset()));\n+\n+    \/\/ flat value array needs exact type match\n+    \/\/ is \"r1 == r7\" (value subclass == array element superclass)\n+\n+     __ cmp(r7, r1);\n+     __ br(Assembler::EQ, is_type_ok);\n+\n+     __ b(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n+\n+     __ bind(is_type_ok);\n+    \/\/ r1: value's klass\n+    \/\/ r3: array\n+    \/\/ r5: array klass\n+    __ test_klass_is_empty_inline_type(r1, r7, done);\n+\n+    \/\/ calc dst for copy\n+    __ ldrw(r7, at_tos_p1()); \/\/ index\n+    __ data_for_value_array_index(r3, r5, r7, r7);\n+\n+    \/\/ ...and src for copy\n+    __ ldr(r6, at_tos());  \/\/ value\n+    __ data_for_oop(r6, r6, r1);\n+\n+    __ mov(r4, r1);  \/\/ Shuffle arguments to avoid conflict with c_rarg1\n+    __ access_value_copy(IN_HEAP, r6, r7, r4);\n+  }\n@@ -1958,2 +2037,1 @@\n-void TemplateTable::if_acmp(Condition cc)\n-{\n+void TemplateTable::if_acmp(Condition cc) {\n@@ -1962,1 +2040,1 @@\n-  Label not_taken;\n+  Label taken, not_taken;\n@@ -1964,0 +2042,38 @@\n+\n+  __ profile_acmp(r2, r1, r0, r4);\n+\n+  Register is_inline_type_mask = rscratch1;\n+  __ mov(is_inline_type_mask, markWord::inline_type_pattern);\n+\n+  if (EnableValhalla) {\n+    __ cmp(r1, r0);\n+    __ br(Assembler::EQ, (cc == equal) ? taken : not_taken);\n+\n+    \/\/ might be substitutable, test if either r0 or r1 is null\n+    __ andr(r2, r0, r1);\n+    __ cbz(r2, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ and both are values ?\n+    __ ldr(r2, Address(r1, oopDesc::mark_offset_in_bytes()));\n+    __ andr(r2, r2, is_inline_type_mask);\n+    __ ldr(r4, Address(r0, oopDesc::mark_offset_in_bytes()));\n+    __ andr(r4, r4, is_inline_type_mask);\n+    __ andr(r2, r2, r4);\n+    __ cmp(r2,  is_inline_type_mask);\n+    __ br(Assembler::NE, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ same value klass ?\n+    __ load_metadata(r2, r1);\n+    __ load_metadata(r4, r0);\n+    __ cmp(r2, r4);\n+    __ br(Assembler::NE, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ Know both are the same type, let's test for substitutability...\n+    if (cc == equal) {\n+      invoke_is_substitutable(r0, r1, taken, not_taken);\n+    } else {\n+      invoke_is_substitutable(r0, r1, not_taken, taken);\n+    }\n+    __ stop(\"Not reachable\");\n+  }\n+\n@@ -1966,0 +2082,1 @@\n+  __ bind(taken);\n@@ -1968,1 +2085,10 @@\n-  __ profile_not_taken_branch(r0);\n+  __ profile_not_taken_branch(r0, true);\n+}\n+\n+void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,\n+                                            Label& is_subst, Label& not_subst) {\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);\n+  \/\/ Restored... r0 answer, jmp to outcome...\n+  __ cbz(r0, not_subst);\n+  __ b(is_subst);\n@@ -1971,0 +2097,1 @@\n+\n@@ -2308,1 +2435,1 @@\n-                                          ConstantPoolCacheEntry::f2_offset())));\n+                                      ConstantPoolCacheEntry::f2_offset())));\n@@ -2311,1 +2438,1 @@\n-                                           ConstantPoolCacheEntry::flags_offset())));\n+                                         ConstantPoolCacheEntry::flags_offset())));\n@@ -2409,0 +2536,2 @@\n+  const Register klass = r5;\n+  const Register inline_klass = r7;\n@@ -2441,0 +2570,5 @@\n+  if (!is_static) {\n+    __ ldr(klass, Address(cache, in_bytes(ConstantPoolCache::base_offset() +\n+                                          ConstantPoolCacheEntry::f1_offset())));\n+  }\n+\n@@ -2443,2 +2577,1 @@\n-  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,\n-           ConstantPoolCacheEntry::tos_state_bits);\n+  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift, ConstantPoolCacheEntry::tos_state_bits);\n@@ -2479,4 +2612,70 @@\n-  do_oop_load(_masm, field, r0, IN_HEAP);\n-  __ push(atos);\n-  if (rc == may_rewrite) {\n-    patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+  if (!EnablePrimitiveClasses) {\n+    do_oop_load(_masm, field, r0, IN_HEAP);\n+    __ push(atos);\n+    if (rc == may_rewrite) {\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+    }\n+    __ b(Done);\n+  } else { \/\/ Valhalla\n+    if (is_static) {\n+      __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+      Label is_null_free_inline_type, uninitialized;\n+      \/\/ Issue below if the static field has not been initialized yet\n+      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_null_free_inline_type);\n+        \/\/ field is not a null free inline type\n+        __ push(atos);\n+        __ b(Done);\n+      \/\/ field is a null free inline type, must not return null even if uninitialized\n+      __ bind(is_null_free_inline_type);\n+        __ cbz(r0, uninitialized);\n+          __ push(atos);\n+          __ b(Done);\n+        __ bind(uninitialized);\n+          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+          Label slow_case, finish;\n+          __ ldrb(rscratch1, Address(cache, InstanceKlass::init_state_offset()));\n+          __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);\n+          __ br(Assembler::NE, slow_case);\n+          __ get_default_value_oop(klass, off \/* temp *\/, r0);\n+        __ b(finish);\n+        __ bind(slow_case);\n+          __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, raw_flags);\n+          __ bind(finish);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+          __ b(Done);\n+    } else {\n+      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_inline_type);\n+        \/\/ Non-inline field case\n+        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+        __ push(atos);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+        }\n+        __ b(Done);\n+      __ bind(is_inline_type);\n+        __ test_field_is_inlined(raw_flags, noreg \/* temp *\/, is_inlined);\n+         \/\/ field is not inlined\n+          __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+          __ cbnz(r0, nonnull);\n+            __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+            __ get_inline_type_field_klass(klass, raw_flags, inline_klass);\n+            __ get_default_value_oop(inline_klass, klass \/* temp *\/, r0);\n+          __ bind(nonnull);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+          __ b(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n+          __ mov(r0, obj);\n+          __ read_inlined_field(klass, raw_flags, off, inline_klass \/* temp *\/, r0);\n+          __ verify_oop(r0);\n+          __ push(atos);\n+      __ bind(rewrite_inline);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);\n+      }\n+      __ b(Done);\n+    }\n@@ -2484,1 +2683,0 @@\n-  __ b(Done);\n@@ -2654,0 +2852,1 @@\n+  const Register flags2 = r6;\n@@ -2655,0 +2854,1 @@\n+  const Register inline_klass = r5;\n@@ -2676,0 +2876,2 @@\n+  __ mov(flags2, flags);\n+\n@@ -2718,8 +2920,54 @@\n-    __ pop(atos);\n-    if (!is_static) pop_and_check_object(obj);\n-    \/\/ Store into the field\n-    do_oop_store(_masm, field, r0, IN_HEAP);\n-    if (rc == may_rewrite) {\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);\n-    }\n-    __ b(Done);\n+     if (!EnablePrimitiveClasses) {\n+      __ pop(atos);\n+      if (!is_static) pop_and_check_object(obj);\n+      \/\/ Store into the field\n+      do_oop_store(_masm, field, r0, IN_HEAP);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);\n+      }\n+      __ b(Done);\n+     } else { \/\/ Valhalla\n+      __ pop(atos);\n+      if (is_static) {\n+        Label is_inline_type;\n+         __ test_field_is_not_null_free_inline_type(flags2, noreg \/* temp *\/, is_inline_type);\n+         __ null_check(r0);\n+         __ bind(is_inline_type);\n+         do_oop_store(_masm, field, r0, IN_HEAP);\n+         __ b(Done);\n+      } else {\n+        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        __ test_field_is_null_free_inline_type(flags2, noreg \/*temp*\/, is_inline_type);\n+        \/\/ Not an inline type\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, r0, IN_HEAP);\n+        __ bind(rewrite_not_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, r19, true, byte_no);\n+        }\n+        __ b(Done);\n+        \/\/ Implementation of the inline type semantic\n+        __ bind(is_inline_type);\n+        __ null_check(r0);\n+        __ test_field_is_inlined(flags2, noreg \/*temp*\/, is_inlined);\n+        \/\/ field is not inlined\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, r0, IN_HEAP);\n+        __ b(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+        pop_and_check_object(obj);\n+        assert_different_registers(r0, inline_klass, obj, off);\n+        __ load_klass(inline_klass, r0);\n+        __ data_for_oop(r0, r0, inline_klass);\n+        __ add(obj, obj, off);\n+        __ access_value_copy(IN_HEAP, r0, obj, inline_klass);\n+        __ bind(rewrite_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_qputfield, bc, r19, true, byte_no);\n+        }\n+        __ b(Done);\n+      }\n+     }  \/\/ Valhalla\n@@ -2865,0 +3113,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -2891,0 +3140,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -2944,0 +3194,17 @@\n+  case Bytecodes::_fast_qputfield: \/\/fall through\n+   {\n+      Label is_inlined, done;\n+      __ null_check(r0);\n+      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n+      \/\/ field is not inlined\n+      do_oop_store(_masm, field, r0, IN_HEAP);\n+      __ b(done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+      __ load_klass(r4, r0);\n+      __ data_for_oop(r0, r0, r4);\n+      __ lea(rscratch1, field);\n+      __ access_value_copy(IN_HEAP, r0, rscratch1, r4);\n+      __ bind(done);\n+    }\n+    break;\n@@ -3041,0 +3308,26 @@\n+  case Bytecodes::_fast_qgetfield:\n+    {\n+      Register index = r4, klass = r5, inline_klass = r6, tmp = r7;\n+      Label is_inlined, nonnull, Done;\n+      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n+        \/\/ field is not inlined\n+        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+        __ cbnz(r0, nonnull);\n+          __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n+          __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n+                                             ConstantPoolCacheEntry::f1_offset())));\n+          __ get_inline_type_field_klass(klass, index, inline_klass);\n+          __ get_default_value_oop(inline_klass, tmp \/* temp *\/, r0);\n+        __ bind(nonnull);\n+        __ verify_oop(r0);\n+        __ b(Done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+        __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n+        __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n+                                           ConstantPoolCacheEntry::f1_offset())));\n+        __ read_inlined_field(klass, index, r1, tmp \/* temp *\/, r0);\n+        __ verify_oop(r0);\n+      __ bind(Done);\n+    }\n+    break;\n@@ -3471,0 +3764,1 @@\n+  Label is_not_value;\n@@ -3487,0 +3781,8 @@\n+  __ ldrb(rscratch1, Address(r4, InstanceKlass::kind_offset()));\n+  __ cmp(rscratch1, (u1)InlineKlassKind);\n+  __ br(Assembler::NE, is_not_value);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n+\n+  __ bind(is_not_value);\n+\n@@ -3493,57 +3795,2 @@\n-  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n-  __ ldrw(r3,\n-          Address(r4,\n-                  Klass::layout_helper_offset()));\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n-  __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);\n-\n-  \/\/ Allocate the instance:\n-  \/\/  If TLAB is enabled:\n-  \/\/    Try to allocate in the TLAB.\n-  \/\/    If fails, go to the slow path.\n-  \/\/    Initialize the allocation.\n-  \/\/    Exit.\n-  \/\/\n-  \/\/  Go to slow path.\n-\n-  if (UseTLAB) {\n-    __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);\n-\n-    if (ZeroTLAB) {\n-      \/\/ the fields have been already cleared\n-      __ b(initialize_header);\n-    }\n-\n-    \/\/ The object is initialized before the header.  If the object size is\n-    \/\/ zero, go directly to the header initialization.\n-    __ sub(r3, r3, sizeof(oopDesc));\n-    __ cbz(r3, initialize_header);\n-\n-    \/\/ Initialize object fields\n-    {\n-      __ add(r2, r0, sizeof(oopDesc));\n-      Label loop;\n-      __ bind(loop);\n-      __ str(zr, Address(__ post(r2, BytesPerLong)));\n-      __ sub(r3, r3, BytesPerLong);\n-      __ cbnz(r3, loop);\n-    }\n-\n-    \/\/ initialize object header only.\n-    __ bind(initialize_header);\n-    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n-    __ store_klass_gap(r0, zr);  \/\/ zero klass gap for compressed oops\n-    __ store_klass(r0, r4);      \/\/ store klass last\n-\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false);\n-      \/\/ Trigger dtrace event for fastpath\n-      __ push(atos); \/\/ save the return value\n-      __ call_VM_leaf(\n-           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), r0);\n-      __ pop(atos); \/\/ restore the return value\n-\n-    }\n-    __ b(done);\n-  }\n+  __ allocate_instance(r4, r0, r3, r1, true, slow_case);\n+  __ b(done);\n@@ -3564,0 +3811,29 @@\n+void TemplateTable::aconst_init() {\n+  transition(vtos, atos);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  __ get_constant_pool(c_rarg1);\n+  call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n+          c_rarg1, c_rarg2);\n+  __ verify_oop(r0);\n+  \/\/ Must prevent reordering of stores for object initialization with stores that publish the new object.\n+  __ membar(Assembler::StoreStore);\n+}\n+\n+void TemplateTable::withfield() {\n+  transition(vtos, atos);\n+  resolve_cache_and_index(f2_byte, c_rarg1 \/*cache*\/, c_rarg2 \/*index*\/, sizeof(u2));\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  \/\/ n.b. unlike x86 cache is now rcpool plus the indexed offset\n+  __ lea(c_rarg1, Address(c_rarg1, in_bytes(cp_base_offset)));\n+\n+  __ lea(c_rarg2, at_tos());\n+  call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), c_rarg1, c_rarg2);\n+  \/\/ new value type is returned in r1\n+  \/\/ stack adjustment is returned in r0\n+  __ verify_oop(r1);\n+  __ add(esp, esp, r0);\n+  __ mov(r0, r1);\n+}\n+\n@@ -3604,0 +3880,1 @@\n+  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -3635,0 +3912,3 @@\n+  __ b(done);\n+  __ bind(is_null);\n+\n@@ -3637,4 +3917,16 @@\n-    __ b(done);\n-    __ bind(is_null);\n-  } else {\n-    __ bind(is_null);   \/\/ same as 'done'\n+\n+  if (EnablePrimitiveClasses) {\n+    \/\/ Get cpool & tags index\n+    __ get_cpool_and_tags(r2, r3); \/\/ r2=cpool, r3=tags array\n+    __ get_unsigned_2_byte_index_at_bcp(r19, 1); \/\/ r19=index\n+     \/\/ See if bytecode has already been quicked\n+    __ add(rscratch1, r3, Array<u1>::base_offset_in_bytes());\n+    __ lea(r1, Address(rscratch1, r19));\n+    __ ldarb(r1, r1);\n+    \/\/ See if CP entry is a Q-descriptor\n+    __ andr (r1, r1, JVM_CONSTANT_QDescBit);\n+    __ cmp(r1, (u1) JVM_CONSTANT_QDescBit);\n+    __ br(Assembler::NE, done);\n+    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+  }\n+\n@@ -3658,0 +3950,1 @@\n+  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -3761,0 +4054,4 @@\n+  Label is_inline_type;\n+  __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+  __ test_markword_is_inline_type(rscratch1, is_inline_type);\n+\n@@ -3854,0 +4151,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -3864,0 +4166,12 @@\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  Label has_identity;\n+  __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+  __ mov(rscratch2, is_inline_type_mask);\n+  __ andr(rscratch1, rscratch1, rscratch2);\n+  __ cmp(rscratch1, rscratch2);\n+  __ br(Assembler::NE, has_identity);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n+  __ bind(has_identity);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":414,"deletions":100,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -3207,0 +3207,3 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);\n+define_pd_global(bool, InlineTypeReturnedAsFields, false);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1818,1 +1818,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n@@ -1859,1 +1859,1 @@\n-    profile_obj_type(ret, R28_mdx, -in_bytes(ReturnTypeEntry::size()), tmp1, tmp2);\n+    profile_obj_type(ret, R28_mdx, -in_bytes(SingleTypeEntry::size()), tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -198,1 +200,1 @@\n-    if (const_opr->type() == T_OBJECT) {\n+    if (const_opr->type() == T_OBJECT || const_opr->type() == T_PRIMITIVE_OBJECT) {\n@@ -482,1 +484,1 @@\n-  __ remove_frame(initial_frame_size_in_bytes());\n+  __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());\n@@ -520,0 +522,16 @@\n+  ciMethod* method = compilation()->method();\n+  if (InlineTypeReturnedAsFields && method->return_type()->is_inlinetype()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n+    if (vk->can_be_returned_as_fields()) {\n+#ifndef _LP64\n+      Unimplemented();\n+#else\n+      address unpack_handler = vk->unpack_handler();\n+      assert(unpack_handler != NULL, \"must be\");\n+      __ call(RuntimeAddress(unpack_handler));\n+      \/\/ At this point, rax points to the value object (for interpreter or C1 caller).\n+      \/\/ The fields of the object are copied into registers (for C2 caller).\n+#endif\n+    }\n+  }\n+\n@@ -521,1 +539,1 @@\n-  __ remove_frame(initial_frame_size_in_bytes());\n+  __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());\n@@ -543,0 +561,4 @@\n+int LIR_Assembler::store_inline_type_fields_to_buf(ciInlineKlass* vk) {\n+  return (__ store_inline_type_fields_to_buf(vk, false));\n+}\n+\n@@ -603,0 +625,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -693,0 +716,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -734,0 +758,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -822,1 +847,1 @@\n-    if (src->type() == T_OBJECT) {\n+    if (src->type() == T_OBJECT || src->type() == T_PRIMITIVE_OBJECT) {\n@@ -1008,0 +1033,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1180,1 +1206,1 @@\n-  if (addr->base()->type() == T_OBJECT) {\n+  if (addr->base()->type() == T_OBJECT || addr->base()->type() == T_PRIMITIVE_OBJECT) {\n@@ -1241,0 +1267,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1617,1 +1644,1 @@\n-  if (UseSlowPath ||\n+  if (UseSlowPath || op->type() == T_PRIMITIVE_OBJECT ||\n@@ -1716,14 +1743,16 @@\n-  __ cmpptr(obj, NULL_WORD);\n-  if (op->should_profile()) {\n-    Label not_null;\n-    __ jccb(Assembler::notEqual, not_null);\n-    \/\/ Object is null; update MDO and exit\n-    Register mdo  = klass_RInfo;\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address data_addr(mdo, md->byte_offset_of_slot(data, DataLayout::flags_offset()));\n-    int header_bits = BitData::null_seen_byte_constant();\n-    __ orb(data_addr, header_bits);\n-    __ jmp(*obj_is_null);\n-    __ bind(not_null);\n-  } else {\n-    __ jcc(Assembler::equal, *obj_is_null);\n+  if (op->need_null_check()) {\n+    __ cmpptr(obj, NULL_WORD);\n+    if (op->should_profile()) {\n+      Label not_null;\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n+      Register mdo  = klass_RInfo;\n+      __ mov_metadata(mdo, md->constant_encoding());\n+      Address data_addr(mdo, md->byte_offset_of_slot(data, DataLayout::flags_offset()));\n+      int header_bits = BitData::null_seen_byte_constant();\n+      __ orb(data_addr, header_bits);\n+      __ jmp(*obj_is_null);\n+      __ bind(not_null);\n+    } else {\n+      __ jcc(Assembler::equal, *obj_is_null);\n+    }\n@@ -1941,0 +1970,124 @@\n+void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {\n+  \/\/ We are loading\/storing from\/to an array that *may* be flattened (the\n+  \/\/ declared type is Object[], abstract[], interface[] or VT.ref[]).\n+  \/\/ If this array is flattened, take the slow path.\n+  Register klass = op->tmp()->as_register();\n+  if (UseArrayMarkWordCheck) {\n+    __ test_flattened_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n+    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ testl(klass, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    __ jcc(Assembler::notZero, *op->stub()->entry());\n+  }\n+  if (!op->value()->is_illegal()) {\n+    \/\/ The array is not flattened, but it might be null-free. If we are storing\n+    \/\/ a null into a null-free array, take the slow path (which will throw NPE).\n+    Label skip;\n+    __ cmpptr(op->value()->as_register(), NULL_WORD);\n+    __ jcc(Assembler::notEqual, skip);\n+    if (UseArrayMarkWordCheck) {\n+      __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+    } else {\n+      __ testl(klass, Klass::_lh_null_free_array_bit_inplace);\n+      __ jcc(Assembler::notZero, *op->stub()->entry());\n+    }\n+    __ bind(skip);\n+  }\n+}\n+\n+void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {\n+  \/\/ We are storing into an array that *may* be null-free (the declared type is\n+  \/\/ Object[], abstract[], interface[] or VT.ref[]).\n+  if (UseArrayMarkWordCheck) {\n+    Label test_mark_word;\n+    Register tmp = op->tmp()->as_register();\n+    __ movptr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n+    __ testl(tmp, markWord::unlocked_value);\n+    __ jccb(Assembler::notZero, test_mark_word);\n+    __ load_prototype_header(tmp, op->array()->as_register(), rscratch1);\n+    __ bind(test_mark_word);\n+    __ testl(tmp, markWord::null_free_array_bit_in_place);\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    Register klass = op->tmp()->as_register();\n+    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n+    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n+    __ testl(klass, Klass::_lh_null_free_array_bit_inplace);\n+  }\n+}\n+\n+void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {\n+  Label L_oops_equal;\n+  Label L_oops_not_equal;\n+  Label L_end;\n+\n+  Register left  = op->left()->as_register();\n+  Register right = op->right()->as_register();\n+\n+  __ cmpptr(left, right);\n+  __ jcc(Assembler::equal, L_oops_equal);\n+\n+  \/\/ (1) Null check -- if one of the operands is null, the other must not be null (because\n+  \/\/     the two references are not equal), so they are not substitutable,\n+  \/\/     FIXME: do null check only if the operand is nullable\n+  __ testptr(left, right);\n+  __ jcc(Assembler::zero, L_oops_not_equal);\n+\n+  ciKlass* left_klass = op->left_klass();\n+  ciKlass* right_klass = op->right_klass();\n+\n+  \/\/ (2) Inline type check -- if either of the operands is not a inline type,\n+  \/\/     they are not substitutable. We do this only if we are not sure that the\n+  \/\/     operands are inline type\n+  if ((left_klass == NULL || right_klass == NULL) ||\/\/ The klass is still unloaded, or came from a Phi node.\n+      !left_klass->is_inlinetype() || !right_klass->is_inlinetype()) {\n+    Register tmp1  = op->tmp1()->as_register();\n+    __ movptr(tmp1, (intptr_t)markWord::inline_type_pattern);\n+    __ andptr(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));\n+    __ cmpptr(tmp1, (intptr_t)markWord::inline_type_pattern);\n+    __ jcc(Assembler::notEqual, L_oops_not_equal);\n+  }\n+\n+  \/\/ (3) Same klass check: if the operands are of different klasses, they are not substitutable.\n+  if (left_klass != NULL && left_klass->is_inlinetype() && left_klass == right_klass) {\n+    \/\/ No need to load klass -- the operands are statically known to be the same inline klass.\n+    __ jmp(*op->stub()->entry());\n+  } else {\n+    Register left_klass_op = op->left_klass_op()->as_register();\n+    Register right_klass_op = op->right_klass_op()->as_register();\n+\n+    if (UseCompressedClassPointers) {\n+      __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));\n+      __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));\n+      __ cmpl(left_klass_op, right_klass_op);\n+    } else {\n+      __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));\n+      __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));\n+      __ cmpptr(left_klass_op, right_klass_op);\n+    }\n+\n+    __ jcc(Assembler::equal, *op->stub()->entry()); \/\/ same klass -> do slow check\n+    \/\/ fall through to L_oops_not_equal\n+  }\n+\n+  __ bind(L_oops_not_equal);\n+  move(op->not_equal_result(), op->result_opr());\n+  __ jmp(L_end);\n+\n+  __ bind(L_oops_equal);\n+  move(op->equal_result(), op->result_opr());\n+  __ jmp(L_end);\n+\n+  \/\/ We've returned from the stub. RAX contains 0x0 IFF the two\n+  \/\/ operands are not substitutable. (Don't compare against 0x1 in case the\n+  \/\/ C compiler is naughty)\n+  __ bind(*op->stub()->continuation());\n+  __ cmpl(rax, 0);\n+  __ jcc(Assembler::equal, L_oops_not_equal); \/\/ (call_stub() == 0x0) -> not_equal\n+  move(op->equal_result(), op->result_opr()); \/\/ (call_stub() != 0x0) -> equal\n+  \/\/ fall-through\n+  __ bind(L_end);\n+}\n@@ -2001,0 +2154,15 @@\n+void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {\n+  assert(dst->is_cpu_register(), \"must be\");\n+  assert(dst->type() == src->type(), \"must be\");\n+\n+  if (src->is_cpu_register()) {\n+    reg2reg(src, dst);\n+  } else if (src->is_stack()) {\n+    stack2reg(src, dst, dst->type());\n+  } else if (src->is_constant()) {\n+    const2reg(src, dst, lir_patch_none, NULL);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n@@ -2869,1 +3037,1 @@\n-  add_call_info(code_offset(), op->info());\n+  add_call_info(code_offset(), op->info(), op->maybe_return_as_fields());\n@@ -2876,1 +3044,1 @@\n-  add_call_info(code_offset(), op->info());\n+  add_call_info(code_offset(), op->info(), op->maybe_return_as_fields());\n@@ -3057,0 +3225,26 @@\n+void LIR_Assembler::arraycopy_inlinetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {\n+  if (null_check) {\n+    __ testptr(obj, obj);\n+    __ jcc(Assembler::zero, *slow_path->entry());\n+  }\n+  if (UseArrayMarkWordCheck) {\n+    if (is_dest) {\n+      __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n+    } else {\n+      __ test_flattened_array_oop(obj, tmp, *slow_path->entry());\n+    }\n+  } else {\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(tmp, obj, tmp_load_klass);\n+    __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));\n+    if (is_dest) {\n+      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains NULLs.\n+      __ testl(tmp, Klass::_lh_null_free_array_bit_inplace);\n+    } else {\n+      __ testl(tmp, Klass::_lh_array_tag_flat_value_bit_inplace);\n+    }\n+    __ jcc(Assembler::notZero, *slow_path->entry());\n+  }\n+}\n+\n+\n@@ -3075,0 +3269,6 @@\n+  if (flags & LIR_OpArrayCopy::always_slow_path) {\n+    __ jmp(*stub->entry());\n+    __ bind(*stub->continuation());\n+    return;\n+  }\n+\n@@ -3168,0 +3368,8 @@\n+  \/\/ Handle inline type arrays\n+  if (flags & LIR_OpArrayCopy::src_inlinetype_check) {\n+    arraycopy_inlinetype_check(src, tmp, stub, false, (flags & LIR_OpArrayCopy::src_null_check));\n+  }\n+  if (flags & LIR_OpArrayCopy::dst_inlinetype_check) {\n+    arraycopy_inlinetype_check(dst, tmp, stub, true, (flags & LIR_OpArrayCopy::dst_null_check));\n+  }\n+\n@@ -3768,0 +3976,20 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Register obj = op->obj()->as_register();\n+  Register tmp = op->tmp()->as_pointer_register();\n+  Address mdo_addr = as_Address(op->mdp()->as_address_ptr());\n+  bool not_null = op->not_null();\n+  int flag = op->flag();\n+\n+  Label not_inline_type;\n+  if (!not_null) {\n+    __ testptr(obj, obj);\n+    __ jccb(Assembler::zero, not_inline_type);\n+  }\n+\n+  __ test_oop_is_not_inline_type(obj, tmp, not_inline_type);\n+\n+  __ orb(mdo_addr, flag);\n+\n+  __ bind(not_inline_type);\n+}\n+\n@@ -4031,0 +4259,3 @@\n+void LIR_Assembler::check_orig_pc() {\n+  __ cmpptr(frame_map()->address_for_orig_pc_addr(), NULL_WORD);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":253,"deletions":22,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/frame.inline.hpp\"\n@@ -67,0 +68,4 @@\n+  if (EnableValhalla) {\n+    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+    andptr(hdr, ~((int) markWord::inline_type_bit_in_place));\n+  }\n@@ -148,1 +153,9 @@\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n+  if (EnableValhalla) {\n+    \/\/ Need to copy markWord::prototype header for klass\n+    assert_different_registers(obj, klass, len, t1, t2);\n+    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+  } else {\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n+  }\n@@ -301,0 +314,12 @@\n+void C1_MacroAssembler::build_frame_helper(int frame_size_in_bytes, int sp_offset_for_orig_pc, int sp_inc, bool reset_orig_pc, bool needs_stack_repair) {\n+  push(rbp);\n+  if (PreserveFramePointer) {\n+    mov(rbp, rsp);\n+  }\n+#if !defined(_LP64) && defined(COMPILER2)\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n+      \/\/ c2 leaves fpu stack dirty. Clean it on entry\n+      empty_FPU_stack();\n+    }\n+#endif \/\/ !_LP64 && COMPILER2\n+  decrement(rsp, frame_size_in_bytes);\n@@ -302,2 +327,13 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n-  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n+  if (needs_stack_repair) {\n+    \/\/ Save stack increment (also account for fixed framesize and rbp)\n+    assert((sp_inc & (StackAlignmentInBytes-1)) == 0, \"stack increment not aligned\");\n+    int real_frame_size = sp_inc + frame_size_in_bytes + wordSize;\n+    movptr(Address(rsp, frame_size_in_bytes - wordSize), real_frame_size);\n+  }\n+  if (reset_orig_pc) {\n+    \/\/ Zero orig_pc to detect deoptimization during buffering in the entry points\n+    movptr(Address(rsp, sp_offset_for_orig_pc), 0);\n+  }\n+}\n+\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, bool needs_stack_repair, bool has_scalarized_args, Label* verified_inline_entry_label) {\n@@ -309,0 +345,1 @@\n+  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n@@ -311,11 +348,1 @@\n-  push(rbp);\n-  if (PreserveFramePointer) {\n-    mov(rbp, rsp);\n-  }\n-#if !defined(_LP64) && defined(COMPILER2)\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n-    \/\/ c2 leaves fpu stack dirty. Clean it on entry\n-    empty_FPU_stack();\n-  }\n-#endif \/\/ !_LP64 && COMPILER2\n-  decrement(rsp, frame_size_in_bytes); \/\/ does not emit code for frame_size == 0\n+  build_frame_helper(frame_size_in_bytes, sp_offset_for_orig_pc, 0, has_scalarized_args, needs_stack_repair);\n@@ -326,5 +353,4 @@\n-}\n-\n-void C1_MacroAssembler::remove_frame(int frame_size_in_bytes) {\n-  increment(rsp, frame_size_in_bytes);  \/\/ Does not emit code for frame_size == 0\n-  pop(rbp);\n+  if (verified_inline_entry_label != NULL) {\n+    \/\/ Jump here from the scalarized entry points that already created the frame.\n+    bind(*verified_inline_entry_label);\n+  }\n@@ -334,1 +360,0 @@\n-\n@@ -351,0 +376,58 @@\n+int C1_MacroAssembler::scalarized_entry(const CompiledEntrySignature* ces, int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, Label& verified_inline_entry_label, bool is_inline_ro_entry) {\n+  assert(InlineTypePassFieldsAsArgs, \"sanity\");\n+  \/\/ Make sure there is enough stack space for this method's activation.\n+  assert(bang_size_in_bytes >= frame_size_in_bytes, \"stack bang size incorrect\");\n+  generate_stack_overflow_check(bang_size_in_bytes);\n+\n+  GrowableArray<SigEntry>* sig    = &ces->sig();\n+  GrowableArray<SigEntry>* sig_cc = is_inline_ro_entry ? &ces->sig_cc_ro() : &ces->sig_cc();\n+  VMRegPair* regs      = ces->regs();\n+  VMRegPair* regs_cc   = is_inline_ro_entry ? ces->regs_cc_ro() : ces->regs_cc();\n+  int args_on_stack    = ces->args_on_stack();\n+  int args_on_stack_cc = is_inline_ro_entry ? ces->args_on_stack_cc_ro() : ces->args_on_stack_cc();\n+\n+  assert(sig->length() <= sig_cc->length(), \"Zero-sized inline class not allowed!\");\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig_cc->length());\n+  int args_passed = sig->length();\n+  int args_passed_cc = SigEntry::fill_sig_bt(sig_cc, sig_bt);\n+\n+  \/\/ Create a temp frame so we can call into the runtime. It must be properly set up to accommodate GC.\n+  build_frame_helper(frame_size_in_bytes, sp_offset_for_orig_pc, 0, true, ces->c1_needs_stack_repair());\n+\n+  \/\/ The runtime call might safepoint, make sure nmethod entry barrier is executed\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  \/\/ C1 code is not hot enough to micro optimize the nmethod entry barrier with an out-of-line stub\n+  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+\n+  \/\/ FIXME -- call runtime only if we cannot in-line allocate all the incoming inline type args.\n+  movptr(rbx, (intptr_t)(ces->method()));\n+  if (is_inline_ro_entry) {\n+    call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id)));\n+  } else {\n+    call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_id)));\n+  }\n+  int rt_call_offset = offset();\n+\n+  \/\/ Remove the temp frame\n+  addptr(rsp, frame_size_in_bytes);\n+  pop(rbp);\n+\n+  \/\/ Check if we need to extend the stack for packing\n+  int sp_inc = 0;\n+  if (args_on_stack > args_on_stack_cc) {\n+    sp_inc = extend_stack_for_inline_args(args_on_stack);\n+  }\n+\n+  shuffle_inline_args(true, is_inline_ro_entry, sig_cc,\n+                      args_passed_cc, args_on_stack_cc, regs_cc, \/\/ from\n+                      args_passed, args_on_stack, regs,          \/\/ to\n+                      sp_inc, rax);\n+\n+  \/\/ Create the real frame. Below jump will then skip over the stack banging and frame\n+  \/\/ setup code in the verified_inline_entry (which has a different real_frame_size).\n+  build_frame_helper(frame_size_in_bytes, sp_offset_for_orig_pc, sp_inc, false, ces->c1_needs_stack_repair());\n+\n+  jmp(verified_inline_entry_label);\n+  return rt_call_offset;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":103,"deletions":20,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -48,1 +48,20 @@\n-void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {\n+void C2_MacroAssembler::verified_entry(Compile* C, int sp_inc) {\n+  if (C->clinit_barrier_on_entry()) {\n+    assert(VM_Version::supports_fast_class_init_checks(), \"sanity\");\n+    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n+\n+    Label L_skip_barrier;\n+    Register klass = rscratch1;\n+\n+    mov_metadata(klass, C->method()->holder()->constant_encoding());\n+    clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+\n+    jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+\n+    bind(L_skip_barrier);\n+  }\n+\n+  int framesize = C->output()->frame_size_in_bytes();\n+  int bangsize = C->output()->bang_size_in_bytes();\n+  bool fp_mode_24b = false;\n+  int stack_bang_size = C->output()->need_stack_bang(bangsize) ? bangsize : 0;\n@@ -101,0 +120,6 @@\n+  if (C->needs_stack_repair()) {\n+    \/\/ Save stack increment just below the saved rbp (also account for fixed framesize and rbp)\n+    assert((sp_inc & (StackAlignmentInBytes-1)) == 0, \"stack increment not aligned\");\n+    movptr(Address(rsp, framesize - wordSize), sp_inc + framesize + wordSize);\n+  }\n+\n@@ -129,0 +154,1 @@\n+}\n@@ -130,16 +156,14 @@\n-  if (!is_stub) {\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n- #ifdef _LP64\n-    if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n-      \/\/ We put the non-hot code of the nmethod entry barrier out-of-line in a stub.\n-      Label dummy_slow_path;\n-      Label dummy_continuation;\n-      Label* slow_path = &dummy_slow_path;\n-      Label* continuation = &dummy_continuation;\n-      if (!Compile::current()->output()->in_scratch_emit_size()) {\n-        \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n-        continuation = &stub->continuation();\n-      }\n-      bs->nmethod_entry_barrier(this, slow_path, continuation);\n+void C2_MacroAssembler::entry_barrier() {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+#ifdef _LP64\n+  if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n+    \/\/ We put the non-hot code of the nmethod entry barrier out-of-line in a stub.\n+    Label dummy_slow_path;\n+    Label dummy_continuation;\n+    Label* slow_path = &dummy_slow_path;\n+    Label* continuation = &dummy_continuation;\n+    if (!Compile::current()->output()->in_scratch_emit_size()) {\n+      \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n+      C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n+      slow_path = &stub->slow_path();\n+      continuation = &stub->continuation();\n@@ -147,0 +171,2 @@\n+    bs->nmethod_entry_barrier(this, slow_path, continuation);\n+  }\n@@ -148,2 +174,2 @@\n-    \/\/ Don't bother with out-of-line nmethod entry barrier stub for x86_32.\n-    bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  \/\/ Don't bother with out-of-line nmethod entry barrier stub for x86_32.\n+  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n@@ -151,1 +177,0 @@\n-  }\n@@ -615,0 +640,4 @@\n+    if (EnableValhalla) {\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      andptr(tmpReg, ~((int) markWord::inline_type_bit_in_place));\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":49,"deletions":20,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  intptr_t* repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const;\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+define_pd_global(bool, InlineTypePassFieldsAsArgs, LP64_ONLY(true) NOT_LP64(false));\n+define_pd_global(bool, InlineTypeReturnedAsFields, LP64_ONLY(true) NOT_LP64(false));\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n@@ -56,0 +58,4 @@\n+#include \"vmreg_x86.inline.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/output.hpp\"\n+#endif\n@@ -1691,0 +1697,4 @@\n+void MacroAssembler::super_call_VM_leaf(address entry_point) {\n+  MacroAssembler::call_VM_leaf_base(entry_point, 1);\n+}\n+\n@@ -2869,0 +2879,140 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  andptr(markword, markWord::inline_type_mask_in_place);\n+  cmpptr(markword, markWord::inline_type_pattern);\n+  jcc(Assembler::equal, is_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n+  movl(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  testl(temp_reg, JVM_ACC_VALUE);\n+  jcc(Assembler::notZero, is_inline_type);\n+}\n+\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+  testptr(object, object);\n+  jcc(Assembler::zero, not_inline_type);\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  movptr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  andptr(tmp, is_inline_type_mask);\n+  cmpptr(tmp, is_inline_type_mask);\n+  jcc(Assembler::notEqual, not_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(klass, temp_reg, done_check);\n+    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  movl(temp_reg, Address(klass, InstanceKlass::misc_status_offset()));\n+  testl(temp_reg, InstanceKlassMiscStatus::is_empty_inline_type_value());\n+  jcc(Assembler::notZero, is_empty_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n+  movl(temp_reg, flags);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n+  andl(temp_reg, 0x1);\n+  testl(temp_reg, temp_reg);\n+  jcc(Assembler::notZero, is_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n+  movl(temp_reg, flags);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n+  andl(temp_reg, 0x1);\n+  testl(temp_reg, temp_reg);\n+  jcc(Assembler::zero, not_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label& is_inlined) {\n+  movl(temp_reg, flags);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_inlined_shift);\n+  andl(temp_reg, 0x1);\n+  testl(temp_reg, temp_reg);\n+  jcc(Assembler::notZero, is_inlined);\n+}\n+\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  movptr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  testl(temp_reg, markWord::unlocked_value);\n+  jccb(Assembler::notZero, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  push(rscratch1);\n+  load_prototype_header(temp_reg, oop, rscratch1);\n+  pop(rscratch1);\n+\n+  bind(test_mark_word);\n+  testl(temp_reg, test_bit);\n+  jcc((jmp_set) ? Assembler::notZero : Assembler::zero, jmp_label);\n+}\n+\n+void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,\n+                                              Label&is_flattened_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_flattened_array_layout(temp_reg, is_flattened_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,\n+                                                  Label&is_non_flattened_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_non_flattened_array_layout(temp_reg, is_non_flattened_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&is_null_free_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_null_free_array_layout(temp_reg, is_null_free_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_non_null_free_array_layout(temp_reg, is_non_null_free_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_flattened_array_layout(Register lh, Label& is_flattened_array) {\n+  testl(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  jcc(Assembler::notZero, is_flattened_array);\n+}\n+\n+void MacroAssembler::test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array) {\n+  testl(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  jcc(Assembler::zero, is_non_flattened_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_layout(Register lh, Label& is_null_free_array) {\n+  testl(lh, Klass::_lh_null_free_array_bit_inplace);\n+  jcc(Assembler::notZero, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array) {\n+  testl(lh, Klass::_lh_null_free_array_bit_inplace);\n+  jcc(Assembler::zero, is_non_null_free_array);\n+}\n+\n+\n@@ -3935,0 +4085,114 @@\n+\/\/ Object \/ value buffer allocation...\n+\/\/\n+\/\/ Kills klass and rsi on LP64\n+void MacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                       Register t1, Register t2,\n+                                       bool clear_fields, Label& alloc_failed)\n+{\n+  Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;\n+  Register layout_size = t1;\n+  assert(new_obj == rax, \"needs to be rax\");\n+  assert_different_registers(klass, new_obj, t1, t2);\n+\n+  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n+  movl(layout_size, Address(klass, Klass::layout_helper_offset()));\n+  \/\/ test to see if it has a finalizer or is malformed in some way\n+  testl(layout_size, Klass::_lh_instance_slow_path_bit);\n+  jcc(Assembler::notZero, slow_case_no_pop);\n+\n+  \/\/ Allocate the instance:\n+  \/\/  If TLAB is enabled:\n+  \/\/    Try to allocate in the TLAB.\n+  \/\/    If fails, go to the slow path.\n+  \/\/  Else If inline contiguous allocations are enabled:\n+  \/\/    Try to allocate in eden.\n+  \/\/    If fails due to heap end, go to slow path.\n+  \/\/\n+  \/\/  If TLAB is enabled OR inline contiguous is enabled:\n+  \/\/    Initialize the allocation.\n+  \/\/    Exit.\n+  \/\/\n+  \/\/  Go to slow path.\n+\n+  push(klass);\n+  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);\n+#ifndef _LP64\n+  if (UseTLAB) {\n+    get_thread(thread);\n+  }\n+#endif \/\/ _LP64\n+\n+  if (UseTLAB) {\n+    tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);\n+    if (ZeroTLAB || (!clear_fields)) {\n+      \/\/ the fields have been already cleared\n+      jmp(initialize_header);\n+    } else {\n+      \/\/ initialize both the header and fields\n+      jmp(initialize_object);\n+    }\n+  } else {\n+    jmp(slow_case);\n+  }\n+\n+  \/\/ If UseTLAB is true, the object is created above and there is an initialize need.\n+  \/\/ Otherwise, skip and go to the slow path.\n+  if (UseTLAB) {\n+    if (clear_fields) {\n+      \/\/ The object is initialized before the header.  If the object size is\n+      \/\/ zero, go directly to the header initialization.\n+      bind(initialize_object);\n+      decrement(layout_size, sizeof(oopDesc));\n+      jcc(Assembler::zero, initialize_header);\n+\n+      \/\/ Initialize topmost object field, divide size by 8, check if odd and\n+      \/\/ test if zero.\n+      Register zero = klass;\n+      xorl(zero, zero);    \/\/ use zero reg to clear memory (shorter code)\n+      shrl(layout_size, LogBytesPerLong); \/\/ divide by 2*oopSize and set carry flag if odd\n+\n+  #ifdef ASSERT\n+      \/\/ make sure instance_size was multiple of 8\n+      Label L;\n+      \/\/ Ignore partial flag stall after shrl() since it is debug VM\n+      jcc(Assembler::carryClear, L);\n+      stop(\"object size is not multiple of 2 - adjust this code\");\n+      bind(L);\n+      \/\/ must be > 0, no extra check needed here\n+  #endif\n+\n+      \/\/ initialize remaining object fields: instance_size was a multiple of 8\n+      {\n+        Label loop;\n+        bind(loop);\n+        movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);\n+        NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));\n+        decrement(layout_size);\n+        jcc(Assembler::notZero, loop);\n+      }\n+    } \/\/ clear_fields\n+\n+    \/\/ initialize object header only.\n+    bind(initialize_header);\n+    pop(klass);\n+    Register mark_word = t2;\n+    movptr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+#ifdef _LP64\n+    xorl(rsi, rsi);                 \/\/ use zero reg to clear memory (shorter code)\n+    store_klass_gap(new_obj, rsi);  \/\/ zero klass gap for compressed oops\n+#endif\n+    movptr(t2, klass);         \/\/ preserve klass\n+    store_klass(new_obj, t2, rscratch1);  \/\/ src klass reg is potentially compressed\n+\n+    jmp(done);\n+  }\n+\n+  bind(slow_case);\n+  pop(klass);\n+  bind(slow_case_no_pop);\n+  jmp(alloc_failed);\n+\n+  bind(done);\n+}\n+\n@@ -4187,0 +4451,50 @@\n+void MacroAssembler::get_inline_type_field_klass(Register klass, Register index, Register inline_klass) {\n+  movptr(inline_klass, Address(klass, InstanceKlass::inline_type_field_klasses_offset()));\n+#ifdef ASSERT\n+  {\n+    Label done;\n+    cmpptr(inline_klass, 0);\n+    jcc(Assembler::notEqual, done);\n+    stop(\"get_inline_type_field_klass contains no inline klass\");\n+    bind(done);\n+  }\n+#endif\n+  movptr(inline_klass, Address(inline_klass, index, Address::times_ptr));\n+}\n+\n+void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_default_value_oop from non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  Register offset = temp_reg;\n+  \/\/ Getting the offset of the pre-allocated default value\n+  movptr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n+  movl(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));\n+\n+  \/\/ Getting the mirror\n+  movptr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n+  resolve_oop_handle(obj, inline_klass);\n+\n+  \/\/ Getting the pre-allocated default value from the mirror\n+  Address field(obj, offset, Address::times_1);\n+  load_heap_oop(obj, field);\n+}\n+\n+void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_empty_value from non-empty inline klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  get_default_value_oop(inline_klass, temp_reg, obj);\n+}\n+\n+\n@@ -4535,1 +4849,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -4597,1 +4915,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -5084,0 +5406,8 @@\n+void MacroAssembler::load_metadata(Register dst, Register src) {\n+  if (UseCompressedClassPointers) {\n+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -5093,1 +5423,6 @@\n-    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+}\n+\n+void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n+  load_klass(dst, src, tmp);\n+  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n@@ -5132,0 +5467,40 @@\n+void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,\n+                                       Register inline_klass) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->value_copy(this, decorators, src, dst, inline_klass);\n+}\n+\n+void MacroAssembler::first_field_offset(Register inline_klass, Register offset) {\n+  movptr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+  movl(offset, Address(offset, InlineKlass::first_field_offset_offset()));\n+}\n+\n+void MacroAssembler::data_for_oop(Register oop, Register data, Register inline_klass) {\n+  \/\/ ((address) (void*) o) + vk->first_field_offset();\n+  Register offset = (data == oop) ? rscratch1 : data;\n+  first_field_offset(inline_klass, offset);\n+  if (data == oop) {\n+    addptr(data, offset);\n+  } else {\n+    lea(data, Address(oop, offset));\n+  }\n+}\n+\n+void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,\n+                                                Register index, Register data) {\n+  assert(index != rcx, \"index needs to shift by rcx\");\n+  assert_different_registers(array, array_klass, index);\n+  assert_different_registers(rcx, array, index);\n+\n+  \/\/ array->base() + (index << Klass::layout_helper_log2_element_size(lh));\n+  movl(rcx, Address(array_klass, Klass::layout_helper_offset()));\n+\n+  \/\/ Klass::layout_helper_log2_element_size(lh)\n+  \/\/ (lh >> _lh_log2_element_size_shift) & _lh_log2_element_size_mask;\n+  shrl(rcx, Klass::_lh_log2_element_size_shift);\n+  andl(rcx, Klass::_lh_log2_element_size_mask);\n+  shlptr(index); \/\/ index << rcx\n+\n+  lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT)));\n+}\n+\n@@ -5471,1 +5846,1 @@\n-void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, KRegister mask) {\n+void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, KRegister mask) {\n@@ -5477,1 +5852,1 @@\n-    vpxor(xtmp, xtmp, xtmp, AVX_512bit);\n+    evpbroadcastq(xtmp, val, AVX_512bit);\n@@ -5479,1 +5854,3 @@\n-    vpxor(xtmp, xtmp, xtmp, AVX_256bit);\n+    movdq(xtmp, val);\n+    punpcklqdq(xtmp, xtmp);\n+    vinserti128_high(xtmp, xtmp);\n@@ -5481,1 +5858,2 @@\n-    pxor(xtmp, xtmp);\n+    movdq(xtmp, val);\n+    punpcklqdq(xtmp, xtmp);\n@@ -5504,1 +5882,1 @@\n-    fill64_masked(3, base, 0, xtmp, mask, cnt, rtmp, true);\n+    fill64_masked(3, base, 0, xtmp, mask, cnt, val, true);\n@@ -5523,1 +5901,1 @@\n-    fill32_masked(3, base, 0, xtmp, mask, cnt, rtmp);\n+    fill32_masked(3, base, 0, xtmp, mask, cnt, val);\n@@ -5536,0 +5914,398 @@\n+int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  \/\/ An inline type might be returned. If fields are in registers we\n+  \/\/ need to allocate an inline type instance and initialize it with\n+  \/\/ the value of the fields.\n+  Label skip;\n+  \/\/ We only need a new buffered inline type if a new one is not returned\n+  testptr(rax, 1);\n+  jcc(Assembler::zero, skip);\n+  int call_offset = -1;\n+\n+#ifdef _LP64\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != NULL, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(rscratch1, rax); \/\/ save rax for slow_case since *_allocate may corrupt it when allocation failed\n+  if (vk != NULL) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(rbx, (intptr_t)vk->get_InlineKlass());\n+    jint obj_size = vk->layout_helper();\n+    assert(obj_size != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB) {\n+      tlab_allocate(r15_thread, rax, noreg, obj_size, r13, r14, slow_case);\n+    } else {\n+      jmp(slow_case);\n+    }\n+  } else {\n+    \/\/ Call from interpreter. RAX contains ((the InlineKlass* of the return type) | 0x01)\n+    mov(rbx, rax);\n+    andptr(rbx, -2);\n+    movl(r14, Address(rbx, Klass::layout_helper_offset()));\n+    if (UseTLAB) {\n+      tlab_allocate(r15_thread, rax, r14, 0, r13, r14, slow_case);\n+    } else {\n+      jmp(slow_case);\n+    }\n+  }\n+  if (UseTLAB) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = rax;\n+    movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::inline_type_prototype().value());\n+    xorl(r13, r13);\n+    store_klass_gap(buffer_obj, r13);\n+    if (vk == NULL) {\n+      \/\/ store_klass corrupts rbx(klass), so save it in r13 for later use (interpreter case only).\n+      mov(r13, rbx);\n+    }\n+    store_klass(buffer_obj, rbx, rscratch1);\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n+    if (vk != NULL) {\n+      call(RuntimeAddress(vk->pack_handler())); \/\/ no need for call info as this will not safepoint.\n+    } else {\n+      movptr(rbx, Address(r13, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      movptr(rbx, Address(rbx, InlineKlass::pack_handler_offset()));\n+      call(rbx);\n+    }\n+    jmp(skip);\n+  }\n+  bind(slow_case);\n+  \/\/ We failed to allocate a new inline type, fall back to a runtime\n+  \/\/ call. Some oop field may be live in some registers but we can't\n+  \/\/ tell. That runtime call will take care of preserving them\n+  \/\/ across a GC if there's one.\n+  mov(rax, rscratch1);\n+#endif\n+\n+  if (from_interpreter) {\n+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());\n+  } else {\n+    call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n+    call_offset = offset();\n+  }\n+\n+  bind(skip);\n+  return call_offset;\n+}\n+\n+\/\/ Move a value between registers\/stack slots and update the reg_state\n+bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]) {\n+  assert(from->is_valid() && to->is_valid(), \"source and destination must be valid\");\n+  if (reg_state[to->value()] == reg_written) {\n+    return true; \/\/ Already written\n+  }\n+  if (from != to && bt != T_VOID) {\n+    if (reg_state[to->value()] == reg_readonly) {\n+      return false; \/\/ Not yet writable\n+    }\n+    if (from->is_reg()) {\n+      if (to->is_reg()) {\n+        if (from->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to->as_XMMRegister(), from->as_XMMRegister());\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to->as_XMMRegister(), from->as_XMMRegister());\n+          }\n+        } else {\n+          movq(to->as_Register(), from->as_Register());\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        Address to_addr = Address(rsp, st_off);\n+        if (from->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to_addr, from->as_XMMRegister());\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to_addr, from->as_XMMRegister());\n+          }\n+        } else {\n+          movq(to_addr, from->as_Register());\n+        }\n+      }\n+    } else {\n+      Address from_addr = Address(rsp, from->reg2stack() * VMRegImpl::stack_slot_size + wordSize);\n+      if (to->is_reg()) {\n+        if (to->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to->as_XMMRegister(), from_addr);\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to->as_XMMRegister(), from_addr);\n+          }\n+        } else {\n+          movq(to->as_Register(), from_addr);\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(r13, from_addr);\n+        movq(Address(rsp, st_off), r13);\n+      }\n+    }\n+  }\n+  \/\/ Update register states\n+  reg_state[from->value()] = reg_writable;\n+  reg_state[to->value()] = reg_written;\n+  return true;\n+}\n+\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  \/\/ Two additional slots to account for return address\n+  int sp_inc = (args_on_stack + 2) * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  \/\/ Save the return address, adjust the stack (make sure it is properly\n+  \/\/ 16-byte aligned) and copy the return address to the new top of the stack.\n+  \/\/ The stack will be repaired on return (see MacroAssembler::remove_frame).\n+  assert(sp_inc > 0, \"sanity\");\n+  pop(r13);\n+  subptr(rsp, sp_inc);\n+  push(r13);\n+  return sp_inc;\n+}\n+\n+\/\/ Read all fields from an inline type buffer and store the field values in registers\/stack slots.\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                                          VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                                          RegState reg_state[]) {\n+  assert(sig->at(sig_index)._bt == T_VOID, \"should be at end delimiter\");\n+  assert(from->is_valid(), \"source must be valid\");\n+  bool progress = false;\n+#ifdef ASSERT\n+  const int start_offset = offset();\n+#endif\n+\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n+  Register fromReg = noreg;\n+  ScalarizedInlineArgsStream stream(sig, sig_index, to, to_count, to_index, -1);\n+  bool done = true;\n+  bool mark_done = true;\n+  VMReg toReg;\n+  BasicType bt;\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n+  while (stream.next(toReg, bt)) {\n+    assert(toReg->is_valid(), \"destination must be valid\");\n+    int idx = (int)toReg->value();\n+    if (reg_state[idx] == reg_readonly) {\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n+    } else if (reg_state[idx] == reg_written) {\n+      continue;\n+    }\n+    assert(reg_state[idx] == reg_writable, \"must be writable\");\n+    reg_state[idx] = reg_written;\n+    progress = true;\n+\n+    if (fromReg == noreg) {\n+      if (from->is_reg()) {\n+        fromReg = from->as_Register();\n+      } else {\n+        int st_off = from->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(tmp1, Address(rsp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        testptr(fromReg, fromReg);\n+        jcc(Assembler::zero, L_null);\n+      }\n+    }\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), 1);\n+      } else {\n+        movq(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n+    Address fromAddr = Address(fromReg, off);\n+    if (!toReg->is_XMMRegister()) {\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n+      if (is_reference_type(bt)) {\n+        load_heap_oop(dst, fromAddr);\n+      } else {\n+        bool is_signed = (bt != T_CHAR) && (bt != T_BOOLEAN);\n+        load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);\n+      }\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), dst);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      movdbl(toReg->as_XMMRegister(), fromAddr);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      movflt(toReg->as_XMMRegister(), fromAddr);\n+    }\n+  }\n+  if (progress && null_check) {\n+    if (done) {\n+      jmp(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+            movq(Address(rsp, st_off), 0);\n+          } else {\n+            xorq(toReg->as_Register(), toReg->as_Register());\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n+  sig_index = stream.sig_index();\n+  to_index = stream.regs_index();\n+\n+  if (mark_done && reg_state[from->value()] != reg_written) {\n+    \/\/ This is okay because no one else will write to that slot\n+    reg_state[from->value()] = reg_writable;\n+  }\n+  from_index--;\n+  assert(progress || (start_offset == offset()), \"should not emit code\");\n+  return done;\n+}\n+\n+bool MacroAssembler::pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                                        VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                                        RegState reg_state[], Register val_array) {\n+  assert(sig->at(sig_index)._bt == T_PRIMITIVE_OBJECT, \"should be at end delimiter\");\n+  assert(to->is_valid(), \"destination must be valid\");\n+\n+  if (reg_state[to->value()] == reg_written) {\n+    skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+    return true; \/\/ Already written\n+  }\n+\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n+  Register val_obj_tmp = r11;\n+  Register from_reg_tmp = r14;\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n+  Register tmp3 = rbx;\n+  Register val_obj = to->is_stack() ? val_obj_tmp : to->as_Register();\n+\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n+  if (reg_state[to->value()] == reg_readonly) {\n+    if (!is_reg_in_unpacked_fields(sig, sig_index, to, from, from_count, from_index)) {\n+      skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+      return false; \/\/ Not yet writable\n+    }\n+    val_obj = val_obj_tmp;\n+  }\n+\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_PRIMITIVE_OBJECT);\n+  load_heap_oop(val_obj, Address(val_array, index));\n+\n+  ScalarizedInlineArgsStream stream(sig, sig_index, from, from_count, from_index);\n+  VMReg fromReg;\n+  BasicType bt;\n+  Label L_null;\n+  while (stream.next(fromReg, bt)) {\n+    assert(fromReg->is_valid(), \"source must be valid\");\n+    reg_state[fromReg->value()] = reg_writable;\n+\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        testb(Address(rsp, ld_off), 1);\n+      } else {\n+        testb(fromReg->as_Register(), 1);\n+      }\n+      jcc(Assembler::notZero, L_notNull);\n+      movptr(val_obj, 0);\n+      jmp(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n+    assert(off > 0, \"offset in object should be positive\");\n+    size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+\n+    Address dst(val_obj, off);\n+    if (!fromReg->is_XMMRegister()) {\n+      Register src;\n+      if (fromReg->is_stack()) {\n+        src = from_reg_tmp;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        load_sized_value(src, Address(rsp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+      } else {\n+        src = fromReg->as_Register();\n+      }\n+      assert_different_registers(dst.base(), src, tmp1, tmp2, tmp3, val_array);\n+      if (is_reference_type(bt)) {\n+        store_heap_oop(dst, src, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        store_sized_value(dst, src, size_in_bytes);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      movdbl(dst, fromReg->as_XMMRegister());\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      movflt(dst, fromReg->as_XMMRegister());\n+    }\n+  }\n+  bind(L_null);\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+\n+  assert(reg_state[to->value()] == reg_writable, \"must have already been read\");\n+  bool success = move_helper(val_obj->as_VMReg(), to, T_OBJECT, reg_state);\n+  assert(success, \"to register must be writeable\");\n+  return true;\n+}\n+\n+VMReg MacroAssembler::spill_reg_for(VMReg reg) {\n+  return reg->is_XMMRegister() ? xmm8->as_VMReg() : r14->as_VMReg();\n+}\n+\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair) {\n+  assert((initial_framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+  if (needs_stack_repair) {\n+    movq(rbp, Address(rsp, initial_framesize));\n+    \/\/ The stack increment resides just below the saved rbp\n+    addq(rsp, Address(rsp, initial_framesize - wordSize));\n+  } else {\n+    if (initial_framesize > 0) {\n+      addq(rsp, initial_framesize);\n+    }\n+    pop(rbp);\n+  }\n+}\n+\n@@ -5625,2 +6401,2 @@\n-void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp,\n-                               bool is_large, KRegister mask) {\n+void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp,\n+                               bool is_large, bool word_copy_only, KRegister mask) {\n@@ -5631,1 +6407,1 @@\n-  assert(tmp==rax,   \"tmp register must be eax for rep stos\");\n+  assert(val==rax,   \"val register must be eax for rep stos\");\n@@ -5637,3 +6413,0 @@\n-  if (!is_large || !UseXMMForObjInit) {\n-    xorptr(tmp, tmp);\n-  }\n@@ -5653,1 +6426,1 @@\n-    movptr(Address(base, cnt, Address::times_ptr), tmp);\n+    movptr(Address(base, cnt, Address::times_ptr), val);\n@@ -5662,1 +6435,1 @@\n-  if (UseFastStosb) {\n+  if (UseFastStosb && !word_copy_only) {\n@@ -5666,1 +6439,1 @@\n-    xmm_clear_mem(base, cnt, tmp, xtmp, mask);\n+    xmm_clear_mem(base, cnt, val, xtmp, mask);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":791,"deletions":18,"binary":false,"changes":809,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -36,0 +37,2 @@\n+class ciInlineKlass;\n+\n@@ -105,0 +108,31 @@\n+  \/\/ markWord tests, kills markWord reg\n+  void test_markword_is_inline_type(Register markword, Label& is_inline_type);\n+\n+  \/\/ inlineKlass queries, kills temp_reg\n+  void test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type);\n+  void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type);\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n+\n+  \/\/ Get the default value oop for the given InlineKlass\n+  void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);\n+  \/\/ The empty value oop, for the given InlineKlass (\"empty\" as in no instance fields)\n+  \/\/ get_default_value_oop with extra assertion for empty inline klass\n+  void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);\n+\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n+  void test_field_is_inlined(Register flags, Register temp_reg, Label& is_inlined);\n+\n+  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  void test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label);\n+  void test_flattened_array_oop(Register oop, Register temp_reg, Label&is_flattened_array);\n+  void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&is_non_flattened_array);\n+  void test_null_free_array_oop(Register oop, Register temp_reg, Label&is_null_free_array);\n+  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array);\n+\n+  \/\/ Check array klass layout helper for flatten or null-free arrays...\n+  void test_flattened_array_layout(Register lh, Label& is_flattened_array);\n+  void test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array);\n+  void test_null_free_array_layout(Register lh, Label& is_null_free_array);\n+  void test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array);\n+\n@@ -350,0 +384,1 @@\n+  void load_metadata(Register dst, Register src);\n@@ -358,0 +393,10 @@\n+  void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);\n+\n+  \/\/ inline type data payload offsets...\n+  void first_field_offset(Register inline_klass, Register offset);\n+  void data_for_oop(Register oop, Register data, Register inline_klass);\n+  \/\/ get data payload ptr a flat value array at index, kills rcx and index\n+  void data_for_value_array_index(Register array, Register array_klass,\n+                                  Register index, Register data);\n+\n+\n@@ -369,0 +414,2 @@\n+  void load_prototype_header(Register dst, Register src, Register tmp);\n+\n@@ -570,0 +617,9 @@\n+\n+  \/\/ Object \/ value buffer allocation...\n+  \/\/ Allocate instance of klass, assumes klass initialized by caller\n+  \/\/ new_obj prefers to be rax\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+\n@@ -581,0 +637,3 @@\n+  \/\/ For field \"index\" within \"klass\", return inline_klass ...\n+  void get_inline_type_field_klass(Register klass, Register index, Register inline_klass);\n+\n@@ -731,1 +790,2 @@\n-  void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }\n+  void andptr(Register dst, Register src) { LP64_ONLY(andq(dst, src)) NOT_LP64(andl(dst, src)) ; }\n+  void andptr(Register dst, Address src) { LP64_ONLY(andq(dst, src)) NOT_LP64(andl(dst, src)) ; }\n@@ -1831,0 +1891,15 @@\n+  \/\/ Inline type specific methods\n+  #include \"asm\/macroAssembler_common.hpp\"\n+\n+  int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);\n+  bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]);\n+  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                            VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                            RegState reg_state[]);\n+  bool pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                          VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                          RegState reg_state[], Register val_array);\n+  int extend_stack_for_inline_args(int args_on_stack);\n+  void remove_frame(int initial_framesize, bool needs_stack_repair);\n+  VMReg spill_reg_for(VMReg reg);\n+\n@@ -1833,1 +1908,1 @@\n-  void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large, KRegister mask=knoreg);\n+  void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only, KRegister mask=knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":77,"deletions":2,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -157,1 +157,5 @@\n-  const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_offset() :\n+  \/\/ The following jump might pass an inline type argument that was erased to Object as oop to a\n+  \/\/ callee that expects inline type arguments to be passed as fields. We need to call the compiled\n+  \/\/ value entry (_code->inline_entry_point() or _adapter->c2i_inline_entry()) which will take care\n+  \/\/ of translating between the calling conventions.\n+  const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_inline_offset() :\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -527,0 +528,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -560,0 +562,82 @@\n+\/\/ Same as java_calling_convention() but for multiple return\n+\/\/ values. There's no way to store them on the stack so if we don't\n+\/\/ have enough registers, multiple values can't be returned.\n+const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;\n+const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;\n+int SharedRuntime::java_return_convention(const BasicType *sig_bt,\n+                                          VMRegPair *regs,\n+                                          int total_args_passed) {\n+  \/\/ Create the mapping between argument positions and\n+  \/\/ registers.\n+  static const Register INT_ArgReg[java_return_convention_max_int] = {\n+    rax, j_rarg5, j_rarg4, j_rarg3, j_rarg2, j_rarg1, j_rarg0\n+  };\n+  static const XMMRegister FP_ArgReg[java_return_convention_max_float] = {\n+    j_farg0, j_farg1, j_farg2, j_farg3,\n+    j_farg4, j_farg5, j_farg6, j_farg7\n+  };\n+\n+\n+  uint int_args = 0;\n+  uint fp_args = 0;\n+\n+  for (int i = 0; i < total_args_passed; i++) {\n+    switch (sig_bt[i]) {\n+    case T_BOOLEAN:\n+    case T_CHAR:\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+      if (int_args < Argument::n_int_register_parameters_j+1) {\n+        regs[i].set1(INT_ArgReg[int_args]->as_VMReg());\n+        int_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_VOID:\n+      \/\/ halves of T_LONG or T_DOUBLE\n+      assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+      regs[i].set_bad();\n+      break;\n+    case T_LONG:\n+      assert(sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      \/\/ fall through\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT:\n+    case T_ARRAY:\n+    case T_ADDRESS:\n+    case T_METADATA:\n+      if (int_args < Argument::n_int_register_parameters_j+1) {\n+        regs[i].set2(INT_ArgReg[int_args]->as_VMReg());\n+        int_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_FLOAT:\n+      if (fp_args < Argument::n_float_register_parameters_j) {\n+        regs[i].set1(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    case T_DOUBLE:\n+      assert(sig_bt[i + 1] == T_VOID, \"expecting half\");\n+      if (fp_args < Argument::n_float_register_parameters_j) {\n+        regs[i].set2(FP_ArgReg[fp_args]->as_VMReg());\n+        fp_args++;\n+      } else {\n+        return -1;\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  return int_args + fp_args;\n+}\n+\n@@ -602,0 +686,106 @@\n+\/\/ For each inline type argument, sig includes the list of fields of\n+\/\/ the inline type. This utility function computes the number of\n+\/\/ arguments for the call if inline types are passed by reference (the\n+\/\/ calling convention the interpreter expects).\n+static int compute_total_args_passed_int(const GrowableArray<SigEntry>* sig_extended) {\n+  int total_args_passed = 0;\n+  if (InlineTypePassFieldsAsArgs) {\n+    for (int i = 0; i < sig_extended->length(); i++) {\n+      BasicType bt = sig_extended->at(i)._bt;\n+      if (bt == T_PRIMITIVE_OBJECT) {\n+        \/\/ In sig_extended, an inline type argument starts with:\n+        \/\/ T_PRIMITIVE_OBJECT, followed by the types of the fields of the\n+        \/\/ inline type and T_VOID to mark the end of the value\n+        \/\/ type. Inline types are flattened so, for instance, in the\n+        \/\/ case of an inline type with an int field and an inline type\n+        \/\/ field that itself has 2 fields, an int and a long:\n+        \/\/ T_PRIMITIVE_OBJECT T_INT T_PRIMITIVE_OBJECT T_INT T_LONG T_VOID (second\n+        \/\/ slot for the T_LONG) T_VOID (inner T_PRIMITIVE_OBJECT) T_VOID\n+        \/\/ (outer T_PRIMITIVE_OBJECT)\n+        total_args_passed++;\n+        int vt = 1;\n+        do {\n+          i++;\n+          BasicType bt = sig_extended->at(i)._bt;\n+          BasicType prev_bt = sig_extended->at(i-1)._bt;\n+          if (bt == T_PRIMITIVE_OBJECT) {\n+            vt++;\n+          } else if (bt == T_VOID &&\n+                     prev_bt != T_LONG &&\n+                     prev_bt != T_DOUBLE) {\n+            vt--;\n+          }\n+        } while (vt != 0);\n+      } else {\n+        total_args_passed++;\n+      }\n+    }\n+  } else {\n+    total_args_passed = sig_extended->length();\n+  }\n+  return total_args_passed;\n+}\n+\n+\n+static void gen_c2i_adapter_helper(MacroAssembler* masm,\n+                                   BasicType bt,\n+                                   BasicType prev_bt,\n+                                   size_t size_in_bytes,\n+                                   const VMRegPair& reg_pair,\n+                                   const Address& to,\n+                                   int extraspace,\n+                                   bool is_oop) {\n+  assert(bt != T_PRIMITIVE_OBJECT || !InlineTypePassFieldsAsArgs, \"no inline type here\");\n+  if (bt == T_VOID) {\n+    assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, \"missing half\");\n+    return;\n+  }\n+\n+  \/\/ Say 4 args:\n+  \/\/ i   st_off\n+  \/\/ 0   32 T_LONG\n+  \/\/ 1   24 T_VOID\n+  \/\/ 2   16 T_OBJECT\n+  \/\/ 3    8 T_BOOL\n+  \/\/ -    0 return address\n+  \/\/\n+  \/\/ However to make thing extra confusing. Because we can fit a long\/double in\n+  \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n+  \/\/ leaves one slot empty and only stores to a single slot. In this case the\n+  \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n+\n+  bool wide = (size_in_bytes == wordSize);\n+  VMReg r_1 = reg_pair.first();\n+  VMReg r_2 = reg_pair.second();\n+  assert(r_2->is_valid() == wide, \"invalid size\");\n+  if (!r_1->is_valid()) {\n+    assert(!r_2->is_valid(), \"must be invalid\");\n+    return;\n+  }\n+\n+  if (!r_1->is_XMMRegister()) {\n+    Register val = rax;\n+    if (r_1->is_stack()) {\n+      int ld_off = r_1->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+      __ load_sized_value(val, Address(rsp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+    } else {\n+      val = r_1->as_Register();\n+    }\n+    assert_different_registers(to.base(), val, rscratch1);\n+    if (is_oop) {\n+      __ push(r13);\n+      __ push(rbx);\n+      __ store_heap_oop(to, val, rscratch1, r13, rbx, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      __ pop(rbx);\n+      __ pop(r13);\n+    } else {\n+      __ store_sized_value(to, val, size_in_bytes);\n+    }\n+  } else {\n+    if (wide) {\n+      __ movdbl(to, r_1->as_XMMRegister());\n+    } else {\n+      __ movflt(to, r_1->as_XMMRegister());\n+    }\n+  }\n+}\n@@ -604,3 +794,1 @@\n-                            int total_args_passed,\n-                            int comp_args_on_stack,\n-                            const BasicType *sig_bt,\n+                            const GrowableArray<SigEntry>* sig_extended,\n@@ -608,1 +796,32 @@\n-                            Label& skip_fixup) {\n+                            bool requires_clinit_barrier,\n+                            address& c2i_no_clinit_check_entry,\n+                            Label& skip_fixup,\n+                            address start,\n+                            OopMapSet* oop_maps,\n+                            int& frame_complete,\n+                            int& frame_size_in_words,\n+                            bool alloc_inline_receiver) {\n+  if (requires_clinit_barrier && VM_Version::supports_fast_class_init_checks()) {\n+    Label L_skip_barrier;\n+    Register method = rbx;\n+\n+    { \/\/ Bypass the barrier for non-static methods\n+      Register flags = rscratch1;\n+      __ movl(flags, Address(method, Method::access_flags_offset()));\n+      __ testl(flags, JVM_ACC_STATIC);\n+      __ jcc(Assembler::zero, L_skip_barrier); \/\/ non-static\n+    }\n+\n+    Register klass = rscratch1;\n+    __ load_method_holder(klass, method);\n+    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+\n+    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+\n+    __ bind(L_skip_barrier);\n+    c2i_no_clinit_check_entry = __ pc();\n+  }\n+\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->c2i_entry_barrier(masm);\n+\n@@ -618,0 +837,42 @@\n+  if (InlineTypePassFieldsAsArgs) {\n+    \/\/ Is there an inline type argument?\n+    bool has_inline_argument = false;\n+    for (int i = 0; i < sig_extended->length() && !has_inline_argument; i++) {\n+      has_inline_argument = (sig_extended->at(i)._bt == T_PRIMITIVE_OBJECT);\n+    }\n+    if (has_inline_argument) {\n+      \/\/ There is at least an inline type argument: we're coming from\n+      \/\/ compiled code so we have no buffers to back the inline types.\n+      \/\/ Allocate the buffers here with a runtime call.\n+      OopMap* map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ false);\n+\n+      frame_complete = __ offset();\n+\n+      __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+\n+      __ mov(c_rarg0, r15_thread);\n+      __ mov(c_rarg1, rbx);\n+      __ mov64(c_rarg2, (int64_t)alloc_inline_receiver);\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));\n+\n+      oop_maps->add_gc_map((int)(__ pc() - start), map);\n+      __ reset_last_Java_frame(false);\n+\n+      RegisterSaver::restore_live_registers(masm);\n+\n+      Label no_exception;\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+      __ jcc(Assembler::equal, no_exception);\n+\n+      __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), NULL_WORD);\n+      __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+      __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+      __ bind(no_exception);\n+\n+      \/\/ We get an array of objects from the runtime call\n+      __ get_vm_result(rscratch2, r15_thread); \/\/ Use rscratch2 (r11) as temporary because rscratch1 (r10) is trashed by movptr()\n+      __ get_vm_result_2(rbx, r15_thread); \/\/ TODO: required to keep the callee Method live?\n+    }\n+  }\n+\n@@ -620,1 +881,1 @@\n-\n+  int total_args_passed = compute_total_args_passed_int(sig_extended);\n@@ -655,46 +916,24 @@\n-  for (int i = 0; i < total_args_passed; i++) {\n-    if (sig_bt[i] == T_VOID) {\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n-      continue;\n-    }\n-\n-    \/\/ offset to start parameters\n-    int st_off   = (total_args_passed - i) * Interpreter::stackElementSize;\n-    int next_off = st_off - Interpreter::stackElementSize;\n-\n-    \/\/ Say 4 args:\n-    \/\/ i   st_off\n-    \/\/ 0   32 T_LONG\n-    \/\/ 1   24 T_VOID\n-    \/\/ 2   16 T_OBJECT\n-    \/\/ 3    8 T_BOOL\n-    \/\/ -    0 return address\n-    \/\/\n-    \/\/ However to make thing extra confusing. Because we can fit a long\/double in\n-    \/\/ a single slot on a 64 bt vm and it would be silly to break them up, the interpreter\n-    \/\/ leaves one slot empty and only stores to a single slot. In this case the\n-    \/\/ slot that is occupied is the T_VOID slot. See I said it was confusing.\n-    VMReg r_1 = regs[i].first();\n-    VMReg r_2 = regs[i].second();\n-    if (!r_1->is_valid()) {\n-      assert(!r_2->is_valid(), \"\");\n-      continue;\n-    }\n-    if (r_1->is_stack()) {\n-      \/\/ memory to memory use rax\n-      int ld_off = r_1->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n-      if (!r_2->is_valid()) {\n-        \/\/ sign extend??\n-        __ movl(rax, Address(rsp, ld_off));\n-        __ movptr(Address(rsp, st_off), rax);\n-\n-      } else {\n-\n-        __ movq(rax, Address(rsp, ld_off));\n-\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ ld_off == LSW, ld_off+wordSize == MSW\n-          \/\/ st_off == MSW, next_off == LSW\n-          __ movq(Address(rsp, next_off), rax);\n+  \/\/ next_arg_comp is the next argument from the compiler point of\n+  \/\/ view (inline type fields are passed in registers\/on the stack). In\n+  \/\/ sig_extended, an inline type argument starts with: T_PRIMITIVE_OBJECT,\n+  \/\/ followed by the types of the fields of the inline type and T_VOID\n+  \/\/ to mark the end of the inline type. ignored counts the number of\n+  \/\/ T_PRIMITIVE_OBJECT\/T_VOID. next_vt_arg is the next inline type argument:\n+  \/\/ used to get the buffer for that argument from the pool of buffers\n+  \/\/ we allocated above and want to pass to the\n+  \/\/ interpreter. next_arg_int is the next argument from the\n+  \/\/ interpreter point of view (inline types are passed by reference).\n+  for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;\n+       next_arg_comp < sig_extended->length(); next_arg_comp++) {\n+    assert(ignored <= next_arg_comp, \"shouldn't skip over more slots than there are arguments\");\n+    assert(next_arg_int <= total_args_passed, \"more arguments for the interpreter than expected?\");\n+    BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+    int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;\n+    if (!InlineTypePassFieldsAsArgs || bt != T_PRIMITIVE_OBJECT) {\n+      int next_off = st_off - Interpreter::stackElementSize;\n+      const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;\n+      const VMRegPair reg_pair = regs[next_arg_comp-ignored];\n+      size_t size_in_bytes = reg_pair.second()->is_valid() ? 8 : 4;\n+      gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                             size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);\n+      next_arg_int++;\n@@ -703,7 +942,4 @@\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov64(rax, CONST64(0xdeadffffdeadaaaa));\n-          __ movptr(Address(rsp, st_off), rax);\n-#endif \/* ASSERT *\/\n-        } else {\n-          __ movq(Address(rsp, st_off), rax);\n-        }\n+      if (bt == T_LONG || bt == T_DOUBLE) {\n+        \/\/ Overwrite the unused slot with known junk\n+        __ mov64(rax, CONST64(0xdeadffffdeadaaaa));\n+        __ movptr(Address(rsp, st_off), rax);\n@@ -711,16 +947,26 @@\n-    } else if (r_1->is_Register()) {\n-      Register r = r_1->as_Register();\n-      if (!r_2->is_valid()) {\n-        \/\/ must be only an int (or less ) so move only 32bits to slot\n-        \/\/ why not sign extend??\n-        __ movl(Address(rsp, st_off), r);\n-      } else {\n-        \/\/ Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n-          \/\/ long\/double in gpr\n-#ifdef ASSERT\n-          \/\/ Overwrite the unused slot with known junk\n-          __ mov64(rax, CONST64(0xdeadffffdeadaaab));\n-          __ movptr(Address(rsp, st_off), rax);\n-          __ movq(Address(rsp, next_off), r);\n+    } else {\n+      ignored++;\n+      \/\/ get the buffer from the just allocated pool of buffers\n+      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_PRIMITIVE_OBJECT);\n+      __ load_heap_oop(r14, Address(rscratch2, index));\n+      next_vt_arg++; next_arg_int++;\n+      int vt = 1;\n+      \/\/ write fields we get from compiled code in registers\/stack\n+      \/\/ slots to the buffer: we know we are done with that inline type\n+      \/\/ argument when we hit the T_VOID that acts as an end of inline\n+      \/\/ type delimiter for this inline type. Inline types are flattened\n+      \/\/ so we might encounter embedded inline types. Each entry in\n+      \/\/ sig_extended contains a field offset in the buffer.\n+      Label L_null;\n+      do {\n+        next_arg_comp++;\n+        BasicType bt = sig_extended->at(next_arg_comp)._bt;\n+        BasicType prev_bt = sig_extended->at(next_arg_comp-1)._bt;\n+        if (bt == T_PRIMITIVE_OBJECT) {\n+          vt++;\n+          ignored++;\n+        } else if (bt == T_VOID &&\n+                   prev_bt != T_LONG &&\n+                   prev_bt != T_DOUBLE) {\n+          vt--;\n+          ignored++;\n@@ -729,1 +975,22 @@\n-          __ movptr(Address(rsp, st_off), r);\n+          int off = sig_extended->at(next_arg_comp)._offset;\n+          if (off == -1) {\n+            \/\/ Nullable inline type argument, emit null check\n+            VMReg reg = regs[next_arg_comp-ignored].first();\n+            Label L_notNull;\n+            if (reg->is_stack()) {\n+              int ld_off = reg->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+              __ testb(Address(rsp, ld_off), 1);\n+            } else {\n+              __ testb(reg->as_Register(), 1);\n+            }\n+            __ jcc(Assembler::notZero, L_notNull);\n+            __ movptr(Address(rsp, st_off), 0);\n+            __ jmp(L_null);\n+            __ bind(L_notNull);\n+            continue;\n+          }\n+          assert(off > 0, \"offset in object should be positive\");\n+          size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+          bool is_oop = is_reference_type(bt);\n+          gen_c2i_adapter_helper(masm, bt, next_arg_comp > 0 ? sig_extended->at(next_arg_comp-1)._bt : T_ILLEGAL,\n+                                 size_in_bytes, regs[next_arg_comp-ignored], Address(r14, off), extraspace, is_oop);\n@@ -731,14 +998,4 @@\n-      }\n-    } else {\n-      assert(r_1->is_XMMRegister(), \"\");\n-      if (!r_2->is_valid()) {\n-        \/\/ only a float use just part of the slot\n-        __ movflt(Address(rsp, st_off), r_1->as_XMMRegister());\n-      } else {\n-#ifdef ASSERT\n-        \/\/ Overwrite the unused slot with known junk\n-        __ mov64(rax, CONST64(0xdeadffffdeadaaac));\n-        __ movptr(Address(rsp, st_off), rax);\n-#endif \/* ASSERT *\/\n-        __ movdbl(Address(rsp, next_off), r_1->as_XMMRegister());\n-      }\n+      } while (vt != 0);\n+      \/\/ pass the buffer to the interpreter\n+      __ movptr(Address(rsp, st_off), r14);\n+      __ bind(L_null);\n@@ -767,2 +1024,1 @@\n-                                    int total_args_passed,\n-                                    const BasicType *sig_bt,\n+                                    const GrowableArray<SigEntry>* sig,\n@@ -854,1 +1110,1 @@\n-  __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_offset())));\n+  __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_inline_offset())));\n@@ -868,0 +1124,2 @@\n+  int total_args_passed = sig->length();\n+\n@@ -871,1 +1129,3 @@\n-    if (sig_bt[i] == T_VOID) {\n+    BasicType bt = sig->at(i)._bt;\n+    assert(bt != T_PRIMITIVE_OBJECT, \"i2c adapter doesn't unpack inline type args\");\n+    if (bt == T_VOID) {\n@@ -874,1 +1134,2 @@\n-      assert(i > 0 && (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), \"missing half\");\n+      BasicType prev_bt = (i > 0) ? sig->at(i-1)._bt : T_ILLEGAL;\n+      assert(i > 0 && (prev_bt == T_LONG || prev_bt == T_DOUBLE), \"missing half\");\n@@ -916,1 +1177,1 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n+        const int offset = (bt==T_LONG||bt==T_DOUBLE)?\n@@ -931,1 +1192,1 @@\n-        const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?\n+        const int offset = (bt==T_LONG||bt==T_DOUBLE)?\n@@ -964,1 +1225,1 @@\n-  \/\/ only needed because eof c2 resolve stubs return Method* as a result in\n+  \/\/ only needed because of c2 resolve stubs return Method* as a result in\n@@ -970,0 +1231,22 @@\n+static void gen_inline_cache_check(MacroAssembler *masm, Label& skip_fixup) {\n+  Label ok;\n+\n+  Register holder = rax;\n+  Register receiver = j_rarg0;\n+  Register temp = rbx;\n+\n+  __ load_klass(temp, receiver, rscratch1);\n+  __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));\n+  __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));\n+  __ jcc(Assembler::equal, ok);\n+  __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+\n+  __ bind(ok);\n+  \/\/ Method might have been compiled since the call site was patched to\n+  \/\/ interpreted if that is the case treat it as a miss so we can get\n+  \/\/ the call site corrected.\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n+  __ jcc(Assembler::equal, skip_fixup);\n+  __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+}\n+\n@@ -971,2 +1254,1 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n@@ -974,3 +1256,9 @@\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+                                                            const GrowableArray<SigEntry>* sig,\n+                                                            const VMRegPair* regs,\n+                                                            const GrowableArray<SigEntry>* sig_cc,\n+                                                            const VMRegPair* regs_cc,\n+                                                            const GrowableArray<SigEntry>* sig_cc_ro,\n+                                                            const VMRegPair* regs_cc_ro,\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n@@ -978,2 +1266,1 @@\n-\n-  gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);\n+  gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);\n@@ -990,1 +1277,2 @@\n-  address c2i_unverified_entry = __ pc();\n+  address c2i_unverified_entry        = __ pc();\n+  address c2i_unverified_inline_entry = __ pc();\n@@ -992,11 +1280,1 @@\n-  Label ok;\n-\n-  Register holder = rax;\n-  Register receiver = j_rarg0;\n-  Register temp = rbx;\n-  {\n-    __ load_klass(temp, receiver, rscratch1);\n-    __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));\n-    __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));\n-    __ jcc(Assembler::equal, ok);\n-    __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+  gen_inline_cache_check(masm, skip_fixup);\n@@ -1005,10 +1283,3 @@\n-    __ bind(ok);\n-    \/\/ Method might have been compiled since the call site was patched to\n-    \/\/ interpreted if that is the case treat it as a miss so we can get\n-    \/\/ the call site corrected.\n-    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n-    __ jcc(Assembler::equal, skip_fixup);\n-    __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n-  }\n-\n-  address c2i_entry = __ pc();\n+  OopMapSet* oop_maps = new OopMapSet();\n+  int frame_complete = CodeOffsets::frame_never_safe;\n+  int frame_size_in_words = 0;\n@@ -1016,1 +1287,1 @@\n-  \/\/ Class initialization barrier for static methods\n+  \/\/ Scalarized c2i adapter with non-scalarized receiver (i.e., don't pack receiver)\n@@ -1018,10 +1289,7 @@\n-  if (VM_Version::supports_fast_class_init_checks()) {\n-    Label L_skip_barrier;\n-    Register method = rbx;\n-\n-    { \/\/ Bypass the barrier for non-static methods\n-      Register flags = rscratch1;\n-      __ movl(flags, Address(method, Method::access_flags_offset()));\n-      __ testl(flags, JVM_ACC_STATIC);\n-      __ jcc(Assembler::zero, L_skip_barrier); \/\/ non-static\n-    }\n+  address c2i_inline_ro_entry = __ pc();\n+  if (regs_cc != regs_cc_ro) {\n+    \/\/ No class init barrier needed because method is guaranteed to be non-static\n+    gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, \/* requires_clinit_barrier = *\/ false, c2i_no_clinit_check_entry,\n+                    skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* alloc_inline_receiver = *\/ false);\n+    skip_fixup.reset();\n+  }\n@@ -1029,3 +1297,5 @@\n-    Register klass = rscratch1;\n-    __ load_method_holder(klass, method);\n-    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+  \/\/ Scalarized c2i adapter\n+  address c2i_entry        = __ pc();\n+  address c2i_inline_entry = __ pc();\n+  gen_c2i_adapter(masm, sig_cc, regs_cc, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                  skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* alloc_inline_receiver = *\/ true);\n@@ -1033,1 +1303,5 @@\n-    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+  \/\/ Non-scalarized c2i adapter\n+  if (regs != regs_cc) {\n+    c2i_unverified_inline_entry = __ pc();\n+    Label inline_entry_skip_fixup;\n+    gen_inline_cache_check(masm, inline_entry_skip_fixup);\n@@ -1035,2 +1309,3 @@\n-    __ bind(L_skip_barrier);\n-    c2i_no_clinit_check_entry = __ pc();\n+    c2i_inline_entry = __ pc();\n+    gen_c2i_adapter(masm, sig, regs, \/* requires_clinit_barrier = *\/ true, c2i_no_clinit_check_entry,\n+                    inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, \/* alloc_inline_receiver = *\/ false);\n@@ -1039,2 +1314,1 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n+  __ flush();\n@@ -1042,1 +1316,6 @@\n-  gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);\n+  \/\/ The c2i adapters might safepoint and trigger a GC. The caller must make sure that\n+  \/\/ the GC knows about the location of oop argument locations passed to the c2i adapter.\n+  if (allocate_code_blob) {\n+    bool caller_must_gc_arguments = (regs != regs_cc);\n+    new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  }\n@@ -1044,2 +1323,1 @@\n-  __ flush();\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -1103,0 +1381,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -2020,0 +2299,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -2145,0 +2425,4 @@\n+      if (EnableValhalla) {\n+        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+        __ andptr(swap_reg, ~((int) markWord::inline_type_bit_in_place));\n+      }\n@@ -2206,0 +2490,1 @@\n+  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n@@ -3697,0 +3982,110 @@\n+BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {\n+  BufferBlob* buf = BufferBlob::create(\"inline types pack\/unpack\", 16 * K);\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  int pack_fields_jobject_off = __ offset();\n+  \/\/ Resolve pre-allocated buffer from JNI handle.\n+  \/\/ We cannot do this in generate_call_stub() because it requires GC code to be initialized.\n+  __ movptr(rax, Address(r13, 0));\n+  __ resolve_jobject(rax \/* value *\/,\n+                     r15_thread \/* thread *\/,\n+                     r12 \/* tmp *\/);\n+  __ movptr(Address(r13, 0), rax);\n+\n+  int pack_fields_off = __ offset();\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address to(rax, off);\n+    if (bt == T_FLOAT) {\n+      __ movflt(to, r_1->as_XMMRegister());\n+    } else if (bt == T_DOUBLE) {\n+      __ movdbl(to, r_1->as_XMMRegister());\n+    } else {\n+      Register val = r_1->as_Register();\n+      assert_different_registers(to.base(), val, r14, r13, rbx, rscratch1);\n+      if (is_reference_type(bt)) {\n+        __ store_heap_oop(to, val, r14, r13, rbx, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        __ store_sized_value(to, r_1->as_Register(), type2aelembytes(bt));\n+      }\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ ret(0);\n+\n+  int unpack_fields_off = __ offset();\n+\n+  Label skip;\n+  __ testptr(rax, rax);\n+  __ jcc(Assembler::zero, skip);\n+\n+  j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    VMReg r_2 = pair.second();\n+    Address from(rax, off);\n+    if (bt == T_FLOAT) {\n+      __ movflt(r_1->as_XMMRegister(), from);\n+    } else if (bt == T_DOUBLE) {\n+      __ movdbl(r_1->as_XMMRegister(), from);\n+    } else if (bt == T_OBJECT || bt == T_ARRAY) {\n+      assert_different_registers(rax, r_1->as_Register());\n+      __ load_heap_oop(r_1->as_Register(), from);\n+    } else {\n+      assert(is_java_primitive(bt), \"unexpected basic type\");\n+      assert_different_registers(rax, r_1->as_Register());\n+      size_t size_in_bytes = type2aelembytes(bt);\n+      __ load_sized_value(r_1->as_Register(), from, size_in_bytes, bt != T_CHAR && bt != T_BOOLEAN);\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+  __ bind(skip);\n+  __ ret(0);\n+\n+  __ flush();\n+\n+  return BufferedInlineTypeBlob::create(&buffer, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":543,"deletions":148,"binary":false,"changes":691,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/assembler.hpp\"\n@@ -39,0 +40,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include \"vmreg_x86.inline.hpp\"\n@@ -320,5 +323,9 @@\n-  \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n-  __ movptr(c_rarg0, result);\n-  Label is_long, is_float, is_double, exit;\n-  __ movl(c_rarg1, result_type);\n-  __ cmpl(c_rarg1, T_OBJECT);\n+  \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+  __ movptr(r13, result);\n+  Label is_long, is_float, is_double, check_prim, exit;\n+  __ movl(rbx, result_type);\n+  __ cmpl(rbx, T_OBJECT);\n+  __ jcc(Assembler::equal, check_prim);\n+  __ cmpl(rbx, T_PRIMITIVE_OBJECT);\n+  __ jcc(Assembler::equal, check_prim);\n+  __ cmpl(rbx, T_LONG);\n@@ -326,3 +333,1 @@\n-  __ cmpl(c_rarg1, T_LONG);\n-  __ jcc(Assembler::equal, is_long);\n-  __ cmpl(c_rarg1, T_FLOAT);\n+  __ cmpl(rbx, T_FLOAT);\n@@ -330,1 +335,1 @@\n-  __ cmpl(c_rarg1, T_DOUBLE);\n+  __ cmpl(rbx, T_DOUBLE);\n@@ -334,1 +339,1 @@\n-  __ movl(Address(c_rarg0, 0), rax);\n+  __ movl(Address(r13, 0), rax);\n@@ -398,0 +403,13 @@\n+  __ BIND(check_prim);\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ Check for scalarized return value\n+    __ testptr(rax, 1);\n+    __ jcc(Assembler::zero, is_long);\n+    \/\/ Load pack handler address\n+    __ andptr(rax, -2);\n+    __ movptr(rax, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    __ movptr(rbx, Address(rax, InlineKlass::pack_handler_jobject_offset()));\n+    \/\/ Call pack handler to initialize the buffer\n+    __ call(rbx);\n+    __ jmp(exit);\n+  }\n@@ -399,1 +417,1 @@\n-  __ movq(Address(c_rarg0, 0), rax);\n+  __ movq(Address(r13, 0), rax);\n@@ -403,1 +421,1 @@\n-  __ movflt(Address(c_rarg0, 0), xmm0);\n+  __ movflt(Address(r13, 0), xmm0);\n@@ -407,1 +425,1 @@\n-  __ movdbl(Address(c_rarg0, 0), xmm0);\n+  __ movdbl(Address(r13, 0), xmm0);\n@@ -3671,0 +3689,10 @@\n+  \/\/ Generate these first because they are called from other stubs\n+  if (InlineTypeReturnedAsFields) {\n+    StubRoutines::_load_inline_type_fields_in_regs =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs),\n+                                 \"load_inline_type_fields_in_regs\", false);\n+    StubRoutines::_store_inline_type_fields_to_buf =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf),\n+                                 \"store_inline_type_fields_to_buf\", true);\n+  }\n+\n@@ -3730,0 +3758,144 @@\n+\/\/ Call here from the interpreter or compiled code to either load\n+\/\/ multiple returned values from the inline type instance being\n+\/\/ returned to registers or to store returned values to a newly\n+\/\/ allocated inline type instance.\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n+address StubGenerator::generate_return_value_stub(address destination, const char* name, bool has_res) {\n+  \/\/ We need to save all registers the calling convention may use so\n+  \/\/ the runtime calls read or update those registers. This needs to\n+  \/\/ be in sync with SharedRuntime::java_return_convention().\n+  enum layout {\n+    pad_off = frame::arg_reg_save_area_bytes\/BytesPerInt, pad_off_2,\n+    rax_off, rax_off_2,\n+    j_rarg5_off, j_rarg5_2,\n+    j_rarg4_off, j_rarg4_2,\n+    j_rarg3_off, j_rarg3_2,\n+    j_rarg2_off, j_rarg2_2,\n+    j_rarg1_off, j_rarg1_2,\n+    j_rarg0_off, j_rarg0_2,\n+    j_farg0_off, j_farg0_2,\n+    j_farg1_off, j_farg1_2,\n+    j_farg2_off, j_farg2_2,\n+    j_farg3_off, j_farg3_2,\n+    j_farg4_off, j_farg4_2,\n+    j_farg5_off, j_farg5_2,\n+    j_farg6_off, j_farg6_2,\n+    j_farg7_off, j_farg7_2,\n+    rbp_off, rbp_off_2,\n+    return_off, return_off_2,\n+\n+    framesize\n+  };\n+\n+  CodeBuffer buffer(name, 1000, 512);\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+\n+  int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+  assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+  int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+  int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+  OopMapSet *oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+  map->set_callee_saved(VMRegImpl::stack2reg(rax_off), rax->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+  int start = __ offset();\n+\n+  __ subptr(rsp, frame_size_in_bytes - 8 \/* return address*\/);\n+\n+  __ movptr(Address(rsp, rbp_off * BytesPerInt), rbp);\n+  __ movdbl(Address(rsp, j_farg7_off * BytesPerInt), j_farg7);\n+  __ movdbl(Address(rsp, j_farg6_off * BytesPerInt), j_farg6);\n+  __ movdbl(Address(rsp, j_farg5_off * BytesPerInt), j_farg5);\n+  __ movdbl(Address(rsp, j_farg4_off * BytesPerInt), j_farg4);\n+  __ movdbl(Address(rsp, j_farg3_off * BytesPerInt), j_farg3);\n+  __ movdbl(Address(rsp, j_farg2_off * BytesPerInt), j_farg2);\n+  __ movdbl(Address(rsp, j_farg1_off * BytesPerInt), j_farg1);\n+  __ movdbl(Address(rsp, j_farg0_off * BytesPerInt), j_farg0);\n+\n+  __ movptr(Address(rsp, j_rarg0_off * BytesPerInt), j_rarg0);\n+  __ movptr(Address(rsp, j_rarg1_off * BytesPerInt), j_rarg1);\n+  __ movptr(Address(rsp, j_rarg2_off * BytesPerInt), j_rarg2);\n+  __ movptr(Address(rsp, j_rarg3_off * BytesPerInt), j_rarg3);\n+  __ movptr(Address(rsp, j_rarg4_off * BytesPerInt), j_rarg4);\n+  __ movptr(Address(rsp, j_rarg5_off * BytesPerInt), j_rarg5);\n+  __ movptr(Address(rsp, rax_off * BytesPerInt), rax);\n+\n+  int frame_complete = __ offset();\n+\n+  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+\n+  __ mov(c_rarg0, r15_thread);\n+  __ mov(c_rarg1, rax);\n+\n+  __ call(RuntimeAddress(destination));\n+\n+  \/\/ Set an oopmap for the call site.\n+\n+  oop_maps->add_gc_map( __ offset() - start, map);\n+\n+  \/\/ clear last_Java_sp\n+  __ reset_last_Java_frame(false);\n+\n+  __ movptr(rbp, Address(rsp, rbp_off * BytesPerInt));\n+  __ movdbl(j_farg7, Address(rsp, j_farg7_off * BytesPerInt));\n+  __ movdbl(j_farg6, Address(rsp, j_farg6_off * BytesPerInt));\n+  __ movdbl(j_farg5, Address(rsp, j_farg5_off * BytesPerInt));\n+  __ movdbl(j_farg4, Address(rsp, j_farg4_off * BytesPerInt));\n+  __ movdbl(j_farg3, Address(rsp, j_farg3_off * BytesPerInt));\n+  __ movdbl(j_farg2, Address(rsp, j_farg2_off * BytesPerInt));\n+  __ movdbl(j_farg1, Address(rsp, j_farg1_off * BytesPerInt));\n+  __ movdbl(j_farg0, Address(rsp, j_farg0_off * BytesPerInt));\n+\n+  __ movptr(j_rarg0, Address(rsp, j_rarg0_off * BytesPerInt));\n+  __ movptr(j_rarg1, Address(rsp, j_rarg1_off * BytesPerInt));\n+  __ movptr(j_rarg2, Address(rsp, j_rarg2_off * BytesPerInt));\n+  __ movptr(j_rarg3, Address(rsp, j_rarg3_off * BytesPerInt));\n+  __ movptr(j_rarg4, Address(rsp, j_rarg4_off * BytesPerInt));\n+  __ movptr(j_rarg5, Address(rsp, j_rarg5_off * BytesPerInt));\n+  __ movptr(rax, Address(rsp, rax_off * BytesPerInt));\n+\n+  __ addptr(rsp, frame_size_in_bytes-8);\n+\n+  \/\/ check for pending exceptions\n+  Label pending;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, pending);\n+\n+  if (has_res) {\n+    __ get_vm_result(rax, r15_thread);\n+  }\n+\n+  __ ret(0);\n+\n+  __ bind(pending);\n+\n+  __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ -------------\n+  \/\/ make sure all code is generated\n+  _masm->flush();\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, false);\n+  return stub->entry_point();\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":185,"deletions":13,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -542,0 +542,3 @@\n+  \/\/ interpreter or compiled code marshalling registers to\/from inline type instance\n+  address generate_return_value_stub(address destination, const char* name, bool has_res);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -178,0 +179,1 @@\n+  case Bytecodes::_fast_qputfield:\n@@ -370,0 +372,1 @@\n+  __ andl(rdx, ~JVM_CONSTANT_QDescBit);\n@@ -821,9 +824,27 @@\n-  \/\/ rax: index\n-  \/\/ rdx: array\n-  index_check(rdx, rax); \/\/ kills rbx\n-  do_oop_load(_masm,\n-              Address(rdx, rax,\n-                      UseCompressedOops ? Address::times_4 : Address::times_ptr,\n-                      arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n-              rax,\n-              IS_ARRAY);\n+  Register array = rdx;\n+  Register index = rax;\n+\n+  index_check(array, index); \/\/ kills rbx\n+  __ profile_array(rbx, array, rcx);\n+  if (UseFlatArray) {\n+    Label is_flat_array, done;\n+    __ test_flattened_array_oop(array, rbx, is_flat_array);\n+    do_oop_load(_masm,\n+                Address(array, index,\n+                        UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+                        arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n+                rax,\n+                IS_ARRAY);\n+    __ jmp(done);\n+    __ bind(is_flat_array);\n+    __ read_flattened_element(array, index, rbx, rcx, rax);\n+    __ bind(done);\n+  } else {\n+    do_oop_load(_masm,\n+                Address(array, index,\n+                        UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+                        arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n+                rax,\n+                IS_ARRAY);\n+  }\n+  __ profile_element(rbx, rax, rcx);\n@@ -1115,1 +1136,1 @@\n-  Label is_null, ok_is_subtype, done;\n+  Label is_null, is_flat_array, ok_is_subtype, done;\n@@ -1127,0 +1148,4 @@\n+\n+  __ profile_array(rdi, rdx, rbx);\n+  __ profile_element(rdi, rax, rbx);\n+\n@@ -1130,0 +1155,7 @@\n+  \/\/ Move array class to rdi\n+  __ load_klass(rdi, rdx, rscratch1);\n+  if (UseFlatArray) {\n+    __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));\n+    __ test_flattened_array_layout(rbx, is_flat_array);\n+  }\n+\n@@ -1132,3 +1164,2 @@\n-  \/\/ Move superklass into rax\n-  __ load_klass(rax, rdx, rscratch1);\n-  __ movptr(rax, Address(rax,\n+  \/\/ Move array element superklass into rax\n+  __ movptr(rax, Address(rdi,\n@@ -1139,1 +1170,2 @@\n-  __ gen_subtype_check(rbx, ok_is_subtype);\n+  \/\/ is \"rbx <: rax\" ? (value subclass <: array element superclass)\n+  __ gen_subtype_check(rbx, ok_is_subtype, false);\n@@ -1157,1 +1189,2 @@\n-  __ profile_null_seen(rbx);\n+  if (EnablePrimitiveClasses) {\n+    Label is_null_into_value_array_npe, store_null;\n@@ -1159,0 +1192,9 @@\n+    \/\/ No way to store null in null-free array\n+    __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);\n+    __ jmp(store_null);\n+\n+    __ bind(is_null_into_value_array_npe);\n+    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+\n+    __ bind(store_null);\n+  }\n@@ -1161,0 +1203,7 @@\n+  __ jmp(done);\n+\n+  if (UseFlatArray) {\n+    Label is_type_ok;\n+    __ bind(is_flat_array); \/\/ Store non-null value to flat\n+\n+    \/\/ Simplistic type check...\n@@ -1162,0 +1211,27 @@\n+    \/\/ Profile the not-null value's klass.\n+    __ load_klass(rbx, rax, rscratch1);\n+    \/\/ Move element klass into rax\n+    __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));\n+    \/\/ flat value array needs exact type match\n+    \/\/ is \"rax == rbx\" (value subclass == array element superclass)\n+    __ cmpptr(rax, rbx);\n+    __ jccb(Assembler::equal, is_type_ok);\n+\n+    __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n+\n+    __ bind(is_type_ok);\n+    \/\/ rbx: value's klass\n+    \/\/ rdx: array\n+    \/\/ rdi: array klass\n+    __ test_klass_is_empty_inline_type(rbx, rax, done);\n+\n+    \/\/ calc dst for copy\n+    __ movl(rax, at_tos_p1()); \/\/ index\n+    __ data_for_value_array_index(rdx, rdi, rax, rax);\n+\n+    \/\/ ...and src for copy\n+    __ movptr(rcx, at_tos());  \/\/ value\n+    __ data_for_oop(rcx, rcx, rbx);\n+\n+    __ access_value_copy(IN_HEAP, rcx, rax, rbx);\n+  }\n@@ -2330,1 +2406,1 @@\n-  Label not_taken;\n+  Label taken, not_taken;\n@@ -2332,0 +2408,36 @@\n+\n+  __ profile_acmp(rbx, rdx, rax, rcx);\n+\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  if (EnableValhalla) {\n+    __ cmpoop(rdx, rax);\n+    __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);\n+\n+    \/\/ might be substitutable, test if either rax or rdx is null\n+    __ testptr(rax, rax);\n+    __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);\n+    __ testptr(rdx, rdx);\n+    __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ and both are values ?\n+    __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+    __ andptr(rbx, is_inline_type_mask);\n+    __ cmpptr(rbx, is_inline_type_mask);\n+    __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ same value klass ?\n+    __ load_metadata(rbx, rdx);\n+    __ load_metadata(rcx, rax);\n+    __ cmpptr(rbx, rcx);\n+    __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);\n+\n+    \/\/ Know both are the same type, let's test for substitutability...\n+    if (cc == equal) {\n+      invoke_is_substitutable(rax, rdx, taken, not_taken);\n+    } else {\n+      invoke_is_substitutable(rax, rdx, not_taken, taken);\n+    }\n+    __ stop(\"Not reachable\");\n+  }\n+\n@@ -2334,0 +2446,1 @@\n+  __ bind(taken);\n@@ -2336,1 +2449,10 @@\n-  __ profile_not_taken_branch(rax);\n+  __ profile_not_taken_branch(rax, true);\n+}\n+\n+void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,\n+                                            Label& is_subst, Label& not_subst) {\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);\n+  \/\/ Restored...rax answer, jmp to outcome...\n+  __ testl(rax, rax);\n+  __ jcc(Assembler::zero, not_subst);\n+  __ jmp(is_subst);\n@@ -2606,1 +2728,2 @@\n-  __ remove_activation(state, rbcp);\n+\n+  __ remove_activation(state, rbcp, true, true, true);\n@@ -2804,0 +2927,1 @@\n+  const Register flags2 = rdx;\n@@ -2809,2 +2933,0 @@\n-  if (!is_static) pop_and_check_object(obj);\n-\n@@ -2813,1 +2935,9 @@\n-  Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;\n+  Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notInlineType;\n+\n+  if (!is_static) {\n+    __ movptr(rcx, Address(cache, index, Address::times_ptr,\n+                           in_bytes(ConstantPoolCache::base_offset() +\n+                                    ConstantPoolCacheEntry::f1_offset())));\n+  }\n+\n+  __ movl(flags2, flags);\n@@ -2823,0 +2953,1 @@\n+  if (!is_static) pop_and_check_object(obj);\n@@ -2832,0 +2963,1 @@\n+\n@@ -2834,1 +2966,1 @@\n-\n+   if (!is_static) pop_and_check_object(obj);\n@@ -2849,4 +2981,83 @@\n-  do_oop_load(_masm, field, rax);\n-  __ push(atos);\n-  if (!is_static && rc == may_rewrite) {\n-    patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+  if (!EnablePrimitiveClasses) {\n+    if (!is_static) pop_and_check_object(obj);\n+    do_oop_load(_masm, field, rax);\n+    __ push(atos);\n+    if (!is_static && rc == may_rewrite) {\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+    }\n+    __ jmp(Done);\n+  } else {\n+    if (is_static) {\n+      __ load_heap_oop(rax, field);\n+      Label is_null_free_inline_type, uninitialized;\n+      \/\/ Issue below if the static field has not been initialized yet\n+      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+        \/\/ field is not a null free inline type\n+        __ push(atos);\n+        __ jmp(Done);\n+      \/\/ field is a null free inline type, must not return null even if uninitialized\n+      __ bind(is_null_free_inline_type);\n+          __ testptr(rax, rax);\n+        __ jcc(Assembler::zero, uninitialized);\n+          __ push(atos);\n+          __ jmp(Done);\n+        __ bind(uninitialized);\n+          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+#ifdef _LP64\n+          Label slow_case, finish;\n+          __ movptr(rbx, Address(obj, java_lang_Class::klass_offset()));\n+          __ cmpb(Address(rbx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+          __ jcc(Assembler::notEqual, slow_case);\n+        __ get_default_value_oop(rbx, rscratch1, rax);\n+        __ jmp(finish);\n+        __ bind(slow_case);\n+#endif \/\/ LP64\n+          __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field),\n+                obj, flags2);\n+#ifdef _LP64\n+          __ bind(finish);\n+  #endif \/\/ _LP64\n+        __ verify_oop(rax);\n+        __ push(atos);\n+        __ jmp(Done);\n+    } else {\n+      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+      \/\/ field is not a null free inline type\n+      pop_and_check_object(obj);\n+      __ load_heap_oop(rax, field);\n+      __ push(atos);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+      }\n+      __ jmp(Done);\n+      __ bind(is_inline_type);\n+        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+          \/\/ field is not inlined\n+          __ movptr(rax, rcx);  \/\/ small dance required to preserve the klass_holder somewhere\n+          pop_and_check_object(obj);\n+          __ push(rax);\n+          __ load_heap_oop(rax, field);\n+          __ pop(rcx);\n+          __ testptr(rax, rax);\n+          __ jcc(Assembler::notZero, nonnull);\n+            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+            __ get_inline_type_field_klass(rcx, flags2, rbx);\n+            __ get_default_value_oop(rbx, rcx, rax);\n+          __ bind(nonnull);\n+          __ verify_oop(rax);\n+          __ push(atos);\n+          __ jmp(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+          pop_and_check_object(rax);\n+          __ read_inlined_field(rcx, flags2, rbx, rax);\n+          __ verify_oop(rax);\n+          __ push(atos);\n+      __ bind(rewrite_inline);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);\n+      }\n+        __ jmp(Done);\n+    }\n@@ -2854,1 +3065,0 @@\n-  __ jmp(Done);\n@@ -2857,0 +3067,3 @@\n+\n+  if (!is_static) pop_and_check_object(obj);\n+\n@@ -2956,0 +3169,22 @@\n+void TemplateTable::withfield() {\n+  transition(vtos, atos);\n+\n+  Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n+  Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n+\n+  resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));\n+\n+  Register cpentry = rbx;\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  __ lea(cpentry, Address(cache, index, Address::times_ptr,\n+                         in_bytes(cp_base_offset)));\n+  __ lea(rax, at_tos());\n+  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cpentry, rax);\n+  \/\/ new value type is returned in rbx\n+  \/\/ stack adjustment is returned in rax\n+  __ verify_oop(rbx);\n+  __ addptr(rsp, rax);\n+  __ movptr(rax, rbx);\n+}\n@@ -3051,0 +3286,1 @@\n+  const Register flags2 = rdx;\n@@ -3067,0 +3303,1 @@\n+  __ movl(flags2, flags);\n@@ -3069,1 +3306,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n@@ -3075,1 +3312,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n@@ -3081,1 +3318,1 @@\n-                                              Register obj, Register off, Register flags) {\n+                                              Register obj, Register off, Register flags, Register flags2) {\n@@ -3088,1 +3325,1 @@\n-        notLong, notFloat, notObj;\n+        notLong, notFloat, notObj, notInlineType;\n@@ -3131,6 +3368,53 @@\n-    __ pop(atos);\n-    if (!is_static) pop_and_check_object(obj);\n-    \/\/ Store into the field\n-    do_oop_store(_masm, field, rax);\n-    if (!is_static && rc == may_rewrite) {\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+    if (!EnablePrimitiveClasses) {\n+      __ pop(atos);\n+      if (!is_static) pop_and_check_object(obj);\n+      \/\/ Store into the field\n+      do_oop_store(_masm, field, rax);\n+      if (!is_static && rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+      }\n+      __ jmp(Done);\n+    } else {\n+      __ pop(atos);\n+      if (is_static) {\n+        Label is_inline_type;\n+        __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        __ null_check(rax);\n+        __ bind(is_inline_type);\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(Done);\n+      } else {\n+        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        \/\/ Not an inline type\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        __ bind(rewrite_not_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+        }\n+        __ jmp(Done);\n+        \/\/ Implementation of the inline type semantic\n+        __ bind(is_inline_type);\n+        __ null_check(rax);\n+        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+        \/\/ field is not inlined\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(rewrite_inline);\n+        __ bind(is_inlined);\n+        \/\/ field is inlined\n+        pop_and_check_object(obj);\n+        assert_different_registers(rax, rdx, obj, off);\n+        __ load_klass(rdx, rax, rscratch1);\n+        __ data_for_oop(rax, rax, rdx);\n+        __ addptr(obj, off);\n+        __ access_value_copy(IN_HEAP, rax, obj, rdx);\n+        __ bind(rewrite_inline);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);\n+        }\n+        __ jmp(Done);\n+      }\n@@ -3138,1 +3422,0 @@\n-    __ jmp(Done);\n@@ -3277,0 +3560,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/fall through\n@@ -3302,0 +3586,1 @@\n+    case Bytecodes::_fast_qputfield: \/\/ fall through\n@@ -3341,0 +3626,4 @@\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rscratch2, rdx);  \/\/ saving flags for is_inlined test\n+  }\n+\n@@ -3354,1 +3643,4 @@\n-  fast_storefield_helper(field, rax);\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+  }\n+  fast_storefield_helper(field, rax, rdx);\n@@ -3360,1 +3652,4 @@\n-  fast_storefield_helper(field, rax);\n+  if (bytecode() == Bytecodes::_fast_qputfield) {\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+  }\n+  fast_storefield_helper(field, rax, rdx);\n@@ -3365,1 +3660,1 @@\n-void TemplateTable::fast_storefield_helper(Address field, Register rax) {\n+void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {\n@@ -3369,0 +3664,17 @@\n+  case Bytecodes::_fast_qputfield:\n+    {\n+      Label is_inlined, done;\n+      __ null_check(rax);\n+      __ test_field_is_inlined(flags, rscratch1, is_inlined);\n+      \/\/ field is not inlined\n+      do_oop_store(_masm, field, rax);\n+      __ jmp(done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+      __ load_klass(rdx, rax, rscratch1);\n+      __ data_for_oop(rax, rax, rdx);\n+      __ lea(rcx, field);\n+      __ access_value_copy(IN_HEAP, rax, rcx, rdx);\n+      __ bind(done);\n+    }\n+    break;\n@@ -3370,1 +3682,3 @@\n-    do_oop_store(_masm, field, rax);\n+    {\n+      do_oop_store(_masm, field, rax);\n+    }\n@@ -3440,1 +3754,1 @@\n-  __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,\n+  __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,\n@@ -3447,1 +3761,1 @@\n-  Address field(rax, rbx, Address::times_1);\n+  Address field(rax, rdx, Address::times_1);\n@@ -3451,0 +3765,39 @@\n+  case Bytecodes::_fast_qgetfield:\n+    {\n+      Label is_inlined, nonnull, Done;\n+      __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,\n+                                   in_bytes(ConstantPoolCache::base_offset() +\n+                                            ConstantPoolCacheEntry::flags_offset())));\n+      __ test_field_is_inlined(rscratch1, rscratch2, is_inlined);\n+        \/\/ field is not inlined\n+        __ load_heap_oop(rax, field);\n+        __ testptr(rax, rax);\n+        __ jcc(Assembler::notZero, nonnull);\n+          __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n+                             in_bytes(ConstantPoolCache::base_offset() +\n+                                      ConstantPoolCacheEntry::flags_offset())));\n+          __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n+          __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n+                                       in_bytes(ConstantPoolCache::base_offset() +\n+                                                ConstantPoolCacheEntry::f1_offset())));\n+          __ get_inline_type_field_klass(rcx, rdx, rbx);\n+          __ get_default_value_oop(rbx, rcx, rax);\n+        __ bind(nonnull);\n+        __ verify_oop(rax);\n+        __ jmp(Done);\n+      __ bind(is_inlined);\n+      \/\/ field is inlined\n+        __ push(rdx); \/\/ save offset\n+        __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n+                           in_bytes(ConstantPoolCache::base_offset() +\n+                                    ConstantPoolCacheEntry::flags_offset())));\n+        __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n+        __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n+                                     in_bytes(ConstantPoolCache::base_offset() +\n+                                              ConstantPoolCacheEntry::f1_offset())));\n+        __ pop(rbx); \/\/ restore offset\n+        __ read_inlined_field(rcx, rdx, rbx, rax);\n+      __ bind(Done);\n+      __ verify_oop(rax);\n+    }\n+    break;\n@@ -3920,2 +4273,1 @@\n-  Label slow_case_no_pop;\n-  Label initialize_header;\n+  Label is_not_value;\n@@ -3931,1 +4283,1 @@\n-  __ jcc(Assembler::notEqual, slow_case_no_pop);\n+  __ jcc(Assembler::notEqual, slow_case);\n@@ -3935,1 +4287,7 @@\n-  __ push(rcx);  \/\/ save the contexts of klass for initializing the header\n+\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InlineKlassKind);\n+  __ jcc(Assembler::notEqual, is_not_value);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n+\n+  __ bind(is_not_value);\n@@ -3938,1 +4296,0 @@\n-  \/\/ make sure klass is fully initialized\n@@ -3942,14 +4299,2 @@\n-  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n-  __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));\n-  \/\/ test to see if it has a finalizer or is malformed in some way\n-  __ testl(rdx, Klass::_lh_instance_slow_path_bit);\n-  __ jcc(Assembler::notZero, slow_case);\n-\n-  \/\/ Allocate the instance:\n-  \/\/  If TLAB is enabled:\n-  \/\/    Try to allocate in the TLAB.\n-  \/\/    If fails, go to the slow path.\n-  \/\/    Initialize the allocation.\n-  \/\/    Exit.\n-  \/\/\n-  \/\/  Go to slow path.\n+  __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);\n+  __ jmp(done);\n@@ -3957,1 +4302,2 @@\n-  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n+  \/\/ slow case\n+  __ bind(slow_case);\n@@ -3959,7 +4305,2 @@\n-  if (UseTLAB) {\n-    NOT_LP64(__ get_thread(thread);)\n-    __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);\n-    if (ZeroTLAB) {\n-      \/\/ the fields have been already cleared\n-      __ jmp(initialize_header);\n-    }\n+  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n@@ -3967,4 +4308,4 @@\n-    \/\/ The object is initialized before the header.  If the object size is\n-    \/\/ zero, go directly to the header initialization.\n-    __ decrement(rdx, sizeof(oopDesc));\n-    __ jcc(Assembler::zero, initialize_header);\n+  __ get_constant_pool(rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n+   __ verify_oop(rax);\n@@ -3972,4 +4313,3 @@\n-    \/\/ Initialize topmost object field, divide rdx by 8, check if odd and\n-    \/\/ test if zero.\n-    __ xorl(rcx, rcx);    \/\/ use zero reg to clear memory (shorter code)\n-    __ shrl(rdx, LogBytesPerLong); \/\/ divide by 2*oopSize and set carry flag if odd\n+  \/\/ continue\n+  __ bind(done);\n+}\n@@ -3977,10 +4317,2 @@\n-    \/\/ rdx must have been multiple of 8\n-#ifdef ASSERT\n-    \/\/ make sure rdx was multiple of 8\n-    Label L;\n-    \/\/ Ignore partial flag stall after shrl() since it is debug VM\n-    __ jcc(Assembler::carryClear, L);\n-    __ stop(\"object size is not multiple of 2 - adjust this code\");\n-    __ bind(L);\n-    \/\/ rdx must be > 0, no extra check needed here\n-#endif\n+void TemplateTable::aconst_init() {\n+  transition(vtos, atos);\n@@ -3988,8 +4320,3 @@\n-    \/\/ initialize remaining object fields: rdx was a multiple of 8\n-    { Label loop;\n-    __ bind(loop);\n-    __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));\n-    __ decrement(rdx);\n-    __ jcc(Assembler::notZero, loop);\n-    }\n+  Label slow_case;\n+  Label done;\n+  Label is_value;\n@@ -3997,10 +4324,2 @@\n-    \/\/ initialize object header only.\n-    __ bind(initialize_header);\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n-              (intptr_t)markWord::prototype().value()); \/\/ header\n-    __ pop(rcx);   \/\/ get saved klass back in the register.\n-#ifdef _LP64\n-    __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n-    __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n-#endif\n-    __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n+  __ get_unsigned_2_byte_index_at_bcp(rdx, 1);\n+  __ get_cpool_and_tags(rcx, rax);\n@@ -4008,8 +4327,6 @@\n-    {\n-      SkipIfEqual skip_if(_masm, &DTraceAllocProbes, 0, rscratch1);\n-      \/\/ Trigger dtrace event for fastpath\n-      __ push(atos);\n-      __ call_VM_leaf(\n-           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), rax);\n-      __ pop(atos);\n-    }\n+  \/\/ Make sure the class we're about to instantiate has been resolved.\n+  \/\/ This is done before loading InstanceKlass to be consistent with the order\n+  \/\/ how Constant Pool is updated (see ConstantPool::klass_at_put)\n+  const int tags_offset = Array<u1>::base_offset_in_bytes();\n+  __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);\n+  __ jcc(Assembler::notEqual, slow_case);\n@@ -4017,2 +4334,18 @@\n-    __ jmp(done);\n-  }\n+  \/\/ get InstanceKlass\n+  __ load_resolved_klass_at_index(rcx, rcx, rdx);\n+\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InlineKlassKind);\n+  __ jcc(Assembler::equal, is_value);\n+\n+  \/\/ in the future, aconst_init will just return null instead of throwing an exception\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));\n+\n+  __ bind(is_value);\n+\n+  \/\/ make sure klass is fully initialized\n+  __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+  __ jcc(Assembler::notEqual, slow_case);\n+\n+  \/\/ have a resolved InlineKlass in rcx, return the default value oop from it\n+  __ get_default_value_oop(rcx, rdx, rax);\n+  __ jmp(done);\n@@ -4020,4 +4353,1 @@\n-  \/\/ slow case\n-  __ pop(rcx);   \/\/ restore stack pointer to what it was when we came in.\n-  __ bind(slow_case_no_pop);\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n@@ -4028,3 +4358,4 @@\n-  __ get_constant_pool(rarg1);\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n-   __ verify_oop(rax);\n+  __ get_constant_pool(rarg1);\n+\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n+      rarg1, rarg2);\n@@ -4033,1 +4364,1 @@\n-  \/\/ continue\n+  __ verify_oop(rax);\n@@ -4073,4 +4404,5 @@\n-  __ cmpb(Address(rdx, rbx,\n-                  Address::times_1,\n-                  Array<u1>::base_offset_in_bytes()),\n-          JVM_CONSTANT_Class);\n+  __ movzbl(rdx, Address(rdx, rbx,\n+      Address::times_1,\n+      Array<u1>::base_offset_in_bytes()));\n+  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n+  __ cmpl(rdx, JVM_CONSTANT_Class);\n@@ -4114,0 +4446,3 @@\n+  __ jmp(done);\n+\n+  __ bind(is_null);\n@@ -4117,4 +4452,15 @@\n-    __ jmp(done);\n-    __ bind(is_null);\n-  } else {\n-    __ bind(is_null);   \/\/ same as 'done'\n+\n+  if (EnablePrimitiveClasses) {\n+    \/\/ Get cpool & tags index\n+    __ get_cpool_and_tags(rcx, rdx); \/\/ rcx=cpool, rdx=tags array\n+    __ get_unsigned_2_byte_index_at_bcp(rbx, 1); \/\/ rbx=index\n+    \/\/ See if CP entry is a Q-descriptor\n+    __ movzbl(rcx, Address(rdx, rbx,\n+        Address::times_1,\n+        Array<u1>::base_offset_in_bytes()));\n+    __ andl (rcx, JVM_CONSTANT_QDescBit);\n+    __ cmpl(rcx, JVM_CONSTANT_QDescBit);\n+    __ jcc(Assembler::notEqual, done);\n+    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n+  }\n+\n@@ -4136,4 +4482,5 @@\n-  __ cmpb(Address(rdx, rbx,\n-                  Address::times_1,\n-                  Array<u1>::base_offset_in_bytes()),\n-          JVM_CONSTANT_Class);\n+  __ movzbl(rdx, Address(rdx, rbx,\n+        Address::times_1,\n+        Array<u1>::base_offset_in_bytes()));\n+  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n+  __ cmpl(rdx, JVM_CONSTANT_Class);\n@@ -4191,1 +4538,0 @@\n-\n@@ -4253,0 +4599,4 @@\n+  Label is_inline_type;\n+  __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+  __ test_markword_is_inline_type(rbx, is_inline_type);\n+\n@@ -4342,0 +4692,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -4350,0 +4705,11 @@\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  Label has_identity;\n+  __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n+  __ andptr(rbx, is_inline_type_mask);\n+  __ cmpl(rbx, is_inline_type_mask);\n+  __ jcc(Assembler::notEqual, has_identity);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n+  __ bind(has_identity);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":504,"deletions":138,"binary":false,"changes":642,"status":"modified"},{"patch":"@@ -1790,1 +1790,1 @@\n-  if (!UseFastStosb && UseSSE >= 2 && UseUnalignedLoadStores) {\n+  if (UseSSE >= 2 && UseUnalignedLoadStores) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2795,0 +2795,36 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      C2_MacroAssembler _masm(&cbuf);\n+      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+        uint con = (tf()->range_cc()->cnt() - 1);\n+        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = fast_out(i)->as_Proj();\n+          if (proj->_con == con) {\n+            \/\/ Set IsInit if rax is non-null (a non-null value is returned buffered or scalarized)\n+            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+            __ testq(rax, rax);\n+            __ set_byte_if_not_zero(toReg);\n+            __ movzbl(toReg, toReg);\n+            if (reg->is_stack()) {\n+              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+              __ movq(Address(rsp, st_off), toReg);\n+            }\n+            break;\n+          }\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ rax &= (rax & 1) - 1\n+        __ movptr(rscratch1, rax);\n+        __ andptr(rscratch1, 0x1);\n+        __ subptr(rscratch1, 0x1);\n+        __ andptr(rax, rscratch1);\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -493,0 +493,4 @@\n+  if (_entry_point == NULL) {\n+    \/\/ CallLeafNoFPInDirect\n+    return 3; \/\/ callq (register)\n+  }\n@@ -499,0 +503,1 @@\n+\n@@ -907,14 +912,1 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  int bangsize = C->output()->bang_size_in_bytes();\n-\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(VM_Version::supports_fast_class_init_checks(), \"sanity\");\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n-    Register klass = rscratch1;\n-\n-    __ mov_metadata(klass, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n-\n-    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+  __ verified_entry(C);\n@@ -922,1 +914,2 @@\n-    __ bind(L_skip_barrier);\n+  if (ra_->C->stub_function() == NULL) {\n+    __ entry_barrier();\n@@ -925,1 +918,3 @@\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != NULL);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    __ bind(*_verified_entry);\n+  }\n@@ -937,6 +932,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -990,23 +979,3 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  \/\/ Remove word for return adr already pushed\n-  \/\/ and RBP\n-  framesize -= 2*wordSize;\n-\n-  \/\/ Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here\n-\n-  if (framesize) {\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    if (framesize < 0x80) {\n-      emit_opcode(cbuf, 0x83); \/\/ addq rsp, #framesize\n-      emit_rm(cbuf, 0x3, 0x00, RSP_enc);\n-      emit_d8(cbuf, framesize);\n-    } else {\n-      emit_opcode(cbuf, 0x81); \/\/ addq rsp, #framesize\n-      emit_rm(cbuf, 0x3, 0x00, RSP_enc);\n-      emit_d32(cbuf, framesize);\n-    }\n-  }\n-\n-  \/\/ popq rbp\n-  emit_opcode(cbuf, 0x58 | RBP_enc);\n+  \/\/ Subtract two words to account for return address and rbp\n+  int initial_framesize = C->output()->frame_size_in_bytes() - 2*wordSize;\n+  __ remove_frame(initial_framesize, C->needs_stack_repair());\n@@ -1030,6 +999,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -1668,0 +1631,49 @@\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"MachVEPNode\");\n+}\n+#endif\n+\n+void MachVEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+{\n+  C2_MacroAssembler _masm(&cbuf);\n+  uint insts_size = cbuf.insts_size();\n+  if (!_verified) {\n+    if (UseCompressedClassPointers) {\n+      __ load_klass(rscratch1, j_rarg0, rscratch2);\n+      __ cmpptr(rax, rscratch1);\n+    } else {\n+      __ cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));\n+    }\n+    __ jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+  } else {\n+    \/\/ TODO 8284443 Avoid creation of temporary frame\n+    if (ra_->C->stub_function() == NULL) {\n+      __ verified_entry(ra_->C, 0);\n+      __ entry_barrier();\n+      int initial_framesize = ra_->C->output()->frame_size_in_bytes() - 2*wordSize;\n+      __ remove_frame(initial_framesize, false);\n+    }\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    if (Compile::current()->output()->in_scratch_emit_size()) {\n+      Label dummy_verified_entry;\n+      __ jmp(dummy_verified_entry);\n+    } else {\n+      __ jmp(*_verified_entry);\n+    }\n+  }\n+  \/* WARNING these NOPs are critical so that verified entry point is properly\n+     4 bytes aligned for patching by NativeJump::patch_verified_entry() *\/\n+  int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) & 0x3);\n+  nops_cnt &= 0x3; \/\/ Do not add nops if code is aligned.\n+  if (nops_cnt > 0) {\n+    __ nop(nops_cnt);\n+  }\n+}\n+\n@@ -1710,7 +1722,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n-\n@@ -3995,0 +4000,16 @@\n+\/\/ Indirect Narrow Oop Operand\n+operand indCompressedOop(rRegN reg) %{\n+  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(DecodeN reg);\n+\n+  op_cost(10);\n+  format %{\"[R12 + $reg << 3] (compressed oop addressing)\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0xc); \/\/ R12\n+    index($reg);\n+    scale(0x3);\n+    disp(0x0);\n+  %}\n+%}\n+\n@@ -4341,1 +4362,1 @@\n-               indCompressedOopOffset,\n+               indCompressedOop, indCompressedOopOffset,\n@@ -6927,0 +6948,13 @@\n+instruct castN2X(rRegL dst, rRegN src)\n+%{\n+  match(Set dst (CastP2X src));\n+\n+  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movptr($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n@@ -11442,0 +11476,1 @@\n+\n@@ -11444,1 +11479,1 @@\n-instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,\n+instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n@@ -11447,3 +11482,120 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                            Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Small ClearArray AVX512 non-constant length.\n+instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                       Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  ins_cost(125);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11497,2 +11649,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, false, knoreg);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false, $ktmp$$KRegister);\n@@ -11503,3 +11655,2 @@\n-\/\/ Small ClearArray AVX512 non-constant length.\n-instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegI zero,\n-                       Universe dummy, rFlagsReg cr)\n+instruct rep_stos_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                 Universe dummy, rFlagsReg cr)\n@@ -11507,2 +11658,2 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (UseAVX > 2));\n-  match(Set dummy (ClearArray cnt base));\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n@@ -11510,1 +11661,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11558,2 +11709,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, false, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true, $ktmp$$KRegister);\n@@ -11565,1 +11716,1 @@\n-instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,\n+instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n@@ -11568,3 +11719,99 @@\n-  predicate((UseAVX <=2) && ((ClearArrayNode*)n)->is_large());\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                                  Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large ClearArray AVX512.\n+instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                             Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11609,2 +11856,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, true, knoreg);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false, $ktmp$$KRegister);\n@@ -11615,3 +11862,2 @@\n-\/\/ Large ClearArray AVX512.\n-instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegI zero,\n-                             Universe dummy, rFlagsReg cr)\n+instruct rep_stos_large_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                       Universe dummy, rFlagsReg cr)\n@@ -11619,3 +11865,3 @@\n-  predicate((UseAVX > 2) && ((ClearArrayNode*)n)->is_large());\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -11660,2 +11906,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, true, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true, $ktmp$$KRegister);\n@@ -11667,1 +11913,1 @@\n-instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rRegI zero, kReg ktmp, Universe dummy, rFlagsReg cr)\n+instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, kReg ktmp, Universe dummy, rFlagsReg cr)\n@@ -11669,3 +11915,3 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() &&\n-              ((UseAVX > 2) && VM_Version::supports_avx512vlbw()));\n-  match(Set dummy (ClearArray cnt base));\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() &&\n+            ((UseAVX > 2) && VM_Version::supports_avx512vlbw()));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n@@ -11673,1 +11919,1 @@\n-  effect(TEMP tmp, TEMP zero, TEMP ktmp, KILL cr);\n+  effect(TEMP tmp, USE_KILL val, TEMP ktmp, KILL cr);\n@@ -11676,1 +11922,1 @@\n-   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n@@ -13480,0 +13726,15 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPInDirect(rRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == NULL);\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf_nofp,runtime indirect \" %}\n+  ins_encode %{\n+     __ call($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -13482,0 +13743,1 @@\n+  predicate(n->as_Call()->entry_point() != NULL);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":355,"deletions":93,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -56,7 +56,26 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(\n-                        MacroAssembler *masm,\n-                        int total_args_passed,\n-                        int comp_args_on_stack,\n-                        const BasicType *sig_bt,\n-                        const VMRegPair *regs,\n-                        AdapterFingerPrint *fingerprint) {\n+int SharedRuntime::java_return_convention(const BasicType *sig_bt,\n+                                           VMRegPair *regs,\n+                                           int total_args_passed) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n+                                                            int comp_args_on_stack,\n+                                                            const GrowableArray <SigEntry>* sig,\n+                                                            const VMRegPair* regs,\n+                                                            const GrowableArray <SigEntry>* sig_cc,\n+                                                            const VMRegPair* regs_cc,\n+                                                            const GrowableArray <SigEntry>* sig_cc_ro,\n+                                                            const VMRegPair* regs_cc_ro,\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n+  if (allocate_code_blob) {\n+    new_adapter = AdapterBlob::create(masm->code(), 0, 0, NULL);\n+  }\n@@ -67,0 +86,4 @@\n+    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -802,1 +802,1 @@\n-  return  false;\n+  return false;\n@@ -892,1 +892,2 @@\n-      strcmp(_matrule->_opType,\"Halt\"      )==0 )\n+      strcmp(_matrule->_opType,\"Halt\"      )==0 ||\n+      strcmp(_matrule->_opType,\"CallLeafNoFP\")==0)\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+                 Inline_Entry,\n+                 Verified_Inline_Entry,\n+                 Verified_Inline_Entry_RO,\n@@ -65,0 +68,1 @@\n+  void check(int e) const { assert(0 <= e && e < max_Entries, \"must be\"); }\n@@ -70,0 +74,3 @@\n+    _values[Inline_Entry  ] = 0;\n+    _values[Verified_Inline_Entry] = -1;\n+    _values[Verified_Inline_Entry_RO] = -1;\n@@ -78,2 +85,2 @@\n-  int value(Entries e) { return _values[e]; }\n-  void set_value(Entries e, int val) { _values[e] = val; }\n+  int value(Entries e) const { check(e); return _values[e]; }\n+  void set_value(Entries e, int val) { check(e); _values[e] = val; }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -214,0 +216,2 @@\n+  assert(!_gen->in_conditional_code(), \"LIRItem cannot be loaded in conditional code\");\n+\n@@ -609,1 +613,2 @@\n-void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info) {\n+void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no,\n+                                 CodeEmitInfo* info_for_exception, CodeEmitInfo* info, CodeStub* throw_imse_stub) {\n@@ -612,1 +617,1 @@\n-  CodeStub* slow_path = new MonitorEnterStub(object, lock, info);\n+  CodeStub* slow_path = new MonitorEnterStub(object, lock, info, throw_imse_stub, scratch);\n@@ -615,1 +620,1 @@\n-  __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception);\n+  __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception, throw_imse_stub);\n@@ -639,4 +644,9 @@\n-void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {\n-  klass2reg_with_patching(klass_reg, klass, info, is_unresolved);\n-  \/\/ If klass is not loaded we do not know if the klass has finalizers:\n-  if (UseFastNewInstance && klass->is_loaded()\n+void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, bool allow_inline, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {\n+  if (allow_inline) {\n+    assert(!is_unresolved && klass->is_loaded(), \"inline type klass should be resolved\");\n+    __ metadata2reg(klass->constant_encoding(), klass_reg);\n+  } else {\n+    klass2reg_with_patching(klass_reg, klass, info, is_unresolved);\n+  }\n+  \/\/ If klass is not loaded we do not know if the klass has finalizers or is an unexpected inline klass\n+  if (UseFastNewInstance && klass->is_loaded() && (allow_inline || !klass->is_inlinetype())\n@@ -656,2 +666,2 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);\n-    __ branch(lir_cond_always, slow_path);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, allow_inline ? Runtime1::new_instance_id : Runtime1::new_instance_no_inline_id);\n+    __ jump(slow_path);\n@@ -757,0 +767,10 @@\n+  if (!src->is_loaded_flattened_array() && !dst->is_loaded_flattened_array()) {\n+    flags &= ~LIR_OpArrayCopy::always_slow_path;\n+  }\n+  if (!src->maybe_flattened_array()) {\n+    flags &= ~LIR_OpArrayCopy::src_inlinetype_check;\n+  }\n+  if (!dst->maybe_flattened_array() && !dst->maybe_null_free_array()) {\n+    flags &= ~LIR_OpArrayCopy::dst_inlinetype_check;\n+  }\n+\n@@ -1561,2 +1581,4 @@\n-  _constants.append(c);\n-  _reg_for_constants.append(result);\n+  if (!in_conditional_code()) {\n+    _constants.append(c);\n+    _reg_for_constants.append(result);\n+  }\n@@ -1566,0 +1588,6 @@\n+void LIRGenerator::set_in_conditional_code(bool v) {\n+  assert(v != _in_conditional_code, \"must change state\");\n+  _in_conditional_code = v;\n+}\n+\n+\n@@ -1657,0 +1685,5 @@\n+  if (!inline_type_field_access_prolog(x)) {\n+    \/\/ Field store will always deopt due to unloaded field or holder klass\n+    return;\n+  }\n+\n@@ -1678,0 +1711,173 @@\n+\/\/ FIXME -- I can't find any other way to pass an address to access_load_at().\n+class TempResolvedAddress: public Instruction {\n+ public:\n+  TempResolvedAddress(ValueType* type, LIR_Opr addr) : Instruction(type) {\n+    set_operand(addr);\n+  }\n+  virtual void input_values_do(ValueVisitor*) {}\n+  virtual void visit(InstructionVisitor* v)   {}\n+  virtual const char* name() const  { return \"TempResolvedAddress\"; }\n+};\n+\n+LIR_Opr LIRGenerator::get_and_load_element_address(LIRItem& array, LIRItem& index) {\n+  ciType* array_type = array.value()->declared_type();\n+  ciFlatArrayKlass* flat_array_klass = array_type->as_flat_array_klass();\n+  assert(flat_array_klass->is_loaded(), \"must be\");\n+\n+  int array_header_size = flat_array_klass->array_header_in_bytes();\n+  int shift = flat_array_klass->log2_element_size();\n+\n+#ifndef _LP64\n+  LIR_Opr index_op = new_register(T_INT);\n+  \/\/ FIXME -- on 32-bit, the shift below can overflow, so we need to check that\n+  \/\/ the top (shift+1) bits of index_op must be zero, or\n+  \/\/ else throw ArrayIndexOutOfBoundsException\n+  if (index.result()->is_constant()) {\n+    jint const_index = index.result()->as_jint();\n+    __ move(LIR_OprFact::intConst(const_index << shift), index_op);\n+  } else {\n+    __ shift_left(index_op, shift, index.result());\n+  }\n+#else\n+  LIR_Opr index_op = new_register(T_LONG);\n+  if (index.result()->is_constant()) {\n+    jint const_index = index.result()->as_jint();\n+    __ move(LIR_OprFact::longConst(const_index << shift), index_op);\n+  } else {\n+    __ convert(Bytecodes::_i2l, index.result(), index_op);\n+    \/\/ Need to shift manually, as LIR_Address can scale only up to 3.\n+    __ shift_left(index_op, shift, index_op);\n+  }\n+#endif\n+\n+  LIR_Opr elm_op = new_pointer_register();\n+  LIR_Address* elm_address = generate_address(array.result(), index_op, 0, array_header_size, T_ADDRESS);\n+  __ leal(LIR_OprFact::address(elm_address), elm_op);\n+  return elm_op;\n+}\n+\n+void LIRGenerator::access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset) {\n+  assert(field != NULL, \"Need a subelement type specified\");\n+\n+  \/\/ Find the starting address of the source (inside the array)\n+  LIR_Opr elm_op = get_and_load_element_address(array, index);\n+\n+  BasicType subelt_type = field->type()->basic_type();\n+  TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(subelt_type), elm_op);\n+  LIRItem elm_item(elm_resolved_addr, this);\n+\n+  DecoratorSet decorators = IN_HEAP;\n+  access_load_at(decorators, subelt_type,\n+                     elm_item, LIR_OprFact::intConst(sub_offset), result,\n+                     NULL, NULL);\n+\n+  if (field->is_null_free()) {\n+    assert(field->type()->is_loaded(), \"Must be\");\n+    assert(field->type()->is_inlinetype(), \"Must be if loaded\");\n+    assert(field->type()->as_inline_klass()->is_initialized(), \"Must be\");\n+    LabelObj* L_end = new LabelObj();\n+    __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n+    __ branch(lir_cond_notEqual, L_end->label());\n+    set_in_conditional_code(true);\n+    Constant* default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+    if (default_value->is_pinned()) {\n+      __ move(LIR_OprFact::value_type(default_value->type()), result);\n+    } else {\n+      __ move(load_constant(default_value), result);\n+    }\n+    __ branch_destination(L_end->label());\n+    set_in_conditional_code(false);\n+  }\n+}\n+\n+void LIRGenerator::access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item,\n+                                          ciField* field, int sub_offset) {\n+  assert(sub_offset == 0 || field != NULL, \"Sanity check\");\n+\n+  \/\/ Find the starting address of the source (inside the array)\n+  LIR_Opr elm_op = get_and_load_element_address(array, index);\n+\n+  ciInlineKlass* elem_klass = NULL;\n+  if (field != NULL) {\n+    elem_klass = field->type()->as_inline_klass();\n+  } else {\n+    elem_klass = array.value()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass();\n+  }\n+  for (int i = 0; i < elem_klass->nof_nonstatic_fields(); i++) {\n+    ciField* inner_field = elem_klass->nonstatic_field_at(i);\n+    assert(!inner_field->is_flattened(), \"flattened fields must have been expanded\");\n+    int obj_offset = inner_field->offset();\n+    int elm_offset = obj_offset - elem_klass->first_field_offset() + sub_offset; \/\/ object header is not stored in array.\n+    BasicType field_type = inner_field->type()->basic_type();\n+\n+    \/\/ Types which are smaller than int are still passed in an int register.\n+    BasicType reg_type = field_type;\n+    switch (reg_type) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+    case T_SHORT:\n+    case T_CHAR:\n+      reg_type = T_INT;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+    LIR_Opr temp = new_register(reg_type);\n+    TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(field_type), elm_op);\n+    LIRItem elm_item(elm_resolved_addr, this);\n+\n+    DecoratorSet decorators = IN_HEAP;\n+    if (is_load) {\n+      access_load_at(decorators, field_type,\n+                     elm_item, LIR_OprFact::intConst(elm_offset), temp,\n+                     NULL, NULL);\n+      access_store_at(decorators, field_type,\n+                      obj_item, LIR_OprFact::intConst(obj_offset), temp,\n+                      NULL, NULL);\n+    } else {\n+      access_load_at(decorators, field_type,\n+                     obj_item, LIR_OprFact::intConst(obj_offset), temp,\n+                     NULL, NULL);\n+      access_store_at(decorators, field_type,\n+                      elm_item, LIR_OprFact::intConst(elm_offset), temp,\n+                      NULL, NULL);\n+    }\n+  }\n+}\n+\n+void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {\n+  LIR_Opr tmp = new_register(T_METADATA);\n+  __ check_flattened_array(array, value, tmp, slow_path);\n+}\n+\n+void LIRGenerator::check_null_free_array(LIRItem& array, LIRItem& value, CodeEmitInfo* info) {\n+  LabelObj* L_end = new LabelObj();\n+  LIR_Opr tmp = new_register(T_METADATA);\n+  __ check_null_free_array(array.result(), tmp);\n+  __ branch(lir_cond_equal, L_end->label());\n+  __ null_check(value.result(), info);\n+  __ branch_destination(L_end->label());\n+}\n+\n+bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {\n+  if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {\n+    ciType* type = x->value()->declared_type();\n+    if (type != NULL && type->is_klass()) {\n+      ciKlass* klass = type->as_klass();\n+      if (!klass->can_be_inline_klass() || (klass->is_inlinetype() && !klass->as_inline_klass()->flatten_array())) {\n+        \/\/ This is known to be a non-flattened object. If the array is flattened,\n+        \/\/ it will be caught by the code generated by array_store_check().\n+        return false;\n+      }\n+    }\n+    \/\/ We're not 100% sure, so let's do the flattened_array_store_check.\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool LIRGenerator::needs_null_free_array_store_check(StoreIndexed* x) {\n+  return x->elt_type() == T_OBJECT && x->array()->maybe_null_free_array();\n+}\n+\n@@ -1680,0 +1886,2 @@\n+  assert(x->elt_type() != T_ARRAY, \"never used\");\n+  bool is_loaded_flattened_array = x->array()->is_loaded_flattened_array();\n@@ -1683,3 +1891,3 @@\n-  bool needs_store_check = obj_store && (x->value()->as_Constant() == NULL ||\n-                                         !get_jobject_constant(x->value())->is_null_object() ||\n-                                         x->should_profile());\n+  bool needs_store_check = obj_store && !(is_loaded_flattened_array && x->is_exact_flattened_array_store()) &&\n+                                        (x->value()->as_Constant() == NULL ||\n+                                         !get_jobject_constant(x->value())->is_null_object());\n@@ -1698,2 +1906,3 @@\n-\n-  if (needs_store_check || x->check_boolean()) {\n+\n+  if (needs_store_check || x->check_boolean()\n+      || is_loaded_flattened_array || needs_flattened_array_store_check(x) || needs_null_free_array_store_check(x)) {\n@@ -1728,0 +1937,16 @@\n+  if (x->should_profile()) {\n+    if (x->array()->is_loaded_flattened_array()) {\n+      \/\/ No need to profile a store to a flattened array of known type. This can happen if\n+      \/\/ the type only became known after optimizations (for example, after the PhiSimplifier).\n+      x->set_should_profile(false);\n+    } else {\n+      ciMethodData* md = NULL;\n+      ciArrayLoadStoreData* load_store = NULL;\n+      profile_array_type(x, md, load_store);\n+      if (x->array()->maybe_null_free_array()) {\n+        profile_null_free_array(array, md, load_store);\n+      }\n+      profile_element_type(x->value(), md, load_store);\n+    }\n+  }\n+\n@@ -1730,1 +1955,1 @@\n-    array_store_check(value.result(), array.result(), store_check_info, x->profiled_method(), x->profiled_bci());\n+    array_store_check(value.result(), array.result(), store_check_info, NULL, -1);\n@@ -1733,4 +1958,21 @@\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n-  if (x->check_boolean()) {\n-    decorators |= C1_MASK_BOOLEAN;\n-  }\n+  if (is_loaded_flattened_array) {\n+    if (!x->value()->is_null_free()) {\n+      __ null_check(value.result(), new CodeEmitInfo(range_check_info));\n+    }\n+    \/\/ If array element is an empty inline type, no need to copy anything\n+    if (!x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_empty()) {\n+      access_flattened_array(false, array, index, value);\n+    }\n+  } else {\n+    StoreFlattenedArrayStub* slow_path = NULL;\n+\n+    if (needs_flattened_array_store_check(x)) {\n+      \/\/ Check if we indeed have a flattened array\n+      index.load_item();\n+      slow_path = new StoreFlattenedArrayStub(array.result(), index.result(), value.result(), state_for(x, x->state_before()));\n+      check_flattened_array(array.result(), value.result(), slow_path);\n+      set_in_conditional_code(true);\n+    } else if (needs_null_free_array_store_check(x)) {\n+      CodeEmitInfo* info = new CodeEmitInfo(range_check_info);\n+      check_null_free_array(array, value, info);\n+    }\n@@ -1738,2 +1980,12 @@\n-  access_store_at(decorators, x->elt_type(), array, index.result(), value.result(),\n-                  NULL, null_check_info);\n+    DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+    if (x->check_boolean()) {\n+      decorators |= C1_MASK_BOOLEAN;\n+    }\n+\n+    access_store_at(decorators, x->elt_type(), array, index.result(), value.result(),\n+                    NULL, null_check_info);\n+    if (slow_path != NULL) {\n+      __ branch_destination(slow_path->continuation());\n+      set_in_conditional_code(false);\n+    }\n+  }\n@@ -1820,0 +2072,25 @@\n+bool LIRGenerator::inline_type_field_access_prolog(AccessField* x) {\n+  ciField* field = x->field();\n+  assert(!field->is_flattened(), \"Flattened field access should have been expanded\");\n+  if (!field->is_null_free()) {\n+    return true; \/\/ Not an inline type field\n+  }\n+  \/\/ Deoptimize if the access is non-static and requires patching (holder not loaded\n+  \/\/ or not accessible) because then we only have partial field information and the\n+  \/\/ field could be flattened (see ciField constructor).\n+  bool could_be_flat = !x->is_static() && x->needs_patching();\n+  \/\/ Deoptimize if we load from a static field with an uninitialized type because we\n+  \/\/ need to throw an exception if initialization of the type failed.\n+  bool not_initialized = x->is_static() && x->as_LoadField() != NULL &&\n+      !field->type()->as_instance_klass()->is_initialized();\n+  if (could_be_flat || not_initialized) {\n+    CodeEmitInfo* info = state_for(x, x->state_before());\n+    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n+                                        Deoptimization::Reason_unloaded,\n+                                        Deoptimization::Action_make_not_entrant);\n+    __ jump(stub);\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -1849,0 +2126,7 @@\n+  if (!inline_type_field_access_prolog(x)) {\n+    \/\/ Field load will always deopt due to unloaded field or holder klass\n+    LIR_Opr result = rlock_result(x, field_type);\n+    __ move(LIR_OprFact::oopConst(NULL), result);\n+    return;\n+  }\n+\n@@ -1877,0 +2161,33 @@\n+\n+  ciField* field = x->field();\n+  if (field->is_null_free()) {\n+    \/\/ Load from non-flattened inline type field requires\n+    \/\/ a null check to replace null with the default value.\n+    ciInstanceKlass* holder = field->holder();\n+    if (field->is_static() && holder->is_loaded()) {\n+      ciObject* val = holder->java_mirror()->field_value(field).as_object();\n+      if (!val->is_null_object()) {\n+        \/\/ Static field is initialized, we don't need to perform a null check.\n+        return;\n+      }\n+    }\n+    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+    if (inline_klass->is_initialized()) {\n+      LabelObj* L_end = new LabelObj();\n+      __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n+      __ branch(lir_cond_notEqual, L_end->label());\n+      set_in_conditional_code(true);\n+      Constant* default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n+      if (default_value->is_pinned()) {\n+        __ move(LIR_OprFact::value_type(default_value->type()), result);\n+      } else {\n+        __ move(load_constant(default_value), result);\n+      }\n+      __ branch_destination(L_end->label());\n+      set_in_conditional_code(false);\n+    } else {\n+      __ cmp(lir_cond_equal, result, LIR_OprFact::oopConst(NULL));\n+      __ branch(lir_cond_equal, new DeoptimizeStub(info, Deoptimization::Reason_uninitialized,\n+                                                         Deoptimization::Action_make_not_entrant));\n+    }\n+  }\n@@ -2021,1 +2338,68 @@\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+  ciMethodData* md = NULL;\n+  ciArrayLoadStoreData* load_store = NULL;\n+  if (x->should_profile()) {\n+    if (x->array()->is_loaded_flattened_array()) {\n+      \/\/ No need to profile a load from a flattened array of known type. This can happen if\n+      \/\/ the type only became known after optimizations (for example, after the PhiSimplifier).\n+      x->set_should_profile(false);\n+    } else {\n+      profile_array_type(x, md, load_store);\n+    }\n+  }\n+\n+  Value element;\n+  if (x->vt() != NULL) {\n+    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    \/\/ Find the destination address (of the NewInlineTypeInstance).\n+    LIRItem obj_item(x->vt(), this);\n+\n+    access_flattened_array(true, array, index, obj_item,\n+                           x->delayed() == NULL ? 0 : x->delayed()->field(),\n+                           x->delayed() == NULL ? 0 : x->delayed()->offset());\n+    set_no_result(x);\n+  } else if (x->delayed() != NULL) {\n+    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    LIR_Opr result = rlock_result(x, x->delayed()->field()->type()->basic_type());\n+    access_sub_element(array, index, result, x->delayed()->field(), x->delayed()->offset());\n+  } else if (x->array() != NULL && x->array()->is_loaded_flattened_array() &&\n+             x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_initialized() &&\n+             x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_empty()) {\n+    \/\/ Load the default instance instead of reading the element\n+    ciInlineKlass* elem_klass = x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass();\n+    LIR_Opr result = rlock_result(x, x->elt_type());\n+    assert(elem_klass->is_initialized(), \"Must be\");\n+    Constant* default_value = new Constant(new InstanceConstant(elem_klass->default_instance()));\n+    if (default_value->is_pinned()) {\n+      __ move(LIR_OprFact::value_type(default_value->type()), result);\n+    } else {\n+      __ move(load_constant(default_value), result);\n+    }\n+  } else {\n+    LIR_Opr result = rlock_result(x, x->elt_type());\n+    LoadFlattenedArrayStub* slow_path = NULL;\n+\n+    if (x->should_profile() && x->array()->maybe_null_free_array()) {\n+      profile_null_free_array(array, md, load_store);\n+    }\n+\n+    if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {\n+      assert(x->delayed() == NULL, \"Delayed LoadIndexed only apply to loaded_flattened_arrays\");\n+      index.load_item();\n+      \/\/ if we are loading from flattened array, load it using a runtime call\n+      slow_path = new LoadFlattenedArrayStub(array.result(), index.result(), result, state_for(x, x->state_before()));\n+      check_flattened_array(array.result(), LIR_OprFact::illegalOpr, slow_path);\n+      set_in_conditional_code(true);\n+    }\n+\n+    DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+    access_load_at(decorators, x->elt_type(),\n+                   array, index.result(), result,\n+                   NULL, null_check_info);\n+\n+    if (slow_path != NULL) {\n+      __ branch_destination(slow_path->continuation());\n+      set_in_conditional_code(false);\n+    }\n+\n+    element = x;\n+  }\n@@ -2023,4 +2407,3 @@\n-  LIR_Opr result = rlock_result(x, x->elt_type());\n-  access_load_at(decorators, x->elt_type(),\n-                 array, index.result(), result,\n-                 NULL, null_check_info);\n+  if (x->should_profile()) {\n+    profile_element_type(element, md, load_store);\n+  }\n@@ -2029,0 +2412,12 @@\n+void LIRGenerator::do_Deoptimize(Deoptimize* x) {\n+  \/\/ This happens only when a class X uses the withfield\/aconst_init bytecode\n+  \/\/ to refer to an inline class V, where V has not yet been loaded\/resolved.\n+  \/\/ This is not a common case. Let's just deoptimize.\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+  CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n+                                      Deoptimization::Reason_unloaded,\n+                                      Deoptimization::Action_make_not_entrant);\n+  __ jump(stub);\n+  LIR_Opr reg = rlock_result(x, T_OBJECT);\n+  __ move(LIR_OprFact::oopConst(NULL), reg);\n+}\n@@ -2527,1 +2922,1 @@\n-  if (do_update) {\n+  if (do_update && signature_at_call_k != NULL) {\n@@ -2612,0 +3007,46 @@\n+void LIRGenerator::profile_flags(ciMethodData* md, ciProfileData* data, int flag, LIR_Condition condition) {\n+  assert(md != NULL && data != NULL, \"should have been initialized\");\n+  LIR_Opr mdp = new_register(T_METADATA);\n+  __ metadata2reg(md->constant_encoding(), mdp);\n+  LIR_Address* addr = new LIR_Address(mdp, md->byte_offset_of_slot(data, DataLayout::flags_offset()), T_BYTE);\n+  LIR_Opr flags = new_register(T_INT);\n+  __ move(addr, flags);\n+  if (condition != lir_cond_always) {\n+    LIR_Opr update = new_register(T_INT);\n+    __ cmove(condition, LIR_OprFact::intConst(0), LIR_OprFact::intConst(flag), update, T_INT);\n+  } else {\n+    __ logical_or(flags, LIR_OprFact::intConst(flag), flags);\n+  }\n+  __ store(flags, addr);\n+}\n+\n+void LIRGenerator::profile_null_free_array(LIRItem array, ciMethodData* md, ciArrayLoadStoreData* load_store) {\n+  assert(compilation()->profile_array_accesses(), \"array access profiling is disabled\");\n+  LabelObj* L_end = new LabelObj();\n+  LIR_Opr tmp = new_register(T_METADATA);\n+  __ check_null_free_array(array.result(), tmp);\n+\n+  profile_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), lir_cond_equal);\n+}\n+\n+void LIRGenerator::profile_array_type(AccessIndexed* x, ciMethodData*& md, ciArrayLoadStoreData*& load_store) {\n+  assert(compilation()->profile_array_accesses(), \"array access profiling is disabled\");\n+  int bci = x->profiled_bci();\n+  md = x->profiled_method()->method_data();\n+  assert(md != NULL, \"Sanity\");\n+  ciProfileData* data = md->bci_to_data(bci);\n+  assert(data != NULL && data->is_ArrayLoadStoreData(), \"incorrect profiling entry\");\n+  load_store = (ciArrayLoadStoreData*)data;\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(load_store, ArrayLoadStoreData::array_offset()), 0,\n+               load_store->array()->type(), x->array(), mdp, true, NULL, NULL);\n+}\n+\n+void LIRGenerator::profile_element_type(Value element, ciMethodData* md, ciArrayLoadStoreData* load_store) {\n+  assert(compilation()->profile_array_accesses(), \"array access profiling is disabled\");\n+  assert(md != NULL && load_store != NULL, \"should have been initialized\");\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(load_store, ArrayLoadStoreData::element_offset()), 0,\n+               load_store->element()->type(), element, mdp, false, NULL, NULL);\n+}\n+\n@@ -2692,0 +3133,8 @@\n+  if (method()->has_scalarized_args()) {\n+    \/\/ Check if deoptimization was triggered (i.e. orig_pc was set) while buffering scalarized inline type arguments\n+    \/\/ in the entry point (see comments in frame::deoptimize). If so, deoptimize only now that we have the right state.\n+    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, 0), NULL, false);\n+    CodeStub* deopt_stub = new DeoptimizeStub(info, Deoptimization::Reason_none, Deoptimization::Action_none);\n+    __ append(new LIR_Op0(lir_check_orig_pc));\n+    __ branch(lir_cond_notEqual, deopt_stub);\n+  }\n@@ -2707,0 +3156,14 @@\n+void LIRGenerator::invoke_load_one_argument(LIRItem* param, LIR_Opr loc) {\n+  if (loc->is_register()) {\n+    param->load_item_force(loc);\n+  } else {\n+    LIR_Address* addr = loc->as_address_ptr();\n+    param->load_for_store(addr->type());\n+    assert(addr->type() != T_PRIMITIVE_OBJECT, \"not supported yet\");\n+    if (addr->type() == T_OBJECT) {\n+      __ move_wide(param->result(), addr);\n+    } else {\n+      __ move(param->result(), addr);\n+    }\n+  }\n+}\n@@ -2714,10 +3177,1 @@\n-    if (loc->is_register()) {\n-      param->load_item_force(loc);\n-    } else {\n-      LIR_Address* addr = loc->as_address_ptr();\n-      param->load_for_store(addr->type());\n-      if (addr->type() == T_OBJECT) {\n-        __ move_wide(param->result(), addr);\n-      } else\n-        __ move(param->result(), addr);\n-    }\n+    invoke_load_one_argument(param, loc);\n@@ -2889,1 +3343,1 @@\n-  if (can_inline_as_constant(right.value())) {\n+  if (can_inline_as_constant(right.value()) && !x->substitutability_check()) {\n@@ -2892,0 +3346,1 @@\n+    \/\/ substitutability_check() needs to use right as a base register.\n@@ -2899,3 +3354,60 @@\n-  LIR_Opr reg = rlock_result(x);\n-  __ cmp(lir_cond(x->cond()), left.result(), right.result());\n-  __ cmove(lir_cond(x->cond()), t_val.result(), f_val.result(), reg, as_BasicType(x->x()->type()));\n+  if (x->substitutability_check()) {\n+    substitutability_check(x, left, right, t_val, f_val);\n+  } else {\n+    LIR_Opr reg = rlock_result(x);\n+    __ cmp(lir_cond(x->cond()), left.result(), right.result());\n+    __ cmove(lir_cond(x->cond()), t_val.result(), f_val.result(), reg, as_BasicType(x->x()->type()));\n+  }\n+}\n+\n+void LIRGenerator::substitutability_check(IfOp* x, LIRItem& left, LIRItem& right, LIRItem& t_val, LIRItem& f_val) {\n+  assert(x->cond() == If::eql || x->cond() == If::neq, \"must be\");\n+  bool is_acmpeq = (x->cond() == If::eql);\n+  LIR_Opr equal_result     = is_acmpeq ? t_val.result() : f_val.result();\n+  LIR_Opr not_equal_result = is_acmpeq ? f_val.result() : t_val.result();\n+  LIR_Opr result = rlock_result(x);\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+\n+  substitutability_check_common(x->x(), x->y(), left, right, equal_result, not_equal_result, result, info);\n+}\n+\n+void LIRGenerator::substitutability_check(If* x, LIRItem& left, LIRItem& right) {\n+  LIR_Opr equal_result     = LIR_OprFact::intConst(1);\n+  LIR_Opr not_equal_result = LIR_OprFact::intConst(0);\n+  LIR_Opr result = new_register(T_INT);\n+  CodeEmitInfo* info = state_for(x, x->state_before());\n+\n+  substitutability_check_common(x->x(), x->y(), left, right, equal_result, not_equal_result, result, info);\n+\n+  assert(x->cond() == If::eql || x->cond() == If::neq, \"must be\");\n+  __ cmp(lir_cond(x->cond()), result, equal_result);\n+}\n+\n+void LIRGenerator::substitutability_check_common(Value left_val, Value right_val, LIRItem& left, LIRItem& right,\n+                                                 LIR_Opr equal_result, LIR_Opr not_equal_result, LIR_Opr result,\n+                                                 CodeEmitInfo* info) {\n+  LIR_Opr tmp1 = LIR_OprFact::illegalOpr;\n+  LIR_Opr tmp2 = LIR_OprFact::illegalOpr;\n+  LIR_Opr left_klass_op = LIR_OprFact::illegalOpr;\n+  LIR_Opr right_klass_op = LIR_OprFact::illegalOpr;\n+\n+  ciKlass* left_klass  = left_val ->as_loaded_klass_or_null();\n+  ciKlass* right_klass = right_val->as_loaded_klass_or_null();\n+\n+  if ((left_klass == NULL || right_klass == NULL) ||\/\/ The klass is still unloaded, or came from a Phi node.\n+      !left_klass->is_inlinetype() || !right_klass->is_inlinetype()) {\n+    init_temps_for_substitutability_check(tmp1, tmp2);\n+  }\n+\n+  if (left_klass != NULL && left_klass->is_inlinetype() && left_klass == right_klass) {\n+    \/\/ No need to load klass -- the operands are statically known to be the same inline klass.\n+  } else {\n+    BasicType t_klass = UseCompressedOops ? T_INT : T_METADATA;\n+    left_klass_op = new_register(t_klass);\n+    right_klass_op = new_register(t_klass);\n+  }\n+\n+  CodeStub* slow_path = new SubstitutabilityCheckStub(left.result(), right.result(), info);\n+  __ substitutability_check(result, left.result(), right.result(), equal_result, not_equal_result,\n+                            tmp1, tmp2,\n+                            left_klass, right_klass, left_klass_op, right_klass_op, info, slow_path);\n@@ -3172,1 +3684,1 @@\n-    ciReturnTypeEntry* ret = data->is_CallTypeData() ? ((ciCallTypeData*)data)->ret() : ((ciVirtualCallTypeData*)data)->ret();\n+    ciSingleTypeEntry* ret = data->is_CallTypeData() ? ((ciCallTypeData*)data)->ret() : ((ciVirtualCallTypeData*)data)->ret();\n@@ -3193,0 +3705,47 @@\n+bool LIRGenerator::profile_inline_klass(ciMethodData* md, ciProfileData* data, Value value, int flag) {\n+  ciKlass* klass = value->as_loaded_klass_or_null();\n+  if (klass != NULL) {\n+    if (klass->is_inlinetype()) {\n+      profile_flags(md, data, flag, lir_cond_always);\n+    } else if (klass->can_be_inline_klass()) {\n+      return false;\n+    }\n+  } else {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\n+void LIRGenerator::do_ProfileACmpTypes(ProfileACmpTypes* x) {\n+  ciMethod* method = x->method();\n+  assert(method != NULL, \"method should be set if branch is profiled\");\n+  ciMethodData* md = method->method_data_or_null();\n+  assert(md != NULL, \"Sanity\");\n+  ciProfileData* data = md->bci_to_data(x->bci());\n+  assert(data != NULL, \"must have profiling data\");\n+  assert(data->is_ACmpData(), \"need BranchData for two-way branches\");\n+  ciACmpData* acmp = (ciACmpData*)data;\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(acmp, ACmpData::left_offset()), 0,\n+               acmp->left()->type(), x->left(), mdp, !x->left_maybe_null(), NULL, NULL);\n+  int flags_offset = md->byte_offset_of_slot(data, DataLayout::flags_offset());\n+  if (!profile_inline_klass(md, acmp, x->left(), ACmpData::left_inline_type_byte_constant())) {\n+    LIR_Opr mdp = new_register(T_METADATA);\n+    __ metadata2reg(md->constant_encoding(), mdp);\n+    LIRItem value(x->left(), this);\n+    value.load_item();\n+    __ profile_inline_type(new LIR_Address(mdp, flags_offset, T_INT), value.result(), ACmpData::left_inline_type_byte_constant(), new_register(T_INT), !x->left_maybe_null());\n+  }\n+  profile_type(md, md->byte_offset_of_slot(acmp, ACmpData::left_offset()),\n+               in_bytes(ACmpData::right_offset()) - in_bytes(ACmpData::left_offset()),\n+               acmp->right()->type(), x->right(), mdp, !x->right_maybe_null(), NULL, NULL);\n+  if (!profile_inline_klass(md, acmp, x->right(), ACmpData::right_inline_type_byte_constant())) {\n+    LIR_Opr mdp = new_register(T_METADATA);\n+    __ metadata2reg(md->constant_encoding(), mdp);\n+    LIRItem value(x->right(), this);\n+    value.load_item();\n+    __ profile_inline_type(new LIR_Address(mdp, flags_offset, T_INT), value.result(), ACmpData::right_inline_type_byte_constant(), new_register(T_INT), !x->left_maybe_null());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":603,"deletions":44,"binary":false,"changes":647,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  bool          _in_conditional_code;\n@@ -198,0 +199,1 @@\n+  void set_in_conditional_code(bool v);\n@@ -217,0 +219,1 @@\n+  bool in_conditional_code() { return _in_conditional_code; }\n@@ -276,0 +279,14 @@\n+  bool inline_type_field_access_prolog(AccessField* x);\n+  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = NULL, int offset = 0);\n+  void access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset);\n+  LIR_Opr get_and_load_element_address(LIRItem& array, LIRItem& index);\n+  bool needs_flattened_array_store_check(StoreIndexed* x);\n+  void check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path);\n+  bool needs_null_free_array_store_check(StoreIndexed* x);\n+  void check_null_free_array(LIRItem& array, LIRItem& value,  CodeEmitInfo* info);\n+  void substitutability_check(IfOp* x, LIRItem& left, LIRItem& right, LIRItem& t_val, LIRItem& f_val);\n+  void substitutability_check(If* x, LIRItem& left, LIRItem& right);\n+  void substitutability_check_common(Value left_val, Value right_val, LIRItem& left, LIRItem& right,\n+                                     LIR_Opr equal_result, LIR_Opr not_equal_result, LIR_Opr result, CodeEmitInfo* info);\n+  void init_temps_for_substitutability_check(LIR_Opr& tmp1, LIR_Opr& tmp2);\n+\n@@ -329,1 +346,1 @@\n-\n+  void invoke_load_one_argument(LIRItem* param, LIR_Opr loc);\n@@ -365,1 +382,1 @@\n-  void monitor_enter (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info);\n+  void monitor_enter (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info, CodeStub* throw_imse_stub);\n@@ -368,1 +385,1 @@\n-  void new_instance    (LIR_Opr  dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr  scratch1, LIR_Opr  scratch2, LIR_Opr  scratch3,  LIR_Opr scratch4, LIR_Opr  klass_reg, CodeEmitInfo* info);\n+  void new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, bool allow_inline, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info);\n@@ -484,0 +501,5 @@\n+  void profile_flags(ciMethodData* md, ciProfileData* load_store, int flag, LIR_Condition condition = lir_cond_always);\n+  void profile_null_free_array(LIRItem array, ciMethodData* md, ciArrayLoadStoreData* load_store);\n+  void profile_array_type(AccessIndexed* x, ciMethodData*& md, ciArrayLoadStoreData*& load_store);\n+  void profile_element_type(Value element, ciMethodData* md, ciArrayLoadStoreData* load_store);\n+  bool profile_inline_klass(ciMethodData* md, ciProfileData* data, Value value, int flag);\n@@ -511,0 +533,1 @@\n+    , _in_conditional_code(false)\n@@ -564,0 +587,1 @@\n+  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n@@ -567,0 +591,1 @@\n+  virtual void do_Deoptimize     (Deoptimize*      x);\n@@ -589,0 +614,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};\n+static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 0, 2,  1, 2, 1, -1};\n@@ -68,1 +68,1 @@\n-static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};\n+static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 0, 1, -1, 1, 1, -1};\n@@ -263,1 +263,1 @@\n-  if (!frame_map()->finalize_frame(max_spills())) {\n+  if (!frame_map()->finalize_frame(max_spills(), compilation()->needs_stack_repair())) {\n@@ -2950,1 +2950,1 @@\n-  return new IRScopeDebugInfo(cur_scope, cur_state->bci(), locals, expressions, monitors, caller_debug_info);\n+  return new IRScopeDebugInfo(cur_scope, cur_state->bci(), locals, expressions, monitors, caller_debug_info, cur_state->should_reexecute());\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -125,0 +127,1 @@\n+int Runtime1::_new_flat_array_slowcase_cnt = 0;\n@@ -127,0 +130,5 @@\n+int Runtime1::_load_flattened_array_slowcase_cnt = 0;\n+int Runtime1::_store_flattened_array_slowcase_cnt = 0;\n+int Runtime1::_substitutability_check_slowcase_cnt = 0;\n+int Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n+int Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n@@ -136,0 +144,1 @@\n+int Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n@@ -351,2 +360,1 @@\n-\n-JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n+static void allocate_instance(JavaThread* current, Klass* klass, TRAPS) {\n@@ -355,1 +363,1 @@\n-    _new_instance_slowcase_cnt++;\n+    Runtime1::_new_instance_slowcase_cnt++;\n@@ -369,0 +377,12 @@\n+JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n+  allocate_instance(current, klass, CHECK);\n+JRT_END\n+\n+\/\/ Same as new_instance but throws error for inline klasses\n+JRT_ENTRY(void, Runtime1::new_instance_no_inline(JavaThread* current, Klass* klass))\n+  if (klass->is_inline_klass()) {\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_InstantiationError());\n+  } else {\n+    allocate_instance(current, klass, CHECK);\n+  }\n+JRT_END\n@@ -403,1 +423,1 @@\n-  Klass* elem_klass = ObjArrayKlass::cast(array_klass)->element_klass();\n+  Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();\n@@ -414,0 +434,22 @@\n+JRT_ENTRY(void, Runtime1::new_flat_array(JavaThread* current, Klass* array_klass, jint length))\n+  NOT_PRODUCT(_new_flat_array_slowcase_cnt++;)\n+\n+  \/\/ Note: no handle for klass needed since they are not used\n+  \/\/       anymore after new_objArray() and no GC can happen before.\n+  \/\/       (This may have to change if this code changes!)\n+  assert(array_klass->is_klass(), \"not a class\");\n+  Handle holder(THREAD, array_klass->klass_holder()); \/\/ keep the klass alive\n+  Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();\n+  assert(elem_klass->is_inline_klass(), \"must be\");\n+  \/\/ Logically creates elements, ensure klass init\n+  elem_klass->initialize(CHECK);\n+  arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);\n+  current->set_vm_result(obj);\n+  \/\/ This is pretty rare but this runtime patch is stressful to deoptimization\n+  \/\/ if we deoptimize here so force a deopt to stress the path.\n+  if (DeoptimizeALot) {\n+    deopt_caller(current);\n+  }\n+JRT_END\n+\n+\n@@ -428,0 +470,81 @@\n+static void profile_flat_array(JavaThread* current) {\n+  ResourceMark rm(current);\n+  vframeStream vfst(current, true);\n+  assert(!vfst.at_end(), \"Java frame must exist\");\n+  \/\/ Check if array access profiling is enabled\n+  if (vfst.nm()->comp_level() != CompLevel_full_profile || !C1UpdateMethodData) {\n+    return;\n+  }\n+  int bci = vfst.bci();\n+  Method* method = vfst.method();\n+  MethodData* md = method->method_data();\n+  if (md != NULL) {\n+    ProfileData* data = md->bci_to_data(bci);\n+    assert(data != NULL && data->is_ArrayLoadStoreData(), \"incorrect profiling entry\");\n+    ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;\n+    load_store->set_flat_array();\n+  }\n+}\n+\n+JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index))\n+  assert(array->klass()->is_flatArray_klass(), \"should not be called\");\n+  profile_flat_array(current);\n+\n+  NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)\n+  assert(array->length() > 0 && index < array->length(), \"already checked\");\n+  flatArrayHandle vah(current, array);\n+  oop obj = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);\n+  current->set_vm_result(obj);\n+JRT_END\n+\n+\n+JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value))\n+  if (array->klass()->is_flatArray_klass()) {\n+    profile_flat_array(current);\n+  }\n+\n+  NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)\n+  if (value == NULL) {\n+    assert(array->klass()->is_flatArray_klass() || array->klass()->is_null_free_array_klass(), \"should not be called\");\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException());\n+  } else {\n+    assert(array->klass()->is_flatArray_klass(), \"should not be called\");\n+    array->value_copy_to_index(value, index);\n+  }\n+JRT_END\n+\n+\n+JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* current, oopDesc* left, oopDesc* right))\n+  NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)\n+  JavaCallArguments args;\n+  args.push_oop(Handle(THREAD, left));\n+  args.push_oop(Handle(THREAD, right));\n+  JavaValue result(T_BOOLEAN);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::ValueObjectMethods_klass(),\n+                         vmSymbols::isSubstitutable_name(),\n+                         vmSymbols::object_object_boolean_signature(),\n+                         &args, CHECK_0);\n+  return result.get_jboolean() ? 1 : 0;\n+JRT_END\n+\n+\n+extern \"C\" void ps();\n+\n+void Runtime1::buffer_inline_args_impl(JavaThread* current, Method* m, bool allocate_receiver) {\n+  JavaThread* THREAD = current;\n+  methodHandle method(current, m); \/\/ We are inside the verified_entry or verified_inline_ro_entry of this method.\n+  oop obj = SharedRuntime::allocate_inline_types_impl(current, method, allocate_receiver, CHECK);\n+  current->set_vm_result(obj);\n+}\n+\n+JRT_ENTRY(void, Runtime1::buffer_inline_args(JavaThread* current, Method* method))\n+  NOT_PRODUCT(_buffer_inline_args_slowcase_cnt++;)\n+  buffer_inline_args_impl(current, method, true);\n+JRT_END\n+\n+JRT_ENTRY(void, Runtime1::buffer_inline_args_no_receiver(JavaThread* current, Method* method))\n+  NOT_PRODUCT(_buffer_inline_args_no_receiver_slowcase_cnt++;)\n+  buffer_inline_args_impl(current, method, false);\n+JRT_END\n+\n@@ -751,0 +874,6 @@\n+JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* current))\n+  NOT_PRODUCT(_throw_illegal_monitor_state_exception_count++;)\n+  ResourceMark rm(current);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IllegalMonitorStateException());\n+JRT_END\n+\n@@ -972,0 +1101,1 @@\n+    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n@@ -1014,0 +1144,5 @@\n+      case Bytecodes::_aconst_init:\n+        { Bytecode_aconst_init baconst_init(caller_method(), caller_method->bcp_from(bci));\n+          k = caller_method->constants()->klass_at(baconst_init.index(), CHECK);\n+        }\n+        break;\n@@ -1017,0 +1152,4 @@\n+          if (k->name()->is_Q_array_signature()) {\n+            \/\/ Logically creates elements, ensure klass init\n+            k->initialize(CHECK);\n+          }\n@@ -1528,0 +1667,1 @@\n+  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %d\", _new_flat_array_slowcase_cnt);\n@@ -1530,0 +1670,6 @@\n+  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %d\", _load_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %d\", _store_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _substitutability_check_slowcase_cnt: %d\", _substitutability_check_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%d\", _buffer_inline_args_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%d\", _buffer_inline_args_no_receiver_slowcase_cnt);\n+\n@@ -1540,0 +1686,1 @@\n+  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %d:\", _throw_illegal_monitor_state_exception_count);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":151,"deletions":4,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -426,1 +426,0 @@\n-    assert(type == _method_entry_ref, \"only special type allowed for now\");\n@@ -429,1 +428,1 @@\n-    _builder->add_special_ref(type, src_obj, field_offset);\n+    _builder->add_special_ref(type, src_obj, field_offset, ref->size() * BytesPerWord);\n@@ -473,4 +472,0 @@\n-void ArchiveBuilder::add_special_ref(MetaspaceClosure::SpecialRef type, address src_obj, size_t field_offset) {\n-  _special_refs->append(SpecialRefInfo(type, src_obj, field_offset));\n-}\n-\n@@ -683,2 +678,18 @@\n-    assert(s.type() == MetaspaceClosure::_method_entry_ref, \"only special type allowed for now\");\n-    assert(*src_p == *dst_p, \"must be a copy\");\n+\n+    MetaspaceClosure::assert_valid(s.type());\n+    switch (s.type()) {\n+    case MetaspaceClosure::_method_entry_ref:\n+      assert(*src_p == *dst_p, \"must be a copy\");\n+      break;\n+    case MetaspaceClosure::_internal_pointer_ref:\n+      {\n+        \/\/ *src_p points to a location inside src_obj. Let's make *dst_p point to\n+        \/\/ the same location inside dst_obj.\n+        size_t off = pointer_delta(*((address*)src_p), src_obj, sizeof(u1));\n+        assert(off < s.src_obj_size_in_bytes(), \"must point to internal address\");\n+        *((address*)dst_p) = dst_obj + off;\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+    DEBUG_ONLY(size_t _src_obj_size_in_bytes;)\n@@ -134,2 +135,4 @@\n-    SpecialRefInfo(MetaspaceClosure::SpecialRef type, address src_obj, size_t field_offset)\n-      : _type(type), _src_obj(src_obj), _field_offset(field_offset) {}\n+    SpecialRefInfo(MetaspaceClosure::SpecialRef type, address src_obj, size_t field_offset, size_t src_obj_size_in_bytes)\n+      : _type(type), _src_obj(src_obj), _field_offset(field_offset) {\n+      DEBUG_ONLY(_src_obj_size_in_bytes = src_obj_size_in_bytes);\n+    }\n@@ -140,0 +143,2 @@\n+\n+    DEBUG_ONLY(size_t src_obj_size_in_bytes() const { return _src_obj_size_in_bytes; })\n@@ -364,1 +369,3 @@\n-  void add_special_ref(MetaspaceClosure::SpecialRef type, address src_obj, size_t field_offset);\n+  void add_special_ref(MetaspaceClosure::SpecialRef type, address src_obj, size_t field_offset, size_t src_obj_size_in_bytes) {\n+    _special_refs->append(SpecialRefInfo(type, src_obj, field_offset, src_obj_size_in_bytes));\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -476,1 +476,5 @@\n-  if (k->local_interfaces()->length() != _interfaces->length()) {\n+  const int actual_num_interfaces = k->local_interfaces()->length();\n+  const int specified_num_interfaces = _interfaces->length(); \/\/ specified in classlist\n+  int expected_num_interfaces = actual_num_interfaces;\n+\n+  if (specified_num_interfaces != expected_num_interfaces) {\n@@ -480,1 +484,1 @@\n-          _interfaces->length(), k->local_interfaces()->length());\n+          specified_num_interfaces, expected_num_interfaces);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,0 +143,65 @@\n+inline void CDSMustMatchFlags::do_print(outputStream* st, bool v) {\n+  st->print(\"%s\", v ? \"true\" : \"false\");\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, intx v) {\n+  st->print(INTX_FORMAT, v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, uintx v) {\n+  st->print(UINTX_FORMAT, v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, double v) {\n+  st->print(\"%f\", v);\n+}\n+\n+void CDSMustMatchFlags::init() {\n+  Arguments::assert_is_dumping_archive();\n+  _max_name_width = 0;\n+\n+#define INIT_CDS_MUST_MATCH_FLAG(n) \\\n+  _v_##n = n; \\\n+  _max_name_width = MAX2(_max_name_width,strlen(#n));\n+  CDS_MUST_MATCH_FLAGS_DO(INIT_CDS_MUST_MATCH_FLAG);\n+#undef INIT_CDS_MUST_MATCH_FLAG\n+}\n+\n+bool CDSMustMatchFlags::runtime_check() const {\n+#define CHECK_CDS_MUST_MATCH_FLAG(n) \\\n+  if (_v_##n != n) { \\\n+    ResourceMark rm; \\\n+    stringStream ss; \\\n+    ss.print(\"VM option %s is different between dumptime (\", #n);  \\\n+    do_print(&ss, _v_ ## n); \\\n+    ss.print(\") and runtime (\"); \\\n+    do_print(&ss, n); \\\n+    ss.print(\")\"); \\\n+    FileMapInfo::fail_continue(\"%s\", ss.as_string()); \\\n+    return false; \\\n+  }\n+  CDS_MUST_MATCH_FLAGS_DO(CHECK_CDS_MUST_MATCH_FLAG);\n+#undef CHECK_CDS_MUST_MATCH_FLAG\n+\n+  return true;\n+}\n+\n+void CDSMustMatchFlags::print_info() const {\n+  LogTarget(Info, cds) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Recorded VM flags during dumptime:\");\n+    print(&ls);\n+  }\n+}\n+\n+void CDSMustMatchFlags::print(outputStream* st) const {\n+#define PRINT_CDS_MUST_MATCH_FLAG(n) \\\n+  st->print(\"- %-s \", #n);                   \\\n+  st->sp(int(_max_name_width - strlen(#n))); \\\n+  do_print(st, _v_##n);                      \\\n+  st->cr();\n+  CDS_MUST_MATCH_FLAGS_DO(PRINT_CDS_MUST_MATCH_FLAG);\n+#undef PRINT_CDS_MUST_MATCH_FLAG\n+}\n+\n@@ -309,0 +374,1 @@\n+  _must_match.init();\n@@ -371,0 +437,1 @@\n+  _must_match.print(st);\n@@ -1473,0 +1540,4 @@\n+  if (!header()->check_must_match_flags()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -184,0 +185,28 @@\n+#define CDS_MUST_MATCH_FLAGS_DO(f) \\\n+  f(EnableValhalla) \\\n+  f(FlatArrayElementMaxOops) \\\n+  f(FlatArrayElementMaxSize) \\\n+  f(InlineFieldMaxFlatSize) \\\n+  f(InlineTypePassFieldsAsArgs) \\\n+  f(InlineTypeReturnedAsFields)\n+\n+class CDSMustMatchFlags {\n+private:\n+  size_t _max_name_width;\n+#define DECLARE_CDS_MUST_MATCH_FLAG(n) \\\n+  decltype(n) _v_##n;\n+  CDS_MUST_MATCH_FLAGS_DO(DECLARE_CDS_MUST_MATCH_FLAG);\n+#undef DECLARE_CDS_MUST_MATCH_FLAG\n+\n+  inline static void do_print(outputStream* st, bool v);\n+  inline static void do_print(outputStream* st, intx v);\n+  inline static void do_print(outputStream* st, uintx v);\n+  inline static void do_print(outputStream* st, double v);\n+  void print_info() const;\n+\n+public:\n+  void init();\n+  bool runtime_check() const;\n+  void print(outputStream* st) const;\n+};\n+\n@@ -239,0 +268,1 @@\n+  CDSMustMatchFlags _must_match;        \/\/ These flags must be the same between dumptime and runtime\n@@ -325,0 +355,4 @@\n+  bool check_must_match_flags() const {\n+    return _must_match.runtime_check();\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -311,3 +311,4 @@\n-    int hash_original = obj->identity_hash();\n-    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original));\n-    assert(archived_oop->mark().is_unlocked(), \"sanity\");\n+    if (!(EnableValhalla && obj->mark().is_inline_type())) {\n+      int hash_original = obj->identity_hash();\n+      archived_oop->set_mark(archived_oop->klass()->prototype_header().copy_set_hash(hash_original));\n+      assert(archived_oop->mark().is_unlocked(), \"sanity\");\n@@ -315,2 +316,3 @@\n-    DEBUG_ONLY(int hash_archived = archived_oop->identity_hash());\n-    assert(hash_original == hash_archived, \"Different hash codes: original %x, archived %x\", hash_original, hash_archived);\n+      DEBUG_ONLY(int hash_archived = archived_oop->identity_hash());\n+      assert(hash_original == hash_archived, \"Different hash codes: original %x, archived %x\", hash_original, hash_archived);\n+    }\n@@ -576,1 +578,1 @@\n-    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::set_mark(mem, k->prototype_header());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -538,1 +539,3 @@\n-      (sym->char_at(1) == JVM_SIGNATURE_ARRAY || sym->char_at(1) == JVM_SIGNATURE_CLASS)) {\n+      (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||\n+       sym->char_at(1) == JVM_SIGNATURE_CLASS ||\n+       sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT )) {\n@@ -551,1 +554,2 @@\n-      return ciObjArrayKlass::make_impl(elem_klass);\n+      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+      return ciArrayKlass::make(elem_klass, null_free_array);\n@@ -577,0 +581,15 @@\n+  int i = 0;\n+  while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {\n+    i++;\n+  }\n+  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+    \/\/ An unloaded array class of inline types is an ObjArrayKlass, an\n+    \/\/ unloaded inline type class is an InstanceKlass. For consistency,\n+    \/\/ make the signature of the unloaded array of inline type use L\n+    \/\/ rather than Q.\n+    char* new_name = name_buffer(sym->utf8_length()+1);\n+    strncpy(new_name, (char*)sym->base(), sym->utf8_length());\n+    new_name[i] = JVM_SIGNATURE_CLASS;\n+    new_name[sym->utf8_length()] = '\\0';\n+    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));\n+  }\n@@ -663,0 +682,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::is_inline_klass\n+\/\/\n+\/\/ Check if the klass is an inline klass.\n+bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n+  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)\n+}\n+\n@@ -759,1 +786,5 @@\n-    return ciConstant(T_OBJECT, mirror);\n+    if (klass->is_loaded() && tag.is_Qdescriptor_klass()) {\n+      return ciConstant(T_OBJECT, klass->as_inline_klass()->val_mirror());\n+    } else {\n+      return ciConstant(T_OBJECT, mirror);\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -138,0 +138,2 @@\n+  bool       has_Q_signature(const constantPoolHandle& cpool,\n+                             int klass_index);\n@@ -205,0 +207,4 @@\n+  ciFlatArrayKlass* get_flat_array_klass(Klass* o) {\n+    if (o == NULL) return NULL;\n+    return get_metadata(o)->as_flat_array_klass();\n+  }\n@@ -500,0 +506,4 @@\n+  ciWrapper* make_null_free_wrapper(ciType* type) {\n+    return _factory->make_null_free_wrapper(type);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+  _original_holder(NULL), _is_flattened(false), _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n@@ -108,0 +108,3 @@\n+  \/\/ this is needed if the field class is not yet loaded.\n+  _is_null_free = _signature->is_Q_signature();\n+\n@@ -219,0 +222,25 @@\n+\/\/ Special copy constructor used to flatten inline type fields by\n+\/\/ copying the fields of the inline type to a new holder klass.\n+ciField::ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) {\n+  assert(field->holder()->is_inlinetype(), \"should only be used for inline type field flattening\");\n+  \/\/ Set the is_final flag\n+  jint final = is_final ? JVM_ACC_FINAL : ~JVM_ACC_FINAL;\n+  AccessFlags flags(field->flags().as_int() & final);\n+  _flags = ciFlags(flags);\n+  _holder = holder;\n+  _offset = offset;\n+  \/\/ Copy remaining fields\n+  _name = field->_name;\n+  _signature = field->_signature;\n+  _type = field->_type;\n+  \/\/ Trust final flattened fields\n+  _is_constant = is_final;\n+  _known_to_link_with_put = field->_known_to_link_with_put;\n+  _known_to_link_with_get = field->_known_to_link_with_get;\n+  _constant_value = field->_constant_value;\n+  assert(!field->is_flattened(), \"field must not be flattened\");\n+  _is_flattened = false;\n+  _is_null_free = field->_is_null_free;\n+  _original_holder = (field->_original_holder != NULL) ? field->_original_holder : field->_holder;\n+}\n+\n@@ -236,0 +264,3 @@\n+  \/\/ Trust final fields in inline type buffers\n+  if (holder->is_inlinetype())\n+    return true;\n@@ -263,0 +294,3 @@\n+  _is_flattened = fd->is_inlined();\n+  _is_null_free = fd->signature()->is_Q_signature();\n+  _original_holder = NULL;\n@@ -346,1 +380,3 @@\n-  ciKlass* type = CURRENT_ENV->get_klass_by_name_impl(_holder, constantPoolHandle(), _signature, false);\n+  \/\/ Use original holder for fields that came in through flattening\n+  ciKlass* accessing_klass = (_original_holder != NULL) ? _original_holder : _holder;\n+  ciKlass* type = CURRENT_ENV->get_klass_by_name_impl(accessing_klass, constantPoolHandle(), _signature, false);\n@@ -375,2 +411,2 @@\n-         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield,\n-         \"unexpected bytecode\");\n+         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield  ||\n+         bc == Bytecodes::_withfield, \"unexpected bytecode\");\n@@ -459,0 +495,2 @@\n+  tty->print(\" is_flattened=%s\", bool_to_str(_is_flattened));\n+  tty->print(\" is_null_free=%s\", bool_to_str(_is_null_free));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  ciInstanceKlass* _original_holder; \/\/ For flattened fields\n@@ -52,0 +53,2 @@\n+  bool             _is_flattened;\n+  bool             _is_null_free;\n@@ -61,0 +64,1 @@\n+  ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final);\n@@ -105,1 +109,1 @@\n-  BasicType layout_type() { return type2field[(_type == NULL) ? T_OBJECT : _type->basic_type()]; }\n+  BasicType layout_type() { return type2field[type()->basic_type()]; }\n@@ -177,0 +181,3 @@\n+  bool is_flattened            () const { return _is_flattened; }\n+  bool is_null_free            () const { return _is_null_free; }\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  bool is_super                () const { return (_flags & JVM_ACC_SUPER                     ) != 0; }\n@@ -62,0 +61,1 @@\n+  bool has_vararg              () const { return (_flags & JVM_ACC_VARARGS                   ) != 0; }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-void ciReturnTypeEntry::translate_type_data_from(const ReturnTypeEntry* ret) {\n+void ciSingleTypeEntry::translate_type_data_from(const SingleTypeEntry* ret) {\n@@ -308,1 +308,1 @@\n-    set_type(ReturnTypeEntry::with_status((Klass*)NULL, k));\n+    set_type(SingleTypeEntry::with_status((Klass*)NULL, k));\n@@ -359,0 +359,4 @@\n+  case DataLayout::array_load_store_data_tag:\n+    return new ciArrayLoadStoreData(data_layout);\n+  case DataLayout::acmp_data_tag:\n+    return new ciACmpData(data_layout);\n@@ -754,0 +758,13 @@\n+      } else if (pdata->is_ArrayLoadStoreData()) {\n+        ciArrayLoadStoreData* array_load_store_data = (ciArrayLoadStoreData*)pdata;\n+        dump_replay_data_type_helper(out, round, count, array_load_store_data, ciArrayLoadStoreData::array_offset(),\n+                                     array_load_store_data->array()->valid_type());\n+        dump_replay_data_type_helper(out, round, count, array_load_store_data, ciArrayLoadStoreData::element_offset(),\n+                                     array_load_store_data->element()->valid_type());\n+      } else if (pdata->is_ACmpData()) {\n+        ciACmpData* acmp_data = (ciACmpData*)pdata;\n+        dump_replay_data_type_helper(out, round, count, acmp_data, ciACmpData::left_offset(),\n+                                     acmp_data->left()->valid_type());\n+        dump_replay_data_type_helper(out, round, count, acmp_data, ciACmpData::right_offset(),\n+                                     acmp_data->right()->valid_type());\n+\n@@ -836,1 +853,1 @@\n-void ciReturnTypeEntry::print_data_on(outputStream* st) const {\n+void ciSingleTypeEntry::print_data_on(outputStream* st) const {\n@@ -909,0 +926,21 @@\n+\n+void ciArrayLoadStoreData::print_data_on(outputStream* st, const char* extra) const {\n+  print_shared(st, \"ciArrayLoadStoreData\", extra);\n+  tab(st, true);\n+  st->print(\"array\");\n+  array()->print_data_on(st);\n+  tab(st, true);\n+  st->print(\"element\");\n+  element()->print_data_on(st);\n+}\n+\n+void ciACmpData::print_data_on(outputStream* st, const char* extra) const {\n+  BranchData::print_data_on(st, extra);\n+  st->cr();\n+  tab(st, true);\n+  st->print(\"left\");\n+  left()->print_data_on(st);\n+  tab(st, true);\n+  st->print(\"right\");\n+  right()->print_data_on(st);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-class ciReturnTypeEntry : public ReturnTypeEntry, ciTypeEntries {\n+class ciSingleTypeEntry : public SingleTypeEntry, ciTypeEntries {\n@@ -129,1 +129,1 @@\n-  void translate_type_data_from(const ReturnTypeEntry* ret);\n+  void translate_type_data_from(const SingleTypeEntry* ret);\n@@ -149,1 +149,1 @@\n-  ciReturnTypeEntry* ret() const { return (ciReturnTypeEntry*)CallTypeData::ret(); }\n+  ciSingleTypeEntry* ret() const { return (ciSingleTypeEntry*)CallTypeData::ret(); }\n@@ -261,1 +261,1 @@\n-  ciReturnTypeEntry* ret() const { return (ciReturnTypeEntry*)VirtualCallTypeData::ret(); }\n+  ciSingleTypeEntry* ret() const { return (ciSingleTypeEntry*)VirtualCallTypeData::ret(); }\n@@ -365,0 +365,34 @@\n+class ciArrayLoadStoreData : public ArrayLoadStoreData {\n+public:\n+  ciArrayLoadStoreData(DataLayout* layout) : ArrayLoadStoreData(layout) {}\n+\n+  ciSingleTypeEntry* array() const { return (ciSingleTypeEntry*)ArrayLoadStoreData::array(); }\n+  ciSingleTypeEntry* element() const { return (ciSingleTypeEntry*)ArrayLoadStoreData::element(); }\n+\n+  virtual void translate_from(const ProfileData* data) {\n+    array()->translate_type_data_from(data->as_ArrayLoadStoreData()->array());\n+    element()->translate_type_data_from(data->as_ArrayLoadStoreData()->element());\n+  }\n+\n+#ifndef PRODUCT\n+  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+#endif\n+};\n+\n+class ciACmpData : public ACmpData {\n+public:\n+  ciACmpData(DataLayout* layout) : ACmpData(layout) {}\n+\n+  ciSingleTypeEntry* left() const { return (ciSingleTypeEntry*)ACmpData::left(); }\n+  ciSingleTypeEntry* right() const { return (ciSingleTypeEntry*)ACmpData::right(); }\n+\n+  virtual void translate_from(const ProfileData* data) {\n+    left()->translate_type_data_from(data->as_ACmpData()->left());\n+    right()->translate_type_data_from(data->as_ACmpData()->right());\n+  }\n+\n+#ifndef PRODUCT\n+  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+  ciWrapper* make_null_free_wrapper(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -973,0 +974,1 @@\n+\n@@ -1019,27 +1021,79 @@\n-  \/\/ staticfield <klass> <name> <signature> <value>\n-  \/\/\n-  \/\/ Initialize a class and fill in the value for a static field.\n-  \/\/ This is useful when the compile was dependent on the value of\n-  \/\/ static fields but it's impossible to properly rerun the static\n-  \/\/ initializer.\n-  void process_staticfield(TRAPS) {\n-    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n-\n-    if (k == NULL || ReplaySuppressInitializers == 0 ||\n-        (ReplaySuppressInitializers == 2 && k->class_loader() == NULL)) {\n-      skip_remaining();\n-      return;\n-    }\n-\n-    assert(k->is_initialized(), \"must be\");\n-\n-    const char* field_name = parse_escaped_string();\n-    const char* field_signature = parse_string();\n-    fieldDescriptor fd;\n-    Symbol* name = SymbolTable::new_symbol(field_name);\n-    Symbol* sig = SymbolTable::new_symbol(field_signature);\n-    if (!k->find_local_field(name, sig, &fd) ||\n-        !fd.is_static() ||\n-        fd.has_initial_value()) {\n-      report_error(field_name);\n-      return;\n+  class InlineTypeFieldInitializer : public FieldClosure {\n+    oop _vt;\n+    CompileReplay* _replay;\n+  public:\n+    InlineTypeFieldInitializer(oop vt, CompileReplay* replay)\n+  : _vt(vt), _replay(replay) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      BasicType bt = fd->field_type();\n+      const char* string_value = bt != T_PRIMITIVE_OBJECT ? _replay->parse_escaped_string() : NULL;\n+      switch (bt) {\n+      case T_BYTE: {\n+        int value = atoi(string_value);\n+        _vt->byte_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_BOOLEAN: {\n+        int value = atoi(string_value);\n+        _vt->bool_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_SHORT: {\n+        int value = atoi(string_value);\n+        _vt->short_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_CHAR: {\n+        int value = atoi(string_value);\n+        _vt->char_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_INT: {\n+        int value = atoi(string_value);\n+        _vt->int_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_LONG: {\n+        jlong value;\n+        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+          break;\n+        }\n+        _vt->long_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_FLOAT: {\n+        float value = atof(string_value);\n+        _vt->float_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        double value = atof(string_value);\n+        _vt->double_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_ARRAY:\n+      case T_OBJECT: {\n+        JavaThread* THREAD = JavaThread::current();\n+        bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n+        assert(res, \"should succeed for arrays & objects\");\n+        break;\n+      }\n+      case T_PRIMITIVE_OBJECT: {\n+        InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+        if (fd->is_inlined()) {\n+          int field_offset = fd->offset() - vk->first_field_offset();\n+          oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+          InlineTypeFieldInitializer init_fields(obj, _replay);\n+          vk->do_nonstatic_fields(&init_fields);\n+        } else {\n+          oop value = vk->allocate_instance(JavaThread::current());\n+          _vt->obj_field_put(fd->offset(), value);\n+        }\n+        break;\n+      }\n+      default: {\n+        fatal(\"Unhandled type: %s\", type2name(bt));\n+      }\n+      }\n@@ -1047,0 +1101,1 @@\n+  };\n@@ -1048,1 +1103,1 @@\n-    oop java_mirror = k->java_mirror();\n+  bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {\n@@ -1055,4 +1110,2 @@\n-        ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);\n-        if (kelem == NULL) {\n-          return;\n-        }\n+        Klass* k = resolve_klass(field_signature, CHECK_(true));\n+        ArrayKlass* kelem = (ArrayKlass *)k;\n@@ -1068,1 +1121,1 @@\n-        value = kelem->multi_allocate(rank, dims, CHECK);\n+        value = kelem->multi_allocate(rank, dims, CHECK_(true));\n@@ -1071,1 +1124,1 @@\n-          value = oopFactory::new_byteArray(length, CHECK);\n+          value = oopFactory::new_byteArray(length, CHECK_(true));\n@@ -1073,1 +1126,1 @@\n-          value = oopFactory::new_boolArray(length, CHECK);\n+          value = oopFactory::new_boolArray(length, CHECK_(true));\n@@ -1075,1 +1128,1 @@\n-          value = oopFactory::new_charArray(length, CHECK);\n+          value = oopFactory::new_charArray(length, CHECK_(true));\n@@ -1077,1 +1130,1 @@\n-          value = oopFactory::new_shortArray(length, CHECK);\n+          value = oopFactory::new_shortArray(length, CHECK_(true));\n@@ -1079,1 +1132,1 @@\n-          value = oopFactory::new_floatArray(length, CHECK);\n+          value = oopFactory::new_floatArray(length, CHECK_(true));\n@@ -1081,1 +1134,1 @@\n-          value = oopFactory::new_doubleArray(length, CHECK);\n+          value = oopFactory::new_doubleArray(length, CHECK_(true));\n@@ -1083,1 +1136,1 @@\n-          value = oopFactory::new_intArray(length, CHECK);\n+          value = oopFactory::new_intArray(length, CHECK_(true));\n@@ -1085,1 +1138,1 @@\n-          value = oopFactory::new_longArray(length, CHECK);\n+          value = oopFactory::new_longArray(length, CHECK_(true));\n@@ -1088,2 +1141,6 @@\n-          Klass* kelem = resolve_klass(field_signature + 1, CHECK);\n-          value = oopFactory::new_objArray(kelem, length, CHECK);\n+          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n+          value = oopFactory::new_objArray(kelem, length, CHECK_(true));\n+        } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&\n+                   field_signature[1] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n+          value = oopFactory::new_valueArray(kelem, length, CHECK_(true));\n@@ -1094,0 +1151,87 @@\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value());\n+      return true;\n+    } else if (field_signature[0] == 'L') {\n+      const char* instance = parse_escaped_string();\n+      Klass* k = resolve_klass(instance, CHECK_(true));\n+      oop value = InstanceKlass::cast(k)->allocate_instance(CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Initialize a class and fill in the value for a static field.\n+  \/\/ This is useful when the compile was dependent on the value of\n+  \/\/ static fields but it's impossible to properly rerun the static\n+  \/\/ initializer.\n+  void process_staticfield(TRAPS) {\n+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n+\n+    if (k == NULL || ReplaySuppressInitializers == 0 ||\n+        (ReplaySuppressInitializers == 2 && k->class_loader() == NULL)) {\n+        skip_remaining();\n+      return;\n+    }\n+\n+    assert(k->is_initialized(), \"must be\");\n+\n+    const char* field_name = parse_escaped_string();\n+    const char* field_signature = parse_string();\n+    fieldDescriptor fd;\n+    Symbol* name = SymbolTable::new_symbol(field_name);\n+    Symbol* sig = SymbolTable::new_symbol(field_signature);\n+    if (!k->find_local_field(name, sig, &fd) ||\n+        !fd.is_static() ||\n+        fd.has_initial_value()) {\n+      report_error(field_name);\n+      return;\n+    }\n+\n+    oop java_mirror = k->java_mirror();\n+    if (strcmp(field_signature, \"I\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->int_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"B\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->byte_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"C\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->char_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"S\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->short_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"Z\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->bool_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"J\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      jlong value;\n+      if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+        fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+        return;\n+      }\n+      java_mirror->long_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"F\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      float value = atof(string_value);\n+      java_mirror->float_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"D\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      double value = atof(string_value);\n+      java_mirror->double_field_put(fd.offset(), value);\n+    } else if (field_signature[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+      Klass* kelem = resolve_klass(field_signature, CHECK);\n+      InlineKlass* vk = InlineKlass::cast(kelem);\n+      oop value = vk->allocate_instance(CHECK);\n+      InlineTypeFieldInitializer init_fields(value, this);\n+      vk->do_nonstatic_fields(&init_fields);\n@@ -1096,37 +1240,2 @@\n-      const char* string_value = parse_escaped_string();\n-      if (strcmp(field_signature, \"I\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->int_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"B\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->byte_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"C\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->char_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"S\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->short_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Z\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->bool_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"J\") == 0) {\n-        jlong value;\n-        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n-          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n-          return;\n-        }\n-        java_mirror->long_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"F\") == 0) {\n-        float value = atof(string_value);\n-        java_mirror->float_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"D\") == 0) {\n-        double value = atof(string_value);\n-        java_mirror->double_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n-        Handle value = java_lang_String::create_from_str(string_value, CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value());\n-      } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n-        Klass* k = resolve_klass(string_value, CHECK);\n-        oop value = InstanceKlass::cast(k)->allocate_instance(CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value);\n-      } else {\n+      bool res = process_staticfield_reference(field_signature, java_mirror, &fd, CHECK);\n+      if (!res)  {\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":189,"deletions":80,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciType.hpp\"\n@@ -59,1 +60,3 @@\n-  ciType*   type_at(int index) const             { return _types.at(index); }\n+  ciType*   type_at(int index) const             { return _types.at(index)->unwrap(); }\n+  bool      returns_null_free_inline_type() const;\n+  bool      is_null_free_at(int index) const;\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -277,1 +278,11 @@\n-  } else if (t1->is_primitive_type() || t2->is_primitive_type()) {\n+  }\n+  \/\/ Unwrap after saving nullness information and handling top meets\n+  bool null_free1 = t1->is_null_free();\n+  bool null_free2 = t2->is_null_free();\n+  if (t1->unwrap() == t2->unwrap() && null_free1 == null_free2) {\n+    return t1;\n+  }\n+  t1 = t1->unwrap();\n+  t2 = t2->unwrap();\n+\n+  if (t1->is_primitive_type() || t2->is_primitive_type()) {\n@@ -279,1 +290,1 @@\n-    \/\/ is T.  null_type meet null_type is null_type.\n+    \/\/ is T. null_type meet null_type is null_type.\n@@ -293,35 +304,38 @@\n-  } else {\n-    \/\/ Both types are non-top non-primitive types.  That is,\n-    \/\/ both types are either instanceKlasses or arrayKlasses.\n-    ciKlass* object_klass = analyzer->env()->Object_klass();\n-    ciKlass* k1 = t1->as_klass();\n-    ciKlass* k2 = t2->as_klass();\n-    if (k1->equals(object_klass) || k2->equals(object_klass)) {\n-      return object_klass;\n-    } else if (!k1->is_loaded() || !k2->is_loaded()) {\n-      \/\/ Unloaded classes fall to java.lang.Object at a merge.\n-      return object_klass;\n-    } else if (k1->is_interface() != k2->is_interface()) {\n-      \/\/ When an interface meets a non-interface, we get Object;\n-      \/\/ This is what the verifier does.\n-      return object_klass;\n-    } else if (k1->is_array_klass() || k2->is_array_klass()) {\n-      \/\/ When an array meets a non-array, we get Object.\n-      \/\/ When objArray meets typeArray, we also get Object.\n-      \/\/ And when typeArray meets different typeArray, we again get Object.\n-      \/\/ But when objArray meets objArray, we look carefully at element types.\n-      if (k1->is_obj_array_klass() && k2->is_obj_array_klass()) {\n-        \/\/ Meet the element types, then construct the corresponding array type.\n-        ciKlass* elem1 = k1->as_obj_array_klass()->element_klass();\n-        ciKlass* elem2 = k2->as_obj_array_klass()->element_klass();\n-        ciKlass* elem  = type_meet_internal(elem1, elem2, analyzer)->as_klass();\n-        \/\/ Do an easy shortcut if one type is a super of the other.\n-        if (elem == elem1) {\n-          assert(k1 == ciObjArrayKlass::make(elem), \"shortcut is OK\");\n-          return k1;\n-        } else if (elem == elem2) {\n-          assert(k2 == ciObjArrayKlass::make(elem), \"shortcut is OK\");\n-          return k2;\n-        } else {\n-          return ciObjArrayKlass::make(elem);\n-        }\n+  }\n+\n+  \/\/ Both types are non-top non-primitive types.  That is,\n+  \/\/ both types are either instanceKlasses or arrayKlasses.\n+  ciKlass* object_klass = analyzer->env()->Object_klass();\n+  ciKlass* k1 = t1->as_klass();\n+  ciKlass* k2 = t2->as_klass();\n+  if (k1->equals(object_klass) || k2->equals(object_klass)) {\n+    return object_klass;\n+  } else if (!k1->is_loaded() || !k2->is_loaded()) {\n+    \/\/ Unloaded classes fall to java.lang.Object at a merge.\n+    return object_klass;\n+  } else if (k1->is_interface() != k2->is_interface()) {\n+    \/\/ When an interface meets a non-interface, we get Object;\n+    \/\/ This is what the verifier does.\n+    return object_klass;\n+  } else if (k1->is_array_klass() || k2->is_array_klass()) {\n+    \/\/ When an array meets a non-array, we get Object.\n+    \/\/ When (obj\/flat)Array meets typeArray, we also get Object.\n+    \/\/ And when typeArray meets different typeArray, we again get Object.\n+    \/\/ But when (obj\/flat)Array meets (obj\/flat)Array, we look carefully at element types.\n+    if ((k1->is_obj_array_klass() || k1->is_flat_array_klass()) &&\n+        (k2->is_obj_array_klass() || k2->is_flat_array_klass())) {\n+      bool null_free = k1->as_array_klass()->is_elem_null_free() &&\n+                       k2->as_array_klass()->is_elem_null_free();\n+      ciType* elem1 = k1->as_array_klass()->element_klass();\n+      ciType* elem2 = k2->as_array_klass()->element_klass();\n+      ciType* elem = elem1;\n+      if (elem1 != elem2) {\n+        elem = type_meet_internal(elem1, elem2, analyzer)->as_klass();\n+      }\n+      \/\/ Do an easy shortcut if one type is a super of the other.\n+      if (elem == elem1 && !elem->is_inlinetype()) {\n+        assert(k1 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n+        return k1;\n+      } else if (elem == elem2 && !elem->is_inlinetype()) {\n+        assert(k2 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n+        return k2;\n@@ -329,1 +343,1 @@\n-        return object_klass;\n+        return ciArrayKlass::make(elem, null_free);\n@@ -332,4 +346,9 @@\n-      \/\/ Must be two plain old instance klasses.\n-      assert(k1->is_instance_klass(), \"previous cases handle non-instances\");\n-      assert(k2->is_instance_klass(), \"previous cases handle non-instances\");\n-      return k1->least_common_ancestor(k2);\n+      return object_klass;\n+    }\n+  } else {\n+    \/\/ Must be two plain old instance klasses.\n+    assert(k1->is_instance_klass(), \"previous cases handle non-instances\");\n+    assert(k2->is_instance_klass(), \"previous cases handle non-instances\");\n+    ciType* result = k1->least_common_ancestor(k2);\n+    if (null_free1 && null_free2 && result->is_inlinetype()) {\n+      result = analyzer->mark_as_null_free(result);\n@@ -337,0 +356,1 @@\n+    return result;\n@@ -398,1 +418,6 @@\n-    state->push(method()->holder());\n+    ciType* holder = method()->holder();\n+    if (holder->is_inlinetype()) {\n+      \/\/ The receiver is null-free\n+      holder = mark_as_null_free(holder);\n+    }\n+    state->push(holder);\n@@ -404,1 +429,5 @@\n-    state->push_translate(str.type());\n+    ciType* arg = str.type();\n+    if (str.is_null_free()) {\n+      arg = mark_as_null_free(arg);\n+    }\n+    state->push_translate(arg);\n@@ -550,2 +579,2 @@\n-\/\/ ciTypeFlow::StateVector::do_aaload\n-void ciTypeFlow::StateVector::do_aaload(ciBytecodeStream* str) {\n+\/\/ ciTypeFlow::StateVector::do_aload\n+void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {\n@@ -553,1 +582,1 @@\n-  ciObjArrayKlass* array_klass = pop_objArray();\n+  ciArrayKlass* array_klass = pop_objOrFlatArray();\n@@ -555,1 +584,1 @@\n-    \/\/ Did aaload on a null reference; push a null and ignore the exception.\n+    \/\/ Did aload on a null reference; push a null and ignore the exception.\n@@ -580,1 +609,5 @@\n-    push_object(element_klass);\n+    if (array_klass->is_elem_null_free()) {\n+      push(outer()->mark_as_null_free(element_klass));\n+    } else {\n+      push_object(element_klass);\n+    }\n@@ -590,0 +623,1 @@\n+  bool null_free = str->has_Q_signature();\n@@ -591,6 +625,13 @@\n-    \/\/ VM's interpreter will not load 'klass' if object is NULL.\n-    \/\/ Type flow after this block may still be needed in two situations:\n-    \/\/ 1) C2 uses do_null_assert() and continues compilation for later blocks\n-    \/\/ 2) C2 does an OSR compile in a later block (see bug 4778368).\n-    pop_object();\n-    do_null_assert(klass);\n+    if (null_free) {\n+      trap(str, klass,\n+           Deoptimization::make_trap_request\n+           (Deoptimization::Reason_unloaded,\n+            Deoptimization::Action_reinterpret));\n+    } else {\n+      \/\/ VM's interpreter will not load 'klass' if object is NULL.\n+      \/\/ Type flow after this block may still be needed in two situations:\n+      \/\/ 1) C2 uses do_null_assert() and continues compilation for later blocks\n+      \/\/ 2) C2 does an OSR compile in a later block (see bug 4778368).\n+      pop_object();\n+      do_null_assert(klass);\n+    }\n@@ -598,2 +639,13 @@\n-    pop_object();\n-    push_object(klass);\n+    ciType* type = pop_value();\n+    null_free |= type->is_null_free();\n+    type = type->unwrap();\n+    if (type->is_loaded() && klass->is_loaded() &&\n+        type != klass && type->is_subtype_of(klass)) {\n+      \/\/ Useless cast, propagate more precise type of object\n+      klass = type->as_klass();\n+    }\n+    if (klass->is_inlinetype() && null_free) {\n+      push(outer()->mark_as_null_free(klass));\n+    } else {\n+      push_object(klass);\n+    }\n@@ -620,1 +672,10 @@\n-    if (!field_type->is_loaded()) {\n+    if (field->is_static() && field->is_null_free() &&\n+        !field_type->as_instance_klass()->is_initialized()) {\n+      \/\/ Deoptimize if we load from a static field with an uninitialized inline type\n+      \/\/ because we need to throw an exception if initialization of the type failed.\n+      trap(str, field_type->as_klass(),\n+           Deoptimization::make_trap_request\n+           (Deoptimization::Reason_unloaded,\n+            Deoptimization::Action_reinterpret));\n+      return;\n+    } else if (!field_type->is_loaded()) {\n@@ -641,0 +702,3 @@\n+      if (field->is_null_free()) {\n+        field_type = outer()->mark_as_null_free(field_type);\n+      }\n@@ -708,0 +772,3 @@\n+        if (sigstr.is_null_free()) {\n+          return_type = outer()->mark_as_null_free(return_type);\n+        }\n@@ -738,1 +805,5 @@\n-        push_object(obj->klass());\n+        ciType* type = obj->klass();\n+        if (type->is_inlinetype()) {\n+          type = outer()->mark_as_null_free(type);\n+        }\n+        push(type);\n@@ -773,1 +844,1 @@\n-  if (!will_link || str->is_unresolved_klass()) {\n+  if (!will_link || str->is_unresolved_klass() || klass->is_inlinetype()) {\n@@ -780,0 +851,33 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciTypeFlow::StateVector::do_aconst_init\n+void ciTypeFlow::StateVector::do_aconst_init(ciBytecodeStream* str) {\n+  bool will_link;\n+  ciKlass* klass = str->get_klass(will_link);\n+  if (!will_link || str->is_unresolved_klass() || !klass->is_inlinetype()) {\n+    trap(str, klass, str->get_klass_index());\n+  } else {\n+    push(outer()->mark_as_null_free(klass));\n+  }\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciTypeFlow::StateVector::do_withfield\n+void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {\n+  bool will_link;\n+  ciField* field = str->get_field(will_link);\n+  ciKlass* klass = field->holder();\n+  if (!will_link) {\n+    trap(str, klass, str->get_field_holder_index());\n+  } else {\n+    ciType* type = pop_value();\n+    ciType* field_type = field->type();\n+    if (field_type->is_two_word()) {\n+      ciType* type2 = pop_value();\n+      assert(type2->is_two_word(), \"must be 2nd half\");\n+      assert(type == half_type(type2), \"must be 2nd half\");\n+    }\n+    pop_object();\n+    push(outer()->mark_as_null_free(klass));\n+  }\n+}\n+\n@@ -885,1 +989,1 @@\n-  case Bytecodes::_aaload: do_aaload(str);                       break;\n+  case Bytecodes::_aaload: do_aload(str);                           break;\n@@ -891,1 +995,1 @@\n-      pop_objArray();\n+      pop_objOrFlatArray();\n@@ -913,1 +1017,2 @@\n-        push_object(ciObjArrayKlass::make(element_klass));\n+        bool null_free = str->has_Q_signature();\n+        push_object(ciArrayKlass::make(element_klass, null_free));\n@@ -1445,0 +1550,3 @@\n+  case Bytecodes::_aconst_init: do_aconst_init(str);              break;\n+  case Bytecodes::_withfield: do_withfield(str);                    break;\n+\n@@ -1472,0 +1580,1 @@\n+\n@@ -1492,1 +1601,1 @@\n-  ciType* type = type_at(c);\n+  ciType* type = type_at(c)->unwrap();\n@@ -1754,3 +1863,6 @@\n-      case Bytecodes::_athrow:     case Bytecodes::_ireturn:\n-      case Bytecodes::_lreturn:    case Bytecodes::_freturn:\n-      case Bytecodes::_dreturn:    case Bytecodes::_areturn:\n+      case Bytecodes::_athrow:\n+      case Bytecodes::_ireturn:\n+      case Bytecodes::_lreturn:\n+      case Bytecodes::_freturn:\n+      case Bytecodes::_dreturn:\n+      case Bytecodes::_areturn:\n@@ -3114,0 +3226,5 @@\n+ciType* ciTypeFlow::mark_as_null_free(ciType* type) {\n+  \/\/ Wrap the type to carry the information that it is null-free\n+  return env()->make_null_free_wrapper(type);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":184,"deletions":67,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -334,2 +334,2 @@\n-    \/\/ pop_objArray and pop_typeArray narrow the tos to ciObjArrayKlass\n-    \/\/ or ciTypeArrayKlass (resp.).  In the rare case that an explicit\n+    \/\/ pop_objOrFlatArray and pop_typeArray narrow the tos to ciObjArrayKlass,\n+    \/\/ ciFlatArrayKlass or ciTypeArrayKlass (resp.). In the rare case that an explicit\n@@ -337,1 +337,1 @@\n-    ciObjArrayKlass* pop_objArray() {\n+    ciArrayKlass* pop_objOrFlatArray() {\n@@ -340,2 +340,3 @@\n-      assert(array->is_obj_array_klass(), \"must be object array type\");\n-      return array->as_obj_array_klass();\n+      assert(array->is_obj_array_klass() || array->is_flat_array_klass(),\n+             \"must be a flat or an object array type\");\n+      return array->as_array_klass();\n@@ -355,1 +356,1 @@\n-    void do_aaload(ciBytecodeStream* str);\n+    void do_aload(ciBytecodeStream* str);\n@@ -364,0 +365,2 @@\n+    void do_aconst_init(ciBytecodeStream* str);\n+    void do_withfield(ciBytecodeStream* str);\n@@ -845,0 +848,2 @@\n+  ciType* mark_as_null_free(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -52,0 +53,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -85,0 +87,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -147,0 +150,2 @@\n+#define CONSTANT_CLASS_DESCRIPTORS        65\n+\n@@ -185,1 +190,1 @@\n-      case JVM_CONSTANT_Class : {\n+      case JVM_CONSTANT_Class: {\n@@ -506,1 +511,8 @@\n-        cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n+\n+        Symbol* const name = cp->symbol_at(class_index);\n+        const unsigned int name_len = name->utf8_length();\n+        if (name->is_Q_signature()) {\n+          cp->unresolved_qdescriptor_at_put(index, class_index, num_klasses++);\n+        } else {\n+          cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n+        }\n@@ -706,1 +718,2 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature,\n+          \/\/ or if it is an inline type, <vnew> with return.\n@@ -710,1 +723,2 @@\n-            if (name != vmSymbols::object_initializer_name()) {\n+            if (name != vmSymbols::object_initializer_name() &&\n+                name != vmSymbols::inline_factory_name()) {\n@@ -715,2 +729,7 @@\n-            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n-              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            } else if (!Signature::is_void_method(signature)) {\n+              \/\/ if return type is non-void then it must be an inline type\n+              if (name == vmSymbols::object_initializer_name() ||\n+                  !EnableValhalla || !supports_inline_types() ||\n+                  !signature->ends_with(JVM_SIGNATURE_ENDCLASS)) {\n+                throwIllegalSignature(\"Method\", name, signature, CHECK);\n+              }\n@@ -735,2 +754,13 @@\n-            if (ref_kind == JVM_REF_newInvokeSpecial) {\n-              if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) { \/\/ <vnew>\n+              \/\/ <vnew> factory methods must be non-void return and invokeStatic.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature() || ref_kind != JVM_REF_invokeStatic) {\n+                classfile_parse_error(\n+                  \"Bad factory method name at constant pool index %u in class file %s\",\n+                  name_ref_index, CHECK);\n+              }\n+            } else if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+              if (ref_kind == JVM_REF_newInvokeSpecial) {\n@@ -742,2 +772,10 @@\n-            } else {\n-              if (name == vmSymbols::object_initializer_name()) {\n+            } else { \/\/ <init>\n+              \/\/ The allowed invocation mode of <init> depends on its signature.\n+              \/\/ This test corresponds to verify_invoke_instructions in the verifier.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature()\n+                  && ref_kind == JVM_REF_newInvokeSpecial) {\n+                \/\/ OK, could be a constructor call\n+              } else {\n@@ -820,4 +858,31 @@\n-\/\/ Side-effects: populates the _local_interfaces field\n-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,\n-                                       const int itfs_len,\n-                                       ConstantPool* const cp,\n+static void check_identity_and_value_modifiers(ClassFileParser* current, const InstanceKlass* super_type, TRAPS) {\n+  assert(super_type != NULL,\"Method doesn't support null super type\");\n+  if (super_type->carries_identity_modifier()) {\n+    if (current->carries_value_modifier()) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(\n+          THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_IncompatibleClassChangeError(),\n+          \"Value type %s has an identity type as supertype\",\n+          current->class_name()->as_klass_external_name());\n+        return;\n+      }\n+    current->set_carries_identity_modifier();\n+  }\n+  if (super_type->carries_value_modifier()) {\n+    if (current->carries_identity_modifier()) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_IncompatibleClassChangeError(),\n+        \"Identity type %s has a value type as supertype\",\n+        current->class_name()->as_klass_external_name());\n+      return;\n+    }\n+    current->set_carries_value_modifier();\n+  }\n+}\n+\n+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,\n+                                       int itfs_len,\n+                                       ConstantPool* cp,\n@@ -825,0 +890,7 @@\n+                                       \/\/ FIXME: lots of these functions\n+                                       \/\/ declare their parameters as const,\n+                                       \/\/ which adds only noise to the code.\n+                                       \/\/ Remove the spurious const modifiers.\n+                                       \/\/ Many are of the form \"const int x\"\n+                                       \/\/ or \"T* const x\".\n+                                       bool* const is_declared_atomic,\n@@ -832,0 +904,1 @@\n+\n@@ -834,3 +907,2 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);\n-\n-    int index;\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n+    int index = 0;\n@@ -839,1 +911,0 @@\n-      Klass* interf;\n@@ -844,32 +915,1 @@\n-      if (cp->tag_at(interface_index).is_klass()) {\n-        interf = cp->resolved_klass_at(interface_index);\n-      } else {\n-        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n-\n-        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n-        \/\/ But need to make sure it's not an array type.\n-        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n-                           \"Bad interface name in class file %s\", CHECK);\n-\n-        \/\/ Call resolve_super so class circularity is checked\n-        interf = SystemDictionary::resolve_super_or_fail(\n-                                                  _class_name,\n-                                                  unresolved_klass,\n-                                                  Handle(THREAD, _loader_data->class_loader()),\n-                                                  _protection_domain,\n-                                                  false,\n-                                                  CHECK);\n-      }\n-\n-      if (!interf->is_interface()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n-                          _class_name->as_klass_external_name(),\n-                          interf->external_name(),\n-                          interf->class_in_module_of_loader()));\n-      }\n-\n-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n-        *has_nonstatic_concrete_methods = true;\n-      }\n-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));\n+      _local_interface_indexes->at_put_grow(index, interface_index);\n@@ -893,2 +933,1 @@\n-        const InstanceKlass* const k = _local_interfaces->at(index);\n-        name = k->name();\n+        name = cp->klass_name_at(_local_interface_indexes->at(index));\n@@ -1380,0 +1419,1 @@\n+  STATIC_INLINE,        \/\/ inline type field\n@@ -1385,0 +1425,1 @@\n+  NONSTATIC_INLINE,\n@@ -1404,6 +1445,7 @@\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n+  NONSTATIC_OOP,       \/\/ T_PRIMITIVE_OBJECT = 14,\n+  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n+  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n+  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n+  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20,\n@@ -1424,6 +1466,7 @@\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n+  STATIC_OOP,          \/\/ T_PRIMITIVE_OBJECT = 14,\n+  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n+  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n+  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n+  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n+  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20\n@@ -1432,1 +1475,1 @@\n-static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {\n+static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {\n@@ -1436,0 +1479,3 @@\n+  if (is_inline_type) {\n+    result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;\n+  }\n@@ -1449,2 +1495,2 @@\n-  void update(bool is_static, BasicType type) {\n-    FieldAllocationType atype = basic_type_to_atype(is_static, type);\n+  void update(bool is_static, BasicType type, bool is_inline_type) {\n+    FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);\n@@ -1462,1 +1508,1 @@\n-                                   bool is_interface,\n+                                   AccessFlags class_access_flags,\n@@ -1478,0 +1524,1 @@\n+  bool is_inline_type = class_access_flags.is_value_class() && !class_access_flags.is_abstract();\n@@ -1485,1 +1532,5 @@\n-  const int total_fields = length + num_injected;\n+\n+  \/\/ two more slots are required for inline classes:\n+  \/\/ one for the static field with a reference to the pre-allocated default value\n+  \/\/ one for the field the JVM injects when detecting an empty inline class\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);\n@@ -1515,0 +1566,1 @@\n+  int instance_fields_count = 0;\n@@ -1519,0 +1571,4 @@\n+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;\n+\n+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    verify_legal_field_modifiers(flags, class_access_flags, CHECK);\n@@ -1520,2 +1576,0 @@\n-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n-    verify_legal_field_modifiers(flags, is_interface, CHECK);\n@@ -1537,0 +1591,1 @@\n+    if (!access_flags.is_static()) instance_fields_count++;\n@@ -1596,1 +1651,1 @@\n-    fac->update(is_static, type);\n+    fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n@@ -1640,1 +1695,1 @@\n-      fac->update(false, type);\n+      fac->update(false, type, false);\n@@ -1645,0 +1700,27 @@\n+  if (is_inline_type) {\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n+                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n+                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                      0);\n+    const BasicType type = Signature::basic_type(vmSymbols::object_signature());\n+    fac->update(true, type, false);\n+    index++;\n+  }\n+\n+  if (is_inline_type && instance_fields_count == 0) {\n+    _is_empty_inline_type = true;\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+    field->initialize(JVM_ACC_FIELD_INTERNAL,\n+        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n+        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n+        0);\n+    const BasicType type = Signature::basic_type(vmSymbols::byte_signature());\n+    fac->update(false, type, false);\n+    index++;\n+  }\n+\n+  if (instance_fields_count > 0) {\n+    _has_nonstatic_fields = true;\n+  }\n+\n@@ -1962,0 +2044,5 @@\n+  const char* class_note = \"\";\n+  if (is_inline_type() && name == vmSymbols::object_initializer_name()) {\n+    class_note = \" (an inline class)\";\n+  }\n+\n@@ -1965,2 +2052,2 @@\n-      \"%s \\\"%s\\\" in class %s has illegal signature \\\"%s\\\"\", type,\n-      name->as_C_string(), _class_name->as_C_string(), sig->as_C_string());\n+      \"%s \\\"%s\\\" in class %s%s has illegal signature \\\"%s\\\"\", type,\n+      name->as_C_string(), _class_name->as_C_string(), class_note, sig->as_C_string());\n@@ -2269,0 +2356,2 @@\n+                                      bool is_value_class,\n+                                      bool is_abstract_class,\n@@ -2310,1 +2399,34 @@\n-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);\n+    verify_legal_method_modifiers(flags, access_flags() , name, CHECK_NULL);\n+  }\n+\n+  if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <vnew>, class file %s\", CHECK_NULL);\n+    } else if (!is_value_class) {\n+       classfile_parse_error(\"Identity class cannot have a method <vnew>, class file %s\", CHECK_NULL);\n+    } else if (signature->is_void_method_signature()) {\n+       classfile_parse_error(\"Factory method <vnew> must have a non-void return type, class file %s\", CHECK_NULL);\n+    } else { \/\/ also OK, a static factory, as long as the return value is good\n+      bool ok = false;\n+      SignatureStream ss((Symbol*) signature, true);\n+      while (!ss.at_return_type())  ss.next();\n+      if (ss.is_reference()) {\n+        Symbol* ret = ss.as_symbol();\n+        const Symbol* required = class_name();\n+        if (is_hidden()) {\n+          \/\/ The original class name for hidden classes changed.\n+          \/\/\/ So using the original name in the return type is no longer valid.\n+          required = vmSymbols::java_lang_Object();\n+        }\n+        ok = (ret == required);\n+      }\n+      if (!ok) {\n+        throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+      }\n+      \/\/ factory method, with a non-void return.  No other\n+      \/\/ definition of <vnew> is possible.\n+      \/\/\n+      \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+      \/\/ signature of any attempt to invoke <vnew>, and ensure that it\n+      \/\/ returns non-void.\n+    }\n@@ -2313,3 +2435,24 @@\n-  if (name == vmSymbols::object_initializer_name() && is_interface) {\n-    classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n-    return NULL;\n+  if (name == vmSymbols::object_initializer_name()) {\n+    if (is_interface) {\n+      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n+    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n+      \/\/ OK, a constructor\n+    } else {\n+      \/\/ not OK, so throw the same error as in verify_legal_method_signature.\n+      throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+    }\n+    \/\/ A declared <init> method must always be a non-static\n+    \/\/ object constructor, with a void return.\n+    \/\/\n+    \/\/ The verifier (in verify_invoke_instructions) will inspect the\n+    \/\/ signature of any attempt to invoke <init>, and ensure that it\n+    \/\/ returns void.\n+  }\n+\n+  if (EnableValhalla) {\n+    if (((flags & JVM_ACC_SYNCHRONIZED) == JVM_ACC_SYNCHRONIZED)\n+        && ((flags & JVM_ACC_STATIC) == 0 )\n+        && !carries_identity_modifier()) {\n+      classfile_parse_error(\"Invalid synchronized method in non-identity class %s\", THREAD);\n+        return NULL;\n+    }\n@@ -2885,0 +3028,2 @@\n+                                    bool is_value_class,\n+                                    bool is_abstract_type,\n@@ -2909,0 +3054,2 @@\n+                                    is_value_class,\n+                                    is_abstract_type,\n@@ -3185,2 +3332,2 @@\n-    \/\/ Access flags\n-    jint flags;\n+\n+    jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n@@ -3189,3 +3336,1 @@\n-      flags = cfs->get_u2_fast() & (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-    } else {\n-      flags = cfs->get_u2_fast() & RECOGNIZED_INNER_CLASS_MODIFIERS;\n+      recognized_modifiers |= JVM_ACC_MODULE;\n@@ -3193,0 +3338,7 @@\n+    if (supports_inline_types()) {\n+      recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY;\n+    }\n+\n+    \/\/ Access flags\n+    jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+\n@@ -3197,1 +3349,13 @@\n-    verify_legal_class_modifiers(flags, CHECK_0);\n+\n+    if (EnableValhalla) {\n+      if (!supports_inline_types()) {\n+        const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+        const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+        if (!is_module && !is_interface) {\n+          flags |= JVM_ACC_IDENTITY;\n+        }\n+      }\n+    }\n+\n+    const char* name = inner_name_index == 0 ? \"unnamed\" : cp->symbol_at(inner_name_index)->as_utf8();\n+    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n@@ -3301,0 +3465,33 @@\n+u2 ClassFileParser::parse_classfile_preload_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const preload_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (preload_attribute_start != NULL) {\n+    cfs->set_current(preload_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  const int size = length;\n+  Array<u2>* const preload_classes = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _preload_classes = preload_classes;\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 class_info_index = cfs->get_u2_fast();\n+      check_property(\n+        valid_klass_reference_at(class_info_index),\n+        \"Preload class_info_index %u has bad constant type in class file %s\",\n+        class_info_index, CHECK_0);\n+      preload_classes->at_put(index++, class_info_index);\n+    }\n+    assert(index == size, \"wrong size\");\n+  }\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3585,0 +3782,2 @@\n+  \/\/ Set _preload_classes attribute to default sentinel\n+  _preload_classes = Universe::the_empty_short_array();\n@@ -3591,0 +3790,1 @@\n+  bool parsed_preload_attribute = false;\n@@ -3616,0 +3816,2 @@\n+  const u1* preload_attribute_start = NULL;\n+  u4  preload_attribute_length = 0;\n@@ -3842,0 +4044,9 @@\n+            if (EnableValhalla && tag == vmSymbols::tag_preload()) {\n+              if (parsed_preload_attribute) {\n+                classfile_parse_error(\"Multiple Preload attributes in class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_preload_attribute = true;\n+              preload_attribute_start = cfs->current();\n+              preload_attribute_length = attribute_length;\n+            }\n@@ -3922,0 +4133,12 @@\n+  if (parsed_preload_attribute) {\n+    const u2 num_classes = parse_classfile_preload_attribute(\n+                            cfs,\n+                            preload_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        preload_attribute_length == sizeof(num_classes) + sizeof(u2) * num_classes,\n+        \"Wrong Preload attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3986,0 +4209,1 @@\n+  this_klass->set_preload_classes(_preload_classes);\n@@ -4037,2 +4261,1 @@\n-                   \"Invalid superclass index %u in class file %s\",\n-                   super_class_index,\n+                   \"Invalid superclass index 0 in class file %s\",\n@@ -4047,1 +4270,0 @@\n-    bool is_array = false;\n@@ -4050,4 +4272,0 @@\n-      if (need_verify)\n-        is_array = super_klass->is_array_klass();\n-    } else if (need_verify) {\n-      is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -4056,0 +4274,1 @@\n+      bool is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -4179,0 +4398,19 @@\n+void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,\n+                                                const char* msg,\n+                                                const Symbol* name,\n+                                                const Symbol* sig) const {\n+\n+  ResourceMark rm(THREAD);\n+  if (name == NULL || sig == NULL) {\n+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"class: %s - %s\", _class_name->as_C_string(), msg);\n+  }\n+  else {\n+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"\\\"%s\\\" sig: \\\"%s\\\" class: %s - %s\", name->as_C_string(), sig->as_C_string(),\n+        _class_name->as_C_string(), msg);\n+  }\n+}\n+\n@@ -4213,0 +4451,5 @@\n+      if (ik->is_inline_klass()) {\n+        JavaThread *THREAD = JavaThread::current();\n+        throwInlineTypeLimitation(THREAD_AND_LOCATION, \"Inline Types do not support Cloneable\");\n+        return;\n+      }\n@@ -4253,0 +4496,6 @@\n+bool ClassFileParser::supports_inline_types() const {\n+  \/\/ Inline types are only supported by class file version 61.65535 and later\n+  return _major_version > JAVA_21_VERSION ||\n+         (_major_version == JAVA_21_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+}\n+\n@@ -4296,3 +4545,4 @@\n-  } else if (max_transitive_size == local_size) {\n-    \/\/ only local interfaces added, share local interface array\n-    return local_ifs;\n+    \/\/ The three lines below are commented to work around bug JDK-8245487\n+\/\/  } else if (max_transitive_size == local_size) {\n+\/\/    \/\/ only local interfaces added, share local interface array\n+\/\/    return local_ifs;\n@@ -4319,0 +4569,1 @@\n+\n@@ -4347,0 +4598,10 @@\n+    \/\/ The JVMS says that super classes for value types must not have the ACC_IDENTITY\n+    \/\/ flag set. But, java.lang.Object must still be allowed to be a direct super class\n+    \/\/ for a value classes.  So, it is treated as a special case for now.\n+    if (this_klass->access_flags().is_value_class() &&\n+        super_ik->name() != vmSymbols::java_lang_Object() &&\n+        super_ik->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super_ik, THREAD);\n+      return;\n+    }\n+\n@@ -4530,1 +4791,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n@@ -4532,0 +4793,4 @@\n+  const bool is_value_class = (flags & JVM_ACC_VALUE) != 0;\n+  const bool is_primitive_class = (flags & JVM_ACC_PRIMITIVE) != 0;\n+  const bool is_identity_class = (flags & JVM_ACC_IDENTITY) != 0;\n+  const bool is_inner_class = name != NULL;\n@@ -4543,1 +4808,23 @@\n-  if (!_need_verify) { return; }\n+  if (is_value_class && !EnableValhalla) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla\",\n+        _class_name->as_C_string()\n+      );\n+    return;\n+  }\n+\n+  if (is_primitive_class && !EnablePrimitiveClasses) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Class modifier ACC_PRIMITIVE in class %s requires option -XX:+EnablePrimitiveClasses\",\n+        _class_name->as_C_string()\n+      );\n+    return;\n+  }\n+\n+  \/\/ if (!_need_verify) { return; }\n@@ -4555,2 +4842,6 @@\n-      (is_interface && major_gte_1_5 && (is_super || is_enum)) ||\n-      (!is_interface && major_gte_1_5 && is_annotation)) {\n+      (is_interface && major_gte_1_5 && ((is_super && (!EnableValhalla || !supports_inline_types())) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation) ||\n+      (is_value_class && is_enum) ||\n+      (is_identity_class && is_value_class) ||\n+      (EnableValhalla && supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n+      (EnablePrimitiveClasses && supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n@@ -4558,7 +4849,21 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Illegal class modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags\n-    );\n-    return;\n+    const char* class_note = \"\";\n+    if (is_value_class)  class_note = \" (a value class)\";\n+    if (is_primitive_class)  class_note = \" (a primitive class)\";\n+    if (is_value_class && is_identity_class) class_note = \" (a value and identity class)\";\n+    if (name == NULL) { \/\/ Not an inner class\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in class %s%s: 0x%X\",\n+        _class_name->as_C_string(), class_note, flags\n+      );\n+      return;\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in declaration of inner class %s%s of class %s: 0x%X\",\n+        name, class_note, _class_name->as_C_string(), flags\n+      );\n+      return;\n+    }\n@@ -4630,2 +4935,2 @@\n-void ClassFileParser::verify_legal_field_modifiers(jint flags,\n-                                                   bool is_interface,\n+void ClassFileParser:: verify_legal_field_modifiers(jint flags,\n+                                                   AccessFlags class_access_flags,\n@@ -4645,0 +4950,5 @@\n+  const bool is_interface = class_access_flags.is_interface();\n+  const bool is_abstract = class_access_flags.is_abstract();\n+  const bool is_value_class = class_access_flags.is_value_class();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+\n@@ -4656,0 +4966,6 @@\n+    } else {\n+      if (is_value_class && !is_abstract && !is_static && !is_final) {\n+        is_illegal = true;\n+      } else if (is_abstract && !is_identity_class && !is_static) {\n+        is_illegal = true;\n+      }\n@@ -4671,1 +4987,1 @@\n-                                                    bool is_interface,\n+                                                    AccessFlags class_access_flags,\n@@ -4690,0 +5006,5 @@\n+  const bool is_factory      = (name == vmSymbols::inline_factory_name() && supports_inline_types());\n+  const bool is_interface    = class_access_flags.is_interface();\n+  const bool is_value_class  = class_access_flags.is_value_class();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+  const bool is_abstract_class = class_access_flags.is_abstract();\n@@ -4693,0 +5014,1 @@\n+  const char* class_note = \"\";\n@@ -4726,1 +5048,7 @@\n-      if (is_initializer) {\n+      if (is_factory) { \/\/ <vnew> factory method\n+        if (is_final || is_synchronized || is_native || !is_static ||\n+            is_abstract || is_bridge) {\n+          is_illegal = true;\n+          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n+        }\n+      } else if (is_initializer) {\n@@ -4732,4 +5060,9 @@\n-        if (is_abstract) {\n-          if ((is_final || is_native || is_private || is_static ||\n-              (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n-            is_illegal = true;\n+        if (!is_identity_class && is_synchronized && !is_static) {\n+          is_illegal = true;\n+          class_note = \" (not an identity class)\";\n+        } else {\n+          if (is_abstract) {\n+            if ((is_final || is_native || is_private || is_static ||\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n+              is_illegal = true;\n+            }\n@@ -4744,5 +5077,14 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Method %s in class %s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), flags);\n+    if (is_value_class && is_initializer) {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method <init> is not allowed in value class %s\",\n+        _class_name->as_C_string());\n+    } else {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+        name->as_C_string(), _class_name->as_C_string(),\n+        class_note, flags);\n+    }\n@@ -4906,1 +5248,12 @@\n-    case JVM_SIGNATURE_CLASS: {\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n+      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators (TODO: JDK-8270852).\n+      \/\/ For now, compare to class file version 51 so old verifier doesn't see Q signatures.\n+      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n+        classfile_parse_error(\"Class name contains illegal Q-signature \"\n+                              \"in descriptor in class file %s, requires option -XX:+EnablePrimitiveClasses\",\n+                              CHECK_0);\n+        return NULL;\n+      }\n+      \/\/ fall through\n+    case JVM_SIGNATURE_CLASS:\n+    {\n@@ -4917,1 +5270,1 @@\n-        \/\/ Skip leading 'L' and ignore first appearance of ';'\n+        \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -4973,0 +5326,4 @@\n+    } else if ((_major_version >= CONSTANT_CLASS_DESCRIPTORS || _class_name->starts_with(\"jdk\/internal\/reflect\/\"))\n+                   && bytes[length - 1] == ';' ) {\n+      \/\/ Support for L...; and Q...; descriptors\n+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);\n@@ -5038,1 +5395,4 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()  ||\n+          (EnableValhalla && supports_inline_types() &&\n+          name == vmSymbols::inline_factory_name())) {\n@@ -5070,0 +5430,3 @@\n+  if ((!supports_inline_types() || !EnablePrimitiveClasses) && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n+    throwIllegalSignature(\"Field\", name, signature, CHECK);\n+  }\n@@ -5097,2 +5460,3 @@\n-  int sig_length = signature->utf8_length();\n-  if (name->utf8_length() > 0 &&\n+  if (!is_value_class()) {\n+    int sig_length = signature->utf8_length();\n+    if (name->utf8_length() > 0 &&\n@@ -5102,1 +5466,2 @@\n-    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+      throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    }\n@@ -5278,1 +5643,0 @@\n-\n@@ -5314,0 +5678,10 @@\n+  if (_field_info->_is_naturally_atomic && ik->is_inline_klass()) {\n+    ik->set_is_naturally_atomic();\n+  }\n+\n+  if (carries_identity_modifier()) {\n+    ik->set_carries_identity_modifier();\n+  } else if (carries_value_modifier()) {\n+    ik->set_carries_value_modifier();\n+  }\n+\n@@ -5315,1 +5689,1 @@\n-  ik->set_static_oop_field_count(_fac->count[STATIC_OOP]);\n+  ik->set_static_oop_field_count(_fac->count[STATIC_OOP] + _fac->count[STATIC_INLINE]);\n@@ -5332,0 +5706,1 @@\n+  assert(NULL == _preload_classes, \"invariant\");\n@@ -5365,0 +5740,3 @@\n+  if (_is_declared_atomic) {\n+    ik->set_is_declared_atomic();\n+  }\n@@ -5472,0 +5850,27 @@\n+  bool all_fields_empty = true;\n+  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static()) {\n+      if (fs.field_descriptor().is_inline_type()) {\n+        Klass* k = _inline_type_field_klasses->at(fs.index());\n+        ik->set_inline_type_field_klass(fs.index(), k);\n+        if (!InlineKlass::cast(k)->is_empty_inline_type()) { all_fields_empty = false; }\n+      } else {\n+        all_fields_empty = false;\n+      }\n+    } else if (is_inline_type() && (fs.name() == vmSymbols::default_value_name())) {\n+      InlineKlass::cast(ik)->set_default_value_offset(ik->field_offset(fs.index()));\n+    }\n+  }\n+\n+  if (_is_empty_inline_type || (is_inline_type() && all_fields_empty)) {\n+    ik->set_is_empty_inline_type();\n+  }\n+\n+  if (is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(ik);\n+    vk->set_alignment(_alignment);\n+    vk->set_first_field_offset(_first_field_offset);\n+    vk->set_exact_size_in_bytes(_exact_size_in_bytes);\n+    InlineKlass::cast(ik)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -5562,0 +5967,1 @@\n+  _preload_classes(NULL),\n@@ -5564,0 +5970,1 @@\n+  _local_interface_indexes(NULL),\n@@ -5575,0 +5982,1 @@\n+  _inline_type_field_klasses(NULL),\n@@ -5601,0 +6009,7 @@\n+  _has_inline_type_fields(false),\n+  _has_nonstatic_fields(false),\n+  _is_empty_inline_type(false),\n+  _is_naturally_atomic(false),\n+  _is_declared_atomic(false),\n+  _carries_value_modifier(false),\n+  _carries_identity_modifier(false),\n@@ -5650,0 +6065,1 @@\n+  _preload_classes = NULL;\n@@ -5667,0 +6083,4 @@\n+  if (_inline_type_field_klasses != NULL) {\n+     MetadataFactory::free_array<InlineKlass*>(_loader_data, _inline_type_field_klasses);\n+  }\n+\n@@ -5689,0 +6109,4 @@\n+  if (_preload_classes != NULL && _preload_classes != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _preload_classes);\n+  }\n+\n@@ -5773,2 +6197,1 @@\n-  \/\/ Access flags\n-  jint flags;\n+  jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n@@ -5777,3 +6200,1 @@\n-    flags = stream->get_u2_fast() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-  } else {\n-    flags = stream->get_u2_fast() & JVM_RECOGNIZED_CLASS_MODIFIERS;\n+    recognized_modifiers |= JVM_ACC_MODULE;\n@@ -5781,0 +6202,7 @@\n+  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE supported version\n+  if (supports_inline_types()) {\n+    recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE;\n+  }\n+\n+  \/\/ Access flags\n+  jint flags = stream->get_u2_fast() & recognized_modifiers;\n@@ -5787,12 +6215,0 @@\n-  verify_legal_class_modifiers(flags, CHECK);\n-\n-  short bad_constant = class_bad_constant_seen();\n-  if (bad_constant != 0) {\n-    \/\/ Do not throw CFE until after the access_flags are checked because if\n-    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n-    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n-    return;\n-  }\n-\n-  _access_flags.set_flags(flags);\n-\n@@ -5810,0 +6226,32 @@\n+  bool is_java_lang_Object = class_name_in_cp == vmSymbols::java_lang_Object();\n+\n+  verify_legal_class_modifiers(flags, NULL, is_java_lang_Object, CHECK);\n+\n+  if (EnableValhalla) {\n+    if(!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface && !is_java_lang_Object) {\n+        flags |= JVM_ACC_IDENTITY;\n+      }\n+    }\n+  }\n+\n+  _access_flags.set_flags(flags);\n+\n+  if (EnableValhalla) {\n+    if (_access_flags.is_identity_class()) set_carries_identity_modifier();\n+    if (_access_flags.is_value_class()) set_carries_value_modifier();\n+    if (carries_identity_modifier() && carries_value_modifier()) {\n+      classfile_parse_error(\"Class %s has both ACC_IDENTITY and ACC_VALUE modifiers\", THREAD);\n+    }\n+  }\n+\n+  short bad_constant = class_bad_constant_seen();\n+  if (bad_constant != 0) {\n+    \/\/ Do not throw CFE until after the access_flags are checked because if\n+    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n+    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n+    return;\n+  }\n+\n@@ -5887,0 +6335,1 @@\n+                   &_is_declared_atomic,\n@@ -5889,2 +6338,0 @@\n-  assert(_local_interfaces != NULL, \"invariant\");\n-\n@@ -5894,1 +6341,1 @@\n-               _access_flags.is_interface(),\n+               _access_flags,\n@@ -5906,1 +6353,3 @@\n-                _access_flags.is_interface(),\n+                is_interface(),\n+                is_value_class(),\n+                is_abstract_class(),\n@@ -5989,2 +6438,2 @@\n-                   \"java.lang.Object cannot implement an interface in class file %s\",\n-                   CHECK);\n+        \"java.lang.Object cannot implement an interface in class file %s\",\n+        CHECK);\n@@ -5995,1 +6444,1 @@\n-    if (_access_flags.is_interface()) {\n+    if (is_interface()) {\n@@ -6013,0 +6462,9 @@\n+    if (_super_klass->is_interface()) {\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (EnableValhalla) {\n+      check_identity_and_value_modifiers(this, _super_klass, CHECK);\n+    }\n+\n@@ -6016,0 +6474,4 @@\n+    if (_super_klass->is_declared_atomic()) {\n+      _is_declared_atomic = true;\n+    }\n+  }\n@@ -6017,3 +6479,54 @@\n-    if (_super_klass->is_interface()) {\n-      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n-      return;\n+  if (*ForceNonTearable != '\\0') {\n+    \/\/ Allow a command line switch to force the same atomicity property:\n+    const char* class_name_str = _class_name->as_C_string();\n+    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+      _is_declared_atomic = true;\n+    }\n+  }\n+\n+  int itfs_len = _local_interface_indexes == NULL ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);\n+  if (_local_interface_indexes != NULL) {\n+    for (int i = 0; i < _local_interface_indexes->length(); i++) {\n+      u2 interface_index = _local_interface_indexes->at(i);\n+      Klass* interf;\n+      if (cp->tag_at(interface_index).is_klass()) {\n+        interf = cp->resolved_klass_at(interface_index);\n+      } else {\n+        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n+\n+        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n+        \/\/ But need to make sure it's not an array type.\n+        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                            \"Bad interface name in class file %s\", CHECK);\n+\n+        \/\/ Call resolve_super so class circularity is checked\n+        interf = SystemDictionary::resolve_super_or_fail(\n+                                                  _class_name,\n+                                                  unresolved_klass,\n+                                                  Handle(THREAD, _loader_data->class_loader()),\n+                                                  _protection_domain,\n+                                                  false,\n+                                                  CHECK);\n+      }\n+\n+      if (!interf->is_interface()) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n+                          _class_name->as_klass_external_name(),\n+                          interf->external_name(),\n+                          interf->class_in_module_of_loader()));\n+      }\n+\n+      if (EnableValhalla) {\n+        \/\/ Check modifiers and set carries_identity_modifier\/carries_value_modifier flags\n+        check_identity_and_value_modifiers(this, InstanceKlass::cast(interf), CHECK);\n+      }\n+\n+      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n+        _has_nonstatic_concrete_methods = true;\n+      }\n+      if (InstanceKlass::cast(interf)->is_declared_atomic()) {\n+        _is_declared_atomic = true;\n+      }\n+      _local_interfaces->at_put(i, InstanceKlass::cast(interf));\n@@ -6022,0 +6535,1 @@\n+  assert(_local_interfaces != NULL, \"invariant\");\n@@ -6050,1 +6564,1 @@\n-  _itable_size = _access_flags.is_interface() ? 0 :\n+  _itable_size = is_interface() ? 0 :\n@@ -6056,0 +6570,26 @@\n+\n+  if (EnablePrimitiveClasses) {\n+    _inline_type_field_klasses = MetadataFactory::new_array<InlineKlass*>(_loader_data,\n+                                                   java_fields_count(),\n+                                                   NULL,\n+                                                   CHECK);\n+    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT && !fs.access_flags().is_static()) {\n+        \/\/ Pre-load inline class\n+        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+            Handle(THREAD, _loader_data->class_loader()),\n+            _protection_domain, true, CHECK);\n+        assert(klass != NULL, \"Sanity check\");\n+        if (!klass->access_flags().is_value_class()) {\n+          assert(klass->is_instance_klass(), \"Sanity check\");\n+          ResourceMark rm(THREAD);\n+            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                      err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                      _class_name->as_C_string(),\n+                      InstanceKlass::cast(klass)->external_name()));\n+        }\n+        _inline_type_field_klasses->at_put(fs.index(), InlineKlass::cast(klass));\n+      }\n+    }\n+  }\n+\n@@ -6058,2 +6598,9 @@\n-                        _parsed_annotations->is_contended(), _field_info);\n-  lb.build_layout();\n+      _parsed_annotations->is_contended(), is_inline_type(),\n+      _field_info, _inline_type_field_klasses);\n+  lb.build_layout(CHECK);\n+  if (is_inline_type()) {\n+    _alignment = lb.get_alignment();\n+    _first_field_offset = lb.get_first_field_offset();\n+    _exact_size_in_bytes = lb.get_exact_size_in_byte();\n+  }\n+  _has_inline_type_fields = _field_info->_has_inline_fields;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":704,"deletions":157,"binary":false,"changes":861,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    if (*start == JVM_SIGNATURE_CLASS) {\n+    if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -403,0 +404,10 @@\n+void ClassLoaderData::inline_classes_do(void f(InlineKlass*)) {\n+  \/\/ Lock-free access requires load_acquire\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+    if (k->is_inline_klass()) {\n+      f(InlineKlass::cast(k));\n+    }\n+    assert(k != k->next_link(), \"no loops!\");\n+  }\n+}\n+\n@@ -557,0 +568,2 @@\n+  inline_classes_do(InlineKlass::cleanup);\n+\n@@ -854,1 +867,5 @@\n-        MetadataFactory::free_metadata(this, (InstanceKlass*)m);\n+        if (!((Klass*)m)->is_inline_klass()) {\n+          MetadataFactory::free_metadata(this, (InstanceKlass*)m);\n+        } else {\n+          MetadataFactory::free_metadata(this, (InlineKlass*)m);\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+  void inline_classes_do(void f(InlineKlass*));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -37,1 +40,0 @@\n-\n@@ -41,0 +43,1 @@\n+  _inline_klass(NULL),\n@@ -56,0 +59,1 @@\n+ _inline_klass(NULL),\n@@ -62,1 +66,1 @@\n-  assert(kind == REGULAR || kind == FLATTENED || kind == INHERITED,\n+  assert(kind == REGULAR || kind == INLINED || kind == INHERITED,\n@@ -78,1 +82,2 @@\n-  _primitive_fields(NULL),\n+  _small_primitive_fields(NULL),\n+  _big_primitive_fields(NULL),\n@@ -86,2 +91,4 @@\n-  if (_primitive_fields == NULL) {\n-    _primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  if (size >= oopSize) {\n+    add_to_big_primitive_list(block);\n+  } else {\n+    add_to_small_primitive_list(block);\n@@ -89,1 +96,0 @@\n-  _primitive_fields->append(block);\n@@ -102,0 +108,10 @@\n+void FieldGroup::add_inlined_field(AllFieldStream fs, InlineKlass* vk) {\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+  block->set_inline_klass(vk);\n+  if (block->size() >= oopSize) {\n+    add_to_big_primitive_list(block);\n+  } else {\n+    add_to_small_primitive_list(block);\n+  }\n+}\n+\n@@ -103,2 +119,5 @@\n-  if (_primitive_fields != NULL) {\n-    _primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  if (_small_primitive_fields != NULL) {\n+    _small_primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  }\n+  if (_big_primitive_fields != NULL) {\n+    _big_primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n@@ -108,0 +127,14 @@\n+void FieldGroup::add_to_small_primitive_list(LayoutRawBlock* block) {\n+  if (_small_primitive_fields == NULL) {\n+    _small_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  }\n+  _small_primitive_fields->append(block);\n+}\n+\n+void FieldGroup::add_to_big_primitive_list(LayoutRawBlock* block) {\n+  if (_big_primitive_fields == NULL) {\n+    _big_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  }\n+  _big_primitive_fields->append(block);\n+}\n+\n@@ -141,1 +174,2 @@\n-      _start = _blocks;  \/\/ start allocating fields from the first empty block\n+      _start = _blocks; \/\/ Setting _start to _blocks instead of _last would allow subclasses\n+      \/\/ to allocate fields in empty slots of their super classes\n@@ -149,3 +183,5 @@\n-  LayoutRawBlock* block = _start;\n-  while (block->kind() != LayoutRawBlock::INHERITED && block->kind() != LayoutRawBlock::REGULAR\n-      && block->kind() != LayoutRawBlock::FLATTENED && block->kind() != LayoutRawBlock::PADDING) {\n+  LayoutRawBlock* block = _blocks;\n+  while (block != NULL\n+         && block->kind() != LayoutRawBlock::INHERITED\n+         && block->kind() != LayoutRawBlock::REGULAR\n+         && block->kind() != LayoutRawBlock::INLINED) {\n@@ -157,3 +193,2 @@\n-\n-\/\/ Insert a set of fields into a layout using a best-fit strategy.\n-\/\/ For each field, search for the smallest empty slot able to fit the field\n+\/\/ Insert a set of fields into a layout.\n+\/\/ For each field, search for an empty slot able to fit the field\n@@ -173,1 +208,0 @@\n-\n@@ -191,0 +225,1 @@\n+\n@@ -207,1 +242,0 @@\n-\n@@ -306,3 +340,11 @@\n-      int size = type2aelembytes(type);\n-      \/\/ INHERITED blocks are marked as non-reference because oop_maps are handled by their holder class\n-      LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n+      LayoutRawBlock* block;\n+      if (type == T_PRIMITIVE_OBJECT) {\n+        InlineKlass* vk = InlineKlass::cast(ik->get_inline_type_field_klass(fs.index()));\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, vk->get_exact_size_in_bytes(),\n+                                   vk->get_alignment(), false);\n+\n+      } else {\n+        int size = type2aelembytes(type);\n+        \/\/ INHERITED blocks are marked as non-reference because oop_maps are handled by their holder class\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n+      }\n@@ -314,1 +356,0 @@\n-\n@@ -319,1 +360,0 @@\n-\n@@ -355,1 +395,0 @@\n-\n@@ -366,1 +405,0 @@\n-\n@@ -380,1 +418,0 @@\n-\n@@ -432,47 +469,46 @@\n-      case LayoutRawBlock::REGULAR: {\n-        FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n-        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                         b->offset(),\n-                         fi->name(_cp)->as_C_string(),\n-                         fi->signature(_cp)->as_C_string(),\n-                         b->size(),\n-                         b->alignment(),\n-                         \"REGULAR\");\n-        break;\n-      }\n-      case LayoutRawBlock::FLATTENED: {\n-        FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n-        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                         b->offset(),\n-                         fi->name(_cp)->as_C_string(),\n-                         fi->signature(_cp)->as_C_string(),\n-                         b->size(),\n-                         b->alignment(),\n-                         \"FLATTENED\");\n-        break;\n-      }\n-      case LayoutRawBlock::RESERVED: {\n-        output->print_cr(\" @%d %d\/- %s\",\n-                         b->offset(),\n-                         b->size(),\n-                         \"RESERVED\");\n-        break;\n-      }\n-      case LayoutRawBlock::INHERITED: {\n-        assert(!is_static, \"Static fields are not inherited in layouts\");\n-        assert(super != NULL, \"super klass must be provided to retrieve inherited fields info\");\n-        bool found = false;\n-        const InstanceKlass* ik = super;\n-        while (!found && ik != NULL) {\n-          for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n-            if (fs.offset() == b->offset()) {\n-              output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                  b->offset(),\n-                  fs.name()->as_C_string(),\n-                  fs.signature()->as_C_string(),\n-                  b->size(),\n-                  b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla\n-                  \"INHERITED\");\n-              found = true;\n-              break;\n-            }\n+    case LayoutRawBlock::REGULAR: {\n+      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n+      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                       b->offset(),\n+                       fi->name(_cp)->as_C_string(),\n+                       fi->signature(_cp)->as_C_string(),\n+                       b->size(),\n+                       b->alignment(),\n+                       \"REGULAR\");\n+      break;\n+    }\n+    case LayoutRawBlock::INLINED: {\n+      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n+      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                       b->offset(),\n+                       fi->name(_cp)->as_C_string(),\n+                       fi->signature(_cp)->as_C_string(),\n+                       b->size(),\n+                       b->alignment(),\n+                       \"INLINED\");\n+      break;\n+    }\n+    case LayoutRawBlock::RESERVED: {\n+      output->print_cr(\" @%d %d\/- %s\",\n+                       b->offset(),\n+                       b->size(),\n+                       \"RESERVED\");\n+      break;\n+    }\n+    case LayoutRawBlock::INHERITED: {\n+      assert(!is_static, \"Static fields are not inherited in layouts\");\n+      assert(super != NULL, \"super klass must be provided to retrieve inherited fields info\");\n+      bool found = false;\n+      const InstanceKlass* ik = super;\n+      while (!found && ik != NULL) {\n+        for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+          if (fs.offset() == b->offset()) {\n+            output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                b->offset(),\n+                fs.name()->as_C_string(),\n+                fs.signature()->as_C_string(),\n+                b->size(),\n+                b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla\n+                \"INHERITED\");\n+            found = true;\n+            break;\n@@ -480,2 +516,1 @@\n-          ik = ik->java_super();\n-        break;\n+        ik = ik->java_super();\n@@ -484,12 +519,14 @@\n-      case LayoutRawBlock::EMPTY:\n-        output->print_cr(\" @%d %d\/1 %s\",\n-                         b->offset(),\n-                         b->size(),\n-                        \"EMPTY\");\n-        break;\n-      case LayoutRawBlock::PADDING:\n-        output->print_cr(\" @%d %d\/1 %s\",\n-                         b->offset(),\n-                         b->size(),\n-                        \"PADDING\");\n-        break;\n+      break;\n+    }\n+    case LayoutRawBlock::EMPTY:\n+      output->print_cr(\" @%d %d\/1 %s\",\n+                       b->offset(),\n+                       b->size(),\n+                       \"EMPTY\");\n+      break;\n+    case LayoutRawBlock::PADDING:\n+      output->print_cr(\" @%d %d\/1 %s\",\n+                       b->offset(),\n+                       b->size(),\n+                       \"PADDING\");\n+      break;\n@@ -502,1 +539,2 @@\n-      Array<u2>* fields, bool is_contended, FieldLayoutInfo* info) :\n+                                       Array<u2>* fields, bool is_contended, bool is_inline_type,\n+                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses) :\n@@ -508,0 +546,1 @@\n+  _inline_type_field_klasses(inline_type_field_klasses),\n@@ -515,0 +554,2 @@\n+  _first_field_offset(-1),\n+  _exact_size_in_bytes(-1),\n@@ -516,2 +557,7 @@\n-  _is_contended(is_contended) {}\n-\n+  _has_inline_type_fields(false),\n+  _is_contended(is_contended),\n+  _is_inline_type(is_inline_type),\n+  _has_flattening_information(is_inline_type),\n+  _has_nonatomic_values(false),\n+  _atomic_field_count(0)\n+ {}\n@@ -544,1 +590,1 @@\n-\/\/ Field sorting for regular classes:\n+\/\/ Field sorting for regular (non-inline) classes:\n@@ -549,0 +595,1 @@\n+\/\/   - field flattening decisions are taken in this method\n@@ -556,0 +603,1 @@\n+      _atomic_field_count++;  \/\/ we might decrement this\n@@ -571,13 +619,19 @@\n-      case T_BYTE:\n-      case T_CHAR:\n-      case T_DOUBLE:\n-      case T_FLOAT:\n-      case T_INT:\n-      case T_LONG:\n-      case T_SHORT:\n-      case T_BOOLEAN:\n-        group->add_primitive_field(fs, type);\n-        break;\n-      case T_OBJECT:\n-      case T_ARRAY:\n-        if (group != _static_fields) _nonstatic_oopmap_count++;\n+    case T_BYTE:\n+    case T_CHAR:\n+    case T_DOUBLE:\n+    case T_FLOAT:\n+    case T_INT:\n+    case T_LONG:\n+    case T_SHORT:\n+    case T_BOOLEAN:\n+      group->add_primitive_field(fs, type);\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY:\n+      if (group != _static_fields) _nonstatic_oopmap_count++;\n+      group->add_oop_field(fs);\n+      break;\n+    case T_PRIMITIVE_OBJECT:\n+      _has_inline_type_fields = true;\n+      if (group == _static_fields) {\n+        \/\/ static fields are never inlined\n@@ -585,3 +639,34 @@\n-        break;\n-      default:\n-        fatal(\"Something wrong?\");\n+      } else {\n+        _has_flattening_information = true;\n+        \/\/ Flattening decision to be taken here\n+        \/\/ This code assumes all verification already have been performed\n+        \/\/ (field's type has been loaded and it is an inline klass)\n+        JavaThread* THREAD = JavaThread::current();\n+        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+        assert(klass != NULL, \"Sanity check\");\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+        if (vk->is_naturally_atomic()) {\n+          too_atomic_to_flatten = false;\n+          \/\/too_volatile_to_flatten = false; \/\/FIXME\n+          \/\/ volatile fields are currently never inlined, this could change in the future\n+        }\n+        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+          group->add_inlined_field(fs, vk);\n+          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+          fs.set_inlined(true);\n+          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+            _has_nonatomic_values = true;\n+            _atomic_field_count--;  \/\/ every other field is atomic but this one\n+          }\n+        } else {\n+          _nonstatic_oopmap_count++;\n+          group->add_oop_field(fs);\n+        }\n+      }\n+      break;\n+    default:\n+      fatal(\"Something wrong?\");\n@@ -599,0 +684,103 @@\n+\/* Field sorting for inline classes:\n+ *   - because inline classes are immutable, the @Contended annotation is ignored\n+ *     when computing their layout (with only read operation, there's no false\n+ *     sharing issue)\n+ *   - this method also records the alignment of the field with the most\n+ *     constraining alignment, this value is then used as the alignment\n+ *     constraint when flattening this inline type into another container\n+ *   - field flattening decisions are taken in this method (those decisions are\n+ *     currently only based in the size of the fields to be inlined, the size\n+ *     of the resulting instance is not considered)\n+ *\/\n+void FieldLayoutBuilder::inline_class_field_sorting(TRAPS) {\n+  assert(_is_inline_type, \"Should only be used for inline classes\");\n+  int alignment = 1;\n+  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+    FieldGroup* group = NULL;\n+    int field_alignment = 1;\n+    if (fs.access_flags().is_static()) {\n+      group = _static_fields;\n+    } else {\n+      _has_nonstatic_fields = true;\n+      _atomic_field_count++;  \/\/ we might decrement this\n+      group = _root_group;\n+    }\n+    assert(group != NULL, \"invariant\");\n+    BasicType type = Signature::basic_type(fs.signature());\n+    switch(type) {\n+    case T_BYTE:\n+    case T_CHAR:\n+    case T_DOUBLE:\n+    case T_FLOAT:\n+    case T_INT:\n+    case T_LONG:\n+    case T_SHORT:\n+    case T_BOOLEAN:\n+      if (group != _static_fields) {\n+        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n+      }\n+      group->add_primitive_field(fs, type);\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY:\n+      if (group != _static_fields) {\n+        _nonstatic_oopmap_count++;\n+        field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+      }\n+      group->add_oop_field(fs);\n+      break;\n+    case T_PRIMITIVE_OBJECT: {\n+\/\/      fs.set_inline(true);\n+      _has_inline_type_fields = true;\n+      if (group == _static_fields) {\n+        \/\/ static fields are never inlined\n+        group->add_oop_field(fs);\n+      } else {\n+        \/\/ Flattening decision to be taken here\n+        \/\/ This code assumes all verifications have already been performed\n+        \/\/ (field's type has been loaded and it is an inline klass)\n+        JavaThread* THREAD = JavaThread::current();\n+        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+        assert(klass != NULL, \"Sanity check\");\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+        if (vk->is_naturally_atomic()) {\n+          too_atomic_to_flatten = false;\n+          \/\/too_volatile_to_flatten = false; \/\/FIXME\n+          \/\/ volatile fields are currently never inlined, this could change in the future\n+        }\n+        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+          group->add_inlined_field(fs, vk);\n+          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+          field_alignment = vk->get_alignment();\n+          fs.set_inlined(true);\n+          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+            _has_nonatomic_values = true;\n+            _atomic_field_count--;  \/\/ every other field is atomic but this one\n+          }\n+        } else {\n+          _nonstatic_oopmap_count++;\n+          field_alignment = type2aelembytes(T_OBJECT);\n+          group->add_oop_field(fs);\n+        }\n+      }\n+      break;\n+    }\n+    default:\n+      fatal(\"Unexpected BasicType\");\n+    }\n+    if (!fs.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n+  }\n+  _alignment = alignment;\n+  if (!_has_nonstatic_fields) {\n+    \/\/ There are a number of fixes required throughout the type system and JIT\n+    Exceptions::fthrow(THREAD_AND_LOCATION,\n+                       vmSymbols::java_lang_ClassFormatError(),\n+                       \"Value Types do not support zero instance size yet\");\n+    return;\n+  }\n+}\n+\n@@ -606,5 +794,7 @@\n-\/\/ Computation of regular classes layout is an evolution of the previous default layout\n-\/\/ (FieldAllocationStyle 1):\n-\/\/   - primitive fields are allocated first (from the biggest to the smallest)\n-\/\/   - then oop fields are allocated, either in existing gaps or at the end of\n-\/\/     the layout\n+\/* Computation of regular classes layout is an evolution of the previous default layout\n+ * (FieldAllocationStyle 1):\n+ *   - primitive fields (both primitive types and flattened inline types) are allocated\n+ *     first, from the biggest to the smallest\n+ *   - then oop fields are allocated (to increase chances to have contiguous oops and\n+ *     a simpler oopmap).\n+ *\/\n@@ -615,1 +805,0 @@\n-\n@@ -623,1 +812,2 @@\n-  _layout->add(_root_group->primitive_fields());\n+  _layout->add(_root_group->big_primitive_fields());\n+  _layout->add(_root_group->small_primitive_fields());\n@@ -631,1 +821,2 @@\n-      _layout->add(cg->primitive_fields(), start);\n+      _layout->add(cg->big_primitive_fields());\n+      _layout->add(cg->small_primitive_fields(), start);\n@@ -640,0 +831,4 @@\n+  \/\/ Warning: IntanceMirrorKlass expects static oops to be allocated first\n+  _static_layout->add_contiguously(_static_fields->oop_fields());\n+  _static_layout->add(_static_fields->big_primitive_fields());\n+  _static_layout->add(_static_fields->small_primitive_fields());\n@@ -641,2 +836,49 @@\n-  _static_layout->add_contiguously(this->_static_fields->oop_fields());\n-  _static_layout->add(this->_static_fields->primitive_fields());\n+  epilogue();\n+}\n+\n+\/* Computation of inline classes has a slightly different strategy than for\n+ * regular classes. Regular classes have their oop fields allocated at the end\n+ * of the layout to increase GC performances. Unfortunately, this strategy\n+ * increases the number of empty slots inside an instance. Because the purpose\n+ * of inline classes is to be embedded into other containers, it is critical\n+ * to keep their size as small as possible. For this reason, the allocation\n+ * strategy is:\n+ *   - big primitive fields (primitive types and flattened inline type smaller\n+ *     than an oop) are allocated first (from the biggest to the smallest)\n+ *   - then oop fields\n+ *   - then small primitive fields (from the biggest to the smallest)\n+ *\/\n+void FieldLayoutBuilder::compute_inline_class_layout(TRAPS) {\n+  prologue();\n+  inline_class_field_sorting(CHECK);\n+  \/\/ Inline types are not polymorphic, so they cannot inherit fields.\n+  \/\/ By consequence, at this stage, the layout must be composed of a RESERVED\n+  \/\/ block, followed by an EMPTY block.\n+  assert(_layout->start()->kind() == LayoutRawBlock::RESERVED, \"Unexpected\");\n+  assert(_layout->start()->next_block()->kind() == LayoutRawBlock::EMPTY, \"Unexpected\");\n+  LayoutRawBlock* first_empty = _layout->start()->next_block();\n+  if (first_empty->offset() % _alignment != 0) {\n+    LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, _alignment - (first_empty->offset() % _alignment));\n+    _layout->insert(first_empty, padding);\n+    _layout->set_start(padding->next_block());\n+  }\n+\n+  _layout->add(_root_group->big_primitive_fields());\n+  _layout->add(_root_group->oop_fields());\n+  _layout->add(_root_group->small_primitive_fields());\n+\n+  LayoutRawBlock* first_field = _layout->first_field_block();\n+   if (first_field != NULL) {\n+     _first_field_offset = _layout->first_field_block()->offset();\n+     _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+   } else {\n+     \/\/ special case for empty value types\n+     _first_field_offset = _layout->blocks()->size();\n+     _exact_size_in_bytes = 0;\n+   }\n+  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+\n+  \/\/ Warning:: InstanceMirrorKlass expects static oops to be allocated first\n+  _static_layout->add_contiguously(_static_fields->oop_fields());\n+  _static_layout->add(_static_fields->big_primitive_fields());\n+  _static_layout->add(_static_fields->small_primitive_fields());\n@@ -647,0 +889,37 @@\n+void FieldLayoutBuilder::add_inlined_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,\n+                InlineKlass* vklass, int offset) {\n+  int diff = offset - vklass->first_field_offset();\n+  const OopMapBlock* map = vklass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* last_map = map + vklass->nonstatic_oop_map_count();\n+  while (map < last_map) {\n+    nonstatic_oop_maps->add(map->offset() + diff, map->count());\n+    map++;\n+  }\n+}\n+\n+void FieldLayoutBuilder::register_embedded_oops_from_list(OopMapBlocksBuilder* nonstatic_oop_maps, GrowableArray<LayoutRawBlock*>* list) {\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      LayoutRawBlock* f = list->at(i);\n+      if (f->kind() == LayoutRawBlock::INLINED) {\n+        InlineKlass* vk = f->inline_klass();\n+        assert(vk != NULL, \"Should have been initialized\");\n+        if (vk->contains_oops()) {\n+          add_inlined_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void FieldLayoutBuilder::register_embedded_oops(OopMapBlocksBuilder* nonstatic_oop_maps, FieldGroup* group) {\n+  if (group->oop_fields() != NULL) {\n+    for (int i = 0; i < group->oop_fields()->length(); i++) {\n+      LayoutRawBlock* b = group->oop_fields()->at(i);\n+      nonstatic_oop_maps->add(b->offset(), 1);\n+    }\n+  }\n+  register_embedded_oops_from_list(nonstatic_oop_maps, group->big_primitive_fields());\n+  register_embedded_oops_from_list(nonstatic_oop_maps, group->small_primitive_fields());\n+}\n+\n@@ -651,1 +930,0 @@\n-\n@@ -658,8 +936,1 @@\n-\n-  if (_root_group->oop_fields() != NULL) {\n-    for (int i = 0; i < _root_group->oop_fields()->length(); i++) {\n-      LayoutRawBlock* b = _root_group->oop_fields()->at(i);\n-      nonstatic_oop_maps->add(b->offset(), 1);\n-    }\n-  }\n-\n+  register_embedded_oops(nonstatic_oop_maps, _root_group);\n@@ -671,1 +942,1 @@\n-        nonstatic_oop_maps->add(cg->oop_fields()->at(0)->offset(), cg->oop_count());\n+        register_embedded_oops(nonstatic_oop_maps, cg);\n@@ -675,1 +946,0 @@\n-\n@@ -691,2 +961,16 @@\n-\n-  if (PrintFieldLayout) {\n+  _info->_has_inline_fields = _has_inline_type_fields;\n+\n+  \/\/ An inline type is naturally atomic if it has just one field, and\n+  \/\/ that field is simple enough.\n+  _info->_is_naturally_atomic = (_is_inline_type &&\n+                                 (_atomic_field_count <= 1) &&\n+                                 !_has_nonatomic_values &&\n+                                 _contended_groups.is_empty());\n+  \/\/ This may be too restrictive, since if all the fields fit in 64\n+  \/\/ bits we could make the decision to align instances of this class\n+  \/\/ to 64-bit boundaries, and load and store them as single words.\n+  \/\/ And on machines which supported larger atomics we could similarly\n+  \/\/ allow larger values to be atomic, if properly aligned.\n+\n+\n+  if (PrintFieldLayout || (PrintInlineLayout && _has_flattening_information)) {\n@@ -700,0 +984,5 @@\n+    if (_is_inline_type) {\n+      tty->print_cr(\"First field offset = %d\", _first_field_offset);\n+      tty->print_cr(\"Alignment = %d bytes\", _alignment);\n+      tty->print_cr(\"Exact size = %d bytes\", _exact_size_in_bytes);\n+    }\n@@ -704,2 +993,6 @@\n-void FieldLayoutBuilder::build_layout() {\n-  compute_regular_layout();\n+void FieldLayoutBuilder::build_layout(TRAPS) {\n+  if (_is_inline_type) {\n+    compute_inline_class_layout(CHECK);\n+  } else {\n+    compute_regular_layout();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":425,"deletions":132,"binary":false,"changes":557,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -55,1 +57,1 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.inline.hpp\"\n@@ -783,0 +785,2 @@\n+int java_lang_Class::_primary_mirror_offset;\n+int java_lang_Class::_secondary_mirror_offset;\n@@ -1006,1 +1010,6 @@\n-      if (k->is_typeArray_klass()) {\n+      if (k->is_flatArray_klass()) {\n+        Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n+        assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n+      } else if (k->is_typeArray_klass()) {\n@@ -1013,1 +1022,6 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        oop comp_oop = element_klass->java_mirror();\n+        if (element_klass->is_inline_klass()) {\n+          InlineKlass* ik = InlineKlass::cast(element_klass);\n+          comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        }\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1053,0 +1067,6 @@\n+\n+    if (k->is_inline_klass()) {\n+      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n+      set_primary_mirror(mirror(), mirror());\n+      set_secondary_mirror(mirror(), secondary_mirror);\n+    }\n@@ -1058,0 +1078,19 @@\n+\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n+\/\/ instance with the same value as the primary mirror\n+oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n+  assert(k->is_inline_klass(), \"primitive class\");\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n+  Handle secondary_mirror(THREAD, mirror_oop);\n+\n+  java_lang_Class::set_klass(secondary_mirror(), k);\n+  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n+\n+  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n+  set_class_loader(secondary_mirror(), class_loader(mirror()));\n+  \/\/ ## handle if java.base is not yet defined\n+  set_module(secondary_mirror(), module(mirror()));\n+  set_primary_mirror(secondary_mirror(), mirror());\n+  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n+  return secondary_mirror();\n+}\n@@ -1105,0 +1144,1 @@\n+      case T_PRIMITIVE_OBJECT:\n@@ -1181,0 +1221,6 @@\n+  if (k->is_inline_klass()) {\n+    \/\/ Inline types have a primary mirror and a secondary mirror. Don't handle this for now. TODO:CDS\n+    k->clear_java_mirror_handle();\n+    return NULL;\n+  }\n+\n@@ -1342,0 +1388,20 @@\n+oop java_lang_Class::primary_mirror(oop java_class) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_primary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_primary_mirror_offset, mirror);\n+}\n+\n+oop java_lang_Class::secondary_mirror(oop java_class) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_secondary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n+}\n+\n@@ -1426,0 +1492,1 @@\n+  bool is_Q_descriptor = false;\n@@ -1431,0 +1498,1 @@\n+    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1437,1 +1505,3 @@\n-  if (is_instance)  st->print(\"L\");\n+  if (is_instance)  {\n+    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n+  }\n@@ -1458,2 +1528,7 @@\n-      const char* sigstr = k->signature_name();\n-      int         siglen = (int) strlen(sigstr);\n+      const char* sigstr;\n+      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n+        sigstr = InlineKlass::cast(k)->val_signature_name();\n+      } else {\n+        sigstr = k->signature_name();\n+      }\n+      int siglen = (int) strlen(sigstr);\n@@ -1539,0 +1614,2 @@\n+  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n+  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n@@ -2738,1 +2815,1 @@\n-      if (method->name() == vmSymbols::object_initializer_name() &&\n+      if (method->is_object_constructor() &&\n@@ -4332,1 +4409,1 @@\n-  return (flags(mname) & (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) > 0;\n+  return (flags(mname) & (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) > 0;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":85,"deletions":8,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -231,0 +231,3 @@\n+  static int _primary_mirror_offset;\n+  static int _secondary_mirror_offset;\n+\n@@ -244,0 +247,3 @@\n+  static void set_primary_mirror(oop java_class, oop comp_mirror);\n+  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n+\n@@ -256,0 +262,1 @@\n+  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -288,0 +295,3 @@\n+  static int component_mirror_offset()     { CHECK_INIT(_component_mirror_offset); }\n+  static int primary_mirror_offset()       { CHECK_INIT(_primary_mirror_offset); }\n+  static int secondary_mirror_offset()     { CHECK_INIT(_secondary_mirror_offset); }\n@@ -295,0 +305,5 @@\n+  static oop  primary_mirror(oop java_class);\n+  static oop  secondary_mirror(oop java_class);\n+  static bool is_primary_mirror(oop java_class);\n+  static bool is_secondary_mirror(oop java_class);\n+\n@@ -300,2 +315,0 @@\n-  static int component_mirror_offset() { return _component_mirror_offset; }\n-\n@@ -1289,1 +1302,1 @@\n-    MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ constructor\n+    MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ constructor\n@@ -1294,0 +1307,1 @@\n+    MN_FLATTENED             = 0x00400000, \/\/ flattened field\n@@ -1833,1 +1847,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+\/\/ For INLINE_FIELD, set when loading inline type fields for\n+\/\/ class circularity checking.\n@@ -104,0 +106,3 @@\n+    case PlaceholderTable::PRIMITIVE_OBJECT_FIELD:\n+       queuehead = _inlineTypeFieldQ;\n+       break;\n@@ -120,0 +125,3 @@\n+    case PlaceholderTable::PRIMITIVE_OBJECT_FIELD:\n+       _inlineTypeFieldQ = seenthread;\n+       break;\n@@ -234,0 +242,1 @@\n+  case PlaceholderTable::PRIMITIVE_OBJECT_FIELD: return \"PRIMITIVE_OBJECT_FIELD\";\n@@ -297,1 +306,2 @@\n-        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n+        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)\n+        && (probe->inlineTypeFieldQ() == NULL)) {\n@@ -333,0 +343,3 @@\n+  st->print(\"inlineTypeFieldQ threads:\");\n+  inlineTypeFieldQ()->print_action_queue(st);\n+  st->cr();\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -70,0 +71,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -77,0 +79,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -330,1 +333,1 @@\n-      \/\/ Ignore wrapping L and ;.\n+      \/\/ Ignore wrapping L and ; (and Q and ; for value types).\n@@ -359,1 +362,8 @@\n-      k = k->array_klass(ndims, CHECK_NULL);\n+      if (class_name->is_Q_array_signature()) {\n+        if (!k->is_inline_klass()) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n+        }\n+        k = InlineKlass::cast(k)->value_array_klass(ndims, CHECK_NULL);\n+      } else {\n+        k = k->array_klass(ndims, CHECK_NULL);\n+      }\n@@ -486,0 +496,43 @@\n+Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,\n+                                                           Handle class_loader,\n+                                                           Handle protection_domain,\n+                                                           bool throw_error,\n+                                                           TRAPS) {\n+  Symbol* class_name = fs->signature()->fundamental_name(THREAD);\n+  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n+  ClassLoaderData* loader_data = class_loader_data(class_loader);\n+  bool throw_circularity_error = false;\n+  PlaceholderEntry* oldprobe;\n+\n+  {\n+    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    oldprobe = PlaceholderTable::get_entry(class_name, loader_data);\n+    if (oldprobe != NULL &&\n+      oldprobe->check_seen_thread(THREAD, PlaceholderTable::PRIMITIVE_OBJECT_FIELD)) {\n+      throw_circularity_error = true;\n+\n+    } else {\n+      PlaceholderTable::find_and_add(class_name, loader_data,\n+                                   PlaceholderTable::PRIMITIVE_OBJECT_FIELD, NULL, THREAD);\n+    }\n+  }\n+\n+  Klass* klass = NULL;\n+  if (!throw_circularity_error) {\n+    klass = SystemDictionary::resolve_or_fail(class_name, class_loader,\n+                                               protection_domain, true, THREAD);\n+  } else {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name->as_C_string());\n+  }\n+\n+  {\n+    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    PlaceholderTable::find_and_remove(class_name, loader_data,\n+                                      PlaceholderTable::PRIMITIVE_OBJECT_FIELD, THREAD);\n+  }\n+\n+  class_name->decrement_refcount();\n+  return klass;\n+}\n+\n@@ -634,1 +687,1 @@\n-         !Signature::has_envelope(name), \"invalid class name\");\n+         !Signature::has_envelope(name), \"invalid class name: %s\", name == NULL ? \"NULL\" : name->as_C_string());\n@@ -845,1 +898,1 @@\n-    if (t != T_OBJECT) {\n+    if (t != T_OBJECT && t != T_PRIMITIVE_OBJECT) {\n@@ -851,1 +904,5 @@\n-      k = k->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        k = InlineKlass::cast(k)->value_array_klass_or_null(ndims);\n+      } else {\n+        k = k->array_klass_or_null(ndims);\n+      }\n@@ -1207,0 +1264,18 @@\n+\n+  if (ik->has_inline_type_fields()) {\n+    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+        if (!fs.access_flags().is_static()) {\n+          \/\/ Pre-load inline class\n+          Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+            class_loader, protection_domain, true, CHECK_NULL);\n+          Klass* k = ik->get_inline_type_field_klass_or_null(fs.index());\n+          if (real_k != k) {\n+            \/\/ oops, the app has substituted a different version of k!\n+            return NULL;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1242,0 +1317,1 @@\n+\n@@ -1830,1 +1906,1 @@\n-    if (t != T_OBJECT) {\n+    if (t != T_OBJECT && t != T_PRIMITIVE_OBJECT) {\n@@ -1838,1 +1914,5 @@\n-      klass = klass->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        klass = InlineKlass::cast(klass)->value_array_klass_or_null(ndims);\n+      } else {\n+        klass = klass->array_klass_or_null(ndims);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":87,"deletions":7,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#define INLINE_TYPE_MAJOR_VERSION                       56\n@@ -278,1 +279,1 @@\n-    \/\/ We need to skip the following four for bootstraping\n+    \/\/ We need to skip the following four for bootstrapping\n@@ -501,0 +502,7 @@\n+    case WRONG_INLINE_TYPE:\n+      ss->print(\"Type \");\n+      _type.details(ss);\n+      ss->print(\" and type \");\n+      _expected.details(ss);\n+      ss->print(\" must be identical inline types.\");\n+      break;\n@@ -595,0 +603,8 @@\n+VerificationType reference_or_inline_type(InstanceKlass* klass) {\n+  if (klass->is_inline_klass()) {\n+    return VerificationType::inline_type(klass->name());\n+  } else {\n+    return VerificationType::reference_type(klass->name());\n+  }\n+}\n+\n@@ -598,1 +614,1 @@\n-  _this_type = VerificationType::reference_type(klass->name());\n+  _this_type = reference_or_inline_type(klass);\n@@ -1038,1 +1054,1 @@\n-          if (!atype.is_reference_array()) {\n+          if (!atype.is_nonscalar_array()) {\n@@ -1211,1 +1227,1 @@\n-          if (!atype.is_reference_array()) {\n+          if (!atype.is_nonscalar_array()) {\n@@ -1611,1 +1627,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1616,1 +1632,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1667,1 +1683,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1679,1 +1695,1 @@\n-          if (_method->name() == vmSymbols::object_initializer_name() &&\n+          if (_method->is_object_constructor() &&\n@@ -1699,0 +1715,11 @@\n+        case Bytecodes::_withfield :\n+          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n+            class_format_error(\n+              \"withfield not supported by this class file version (%d.%d), class %s\",\n+              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n+            return;\n+          }\n+          \/\/ pass FALSE, operand can't be an array type for withfield.\n+          verify_field_instructions(\n+            &bcs, &current_frame, cp, false, CHECK_VERIFY(this));\n+          no_control_flow = false; break;\n@@ -1702,4 +1729,0 @@\n-          verify_invoke_instructions(\n-            &bcs, code_length, &current_frame, (bci >= ex_min && bci < ex_max),\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n-          no_control_flow = false; break;\n@@ -1710,1 +1733,1 @@\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n+            &this_uninit, cp, &stackmap_table, CHECK_VERIFY(this));\n@@ -1728,0 +1751,22 @@\n+        case Bytecodes::_aconst_init :\n+        {\n+          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n+            class_format_error(\n+              \"aconst_init not supported by this class file version (%d.%d), class %s\",\n+              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n+            return;\n+          }\n+          index = bcs.get_index_u2();\n+          verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));\n+          VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));\n+          if (!ref_type.is_object()) {\n+            verify_error(ErrorContext::bad_type(bci,\n+                TypeOrigin::cp(index, ref_type)),\n+                \"Illegal aconst_init instruction\");\n+            return;\n+          }\n+          VerificationType inline_type =\n+            VerificationType::change_ref_to_inline_type(ref_type);\n+          current_frame.push_stack(inline_type, CHECK_VERIFY(this));\n+          no_control_flow = false; break;\n+        }\n@@ -1768,3 +1813,3 @@\n-        case Bytecodes::_monitorexit :\n-          current_frame.pop_stack(\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+        case Bytecodes::_monitorexit : {\n+          VerificationType ref = current_frame.pop_stack(\n+            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -1772,0 +1817,1 @@\n+        }\n@@ -2036,0 +2082,1 @@\n+\n@@ -2150,1 +2197,1 @@\n-            | (1 << JVM_CONSTANT_String)  | (1 << JVM_CONSTANT_Class)\n+            | (1 << JVM_CONSTANT_String) | (1 << JVM_CONSTANT_Class)\n@@ -2325,1 +2372,1 @@\n-    (!allow_arrays || !ref_class_type.is_array())) {\n+      (!allow_arrays || !ref_class_type.is_array())) {\n@@ -2332,0 +2379,1 @@\n+\n@@ -2361,0 +2409,11 @@\n+    case Bytecodes::_withfield: {\n+      for (int i = n - 1; i >= 0; i--) {\n+        current_frame->pop_stack(field_type[i], CHECK_VERIFY(this));\n+      }\n+      \/\/ Check that the receiver is a subtype of the referenced class.\n+      current_frame->pop_stack(target_class_type, CHECK_VERIFY(this));\n+      VerificationType target_inline_type =\n+        VerificationType::change_ref_to_inline_type(target_class_type);\n+      current_frame->push_stack(target_inline_type, CHECK_VERIFY(this));\n+      break;\n+    }\n@@ -2782,1 +2841,1 @@\n-    bool in_try_block, bool *this_uninit, VerificationType return_type,\n+    bool in_try_block, bool *this_uninit,\n@@ -2814,1 +2873,1 @@\n-  \/\/ Get referenced class type\n+  \/\/ Get referenced class\n@@ -2880,3 +2939,7 @@\n-    \/\/ Make sure <init> can only be invoked by invokespecial\n-    if (opcode != Bytecodes::_invokespecial ||\n-        method_name != vmSymbols::object_initializer_name()) {\n+    \/\/ Make sure:\n+    \/\/   <init> can only be invoked by invokespecial.\n+    \/\/   <vnew> can only be invoked by invokestatic.\n+    if (!((opcode == Bytecodes::_invokestatic &&\n+           method_name == vmSymbols::inline_factory_name()) ||\n+         (opcode == Bytecodes::_invokespecial &&\n+          method_name == vmSymbols::object_initializer_name()))) {\n@@ -2890,1 +2953,1 @@\n-                  current_class()->super()->name()))) {\n+                  current_class()->super()->name()))) { \/\/ super() can never be an inline_type.\n@@ -2975,3 +3038,1 @@\n-      \/\/ <init> method must have a void return type\n-      \/* Unreachable?  Class file parser verifies that methods with '<' have\n-       * void return *\/\n+      \/\/ an <init> method must have a void return type\n@@ -2990,0 +3051,7 @@\n+  } else { \/\/ no return type\n+    \/\/ <vnew> method may not have a void return type\n+    if (method_name == vmSymbols::inline_factory_name()) {\n+      verify_error(ErrorContext::bad_code(bci),\n+          \"Return type must be non-void in <vnew> static factory method\");\n+      return;\n+    }\n@@ -3037,1 +3105,2 @@\n-    \/\/ add one dimension to component with 'L' prepended and ';' postpended.\n+    char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_PRIMITIVE_OBJECT : JVM_SIGNATURE_CLASS;\n+    \/\/ add one dimension to component with 'L' or 'Q' prepended and ';' appended.\n@@ -3041,1 +3110,1 @@\n-                         JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);\n+                         JVM_SIGNATURE_ARRAY, Q_or_L, component_name);\n@@ -3083,1 +3152,1 @@\n-    index, VerificationType::reference_check(), CHECK_VERIFY(this));\n+    index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n@@ -3120,1 +3189,1 @@\n-    VerificationType::reference_check(), CHECK_VERIFY(this));\n+    VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":100,"deletions":31,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -249,0 +249,4 @@\n+  case vmIntrinsics::_asPrimaryType:\n+  case vmIntrinsics::_asPrimaryTypeArg:\n+  case vmIntrinsics::_asValueType:\n+  case vmIntrinsics::_asValueTypeArg:\n@@ -319,0 +323,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:\n+  case vmIntrinsics::_finishPrivateBuffer:\n@@ -328,0 +334,1 @@\n+  case vmIntrinsics::_getValue:\n@@ -337,0 +344,1 @@\n+  case vmIntrinsics::_putValue:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -302,0 +302,6 @@\n+  do_intrinsic(_asPrimaryType,            java_lang_Class,        asPrimaryType_name, void_class_signature,      F_R)   \\\n+  do_intrinsic(_asPrimaryTypeArg,         jdk_internal_value_PrimitiveClass, asPrimaryType_name, class_class_signature, F_S) \\\n+   do_name(     asPrimaryType_name,                              \"asPrimaryType\")                                       \\\n+  do_intrinsic(_asValueType,              java_lang_Class,        asValueType_name, void_class_signature,        F_R)   \\\n+  do_intrinsic(_asValueTypeArg,           jdk_internal_value_PrimitiveClass, asValueType_name,   class_class_signature, F_S) \\\n+   do_name(     asValueType_name,                                \"asValueType\")                                         \\\n@@ -652,0 +658,2 @@\n+  do_signature(getValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;)Ljava\/lang\/Object;\")                   \\\n+  do_signature(putValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;Ljava\/lang\/Object;)V\")                  \\\n@@ -662,0 +670,3 @@\n+  do_name(getValue_name,\"getValue\")             do_name(putValue_name,\"putValue\")                                       \\\n+  do_name(makePrivateBuffer_name,\"makePrivateBuffer\")                                                                   \\\n+  do_name(finishPrivateBuffer_name,\"finishPrivateBuffer\")                                                               \\\n@@ -672,0 +683,1 @@\n+  do_intrinsic(_getValue,           jdk_internal_misc_Unsafe,     getValue_name, getValue_signature,             F_RN)  \\\n@@ -681,0 +693,4 @@\n+  do_intrinsic(_putValue,           jdk_internal_misc_Unsafe,     putValue_name, putValue_signature,             F_RN)  \\\n+                                                                                                                        \\\n+  do_intrinsic(_makePrivateBuffer,  jdk_internal_misc_Unsafe,     makePrivateBuffer_name, object_object_signature, F_RN)   \\\n+  do_intrinsic(_finishPrivateBuffer,  jdk_internal_misc_Unsafe,   finishPrivateBuffer_name, object_object_signature, F_RN) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  template(tag_preload,                               \"Preload\")                                  \\\n@@ -392,0 +393,1 @@\n+  template(inline_factory_name,                       \"<vnew>\")                                   \\\n@@ -526,0 +528,2 @@\n+  template(default_value_name,                        \".default\")                                 \\\n+  template(empty_marker_name,                         \".empty\")                                   \\\n@@ -601,0 +605,1 @@\n+  template(class_class_signature,                     \"(Ljava\/lang\/Class;)Ljava\/lang\/Class;\")     \\\n@@ -614,0 +619,1 @@\n+  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\") \\\n@@ -755,0 +761,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n@@ -781,0 +789,5 @@\n+  template(java_lang_runtime_ValueObjectMethods,            \"java\/lang\/runtime\/ValueObjectMethods\")               \\\n+  template(isSubstitutable_name,                            \"isSubstitutable\")                                    \\\n+  template(valueObjectHashCode_name,                        \"valueObjectHashCode\")                                \\\n+  template(jdk_internal_value_PrimitiveClass,               \"jdk\/internal\/value\/PrimitiveClass\")                  \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -270,2 +270,2 @@\n-BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)\n-  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)\n+BufferBlob::BufferBlob(const char* name, int header_size, int size, CodeBuffer* cb)\n+  : RuntimeBlob(name, cb, header_size, size, CodeOffsets::frame_never_safe, 0, NULL)\n@@ -282,1 +282,1 @@\n-    blob = new (size) BufferBlob(name, size, cb);\n+    blob = new (size) BufferBlob(name, sizeof(BufferBlob), size, cb);\n@@ -298,0 +298,4 @@\n+BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments)\n+  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)\n+{}\n+\n@@ -302,2 +306,2 @@\n-AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :\n-  BufferBlob(\"I2C\/C2I adapters\", size, cb) {\n+AdapterBlob::AdapterBlob(int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+  BufferBlob(\"I2C\/C2I adapters\", size, cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {\n@@ -307,1 +311,1 @@\n-AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {\n+AdapterBlob* AdapterBlob::create(CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) {\n@@ -316,1 +320,1 @@\n-    blob = new (size) AdapterBlob(size, cb);\n+    blob = new (size) AdapterBlob(size, cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);\n@@ -394,0 +398,25 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of BufferedInlineTypeBlob\n+BufferedInlineTypeBlob::BufferedInlineTypeBlob(int size, CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off) :\n+  BufferBlob(\"buffered inline type\", sizeof(BufferedInlineTypeBlob), size, cb),\n+  _pack_fields_off(pack_fields_off),\n+  _pack_fields_jobject_off(pack_fields_jobject_off),\n+  _unpack_fields_off(unpack_fields_off) {\n+  CodeCache::commit(this);\n+}\n+\n+BufferedInlineTypeBlob* BufferedInlineTypeBlob::create(CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  BufferedInlineTypeBlob* blob = NULL;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferedInlineTypeBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) BufferedInlineTypeBlob(size, cb, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  virtual bool is_buffered_inline_type_blob() const   { return false; }\n@@ -399,0 +400,1 @@\n+  friend class BufferedInlineTypeBlob;\n@@ -405,1 +407,2 @@\n-  BufferBlob(const char* name, int size, CodeBuffer* cb);\n+  BufferBlob(const char* name, int header_size, int size, CodeBuffer* cb);\n+  BufferBlob(const char* name, int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments = false);\n@@ -437,1 +440,1 @@\n-  AdapterBlob(int size, CodeBuffer* cb);\n+  AdapterBlob(int size, CodeBuffer* cb, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments = false);\n@@ -441,1 +444,5 @@\n-  static AdapterBlob* create(CodeBuffer* cb);\n+  static AdapterBlob* create(CodeBuffer* cb,\n+                             int frame_complete,\n+                             int frame_size,\n+                             OopMapSet* oop_maps,\n+                             bool caller_must_gc_arguments = false);\n@@ -445,0 +452,2 @@\n+\n+  bool caller_must_gc_arguments(JavaThread* thread) const { return true; }\n@@ -477,0 +486,22 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ BufferedInlineTypeBlob : used for pack\/unpack handlers\n+\n+class BufferedInlineTypeBlob: public BufferBlob {\n+private:\n+  const int _pack_fields_off;\n+  const int _pack_fields_jobject_off;\n+  const int _unpack_fields_off;\n+\n+  BufferedInlineTypeBlob(int size, CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off);\n+\n+public:\n+  \/\/ Creation\n+  static BufferedInlineTypeBlob* create(CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off);\n+\n+  address pack_fields() const { return code_begin() + _pack_fields_off; }\n+  address pack_fields_jobject() const { return code_begin() + _pack_fields_jobject_off; }\n+  address unpack_fields() const { return code_begin() + _unpack_fields_off; }\n+\n+  \/\/ Typing\n+  virtual bool is_buffered_inline_type_blob() const { return true; }\n+};\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  ScopeValue*                _is_init;\n@@ -130,1 +131,1 @@\n-  ObjectValue(int id, ScopeValue* klass)\n+  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = NULL)\n@@ -133,0 +134,1 @@\n+     , _is_init(is_init)\n@@ -142,0 +144,1 @@\n+     , _is_init(NULL)\n@@ -150,0 +153,1 @@\n+  ScopeValue*                 is_init() const           { return _is_init; }\n@@ -155,0 +159,1 @@\n+  bool                        maybe_null() const        { return !_is_init->is_marker(); }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -690,0 +690,6 @@\n+\n+    assert(!method->has_scalarized_args(), \"scalarized native wrappers not supported yet\"); \/\/ for the next 3 fields\n+    _inline_entry_point       = _entry_point;\n+    _verified_inline_entry_point = _verified_entry_point;\n+    _verified_inline_ro_entry_point = _verified_entry_point;\n+\n@@ -873,0 +879,3 @@\n+    _inline_entry_point       = code_begin()         + offsets->value(CodeOffsets::Inline_Entry);\n+    _verified_inline_entry_point = code_begin()      + offsets->value(CodeOffsets::Verified_Inline_Entry);\n+    _verified_inline_ro_entry_point = code_begin()   + offsets->value(CodeOffsets::Verified_Inline_Entry_RO);\n@@ -3001,0 +3010,1 @@\n+  if (pos == inline_entry_point())                                      label = \"[Inline Entry Point]\";\n@@ -3002,0 +3012,2 @@\n+  if (pos == verified_inline_entry_point())                             label = \"[Verified Inline Entry Point]\";\n+  if (pos == verified_inline_ro_entry_point())                          label = \"[Verified Inline Entry Point (RO)]\";\n@@ -3011,0 +3023,10 @@\n+static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {\n+  if (pos == entry) {\n+    stream->bol();\n+    stream->print_cr(\"%s\", label);\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n@@ -3013,33 +3035,12 @@\n-    const char* label = nmethod_section_label(block_begin);\n-    if (label != NULL) {\n-      stream->bol();\n-      stream->print_cr(\"%s\", label);\n-    }\n-  }\n-\n-  if (block_begin == entry_point()) {\n-    Method* m = method();\n-    if (m != NULL) {\n-      stream->print(\"  # \");\n-      m->print_value_on(stream);\n-      stream->cr();\n-    }\n-    if (m != NULL && !is_osr_method()) {\n-      ResourceMark rm;\n-      int sizeargs = m->size_of_parameters();\n-      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);\n-      VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);\n-      {\n-        int sig_index = 0;\n-        if (!m->is_static())\n-          sig_bt[sig_index++] = T_OBJECT; \/\/ 'this'\n-        for (SignatureStream ss(m->signature()); !ss.at_return_type(); ss.next()) {\n-          BasicType t = ss.type();\n-          sig_bt[sig_index++] = t;\n-          if (type2size[t] == 2) {\n-            sig_bt[sig_index++] = T_VOID;\n-          } else {\n-            assert(type2size[t] == 1, \"size is 1 or 2\");\n-          }\n-        }\n-        assert(sig_index == sizeargs, \"\");\n+    int n = 0;\n+    \/\/ Multiple entry points may be at the same position. Print them all.\n+    n += maybe_print_entry_label(stream, block_begin, entry_point(),                    \"[Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             \"[Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),           \"[Verified Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    \"[Verified Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), \"[Verified Inline Entry Point (RO)]\");\n+    if (n == 0) {\n+      const char* label = nmethod_section_label(block_begin);\n+      if (label != NULL) {\n+        stream->bol();\n+        stream->print_cr(\"%s\", label);\n@@ -3047,54 +3048,63 @@\n-      const char* spname = \"sp\"; \/\/ make arch-specific?\n-      intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n-      int stack_slot_offset = this->frame_size() * wordSize;\n-      int tab1 = 14, tab2 = 24;\n-      int sig_index = 0;\n-      int arg_index = (m->is_static() ? 0 : -1);\n-      bool did_old_sp = false;\n-      for (SignatureStream ss(m->signature()); !ss.at_return_type(); ) {\n-        bool at_this = (arg_index == -1);\n-        bool at_old_sp = false;\n-        BasicType t = (at_this ? T_OBJECT : ss.type());\n-        assert(t == sig_bt[sig_index], \"sigs in sync\");\n-        if (at_this)\n-          stream->print(\"  # this: \");\n-        else\n-          stream->print(\"  # parm%d: \", arg_index);\n-        stream->move_to(tab1);\n-        VMReg fst = regs[sig_index].first();\n-        VMReg snd = regs[sig_index].second();\n-        if (fst->is_reg()) {\n-          stream->print(\"%s\", fst->name());\n-          if (snd->is_valid())  {\n-            stream->print(\":%s\", snd->name());\n-          }\n-        } else if (fst->is_stack()) {\n-          int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n-          if (offset == stack_slot_offset)  at_old_sp = true;\n-          stream->print(\"[%s+0x%x]\", spname, offset);\n-        } else {\n-          stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n-        }\n-        stream->print(\" \");\n-        stream->move_to(tab2);\n-        stream->print(\"= \");\n-        if (at_this) {\n-          m->method_holder()->print_value_on(stream);\n-        } else {\n-          bool did_name = false;\n-          if (!at_this && ss.is_reference()) {\n-            Symbol* name = ss.as_symbol();\n-            name->print_value_on(stream);\n-            did_name = true;\n-          }\n-          if (!did_name)\n-            stream->print(\"%s\", type2name(t));\n-        }\n-        if (at_old_sp) {\n-          stream->print(\"  (%s of caller)\", spname);\n-          did_old_sp = true;\n-        }\n-        stream->cr();\n-        sig_index += type2size[t];\n-        arg_index += 1;\n-        if (!at_this)  ss.next();\n+    }\n+  }\n+\n+  Method* m = method();\n+  if (m == NULL || is_osr_method()) {\n+    return;\n+  }\n+\n+  \/\/ Print the name of the method (only once)\n+  address low = MIN4(entry_point(), verified_entry_point(), verified_inline_entry_point(), verified_inline_ro_entry_point());\n+  low = MIN2(low, inline_entry_point());\n+  assert(low != 0, \"sanity\");\n+  if (block_begin == low) {\n+    stream->print(\"  # \");\n+    m->print_value_on(stream);\n+    stream->cr();\n+  }\n+\n+  \/\/ Print the arguments for the 3 types of verified entry points\n+  CompiledEntrySignature ces(m);\n+  ces.compute_calling_conventions();\n+  const GrowableArray<SigEntry>* sig_cc;\n+  const VMRegPair* regs;\n+  if (block_begin == verified_entry_point()) {\n+    sig_cc = &ces.sig_cc();\n+    regs = ces.regs_cc();\n+  } else if (block_begin == verified_inline_entry_point()) {\n+    sig_cc = &ces.sig();\n+    regs = ces.regs();\n+  } else if (block_begin == verified_inline_ro_entry_point()) {\n+    sig_cc = &ces.sig_cc_ro();\n+    regs = ces.regs_cc_ro();\n+  } else {\n+    return;\n+  }\n+\n+  bool has_this = !m->is_static();\n+  if (ces.has_inline_recv() && block_begin == verified_entry_point()) {\n+    \/\/ <this> argument is scalarized for verified_entry_point()\n+    has_this = false;\n+  }\n+  const char* spname = \"sp\"; \/\/ make arch-specific?\n+  int stack_slot_offset = this->frame_size() * wordSize;\n+  int tab1 = 14, tab2 = 24;\n+  int sig_index = 0;\n+  int arg_index = has_this ? -1 : 0;\n+  bool did_old_sp = false;\n+  for (ExtendedSignature sig = ExtendedSignature(sig_cc, SigEntryFilter()); !sig.at_end(); ++sig) {\n+    bool at_this = (arg_index == -1);\n+    bool at_old_sp = false;\n+    BasicType t = (*sig)._bt;\n+    if (at_this) {\n+      stream->print(\"  # this: \");\n+    } else {\n+      stream->print(\"  # parm%d: \", arg_index);\n+    }\n+    stream->move_to(tab1);\n+    VMReg fst = regs[sig_index].first();\n+    VMReg snd = regs[sig_index].second();\n+    if (fst->is_reg()) {\n+      stream->print(\"%s\", fst->name());\n+      if (snd->is_valid())  {\n+        stream->print(\":%s\", snd->name());\n@@ -3102,6 +3112,18 @@\n-      if (!did_old_sp) {\n-        stream->print(\"  # \");\n-        stream->move_to(tab1);\n-        stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n-        stream->print(\"  (%s of caller)\", spname);\n-        stream->cr();\n+    } else if (fst->is_stack()) {\n+      int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n+      if (offset == stack_slot_offset)  at_old_sp = true;\n+      stream->print(\"[%s+0x%x]\", spname, offset);\n+    } else {\n+      stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n+    }\n+    stream->print(\" \");\n+    stream->move_to(tab2);\n+    stream->print(\"= \");\n+    if (at_this) {\n+      m->method_holder()->print_value_on(stream);\n+    } else {\n+      bool did_name = false;\n+      if (is_reference_type(t)) {\n+        Symbol* name = (*sig)._symbol;\n+        name->print_value_on(stream);\n+        did_name = true;\n@@ -3109,0 +3131,2 @@\n+      if (!did_name)\n+        stream->print(\"%s\", type2name(t));\n@@ -3110,0 +3134,14 @@\n+    if (at_old_sp) {\n+      stream->print(\"  (%s of caller)\", spname);\n+      did_old_sp = true;\n+    }\n+    stream->cr();\n+    sig_index += type2size[t];\n+    arg_index += 1;\n+  }\n+  if (!did_old_sp) {\n+    stream->print(\"  # \");\n+    stream->move_to(tab1);\n+    stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n+    stream->print(\"  (%s of caller)\", spname);\n+    stream->cr();\n@@ -3233,1 +3271,1 @@\n-      st->print(\" {reexecute=%d rethrow=%d return_oop=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop());\n+      st->print(\" {reexecute=%d rethrow=%d return_oop=%d return_scalarized=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop(), sd->return_scalarized());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":132,"deletions":94,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/compilerDefinitions.hpp\"\n@@ -197,0 +198,3 @@\n+  address _inline_entry_point;               \/\/ inline type entry point (unpack all inline type args) with class check\n+  address _verified_inline_entry_point;      \/\/ inline type entry point (unpack all inline type args) without class check\n+  address _verified_inline_ro_entry_point;   \/\/ inline type entry point (unpack receiver only) without class check\n@@ -427,2 +431,5 @@\n-  address entry_point() const                     { return _entry_point;             } \/\/ normal entry point\n-  address verified_entry_point() const            { return _verified_entry_point;    } \/\/ if klass is correct\n+  address entry_point() const                     { return _entry_point;             }        \/\/ normal entry point\n+  address verified_entry_point() const            { return _verified_entry_point;    }        \/\/ normal entry point without class check\n+  address inline_entry_point() const              { return _inline_entry_point; }             \/\/ inline type entry point (unpack all inline type args)\n+  address verified_inline_entry_point() const     { return _verified_inline_entry_point; }    \/\/ inline type entry point (unpack all inline type args) without class check\n+  address verified_inline_ro_entry_point() const  { return _verified_inline_ro_entry_point; } \/\/ inline type entry point (only unpack receiver) without class check\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1211,1 +1211,1 @@\n-          if (vfst.method()->is_static_initializer() ||\n+        if (vfst.method()->is_class_initializer() ||\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  assert(bt == T_OBJECT, \"or we shouldn't be here\");\n+  assert(bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT, \"or we shouldn't be here\");\n@@ -713,1 +713,1 @@\n-void G1BarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n+void G1BarrierSetC2::eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const {\n@@ -715,1 +715,1 @@\n-    macro->replace_node(node, macro->zerocon(node->as_Load()->bottom_type()->basic_type()));\n+    igvn->replace_node(node, igvn->zerocon(node->as_Load()->bottom_type()->basic_type()));\n@@ -744,1 +744,1 @@\n-      macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+      igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n@@ -752,18 +752,16 @@\n-        int ind = 1;\n-        if (!this_region->in(ind)->is_IfFalse()) {\n-          ind = 2;\n-        }\n-        if (this_region->in(ind)->is_IfFalse() &&\n-            this_region->in(ind)->in(0)->Opcode() == Op_If) {\n-          Node* bol = this_region->in(ind)->in(0)->in(1);\n-          assert(bol->is_Bool(), \"\");\n-          cmpx = bol->in(1);\n-          if (bol->as_Bool()->_test._test == BoolTest::ne &&\n-              cmpx->is_Cmp() && cmpx->in(2) == macro->intcon(0) &&\n-              cmpx->in(1)->is_Load()) {\n-            Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n-            const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-            if (adr->is_AddP() && adr->in(AddPNode::Base) == macro->top() &&\n-                adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n-                adr->in(AddPNode::Offset) == macro->MakeConX(marking_offset)) {\n-              macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+        for (int i = 1; i < 3; ++i) {\n+          if (this_region->in(i)->is_IfFalse() &&\n+              this_region->in(i)->in(0)->is_If() &&\n+              this_region->in(i)->in(0)->in(1)->is_Bool()) {\n+            Node* bol = this_region->in(i)->in(0)->in(1);\n+            cmpx = bol->in(1);\n+            if (bol->as_Bool()->_test._test == BoolTest::ne &&\n+                cmpx->is_Cmp() && cmpx->in(2) == igvn->intcon(0) &&\n+                cmpx->in(1)->is_Load()) {\n+              Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n+              const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n+              if (adr->is_AddP() && adr->in(AddPNode::Base) == igvn->C->top() &&\n+                  adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n+                  adr->in(AddPNode::Offset) == igvn->MakeConX(marking_offset)) {\n+                igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+              }\n@@ -788,1 +786,1 @@\n-      macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+      igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n@@ -794,1 +792,1 @@\n-    macro->replace_node(node, macro->top());\n+    igvn->replace_node(node, igvn->C->top());\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const;\n+  virtual void eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,1 +518,2 @@\n-    if (klass->is_array_klass()) {\n+    \/\/ CMH: Valhalla flat arrays can split this work up, but for now, doesn't\n+    if (klass->is_array_klass() && !klass->is_flatArray_klass()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -30,0 +31,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -55,0 +58,27 @@\n+void BarrierSet::throw_array_null_pointer_store_exception(arrayOop src, arrayOop dst, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Klass* bound = ObjArrayKlass::cast(dst->klass())->element_klass();\n+  stringStream ss;\n+  ss.print(\"arraycopy: can not copy null values into %s[]\",\n+           bound->external_name());\n+  THROW_MSG(vmSymbols::java_lang_NullPointerException(), ss.as_string());\n+}\n+\n+void BarrierSet::throw_array_store_exception(arrayOop src, arrayOop dst, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Klass* bound = ObjArrayKlass::cast(dst->klass())->element_klass();\n+  Klass* stype = ObjArrayKlass::cast(src->klass())->element_klass();\n+  stringStream ss;\n+  if (!bound->is_subtype_of(stype)) {\n+    ss.print(\"arraycopy: type mismatch: can not copy %s[] into %s[]\",\n+             stype->external_name(), bound->external_name());\n+  } else {\n+    \/\/ oop_arraycopy should return the index in the source array that\n+    \/\/ contains the problematic oop.\n+    ss.print(\"arraycopy: element type mismatch: can not cast one of the elements\"\n+             \" of %s[] to the type of the destination array, %s\",\n+             stype->external_name(), bound->external_name());\n+  }\n+  THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/exceptions.hpp\"\n@@ -122,0 +123,3 @@\n+  static void throw_array_null_pointer_store_exception(arrayOop src, arrayOop dst, TRAPS);\n+  static void throw_array_store_exception(arrayOop src, arrayOop dst, TRAPS);\n+\n@@ -285,1 +289,1 @@\n-    static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+    static void oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -316,0 +320,5 @@\n+\n+    static void value_copy_in_heap(void* src, void* dst, InlineKlass* md) {\n+      Raw::value_copy(src, dst, md);\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+Node* C2ParseAccess::control() const {\n+  return _ctl == NULL ? _kit->control() : _ctl;\n+}\n+\n@@ -156,1 +160,1 @@\n-    Node* control = control_dependent ? kit->control() : NULL;\n+    Node* control = control_dependent ? parse_access.control() : NULL;\n@@ -682,1 +686,1 @@\n-  ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset,  dst_base, offset, payload_size, true, false);\n+  ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset, dst_base, offset, payload_size, true, false);\n@@ -783,1 +787,1 @@\n-  phase->igvn().replace_node(ac, call);\n+  phase->replace_node(ac, call);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  Node* _ctl;\n@@ -154,1 +155,2 @@\n-                BasicType type, Node* base, C2AccessValuePtr& addr) :\n+                BasicType type, Node* base, C2AccessValuePtr& addr,\n+                Node* ctl = NULL) :\n@@ -156,1 +158,2 @@\n-    _kit(kit) {\n+    _kit(kit),\n+    _ctl(ctl) {\n@@ -161,0 +164,1 @@\n+  Node* control() const;\n@@ -238,1 +242,1 @@\n-  virtual void clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const;\n+  virtual void clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* size, bool is_array) const;\n@@ -266,1 +270,1 @@\n-  virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const { }\n+  virtual void eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const { }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -287,0 +287,1 @@\n+  oop obj_buffer_allocate(Klass* klass, size_t size, TRAPS); \/\/ doesn't clear memory\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,2 +408,1 @@\n-  \/\/ May be bootstrapping\n-  oopDesc::set_mark(mem, markWord::prototype());\n+  oopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n@@ -422,0 +421,6 @@\n+oop ObjBufferAllocator::initialize(HeapWord* mem) const {\n+  oopDesc::set_klass_gap(mem, 0);\n+  return finish(mem);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,0 +98,8 @@\n+class ObjBufferAllocator: public MemAllocator {\n+public:\n+  ObjBufferAllocator(Klass* klass, size_t word_size, Thread* thread = Thread::current())\n+    : MemAllocator(klass, word_size, thread) {}\n+  virtual oop initialize(HeapWord* mem) const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-\n@@ -88,1 +87,1 @@\n-    static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+    static void oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n@@ -91,1 +90,5 @@\n-\n+  private:\n+    \/\/ Failing checkcast or check null during copy, still needs barrier\n+    template <typename T>\n+    static inline void oop_arraycopy_partial_barrier(BarrierSetT *bs, T* dst_raw, T* p);\n+  public:\n@@ -105,0 +108,2 @@\n+\n+    static void value_copy_in_heap(void* src, void* dst, InlineKlass* md);\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -835,1 +835,1 @@\n-    Node* offset = phase->igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+    Node* offset = phase->MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n@@ -887,1 +887,1 @@\n-    phase->igvn().replace_node(ac, call);\n+    phase->replace_node(ac, call);\n@@ -913,1 +913,1 @@\n-void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {\n+void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseIterGVN* igvn, Node* n) const {\n@@ -915,1 +915,1 @@\n-    shenandoah_eliminate_wb_pre(n, &macro->igvn());\n+    shenandoah_eliminate_wb_pre(n, igvn);\n@@ -1048,1 +1048,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain_sig()->cnt();\n@@ -1134,1 +1134,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain_sig()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const;\n+  virtual void eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-    if (is_reference_type(bt)) {\n+    if (is_reference_type(bt) && (!ary_ptr->is_flat())) {\n@@ -303,1 +303,1 @@\n-        length = phase->transform_later(new SubLNode(length, phase->longcon(1))); \/\/ Size is in longs\n+        length = phase->transform_later(new SubXNode(length, phase->longcon(1))); \/\/ Size is in longs\n@@ -348,1 +348,1 @@\n-  phase->igvn().replace_node(ac, call);\n+  phase->replace_node(ac, call);\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,0 +174,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsValhallaEnabled(void);\n+\n@@ -574,0 +577,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsIdentityClass(JNIEnv *env, jclass cls);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -48,0 +49,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -78,0 +82,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -159,1 +164,3 @@\n-  oop java_class = klass->java_mirror();\n+  oop java_class = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(klass)->val_mirror()\n+                      : klass->java_mirror();\n@@ -223,0 +230,4 @@\n+  if (klass->is_inline_klass()) {\n+    THROW(vmSymbols::java_lang_InstantiationError());\n+  }\n+\n@@ -247,0 +258,194 @@\n+JRT_ENTRY(void, InterpreterRuntime::aconst_init(JavaThread* current, ConstantPool* pool, int index))\n+  \/\/ Getting the InlineKlass\n+  Klass* k = pool->klass_at(index, CHECK);\n+  if (!k->is_inline_klass()) {\n+    \/\/ inconsistency with 'new' which throws an InstantiationError\n+    \/\/ in the future, aconst_init will just return null instead of throwing an exception\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  }\n+  assert(k->is_inline_klass(), \"aconst_init argument must be the inline type class\");\n+  InlineKlass* vklass = InlineKlass::cast(k);\n+\n+  vklass->initialize(CHECK);\n+  oop res = vklass->default_value();\n+  current->set_vm_result(res);\n+JRT_END\n+\n+JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr))\n+  oop obj = NULL;\n+  int recv_offset = type2size[as_BasicType(cpe->flag_state())];\n+  assert(frame::interpreter_frame_expression_stack_direction() == -1, \"currently is -1 on all platforms\");\n+  int ret_adj = (recv_offset + type2size[T_OBJECT] )* AbstractInterpreter::stackElementSize;\n+  int offset = cpe->f2_as_offset();\n+  obj = (oopDesc*)(((uintptr_t*)ptr)[recv_offset * Interpreter::stackElementWords]);\n+  if (obj == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+  }\n+  assert(oopDesc::is_oop(obj), \"Verifying receiver\");\n+  assert(obj->klass()->is_inline_klass(), \"Must have been checked during resolution\");\n+  instanceHandle old_value_h(THREAD, (instanceOop)obj);\n+  oop ref = NULL;\n+  if (cpe->flag_state() == atos) {\n+    ref = *(oopDesc**)ptr;\n+  }\n+  Handle ref_h(THREAD, ref);\n+  InlineKlass* ik = InlineKlass::cast(old_value_h()->klass());\n+  \/\/ Ensure that the class is initialized or being initialized\n+  \/\/ If the class is in error state, the creation of a new value should not be allowed\n+  ik->initialize(CHECK_(ret_adj));\n+\n+  bool can_skip = false;\n+  switch(cpe->flag_state()) {\n+    case ztos:\n+      if (old_value_h()->bool_field(offset) == (jboolean)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case btos:\n+      if (old_value_h()->byte_field(offset) == (jbyte)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case ctos:\n+      if (old_value_h()->char_field(offset) == (jchar)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case stos:\n+      if (old_value_h()->short_field(offset) == (jshort)(*(jint*)ptr)) can_skip = true;\n+      break;\n+    case itos:\n+      if (old_value_h()->int_field(offset) == *(jint*)ptr) can_skip = true;\n+      break;\n+    case ltos:\n+      if (old_value_h()->long_field(offset) == *(jlong*)ptr) can_skip = true;\n+      break;\n+    case ftos:\n+      if (memcmp(old_value_h()->field_addr<jfloat>(offset), (jfloat*)ptr, sizeof(jfloat)) == 0) can_skip = true;\n+      break;\n+    case dtos:\n+      if (memcmp(old_value_h()->field_addr<jdouble>(offset), (jdouble*)ptr, sizeof(jdouble)) == 0) can_skip = true;\n+      break;\n+    case atos:\n+      if (!cpe->is_inlined() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n+      break;\n+    default:\n+      break;\n+  }\n+  if (can_skip) {\n+    current->set_vm_result(old_value_h());\n+    return ret_adj;\n+  }\n+\n+  instanceOop new_value = ik->allocate_instance_buffer(CHECK_(ret_adj));\n+  Handle new_value_h = Handle(THREAD, new_value);\n+  ik->inline_copy_oop_to_new_oop(old_value_h(), new_value_h());\n+  switch(cpe->flag_state()) {\n+    case ztos:\n+      new_value_h()->bool_field_put(offset, (jboolean)(*(jint*)ptr));\n+      break;\n+    case btos:\n+      new_value_h()->byte_field_put(offset, (jbyte)(*(jint*)ptr));\n+      break;\n+    case ctos:\n+      new_value_h()->char_field_put(offset, (jchar)(*(jint*)ptr));\n+      break;\n+    case stos:\n+      new_value_h()->short_field_put(offset, (jshort)(*(jint*)ptr));\n+      break;\n+    case itos:\n+      new_value_h()->int_field_put(offset, (*(jint*)ptr));\n+      break;\n+    case ltos:\n+      new_value_h()->long_field_put(offset, *(jlong*)ptr);\n+      break;\n+    case ftos:\n+      new_value_h()->float_field_put(offset, *(jfloat*)ptr);\n+      break;\n+    case dtos:\n+      new_value_h()->double_field_put(offset, *(jdouble*)ptr);\n+      break;\n+    case atos:\n+      {\n+        if (cpe->is_null_free_inline_type())  {\n+          if (!cpe->is_inlined()) {\n+              if (ref_h() == NULL) {\n+                THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+              }\n+              new_value_h()->obj_field_put(offset, ref_h());\n+            } else {\n+              int field_index = cpe->field_index();\n+              InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n+              field_ik->write_inlined_field(new_value_h(), offset, ref_h(), CHECK_(ret_adj));\n+            }\n+        } else {\n+          new_value_h()->obj_field_put(offset, ref_h());\n+        }\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  current->set_vm_result(new_value_h());\n+  return ret_adj;\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int index))\n+  \/\/ The interpreter tries to access an inline static field that has not been initialized.\n+  \/\/ This situation can happen in different scenarios:\n+  \/\/   1 - if the load or initialization of the field failed during step 8 of\n+  \/\/       the initialization of the holder of the field, in this case the access to the field\n+  \/\/       must fail\n+  \/\/   2 - it can also happen when the initialization of the holder class triggered the initialization of\n+  \/\/       another class which accesses this field in its static initializer, in this case the\n+  \/\/       access must succeed to allow circularity\n+  \/\/ The code below tries to load and initialize the field's class again before returning the default value.\n+  \/\/ If the field was not initialized because of an error, an exception should be thrown.\n+  \/\/ If the class is being initialized, the default value is returned.\n+  instanceHandle mirror_h(THREAD, (instanceOop)mirror);\n+  InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  assert(klass->field_signature(index)->is_Q_signature(), \"Sanity check\");\n+  if (klass->is_being_initialized() && klass->is_init_thread(THREAD)) {\n+    int offset = klass->field_offset(index);\n+    Klass* field_k = klass->get_inline_type_field_klass_or_null(index);\n+    if (field_k == NULL) {\n+      field_k = SystemDictionary::resolve_or_fail(klass->field_signature(index)->fundamental_name(THREAD),\n+          Handle(THREAD, klass->class_loader()),\n+          Handle(THREAD, klass->protection_domain()),\n+          true, CHECK);\n+      assert(field_k != NULL, \"Should have been loaded or an exception thrown above\");\n+      klass->set_inline_type_field_klass(index, field_k);\n+    }\n+    field_k->initialize(CHECK);\n+    oop defaultvalue = InlineKlass::cast(field_k)->default_value();\n+    \/\/ It is safe to initialize the static field because 1) the current thread is the initializing thread\n+    \/\/ and is the only one that can access it, and 2) the field is actually not initialized (i.e. null)\n+    \/\/ otherwise the JVM should not be executing this code.\n+    mirror_h()->obj_field_put(offset, defaultvalue);\n+    current->set_vm_result(defaultvalue);\n+  } else {\n+    assert(klass->is_in_error_state(), \"If not initializing, initialization must have failed to get there\");\n+    ResourceMark rm(THREAD);\n+    const char* desc = \"Could not initialize class \";\n+    const char* className = klass->external_name();\n+    size_t msglen = strlen(desc) + strlen(className) + 1;\n+    char* message = NEW_RESOURCE_ARRAY(char, msglen);\n+    if (NULL == message) {\n+      \/\/ Out of memory: can't create detailed error message\n+      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);\n+    } else {\n+      jio_snprintf(message, msglen, \"%s%s\", desc, className);\n+      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);\n+    }\n+  }\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::read_inlined_field(JavaThread* current, oopDesc* obj, int index, Klass* field_holder))\n+  Handle obj_h(THREAD, obj);\n+\n+  assert(oopDesc::is_oop(obj), \"Sanity check\");\n+\n+  assert(field_holder->is_instance_klass(), \"Sanity check\");\n+  InstanceKlass* klass = InstanceKlass::cast(field_holder);\n+\n+  assert(klass->field_is_inlined(index), \"Sanity check\");\n+\n+  InlineKlass* field_vklass = InlineKlass::cast(klass->get_inline_type_field_klass(index));\n+\n+  oop res = field_vklass->read_inlined_field(obj_h(), klass->field_offset(index), CHECK);\n+  current->set_vm_result(res);\n+JRT_END\n@@ -256,1 +461,8 @@\n-  objArrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n+  bool      is_qtype_desc = pool->tag_at(index).is_Qdescriptor_klass();\n+  arrayOop obj;\n+  if ((!klass->is_array_klass()) && is_qtype_desc) { \/\/ Logically creates elements, ensure klass init\n+    klass->initialize(CHECK);\n+    obj = oopFactory::new_valueArray(klass, size, CHECK);\n+  } else {\n+    obj = oopFactory::new_objArray(klass, size, CHECK);\n+  }\n@@ -260,0 +472,10 @@\n+JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* current, arrayOopDesc* array, int index))\n+  flatArrayHandle vah(current, (flatArrayOop)array);\n+  oop value_holder = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);\n+  current->set_vm_result(value_holder);\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index))\n+  assert(val != NULL, \"can't store null into flat array\");\n+  ((flatArrayOop)array)->value_copy_to_index(cast_to_oop(val), index);\n+JRT_END\n@@ -265,2 +487,3 @@\n-  int          i = last_frame.get_index_u2(Bytecodes::_multianewarray);\n-  Klass* klass   = constants->klass_at(i, CHECK);\n+  int i = last_frame.get_index_u2(Bytecodes::_multianewarray);\n+  Klass* klass = constants->klass_at(i, CHECK);\n+  bool is_qtype = klass->name()->is_Q_array_signature();\n@@ -271,0 +494,4 @@\n+  if (is_qtype) { \/\/ Logically creates elements, ensure klass init\n+    klass->initialize(CHECK);\n+  }\n+\n@@ -295,0 +522,23 @@\n+JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* current, oopDesc* aobj, oopDesc* bobj))\n+  assert(oopDesc::is_oop(aobj) && oopDesc::is_oop(bobj), \"must be valid oops\");\n+\n+  Handle ha(THREAD, aobj);\n+  Handle hb(THREAD, bobj);\n+  JavaValue result(T_BOOLEAN);\n+  JavaCallArguments args;\n+  args.push_oop(ha);\n+  args.push_oop(hb);\n+  methodHandle method(current, Universe::is_substitutable_method());\n+  JavaCalls::call(&result, method, &args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    \/\/ Something really bad happened because isSubstitutable() should not throw exceptions\n+    \/\/ If it is an error, just let it propagate\n+    \/\/ If it is an exception, wrap it into an InternalError\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+      Handle e(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in substitutability test\", e, false);\n+    }\n+  }\n+  return result.get_jboolean();\n+JRT_END\n@@ -631,0 +881,4 @@\n+JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* current))\n+  THROW(vmSymbols::java_lang_InstantiationError());\n+JRT_END\n+\n@@ -664,1 +918,1 @@\n-                    bytecode == Bytecodes::_putstatic);\n+                    bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);\n@@ -666,0 +920,1 @@\n+  bool is_inline_type  = bytecode == Bytecodes::_withfield;\n@@ -710,3 +965,9 @@\n-    get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);\n-    if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {\n-      put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);\n+    if (is_static) {\n+      get_code = Bytecodes::_getstatic;\n+    } else {\n+      get_code = Bytecodes::_getfield;\n+    }\n+    if (is_put && is_inline_type) {\n+        put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);\n+    } else if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {\n+        put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);\n@@ -724,1 +985,3 @@\n-    info.access_flags().is_volatile()\n+    info.access_flags().is_volatile(),\n+    info.is_inlined(),\n+    info.signature()->is_Q_signature() && info.is_inline_type()\n@@ -963,0 +1226,1 @@\n+  case Bytecodes::_withfield:\n@@ -1165,0 +1429,1 @@\n+  bool is_inlined = cp_entry->is_inlined();\n@@ -1173,1 +1438,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static, is_inlined);\n@@ -1203,0 +1468,6 @@\n+\n+  \/\/ Both Q-signatures and L-signatures are mapped to atos\n+  if (cp_entry->flag_state() == atos && ik->field_signature(index)->is_Q_signature()) {\n+    sig_type = JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+  }\n+\n@@ -1204,0 +1475,1 @@\n+  bool is_inlined = cp_entry->is_inlined();\n@@ -1206,1 +1478,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static, is_inlined);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":283,"deletions":11,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -963,0 +963,1 @@\n+         byte == Bytecodes::_withfield ||\n@@ -967,1 +968,2 @@\n-  bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic || byte == Bytecodes::_nofast_putfield);\n+  bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic ||\n+                    byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);\n@@ -978,0 +980,14 @@\n+  if (byte == Bytecodes::_withfield && !resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode withfield cannot be used on identity class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n+  if (is_put && !is_static && byte != Bytecodes::_withfield && resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode putfield cannot be used on primitive class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n@@ -1005,0 +1021,2 @@\n+    \/\/ (3) by withfield when field is in a value type and the\n+    \/\/     selected class and current class are nest mates.\n@@ -1008,6 +1026,15 @@\n-        ResourceMark rm(THREAD);\n-        stringStream ss;\n-        ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n-                 is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n-                current_klass->external_name());\n-        THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        \/\/ If byte code is a withfield check if they are nestmates.\n+        bool are_nestmates = false;\n+        if (sel_klass->is_instance_klass() &&\n+            InstanceKlass::cast(sel_klass)->is_inline_klass() &&\n+            current_klass->is_instance_klass()) {\n+          are_nestmates = InstanceKlass::cast(current_klass)->has_nestmate_access_to(InstanceKlass::cast(sel_klass), THREAD);\n+        }\n+        if (!are_nestmates) {\n+          ResourceMark rm(THREAD);\n+          stringStream ss;\n+          ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n+                   is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n+                    current_klass->external_name());\n+          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        }\n@@ -1021,1 +1048,1 @@\n-                                                   !m->is_static_initializer());\n+                                                   !m->is_class_initializer());\n@@ -1024,1 +1051,1 @@\n-                                                     !m->is_object_initializer());\n+                                                     !m->is_object_constructor());\n@@ -1152,0 +1179,2 @@\n+  \/\/ Since this method is never inherited from a super, any appearance here under\n+  \/\/ the wrong class would be an error.\n@@ -1222,1 +1251,1 @@\n-      \/\/ check if the method is not <init>\n+      \/\/ check if the method is not <init>, which is never inherited\n@@ -1644,2 +1673,2 @@\n-                             const methodHandle& attached_method,\n-                             Bytecodes::Code byte, TRAPS) {\n+                                  const methodHandle& attached_method,\n+                                  Bytecodes::Code byte, bool check_null_and_abstract, TRAPS) {\n@@ -1650,0 +1679,1 @@\n+  Klass* recv_klass = recv.is_null() ? defc : recv->klass();\n@@ -1652,2 +1682,2 @@\n-      resolve_virtual_call(result, recv, recv->klass(), link_info,\n-                           \/*check_null_and_abstract=*\/true, CHECK);\n+      resolve_virtual_call(result, recv, recv_klass, link_info,\n+                           check_null_and_abstract, CHECK);\n@@ -1656,2 +1686,2 @@\n-      resolve_interface_call(result, recv, recv->klass(), link_info,\n-                             \/*check_null_and_abstract=*\/true, CHECK);\n+      resolve_interface_call(result, recv, recv_klass, link_info,\n+                             check_null_and_abstract, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -162,1 +162,2 @@\n-  assert(_desc->tos_in()  == tos_in , \"inconsistent tos_in  information\");\n+  assert(_desc->tos_in()  == tos_in,\n+         \"inconsistent tos_in  information\");\n@@ -233,0 +234,1 @@\n+\n@@ -285,1 +287,1 @@\n-  def(Bytecodes::_aaload              , ____|____|____|____, itos, atos, aaload              ,  _           );\n+  def(Bytecodes::_aaload              , ____|____|clvm|____, itos, atos, aaload              ,  _           );\n@@ -437,0 +439,3 @@\n+  def(Bytecodes::_breakpoint          , ubcp|disp|clvm|____, vtos, vtos, _breakpoint         ,  _           );\n+  def(Bytecodes::_aconst_init         , ubcp|____|clvm|____, vtos, atos, aconst_init        , _            );\n+  def(Bytecodes::_withfield           , ubcp|____|clvm|____, vtos, atos, withfield           , _            );\n@@ -455,0 +460,1 @@\n+  def(Bytecodes::_fast_qgetfield      , ubcp|____|clvm|____, atos, atos, fast_accessfield    ,  atos        );\n@@ -464,0 +470,1 @@\n+  def(Bytecodes::_fast_qputfield      , ubcp|____|clvm|____, atos, vtos, fast_storefield ,   atos        );\n@@ -500,0 +507,1 @@\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -301,0 +301,1 @@\n+  static void withfield();\n@@ -303,0 +304,1 @@\n+  static void aconst_init();\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1101,0 +1101,1 @@\n+      const bool return_scalarized     = false;\n@@ -1104,1 +1105,1 @@\n-                                      has_ea_local_in_scope, arg_escape,\n+                                      return_scalarized, has_ea_local_in_scope, arg_escape,\n@@ -1241,0 +1242,2 @@\n+      _offsets.set_value(CodeOffsets::Verified_Inline_Entry, pc_offset);\n+      _offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, pc_offset);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1375,1 +1375,1 @@\n-              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false, CHECK_NULL);\n@@ -1607,1 +1607,1 @@\n-  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);\n+  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false, THREAD);\n@@ -1907,1 +1907,1 @@\n-    if (m->is_initializer() && !m->is_static()) {\n+    if (m->is_object_constructor()) {\n@@ -1934,1 +1934,1 @@\n-    if (!m->is_initializer() && !m->is_overpass()) {\n+    if (!(m->is_object_constructor() || m->is_class_initializer()) && !m->is_overpass()) {\n@@ -2613,2 +2613,1 @@\n-  if (m->is_initializer()) {\n-    if (m->is_static_initializer()) {\n+  if (m->is_class_initializer()) {\n@@ -2617,1 +2616,2 @@\n-    }\n+  }\n+  else if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  nonstatic_field(InstanceKlass,               _misc_status._flags,                           u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _misc_status._flags,                           u4)                                    \\\n@@ -602,0 +602,2 @@\n+  declare_constant(DataLayout::array_load_store_data_tag)                 \\\n+  declare_constant(DataLayout::acmp_data_tag)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"runtime\/reflectionUtils.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -512,0 +515,132 @@\n+\n+class FindClassByNameClosure : public KlassInfoClosure {\n+ private:\n+  GrowableArray<Klass*>* _klasses;\n+  Symbol* _classname;\n+ public:\n+  FindClassByNameClosure(GrowableArray<Klass*>* klasses, Symbol* classname) :\n+    _klasses(klasses), _classname(classname) { }\n+\n+  void do_cinfo(KlassInfoEntry* cie) {\n+    if (cie->klass()->name() == _classname) {\n+      _klasses->append(cie->klass());\n+    }\n+  }\n+};\n+\n+class FieldDesc {\n+private:\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _offset;\n+  int _index;\n+  InstanceKlass* _holder;\n+  AccessFlags _access_flags;\n+ public:\n+  FieldDesc() {\n+    _name = NULL;\n+    _signature = NULL;\n+    _offset = -1;\n+    _index = -1;\n+    _holder = NULL;\n+    _access_flags = AccessFlags();\n+  }\n+  FieldDesc(fieldDescriptor& fd) {\n+    _name = fd.name();\n+    _signature = fd.signature();\n+    _offset = fd.offset();\n+    _index = fd.index();\n+    _holder = fd.field_holder();\n+    _access_flags = fd.access_flags();\n+  }\n+  const Symbol* name() { return _name;}\n+  const Symbol* signature() { return _signature; }\n+  const int offset() { return _offset; }\n+  const int index() { return _index; }\n+  const InstanceKlass* holder() { return _holder; }\n+  const AccessFlags& access_flags() { return _access_flags; }\n+  const bool is_inline_type() { return Signature::basic_type(_signature) == T_PRIMITIVE_OBJECT; }\n+};\n+\n+static int compare_offset(FieldDesc* f1, FieldDesc* f2) {\n+   return f1->offset() > f2->offset() ? 1 : -1;\n+}\n+\n+static void print_field(outputStream* st, int level, int offset, FieldDesc& fd, bool is_inline_type, bool is_inlined ) {\n+  const char* inlined_msg = \"\";\n+  if (is_inline_type) {\n+    inlined_msg = is_inlined ? \"inlined\" : \"not inlined\";\n+  }\n+  st->print_cr(\"  @ %d %*s \\\"%s\\\" %s %s %s\",\n+      offset, level * 3, \"\",\n+      fd.name()->as_C_string(),\n+      fd.signature()->as_C_string(),\n+      is_inline_type ? \" \/\/ inline type \" : \"\",\n+      inlined_msg);\n+}\n+\n+static void print_inlined_field(outputStream* st, int level, int offset, InstanceKlass* klass) {\n+  assert(klass->is_inline_klass(), \"Only inline types can be inlined\");\n+  InlineKlass* vklass = InlineKlass::cast(klass);\n+  GrowableArray<FieldDesc>* fields = new (mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+  for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {\n+    if (!fd.access_flags().is_static()) {\n+      fields->append(FieldDesc(fd.field_descriptor()));\n+    }\n+  }\n+  fields->sort(compare_offset);\n+  for(int i = 0; i < fields->length(); i++) {\n+    FieldDesc fd = fields->at(i);\n+    int offset2 = offset + fd.offset() - vklass->first_field_offset();\n+    print_field(st, level, offset2, fd,\n+        fd.is_inline_type(), fd.holder()->field_is_inlined(fd.index()));\n+    if (fd.holder()->field_is_inlined(fd.index())) {\n+      print_inlined_field(st, level + 1, offset2 ,\n+          InstanceKlass::cast(fd.holder()->get_inline_type_field_klass(fd.index())));\n+    }\n+  }\n+}\n+\n+void PrintClassLayout::print_class_layout(outputStream* st, char* class_name) {\n+  KlassInfoTable cit(true);\n+  if (cit.allocation_failed()) {\n+    st->print_cr(\"ERROR: Ran out of C-heap; hierarchy not generated\");\n+    return;\n+  }\n+\n+  Thread* THREAD = Thread::current();\n+\n+  Symbol* classname = SymbolTable::probe(class_name, (int)strlen(class_name));\n+\n+  GrowableArray<Klass*>* klasses = new (mtServiceability) GrowableArray<Klass*>(100, mtServiceability);\n+\n+  FindClassByNameClosure fbnc(klasses, classname);\n+  cit.iterate(&fbnc);\n+\n+  for(int i = 0; i < klasses->length(); i++) {\n+    Klass* klass = klasses->at(i);\n+    if (!klass->is_instance_klass()) continue;  \/\/ Skip\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    int tab = 1;\n+    st->print_cr(\"Class %s [@%s]:\", klass->name()->as_C_string(),\n+        klass->class_loader_data()->loader_name());\n+    ResourceMark rm;\n+    GrowableArray<FieldDesc>* fields = new (mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+    for (FieldStream fd(ik, false, false); !fd.eos(); fd.next()) {\n+      if (!fd.access_flags().is_static()) {\n+        fields->append(FieldDesc(fd.field_descriptor()));\n+      }\n+    }\n+    fields->sort(compare_offset);\n+    for(int i = 0; i < fields->length(); i++) {\n+      FieldDesc fd = fields->at(i);\n+      print_field(st, 0, fd.offset(), fd, fd.is_inline_type(), fd.holder()->field_is_inlined(fd.index()));\n+      if (fd.holder()->field_is_inlined(fd.index())) {\n+        print_inlined_field(st, 1, fd.offset(),\n+            InstanceKlass::cast(fd.holder()->get_inline_type_field_klass(fd.index())));\n+      }\n+    }\n+  }\n+  st->cr();\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -194,0 +194,5 @@\n+class PrintClassLayout : AllStatic {\n+ public:\n+  static void print_class_layout(outputStream* st, char* classname);\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+  virtual void do_oop_no_buffering(oop* o) { do_oop(o); }\n+  virtual void do_oop_no_buffering(narrowOop* o) { do_oop(o); }\n@@ -139,0 +141,5 @@\n+class BufferedValueClosure : public Closure {\n+public:\n+  virtual void do_buffered_value(oop* p) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,1 +82,5 @@\n-    _method_entry_ref\n+    \/\/ A field that points to a method entry. E.g., Method::_i2i_entry\n+    _method_entry_ref,\n+\n+    \/\/ A field that points to a location inside the current object.\n+    _internal_pointer_ref,\n@@ -361,1 +365,9 @@\n-    push_special(_method_entry_ref, ref, (intptr_t*)p);\n+    push_special(_method_entry_ref, ref, p);\n+    if (!ref->keep_after_pushing()) {\n+      delete ref;\n+    }\n+  }\n+\n+  template <class T> void push_internal_pointer(T** mpp, intptr_t* p) {\n+    Ref* ref = new MSORef<T>(mpp, _default);\n+    push_special(_internal_pointer_ref, ref, p);\n@@ -370,1 +382,5 @@\n-    assert(type == _method_entry_ref, \"only special type allowed for now\");\n+    assert_valid(type);\n+  }\n+\n+  static void assert_valid(SpecialRef type) {\n+    assert(type == _method_entry_ref || type == _internal_pointer_ref, \"only special types allowed for now\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -137,0 +137,2 @@\n+LatestMethodCache* Universe::_is_substitutable_cache  = NULL;\n+LatestMethodCache* Universe::_value_object_hash_code_cache = NULL;\n@@ -236,0 +238,2 @@\n+  _is_substitutable_cache->metaspace_pointers_do(it);\n+  _value_object_hash_code_cache->metaspace_pointers_do(it);\n@@ -287,0 +291,2 @@\n+  _is_substitutable_cache->serialize(f);\n+  _value_object_hash_code_cache->serialize(f);\n@@ -367,0 +373,1 @@\n+\n@@ -782,1 +789,0 @@\n-\n@@ -802,0 +808,2 @@\n+  Universe::_is_substitutable_cache = new LatestMethodCache();\n+  Universe::_value_object_hash_code_cache = new LatestMethodCache();\n@@ -969,0 +977,11 @@\n+\n+  \/\/ Set up substitutability testing\n+  ResourceMark rm;\n+  initialize_known_method(_is_substitutable_cache,\n+                          vmClasses::ValueObjectMethods_klass(),\n+                          vmSymbols::isSubstitutable_name()->as_C_string(),\n+                          vmSymbols::object_object_boolean_signature(), true, CHECK);\n+  initialize_known_method(_value_object_hash_code_cache,\n+                          vmClasses::ValueObjectMethods_klass(),\n+                          vmSymbols::valueObjectHashCode_name()->as_C_string(),\n+                          vmSymbols::object_int_signature(), true, CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+  static LatestMethodCache* _is_substitutable_cache;   \/\/ ValueObjectMethods.isSubstitutable() method\n+  static LatestMethodCache* _value_object_hash_code_cache;  \/\/ ValueObjectMethods.valueObjectHashCode() method\n@@ -154,0 +156,1 @@\n+\n@@ -276,0 +279,3 @@\n+  static Method*      is_substitutable_method()       { return _is_substitutable_cache->get_method(); }\n+  static Method*      value_object_hash_code_method() { return _value_object_hash_code_cache->get_method(); }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,0 +194,2 @@\n+\/\/ * ARRAYCOPY_NOTNULL: This property means that the source array may contain null elements\n+\/\/   but the destination does not allow null elements (i.e. throw NPE)\n@@ -200,5 +202,6 @@\n-const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) << 24;\n-const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) << 25;\n-const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) << 26;\n-const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) << 27;\n-const DecoratorSet ARRAYCOPY_DECORATOR_MASK       = ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT |\n+const DecoratorSet ARRAYCOPY_NOTNULL              = UCONST64(1) << 24;\n+const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) << 25;\n+const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) << 26;\n+const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) << 27;\n+const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) << 28;\n+const DecoratorSet ARRAYCOPY_DECORATOR_MASK       = ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL |\n@@ -212,2 +215,2 @@\n-const DecoratorSet ACCESS_READ                    = UCONST64(1) << 28;\n-const DecoratorSet ACCESS_WRITE                   = UCONST64(1) << 29;\n+const DecoratorSet ACCESS_READ                    = UCONST64(1) << 29;\n+const DecoratorSet ACCESS_WRITE                   = UCONST64(1) << 30;\n@@ -216,1 +219,1 @@\n-const DecoratorSet DECORATOR_LAST = UCONST64(1) << 29;\n+const DecoratorSet DECORATOR_LAST = UCONST64(1) << 30;\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -235,1 +236,1 @@\n-      \/\/ All of these should have been reverted back to ClassIndex before calling\n+      \/\/ All of these should have been reverted back to Unresolved before calling\n@@ -254,0 +255,1 @@\n+  assert(!k->name()->is_Q_signature(), \"Q-type without JVM_CONSTANT_QDescBit\");\n@@ -380,1 +382,4 @@\n-      tag_at_put(index, JVM_CONSTANT_UnresolvedClass);\n+      {\n+        jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n+        tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n+      }\n@@ -436,1 +441,2 @@\n-  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n+  jbyte qdesc_bit = tag_at(cp_index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n+  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n@@ -481,0 +487,6 @@\n+void check_is_inline_type(Klass* k, TRAPS) {\n+  if (!k->is_inline_klass()) {\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  }\n+}\n+\n@@ -518,0 +530,5 @@\n+  bool inline_type_signature = false;\n+  if (name->is_Q_signature()) {\n+    name = name->fundamental_name(THREAD);\n+    inline_type_signature = true;\n+  }\n@@ -527,0 +544,3 @@\n+  if (inline_type_signature) {\n+    name->decrement_refcount();\n+  }\n@@ -535,0 +555,16 @@\n+  if (!HAS_PENDING_EXCEPTION && inline_type_signature) {\n+    check_is_inline_type(k, THREAD);\n+  }\n+\n+  if (!HAS_PENDING_EXCEPTION) {\n+    Klass* bottom_klass = NULL;\n+    if (k->is_objArray_klass()) {\n+      bottom_klass = ObjArrayKlass::cast(k)->bottom_klass();\n+      assert(bottom_klass != NULL, \"Should be set\");\n+      assert(bottom_klass->is_instance_klass() || bottom_klass->is_typeArray_klass(), \"Sanity check\");\n+    } else if (k->is_flatArray_klass()) {\n+      bottom_klass = FlatArrayKlass::cast(k)->element_klass();\n+      assert(bottom_klass != NULL, \"Should be set\");\n+    }\n+  }\n+\n@@ -538,1 +574,5 @@\n-    save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n+    jbyte tag = JVM_CONSTANT_UnresolvedClass;\n+    if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+      tag |= JVM_CONSTANT_QDescBit;\n+    }\n+    save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);\n@@ -557,0 +597,4 @@\n+  jbyte tag = JVM_CONSTANT_Class;\n+  if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+    tag |= JVM_CONSTANT_QDescBit;\n+  }\n@@ -561,1 +605,1 @@\n-                                  (jbyte)JVM_CONSTANT_Class);\n+                                  tag);\n@@ -994,1 +1038,3 @@\n-      result_oop = resolved->java_mirror();\n+      result_oop = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(resolved)->val_mirror()\n+                      : resolved->java_mirror();\n@@ -1912,0 +1958,6 @@\n+      case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {\n+        idx1 = Bytes::get_Java_u2(bytes);\n+        printf(\"qclass        #%03d\", idx1);\n+        ent_size = 2;\n+        break;\n+      }\n@@ -1954,0 +2006,4 @@\n+      case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {\n+        printf(\"UnresolvedQClass: %s\", WARN_MSG);\n+        break;\n+      }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":62,"deletions":6,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-  \/\/ For temporary use while constructing constant pool\n+  \/\/ For temporary use while constructing constant pool. Used during a retransform\/class redefinition as well.\n@@ -294,0 +294,9 @@\n+  void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {\n+      release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);\n+\n+      assert((name_index & 0xffff0000) == 0, \"must be\");\n+      assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n+      *int_at_addr(which) =\n+        build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -124,1 +124,3 @@\n-                                       bool is_volatile) {\n+                                       bool is_volatile,\n+                                       bool is_inlined,\n+                                       bool is_null_free_inline_type) {\n@@ -129,0 +131,1 @@\n+  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n@@ -131,1 +134,3 @@\n-                  ((is_final    ? 1 : 0) << is_final_shift),\n+                  ((is_final    ? 1 : 0) << is_final_shift) |\n+                  ((is_inlined  ? 1 : 0) << is_inlined_shift) |\n+                  ((is_null_free_inline_type ? 1 : 0) << is_null_free_inline_type_shift),\n@@ -289,0 +294,1 @@\n+      invoke_code = Bytecodes::_invokevirtual;\n@@ -304,1 +310,1 @@\n-    set_bytecode_2(Bytecodes::_invokevirtual);\n+    set_bytecode_2(invoke_code);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -166,0 +167,2 @@\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_PRIMITIVE_OBJECT; }\n+\n@@ -438,1 +441,3 @@\n-                                       parser.is_interface());\n+                                       parser.is_interface(),\n+                                       parser.has_inline_fields() ? parser.java_fields_count() : 0,\n+                                       parser.is_inline_type());\n@@ -460,0 +465,3 @@\n+  } else if (parser.is_inline_type()) {\n+    \/\/ inline type\n+    ik = new (loader_data, size, THREAD) InlineKlass(parser);\n@@ -471,0 +479,7 @@\n+#ifdef ASSERT\n+  assert(ik->size() == size, \"\");\n+  ik->bounds_check((address) ik->start_of_vtable(), false, size);\n+  ik->bounds_check((address) ik->start_of_itable(), false, size);\n+  ik->bounds_check((address) ik->end_of_itable(), true, size);\n+  ik->bounds_check((address) ik->end_of_nonstatic_oop_maps(), true, size);\n+#endif \/\/ASSERT\n@@ -474,0 +489,23 @@\n+#ifndef PRODUCT\n+bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {\n+  const char* bad = NULL;\n+  address end = NULL;\n+  if (addr < (address)this) {\n+    bad = \"before\";\n+  } else if (addr == (address)this) {\n+    if (edge_ok)  return true;\n+    bad = \"just before\";\n+  } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes < 0 ? size() : size_in_bytes))) {\n+    if (edge_ok)  return true;\n+    bad = \"just after\";\n+  } else if (addr > end) {\n+    bad = \"after\";\n+  } else {\n+    return true;\n+  }\n+  tty->print_cr(\"%s object bounds: \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \"..\" INTPTR_FORMAT \"]\",\n+      bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);\n+  Verbose = WizardMode = true; this->print(); \/\/@@\n+  return false;\n+}\n+#endif \/\/PRODUCT\n@@ -513,1 +551,4 @@\n-  _init_thread(NULL)\n+  _init_thread(NULL),\n+  _inline_type_field_klasses(NULL),\n+  _preload_classes(NULL),\n+  _adr_inlineklass_fixed_block(NULL)\n@@ -520,0 +561,4 @@\n+    if (parser.has_inline_fields()) {\n+      set_has_inline_type_fields();\n+    }\n+    _java_fields_count = parser.java_fields_count();\n@@ -524,0 +569,4 @@\n+\n+  if (has_inline_type_fields()) {\n+    _inline_type_field_klasses = (const Klass**) adr_inline_type_field_klasses();\n+  }\n@@ -688,0 +737,6 @@\n+  if (preload_classes() != NULL &&\n+      preload_classes() != Universe::the_empty_short_array() &&\n+      !preload_classes()->is_shared()) {\n+    MetadataFactory::free_array<jushort>(loader_data, preload_classes());\n+  }\n+\n@@ -838,0 +893,78 @@\n+\n+  \/\/ If a class declares a method that uses an inline class as an argument\n+  \/\/ type or return inline type, this inline class must be loaded during the\n+  \/\/ linking of this class because size and properties of the inline class\n+  \/\/ must be known in order to be able to perform inline type optimizations.\n+  \/\/ The implementation below is an approximation of this rule, the code\n+  \/\/ iterates over all methods of the current class (including overridden\n+  \/\/ methods), not only the methods declared by this class. This\n+  \/\/ approximation makes the code simpler, and doesn't change the semantic\n+  \/\/ because classes declaring methods overridden by the current class are\n+  \/\/ linked (and have performed their own pre-loading) before the linking\n+  \/\/ of the current class.\n+\n+\n+  \/\/ Note:\n+  \/\/ Inline class types are loaded during\n+  \/\/ the loading phase (see ClassFileParser::post_process_parsed_stream()).\n+  \/\/ Inline class types used as element types for array creation\n+  \/\/ are not pre-loaded. Their loading is triggered by either anewarray\n+  \/\/ or multianewarray bytecodes.\n+\n+  \/\/ Could it be possible to do the following processing only if the\n+  \/\/ class uses inline types?\n+  if (EnableValhalla) {\n+    ResourceMark rm(THREAD);\n+    if (EnablePrimitiveClasses) {\n+      for (int i = 0; i < methods()->length(); i++) {\n+        Method* m = methods()->at(i);\n+        for (SignatureStream ss(m->signature()); !ss.is_done(); ss.next()) {\n+          if (ss.is_reference()) {\n+            if (ss.is_array()) {\n+              continue;\n+            }\n+            if (ss.type() == T_PRIMITIVE_OBJECT) {\n+              Symbol* symb = ss.as_symbol();\n+              if (symb == name()) continue;\n+              oop loader = class_loader();\n+              oop protection_domain = this->protection_domain();\n+              Klass* klass = SystemDictionary::resolve_or_fail(symb,\n+                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n+                                                              CHECK_false);\n+              if (klass == NULL) {\n+                THROW_(vmSymbols::java_lang_LinkageError(), false);\n+              }\n+              if (!klass->is_inline_klass()) {\n+                Exceptions::fthrow(\n+                  THREAD_AND_LOCATION,\n+                  vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  \"class %s is not an inline type\",\n+                  klass->external_name());\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+    \/\/ Aggressively preloading all classes from the Preload attribute\n+    if (preload_classes() != NULL) {\n+      for (int i = 0; i < preload_classes()->length(); i++) {\n+        if (constants()->tag_at(preload_classes()->at(i)).is_klass()) continue;\n+        Symbol* class_name = constants()->klass_at_noresolve(preload_classes()->at(i));\n+        if (class_name == name()) continue;\n+        oop loader = class_loader();\n+        oop protection_domain = this->protection_domain();\n+        Klass* klass = SystemDictionary::resolve_or_null(class_name,\n+                                                          Handle(THREAD, loader), Handle(THREAD, protection_domain), THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+        }\n+        if (klass != NULL) {\n+          log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute\", class_name->as_C_string(), name()->as_C_string());\n+        } else {\n+          log_warning(class, preload)(\"Preloading of class %s during linking of class %s (Preload attribute) failed\", class_name->as_C_string(), name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1082,0 +1215,19 @@\n+  \/\/ Pre-allocating an instance of the default value\n+  if (is_inline_klass()) {\n+      InlineKlass* vk = InlineKlass::cast(this);\n+      oop val = vk->allocate_instance(THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          {\n+              EXCEPTION_MARK;\n+              add_initialization_error(THREAD, e);\n+              \/\/ Locks object, set state, and notify all waiting threads\n+              set_initialization_state_and_notify(initialization_error, THREAD);\n+              CLEAR_PENDING_EXCEPTION;\n+          }\n+          THROW_OOP(e());\n+      }\n+      vk->set_default_value(val);\n+  }\n+\n@@ -1114,1 +1266,41 @@\n-\n+  \/\/ Initialize classes of inline fields\n+  if (EnablePrimitiveClasses) {\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+        Klass* klass = get_inline_type_field_klass_or_null(fs.index());\n+        if (fs.access_flags().is_static() && klass == NULL) {\n+          klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())->fundamental_name(THREAD),\n+              Handle(THREAD, class_loader()),\n+              Handle(THREAD, protection_domain()),\n+              true, THREAD);\n+          set_inline_type_field_klass(fs.index(), klass);\n+        }\n+\n+        if (!HAS_PENDING_EXCEPTION) {\n+          assert(klass != NULL, \"Must  be\");\n+          InstanceKlass::cast(klass)->initialize(THREAD);\n+          if (fs.access_flags().is_static()) {\n+            if (java_mirror()->obj_field(fs.offset()) == NULL) {\n+              java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n+            }\n+          }\n+        }\n+\n+        if (HAS_PENDING_EXCEPTION) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          {\n+            EXCEPTION_MARK;\n+            add_initialization_error(THREAD, e);\n+            \/\/ Locks object, set state, and notify all waiting threads\n+            set_initialization_state_and_notify(initialization_error, THREAD);\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+          THROW_OOP(e());\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  \/\/ Step 9\n@@ -1137,1 +1329,1 @@\n-  \/\/ Step 9\n+  \/\/ Step 10\n@@ -1143,1 +1335,1 @@\n-    \/\/ Step 10 and 11\n+    \/\/ Step 11 and 12\n@@ -1412,1 +1604,2 @@\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this,\n+                                                                  false, false, CHECK_NULL);\n@@ -1419,2 +1612,2 @@\n-  ObjArrayKlass* oak = array_klasses();\n-  return oak->array_klass(n, THREAD);\n+  ArrayKlass* ak = array_klasses();\n+  return ak->array_klass(n, THREAD);\n@@ -1425,2 +1618,2 @@\n-  ObjArrayKlass* oak = array_klasses_acquire();\n-  if (oak == NULL) {\n+  ArrayKlass* ak = array_klasses_acquire();\n+  if (ak == NULL) {\n@@ -1429,1 +1622,1 @@\n-    return oak->array_klass_or_null(n);\n+    return ak->array_klass_or_null(n);\n@@ -1446,1 +1639,1 @@\n-  if (clinit != NULL && clinit->has_valid_initializer_flags()) {\n+  if (clinit != NULL && clinit->is_class_initializer()) {\n@@ -1495,1 +1688,1 @@\n-    MutexLocker x(OopMapCacheAlloc_lock);\n+    MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);\n@@ -1507,5 +1700,0 @@\n-bool InstanceKlass::contains_field_offset(int offset) {\n-  fieldDescriptor fd;\n-  return find_field_from_offset(offset, false, &fd);\n-}\n-\n@@ -1582,0 +1770,9 @@\n+bool InstanceKlass::contains_field_offset(int offset) {\n+  if (this->is_inline_klass()) {\n+    InlineKlass* vk = InlineKlass::cast(this);\n+    return offset >= vk->first_field_offset() && offset < (vk->first_field_offset() + vk->get_exact_size_in_bytes());\n+  } else {\n+    fieldDescriptor fd;\n+    return find_field_from_offset(offset, false, &fd);\n+  }\n+}\n@@ -1974,0 +2171,4 @@\n+    if (name == vmSymbols::object_initializer_name() ||\n+        name == vmSymbols::inline_factory_name()) {\n+      break;  \/\/ <init> and <vnew> is never inherited\n+    }\n@@ -2451,0 +2652,1 @@\n+  it->push(&_preload_classes);\n@@ -2452,0 +2654,6 @@\n+\n+  if (has_inline_type_fields()) {\n+    for (int i = 0; i < java_fields_count(); i++) {\n+      it->push(&((Klass**)adr_inline_type_field_klasses())[i]);\n+    }\n+  }\n@@ -2495,0 +2703,8 @@\n+  if (has_inline_type_fields()) {\n+    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+        reset_inline_type_field_klass(fs.index());\n+      }\n+    }\n+  }\n+\n@@ -2557,0 +2773,4 @@\n+  if (is_inline_klass()) {\n+    InlineKlass::cast(this)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -2737,0 +2957,2 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n@@ -2738,0 +2960,1 @@\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -2744,1 +2967,1 @@\n-  \/\/ Add L as type indicator\n+  \/\/ Add L or Q as type indicator\n@@ -2746,1 +2969,1 @@\n-  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n@@ -3088,2 +3311,1 @@\n-  \/\/ Remember to strip ACC_SUPER bit\n-  return (access & (~JVM_ACC_SUPER)) & JVM_ACC_WRITTEN_FLAGS;\n+  return (access & JVM_ACC_WRITTEN_FLAGS);\n@@ -3346,1 +3568,4 @@\n-static void print_vtable(intptr_t* start, int len, outputStream* st) {\n+static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {\n+  ResourceMark rm;\n+  int* forward_refs = NEW_RESOURCE_ARRAY(int, len);\n+  for (int i = 0; i < len; i++)  forward_refs[i] = 0;\n@@ -3350,0 +3575,5 @@\n+    if (forward_refs[i] != 0) {\n+      int from = forward_refs[i];\n+      int off = (int) start[from];\n+      st->print(\" (offset %d <= [%d])\", off, from);\n+    }\n@@ -3353,0 +3583,6 @@\n+    } else if (self != NULL && e > 0 && e < 0x10000) {\n+      address location = self + e;\n+      int index = (int)((intptr_t*)location - start);\n+      st->print(\" (offset %d => [%d])\", (int)e, index);\n+      if (index >= 0 && index < len)\n+        forward_refs[index] = i;\n@@ -3359,1 +3595,22 @@\n-  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n+  return print_vtable(NULL, reinterpret_cast<intptr_t*>(start), len, st);\n+}\n+\n+template<typename T>\n+ static void print_array_on(outputStream* st, Array<T>* array) {\n+   if (array == NULL) { st->print_cr(\"NULL\"); return; }\n+   array->print_value_on(st); st->cr();\n+   if (Verbose || WizardMode) {\n+     for (int i = 0; i < array->length(); i++) {\n+       st->print(\"%d : \", i); array->at(i)->print_value_on(st); st->cr();\n+     }\n+   }\n+ }\n+\n+static void print_array_on(outputStream* st, Array<int>* array) {\n+  if (array == NULL) { st->print_cr(\"NULL\"); return; }\n+  array->print_value_on(st); st->cr();\n+  if (Verbose || WizardMode) {\n+    for (int i = 0; i < array->length(); i++) {\n+      st->print(\"%d : %d\", i, array->at(i)); st->cr();\n+    }\n+  }\n@@ -3373,0 +3630,1 @@\n+  st->print(BULLET\"misc flags:        0x%x\", _misc_status.flags());               st->cr();\n@@ -3399,15 +3657,3 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);                  st->cr();\n-  if (Verbose || WizardMode) {\n-    Array<Method*>* method_array = methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-    }\n-  }\n-  st->print(BULLET\"method ordering:   \"); method_ordering()->print_value_on(st);      st->cr();\n-  st->print(BULLET\"default_methods:   \"); default_methods()->print_value_on(st);      st->cr();\n-  if (Verbose && default_methods() != NULL) {\n-    Array<Method*>* method_array = default_methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-    }\n-  }\n+  st->print(BULLET\"methods:           \"); print_array_on(st, methods());\n+  st->print(BULLET\"method ordering:   \"); print_array_on(st, method_ordering());\n+  st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n@@ -3415,1 +3661,1 @@\n-    st->print(BULLET\"default vtable indices:   \"); default_vtable_indices()->print_value_on(st);       st->cr();\n+    st->print(BULLET\"default vtable indices:   \"); print_array_on(st, default_vtable_indices());\n@@ -3417,2 +3663,2 @@\n-  st->print(BULLET\"local interfaces:  \"); local_interfaces()->print_value_on(st);      st->cr();\n-  st->print(BULLET\"trans. interfaces: \"); transitive_interfaces()->print_value_on(st); st->cr();\n+  st->print(BULLET\"local interfaces:  \"); print_array_on(st, local_interfaces());\n+  st->print(BULLET\"trans. interfaces: \"); print_array_on(st, transitive_interfaces());\n@@ -3464,0 +3710,1 @@\n+  st->print(BULLET\"preload classes:     \"); preload_classes()->print_value_on(st); st->cr();\n@@ -3474,1 +3721,1 @@\n-  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);\n+  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":290,"deletions":43,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -54,0 +55,2 @@\n+\/\/    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true\n+\/\/    [EMBEDDED InlineKlassFixedBlock] only if is an InlineKlass instance\n@@ -70,0 +73,1 @@\n+class BufferedInlineTypeBlob;\n@@ -130,0 +134,17 @@\n+class SigEntry;\n+\n+class InlineKlassFixedBlock {\n+  Array<SigEntry>** _extended_sig;\n+  Array<VMRegPair>** _return_regs;\n+  address* _pack_handler;\n+  address* _pack_handler_jobject;\n+  address* _unpack_handler;\n+  int* _default_value_offset;\n+  ArrayKlass** _null_free_inline_array_klasses;\n+  int _alignment;\n+  int _first_field_offset;\n+  int _exact_size_in_bytes;\n+\n+  friend class InlineKlass;\n+};\n+\n@@ -135,0 +156,1 @@\n+  friend class TemplateTable;\n@@ -169,1 +191,1 @@\n-  ObjArrayKlass* volatile _array_klasses;\n+  ArrayKlass* volatile _array_klasses;\n@@ -288,0 +310,3 @@\n+  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, NULL if none present\n+  Array<u2>* _preload_classes;\n+  const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n@@ -339,0 +364,28 @@\n+  bool has_inline_type_fields() const { return _misc_status.has_inline_type_fields(); }\n+  void set_has_inline_type_fields()   { _misc_status.set_has_inline_type_fields(true); }\n+\n+  bool is_empty_inline_type() const   { return _misc_status.is_empty_inline_type(); }\n+  void set_is_empty_inline_type()     { _misc_status.set_is_empty_inline_type(true); }\n+\n+  \/\/ Note:  The naturally_atomic property only applies to\n+  \/\/ inline classes; it is never true on identity classes.\n+  \/\/ The bit is placed on instanceKlass for convenience.\n+\n+  \/\/ Query if h\/w provides atomic load\/store for instances.\n+  bool is_naturally_atomic() const  { return _misc_status.is_naturally_atomic(); }\n+  void set_is_naturally_atomic()    { _misc_status.set_is_naturally_atomic(true); }\n+\n+  \/\/ Query if this class implements jl.NonTearable or was\n+  \/\/ mentioned in the JVM option ForceNonTearable.\n+  \/\/ This bit can occur anywhere, but is only significant\n+  \/\/ for inline classes *and* their super types.\n+  \/\/ It inherits from supers along with NonTearable.\n+  bool is_declared_atomic() const { return _misc_status.is_declared_atomic(); }\n+  void set_is_declared_atomic()   { _misc_status.set_is_declared_atomic(true); }\n+\n+  bool carries_value_modifier() const { return _misc_status.carries_value_modifier(); }\n+  void set_carries_value_modifier()   { _misc_status.set_carries_value_modifier(true); }\n+\n+  bool carries_identity_modifier() const  { return _misc_status.carries_identity_modifier(); }\n+  void set_carries_identity_modifier()    { _misc_status.set_carries_identity_modifier(true); }\n+\n@@ -354,3 +407,3 @@\n-  ObjArrayKlass* array_klasses() const     { return _array_klasses; }\n-  inline ObjArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n-  inline void release_set_array_klasses(ObjArrayKlass* k); \/\/ store with release semantics\n+  ArrayKlass* array_klasses() const     { return _array_klasses; }\n+  inline ArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n+  inline void release_set_array_klasses(ArrayKlass* k); \/\/ store with release semantics\n@@ -400,0 +453,2 @@\n+  bool    field_is_inlined(int index) const { return field(index)->is_inlined(); }\n+  bool    field_is_null_free_inline_type(int index) const;\n@@ -411,0 +466,3 @@\n+  Array<u2>* preload_classes() const { return _preload_classes; }\n+  void set_preload_classes(Array<u2>* c) { _preload_classes = c; }\n+\n@@ -542,0 +600,3 @@\n+  static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }\n+  static ByteSize misc_status_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_status)); }\n+\n@@ -884,0 +945,3 @@\n+  static ByteSize inline_type_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _inline_type_field_klasses)); }\n+  static ByteSize adr_inlineklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_inlineklass_fixed_block)); }\n+\n@@ -939,1 +1003,2 @@\n-                  bool is_interface) {\n+                  bool is_interface,\n+                  int java_fields, bool is_inline_type) {\n@@ -944,1 +1009,3 @@\n-           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0));\n+           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0) +\n+           (java_fields * (int)sizeof(Klass*)\/wordSize) +\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n@@ -950,1 +1017,3 @@\n-                                               is_interface());\n+                                               is_interface(),\n+                                               has_inline_type_fields() ? java_fields_count() : 0,\n+                                               is_inline_klass());\n@@ -958,0 +1027,1 @@\n+  bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;\n@@ -964,0 +1034,6 @@\n+  inline address adr_inline_type_field_klasses() const;\n+  inline Klass* get_inline_type_field_klass(int idx) const;\n+  inline Klass* get_inline_type_field_klass_or_null(int idx) const;\n+  inline void set_inline_type_field_klass(int idx, Klass* k);\n+  inline void reset_inline_type_field_klass(int idx);\n+\n@@ -965,1 +1041,1 @@\n-  int size_helper() const {\n+  virtual int size_helper() const {\n@@ -1019,0 +1095,1 @@\n+  const char* signature_name_of_carrier(char c) const;\n@@ -1140,1 +1217,1 @@\n-  void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n+  virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":86,"deletions":9,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -48,1 +48,12 @@\n-    flag(has_contended_annotations          , 1 << 13) \/* has @Contended annotation *\/\n+    flag(has_contended_annotations          , 1 << 13) \/* has @Contended annotation *\/ \\\n+    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(is_empty_inline_type               , 1 << 15) \/* empty inline type (*) *\/ \\\n+    flag(is_naturally_atomic                , 1 << 16) \/* loaded\/stored in one instruction *\/ \\\n+    flag(is_declared_atomic                 , 1 << 17) \/* Listed -XX:ForceNonTearable=clist option *\/ \\\n+    flag(carries_value_modifier             , 1 << 18) \/* the class or one of its super types has the ACC_VALUE modifier *\/ \\\n+    flag(carries_identity_modifier          , 1 << 19) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/\n+\n+  \/* (*) An inline type is considered empty if it contains no non-static fields or\n+     if it contains only empty inline fields. Note that JITs have a slightly different\n+     definition: empty inline fields must be flattened otherwise the container won't\n+     be considered empty *\/\n@@ -61,1 +72,1 @@\n-  u2 _flags;\n+  u4 _flags;\n@@ -88,0 +99,6 @@\n+\n+  u4 flags() const { return _flags; }\n+\n+  static u4 is_empty_inline_type_value() {\n+    return _misc_is_empty_inline_type;\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlassMiscStatus.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -203,1 +203,2 @@\n-                           _shared_class_path_index(-1) {\n+                               _prototype_header(markWord::prototype()),\n+                               _shared_class_path_index(-1) {\n@@ -217,1 +218,1 @@\n-  int lh = array_layout_helper(tag, hsize, etype, exact_log2(esize));\n+  int lh = array_layout_helper(tag, false, hsize, etype, exact_log2(esize));\n@@ -747,0 +748,2 @@\n+     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  InlineKlassKind,\n@@ -48,0 +49,1 @@\n+  FlatArrayKlassKind,\n@@ -102,1 +104,1 @@\n-  \/\/    tag is 0x80 if the elements are oops, 0xC0 if non-oops\n+  \/\/    tag is 0x80 if the elements are oops, 0xC0 if non-oops, 0xA0 if value types\n@@ -168,0 +170,1 @@\n+  markWord _prototype_header;  \/\/ inline type and inline array mark patterns\n@@ -397,1 +400,1 @@\n-  static const int _lh_array_tag_bits          = 2;\n+  static const int _lh_array_tag_bits          = 3;\n@@ -399,2 +402,10 @@\n-  static const int _lh_array_tag_obj_value     = ~0x01;   \/\/ 0x80000000 >> 30\n-  static const unsigned int _lh_array_tag_type_value = 0Xffffffff; \/\/ ~0x00,  \/\/ 0xC0000000 >> 30\n+  static const unsigned int _lh_array_tag_type_value = 0Xfffffffc;\n+  static const unsigned int _lh_array_tag_vt_value   = 0Xfffffffd;\n+  static const unsigned int _lh_array_tag_obj_value  = 0Xfffffffe;\n+\n+  \/\/ null-free array flag bit under the array tag bits, shift one more to get array tag value\n+  static const int _lh_null_free_shift = _lh_array_tag_shift - 1;\n+  static const int _lh_null_free_mask  = 1;\n+\n+  static const jint _lh_array_tag_flat_value_bit_inplace = (jint) (1 << _lh_array_tag_shift);\n+  static const jint _lh_null_free_array_bit_inplace = (jint) (_lh_null_free_mask << _lh_null_free_shift);\n@@ -418,2 +429,1 @@\n-    \/\/ _lh_array_tag_type_value == (lh >> _lh_array_tag_shift);\n-    return (juint)lh >= (juint)(_lh_array_tag_type_value << _lh_array_tag_shift);\n+    return (juint) _lh_array_tag_type_value == (juint)(lh >> _lh_array_tag_shift);\n@@ -422,2 +432,13 @@\n-    \/\/ _lh_array_tag_obj_value == (lh >> _lh_array_tag_shift);\n-    return (jint)lh < (jint)(_lh_array_tag_type_value << _lh_array_tag_shift);\n+    return (juint)_lh_array_tag_obj_value == (juint)(lh >> _lh_array_tag_shift);\n+  }\n+  static bool layout_helper_is_flatArray(jint lh) {\n+    return (juint)_lh_array_tag_vt_value == (juint)(lh >> _lh_array_tag_shift);\n+  }\n+  static bool layout_helper_is_null_free(jint lh) {\n+    assert(layout_helper_is_flatArray(lh) || layout_helper_is_objArray(lh), \"must be array of inline types\");\n+    return ((lh >> _lh_null_free_shift) & _lh_null_free_mask);\n+  }\n+  static jint layout_helper_set_null_free(jint lh) {\n+    lh |= (_lh_null_free_mask << _lh_null_free_shift);\n+    assert(layout_helper_is_null_free(lh), \"Bad encoding\");\n+    return lh;\n@@ -434,1 +455,1 @@\n-    assert(btvalue >= T_BOOLEAN && btvalue <= T_OBJECT, \"sanity\");\n+    assert((btvalue >= T_BOOLEAN && btvalue <= T_OBJECT) || btvalue == T_PRIMITIVE_OBJECT, \"sanity\");\n@@ -455,1 +476,1 @@\n-    assert(l2esz <= LogBytesPerLong,\n+    assert(layout_helper_element_type(lh) == T_PRIMITIVE_OBJECT || l2esz <= LogBytesPerLong,\n@@ -459,1 +480,1 @@\n-  static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {\n+  static jint array_layout_helper(jint tag, bool null_free, int hsize, BasicType etype, int log2_esize) {\n@@ -461,0 +482,1 @@\n+      |    ((null_free ? 1 : 0) <<  _lh_null_free_shift)\n@@ -613,0 +635,1 @@\n+  virtual bool is_flatArray_klass_slow()    const { return false; }\n@@ -614,0 +637,2 @@\n+  \/\/ current implementation uses this method even in non debug builds\n+  virtual bool is_inline_klass_slow()       const { return false; }\n@@ -629,0 +654,1 @@\n+  bool is_inline_klass()                const { return is_inline_klass_slow(); } \/\/temporary hack\n@@ -630,1 +656,1 @@\n-  bool is_other_instance_klass()        const { return _kind == InstanceKlassKind; }\n+  bool is_other_instance_klass()        const { return _kind <= InlineKlassKind; }\n@@ -636,0 +662,1 @@\n+  bool is_flatArray_klass()             const { return assert_same_query( _kind == FlatArrayKlassKind, is_flatArray_klass_slow()); }\n@@ -640,0 +667,2 @@\n+  inline bool is_null_free_array_klass()      const { return layout_helper_is_null_free(layout_helper()); }\n+\n@@ -648,1 +677,2 @@\n-  bool is_super() const                 { return _access_flags.is_super(); }\n+  bool is_value_class() const           { return _access_flags.is_value_class(); }\n+  bool is_identity_class() const        { return _access_flags.is_identity_class(); }\n@@ -671,0 +701,11 @@\n+  \/\/ inline types and inline type array patterns\n+  markWord prototype_header() const {\n+    return _prototype_header;\n+  }\n+  static inline markWord default_prototype_header(Klass* k) {\n+    return (k == NULL) ? markWord::prototype() : k->prototype_header();\n+  }\n+\n+  inline void set_prototype_header(markWord header);\n+  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1232,3 +1232,4 @@\n-  if (m->is_static())           return false;   \/\/ e.g., Stream.empty\n-  if (m->is_initializer())      return false;   \/\/ <init> or <clinit>\n-  if (m->is_private())          return false;   \/\/ uses direct call\n+  if (m->is_static())             return false;   \/\/ e.g., Stream.empty\n+  if (m->is_private())            return false;   \/\/ uses direct call\n+  if (m->is_object_constructor()) return false;   \/\/ <init>(...)V\n+  if (m->is_class_initializer())  return false;   \/\/ <clinit>()V\n@@ -1443,0 +1444,12 @@\n+int count_interface_methods_needing_itable_index(Array<Method*>* methods) {\n+  int method_count = 0;\n+  if (methods->length() > 0) {\n+    for (int i = methods->length(); --i >= 0; ) {\n+      if (interface_method_needs_itable_index(methods->at(i))) {\n+        method_count++;\n+      }\n+    }\n+  }\n+  return method_count;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -123,1 +124,0 @@\n-\n@@ -162,0 +162,5 @@\n+address Method::get_c2i_inline_entry() {\n+  assert(adapter() != NULL, \"must have\");\n+  return adapter()->get_c2i_inline_entry();\n+}\n+\n@@ -167,0 +172,5 @@\n+address Method::get_c2i_unverified_inline_entry() {\n+  assert(adapter() != NULL, \"must have\");\n+  return adapter()->get_c2i_unverified_inline_entry();\n+}\n+\n@@ -673,0 +683,13 @@\n+\/\/ InlineKlass the method is declared to return. This must not\n+\/\/ safepoint as it is called with references live on the stack at\n+\/\/ locations the GC is unaware of.\n+InlineKlass* Method::returns_inline_type(Thread* thread) const {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  NoSafepointVerifier nsv;\n+  SignatureStream ss(signature());\n+  while (!ss.at_return_type()) {\n+    ss.next();\n+  }\n+  return ss.as_inline_klass(method_holder());\n+}\n+\n@@ -678,1 +701,1 @@\n-  \/\/   aload_0\n+  \/\/   aload_0, _fast_aload_0, or _nofast_aload_0\n@@ -702,1 +725,2 @@\n-  if (cb[0] != Bytecodes::_aload_0 || cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {\n+  if ((cb[0] != Bytecodes::_aload_0 && cb[0] != Bytecodes::_fast_aload_0 && cb[0] != Bytecodes::_nofast_aload_0) ||\n+       cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {\n@@ -860,0 +884,5 @@\n+  if (has_scalarized_return()) {\n+    \/\/ Don't treat this as (trivial) getter method because the\n+    \/\/ inline type should be returned in a scalarized form.\n+    return false;\n+  }\n@@ -881,0 +910,5 @@\n+  if (has_scalarized_args()) {\n+    \/\/ Don't treat this as (trivial) setter method because the\n+    \/\/ inline type argument should be passed in a scalarized form.\n+    return false;\n+  }\n@@ -891,1 +925,2 @@\n-          Bytecodes::is_return(java_code_at(last_index)));\n+          Bytecodes::is_return(java_code_at(last_index)) &&\n+          !has_scalarized_args());\n@@ -894,2 +929,2 @@\n-bool Method::is_initializer() const {\n-  return is_object_initializer() || is_static_initializer();\n+bool Method::is_object_constructor_or_class_initializer() const {\n+  return (is_object_constructor() || is_class_initializer());\n@@ -898,6 +933,1 @@\n-bool Method::has_valid_initializer_flags() const {\n-  return (is_static() ||\n-          method_holder()->major_version() < 51);\n-}\n-\n-bool Method::is_static_initializer() const {\n+bool Method::is_class_initializer() const {\n@@ -907,2 +937,3 @@\n-  return name() == vmSymbols::class_initializer_name() &&\n-         has_valid_initializer_flags();\n+  return (name() == vmSymbols::class_initializer_name() &&\n+          (is_static() ||\n+           method_holder()->major_version() < 51));\n@@ -911,2 +942,8 @@\n-bool Method::is_object_initializer() const {\n-   return name() == vmSymbols::object_initializer_name();\n+\/\/ A method named <init>, is a classic object constructor.\n+bool Method::is_object_constructor() const {\n+  return name() == vmSymbols::object_initializer_name();\n+}\n+\n+\/\/ A method named <vnew> is a factory for an inline class.\n+bool Method::is_static_vnew_factory() const {\n+  return name() == vmSymbols::inline_factory_name();\n@@ -970,1 +1007,1 @@\n-  if( constants()->tag_at(klass_index).is_unresolved_klass() ) {\n+  if( constants()->tag_at(klass_index).is_unresolved_klass()) {\n@@ -986,1 +1023,3 @@\n-    if (constants()->tag_at(klass_index).is_unresolved_klass()) return false;\n+    if (constants()->tag_at(klass_index).is_unresolved_klass()) {\n+      return false;\n+    }\n@@ -1155,0 +1194,2 @@\n+    _from_compiled_inline_entry = NULL;\n+    _from_compiled_inline_ro_entry = NULL;\n@@ -1157,0 +1198,2 @@\n+    _from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1188,0 +1231,2 @@\n+  _from_compiled_inline_entry = NULL;\n+  _from_compiled_inline_ro_entry = NULL;\n@@ -1226,0 +1271,3 @@\n+  if (InlineTypeReturnedAsFields && returns_inline_type(THREAD)) {\n+    set_has_scalarized_return(true);\n+  }\n@@ -1265,0 +1313,2 @@\n+  mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n+  mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n@@ -1281,0 +1331,12 @@\n+address Method::verified_inline_code_entry() {\n+  debug_only(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_entry != NULL, \"must be set\");\n+  return _from_compiled_inline_entry;\n+}\n+\n+address Method::verified_inline_ro_code_entry() {\n+  debug_only(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_ro_entry != NULL, \"must be set\");\n+  return _from_compiled_inline_ro_entry;\n+}\n+\n@@ -1312,0 +1374,2 @@\n+  mh->_from_compiled_inline_entry = code->verified_inline_entry_point();\n+  mh->_from_compiled_inline_ro_entry = code->verified_inline_ro_entry_point();\n@@ -2310,0 +2374,25 @@\n+bool Method::is_scalarized_arg(int idx) const {\n+  if (!has_scalarized_args()) {\n+    return false;\n+  }\n+  \/\/ Search through signature and check if argument is wrapped in T_PRIMITIVE_OBJECT\/T_VOID\n+  int depth = 0;\n+  const GrowableArray<SigEntry>* sig = adapter()->get_sig_cc();\n+  for (int i = 0; i < sig->length(); i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      depth++;\n+    }\n+    if (idx == 0) {\n+      break; \/\/ Argument found\n+    }\n+    if (bt == T_VOID && (sig->at(i-1)._bt != T_LONG && sig->at(i-1)._bt != T_DOUBLE)) {\n+      depth--;\n+    }\n+    if (depth == 0 && bt != T_LONG && bt != T_DOUBLE) {\n+      idx--; \/\/ Advance to next argument\n+    }\n+  }\n+  return depth != 0;\n+}\n+\n@@ -2341,0 +2430,4 @@\n+#ifdef ASSERT\n+  if (valid_itable_index())\n+    st->print_cr(\" - itable index:      %d\",   itable_index());\n+#endif\n@@ -2348,1 +2441,3 @@\n-  st->print_cr(\" - compiled entry     \" PTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled entry           \" PTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled inline entry    \" PTR_FORMAT, p2i(from_compiled_inline_entry()));\n+  st->print_cr(\" - compiled inline ro entry \" PTR_FORMAT, p2i(from_compiled_inline_ro_entry()));\n@@ -2418,0 +2513,1 @@\n+  if (WizardMode) access_flags().print_on(st);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":115,"deletions":19,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -94,3 +94,7 @@\n-    _scoped                 = 1 << 7,\n-    _changes_current_thread = 1 << 8,\n-    _jvmti_mount_transition = 1 << 9,\n+    _scalarized_args        = 1 << 7,\n+    _scalarized_return      = 1 << 8,\n+    _c1_needs_stack_repair  = 1 << 9,\n+    _c2_needs_stack_repair  = 1 << 10,\n+    _scoped                 = 1 << 11,\n+    _changes_current_thread = 1 << 12,\n+    _jvmti_mount_transition = 1 << 13,\n@@ -111,1 +115,3 @@\n-  volatile address _from_compiled_entry;        \/\/ Cache of: _code ? _code->entry_point() : _adapter->c2i_entry()\n+  volatile address _from_compiled_entry;           \/\/ Cache of: _code ? _code->verified_entry_point()           : _adapter->c2i_entry()\n+  volatile address _from_compiled_inline_ro_entry; \/\/ Cache of: _code ? _code->verified_inline_ro_entry_point() : _adapter->c2i_inline_ro_entry()\n+  volatile address _from_compiled_inline_entry;    \/\/ Cache of: _code ? _code->verified_inline_entry_point()    : _adapter->c2i_inline_entry()\n@@ -150,0 +156,2 @@\n+  address from_compiled_inline_ro_entry() const;\n+  address from_compiled_inline_entry() const;\n@@ -431,0 +439,2 @@\n+  address verified_inline_code_entry();\n+  address verified_inline_ro_code_entry();\n@@ -449,1 +459,7 @@\n-    _from_compiled_entry =  entry;\n+    _from_compiled_entry = entry;\n+  }\n+  void set_from_compiled_inline_ro_entry(address entry) {\n+    _from_compiled_inline_ro_entry = entry;\n+  }\n+  void set_from_compiled_inline_entry(address entry) {\n+    _from_compiled_inline_entry = entry;\n@@ -454,0 +470,1 @@\n+  address get_c2i_inline_entry();\n@@ -455,0 +472,1 @@\n+  address get_c2i_unverified_inline_entry();\n@@ -568,1 +586,1 @@\n-  bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }\n+  InlineKlass* returns_inline_type(Thread* thread) const;\n@@ -643,6 +661,0 @@\n-  \/\/ returns true if the method is an initializer (<init> or <clinit>).\n-  bool is_initializer() const;\n-\n-  \/\/ returns true if the method is static OR if the classfile version < 51\n-  bool has_valid_initializer_flags() const;\n-\n@@ -651,1 +663,8 @@\n-  bool is_static_initializer() const;\n+  bool is_class_initializer() const;\n+\n+  \/\/ returns true if the method name is <init> and the method is not a static factory\n+  bool is_object_constructor() const;\n+\n+  \/\/ returns true if the method is an object constructor or class initializer\n+  \/\/ (non-static <init> or <clinit>), but false for factories (static <vnew>).\n+  bool is_object_constructor_or_class_initializer() const;\n@@ -653,2 +672,2 @@\n-  \/\/ returns true if the method name is <init>\n-  bool is_object_initializer() const;\n+  \/\/ returns true if the method name is <vnew> and the method is static\n+  bool is_static_vnew_factory() const;\n@@ -676,0 +695,2 @@\n+  static ByteSize from_compiled_inline_offset()  { return byte_offset_of(Method, _from_compiled_inline_entry); }\n+  static ByteSize from_compiled_inline_ro_offset(){ return byte_offset_of(Method, _from_compiled_inline_ro_entry); }\n@@ -677,0 +698,1 @@\n+  static ByteSize flags_offset()                 { return byte_offset_of(Method, _flags); }\n@@ -896,0 +918,34 @@\n+  bool has_scalarized_args() const {\n+    return (_flags & _scalarized_args) != 0;\n+  }\n+\n+  void set_has_scalarized_args(bool x) {\n+    _flags = x ? (_flags | _scalarized_args) : (_flags & ~_scalarized_args);\n+  }\n+\n+  bool has_scalarized_return() const {\n+    return (_flags & _scalarized_return) != 0;\n+  }\n+\n+  void set_has_scalarized_return(bool x) {\n+    _flags = x ? (_flags | _scalarized_return) : (_flags & ~_scalarized_return);\n+  }\n+\n+  bool is_scalarized_arg(int idx) const;\n+\n+  bool c1_needs_stack_repair() {\n+    return (_flags & _c1_needs_stack_repair) != 0;\n+  }\n+\n+  bool c2_needs_stack_repair() {\n+    return (_flags & _c2_needs_stack_repair) != 0;\n+  }\n+\n+  void set_c1_needs_stack_repair(bool x) {\n+    _flags = x ? (_flags | _c1_needs_stack_repair) : (_flags & ~_c1_needs_stack_repair);\n+  }\n+\n+  void set_c2_needs_stack_repair(bool x) {\n+    _flags = x ? (_flags | _c2_needs_stack_repair) : (_flags & ~_c2_needs_stack_repair);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":71,"deletions":15,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    st->print(\"flags(%d) \", flags);\n+    st->print(\"flags(%d) %p\/%d\", flags, data(), in_bytes(DataLayout::flags_offset()));\n@@ -213,1 +213,1 @@\n-  assert(TypeStackSlotEntries::per_arg_count() > ReturnTypeEntry::static_cell_count(), \"code to test for arguments\/results broken\");\n+  assert(TypeStackSlotEntries::per_arg_count() > SingleTypeEntry::static_cell_count(), \"code to test for arguments\/results broken\");\n@@ -223,1 +223,1 @@\n-    ret_cell = ReturnTypeEntry::static_cell_count();\n+    ret_cell = SingleTypeEntry::static_cell_count();\n@@ -326,1 +326,1 @@\n-void ReturnTypeEntry::clean_weak_klass_links(bool always_clean) {\n+void SingleTypeEntry::clean_weak_klass_links(bool always_clean) {\n@@ -364,1 +364,1 @@\n-void ReturnTypeEntry::print_data_on(outputStream* st) const {\n+void SingleTypeEntry::print_data_on(outputStream* st) const {\n@@ -529,0 +529,4 @@\n+  if (data()->flags()) {\n+    tty->cr();\n+    tab(st);\n+  }\n@@ -654,0 +658,21 @@\n+void ArrayLoadStoreData::print_data_on(outputStream* st, const char* extra) const {\n+  print_shared(st, \"ArrayLoadStore\", extra);\n+  st->cr();\n+  tab(st, true);\n+  st->print(\"array\");\n+  _array.print_data_on(st);\n+  tab(st, true);\n+  st->print(\"element\");\n+  _element.print_data_on(st);\n+}\n+\n+void ACmpData::print_data_on(outputStream* st, const char* extra) const {\n+  BranchData::print_data_on(st, extra);\n+  tab(st, true);\n+  st->print(\"left\");\n+  _left.print_data_on(st);\n+  tab(st, true);\n+  st->print(\"right\");\n+  _right.print_data_on(st);\n+}\n+\n@@ -675,1 +700,0 @@\n-  case Bytecodes::_aastore:\n@@ -681,0 +705,3 @@\n+  case Bytecodes::_aaload:\n+  case Bytecodes::_aastore:\n+    return ArrayLoadStoreData::static_cell_count();\n@@ -720,2 +747,0 @@\n-  case Bytecodes::_if_acmpeq:\n-  case Bytecodes::_if_acmpne:\n@@ -725,0 +750,3 @@\n+  case Bytecodes::_if_acmpne:\n+  case Bytecodes::_if_acmpeq:\n+    return ACmpData::static_cell_count();\n@@ -783,0 +811,1 @@\n+  case Bytecodes::_aaload:\n@@ -986,1 +1015,0 @@\n-  case Bytecodes::_aastore:\n@@ -995,0 +1023,5 @@\n+  case Bytecodes::_aaload:\n+  case Bytecodes::_aastore:\n+    cell_count = ArrayLoadStoreData::static_cell_count();\n+    tag = DataLayout::array_load_store_data_tag;\n+    break;\n@@ -1066,2 +1099,0 @@\n-  case Bytecodes::_if_acmpeq:\n-  case Bytecodes::_if_acmpne:\n@@ -1073,0 +1104,5 @@\n+  case Bytecodes::_if_acmpeq:\n+  case Bytecodes::_if_acmpne:\n+    cell_count = ACmpData::static_cell_count();\n+    tag = DataLayout::acmp_data_tag;\n+    break;\n@@ -1140,0 +1176,4 @@\n+  case DataLayout::array_load_store_data_tag:\n+    return ((new ArrayLoadStoreData(this))->cell_count());\n+  case DataLayout::acmp_data_tag:\n+    return ((new ACmpData(this))->cell_count());\n@@ -1174,0 +1214,4 @@\n+  case DataLayout::array_load_store_data_tag:\n+    return new ArrayLoadStoreData(this);\n+  case DataLayout::acmp_data_tag:\n+    return new ACmpData(this);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":55,"deletions":11,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  return !SafepointSynchronize::is_at_safepoint();\n+  return !SafepointSynchronize::is_at_safepoint() ;\n@@ -140,6 +140,8 @@\n-bool oopDesc::is_instance_noinline()    const { return is_instance();    }\n-bool oopDesc::is_instanceRef_noinline() const { return is_instanceRef(); }\n-bool oopDesc::is_stackChunk_noinline()  const { return is_stackChunk();  }\n-bool oopDesc::is_array_noinline()       const { return is_array();       }\n-bool oopDesc::is_objArray_noinline()    const { return is_objArray();    }\n-bool oopDesc::is_typeArray_noinline()   const { return is_typeArray();   }\n+bool oopDesc::is_instance_noinline()        const { return is_instance();         }\n+bool oopDesc::is_instanceRef_noinline()     const { return is_instanceRef();      }\n+bool oopDesc::is_stackChunk_noinline()      const { return is_stackChunk();       }\n+bool oopDesc::is_array_noinline()           const { return is_array();            }\n+bool oopDesc::is_objArray_noinline()        const { return is_objArray();         }\n+bool oopDesc::is_typeArray_noinline()       const { return is_typeArray();        }\n+bool oopDesc::is_flatArray_noinline()       const { return is_flatArray();        }\n+bool oopDesc::is_null_free_array_noinline() const { return is_null_free_array();  }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,10 @@\n+\/\/\n+\/\/ oopDesc::_mark - the \"oop mark word\" encoding to be found separately in markWord.hpp\n+\/\/\n+\/\/ oopDesc::_metadata - encodes the object's klass pointer, as a raw pointer in \"_klass\"\n+\/\/                      or compressed pointer in \"_compressed_klass\"\n+\/\/\n+\/\/ The overall size of the _metadata field is dependent on \"UseCompressedClassPointers\",\n+\/\/ hence the terms \"narrow\" (32 bits) vs \"wide\" (64 bits).\n+\/\/\n+\n@@ -110,6 +120,9 @@\n-  inline bool is_instance()    const;\n-  inline bool is_instanceRef() const;\n-  inline bool is_stackChunk()  const;\n-  inline bool is_array()       const;\n-  inline bool is_objArray()    const;\n-  inline bool is_typeArray()   const;\n+  inline bool is_instance()         const;\n+  inline bool is_inline_type()      const;\n+  inline bool is_instanceRef()      const;\n+  inline bool is_stackChunk()       const;\n+  inline bool is_array()            const;\n+  inline bool is_objArray()         const;\n+  inline bool is_typeArray()        const;\n+  inline bool is_flatArray()        const;\n+  inline bool is_null_free_array()  const;\n@@ -118,6 +131,8 @@\n-  bool is_instance_noinline()    const;\n-  bool is_instanceRef_noinline() const;\n-  bool is_stackChunk_noinline()  const;\n-  bool is_array_noinline()       const;\n-  bool is_objArray_noinline()    const;\n-  bool is_typeArray_noinline()   const;\n+  bool is_instance_noinline()         const;\n+  bool is_instanceRef_noinline()      const;\n+  bool is_stackChunk_noinline()       const;\n+  bool is_array_noinline()            const;\n+  bool is_objArray_noinline()         const;\n+  bool is_typeArray_noinline()        const;\n+  bool is_flatArray_noinline()        const;\n+  bool is_null_free_array_noinline()  const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  set_mark(markWord::prototype());\n+  set_mark(Klass::default_prototype_header(klass()));\n@@ -199,0 +199,15 @@\n+bool oopDesc::is_inline_type() const { return mark().is_inline_type(); }\n+#ifdef _LP64\n+bool oopDesc::is_flatArray() const {\n+  markWord mrk = mark();\n+  return (mrk.is_unlocked()) ? mrk.is_flat_array() : klass()->is_flatArray_klass();\n+}\n+bool oopDesc::is_null_free_array() const {\n+  markWord mrk = mark();\n+  return (mrk.is_unlocked()) ? mrk.is_null_free_array() : klass()->is_null_free_array_klass();\n+}\n+#else\n+bool oopDesc::is_flatArray()       const { return klass()->is_flatArray_klass(); }\n+bool oopDesc::is_null_free_array() const { return klass()->is_null_free_array_klass(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-      if( t->is_ptr()->_offset == 0 ) { \/\/ Not derived?\n+      if (t->is_ptr()->offset() == 0) { \/\/ Not derived?\n@@ -262,1 +262,1 @@\n-          uint cnt = mcall->tf()->domain()->cnt();\n+          uint cnt = mcall->tf()->domain_cc()->cnt();\n@@ -328,1 +328,1 @@\n-        uint cnt = mcall->tf()->domain()->cnt();\n+        uint cnt = mcall->tf()->domain_cc()->cnt();\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -757,0 +757,6 @@\n+  product(bool, UseArrayLoadStoreProfile, true,                             \\\n+          \"Take advantage of profiling at array load\/store\")                \\\n+                                                                            \\\n+  product(bool, UseACmpProfile, true,                                       \\\n+          \"Take advantage of profiling at acmp\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -596,0 +596,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:\n+  case vmIntrinsics::_finishPrivateBuffer:\n@@ -605,0 +607,1 @@\n+  case vmIntrinsics::_getValue:\n@@ -614,0 +617,1 @@\n+  case vmIntrinsics::_putValue:\n@@ -698,0 +702,4 @@\n+  case vmIntrinsics::_asPrimaryType:\n+  case vmIntrinsics::_asPrimaryTypeArg:\n+  case vmIntrinsics::_asValueType:\n+  case vmIntrinsics::_asValueTypeArg:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n@@ -89,0 +88,2 @@\n+  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -397,1 +398,1 @@\n-bool RegionNode::try_clean_mem_phi(PhaseGVN *phase) {\n+Node* PhiNode::try_clean_mem_phi(PhaseGVN *phase) {\n@@ -417,2 +418,1 @@\n-  PhiNode* phi = has_unique_phi();\n-  if (phi && phi->type() == Type::MEMORY && req() == 3 && phi->is_diamond_phi(true)) {\n+  if (type() == Type::MEMORY && is_diamond_phi(true)) {\n@@ -420,1 +420,2 @@\n-    assert(phi->req() == 3, \"same as region\");\n+    assert(req() == 3, \"same as region\");\n+    Node* r = in(0);\n@@ -422,2 +423,2 @@\n-      Node *mem = phi->in(i);\n-      if (mem && mem->is_MergeMem() && in(i)->outcnt() == 1) {\n+      Node *mem = in(i);\n+      if (mem && mem->is_MergeMem() && r->in(i)->outcnt() == 1) {\n@@ -427,1 +428,1 @@\n-        Node* other = phi->in(j);\n+        Node* other = in(j);\n@@ -431,2 +432,1 @@\n-          phase->is_IterGVN()->replace_node(phi, m);\n-          return true;\n+          return m;\n@@ -437,1 +437,1 @@\n-  return false;\n+  return NULL;\n@@ -452,2 +452,9 @@\n-    if (has_phis && try_clean_mem_phi(phase)) {\n-      has_phis = false;\n+    if (has_phis) {\n+      PhiNode* phi = has_unique_phi();\n+      if (phi != NULL) {\n+        Node* m = phi->try_clean_mem_phi(phase);\n+        if (m != NULL) {\n+          phase->is_IterGVN()->replace_node(phi, m);\n+          has_phis = false;\n+        }\n+      }\n@@ -863,1 +870,2 @@\n-             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck()) {\n+             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck() ||\n+             cmp1->is_FlatArrayCheck() || cmp2->is_FlatArrayCheck()) {\n@@ -944,1 +952,1 @@\n-  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), \"flatten at\");\n+  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flattened_accesses_share_alias()), \"flatten at\");\n@@ -1081,0 +1089,8 @@\n+  \/\/ Flat array element shouldn't get their own memory slice until flattened_accesses_share_alias is cleared.\n+  \/\/ It could be the graph has no loads\/stores and flattened_accesses_share_alias is never cleared. EA could still\n+  \/\/ creates per element Phis but that wouldn't be a problem as there are no memory accesses for that array.\n+  assert(_adr_type == NULL || _adr_type->isa_aryptr() == NULL ||\n+         _adr_type->is_aryptr()->is_known_instance() ||\n+         !_adr_type->is_aryptr()->is_flat() ||\n+         !Compile::current()->flattened_accesses_share_alias() ||\n+         _adr_type == TypeAryPtr::INLINES, \"flat array element shouldn't get its own slice yet\");\n@@ -1420,0 +1436,8 @@\n+  if (phase->is_IterGVN()) {\n+    Node* m = try_clean_mem_phi(phase);\n+    if (m != NULL) {\n+      return m;\n+    }\n+  }\n+\n+\n@@ -1942,0 +1966,44 @@\n+\/\/ Push inline type input nodes (and null) down through the phi recursively (can handle data loops).\n+InlineTypeNode* PhiNode::push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init) {\n+  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), is_init);\n+  if (can_reshape) {\n+    \/\/ Replace phi right away to be able to use the inline\n+    \/\/ type node when reaching the phi again through data loops.\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* u = fast_out(i);\n+      igvn->rehash_node_delayed(u);\n+      imax -= u->replace_edge(this, vt);\n+      --i;\n+    }\n+    igvn->rehash_node_delayed(this);\n+    assert(outcnt() == 0, \"should be dead now\");\n+  }\n+  ResourceMark rm;\n+  Node_List casts;\n+  for (uint i = 1; i < req(); ++i) {\n+    Node* n = in(i);\n+    while (n->is_ConstraintCast()) {\n+      casts.push(n);\n+      n = n->in(1);\n+    }\n+    if (phase->type(n)->is_zero_type()) {\n+      n = InlineTypeNode::make_null(*phase, vk);\n+    } else if (n->is_Phi()) {\n+      assert(can_reshape, \"can only handle phis during IGVN\");\n+      n = phase->transform(n->as_Phi()->push_inline_types_through(phase, can_reshape, vk, is_init));\n+    }\n+    while (casts.size() != 0) {\n+      \/\/ Push the cast(s) through the InlineTypeNode\n+      Node* cast = casts.pop()->clone();\n+      cast->set_req_X(1, n->as_InlineType()->get_oop(), phase);\n+      n = n->clone();\n+      n->as_InlineType()->set_oop(phase->transform(cast));\n+      n = phase->transform(n);\n+    }\n+    bool transform = !can_reshape && (i == (req()-1)); \/\/ Transform phis on last merge\n+    vt->merge_with(phase, n->as_InlineType(), i, transform);\n+  }\n+  return vt;\n+}\n+\n@@ -2243,0 +2311,2 @@\n+    \/\/ TODO revisit this with JDK-8247216\n+    bool mergemem_only = true;\n@@ -2255,0 +2325,2 @@\n+      } else {\n+        mergemem_only = false;\n@@ -2259,1 +2331,1 @@\n-    if (!saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n+    if (!mergemem_only && !saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n@@ -2330,0 +2402,5 @@\n+            if (igvn) {\n+              \/\/ TODO revisit this with JDK-8247216\n+              \/\/ Put 'n' on the worklist because it might be modified by MergeMemStream::iteration_setup\n+              igvn->_worklist.push(n);\n+            }\n@@ -2448,0 +2525,78 @@\n+  \/\/ Check recursively if inputs are either an inline type, constant null\n+  \/\/ or another Phi (including self references through data loops). If so,\n+  \/\/ push the inline types down through the phis to enable folding of loads.\n+  if (EnableValhalla && (_type->isa_ptr() || _type->isa_inlinetype()) && req() > 2) {\n+    ResourceMark rm;\n+    Unique_Node_List worklist;\n+    worklist.push(this);\n+    bool can_optimize = true;\n+    ciInlineKlass* vk = NULL;\n+    \/\/ true if all IsInit inputs of all InlineType* nodes are true\n+    bool is_init = true;\n+    Node_List casts;\n+\n+    \/\/ TODO 8284443 We need to prevent endless pushing through\n+    \/\/ TODO 8284443 We could revisit the same node over and over again, right?\n+    \/\/ TestLWorld -XX:+UseZGC -DScenarios=0 -DTest=test69\n+    \/\/ TestLWorld -XX:-TieredCompilation -XX:-DoEscapeAnalysis -XX:+AlwaysIncrementalInline\n+    bool only_phi = (outcnt() != 0);\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* n = fast_out(i);\n+      if (n->is_InlineType() && n->in(1) == this) {\n+        can_optimize = false;\n+        break;\n+      }\n+      if (!n->is_Phi()) {\n+        only_phi = false;\n+      }\n+    }\n+    if (only_phi) {\n+      can_optimize = false;\n+    }\n+    for (uint next = 0; next < worklist.size() && can_optimize; next++) {\n+      Node* phi = worklist.at(next);\n+      for (uint i = 1; i < phi->req() && can_optimize; i++) {\n+        Node* n = phi->in(i);\n+        if (n == NULL) {\n+          can_optimize = false;\n+          break;\n+        }\n+        while (n->is_ConstraintCast()) {\n+          if (n->in(0) != NULL && n->in(0)->is_top()) {\n+            \/\/ Will die, don't optimize\n+            can_optimize = false;\n+            break;\n+          }\n+          casts.push(n);\n+          n = n->in(1);\n+        }\n+        const Type* t = phase->type(n);\n+        if (n->is_InlineType() && (vk == NULL || vk == t->inline_klass())) {\n+          vk = (vk == NULL) ? t->inline_klass() : vk;\n+          if (phase->find_int_con(n->as_InlineType()->get_is_init(), 0) != 1) {\n+            is_init = false;\n+          }\n+        } else if (n->is_Phi() && can_reshape && (n->bottom_type()->isa_ptr() || n->bottom_type()->isa_inlinetype())) {\n+          worklist.push(n);\n+        } else if (t->is_zero_type()) {\n+          is_init = false;\n+        } else {\n+          can_optimize = false;\n+        }\n+      }\n+    }\n+    \/\/ Check if cast nodes can be pushed through\n+    const Type* t = Type::get_const_type(vk);\n+    while (casts.size() != 0 && can_optimize && t != NULL) {\n+      Node* cast = casts.pop();\n+      if (t->filter(cast->bottom_type()) == Type::TOP) {\n+        can_optimize = false;\n+      }\n+    }\n+    if (can_optimize && vk != NULL) {\n+\/\/ TODO 8275400\n+\/\/      assert(!_type->isa_ptr() || _type->maybe_null() || is_init, \"Phi not null but a possible null was seen\");\n+      return push_inline_types_through(phase, can_reshape, vk, is_init);\n+    }\n+  }\n+\n@@ -2540,0 +2695,1 @@\n+\n@@ -2784,0 +2940,6 @@\n+\n+  \/\/ CheckCastPPNode::Ideal() for inline types reuses the exception\n+  \/\/ paths of a call to perform an allocation: we can see a Phi here.\n+  if (in(1)->is_Phi()) {\n+    return this;\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":177,"deletions":15,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  bool try_clean_mem_phi(PhaseGVN* phase);\n@@ -221,0 +220,3 @@\n+  Node* try_clean_mem_phi(PhaseGVN *phase);\n+\n+  InlineTypeNode* push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init);\n@@ -403,0 +405,2 @@\n+  bool is_flat_array_check(PhaseTransform* phase, Node** array = NULL);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+macro(FlatArrayCheck)\n@@ -371,0 +372,1 @@\n+macro(InlineType)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -395,0 +396,3 @@\n+  if (dead->is_InlineType()) {\n+    remove_inline_type(dead);\n+  }\n@@ -435,0 +439,3 @@\n+    if (n->outcnt() == 0) {\n+      worklist->push(n);\n+    }\n@@ -442,0 +449,6 @@\n+  remove_useless_nodes(_inline_type_nodes,  useful); \/\/ remove useless inline type nodes\n+#ifdef ASSERT\n+  if (_modified_nodes != NULL) {\n+    _modified_nodes->remove_useless_nodes(useful.member_set());\n+  }\n+#endif\n@@ -623,0 +636,1 @@\n+                  _inline_type_nodes (comp_arena(), 8, 0, NULL),\n@@ -727,4 +741,2 @@\n-      const TypeTuple *domain = StartOSRNode::osr_domain();\n-      const TypeTuple *range = TypeTuple::make_range(method()->signature());\n-      init_tf(TypeFunc::make(domain, range));\n-      StartNode* s = new StartOSRNode(root(), domain);\n+      init_tf(TypeFunc::make(method(), \/* is_osr_compilation = *\/ true));\n+      StartNode* s = new StartOSRNode(root(), tf()->domain_sig());\n@@ -737,1 +749,1 @@\n-      StartNode* s = new StartNode(root(), tf()->domain());\n+      StartNode* s = new StartNode(root(), tf()->domain_cc());\n@@ -856,0 +868,10 @@\n+  if (needs_stack_repair()) {\n+    \/\/ One extra slot for the special stack increment value\n+    next_slot += 2;\n+  }\n+  \/\/ TODO 8284443 Only reserve extra slot if needed\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ One extra slot to hold the IsInit information for a nullable\n+    \/\/ inline type return if we run out of registers.\n+    next_slot += 2;\n+  }\n@@ -1008,0 +1030,4 @@\n+  _has_flattened_accesses = false;\n+  _flattened_accesses_share_alias = true;\n+  _scalarize_in_safepoints = false;\n+\n@@ -1302,1 +1328,2 @@\n-    assert(InlineUnsafeOps || StressReflectiveCode, \"indeterminate pointers come only from unsafe ops\");\n+    bool default_value_load = EnableValhalla && tj->is_instptr()->instance_klass() == ciEnv::current()->Class_klass();\n+    assert(InlineUnsafeOps || StressReflectiveCode || default_value_load, \"indeterminate pointers come only from unsafe ops\");\n@@ -1315,0 +1342,9 @@\n+  if (ta && ta->is_not_flat()) {\n+    \/\/ Erase not flat property for alias analysis.\n+    tj = ta = ta->cast_to_not_flat(false);\n+  }\n+  if (ta && ta->is_not_null_free()) {\n+    \/\/ Erase not null free property for alias analysis.\n+    tj = ta = ta->cast_to_not_null_free(false);\n+  }\n+\n@@ -1328,0 +1364,2 @@\n+    \/\/ For flattened inline type array, each field has its own slice so\n+    \/\/ we must include the field offset.\n@@ -1368,1 +1406,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());\n@@ -1372,1 +1410,6 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());\n+    }\n+    \/\/ Initially all flattened array accesses share a single slice\n+    if (ta->is_flat() && ta->elem() != TypeInlineType::BOTTOM && _flattened_accesses_share_alias) {\n+      const TypeAry *tary = TypeAry::make(TypeInlineType::BOTTOM, ta->size());\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));\n@@ -1379,1 +1422,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,aklass,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,aklass,false,Type::Offset(offset), ta->field_offset());\n@@ -1429,1 +1472,1 @@\n-        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, offset);\n+        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, Type::Offset(offset));\n@@ -1444,1 +1487,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, offset, to->instance_id());\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder->flatten_array(), to->instance_id());\n@@ -1446,1 +1489,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, offset);\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, Type::Offset(offset));\n@@ -1462,1 +1505,1 @@\n-                                       offset);\n+                                       Type::Offset(offset));\n@@ -1468,1 +1511,1 @@\n-        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), offset);\n+        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), Type::Offset(offset));\n@@ -1470,1 +1513,1 @@\n-        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, offset);\n+        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_null_free());\n@@ -1603,1 +1646,1 @@\n-Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field) {\n+Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field, bool uncached) {\n@@ -1608,3 +1651,6 @@\n-  AliasCacheEntry* ace = probe_alias_cache(adr_type);\n-  if (ace->_adr_type == adr_type) {\n-    return alias_type(ace->_index);\n+  AliasCacheEntry* ace = NULL;\n+  if (!uncached) {\n+    ace = probe_alias_cache(adr_type);\n+    if (ace->_adr_type == adr_type) {\n+      return alias_type(ace->_index);\n+    }\n@@ -1660,0 +1706,1 @@\n+    ciField* field = NULL;\n@@ -1666,0 +1713,1 @@\n+      const Type* elemtype = flat->is_aryptr()->elem();\n@@ -1667,1 +1715,8 @@\n-        alias_type(idx)->set_element(flat->is_aryptr()->elem());\n+        alias_type(idx)->set_element(elemtype);\n+      }\n+      int field_offset = flat->is_aryptr()->field_offset().get();\n+      if (elemtype->isa_inlinetype() &&\n+          field_offset != Type::OffsetBot) {\n+        ciInlineKlass* vk = elemtype->inline_klass();\n+        field_offset += vk->first_field_offset();\n+        field = vk->get_field_by_offset(field_offset, false);\n@@ -1679,0 +1734,2 @@\n+      if (flat->offset() == in_bytes(Klass::layout_helper_offset()))\n+        alias_type(idx)->set_rewritable(false);\n@@ -1689,1 +1746,0 @@\n-      ciField* field;\n@@ -1696,0 +1752,4 @@\n+      } else if (tinst->is_inlinetypeptr()) {\n+        \/\/ Inline type field\n+        ciInlineKlass* vk = tinst->inline_klass();\n+        field = vk->get_field_by_offset(tinst->offset(), false);\n@@ -1700,7 +1760,14 @@\n-      assert(field == NULL ||\n-             original_field == NULL ||\n-             (field->holder() == original_field->holder() &&\n-              field->offset() == original_field->offset() &&\n-              field->is_static() == original_field->is_static()), \"wrong field?\");\n-      \/\/ Set field() and is_rewritable() attributes.\n-      if (field != NULL)  alias_type(idx)->set_field(field);\n+    }\n+    assert(field == NULL ||\n+           original_field == NULL ||\n+           (field->holder() == original_field->holder() &&\n+            field->offset() == original_field->offset() &&\n+            field->is_static() == original_field->is_static()), \"wrong field?\");\n+    \/\/ Set field() and is_rewritable() attributes.\n+    if (field != NULL) {\n+      alias_type(idx)->set_field(field);\n+      if (flat->isa_aryptr()) {\n+        \/\/ Fields of flat arrays are rewritable although they are declared final\n+        assert(flat->is_aryptr()->is_flat(), \"must be a flat array\");\n+        alias_type(idx)->set_rewritable(true);\n+      }\n@@ -1711,3 +1778,4 @@\n-  ace->_adr_type = adr_type;\n-  ace->_index    = idx;\n-  assert(alias_type(adr_type) == alias_type(idx),  \"type must be installed\");\n+  if (!uncached) {\n+    ace->_adr_type = adr_type;\n+    ace->_index    = idx;\n+    assert(alias_type(adr_type) == alias_type(idx),  \"type must be installed\");\n@@ -1715,6 +1783,7 @@\n-  \/\/ Might as well try to fill the cache for the flattened version, too.\n-  AliasCacheEntry* face = probe_alias_cache(flat);\n-  if (face->_adr_type == NULL) {\n-    face->_adr_type = flat;\n-    face->_index    = idx;\n-    assert(alias_type(flat) == alias_type(idx), \"flat type must work too\");\n+    \/\/ Might as well try to fill the cache for the flattened version, too.\n+    AliasCacheEntry* face = probe_alias_cache(flat);\n+    if (face->_adr_type == NULL) {\n+      face->_adr_type = flat;\n+      face->_index    = idx;\n+      assert(alias_type(flat) == alias_type(idx), \"flat type must work too\");\n+    }\n@@ -1837,0 +1906,417 @@\n+void Compile::add_inline_type(Node* n) {\n+  assert(n->is_InlineType(), \"unexpected node\");\n+  _inline_type_nodes.push(n);\n+}\n+\n+void Compile::remove_inline_type(Node* n) {\n+  assert(n->is_InlineType(), \"unexpected node\");\n+  if (_inline_type_nodes.contains(n)) {\n+    _inline_type_nodes.remove(n);\n+  }\n+}\n+\n+\/\/ Does the return value keep otherwise useless inline type allocations alive?\n+static bool return_val_keeps_allocations_alive(Node* ret_val) {\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(ret_val);\n+  bool some_allocations = false;\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    assert(n == ret_val || !n->is_InlineType(), \"chain of inline type nodes\");\n+    if (n->outcnt() > 1) {\n+      \/\/ Some other use for the allocation\n+      return false;\n+    } else if (n->is_InlineType()) {\n+      wq.push(n->in(1));\n+    } else if (n->is_Phi()) {\n+      for (uint j = 1; j < n->req(); j++) {\n+        wq.push(n->in(j));\n+      }\n+    } else if (n->is_CheckCastPP() &&\n+               n->in(1)->is_Proj() &&\n+               n->in(1)->in(0)->is_Allocate()) {\n+      some_allocations = true;\n+    } else if (n->is_CheckCastPP()) {\n+      wq.push(n->in(1));\n+    }\n+  }\n+  return some_allocations;\n+}\n+\n+void Compile::process_inline_types(PhaseIterGVN &igvn, bool remove) {\n+  \/\/ Make sure that the return value does not keep an otherwise unused allocation alive\n+  if (tf()->returns_inline_type_as_fields()) {\n+    Node* ret = NULL;\n+    for (uint i = 1; i < root()->req(); i++) {\n+      Node* in = root()->in(i);\n+      if (in->Opcode() == Op_Return) {\n+        assert(ret == NULL, \"only one return\");\n+        ret = in;\n+      }\n+    }\n+    if (ret != NULL) {\n+      Node* ret_val = ret->in(TypeFunc::Parms);\n+      if (igvn.type(ret_val)->isa_oopptr() &&\n+          return_val_keeps_allocations_alive(ret_val)) {\n+        igvn.replace_input_of(ret, TypeFunc::Parms, InlineTypeNode::tagged_klass(igvn.type(ret_val)->inline_klass(), igvn));\n+        assert(ret_val->outcnt() == 0, \"should be dead now\");\n+        igvn.remove_dead_node(ret_val);\n+      }\n+    }\n+  }\n+  if (_inline_type_nodes.length() == 0) {\n+    return;\n+  }\n+  \/\/ Scalarize inline types in safepoint debug info.\n+  \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info.\n+  set_scalarize_in_safepoints(true);\n+  for (int i = _inline_type_nodes.length()-1; i >= 0; i--) {\n+    _inline_type_nodes.at(i)->as_InlineType()->make_scalar_in_safepoints(&igvn);\n+  }\n+  if (remove) {\n+    \/\/ Remove inline type nodes by replacing them with their oop input\n+    while (_inline_type_nodes.length() > 0) {\n+      InlineTypeNode* vt = _inline_type_nodes.pop()->as_InlineType();\n+      if (vt->outcnt() == 0) {\n+        igvn.remove_dead_node(vt);\n+        continue;\n+      }\n+      for (DUIterator i = vt->outs(); vt->has_out(i); i++) {\n+        DEBUG_ONLY(bool must_be_buffered = false);\n+        Node* u = vt->out(i);\n+        \/\/ Check if any users are blackholes. If so, rewrite them to use either the\n+        \/\/ allocated buffer, or individual components, instead of the inline type node\n+        \/\/ that goes away.\n+        if (u->is_Blackhole()) {\n+          BlackholeNode* bh = u->as_Blackhole();\n+\n+          \/\/ Unlink the old input\n+          int idx = bh->find_edge(vt);\n+          assert(idx != -1, \"The edge should be there\");\n+          bh->del_req(idx);\n+          --i;\n+\n+          if (vt->is_allocated(&igvn)) {\n+            \/\/ Already has the allocated instance, blackhole that\n+            bh->add_req(vt->get_oop());\n+          } else {\n+            \/\/ Not allocated yet, blackhole the components\n+            for (uint c = 0; c < vt->field_count(); c++) {\n+              bh->add_req(vt->field_value(c));\n+            }\n+          }\n+\n+          \/\/ Node modified, record for IGVN\n+          igvn.record_for_igvn(bh);\n+        }\n+#ifdef ASSERT\n+        \/\/ Verify that inline type is buffered when replacing by oop\n+        else if (u->is_InlineType()) {\n+          InlineTypeNode* vt2 = u->as_InlineType();\n+          for (uint i = 0; i < vt2->field_count(); ++i) {\n+            if (vt2->field_value(i) == vt && !vt2->field_is_flattened(i)) {\n+              \/\/ Use in non-flat field\n+              must_be_buffered = true;\n+            }\n+          }\n+        } else if (u->Opcode() != Op_Return || !tf()->returns_inline_type_as_fields()) {\n+          must_be_buffered = true;\n+        }\n+        if (must_be_buffered && !vt->is_allocated(&igvn)) {\n+          vt->dump(-3);\n+          assert(false, \"Should have been buffered\");\n+        }\n+#endif\n+      }\n+      igvn.replace_node(vt, vt->get_oop());\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n+void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN& igvn) {\n+  if (!_has_flattened_accesses) {\n+    return;\n+  }\n+  \/\/ Initially, all flattened array accesses share the same slice to\n+  \/\/ keep dependencies with Object[] array accesses (that could be\n+  \/\/ to a flattened array) correct. We're done with parsing so we\n+  \/\/ now know all flattened array accesses in this compile\n+  \/\/ unit. Let's move flattened array accesses to their own slice,\n+  \/\/ one per element field. This should help memory access\n+  \/\/ optimizations.\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(root());\n+\n+  Node_List mergememnodes;\n+  Node_List memnodes;\n+\n+  \/\/ Alias index currently shared by all flattened memory accesses\n+  int index = get_alias_index(TypeAryPtr::INLINES);\n+\n+  \/\/ Find MergeMem nodes and flattened array accesses\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    if (n->is_Mem()) {\n+      const TypePtr* adr_type = NULL;\n+      if (n->Opcode() == Op_StoreCM) {\n+        adr_type = get_adr_type(get_alias_index(n->in(MemNode::OopStore)->adr_type()));\n+      } else {\n+        adr_type = get_adr_type(get_alias_index(n->adr_type()));\n+      }\n+      if (adr_type == TypeAryPtr::INLINES) {\n+        memnodes.push(n);\n+      }\n+    } else if (n->is_MergeMem()) {\n+      MergeMemNode* mm = n->as_MergeMem();\n+      if (mm->memory_at(index) != mm->base_memory()) {\n+        mergememnodes.push(n);\n+      }\n+    }\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* m = n->in(j);\n+      if (m != NULL) {\n+        wq.push(m);\n+      }\n+    }\n+  }\n+\n+  if (memnodes.size() > 0) {\n+    _flattened_accesses_share_alias = false;\n+\n+    \/\/ We are going to change the slice for the flattened array\n+    \/\/ accesses so we need to clear the cache entries that refer to\n+    \/\/ them.\n+    for (uint i = 0; i < AliasCacheSize; i++) {\n+      AliasCacheEntry* ace = &_alias_cache[i];\n+      if (ace->_adr_type != NULL &&\n+          ace->_adr_type->isa_aryptr() &&\n+          ace->_adr_type->is_aryptr()->is_flat()) {\n+        ace->_adr_type = NULL;\n+        ace->_index = (i != 0) ? 0 : AliasIdxTop; \/\/ Make sure the NULL adr_type resolves to AliasIdxTop\n+      }\n+    }\n+\n+    \/\/ Find what aliases we are going to add\n+    int start_alias = num_alias_types()-1;\n+    int stop_alias = 0;\n+\n+    for (uint i = 0; i < memnodes.size(); i++) {\n+      Node* m = memnodes.at(i);\n+      const TypePtr* adr_type = NULL;\n+      if (m->Opcode() == Op_StoreCM) {\n+        adr_type = m->in(MemNode::OopStore)->adr_type();\n+        if (adr_type != TypeAryPtr::INLINES) {\n+          \/\/ store was optimized out and we lost track of the adr_type\n+          Node* clone = new StoreCMNode(m->in(MemNode::Control), m->in(MemNode::Memory), m->in(MemNode::Address),\n+                                        m->adr_type(), m->in(MemNode::ValueIn), m->in(MemNode::OopStore),\n+                                        get_alias_index(adr_type));\n+          igvn.register_new_node_with_optimizer(clone);\n+          igvn.replace_node(m, clone);\n+        }\n+      } else {\n+        adr_type = m->adr_type();\n+#ifdef ASSERT\n+        m->as_Mem()->set_adr_type(adr_type);\n+#endif\n+      }\n+      int idx = get_alias_index(adr_type);\n+      start_alias = MIN2(start_alias, idx);\n+      stop_alias = MAX2(stop_alias, idx);\n+    }\n+\n+    assert(stop_alias >= start_alias, \"should have expanded aliases\");\n+\n+    Node_Stack stack(0);\n+#ifdef ASSERT\n+    VectorSet seen(Thread::current()->resource_area());\n+#endif\n+    \/\/ Now let's fix the memory graph so each flattened array access\n+    \/\/ is moved to the right slice. Start from the MergeMem nodes.\n+    uint last = unique();\n+    for (uint i = 0; i < mergememnodes.size(); i++) {\n+      MergeMemNode* current = mergememnodes.at(i)->as_MergeMem();\n+      Node* n = current->memory_at(index);\n+      MergeMemNode* mm = NULL;\n+      do {\n+        \/\/ Follow memory edges through memory accesses, phis and\n+        \/\/ narrow membars and push nodes on the stack. Once we hit\n+        \/\/ bottom memory, we pop element off the stack one at a\n+        \/\/ time, in reverse order, and move them to the right slice\n+        \/\/ by changing their memory edges.\n+        if ((n->is_Phi() && n->adr_type() != TypePtr::BOTTOM) || n->is_Mem() || n->adr_type() == TypeAryPtr::INLINES) {\n+          assert(!seen.test_set(n->_idx), \"\");\n+          \/\/ Uses (a load for instance) will need to be moved to the\n+          \/\/ right slice as well and will get a new memory state\n+          \/\/ that we don't know yet. The use could also be the\n+          \/\/ backedge of a loop. We put a place holder node between\n+          \/\/ the memory node and its uses. We replace that place\n+          \/\/ holder with the correct memory state once we know it,\n+          \/\/ i.e. when nodes are popped off the stack. Using the\n+          \/\/ place holder make the logic work in the presence of\n+          \/\/ loops.\n+          if (n->outcnt() > 1) {\n+            Node* place_holder = NULL;\n+            assert(!n->has_out_with(Op_Node), \"\");\n+            for (DUIterator k = n->outs(); n->has_out(k); k++) {\n+              Node* u = n->out(k);\n+              if (u != current && u->_idx < last) {\n+                bool success = false;\n+                for (uint l = 0; l < u->req(); l++) {\n+                  if (!stack.is_empty() && u == stack.node() && l == stack.index()) {\n+                    continue;\n+                  }\n+                  Node* in = u->in(l);\n+                  if (in == n) {\n+                    if (place_holder == NULL) {\n+                      place_holder = new Node(1);\n+                      place_holder->init_req(0, n);\n+                    }\n+                    igvn.replace_input_of(u, l, place_holder);\n+                    success = true;\n+                  }\n+                }\n+                if (success) {\n+                  --k;\n+                }\n+              }\n+            }\n+          }\n+          if (n->is_Phi()) {\n+            stack.push(n, 1);\n+            n = n->in(1);\n+          } else if (n->is_Mem()) {\n+            stack.push(n, n->req());\n+            n = n->in(MemNode::Memory);\n+          } else {\n+            assert(n->is_Proj() && n->in(0)->Opcode() == Op_MemBarCPUOrder, \"\");\n+            stack.push(n, n->req());\n+            n = n->in(0)->in(TypeFunc::Memory);\n+          }\n+        } else {\n+          assert(n->adr_type() == TypePtr::BOTTOM || (n->Opcode() == Op_Node && n->_idx >= last) || (n->is_Proj() && n->in(0)->is_Initialize()), \"\");\n+          \/\/ Build a new MergeMem node to carry the new memory state\n+          \/\/ as we build it. IGVN should fold extraneous MergeMem\n+          \/\/ nodes.\n+          mm = MergeMemNode::make(n);\n+          igvn.register_new_node_with_optimizer(mm);\n+          while (stack.size() > 0) {\n+            Node* m = stack.node();\n+            uint idx = stack.index();\n+            if (m->is_Mem()) {\n+              \/\/ Move memory node to its new slice\n+              const TypePtr* adr_type = m->adr_type();\n+              int alias = get_alias_index(adr_type);\n+              Node* prev = mm->memory_at(alias);\n+              igvn.replace_input_of(m, MemNode::Memory, prev);\n+              mm->set_memory_at(alias, m);\n+            } else if (m->is_Phi()) {\n+              \/\/ We need as many new phis as there are new aliases\n+              igvn.replace_input_of(m, idx, mm);\n+              if (idx == m->req()-1) {\n+                Node* r = m->in(0);\n+                for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n+                  const Type* adr_type = get_adr_type(j);\n+                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n+                    continue;\n+                  }\n+                  Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));\n+                  igvn.register_new_node_with_optimizer(phi);\n+                  for (uint k = 1; k < m->req(); k++) {\n+                    phi->init_req(k, m->in(k)->as_MergeMem()->memory_at(j));\n+                  }\n+                  mm->set_memory_at(j, phi);\n+                }\n+                Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);\n+                igvn.register_new_node_with_optimizer(base_phi);\n+                for (uint k = 1; k < m->req(); k++) {\n+                  base_phi->init_req(k, m->in(k)->as_MergeMem()->base_memory());\n+                }\n+                mm->set_base_memory(base_phi);\n+              }\n+            } else {\n+              \/\/ This is a MemBarCPUOrder node from\n+              \/\/ Parse::array_load()\/Parse::array_store(), in the\n+              \/\/ branch that handles flattened arrays hidden under\n+              \/\/ an Object[] array. We also need one new membar per\n+              \/\/ new alias to keep the unknown access that the\n+              \/\/ membars protect properly ordered with accesses to\n+              \/\/ known flattened array.\n+              assert(m->is_Proj(), \"projection expected\");\n+              Node* ctrl = m->in(0)->in(TypeFunc::Control);\n+              igvn.replace_input_of(m->in(0), TypeFunc::Control, top());\n+              for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n+                const Type* adr_type = get_adr_type(j);\n+                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n+                  continue;\n+                }\n+                MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);\n+                igvn.register_new_node_with_optimizer(mb);\n+                Node* mem = mm->memory_at(j);\n+                mb->init_req(TypeFunc::Control, ctrl);\n+                mb->init_req(TypeFunc::Memory, mem);\n+                ctrl = new ProjNode(mb, TypeFunc::Control);\n+                igvn.register_new_node_with_optimizer(ctrl);\n+                mem = new ProjNode(mb, TypeFunc::Memory);\n+                igvn.register_new_node_with_optimizer(mem);\n+                mm->set_memory_at(j, mem);\n+              }\n+              igvn.replace_node(m->in(0)->as_Multi()->proj_out(TypeFunc::Control), ctrl);\n+            }\n+            if (idx < m->req()-1) {\n+              idx += 1;\n+              stack.set_index(idx);\n+              n = m->in(idx);\n+              break;\n+            }\n+            \/\/ Take care of place holder nodes\n+            if (m->has_out_with(Op_Node)) {\n+              Node* place_holder = m->find_out_with(Op_Node);\n+              if (place_holder != NULL) {\n+                Node* mm_clone = mm->clone();\n+                igvn.register_new_node_with_optimizer(mm_clone);\n+                Node* hook = new Node(1);\n+                hook->init_req(0, mm);\n+                igvn.replace_node(place_holder, mm_clone);\n+                hook->destruct(&igvn);\n+              }\n+              assert(!m->has_out_with(Op_Node), \"place holder should be gone now\");\n+            }\n+            stack.pop();\n+          }\n+        }\n+      } while(stack.size() > 0);\n+      \/\/ Fix the memory state at the MergeMem we started from\n+      igvn.rehash_node_delayed(current);\n+      for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n+        const Type* adr_type = get_adr_type(j);\n+        if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {\n+          continue;\n+        }\n+        current->set_memory_at(j, mm);\n+      }\n+      current->set_memory_at(index, current->base_memory());\n+    }\n+    igvn.optimize();\n+  }\n+  print_method(PHASE_SPLIT_INLINES_ARRAY, 2);\n+#ifdef ASSERT\n+  if (!_flattened_accesses_share_alias) {\n+    wq.clear();\n+    wq.push(root());\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* n = wq.at(i);\n+      assert(n->adr_type() != TypeAryPtr::INLINES, \"should have been removed from the graph\");\n+      for (uint j = 0; j < n->req(); j++) {\n+        Node* m = n->in(j);\n+        if (m != NULL) {\n+          wq.push(m);\n+        }\n+      }\n+    }\n+  }\n+#endif\n+}\n+\n@@ -2126,1 +2612,4 @@\n-  assert(_modified_nodes == NULL, \"not allowed\");\n+#ifdef ASSERT\n+  Unique_Node_List* modified_nodes = _modified_nodes;\n+  _modified_nodes = NULL;\n+#endif\n@@ -2140,0 +2629,1 @@\n+  DEBUG_ONLY( _modified_nodes = modified_nodes; )\n@@ -2283,0 +2773,5 @@\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n+\n+  adjust_flattened_array_access_aliases(igvn);\n+\n@@ -2396,0 +2891,8 @@\n+  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n+\n+  if (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual and MH calls.\n+    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n+    process_late_inline_calls_no_inline(igvn);\n+  }\n+\n@@ -2406,0 +2909,4 @@\n+  \/\/ Process inline type nodes again and remove them. From here\n+  \/\/ on we don't need to keep track of field values anymore.\n+  process_inline_types(igvn, \/* remove= *\/ true);\n+\n@@ -2421,0 +2928,1 @@\n+  DEBUG_ONLY( _late_inlines.clear(); )\n@@ -2423,8 +2931,0 @@\n-\n-  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n-\n-  if (_late_inlines.length() > 0) {\n-    \/\/ More opportunities to optimize virtual and MH calls.\n-    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n-    process_late_inline_calls_no_inline(igvn);\n-  }\n@@ -3055,0 +3555,1 @@\n+\n@@ -3207,1 +3708,16 @@\n-      n->add_prec(prec);\n+      if (prec->is_MergeMem()) {\n+        MergeMemNode* mm = prec->as_MergeMem();\n+        Node* base = mm->base_memory();\n+        for (int i = AliasIdxRaw + 1; i < num_alias_types(); i++) {\n+          const Type* adr_type = get_adr_type(i);\n+          if (adr_type->isa_aryptr() && adr_type->is_aryptr()->is_flat()) {\n+            Node* m = mm->memory_at(i);\n+            n->add_prec(m);\n+          }\n+        }\n+        if (mm->outcnt() == 0) {\n+          mm->disconnect_inputs(this);\n+        }\n+      } else {\n+        n->add_prec(prec);\n+      }\n@@ -3803,0 +4319,7 @@\n+#ifdef ASSERT\n+  case Op_InlineType: {\n+    n->dump(-1);\n+    assert(false, \"inline type node was not removed\");\n+    break;\n+  }\n+#endif\n@@ -4179,2 +4702,2 @@\n-      if (accessing_method->is_static_initializer() ||\n-          accessing_method->is_object_initializer() ||\n+      if (accessing_method->is_class_initializer() ||\n+          accessing_method->is_object_constructor() ||\n@@ -4188,1 +4711,1 @@\n-      if (accessing_method->is_static_initializer()) {\n+      if (accessing_method->is_class_initializer()) {\n@@ -4244,0 +4767,1 @@\n+               (n->is_Allocate() && i >= AllocateNode::InlineType) ||\n@@ -4246,1 +4770,1 @@\n-              \"only region, phi, arraycopy, unlock or membar nodes have null data edges\");\n+              \"only region, phi, arraycopy, allocate, unlock or membar nodes have null data edges\");\n@@ -4380,0 +4904,8 @@\n+\n+    \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+    \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+    \/\/ the klass for [LMyValue. Perform a full test.\n+    if (!superk->is_aryklassptr()->is_null_free() && superk->is_aryklassptr()->elem()->isa_instklassptr() &&\n+        superk->is_aryklassptr()->elem()->is_instklassptr()->instance_klass()->is_inlinetype()) {\n+      return SSC_full_test;\n+    }\n@@ -4931,0 +5463,21 @@\n+Node* Compile::optimize_acmp(PhaseGVN* phase, Node* a, Node* b) {\n+  const TypeInstPtr* ta = phase->type(a)->isa_instptr();\n+  const TypeInstPtr* tb = phase->type(b)->isa_instptr();\n+  if (!EnableValhalla || ta == NULL || tb == NULL ||\n+      ta->is_zero_type() || tb->is_zero_type() ||\n+      !ta->can_be_inline_type() || !tb->can_be_inline_type()) {\n+    \/\/ Use old acmp if one operand is null or not an inline type\n+    return new CmpPNode(a, b);\n+  } else if (ta->is_inlinetypeptr() || tb->is_inlinetypeptr()) {\n+    \/\/ We know that one operand is an inline type. Therefore,\n+    \/\/ new acmp will only return true if both operands are NULL.\n+    \/\/ Check if both operands are null by or'ing the oops.\n+    a = phase->transform(new CastP2XNode(NULL, a));\n+    b = phase->transform(new CastP2XNode(NULL, b));\n+    a = phase->transform(new OrXNode(a, b));\n+    return new CmpXNode(a, phase->MakeConX(0));\n+  }\n+  \/\/ Use new acmp\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":604,"deletions":51,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class CallNode;\n@@ -95,0 +96,1 @@\n+class InlineTypeNode;\n@@ -346,0 +348,3 @@\n+  bool                  _has_flattened_accesses; \/\/ Any known flattened array accesses?\n+  bool                  _flattened_accesses_share_alias; \/\/ Initially all flattened array share a single slice\n+  bool                  _scalarize_in_safepoints; \/\/ Scalarize inline types in safepoint debug info\n@@ -361,0 +366,1 @@\n+  GrowableArray<Node*>  _inline_type_nodes;     \/\/ List of InlineType nodes\n@@ -634,0 +640,10 @@\n+  void          set_flattened_accesses()         { _has_flattened_accesses = true; }\n+  bool          flattened_accesses_share_alias() const { return _flattened_accesses_share_alias; }\n+  void          set_flattened_accesses_share_alias(bool z) { _flattened_accesses_share_alias = z; }\n+  bool          scalarize_in_safepoints() const { return _scalarize_in_safepoints; }\n+  void          set_scalarize_in_safepoints(bool z) { _scalarize_in_safepoints = z; }\n+\n+  \/\/ Support for scalarized inline type calling convention\n+  bool              has_scalarized_args() const  { return _method != NULL && _method->has_scalarized_args(); }\n+  bool              needs_stack_repair()  const  { return _method != NULL && _method->get_Method()->c2_needs_stack_repair(); }\n+\n@@ -735,0 +751,7 @@\n+  \/\/ Keep track of inline type nodes for later processing\n+  void add_inline_type(Node* n);\n+  void remove_inline_type(Node* n);\n+  void process_inline_types(PhaseIterGVN &igvn, bool remove = false);\n+\n+  void adjust_flattened_array_access_aliases(PhaseIterGVN& igvn);\n+\n@@ -879,1 +902,1 @@\n-  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL) { return find_alias_type(adr_type, false, field); }\n+  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL, bool uncached = false) { return find_alias_type(adr_type, false, field, uncached); }\n@@ -883,1 +906,1 @@\n-  int               get_alias_index(const TypePtr* at)  { return alias_type(at)->index(); }\n+  int               get_alias_index(const TypePtr* at, bool uncached = false) { return alias_type(at, NULL, uncached)->index(); }\n@@ -1114,1 +1137,1 @@\n-  AliasType* find_alias_type(const TypePtr* adr_type, bool no_create, ciField* field);\n+  AliasType* find_alias_type(const TypePtr* adr_type, bool no_create, ciField* field, bool uncached = false);\n@@ -1190,1 +1213,3 @@\n-  \/\/ Auxiliary methods for randomized fuzzing\/stressing\n+  Node* optimize_acmp(PhaseGVN* phase, Node* a, Node* b);\n+\n+  \/\/ Auxiliary method for randomized fuzzing\/stressing\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -155,0 +156,10 @@\n+    if ((n->Opcode() == Op_LoadX || n->Opcode() == Op_StoreX) &&\n+        !n->in(MemNode::Address)->is_AddP() &&\n+        _igvn->type(n->in(MemNode::Address))->isa_oopptr()) {\n+      \/\/ Load\/Store at mark work address is at offset 0 so has no AddP which confuses EA\n+      Node* addp = new AddPNode(n->in(MemNode::Address), n->in(MemNode::Address), _igvn->MakeConX(0));\n+      _igvn->register_new_node_with_optimizer(addp);\n+      _igvn->replace_input_of(n, MemNode::Address, addp);\n+      ideal_nodes.push(addp);\n+      _nodes.at_put_grow(addp->_idx, NULL, NULL);\n+    }\n@@ -451,1 +462,1 @@\n-      const TypeTuple* d = call->tf()->domain();\n+      const TypeTuple* d = call->tf()->domain_sig();\n@@ -525,0 +536,11 @@\n+      } else if (n->as_Call()->tf()->returns_inline_type_as_fields()) {\n+        bool returns_oop = false;\n+        for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax && !returns_oop; i++) {\n+          ProjNode* pn = n->fast_out(i)->as_Proj();\n+          if (pn->_con >= TypeFunc::Parms && pn->bottom_type()->isa_ptr()) {\n+            returns_oop = true;\n+          }\n+        }\n+        if (returns_oop) {\n+          add_call_node(n->as_Call());\n+        }\n@@ -556,0 +578,1 @@\n+    case Op_InlineType:\n@@ -626,2 +649,4 @@\n-      if (n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->is_Call() &&\n-          n->in(0)->as_Call()->returns_pointer()) {\n+      if (n->as_Proj()->_con >= TypeFunc::Parms && n->in(0)->is_Call() &&\n+          (n->in(0)->as_Call()->returns_pointer() || n->bottom_type()->isa_ptr())) {\n+        assert((n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->as_Call()->returns_pointer()) ||\n+               n->in(0)->as_Call()->tf()->returns_inline_type_as_fields(), \"what kind of oop return is it?\");\n@@ -727,0 +752,1 @@\n+    case Op_InlineType:\n@@ -781,2 +807,2 @@\n-      assert(n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->is_Call() &&\n-             n->in(0)->as_Call()->returns_pointer(), \"Unexpected node type\");\n+      assert((n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->as_Call()->returns_pointer()) ||\n+             n->in(0)->as_Call()->tf()->returns_inline_type_as_fields(), \"what kind of oop return is it?\");\n@@ -957,1 +983,1 @@\n-  assert(call->returns_pointer(), \"only for call which returns pointer\");\n+  assert(call->returns_pointer() || call->tf()->returns_inline_type_as_fields(), \"only for call which returns pointer\");\n@@ -1033,1 +1059,2 @@\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0, \"TODO: add failed case check\");\n+      assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+             strncmp(name, \"_load_unknown_inline\", 20) == 0, \"TODO: add failed case check\");\n@@ -1061,1 +1088,1 @@\n-        const TypeTuple* d = call->tf()->domain();\n+        const TypeTuple* d = call->tf()->domain_cc();\n@@ -1109,1 +1136,1 @@\n-      const TypeTuple * d = call->tf()->domain();\n+      const TypeTuple * d = call->tf()->domain_sig();\n@@ -1140,1 +1167,4 @@\n-                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != NULL)));\n+                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != NULL)) ||\n+                               (aat->isa_aryptr() && aat->isa_aryptr()->elem() != NULL &&\n+                                                               aat->isa_aryptr()->is_flat() &&\n+                                                               aat->isa_aryptr()->elem()->inline_klass()->contains_oops()));\n@@ -1189,0 +1219,3 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"vectorizedMismatch\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"load_unknown_inline\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"store_unknown_inline\") == 0 ||\n@@ -1251,1 +1284,1 @@\n-        const TypeTuple* d = call->tf()->domain();\n+        const TypeTuple* d = call->tf()->domain_cc();\n@@ -1295,1 +1328,1 @@\n-      const TypeTuple* d = call->tf()->domain();\n+      const TypeTuple* d = call->tf()->domain_cc();\n@@ -1708,0 +1741,1 @@\n+  PointsToNode* init_val = phantom_obj;\n@@ -1713,1 +1747,8 @@\n-    return 0;\n+    if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+      \/\/ Non-flattened inline type arrays are initialized with\n+      \/\/ the default value instead of null. Handle them here.\n+      init_val = ptnode_adr(alloc->as_Allocate()->in(AllocateNode::DefaultValue)->_idx);\n+      assert(init_val != NULL, \"default value should be registered\");\n+    } else {\n+      return 0;\n+    }\n@@ -1715,1 +1756,2 @@\n-  assert(pta->arraycopy_dst() || alloc->as_CallStaticJava(), \"sanity\");\n+  \/\/ Non-escaped allocation returned from Java or runtime call has unknown values in fields.\n+  assert(pta->arraycopy_dst() || alloc->is_CallStaticJava() || init_val != phantom_obj, \"sanity\");\n@@ -1717,1 +1759,1 @@\n-  if (!pta->arraycopy_dst() && alloc->as_CallStaticJava()->method() == NULL) {\n+  if (alloc->is_CallStaticJava() && alloc->as_CallStaticJava()->method() == NULL) {\n@@ -1719,1 +1761,2 @@\n-    assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n+    assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+           strncmp(name, \"_load_unknown_inline\", 20) == 0, \"sanity\");\n@@ -1727,1 +1770,1 @@\n-      if (add_edge(field, phantom_obj)) {\n+      if (add_edge(field, init_val)) {\n@@ -1742,1 +1785,1 @@\n-  if (!alloc->is_Allocate()) {\n+  if (!alloc->is_Allocate() || alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n@@ -1828,1 +1871,1 @@\n-                tty->print_cr(\"----------missed referernce to object-----------\");\n+                tty->print_cr(\"----------missed reference to object------------\");\n@@ -1830,1 +1873,1 @@\n-                tty->print_cr(\"----------object referernced by init store -----\");\n+                tty->print_cr(\"----------object referenced by init store-------\");\n@@ -2096,1 +2139,2 @@\n-          if (not_global_escape(alock->obj_node())) {\n+          const Type* obj_type = igvn->type(alock->obj_node());\n+          if (not_global_escape(alock->obj_node()) && !obj_type->is_inlinetypeptr()) {\n@@ -2137,5 +2181,10 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n-      mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n-      mb->init_req(TypeFunc::Control, storestore->in(TypeFunc::Control));\n-      igvn->register_new_node_with_optimizer(mb);\n-      igvn->replace_node(storestore, mb);\n+      if (alloc->in(AllocateNode::InlineType) != NULL) {\n+        \/\/ Non-escaping inline type buffer allocations don't require a membar\n+        storestore->as_MemBar()->remove(_igvn);\n+      } else {\n+        MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n+        mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n+        mb->init_req(TypeFunc::Control, storestore->in(TypeFunc::Control));\n+        igvn->register_new_node_with_optimizer(mb);\n+        igvn->replace_node(storestore, mb);\n+      }\n@@ -2294,0 +2343,1 @@\n+  int field_offset = adr_type->isa_aryptr() ? adr_type->isa_aryptr()->field_offset().get() : Type::OffsetBot;\n@@ -2295,1 +2345,1 @@\n-  if (offset == Type::OffsetBot) {\n+  if (offset == Type::OffsetBot && field_offset == Type::OffsetBot) {\n@@ -2307,1 +2357,1 @@\n-      ciField* field = _compile->alias_type(adr_type->isa_instptr())->field();\n+      ciField* field = _compile->alias_type(adr_type->is_ptr())->field();\n@@ -2327,1 +2377,7 @@\n-        bt = elemtype->array_element_basic_type();\n+        if (elemtype->isa_inlinetype() && field_offset != Type::OffsetBot) {\n+          ciInlineKlass* vk = elemtype->inline_klass();\n+          field_offset += vk->first_field_offset();\n+          bt = vk->get_field_by_offset(field_offset, false)->layout_type();\n+        } else {\n+          bt = elemtype->array_element_basic_type();\n+        }\n@@ -2511,3 +2567,1 @@\n-  const TypePtr *t_ptr = adr_type->isa_ptr();\n-  assert(t_ptr != NULL, \"must be a pointer type\");\n-  return t_ptr->offset();\n+  return adr_type->is_ptr()->flattened_offset();\n@@ -2667,1 +2721,8 @@\n-    t = base_t->add_offset(offs)->is_oopptr();\n+    if (base_t->isa_aryptr() != NULL) {\n+      \/\/ In the case of a flattened inline type array, each field has its\n+      \/\/ own slice so we need to extract the field being accessed from\n+      \/\/ the address computation\n+      t = base_t->isa_aryptr()->add_field_offset_and_offset(offs)->is_oopptr();\n+    } else {\n+      t = base_t->add_offset(offs)->is_oopptr();\n+    }\n@@ -2669,1 +2730,1 @@\n-  int inst_id =  base_t->instance_id();\n+  int inst_id = base_t->instance_id();\n@@ -2683,1 +2744,1 @@\n-  \/\/ It could happened when CHA type is different from MDO type on a dead path\n+  \/\/ It could happen when CHA type is different from MDO type on a dead path\n@@ -2693,1 +2754,12 @@\n-  const TypeOopPtr *tinst = base_t->add_offset(t->offset())->is_oopptr();\n+  const TypePtr* tinst = base_t->add_offset(t->offset());\n+  if (tinst->isa_aryptr() && t->isa_aryptr()) {\n+    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ own slice so we need to keep track of the field being accessed.\n+    tinst = tinst->is_aryptr()->with_field_offset(t->is_aryptr()->field_offset().get());\n+    \/\/ Keep array properties (not flat\/null-free)\n+    tinst = tinst->is_aryptr()->update_properties(t->is_aryptr());\n+    if (tinst == NULL) {\n+      return false; \/\/ Skip dead path with inconsistent properties\n+    }\n+  }\n+\n@@ -3375,0 +3447,7 @@\n+          if (tn_t->isa_aryptr()) {\n+            \/\/ Keep array properties (not flat\/null-free)\n+            tinst = tinst->is_aryptr()->update_properties(tn_t->is_aryptr());\n+            if (tinst == NULL) {\n+              continue; \/\/ Skip dead path with inconsistent properties\n+            }\n+          }\n@@ -3400,1 +3479,1 @@\n-      if(use->is_Mem() && use->in(MemNode::Address) == n) {\n+      if (use->is_Mem() && use->in(MemNode::Address) == n) {\n@@ -3436,0 +3515,3 @@\n+      } else if (use->Opcode() == Op_Return) {\n+        \/\/ Allocation is referenced by field of returned inline type\n+        assert(_compile->tf()->returns_inline_type_as_fields(), \"EA: unexpected reference by ReturnNode\");\n@@ -3448,1 +3530,1 @@\n-              op == Op_SubTypeCheck ||\n+              op == Op_SubTypeCheck || op == Op_InlineType || op == Op_FlatArrayCheck ||\n@@ -3518,0 +3600,3 @@\n+    } else if (n->is_CallLeaf() && n->as_CallLeaf()->_name != NULL &&\n+               strcmp(n->as_CallLeaf()->_name, \"store_unknown_inline\") == 0) {\n+      n = n->as_CallLeaf()->proj_out(TypeFunc::Memory);\n@@ -3560,1 +3645,1 @@\n-      } else if(use->is_Mem()) {\n+      } else if (use->is_Mem()) {\n@@ -3569,0 +3654,4 @@\n+      } else if (use->is_CallLeaf() && use->as_CallLeaf()->_name != NULL &&\n+                 strcmp(use->as_CallLeaf()->_name, \"store_unknown_inline\") == 0) {\n+        \/\/ store_unknown_inline overwrites destination array\n+        memnode_worklist.append_if_missing(use);\n@@ -3578,1 +3667,1 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {\n+              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar || op == Op_FlatArrayCheck)) {\n@@ -3665,1 +3754,1 @@\n-  \/\/ chains as is done in split_memory_phi() since they  will\n+  \/\/ chains as is done in split_memory_phi() since they will\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":130,"deletions":41,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-      for (int i = node->req()-1; i >= 0; --i) {\n+      for (int i = node->len()-1; i >= 0; --i) {\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  assert(!_gvn.is_IterGVN(), \"IdealKit can't be used during Optimize phase\");\n@@ -83,1 +82,0 @@\n-\n@@ -87,0 +85,4 @@\n+  if_then(bol, prob, cnt, push_new_state);\n+}\n+\n+void IdealKit::if_then(Node* bol, float prob, float cnt, bool push_new_state) {\n@@ -299,1 +301,1 @@\n-    C->record_for_igvn(n);\n+    gvn().record_for_igvn(n);\n@@ -308,1 +310,1 @@\n-  C->record_for_igvn(n);\n+  gvn().record_for_igvn(n);\n@@ -528,2 +530,2 @@\n-  if (slow_call_type->range()->cnt() > TypeFunc::Parms) {\n-    assert(slow_call_type->range()->cnt() == TypeFunc::Parms+1, \"only one return value\");\n+  if (slow_call_type->range_sig()->cnt() > TypeFunc::Parms) {\n+    assert(slow_call_type->range_sig()->cnt() == TypeFunc::Parms+1, \"only one return value\");\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+  void if_then(Node* bol, float prob = PROB_FAIR, float cnt = COUNT_UNKNOWN, bool push_new_state = true);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1233,0 +1233,17 @@\n+\/\/ Returns true if this IfNode belongs to a flat array check\n+\/\/ and returns the corresponding array in the 'array' parameter.\n+bool IfNode::is_flat_array_check(PhaseTransform* phase, Node** array) {\n+  Node* bol = in(1);\n+  if (!bol->is_Bool()) {\n+    return false;\n+  }\n+  Node* cmp = bol->in(1);\n+  if (cmp->isa_FlatArrayCheck()) {\n+    if (array != NULL) {\n+      *array = cmp->in(FlatArrayCheckNode::ArrayOrKlass);\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -320,0 +321,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:        return inline_unsafe_make_private_buffer();\n+  case vmIntrinsics::_finishPrivateBuffer:      return inline_unsafe_finish_private_buffer();\n@@ -329,0 +332,1 @@\n+  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n@@ -339,0 +343,1 @@\n+  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n@@ -512,0 +517,5 @@\n+  case vmIntrinsics::_asPrimaryType:\n+  case vmIntrinsics::_asPrimaryTypeArg:\n+  case vmIntrinsics::_asValueType:\n+  case vmIntrinsics::_asValueTypeArg:           return inline_primitive_Class_conversion(intrinsic_id());\n+\n@@ -2171,0 +2181,1 @@\n+  bool null_free = false;\n@@ -2176,0 +2187,1 @@\n+      null_free = alias_type->field()->is_null_free();\n@@ -2184,0 +2196,1 @@\n+      null_free = adr_type->is_aryptr()->is_null_free();\n@@ -2196,0 +2209,3 @@\n+    if (null_free) {\n+      result = result->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n@@ -2250,2 +2266,2 @@\n-      assert(rtype == type, \"getter must return the expected value\");\n-      assert(sig->count() == 2, \"oop getter has 2 arguments\");\n+      assert(rtype == type || (rtype == T_OBJECT && type == T_PRIMITIVE_OBJECT), \"getter must return the expected value\");\n+      assert(sig->count() == 2 || (type == T_PRIMITIVE_OBJECT && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n@@ -2257,1 +2273,1 @@\n-      assert(sig->count() == 3, \"oop putter has 3 arguments\");\n+      assert(sig->count() == 3 || (type == T_PRIMITIVE_OBJECT && sig->count() == 4), \"oop putter has 3 arguments\");\n@@ -2261,1 +2277,1 @@\n-      assert(vtype == type, \"putter must accept the expected value\");\n+      assert(vtype == type || (type == T_PRIMITIVE_OBJECT && vtype == T_OBJECT), \"putter must accept the expected value\");\n@@ -2283,0 +2299,51 @@\n+\n+  ciInlineKlass* inline_klass = NULL;\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    const TypeInstPtr* cls = _gvn.type(argument(4))->isa_instptr();\n+    if (cls == NULL || cls->const_oop() == NULL) {\n+      return false;\n+    }\n+    ciType* mirror_type = cls->const_oop()->as_instance()->java_mirror_type();\n+    if (!mirror_type->is_inlinetype()) {\n+      return false;\n+    }\n+    inline_klass = mirror_type->as_inline_klass();\n+  }\n+\n+  if (base->is_InlineType()) {\n+    InlineTypeNode* vt = base->as_InlineType();\n+    if (is_store) {\n+      if (!vt->is_allocated(&_gvn)) {\n+        return false;\n+      }\n+      base = vt->get_oop();\n+    } else {\n+      if (offset->is_Con()) {\n+        long off = find_long_con(offset, 0);\n+        ciInlineKlass* vk = vt->type()->inline_klass();\n+        if ((long)(int)off != off || !vk->contains_field_offset(off)) {\n+          return false;\n+        }\n+\n+        ciField* field = vk->get_non_flattened_field_by_offset(off);\n+        if (field != NULL) {\n+          BasicType bt = field->layout_type();\n+          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flattened())) {\n+            bt = T_OBJECT;\n+          }\n+          if (bt == type && (bt != T_PRIMITIVE_OBJECT || field->type() == inline_klass)) {\n+            set_result(vt->field_value_by_offset(off, false));\n+            return true;\n+          }\n+        }\n+      }\n+      {\n+        \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        vt = vt->buffer(this);\n+      }\n+      base = vt->get_oop();\n+    }\n+  }\n+\n@@ -2293,1 +2360,1 @@\n-    if (type != T_OBJECT) {\n+    if (type != T_OBJECT && (inline_klass == NULL || !inline_klass->has_object_fields())) {\n@@ -2311,1 +2378,1 @@\n-  Node* val = is_store ? argument(4) : NULL;\n+  Node* val = is_store ? argument(4 + (type == T_PRIMITIVE_OBJECT ? 1 : 0)) : NULL;\n@@ -2332,1 +2399,25 @@\n-  BasicType bt = alias_type->basic_type();\n+  BasicType bt = T_ILLEGAL;\n+  ciField* field = NULL;\n+  if (adr_type->isa_instptr()) {\n+    const TypeInstPtr* instptr = adr_type->is_instptr();\n+    ciInstanceKlass* k = instptr->instance_klass();\n+    int off = instptr->offset();\n+    if (instptr->const_oop() != NULL &&\n+        k == ciEnv::current()->Class_klass() &&\n+        instptr->offset() >= (k->size_helper() * wordSize)) {\n+      k = instptr->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+      field = k->get_field_by_offset(off, true);\n+    } else {\n+      field = k->get_non_flattened_field_by_offset(off);\n+    }\n+    if (field != NULL) {\n+      bt = field->layout_type();\n+    }\n+    assert(bt == alias_type->basic_type() || bt == T_PRIMITIVE_OBJECT, \"should match\");\n+    if (field != NULL && bt == T_PRIMITIVE_OBJECT && !field->is_flattened()) {\n+      bt = T_OBJECT;\n+    }\n+  } else {\n+    bt = alias_type->basic_type();\n+  }\n+\n@@ -2340,1 +2431,1 @@\n-    if (is_reference_type(bt, true)) {\n+    if (bt != T_PRIMITIVE_OBJECT && is_reference_type(bt, true)) {\n@@ -2355,0 +2446,25 @@\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    if (adr_type->isa_instptr()) {\n+      if (field == NULL || field->type() != inline_klass) {\n+        mismatched = true;\n+      }\n+    } else if (adr_type->isa_aryptr()) {\n+      const Type* elem = adr_type->is_aryptr()->elem();\n+      if (!elem->isa_inlinetype()) {\n+        mismatched = true;\n+      } else if (elem->inline_klass() != inline_klass) {\n+        mismatched = true;\n+      }\n+    } else {\n+      mismatched = true;\n+    }\n+    if (is_store) {\n+      const Type* val_t = _gvn.type(val);\n+      if (!(val_t->isa_inlinetype() || val_t->is_inlinetypeptr()) || val_t->inline_klass() != inline_klass) {\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -2356,1 +2472,1 @@\n-  assert(!mismatched || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  assert(!mismatched || type == T_PRIMITIVE_OBJECT || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -2368,4 +2484,8 @@\n-  if (!is_store && type == T_OBJECT) {\n-    const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);\n-    if (tjp != NULL) {\n-      value_type = tjp;\n+  if (!is_store) {\n+    if (type == T_OBJECT) {\n+      const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);\n+      if (tjp != NULL) {\n+        value_type = tjp;\n+      }\n+    } else if (type == T_PRIMITIVE_OBJECT) {\n+      value_type = NULL;\n@@ -2387,2 +2507,2 @@\n-    ciField* field = alias_type->field();\n-    if (heap_base_oop != top() && field != NULL && field->is_constant() && !mismatched) {\n+\n+    if (heap_base_oop != top() && field != NULL && field->is_constant() && !field->is_flattened() && !mismatched) {\n@@ -2394,1 +2514,16 @@\n-      p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n+      if (type == T_PRIMITIVE_OBJECT) {\n+        if (adr_type->isa_instptr() && !mismatched) {\n+          ciInstanceKlass* holder = adr_type->is_instptr()->instance_klass();\n+          int offset = adr_type->is_instptr()->offset();\n+          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, base, holder, offset, decorators);\n+        } else {\n+          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, NULL, 0, decorators);\n+        }\n+      } else {\n+        p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n+        const TypeOopPtr* ptr = value_type->make_oopptr();\n+        if (ptr != NULL && ptr->is_inlinetypeptr()) {\n+          \/\/ Load a non-flattened inline type from memory\n+          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass(), !ptr->maybe_null());\n+        }\n+      }\n@@ -2432,1 +2567,17 @@\n-    access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n+    if (type == T_PRIMITIVE_OBJECT) {\n+      if (adr_type->isa_instptr() && !mismatched) {\n+        ciInstanceKlass* holder = adr_type->is_instptr()->instance_klass();\n+        int offset = adr_type->is_instptr()->offset();\n+        val->as_InlineType()->store_flattened(this, base, base, holder, offset, decorators);\n+      } else {\n+        val->as_InlineType()->store_flattened(this, base, adr, NULL, 0, decorators);\n+      }\n+    } else {\n+      access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n+    }\n+  }\n+\n+  if (argument(1)->is_InlineType() && is_store) {\n+    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n+    value = value->make_larval(this, false);\n+    replace_in_map(argument(1), value);\n@@ -2438,0 +2589,40 @@\n+bool LibraryCallKit::inline_unsafe_make_private_buffer() {\n+  Node* receiver = argument(0);\n+  Node* value = argument(1);\n+  if (!value->is_InlineType()) {\n+    return false;\n+  }\n+\n+  receiver = null_check(receiver);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n+  set_result(value->as_InlineType()->make_larval(this, true));\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_unsafe_finish_private_buffer() {\n+  Node* receiver = argument(0);\n+  Node* buffer = argument(1);\n+  if (!buffer->is_InlineType()) {\n+    return false;\n+  }\n+  InlineTypeNode* vt = buffer->as_InlineType();\n+  if (!vt->is_allocated(&_gvn)) {\n+    return false;\n+  }\n+  \/\/ TODO 8239003 Why is this needed?\n+  if (AllocateNode::Ideal_allocation(vt->get_oop(), &_gvn) == NULL) {\n+    return false;\n+  }\n+\n+  receiver = null_check(receiver);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n+  set_result(vt->finish_larval(this));\n+  return true;\n+}\n+\n@@ -2643,0 +2834,13 @@\n+    if (oldval != NULL && oldval->is_InlineType()) {\n+      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      oldval = oldval->as_InlineType()->buffer(this)->get_oop();\n+    }\n+    if (newval != NULL && newval->is_InlineType()) {\n+      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      newval = newval->as_InlineType()->buffer(this)->get_oop();\n+    }\n+\n@@ -2804,2 +3008,7 @@\n-\n-  Node* obj = new_instance(kls, test);\n+  Node* obj = NULL;\n+  const TypeInstKlassPtr* tkls = _gvn.type(kls)->isa_instklassptr();\n+  if (tkls != NULL && tkls->instance_klass()->is_inlinetype()) {\n+    obj = InlineTypeNode::make_default(_gvn, tkls->instance_klass()->as_inline_klass())->buffer(this);\n+  } else {\n+    obj = new_instance(kls, test);\n+  }\n@@ -3385,1 +3594,1 @@\n-  const Type* objects_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, objects_klass, xk, 0);\n+  const Type* objects_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, objects_klass, xk, TypeAryPtr::Offset(0));\n@@ -3404,9 +3613,0 @@\n-\/\/---------------------------load_mirror_from_klass----------------------------\n-\/\/ Given a klass oop, load its java mirror (a java.lang.Class oop).\n-Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {\n-  Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));\n-  Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n-  \/\/ mirror = ((OopHandle)mirror)->resolve();\n-  return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);\n-}\n-\n@@ -3455,0 +3655,1 @@\n+\n@@ -3648,0 +3849,31 @@\n+\/\/-------------------------inline_primitive_Class_conversion-------------------\n+\/\/               Class<T> java.lang.Class                  .asPrimaryType()\n+\/\/ public static Class<T> jdk.internal.value.PrimitiveClass.asPrimaryType(Class<T>)\n+\/\/               Class<T> java.lang.Class                  .asValueType()\n+\/\/ public static Class<T> jdk.internal.value.PrimitiveClass.asValueType(Class<T>)\n+bool LibraryCallKit::inline_primitive_Class_conversion(vmIntrinsics::ID id) {\n+  Node* mirror = argument(0); \/\/ Receiver\/argument Class\n+  const TypeInstPtr* mirror_con = _gvn.type(mirror)->isa_instptr();\n+  if (mirror_con == NULL) {\n+    return false;\n+  }\n+\n+  bool is_val_mirror = true;\n+  ciType* tm = mirror_con->java_mirror_type(&is_val_mirror);\n+  if (tm != NULL) {\n+    Node* result = mirror;\n+    if ((id == vmIntrinsics::_asPrimaryType || id == vmIntrinsics::_asPrimaryTypeArg) && is_val_mirror) {\n+      result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->ref_mirror()));\n+    } else if (id == vmIntrinsics::_asValueType || id == vmIntrinsics::_asValueTypeArg) {\n+      if (!tm->is_inlinetype()) {\n+        return false; \/\/ Throw UnsupportedOperationException\n+      } else if (!is_val_mirror) {\n+        result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->val_mirror()));\n+      }\n+    }\n+    set_result(result);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -3663,1 +3895,2 @@\n-  ciType* tm = mirror_con->java_mirror_type();\n+  bool requires_null_check = false;\n+  ciType* tm = mirror_con->java_mirror_type(&requires_null_check);\n@@ -3673,0 +3906,3 @@\n+        if (requires_null_check) {\n+          obj = null_check(obj);\n+        }\n@@ -3693,0 +3929,3 @@\n+  if (requires_null_check) {\n+    obj = null_check(obj);\n+  }\n@@ -3700,1 +3939,1 @@\n-  enum { _bad_type_path = 1, _prim_path = 2, PATH_LIMIT };\n+  enum { _bad_type_path = 1, _prim_path = 2, _npe_path = 3, PATH_LIMIT };\n@@ -3710,0 +3949,2 @@\n+  Node* io = i_o();\n+  Node* mem = merged_memory();\n@@ -3711,0 +3952,21 @@\n+    if (EnableValhalla && !requires_null_check) {\n+      \/\/ Check if we are casting to QMyValue\n+      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), NULL);\n+      if (ctrl_val_mirror != NULL) {\n+        RegionNode* r = new RegionNode(3);\n+        record_for_igvn(r);\n+        r->init_req(1, control());\n+\n+        \/\/ Casting to QMyValue, check for null\n+        set_control(ctrl_val_mirror);\n+        { \/\/ PreserveJVMState because null check replaces obj in map\n+          PreserveJVMState pjvms(this);\n+          Node* null_ctr = top();\n+          null_check_oop(obj, &null_ctr);\n+          region->init_req(_npe_path, null_ctr);\n+          r->init_req(2, control());\n+        }\n+        set_control(_gvn.transform(r));\n+      }\n+    }\n+\n@@ -3717,1 +3979,2 @@\n-      region->in(_bad_type_path) != top()) {\n+      region->in(_bad_type_path) != top() ||\n+      region->in(_npe_path) != top()) {\n@@ -3721,0 +3984,3 @@\n+    \/\/ Set IO and memory because gen_checkcast may override them when buffering inline types\n+    set_i_o(io);\n+    set_all_memory(mem);\n@@ -3754,0 +4020,1 @@\n+  RegionNode* prim_region = new RegionNode(2);\n@@ -3756,0 +4023,1 @@\n+  record_for_igvn(prim_region);\n@@ -3780,2 +4048,5 @@\n-    int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);\n-    region->init_req(prim_path, null_ctl);\n+    if (which_arg == 0) {\n+      prim_region->init_req(1, null_ctl);\n+    } else {\n+      region->init_req(_prim_1_path, null_ctl);\n+    }\n@@ -3791,0 +4062,3 @@\n+    \/\/ If superc is an inline mirror, we also need to check if superc == subc because LMyValue\n+    \/\/ is not a subtype of QMyValue but due to subk == superk the subtype check will pass.\n+    generate_fair_guard(is_val_mirror(args[0]), prim_region);\n@@ -3798,1 +4072,2 @@\n-  set_control(region->in(_prim_0_path)); \/\/ go back to first null check\n+  \/\/ This path is also used if superc is a value mirror.\n+  set_control(_gvn.transform(prim_region));\n@@ -3803,1 +4078,1 @@\n-    generate_guard(bol_eq, region, PROB_FAIR);\n+    generate_fair_guard(bol_eq, region);\n@@ -3834,2 +4109,1 @@\n-Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region,\n-                                                  bool obj_array, bool not_array) {\n+Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind) {\n@@ -3841,9 +4115,0 @@\n-  \/\/ If obj_array\/non_array==false\/false:\n-  \/\/ Branch around if the given klass is in fact an array (either obj or prim).\n-  \/\/ If obj_array\/non_array==false\/true:\n-  \/\/ Branch around if the given klass is not an array klass of any kind.\n-  \/\/ If obj_array\/non_array==true\/true:\n-  \/\/ Branch around if the kls is not an oop array (kls is int[], String, etc.)\n-  \/\/ If obj_array\/non_array==true\/false:\n-  \/\/ Branch around if the kls is an oop array (Object[] or subtype)\n-  \/\/\n@@ -3854,4 +4119,11 @@\n-    bool query = (obj_array\n-                  ? Klass::layout_helper_is_objArray(layout_con)\n-                  : Klass::layout_helper_is_array(layout_con));\n-    if (query == not_array) {\n+    bool query = 0;\n+    switch(kind) {\n+      case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;\n+      case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;\n+      case TypeArray:      query = Klass::layout_helper_is_typeArray(layout_con); break;\n+      case AnyArray:       query = Klass::layout_helper_is_array(layout_con); break;\n+      case NonArray:       query = !Klass::layout_helper_is_array(layout_con); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    if (!query) {\n@@ -3867,0 +4139,21 @@\n+  unsigned int value = 0;\n+  BoolTest::mask btest = BoolTest::illegal;\n+  switch(kind) {\n+    case ObjectArray:\n+    case NonObjectArray: {\n+      value = Klass::_lh_array_tag_obj_value;\n+      layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n+      btest = (kind == ObjectArray) ? BoolTest::eq : BoolTest::ne;\n+      break;\n+    }\n+    case TypeArray: {\n+      value = Klass::_lh_array_tag_type_value;\n+      layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n+      btest = BoolTest::eq;\n+      break;\n+    }\n+    case AnyArray:    value = Klass::_lh_neutral_value; btest = BoolTest::lt; break;\n+    case NonArray:    value = Klass::_lh_neutral_value; btest = BoolTest::gt; break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -3868,4 +4161,1 @@\n-  jint  nval = (obj_array\n-                ? (jint)(Klass::_lh_array_tag_type_value\n-                   <<    Klass::_lh_array_tag_shift)\n-                : Klass::_lh_neutral_value);\n+  jint nval = (jint)value;\n@@ -3873,3 +4163,0 @@\n-  BoolTest::mask btest = BoolTest::lt;  \/\/ correct for testing is_[obj]array\n-  \/\/ invert the test if we are looking for a non-array\n-  if (not_array)  btest = BoolTest(btest).negate();\n@@ -3882,1 +4169,1 @@\n-\/\/ private static native Object java.lang.reflect.newArray(Class<?> componentType, int length);\n+\/\/ private static native Object java.lang.reflect.Array.newArray(Class<?> componentType, int length);\n@@ -4027,1 +4314,13 @@\n-    Node* not_objArray = generate_non_objArray_guard(klass_node, bailout);\n+    \/\/ Inline type array may have object field that would require a\n+    \/\/ write barrier. Conservatively, go to slow path.\n+    \/\/ TODO 8251971: Optimize for the case when flat src\/dst are later found\n+    \/\/ to not contain oops (i.e., move this check to the macro expansion phase).\n+    BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+    const TypeAryPtr* orig_t = _gvn.type(original)->isa_aryptr();\n+    const TypeKlassPtr* tklass = _gvn.type(klass_node)->is_klassptr();\n+    bool exclude_flat = UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, false, false, BarrierSetC2::Parsing) &&\n+                        \/\/ Can src array be flat and contain oops?\n+                        (orig_t == NULL || (!orig_t->is_not_flat() && (!orig_t->is_flat() || orig_t->elem()->inline_klass()->contains_oops()))) &&\n+                        \/\/ Can dest array be flat and contain oops?\n+                        tklass->can_be_inline_array() && (!tklass->is_flat() || tklass->is_aryklassptr()->elem()->is_instklassptr()->instance_klass()->as_inline_klass()->contains_oops());\n+    Node* not_objArray = exclude_flat ? generate_non_objArray_guard(klass_node, bailout) : generate_typeArray_guard(klass_node, bailout);\n@@ -4031,1 +4330,1 @@\n-      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, 0\/*offset*\/);\n+      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));\n@@ -4052,0 +4351,32 @@\n+    \/\/ Handle inline type arrays\n+    bool can_validate = !too_many_traps(Deoptimization::Reason_class_check);\n+    if (!stopped()) {\n+      orig_t = _gvn.type(original)->isa_aryptr();\n+      if (orig_t != NULL && orig_t->is_flat()) {\n+        \/\/ Src is flat, check that dest is flat as well\n+        if (exclude_flat) {\n+          \/\/ Dest can't be flat, bail out\n+          bailout->add_req(control());\n+          set_control(top());\n+        } else {\n+          generate_fair_guard(flat_array_test(klass_node, \/* flat = *\/ false), bailout);\n+        }\n+      } else if (UseFlatArray && (orig_t == NULL || !orig_t->is_not_flat()) &&\n+                 \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check if validated).\n+                 ((!tklass->is_flat() && tklass->can_be_inline_array()) || !can_validate)) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n+        generate_fair_guard(flat_array_test(load_object_klass(original)), bailout);\n+        if (orig_t != NULL) {\n+          orig_t = orig_t->cast_to_not_flat();\n+          original = _gvn.transform(new CheckCastPPNode(control(), original, orig_t));\n+        }\n+      }\n+      if (!can_validate) {\n+        \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n+        \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat\/null-free.\n+        generate_fair_guard(null_free_array_test(klass_node), bailout);\n+      }\n+    }\n+\n@@ -4094,1 +4425,1 @@\n-      if (!too_many_traps(Deoptimization::Reason_class_check)) {\n+      if (can_validate) {\n@@ -4233,1 +4564,6 @@\n-  Node* obj = NULL;\n+  Node* obj = argument(0);\n+\n+  if (gvn().type(obj)->is_inlinetypeptr()) {\n+    return false;\n+  }\n+\n@@ -4243,1 +4579,0 @@\n-    obj = argument(0);\n@@ -4283,1 +4618,2 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+  \/\/ This also serves as guard against inline types\n+  Node *lock_mask      = _gvn.MakeConX(markWord::inline_type_mask_in_place);\n@@ -4349,1 +4685,10 @@\n-  Node* obj = null_check_receiver();\n+  Node* obj = argument(0);\n+  if (obj->is_InlineType()) {\n+    const Type* t = _gvn.type(obj);\n+    if (t->maybe_null()) {\n+      null_check(obj);\n+    }\n+    set_result(makecon(TypeInstPtr::make(t->inline_klass()->java_mirror())));\n+    return true;\n+  }\n+  obj = null_check_receiver();\n@@ -4714,1 +5059,2 @@\n-    Node* obj = null_check_receiver();\n+    Node* obj = argument(0);\n+    obj = null_check_receiver();\n@@ -4724,1 +5070,2 @@\n-        obj_type->speculative_type()->is_instance_klass()) {\n+        obj_type->speculative_type()->is_instance_klass() &&\n+        !obj_type->speculative_type()->is_inlinetype()) {\n@@ -4754,0 +5101,5 @@\n+    \/\/ We only go to the fast case code if we pass a number of guards.\n+    \/\/ The paths which do not pass are accumulated in the slow_region.\n+    RegionNode* slow_region = new RegionNode(1);\n+    record_for_igvn(slow_region);\n+\n@@ -4759,3 +5111,0 @@\n-      Node* obj_length = load_array_length(obj);\n-      Node* obj_size  = NULL;\n-      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n@@ -4764,20 +5113,7 @@\n-      if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing)) {\n-        \/\/ If it is an oop array, it requires very special treatment,\n-        \/\/ because gc barriers are required when accessing the array.\n-        Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n-        if (is_obja != NULL) {\n-          PreserveJVMState pjvms2(this);\n-          set_control(is_obja);\n-          \/\/ Generate a direct call to the right arraycopy function(s).\n-          \/\/ Clones are always tightly coupled.\n-          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n-          ac->set_clone_oop_array();\n-          Node* n = _gvn.transform(ac);\n-          assert(n == ac, \"cannot disappear\");\n-          ac->connect_outputs(this, \/*deoptimize_on_exception=*\/true);\n-\n-          result_reg->init_req(_objArray_path, control());\n-          result_val->init_req(_objArray_path, alloc_obj);\n-          result_i_o ->set_req(_objArray_path, i_o());\n-          result_mem ->set_req(_objArray_path, reset_memory());\n-        }\n+      const TypeAryPtr* ary_ptr = obj_type->isa_aryptr();\n+      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Expansion) &&\n+          obj_type->can_be_inline_array() &&\n+          (ary_ptr == NULL || (!ary_ptr->is_not_flat() && (!ary_ptr->is_flat() || ary_ptr->elem()->inline_klass()->contains_oops())))) {\n+        \/\/ Flattened inline type array may have object field that would require a\n+        \/\/ write barrier. Conservatively, go to slow path.\n+        generate_fair_guard(flat_array_test(obj_klass), slow_region);\n@@ -4785,7 +5121,0 @@\n-      \/\/ Otherwise, there are no barriers to worry about.\n-      \/\/ (We can dispense with card marks if we know the allocation\n-      \/\/  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks\n-      \/\/  causes the non-eden paths to take compensating steps to\n-      \/\/  simulate a fresh allocation, so that no further\n-      \/\/  card marks are required in compiled code to initialize\n-      \/\/  the object.)\n@@ -4794,7 +5123,43 @@\n-        copy_to_clone(obj, alloc_obj, obj_size, true);\n-\n-        \/\/ Present the results of the copy.\n-        result_reg->init_req(_array_path, control());\n-        result_val->init_req(_array_path, alloc_obj);\n-        result_i_o ->set_req(_array_path, i_o());\n-        result_mem ->set_req(_array_path, reset_memory());\n+        Node* obj_length = load_array_length(obj);\n+        Node* obj_size  = NULL;\n+        Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+\n+        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+        if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing)) {\n+          \/\/ If it is an oop array, it requires very special treatment,\n+          \/\/ because gc barriers are required when accessing the array.\n+          Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n+          if (is_obja != NULL) {\n+            PreserveJVMState pjvms2(this);\n+            set_control(is_obja);\n+            \/\/ Generate a direct call to the right arraycopy function(s).\n+            \/\/ Clones are always tightly coupled.\n+            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n+            ac->set_clone_oop_array();\n+            Node* n = _gvn.transform(ac);\n+            assert(n == ac, \"cannot disappear\");\n+            ac->connect_outputs(this, \/*deoptimize_on_exception=*\/true);\n+\n+            result_reg->init_req(_objArray_path, control());\n+            result_val->init_req(_objArray_path, alloc_obj);\n+            result_i_o ->set_req(_objArray_path, i_o());\n+            result_mem ->set_req(_objArray_path, reset_memory());\n+          }\n+        }\n+        \/\/ Otherwise, there are no barriers to worry about.\n+        \/\/ (We can dispense with card marks if we know the allocation\n+        \/\/  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks\n+        \/\/  causes the non-eden paths to take compensating steps to\n+        \/\/  simulate a fresh allocation, so that no further\n+        \/\/  card marks are required in compiled code to initialize\n+        \/\/  the object.)\n+\n+        if (!stopped()) {\n+          copy_to_clone(obj, alloc_obj, obj_size, true);\n+\n+          \/\/ Present the results of the copy.\n+          result_reg->init_req(_array_path, control());\n+          result_val->init_req(_array_path, alloc_obj);\n+          result_i_o ->set_req(_array_path, i_o());\n+          result_mem ->set_req(_array_path, reset_memory());\n+        }\n@@ -4804,4 +5169,0 @@\n-    \/\/ We only go to the instance fast case code if we pass a number of guards.\n-    \/\/ The paths which do not pass are accumulated in the slow_region.\n-    RegionNode* slow_region = new RegionNode(1);\n-    record_for_igvn(slow_region);\n@@ -4968,2 +5329,1 @@\n-    CallProjections callprojs;\n-    alloc->extract_projections(&callprojs, true);\n+    CallProjections* callprojs = alloc->extract_projections(true);\n@@ -4972,1 +5332,1 @@\n-    C->gvn_replace_by(callprojs.fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n+    C->gvn_replace_by(callprojs->fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -5014,1 +5374,1 @@\n-    set_i_o(callprojs.fallthrough_ioproj);\n+    set_i_o(callprojs->fallthrough_ioproj);\n@@ -5190,0 +5550,2 @@\n+          src_type = _gvn.type(src);\n+          top_src = src_type->isa_aryptr();\n@@ -5193,0 +5555,2 @@\n+          dest_type = _gvn.type(dest);\n+          top_dest = dest_type->isa_aryptr();\n@@ -5208,2 +5572,1 @@\n-      can_emit_guards &&\n-      !src->is_top() && !dest->is_top()) {\n+      can_emit_guards && !src->is_top() && !dest->is_top()) {\n@@ -5252,0 +5615,2 @@\n+      slow_region->add_req(not_subtype_ctrl);\n+    }\n@@ -5253,6 +5618,28 @@\n-      if (not_subtype_ctrl != top()) {\n-        PreserveJVMState pjvms(this);\n-        set_control(not_subtype_ctrl);\n-        uncommon_trap(Deoptimization::Reason_intrinsic,\n-                      Deoptimization::Action_make_not_entrant);\n-        assert(stopped(), \"Should be stopped\");\n+    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->is_klassptr();\n+    const Type* toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n+    src = _gvn.transform(new CheckCastPPNode(control(), src, toop));\n+    src_type = _gvn.type(src);\n+    top_src  = src_type->isa_aryptr();\n+\n+    \/\/ Handle flat inline type arrays (null-free arrays are handled by the subtype check above)\n+    if (!stopped() && UseFlatArray) {\n+      \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check). Handle flat src here.\n+      assert(top_dest == NULL || !top_dest->is_flat() || top_src->is_flat(), \"src array must be flat\");\n+      if (top_src != NULL && top_src->is_flat()) {\n+        \/\/ Src is flat, check that dest is flat as well\n+        if (top_dest != NULL && !top_dest->is_flat()) {\n+          generate_fair_guard(flat_array_test(dest_klass, \/* flat = *\/ false), slow_region);\n+          \/\/ Since dest is flat and src <: dest, dest must have the same type as src.\n+          top_dest = top_src->cast_to_exactness(false);\n+          assert(top_dest->is_flat(), \"dest must be flat\");\n+          dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));\n+        }\n+      } else if (top_src == NULL || !top_src->is_not_flat()) {\n+        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n+        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n+        assert(top_dest == NULL || !top_dest->is_flat(), \"dest array must not be flat\");\n+        generate_fair_guard(flat_array_test(src), slow_region);\n+        if (top_src != NULL) {\n+          top_src = top_src->cast_to_not_flat();\n+          src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));\n+        }\n@@ -5261,0 +5648,1 @@\n+\n@@ -5268,4 +5656,0 @@\n-\n-    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->is_klassptr();\n-    const Type *toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n-    src = _gvn.transform(new CheckCastPPNode(control(), src, toop));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":509,"deletions":125,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -108,3 +109,11 @@\n-    if (!stopped() && result() != NULL) {\n-      BasicType bt = result()->bottom_type()->basic_type();\n-      push_node(bt, result());\n+    Node* res = result();\n+    if (!stopped() && res != NULL) {\n+      BasicType bt = res->bottom_type()->basic_type();\n+      if (C->inlining_incrementally() && res->is_InlineType()) {\n+        \/\/ The caller expects an oop when incrementally inlining an intrinsic that returns an\n+        \/\/ inline type. Make sure the call is re-executed if the allocation triggers a deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        res = res->as_InlineType()->buffer(this);\n+      }\n+      push_node(bt, res);\n@@ -141,1 +150,0 @@\n-  Node* load_mirror_from_klass(Node* klass);\n@@ -163,0 +171,9 @@\n+\n+  enum ArrayKind {\n+    AnyArray,\n+    NonArray,\n+    ObjectArray,\n+    NonObjectArray,\n+    TypeArray\n+  };\n+\n@@ -164,0 +181,1 @@\n+\n@@ -165,1 +183,1 @@\n-    return generate_array_guard_common(kls, region, false, false);\n+    return generate_array_guard_common(kls, region, AnyArray);\n@@ -168,1 +186,1 @@\n-    return generate_array_guard_common(kls, region, false, true);\n+    return generate_array_guard_common(kls, region, NonArray);\n@@ -171,1 +189,1 @@\n-    return generate_array_guard_common(kls, region, true, false);\n+    return generate_array_guard_common(kls, region, ObjectArray);\n@@ -174,1 +192,4 @@\n-    return generate_array_guard_common(kls, region, true, true);\n+    return generate_array_guard_common(kls, region, NonObjectArray);\n+  }\n+  Node* generate_typeArray_guard(Node* kls, RegionNode* region) {\n+    return generate_array_guard_common(kls, region, TypeArray);\n@@ -176,2 +197,1 @@\n-  Node* generate_array_guard_common(Node* kls, RegionNode* region,\n-                                    bool obj_array, bool not_array);\n+  Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);\n@@ -237,0 +257,2 @@\n+  bool inline_unsafe_make_private_buffer();\n+  bool inline_unsafe_finish_private_buffer();\n@@ -253,0 +275,1 @@\n+  bool inline_primitive_Class_conversion(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -80,2 +80,4 @@\n-         LoopNestInnerLoop = 1 << 18,\n-         LoopNestLongOuterLoop = 1 << 19};\n+         LoopNestInnerLoop   = 1<< 18,\n+         LoopNestLongOuterLoop = 1<< 19,\n+         FlattenedArrays     = 1<<20};\n+\n@@ -108,0 +110,1 @@\n+  bool is_flattened_arrays() const { return _loop_flags & FlattenedArrays; }\n@@ -125,0 +128,1 @@\n+  void mark_flattened_arrays() { _loop_flags |= FlattenedArrays; }\n@@ -1428,3 +1432,3 @@\n-                                        Node_List &old_new,\n-                                        IfNode* unswitch_iff,\n-                                        CloneLoopMode mode);\n+                                      Node_List &old_new,\n+                                      Node_List &unswitch_iffs,\n+                                      CloneLoopMode mode);\n@@ -1448,1 +1452,1 @@\n-  IfNode* find_unswitching_candidate(const IdealLoopTree *loop) const;\n+  IfNode* find_unswitching_candidate(const IdealLoopTree *loop, Node_List& unswitch_iffs) const;\n@@ -1565,0 +1569,1 @@\n+  void move_flat_array_check_out_of_loop(Node* n);\n@@ -1566,0 +1571,1 @@\n+  bool flatten_array_element_type_check(Node *n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -64,0 +65,6 @@\n+  \/\/ Inline types should not be split through Phis because they cannot be merged\n+  \/\/ through Phi nodes but each value input needs to be merged individually.\n+  if (n->is_InlineType()) {\n+    return NULL;\n+  }\n+\n@@ -999,0 +1006,49 @@\n+\/\/ If UseArrayMarkWordCheck is enabled, we can't use immutable memory for the flat array check\n+\/\/ because we are loading the mark word which is mutable. Although the bits we are interested in\n+\/\/ are immutable (we check for markWord::unlocked_value), we need to use raw memory to not break\n+\/\/ anti dependency analysis. Below code will attempt to still move flat array checks out of loops,\n+\/\/ mainly to enable loop unswitching.\n+void PhaseIdealLoop::move_flat_array_check_out_of_loop(Node* n) {\n+  \/\/ Skip checks for more than one array\n+  if (n->req() > 3) {\n+    return;\n+  }\n+  Node* mem = n->in(FlatArrayCheckNode::Memory);\n+  Node* array = n->in(FlatArrayCheckNode::ArrayOrKlass)->uncast();\n+  IdealLoopTree* check_loop = get_loop(get_ctrl(n));\n+  IdealLoopTree* ary_loop = get_loop(get_ctrl(array));\n+\n+  \/\/ Check if array is loop invariant\n+  if (!check_loop->is_member(ary_loop)) {\n+    \/\/ Walk up memory graph from the check until we leave the loop\n+    VectorSet wq;\n+    wq.set(mem->_idx);\n+    while (check_loop->is_member(get_loop(ctrl_or_self(mem)))) {\n+      if (mem->is_Phi()) {\n+        mem = mem->in(1);\n+      } else if (mem->is_MergeMem()) {\n+        mem = mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw);\n+      } else if (mem->is_Proj()) {\n+        mem = mem->in(0);\n+      } else if (mem->is_MemBar() || mem->is_SafePoint()) {\n+        mem = mem->in(TypeFunc::Memory);\n+      } else if (mem->is_Store() || mem->is_LoadStore() || mem->is_ClearArray()) {\n+        mem = mem->in(MemNode::Memory);\n+      } else {\n+#ifdef ASSERT\n+        mem->dump();\n+#endif\n+        ShouldNotReachHere();\n+      }\n+      if (wq.test_set(mem->_idx)) {\n+        return;\n+      }\n+    }\n+    \/\/ Replace memory input and re-compute ctrl to move the check out of the loop\n+    _igvn.replace_input_of(n, 1, mem);\n+    set_ctrl_and_loop(n, get_early_ctrl(n));\n+    Node* bol = n->unique_out();\n+    set_ctrl_and_loop(bol, get_early_ctrl(bol));\n+  }\n+}\n+\n@@ -1011,0 +1067,6 @@\n+\n+  if (UseArrayMarkWordCheck && n->isa_FlatArrayCheck()) {\n+    move_flat_array_check_out_of_loop(n);\n+    return n;\n+  }\n+\n@@ -1288,0 +1350,96 @@\n+bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {\n+  \/\/ If the CmpP is a subtype check for a value that has just been\n+  \/\/ loaded from an array, the subtype check guarantees the value\n+  \/\/ can't be stored in a flattened array and the load of the value\n+  \/\/ happens with a flattened array check then: push the type check\n+  \/\/ through the phi of the flattened array check. This needs special\n+  \/\/ logic because the subtype check's input is not a phi but a\n+  \/\/ LoadKlass that must first be cloned through the phi.\n+  if (n->Opcode() != Op_CmpP) {\n+    return false;\n+  }\n+\n+  Node* klassptr = n->in(1);\n+  Node* klasscon = n->in(2);\n+\n+  if (klassptr->is_DecodeNarrowPtr()) {\n+    klassptr = klassptr->in(1);\n+  }\n+\n+  if (klassptr->Opcode() != Op_LoadKlass && klassptr->Opcode() != Op_LoadNKlass) {\n+    return false;\n+  }\n+\n+  if (!klasscon->is_Con()) {\n+    return false;\n+  }\n+\n+  Node* addr = klassptr->in(MemNode::Address);\n+\n+  if (!addr->is_AddP()) {\n+    return false;\n+  }\n+\n+  intptr_t offset;\n+  Node* obj = AddPNode::Ideal_base_and_offset(addr, &_igvn, offset);\n+\n+  if (obj == NULL) {\n+    return false;\n+  }\n+\n+  assert(obj != NULL && addr->in(AddPNode::Base) == addr->in(AddPNode::Address), \"malformed AddP?\");\n+  if (obj->Opcode() == Op_CastPP) {\n+    obj = obj->in(1);\n+  }\n+\n+  if (!obj->is_Phi()) {\n+    return false;\n+  }\n+\n+  Node* region = obj->in(0);\n+\n+  Node* phi = PhiNode::make_blank(region, n->in(1));\n+  for (uint i = 1; i < region->req(); i++) {\n+    Node* in = obj->in(i);\n+    Node* ctrl = region->in(i);\n+    if (addr->in(AddPNode::Base) != obj) {\n+      Node* cast = addr->in(AddPNode::Base);\n+      assert(cast->Opcode() == Op_CastPP && cast->in(0) != NULL, \"inconsistent subgraph\");\n+      Node* cast_clone = cast->clone();\n+      cast_clone->set_req(0, ctrl);\n+      cast_clone->set_req(1, in);\n+      register_new_node(cast_clone, ctrl);\n+      _igvn.set_type(cast_clone, cast_clone->Value(&_igvn));\n+      in = cast_clone;\n+    }\n+    Node* addr_clone = addr->clone();\n+    addr_clone->set_req(AddPNode::Base, in);\n+    addr_clone->set_req(AddPNode::Address, in);\n+    register_new_node(addr_clone, ctrl);\n+    _igvn.set_type(addr_clone, addr_clone->Value(&_igvn));\n+    Node* klassptr_clone = klassptr->clone();\n+    klassptr_clone->set_req(2, addr_clone);\n+    register_new_node(klassptr_clone, ctrl);\n+    _igvn.set_type(klassptr_clone, klassptr_clone->Value(&_igvn));\n+    if (klassptr != n->in(1)) {\n+      Node* decode = n->in(1);\n+      assert(decode->is_DecodeNarrowPtr(), \"inconsistent subgraph\");\n+      Node* decode_clone = decode->clone();\n+      decode_clone->set_req(1, klassptr_clone);\n+      register_new_node(decode_clone, ctrl);\n+      _igvn.set_type(decode_clone, decode_clone->Value(&_igvn));\n+      klassptr_clone = decode_clone;\n+    }\n+    phi->set_req(i, klassptr_clone);\n+  }\n+  register_new_node(phi, region);\n+  Node* orig = n->in(1);\n+  _igvn.replace_input_of(n, 1, phi);\n+  split_if_with_blocks_post(n);\n+  if (n->outcnt() != 0) {\n+    _igvn.replace_input_of(n, 1, orig);\n+    _igvn.remove_dead_node(phi);\n+  }\n+  return true;\n+}\n+\n@@ -1294,0 +1452,4 @@\n+  if (flatten_array_element_type_check(n)) {\n+    return;\n+  }\n+\n@@ -1428,0 +1590,5 @@\n+\n+  \/\/ Remove multiple allocations of the same inline type\n+  if (n->is_InlineType()) {\n+    n->as_InlineType()->remove_redundant_allocations(this);\n+  }\n@@ -1855,1 +2022,9 @@\n-  Node *sample_cmp = sample_bool->in(1);\n+  Node* sample_cmp = sample_bool->in(1);\n+  const Type* t = Type::TOP;\n+  const TypePtr* at = NULL;\n+  if (sample_cmp->is_FlatArrayCheck()) {\n+    \/\/ Left input of a FlatArrayCheckNode is memory, set the (adr) type of the phi accordingly\n+    assert(sample_cmp->in(1)->bottom_type() == Type::MEMORY, \"unexpected input type\");\n+    t = Type::MEMORY;\n+    at = TypeRawPtr::BOTTOM;\n+  }\n@@ -1858,1 +2033,1 @@\n-  PhiNode *phi1 = new PhiNode(phi->in(0), Type::TOP);\n+  PhiNode *phi1 = new PhiNode(phi->in(0), t, at);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":177,"deletions":2,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -85,12 +88,0 @@\n-void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {\n-  assert(old != NULL, \"sanity\");\n-  for (DUIterator_Fast imax, i = old->fast_outs(imax); i < imax; i++) {\n-    Node* use = old->fast_out(i);\n-    _igvn.rehash_node_delayed(use);\n-    imax -= replace_input(use, old, target);\n-    \/\/ back up iterator\n-    --i;\n-  }\n-  assert(old->outcnt() == 0, \"all uses must be deleted\");\n-}\n-\n@@ -159,1 +150,1 @@\n-  bs->eliminate_gc_barrier(this, p2x);\n+  bs->eliminate_gc_barrier(&_igvn, p2x);\n@@ -213,1 +204,1 @@\n-        int adr_offset = atype->offset();\n+        int adr_offset = atype->flattened_offset();\n@@ -258,1 +249,1 @@\n-   } else if (mem->Opcode() == Op_StrInflatedCopy) {\n+    } else if (mem->Opcode() == Op_StrInflatedCopy) {\n@@ -303,1 +294,5 @@\n-      const TypePtr* adr_type = NULL;\n+      Node* base = ac->in(ArrayCopyNode::Src);\n+      const TypeAryPtr* adr_type = _igvn.type(base)->is_aryptr();\n+      if (adr_type->is_aryptr()->is_flat()) {\n+        shift = adr_type->flat_log_elem_size();\n+      }\n@@ -306,2 +301,2 @@\n-        Node* base = ac->in(ArrayCopyNode::Src);\n-        adr_type = _igvn.type(base)->is_ptr()->add_offset(off);\n+        adr_type = _igvn.type(adr)->is_aryptr();\n+        assert(adr_type == _igvn.type(base)->is_aryptr()->add_field_offset_and_offset(off), \"incorrect address type\");\n@@ -311,1 +306,1 @@\n-          return value_from_mem(ac->in(TypeFunc::Memory), ctl, ft, ftype, adr_type->isa_oopptr(), alloc);\n+          return value_from_mem(ac->in(TypeFunc::Memory), ctl, ft, ftype, adr_type, alloc);\n@@ -314,0 +309,5 @@\n+        if (ac->in(ArrayCopyNode::Src) == ac->in(ArrayCopyNode::Dest)) {\n+          \/\/ Non constant offset in the array: we can't statically\n+          \/\/ determine the value\n+          return NULL;\n+        }\n@@ -321,7 +321,5 @@\n-        Node* base = ac->in(ArrayCopyNode::Src);\n-        adr_type = _igvn.type(base)->is_ptr()->add_offset(Type::OffsetBot);\n-        if (ac->in(ArrayCopyNode::Src) == ac->in(ArrayCopyNode::Dest)) {\n-          \/\/ Non constant offset in the array: we can't statically\n-          \/\/ determine the value\n-          return NULL;\n-        }\n+        \/\/ In the case of a flattened inline type array, each field has its\n+        \/\/ own slice so we need to extract the field being accessed from\n+        \/\/ the address computation\n+        adr_type = adr_type->add_field_offset_and_offset(offset)->add_offset(Type::OffsetBot)->is_aryptr();\n+        adr = _igvn.transform(new CastPPNode(adr, adr_type));\n@@ -338,0 +336,1 @@\n+      assert(res->isa_DecodeN(), \"should be narrow oop\");\n@@ -353,1 +352,1 @@\n-  int offset = adr_t->offset();\n+  int offset = adr_t->flattened_offset();\n@@ -388,1 +387,1 @@\n-    } else  {\n+    } else {\n@@ -392,1 +391,7 @@\n-        values.at_put(j, _igvn.zerocon(ft));\n+        Node* default_value = alloc->in(AllocateNode::DefaultValue);\n+        if (default_value != NULL) {\n+          values.at_put(j, default_value);\n+        } else {\n+          assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+          values.at_put(j, _igvn.zerocon(ft));\n+        }\n@@ -412,1 +417,7 @@\n-        values.at_put(j, _igvn.zerocon(ft));\n+        Node* default_value = alloc->in(AllocateNode::DefaultValue);\n+        if (default_value != NULL) {\n+          values.at_put(j, default_value);\n+        } else {\n+          assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+          values.at_put(j, _igvn.zerocon(ft));\n+        }\n@@ -456,1 +467,1 @@\n-  int offset = adr_t->offset();\n+  int offset = adr_t->flattened_offset();\n@@ -458,1 +469,0 @@\n-  Node *alloc_ctrl = alloc->in(TypeFunc::Control);\n@@ -474,1 +484,1 @@\n-        done = true; \/\/ Something go wrong.\n+        done = true; \/\/ Something went wrong.\n@@ -484,1 +494,1 @@\n-             atype->is_known_instance_field() && atype->offset() == offset &&\n+             atype->is_known_instance_field() && atype->flattened_offset() == offset &&\n@@ -517,0 +527,5 @@\n+      Node* default_value = alloc->in(AllocateNode::DefaultValue);\n+      if (default_value != NULL) {\n+        return default_value;\n+      }\n+      assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n@@ -548,1 +563,1 @@\n-  \/\/ Something go wrong.\n+  \/\/ Something went wrong.\n@@ -552,0 +567,42 @@\n+\/\/ Search the last value stored into the inline type's fields.\n+Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {\n+  \/\/ Subtract the offset of the first field to account for the missing oop header\n+  offset -= vk->first_field_offset();\n+  \/\/ Create a new InlineTypeNode and retrieve the field values from memory\n+  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk);\n+  transform_later(vt);\n+  for (int i = 0; i < vk->nof_declared_nonstatic_fields(); ++i) {\n+    ciType* field_type = vt->field_type(i);\n+    int field_offset = offset + vt->field_offset(i);\n+    Node* value = NULL;\n+    if (vt->field_is_flattened(i)) {\n+      value = inline_type_from_mem(mem, ctl, field_type->as_inline_klass(), adr_type, field_offset, alloc);\n+    } else {\n+      const Type* ft = Type::get_const_type(field_type);\n+      BasicType bt = type2field[field_type->basic_type()];\n+      if (UseCompressedOops && !is_java_primitive(bt)) {\n+        ft = ft->make_narrowoop();\n+        bt = T_NARROWOOP;\n+      }\n+      \/\/ Each inline type field has its own memory slice\n+      adr_type = adr_type->with_field_offset(field_offset);\n+      value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);\n+      if (value != NULL && ft->isa_narrowoop()) {\n+        assert(UseCompressedOops, \"unexpected narrow oop\");\n+        if (value->is_EncodeP()) {\n+          value = value->in(1);\n+        } else {\n+          value = transform_later(new DecodeNNode(value, value->get_ptr_type()));\n+        }\n+      }\n+    }\n+    if (value != NULL) {\n+      vt->set_field_value(i, value);\n+    } else {\n+      \/\/ We might have reached the TrackedInitializationLimit\n+      return NULL;\n+    }\n+  }\n+  return vt;\n+}\n+\n@@ -560,0 +617,1 @@\n+  Unique_Node_List worklist;\n@@ -568,0 +626,1 @@\n+    worklist.push(res);\n@@ -581,1 +640,1 @@\n-  if (can_eliminate && res != NULL) {\n+  while (can_eliminate && worklist.size() > 0) {\n@@ -583,2 +642,2 @@\n-    for (DUIterator_Fast jmax, j = res->fast_outs(jmax);\n-                               j < jmax && can_eliminate; j++) {\n+    res = worklist.pop();\n+    for (DUIterator_Fast jmax, j = res->fast_outs(jmax); j < jmax && can_eliminate; j++) {\n@@ -632,0 +691,21 @@\n+      } else if (use->is_InlineType() && use->as_InlineType()->get_oop() == res) {\n+        \/\/ Look at uses\n+        for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+          Node* u = use->fast_out(k);\n+          if (u->is_InlineType()) {\n+            \/\/ Use in flat field can be eliminated\n+            InlineTypeNode* vt = u->as_InlineType();\n+            for (uint i = 0; i < vt->field_count(); ++i) {\n+              if (vt->field_value(i) == use && !vt->field_is_flattened(i)) {\n+                can_eliminate = false; \/\/ Use in non-flattened field\n+                break;\n+              }\n+            }\n+          } else {\n+            \/\/ Add other uses to the worklist to process individually\n+            worklist.push(u);\n+          }\n+        }\n+      } else if (use->Opcode() == Op_StoreX && use->in(MemNode::Address) == res) {\n+        \/\/ Store to mark word of inline type larval buffer\n+        assert(res_type->is_inlinetypeptr(), \"Unexpected store to mark word\");\n@@ -643,1 +723,1 @@\n-          }else {\n+          } else {\n@@ -649,0 +729,3 @@\n+      } else {\n+        assert(use->Opcode() == Op_CastP2X, \"should be\");\n+        assert(!use->has_out_with(Op_OrL), \"should have been removed because oop is never null\");\n@@ -661,1 +744,1 @@\n-    } else if (alloc->_is_scalar_replaceable) {\n+    } else {\n@@ -707,0 +790,3 @@\n+      if (basic_elem_type == T_PRIMITIVE_OBJECT && !res_type->is_aryptr()->is_flat()) {\n+        basic_elem_type = T_OBJECT;\n+      }\n@@ -710,0 +796,4 @@\n+      if (res_type->is_aryptr()->is_flat()) {\n+        \/\/ Flattened inline type array\n+        element_size = res_type->is_aryptr()->flat_elem_size();\n+      }\n@@ -715,0 +805,2 @@\n+  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr(), \"Inline type allocations should not have safepoint uses\");\n+  Unique_Node_List value_worklist;\n@@ -741,0 +833,1 @@\n+        assert(!field->is_flattened(), \"flattened inline type fields should not have safepoint uses\");\n@@ -766,3 +859,9 @@\n-      const TypeOopPtr *field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n-\n-      Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n+      Node* field_val = NULL;\n+      const TypeOopPtr* field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n+      if (res_type->isa_aryptr() && res_type->is_aryptr()->is_flat()) {\n+        ciInlineKlass* vk = res_type->is_aryptr()->elem()->inline_klass();\n+        assert(vk->flatten_array(), \"must be flattened\");\n+        field_val = inline_type_from_mem(mem, ctl, vk, field_addr_type->isa_aryptr(), 0, alloc);\n+      } else {\n+        field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n+      }\n@@ -831,1 +930,1 @@\n-        } else {\n+        } else if (!field_val->is_InlineType()) {\n@@ -835,0 +934,4 @@\n+      if (field_val->is_InlineType()) {\n+        \/\/ Keep track of inline types to scalarize them later\n+        value_worklist.push(field_val);\n+      }\n@@ -847,0 +950,8 @@\n+  \/\/ Scalarize inline types that were added to the safepoint.\n+  \/\/ Don't allow linking a constant oop (if available) for flat array elements\n+  \/\/ because Deoptimization::reassign_flat_array_elements needs field values.\n+  bool allow_oop = res_type != NULL && (!res_type->isa_aryptr() || !res_type->is_aryptr()->is_flat());\n+  for (uint i = 0; i < value_worklist.size(); ++i) {\n+    InlineTypeNode* vt = value_worklist.at(i)->as_InlineType();\n+    vt->make_scalar_in_safepoints(&_igvn, allow_oop);\n+  }\n@@ -862,1 +973,2 @@\n-void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {\n+void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc, bool inline_alloc) {\n+  Unique_Node_List worklist;\n@@ -865,0 +977,4 @@\n+    worklist.push(res);\n+  }\n+  while (worklist.size() > 0) {\n+    res = worklist.pop();\n@@ -874,10 +990,7 @@\n-#ifdef ASSERT\n-            \/\/ Verify that there is no dependent MemBarVolatile nodes,\n-            \/\/ they should be removed during IGVN, see MemBarNode::Ideal().\n-            for (DUIterator_Fast pmax, p = n->fast_outs(pmax);\n-                                       p < pmax; p++) {\n-              Node* mb = n->fast_out(p);\n-              assert(mb->is_Initialize() || !mb->is_MemBar() ||\n-                     mb->req() <= MemBarNode::Precedent ||\n-                     mb->in(MemBarNode::Precedent) != n,\n-                     \"MemBarVolatile should be eliminated for non-escaping object\");\n+            for (DUIterator_Fast pmax, p = n->fast_outs(pmax); p < pmax; p++) {\n+              MemBarNode* mb = n->fast_out(p)->isa_MemBar();\n+              if (mb != NULL && mb->req() <= MemBarNode::Precedent && mb->in(MemBarNode::Precedent) == n) {\n+                \/\/ MemBarVolatiles should have been removed by MemBarNode::Ideal() for non-inline allocations\n+                assert(inline_alloc, \"MemBarVolatile should be eliminated for non-escaping object\");\n+                mb->remove(&_igvn);\n+              }\n@@ -885,1 +998,0 @@\n-#endif\n@@ -909,2 +1021,1 @@\n-          CallProjections callprojs;\n-          ac->extract_projections(&callprojs, true);\n+          CallProjections* callprojs = ac->extract_projections(true);\n@@ -912,3 +1023,3 @@\n-          _igvn.replace_node(callprojs.fallthrough_ioproj, ac->in(TypeFunc::I_O));\n-          _igvn.replace_node(callprojs.fallthrough_memproj, ac->in(TypeFunc::Memory));\n-          _igvn.replace_node(callprojs.fallthrough_catchproj, ac->in(TypeFunc::Control));\n+          _igvn.replace_node(callprojs->fallthrough_ioproj, ac->in(TypeFunc::I_O));\n+          _igvn.replace_node(callprojs->fallthrough_memproj, ac->in(TypeFunc::Memory));\n+          _igvn.replace_node(callprojs->fallthrough_catchproj, ac->in(TypeFunc::Control));\n@@ -931,0 +1042,19 @@\n+      } else if (use->is_InlineType()) {\n+        assert(use->as_InlineType()->get_oop() == res, \"unexpected inline type ptr use\");\n+        \/\/ Cut off oop input and remove known instance id from type\n+        _igvn.rehash_node_delayed(use);\n+        use->as_InlineType()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n+        const TypeOopPtr* toop = _igvn.type(use)->is_oopptr()->cast_to_instance_id(TypeOopPtr::InstanceBot);\n+        _igvn.set_type(use, toop);\n+        use->as_InlineType()->set_type(toop);\n+        \/\/ Process users\n+        for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+          Node* u = use->fast_out(k);\n+          if (!u->is_InlineType()) {\n+            worklist.push(u);\n+          }\n+        }\n+      } else if (use->Opcode() == Op_StoreX && use->in(MemNode::Address) == res) {\n+        \/\/ Store to mark word of inline type larval buffer\n+        assert(inline_alloc, \"Unexpected store to mark word\");\n+        _igvn.replace_node(use, use->in(MemNode::Memory));\n@@ -943,1 +1073,1 @@\n-  if (_callprojs.resproj != NULL && _callprojs.resproj->outcnt() != 0) {\n+  if (_callprojs->resproj[0] != NULL && _callprojs->resproj[0]->outcnt() != 0) {\n@@ -947,2 +1077,2 @@\n-    for (DUIterator_Fast jmax, j = _callprojs.resproj->fast_outs(jmax);  j < jmax; j++) {\n-      Node* use = _callprojs.resproj->fast_out(j);\n+    for (DUIterator_Fast jmax, j = _callprojs->resproj[0]->fast_outs(jmax);  j < jmax; j++) {\n+      Node* use = _callprojs->resproj[0]->fast_out(j);\n@@ -955,3 +1085,3 @@\n-    for (DUIterator_Last jmin, j = _callprojs.resproj->last_outs(jmin); j >= jmin; ) {\n-      Node* use = _callprojs.resproj->last_out(j);\n-      uint oc1 = _callprojs.resproj->outcnt();\n+    for (DUIterator_Last jmin, j = _callprojs->resproj[0]->last_outs(jmin); j >= jmin; ) {\n+      Node* use = _callprojs->resproj[0]->last_out(j);\n+      uint oc1 = _callprojs->resproj[0]->outcnt();\n@@ -968,1 +1098,1 @@\n-          assert(tmp == NULL || tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n+          assert(tmp == NULL || tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n@@ -976,1 +1106,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem->in(TypeFunc::Memory) == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -978,1 +1108,1 @@\n-            assert(mem == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -983,0 +1113,4 @@\n+      } else if (use->Opcode() == Op_MemBarStoreStore) {\n+        \/\/ Inline type buffer allocations are followed by a membar\n+        assert(inline_alloc, \"Unexpected MemBarStoreStore\");\n+        use->as_MemBar()->remove(&_igvn);\n@@ -986,1 +1120,1 @@\n-      j -= (oc1 - _callprojs.resproj->outcnt());\n+      j -= (oc1 - _callprojs->resproj[0]->outcnt());\n@@ -989,2 +1123,2 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_catchproj, alloc->in(TypeFunc::Control));\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, alloc->in(TypeFunc::Control));\n@@ -992,2 +1126,2 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, alloc->in(TypeFunc::Memory));\n+  if (_callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_memproj, alloc->in(TypeFunc::Memory));\n@@ -995,2 +1129,2 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n-    _igvn.replace_node(_callprojs.catchall_memproj, C->top());\n+  if (_callprojs->catchall_memproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_memproj, C->top());\n@@ -998,2 +1132,2 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    _igvn.replace_node(_callprojs.fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -1001,2 +1135,2 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n-    _igvn.replace_node(_callprojs.catchall_ioproj, C->top());\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_ioproj, C->top());\n@@ -1004,2 +1138,2 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n-    _igvn.replace_node(_callprojs.catchall_catchproj, C->top());\n+  if (_callprojs->catchall_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_catchproj, C->top());\n@@ -1015,1 +1149,1 @@\n-  if (!EliminateAllocations || !alloc->_is_non_escaping) {\n+  if (!EliminateAllocations) {\n@@ -1020,1 +1154,8 @@\n-  Node* res = alloc->result_cast();\n+\n+  \/\/ Attempt to eliminate inline type buffer allocations\n+  \/\/ regardless of usage and escape\/replaceable status.\n+  bool inline_alloc = tklass->isa_instklassptr() &&\n+                      tklass->is_instklassptr()->instance_klass()->is_inlinetype();\n+  if (!alloc->_is_non_escaping && !inline_alloc) {\n+    return false;\n+  }\n@@ -1023,1 +1164,2 @@\n-  bool boxing_alloc = C->eliminate_boxing() &&\n+  Node* res = alloc->result_cast();\n+  bool boxing_alloc = (res == NULL) && C->eliminate_boxing() &&\n@@ -1030,1 +1172,1 @@\n-  alloc->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = alloc->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1038,1 +1180,1 @@\n-    assert(res == NULL, \"sanity\");\n+    assert(res == NULL || inline_alloc, \"sanity\");\n@@ -1043,0 +1185,1 @@\n+      assert(!inline_alloc, \"Inline type allocations should not have safepoint uses\");\n@@ -1063,1 +1206,1 @@\n-  process_users_of_allocation(alloc);\n+  process_users_of_allocation(alloc, inline_alloc);\n@@ -1085,1 +1228,1 @@\n-  boxing->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = boxing->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1087,1 +1230,1 @@\n-  const TypeTuple* r = boxing->tf()->range();\n+  const TypeTuple* r = boxing->tf()->range_sig();\n@@ -1271,1 +1414,1 @@\n-    IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n+    IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n@@ -1274,1 +1417,1 @@\n-    Node *toobig_true = new IfTrueNode( toobig_iff );\n+    Node* toobig_true = new IfTrueNode(toobig_iff);\n@@ -1277,1 +1420,1 @@\n-    toobig_false = new IfFalseNode( toobig_iff );\n+    toobig_false = new IfFalseNode(toobig_iff);\n@@ -1316,0 +1459,1 @@\n+\n@@ -1373,0 +1517,3 @@\n+  } else {\n+    \/\/ Let the runtime know if this is a larval allocation\n+    call->init_req(TypeFunc::Parms+1, _igvn.intcon(alloc->_larval));\n@@ -1404,1 +1551,1 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1410,2 +1557,2 @@\n-  if (expand_fast_path && _callprojs.fallthrough_memproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_memproj, result_phi_rawmem);\n+  if (expand_fast_path && _callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_memproj, result_phi_rawmem);\n@@ -1415,4 +1562,4 @@\n-  if (_callprojs.catchall_memproj != NULL ) {\n-    if (_callprojs.fallthrough_memproj == NULL) {\n-      _callprojs.fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n-      transform_later(_callprojs.fallthrough_memproj);\n+  if (_callprojs->catchall_memproj != NULL) {\n+    if (_callprojs->fallthrough_memproj == NULL) {\n+      _callprojs->fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n+      transform_later(_callprojs->fallthrough_memproj);\n@@ -1420,2 +1567,2 @@\n-    migrate_outs(_callprojs.catchall_memproj, _callprojs.fallthrough_memproj);\n-    _igvn.remove_dead_node(_callprojs.catchall_memproj);\n+    _igvn.replace_in_uses(_callprojs->catchall_memproj, _callprojs->fallthrough_memproj);\n+    _igvn.remove_dead_node(_callprojs->catchall_memproj);\n@@ -1429,2 +1576,2 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_ioproj, result_phi_i_o);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_ioproj, result_phi_i_o);\n@@ -1434,4 +1581,4 @@\n-  if (_callprojs.catchall_ioproj != NULL ) {\n-    if (_callprojs.fallthrough_ioproj == NULL) {\n-      _callprojs.fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n-      transform_later(_callprojs.fallthrough_ioproj);\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    if (_callprojs->fallthrough_ioproj == NULL) {\n+      _callprojs->fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n+      transform_later(_callprojs->fallthrough_ioproj);\n@@ -1439,2 +1586,2 @@\n-    migrate_outs(_callprojs.catchall_ioproj, _callprojs.fallthrough_ioproj);\n-    _igvn.remove_dead_node(_callprojs.catchall_ioproj);\n+    _igvn.replace_in_uses(_callprojs->catchall_ioproj, _callprojs->fallthrough_ioproj);\n+    _igvn.remove_dead_node(_callprojs->catchall_ioproj);\n@@ -1459,2 +1606,2 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n-    ctrl = _callprojs.fallthrough_catchproj->clone();\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    ctrl = _callprojs->fallthrough_catchproj->clone();\n@@ -1462,1 +1609,1 @@\n-    _igvn.replace_node(_callprojs.fallthrough_catchproj, result_region);\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, result_region);\n@@ -1467,1 +1614,1 @@\n-  if (_callprojs.resproj == NULL) {\n+  if (_callprojs->resproj[0] == NULL) {\n@@ -1471,1 +1618,1 @@\n-    slow_result = _callprojs.resproj->clone();\n+    slow_result = _callprojs->resproj[0]->clone();\n@@ -1473,1 +1620,1 @@\n-    _igvn.replace_node(_callprojs.resproj, result_phi_rawoop);\n+    _igvn.replace_node(_callprojs->resproj[0], result_phi_rawoop);\n@@ -1483,1 +1630,1 @@\n-  result_phi_rawmem->init_req(slow_result_path, _callprojs.fallthrough_memproj);\n+  result_phi_rawmem->init_req(slow_result_path, _callprojs->fallthrough_memproj);\n@@ -1495,4 +1642,4 @@\n-  alloc->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n-  if (_callprojs.resproj != NULL) {\n-    for (DUIterator_Fast imax, i = _callprojs.resproj->fast_outs(imax); i < imax; i++) {\n-      Node* use = _callprojs.resproj->fast_out(i);\n+  _callprojs = alloc->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  if (_callprojs->resproj[0] != NULL) {\n+    for (DUIterator_Fast imax, i = _callprojs->resproj[0]->fast_outs(imax); i < imax; i++) {\n+      Node* use = _callprojs->resproj[0]->fast_out(i);\n@@ -1503,2 +1650,2 @@\n-    assert(_callprojs.resproj->outcnt() == 0, \"all uses must be deleted\");\n-    _igvn.remove_dead_node(_callprojs.resproj);\n+    assert(_callprojs->resproj[0]->outcnt() == 0, \"all uses must be deleted\");\n+    _igvn.remove_dead_node(_callprojs->resproj[0]);\n@@ -1506,3 +1653,3 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_catchproj, ctrl);\n-    _igvn.remove_dead_node(_callprojs.fallthrough_catchproj);\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_catchproj, ctrl);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_catchproj);\n@@ -1510,3 +1657,3 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n-    _igvn.rehash_node_delayed(_callprojs.catchall_catchproj);\n-    _callprojs.catchall_catchproj->set_req(0, top());\n+  if (_callprojs->catchall_catchproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_catchproj);\n+    _callprojs->catchall_catchproj->set_req(0, top());\n@@ -1514,2 +1661,2 @@\n-  if (_callprojs.fallthrough_proj != NULL) {\n-    Node* catchnode = _callprojs.fallthrough_proj->unique_ctrl_out();\n+  if (_callprojs->fallthrough_proj != NULL) {\n+    Node* catchnode = _callprojs->fallthrough_proj->unique_ctrl_out();\n@@ -1517,1 +1664,1 @@\n-    _igvn.remove_dead_node(_callprojs.fallthrough_proj);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_proj);\n@@ -1519,3 +1666,3 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_memproj, mem);\n-    _igvn.remove_dead_node(_callprojs.fallthrough_memproj);\n+  if (_callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_memproj, mem);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_memproj);\n@@ -1523,3 +1670,3 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n-    migrate_outs(_callprojs.fallthrough_ioproj, i_o);\n-    _igvn.remove_dead_node(_callprojs.fallthrough_ioproj);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_ioproj, i_o);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_ioproj);\n@@ -1527,3 +1674,3 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n-    _igvn.rehash_node_delayed(_callprojs.catchall_memproj);\n-    _callprojs.catchall_memproj->set_req(0, top());\n+  if (_callprojs->catchall_memproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_memproj);\n+    _callprojs->catchall_memproj->set_req(0, top());\n@@ -1531,3 +1678,3 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n-    _igvn.rehash_node_delayed(_callprojs.catchall_ioproj);\n-    _callprojs.catchall_ioproj->set_req(0, top());\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_ioproj);\n+    _callprojs->catchall_ioproj->set_req(0, top());\n@@ -1651,5 +1798,4 @@\n-Node*\n-PhaseMacroExpand::initialize_object(AllocateNode* alloc,\n-                                    Node* control, Node* rawmem, Node* object,\n-                                    Node* klass_node, Node* length,\n-                                    Node* size_in_bytes) {\n+Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,\n+                                          Node* control, Node* rawmem, Node* object,\n+                                          Node* klass_node, Node* length,\n+                                          Node* size_in_bytes) {\n@@ -1658,1 +1804,1 @@\n-  Node* mark_node = alloc->make_ideal_mark(&_igvn, object, control, rawmem);\n+  Node* mark_node = alloc->make_ideal_mark(&_igvn, control, rawmem);\n@@ -1694,0 +1840,2 @@\n+                                            alloc->in(AllocateNode::DefaultValue),\n+                                            alloc->in(AllocateNode::RawDefaultValue),\n@@ -2063,0 +2211,43 @@\n+void PhaseMacroExpand::inline_type_guard(Node** ctrl, LockNode* lock) {\n+  Node* obj = lock->obj_node();\n+  const TypePtr* obj_type = _igvn.type(obj)->make_ptr();\n+  if (!obj_type->can_be_inline_type()) {\n+    return;\n+  }\n+  Node* mark = make_load(*ctrl, lock->memory(), obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n+  Node* value_mask = _igvn.MakeConX(markWord::inline_type_pattern);\n+  Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));\n+  Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));\n+  Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  Node* unc_ctrl = generate_slow_guard(ctrl, bol, NULL);\n+\n+  int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+  address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+  const TypePtr* no_memory_effects = NULL;\n+  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\",\n+                                         no_memory_effects);\n+  unc->init_req(TypeFunc::Control, unc_ctrl);\n+  unc->init_req(TypeFunc::I_O, lock->i_o());\n+  unc->init_req(TypeFunc::Memory, lock->memory());\n+  unc->init_req(TypeFunc::FramePtr,  lock->in(TypeFunc::FramePtr));\n+  unc->init_req(TypeFunc::ReturnAdr, lock->in(TypeFunc::ReturnAdr));\n+  unc->init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));\n+  unc->set_cnt(PROB_UNLIKELY_MAG(4));\n+  unc->copy_call_debug_info(&_igvn, lock);\n+\n+  assert(unc->peek_monitor_box() == lock->box_node(), \"wrong monitor\");\n+  assert((obj_type->is_inlinetypeptr() && unc->peek_monitor_obj()->is_SafePointScalarObject()) ||\n+         (obj->is_InlineType() && obj->in(1) == unc->peek_monitor_obj()) ||\n+         (obj == unc->peek_monitor_obj()), \"wrong monitor\");\n+\n+  \/\/ pop monitor and push obj back on stack: we trap before the monitorenter\n+  unc->pop_monitor();\n+  unc->grow_stack(unc->jvms(), 1);\n+  unc->set_stack(unc->jvms(), unc->jvms()->stk_size()-1, obj);\n+  _igvn.register_new_node_with_optimizer(unc);\n+\n+  unc_ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));\n+  Node* halt = _igvn.transform(new HaltNode(unc_ctrl, lock->in(TypeFunc::FramePtr), \"monitor enter on inline type\"));\n+  _igvn.add_input_to(C->root(), halt);\n+}\n+\n@@ -2094,1 +2285,1 @@\n-  alock->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = alock->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2098,2 +2289,2 @@\n-         _callprojs.fallthrough_proj != NULL &&\n-         _callprojs.fallthrough_memproj != NULL,\n+         _callprojs->fallthrough_proj != NULL &&\n+         _callprojs->fallthrough_memproj != NULL,\n@@ -2102,2 +2293,2 @@\n-  Node* fallthroughproj = _callprojs.fallthrough_proj;\n-  Node* memproj_fallthrough = _callprojs.fallthrough_memproj;\n+  Node* fallthroughproj = _callprojs->fallthrough_proj;\n+  Node* memproj_fallthrough = _callprojs->fallthrough_memproj;\n@@ -2109,0 +2300,3 @@\n+    \/\/ Deoptimize and re-execute if object is an inline type\n+    inline_type_guard(&ctrl, alock->as_Lock());\n+\n@@ -2169,0 +2363,3 @@\n+  \/\/ Deoptimize and re-execute if object is an inline type\n+  inline_type_guard(&slow_path, lock);\n+\n@@ -2174,1 +2371,1 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2180,2 +2377,2 @@\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n+         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2186,1 +2383,1 @@\n-  Node *slow_ctrl = _callprojs.fallthrough_proj->clone();\n+  Node *slow_ctrl = _callprojs->fallthrough_proj->clone();\n@@ -2188,2 +2385,2 @@\n-  _igvn.hash_delete(_callprojs.fallthrough_proj);\n-  _callprojs.fallthrough_proj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs->fallthrough_proj);\n+  _callprojs->fallthrough_proj->disconnect_inputs(C);\n@@ -2193,1 +2390,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_proj, region);\n+  _igvn.replace_node(_callprojs->fallthrough_proj, region);\n@@ -2201,1 +2398,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, mem_phi);\n@@ -2234,3 +2431,3 @@\n-  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n+         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2242,1 +2439,1 @@\n-  Node *slow_ctrl = _callprojs.fallthrough_proj->clone();\n+  Node *slow_ctrl = _callprojs->fallthrough_proj->clone();\n@@ -2244,2 +2441,2 @@\n-  _igvn.hash_delete(_callprojs.fallthrough_proj);\n-  _callprojs.fallthrough_proj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs->fallthrough_proj);\n+  _callprojs->fallthrough_proj->disconnect_inputs(C);\n@@ -2249,1 +2446,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_proj, region);\n+  _igvn.replace_node(_callprojs->fallthrough_proj, region);\n@@ -2256,1 +2453,1 @@\n-  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, mem_phi);\n@@ -2259,0 +2456,211 @@\n+\/\/ An inline type might be returned from the call but we don't know its\n+\/\/ type. Either we get a buffered inline type (and nothing needs to be done)\n+\/\/ or one of the inlines being returned is the klass of the inline type\n+\/\/ and we need to allocate an inline type instance of that type and\n+\/\/ initialize it with other values being returned. In that case, we\n+\/\/ first try a fast path allocation and initialize the value with the\n+\/\/ inline klass's pack handler or we fall back to a runtime call.\n+void PhaseMacroExpand::expand_mh_intrinsic_return(CallStaticJavaNode* call) {\n+  assert(call->method()->is_method_handle_intrinsic(), \"must be a method handle intrinsic call\");\n+  Node* ret = call->proj_out_or_null(TypeFunc::Parms);\n+  if (ret == NULL) {\n+    return;\n+  }\n+  const TypeFunc* tf = call->_tf;\n+  const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n+  const TypeFunc* new_tf = TypeFunc::make(tf->domain_sig(), tf->domain_cc(), tf->range_sig(), domain);\n+  call->_tf = new_tf;\n+  \/\/ Make sure the change of type is applied before projections are processed by igvn\n+  _igvn.set_type(call, call->Value(&_igvn));\n+  _igvn.set_type(ret, ret->Value(&_igvn));\n+\n+  \/\/ Before any new projection is added:\n+  CallProjections* projs = call->extract_projections(true, true);\n+\n+  \/\/ Create temporary hook nodes that will be replaced below.\n+  \/\/ Add an input to prevent hook nodes from being dead.\n+  Node* ctl = new Node(call);\n+  Node* mem = new Node(ctl);\n+  Node* io = new Node(ctl);\n+  Node* ex_ctl = new Node(ctl);\n+  Node* ex_mem = new Node(ctl);\n+  Node* ex_io = new Node(ctl);\n+  Node* res = new Node(ctl);\n+\n+  \/\/ Allocate a new buffered inline type only if a new one is not returned\n+  Node* cast = transform_later(new CastP2XNode(ctl, res));\n+  Node* mask = MakeConX(0x1);\n+  Node* masked = transform_later(new AndXNode(cast, mask));\n+  Node* cmp = transform_later(new CmpXNode(masked, mask));\n+  Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n+  IfNode* allocation_iff = new IfNode(ctl, bol, PROB_MAX, COUNT_UNKNOWN);\n+  transform_later(allocation_iff);\n+  Node* allocation_ctl = transform_later(new IfTrueNode(allocation_iff));\n+  Node* no_allocation_ctl = transform_later(new IfFalseNode(allocation_iff));\n+  Node* no_allocation_res = transform_later(new CheckCastPPNode(no_allocation_ctl, res, TypeInstPtr::BOTTOM));\n+\n+  \/\/ Try to allocate a new buffered inline instance either from TLAB or eden space\n+  Node* needgc_ctrl = NULL; \/\/ needgc means slowcase, i.e. allocation failed\n+  CallLeafNoFPNode* handler_call;\n+  const bool alloc_in_place = UseTLAB;\n+  if (alloc_in_place) {\n+    Node* fast_oop_ctrl = NULL;\n+    Node* fast_oop_rawmem = NULL;\n+    Node* mask2 = MakeConX(-2);\n+    Node* masked2 = transform_later(new AndXNode(cast, mask2));\n+    Node* rawklassptr = transform_later(new CastX2PNode(masked2));\n+    Node* klass_node = transform_later(new CheckCastPPNode(allocation_ctl, rawklassptr, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    Node* layout_val = make_load(NULL, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);\n+    Node* size_in_bytes = ConvI2X(layout_val);\n+    BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+    Node* fast_oop = bs->obj_allocate(this, mem, allocation_ctl, size_in_bytes, io, needgc_ctrl,\n+                                      fast_oop_ctrl, fast_oop_rawmem,\n+                                      AllocateInstancePrefetchLines);\n+    \/\/ Allocation succeed, initialize buffered inline instance header firstly,\n+    \/\/ and then initialize its fields with an inline class specific handler\n+    Node* mark_node = makecon(TypeRawPtr::make((address)markWord::inline_type_prototype().value()));\n+    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::mark_offset_in_bytes(), mark_node, T_ADDRESS);\n+    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+    if (UseCompressedClassPointers) {\n+      fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);\n+    }\n+    Node* fixed_block  = make_load(fast_oop_ctrl, fast_oop_rawmem, klass_node, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);\n+    Node* pack_handler = make_load(fast_oop_ctrl, fast_oop_rawmem, fixed_block, in_bytes(InlineKlass::pack_handler_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);\n+    handler_call = new CallLeafNoFPNode(OptoRuntime::pack_inline_type_Type(),\n+                                        NULL,\n+                                        \"pack handler\",\n+                                        TypeRawPtr::BOTTOM);\n+    handler_call->init_req(TypeFunc::Control, fast_oop_ctrl);\n+    handler_call->init_req(TypeFunc::Memory, fast_oop_rawmem);\n+    handler_call->init_req(TypeFunc::I_O, top());\n+    handler_call->init_req(TypeFunc::FramePtr, call->in(TypeFunc::FramePtr));\n+    handler_call->init_req(TypeFunc::ReturnAdr, top());\n+    handler_call->init_req(TypeFunc::Parms, pack_handler);\n+    handler_call->init_req(TypeFunc::Parms+1, fast_oop);\n+  } else {\n+    needgc_ctrl = allocation_ctl;\n+  }\n+\n+  \/\/ Allocation failed, fall back to a runtime call\n+  CallStaticJavaNode* slow_call = new CallStaticJavaNode(OptoRuntime::store_inline_type_fields_Type(),\n+                                                         StubRoutines::store_inline_type_fields_to_buf(),\n+                                                         \"store_inline_type_fields\",\n+                                                         TypePtr::BOTTOM);\n+  slow_call->init_req(TypeFunc::Control, needgc_ctrl);\n+  slow_call->init_req(TypeFunc::Memory, mem);\n+  slow_call->init_req(TypeFunc::I_O, io);\n+  slow_call->init_req(TypeFunc::FramePtr, call->in(TypeFunc::FramePtr));\n+  slow_call->init_req(TypeFunc::ReturnAdr, call->in(TypeFunc::ReturnAdr));\n+  slow_call->init_req(TypeFunc::Parms, res);\n+\n+  Node* slow_ctl = transform_later(new ProjNode(slow_call, TypeFunc::Control));\n+  Node* slow_mem = transform_later(new ProjNode(slow_call, TypeFunc::Memory));\n+  Node* slow_io = transform_later(new ProjNode(slow_call, TypeFunc::I_O));\n+  Node* slow_res = transform_later(new ProjNode(slow_call, TypeFunc::Parms));\n+  Node* slow_catc = transform_later(new CatchNode(slow_ctl, slow_io, 2));\n+  Node* slow_norm = transform_later(new CatchProjNode(slow_catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci));\n+  Node* slow_excp = transform_later(new CatchProjNode(slow_catc, CatchProjNode::catch_all_index,    CatchProjNode::no_handler_bci));\n+\n+  Node* ex_r = new RegionNode(3);\n+  Node* ex_mem_phi = new PhiNode(ex_r, Type::MEMORY, TypePtr::BOTTOM);\n+  Node* ex_io_phi = new PhiNode(ex_r, Type::ABIO);\n+  ex_r->init_req(1, slow_excp);\n+  ex_mem_phi->init_req(1, slow_mem);\n+  ex_io_phi->init_req(1, slow_io);\n+  ex_r->init_req(2, ex_ctl);\n+  ex_mem_phi->init_req(2, ex_mem);\n+  ex_io_phi->init_req(2, ex_io);\n+  transform_later(ex_r);\n+  transform_later(ex_mem_phi);\n+  transform_later(ex_io_phi);\n+\n+  \/\/ We don't know how many values are returned. This assumes the\n+  \/\/ worst case, that all available registers are used.\n+  for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+    if (domain->field_at(i) == Type::HALF) {\n+      slow_call->init_req(i, top());\n+      if (alloc_in_place) {\n+        handler_call->init_req(i+1, top());\n+      }\n+      continue;\n+    }\n+    Node* proj = transform_later(new ProjNode(call, i));\n+    slow_call->init_req(i, proj);\n+    if (alloc_in_place) {\n+      handler_call->init_req(i+1, proj);\n+    }\n+  }\n+  \/\/ We can safepoint at that new call\n+  slow_call->copy_call_debug_info(&_igvn, call);\n+  transform_later(slow_call);\n+  if (alloc_in_place) {\n+    transform_later(handler_call);\n+  }\n+\n+  Node* fast_ctl = NULL;\n+  Node* fast_res = NULL;\n+  MergeMemNode* fast_mem = NULL;\n+  if (alloc_in_place) {\n+    fast_ctl = transform_later(new ProjNode(handler_call, TypeFunc::Control));\n+    Node* rawmem = transform_later(new ProjNode(handler_call, TypeFunc::Memory));\n+    fast_res = transform_later(new ProjNode(handler_call, TypeFunc::Parms));\n+    fast_mem = MergeMemNode::make(mem);\n+    fast_mem->set_memory_at(Compile::AliasIdxRaw, rawmem);\n+    transform_later(fast_mem);\n+  }\n+\n+  Node* r = new RegionNode(alloc_in_place ? 4 : 3);\n+  Node* mem_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);\n+  Node* io_phi = new PhiNode(r, Type::ABIO);\n+  Node* res_phi = new PhiNode(r, TypeInstPtr::BOTTOM);\n+  r->init_req(1, no_allocation_ctl);\n+  mem_phi->init_req(1, mem);\n+  io_phi->init_req(1, io);\n+  res_phi->init_req(1, no_allocation_res);\n+  r->init_req(2, slow_norm);\n+  mem_phi->init_req(2, slow_mem);\n+  io_phi->init_req(2, slow_io);\n+  res_phi->init_req(2, slow_res);\n+  if (alloc_in_place) {\n+    r->init_req(3, fast_ctl);\n+    mem_phi->init_req(3, fast_mem);\n+    io_phi->init_req(3, io);\n+    res_phi->init_req(3, fast_res);\n+  }\n+  transform_later(r);\n+  transform_later(mem_phi);\n+  transform_later(io_phi);\n+  transform_later(res_phi);\n+\n+  \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+  \/\/ store that would make this buffer accessible by other threads.\n+  MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+  transform_later(mb);\n+  mb->init_req(TypeFunc::Memory, mem_phi);\n+  mb->init_req(TypeFunc::Control, r);\n+  r = new ProjNode(mb, TypeFunc::Control);\n+  transform_later(r);\n+  mem_phi = new ProjNode(mb, TypeFunc::Memory);\n+  transform_later(mem_phi);\n+\n+  assert(projs->nb_resproj == 1, \"unexpected number of results\");\n+  _igvn.replace_in_uses(projs->fallthrough_catchproj, r);\n+  _igvn.replace_in_uses(projs->fallthrough_memproj, mem_phi);\n+  _igvn.replace_in_uses(projs->fallthrough_ioproj, io_phi);\n+  _igvn.replace_in_uses(projs->resproj[0], res_phi);\n+  _igvn.replace_in_uses(projs->catchall_catchproj, ex_r);\n+  _igvn.replace_in_uses(projs->catchall_memproj, ex_mem_phi);\n+  _igvn.replace_in_uses(projs->catchall_ioproj, ex_io_phi);\n+  \/\/ The CatchNode should not use the ex_io_phi. Re-connect it to the catchall_ioproj.\n+  Node* cn = projs->fallthrough_catchproj->in(0);\n+  _igvn.replace_input_of(cn, 1, projs->catchall_ioproj);\n+\n+  _igvn.replace_node(ctl, projs->fallthrough_catchproj);\n+  _igvn.replace_node(mem, projs->fallthrough_memproj);\n+  _igvn.replace_node(io, projs->fallthrough_ioproj);\n+  _igvn.replace_node(res, projs->resproj[0]);\n+  _igvn.replace_node(ex_ctl, projs->catchall_catchproj);\n+  _igvn.replace_node(ex_mem, projs->catchall_memproj);\n+  _igvn.replace_node(ex_io, projs->catchall_ioproj);\n+ }\n+\n@@ -2284,1 +2692,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2296,0 +2704,101 @@\n+\/\/ FlatArrayCheckNode (array1 array2 ...) is expanded into:\n+\/\/\n+\/\/ long mark = array1.mark | array2.mark | ...;\n+\/\/ long locked_bit = markWord::unlocked_value & array1.mark & array2.mark & ...;\n+\/\/ if (locked_bit == 0) {\n+\/\/   \/\/ One array is locked, load prototype header from the klass\n+\/\/   mark = array1.klass.proto | array2.klass.proto | ...\n+\/\/ }\n+\/\/ if ((mark & markWord::flat_array_bit_in_place) == 0) {\n+\/\/    ...\n+\/\/ }\n+void PhaseMacroExpand::expand_flatarraycheck_node(FlatArrayCheckNode* check) {\n+  bool array_inputs = _igvn.type(check->in(FlatArrayCheckNode::ArrayOrKlass))->isa_oopptr() != NULL;\n+  if (UseArrayMarkWordCheck && array_inputs) {\n+    Node* mark = MakeConX(0);\n+    Node* locked_bit = MakeConX(markWord::unlocked_value);\n+    Node* mem = check->in(FlatArrayCheckNode::Memory);\n+    for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+      Node* ary = check->in(i);\n+      const TypeOopPtr* t = _igvn.type(ary)->isa_oopptr();\n+      assert(t != NULL, \"Mixing array and klass inputs\");\n+      assert(!t->is_flat() && !t->is_not_flat(), \"Should have been optimized out\");\n+      Node* mark_adr = basic_plus_adr(ary, oopDesc::mark_offset_in_bytes());\n+      Node* mark_load = _igvn.transform(LoadNode::make(_igvn, NULL, mem, mark_adr, mark_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+      mark = _igvn.transform(new OrXNode(mark, mark_load));\n+      locked_bit = _igvn.transform(new AndXNode(locked_bit, mark_load));\n+    }\n+    assert(!mark->is_Con(), \"Should have been optimized out\");\n+    Node* cmp = _igvn.transform(new CmpXNode(locked_bit, MakeConX(0)));\n+    Node* is_unlocked = _igvn.transform(new BoolNode(cmp, BoolTest::ne));\n+\n+    \/\/ BoolNode might be shared, replace each if user\n+    Node* old_bol = check->unique_out();\n+    assert(old_bol->is_Bool() && old_bol->as_Bool()->_test._test == BoolTest::ne, \"unexpected condition\");\n+    for (DUIterator_Last imin, i = old_bol->last_outs(imin); i >= imin; --i) {\n+      IfNode* old_iff = old_bol->last_out(i)->as_If();\n+      Node* ctrl = old_iff->in(0);\n+      RegionNode* region = new RegionNode(3);\n+      Node* mark_phi = new PhiNode(region, TypeX_X);\n+\n+      \/\/ Check if array is unlocked\n+      IfNode* iff = _igvn.transform(new IfNode(ctrl, is_unlocked, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+\n+      \/\/ Unlocked: Use bits from mark word\n+      region->init_req(1, _igvn.transform(new IfTrueNode(iff)));\n+      mark_phi->init_req(1, mark);\n+\n+      \/\/ Locked: Load prototype header from klass\n+      ctrl = _igvn.transform(new IfFalseNode(iff));\n+      Node* proto = MakeConX(0);\n+      for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+        Node* ary = check->in(i);\n+        \/\/ Make loads control dependent to make sure they are only executed if array is locked\n+        Node* klass_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());\n+        Node* klass = _igvn.transform(LoadKlassNode::make(_igvn, ctrl, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* proto_adr = basic_plus_adr(klass, in_bytes(Klass::prototype_header_offset()));\n+        Node* proto_load = _igvn.transform(LoadNode::make(_igvn, ctrl, C->immutable_memory(), proto_adr, proto_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+        proto = _igvn.transform(new OrXNode(proto, proto_load));\n+      }\n+      region->init_req(2, ctrl);\n+      mark_phi->init_req(2, proto);\n+\n+      \/\/ Check if flat array bits are set\n+      Node* mask = MakeConX(markWord::flat_array_bit_in_place);\n+      Node* masked = _igvn.transform(new AndXNode(_igvn.transform(mark_phi), mask));\n+      cmp = _igvn.transform(new CmpXNode(masked, MakeConX(0)));\n+      Node* is_not_flat = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n+\n+      ctrl = _igvn.transform(region);\n+      iff = _igvn.transform(new IfNode(ctrl, is_not_flat, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+      _igvn.replace_node(old_iff, iff);\n+    }\n+    _igvn.replace_node(check, C->top());\n+  } else {\n+    \/\/ Fall back to layout helper check\n+    Node* lhs = intcon(0);\n+    for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+      Node* array_or_klass = check->in(i);\n+      Node* klass = NULL;\n+      const TypePtr* t = _igvn.type(array_or_klass)->is_ptr();\n+      assert(!t->is_flat() && !t->is_not_flat(), \"Should have been optimized out\");\n+      if (t->isa_oopptr() != NULL) {\n+        Node* klass_adr = basic_plus_adr(array_or_klass, oopDesc::klass_offset_in_bytes());\n+        klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+      } else {\n+        assert(t->isa_aryklassptr(), \"Unexpected input type\");\n+        klass = array_or_klass;\n+      }\n+      Node* lh_addr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n+      Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+      lhs = _igvn.transform(new OrINode(lhs, lh_val));\n+    }\n+    Node* masked = transform_later(new AndINode(lhs, intcon(Klass::_lh_array_tag_flat_value_bit_inplace)));\n+    Node* cmp = transform_later(new CmpINode(masked, intcon(0)));\n+    Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n+    Node* old_bol = check->unique_out();\n+    _igvn.replace_node(old_bol, bol);\n+    _igvn.replace_node(check, C->top());\n+  }\n+}\n+\n@@ -2356,2 +2865,5 @@\n-      case Node::Class_CallStaticJava:\n-        success = eliminate_boxing_node(n->as_CallStaticJava());\n+      case Node::Class_CallStaticJava: {\n+        CallStaticJavaNode* call = n->as_CallStaticJava();\n+        if (!call->method()->is_method_handle_intrinsic()) {\n+          success = eliminate_boxing_node(n->as_CallStaticJava());\n+        }\n@@ -2359,0 +2871,1 @@\n+      }\n@@ -2372,0 +2885,2 @@\n+      case Node::Class_FlatArrayCheck:\n+        break;\n@@ -2412,4 +2927,7 @@\n-        \/\/ Remove it from macro list and put on IGVN worklist to optimize.\n-        C->remove_macro_node(n);\n-        _igvn._worklist.push(n);\n-        success = true;\n+        CallStaticJavaNode* call = n->as_CallStaticJava();\n+        if (!call->method()->is_method_handle_intrinsic()) {\n+          \/\/ Remove it from macro list and put on IGVN worklist to optimize.\n+          C->remove_macro_node(n);\n+          _igvn._worklist.push(n);\n+          success = true;\n+        }\n@@ -2518,0 +3036,7 @@\n+    case Node::Class_CallStaticJava:\n+      expand_mh_intrinsic_return(n->as_CallStaticJava());\n+      C->remove_macro_node(n);\n+      break;\n+    case Node::Class_FlatArrayCheck:\n+      expand_flatarraycheck_node(n->as_FlatArrayCheck());\n+      break;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":704,"deletions":179,"binary":false,"changes":883,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  CallProjections _callprojs;\n+  CallProjections* _callprojs;\n@@ -99,0 +99,1 @@\n+  Node* inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc);\n@@ -104,1 +105,1 @@\n-  void process_users_of_allocation(CallNode *alloc);\n+  void process_users_of_allocation(CallNode *alloc, bool inline_alloc = false);\n@@ -111,0 +112,1 @@\n+  void inline_type_guard(Node** ctrl, LockNode* lock);\n@@ -112,0 +114,1 @@\n+  void expand_mh_intrinsic_return(CallStaticJavaNode* call);\n@@ -121,0 +124,1 @@\n+  Node* generate_fair_guard(Node** ctrl, Node* test, RegionNode* region);\n@@ -131,0 +135,4 @@\n+  Node* array_lh_test(Node* array, jint mask);\n+  Node* generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region);\n+  Node* generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region);\n+\n@@ -140,0 +148,1 @@\n+                           Node* dest_length,\n@@ -146,0 +155,2 @@\n+                            Node* val,\n+                            Node* raw_val,\n@@ -181,1 +192,3 @@\n-\n+  const TypePtr* adjust_for_flat_array(const TypeAryPtr* top_dest, Node*& src_offset,\n+                                       Node*& dest_offset, Node*& length, BasicType& dest_elem,\n+                                       Node*& dest_length);\n@@ -186,0 +199,2 @@\n+  void expand_flatarraycheck_node(FlatArrayCheckNode* check);\n+\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -186,0 +186,44 @@\n+\/\/ Array of RegMask, one per returned values (inline type instances can\n+\/\/ be returned as multiple return values, one per field)\n+RegMask* Matcher::return_values_mask(const TypeFunc* tf) {\n+  const TypeTuple* range = tf->range_cc();\n+  uint cnt = range->cnt() - TypeFunc::Parms;\n+  if (cnt == 0) {\n+    return NULL;\n+  }\n+  RegMask* mask = NEW_RESOURCE_ARRAY(RegMask, cnt);\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, cnt);\n+  VMRegPair* vm_parm_regs = NEW_RESOURCE_ARRAY(VMRegPair, cnt);\n+  for (uint i = 0; i < cnt; i++) {\n+    sig_bt[i] = range->field_at(i+TypeFunc::Parms)->basic_type();\n+  }\n+\n+  int regs = SharedRuntime::java_return_convention(sig_bt, vm_parm_regs, cnt);\n+  if (regs <= 0) {\n+    \/\/ We ran out of registers to store the IsInit information for a nullable inline type return.\n+    \/\/ Since it is only set in the 'call_epilog', we can simply put it on the stack.\n+    assert(tf->returns_inline_type_as_fields(), \"should have been tested during graph construction\");\n+    \/\/ TODO 8284443 Can we teach the register allocator to reserve a stack slot instead?\n+    \/\/ mask[--cnt] = STACK_ONLY_mask does not work (test with -XX:+StressGCM)\n+    int slot = C->fixed_slots() - 2;\n+    if (C->needs_stack_repair()) {\n+      slot -= 2; \/\/ Account for stack increment value\n+    }\n+    mask[--cnt].Clear();\n+    mask[cnt].Insert(OptoReg::stack2reg(slot));\n+  }\n+  for (uint i = 0; i < cnt; i++) {\n+    mask[i].Clear();\n+\n+    OptoReg::Name reg1 = OptoReg::as_OptoReg(vm_parm_regs[i].first());\n+    if (OptoReg::is_valid(reg1)) {\n+      mask[i].Insert(reg1);\n+    }\n+    OptoReg::Name reg2 = OptoReg::as_OptoReg(vm_parm_regs[i].second());\n+    if (OptoReg::is_valid(reg2)) {\n+      mask[i].Insert(reg2);\n+    }\n+  }\n+\n+  return mask;\n+}\n@@ -201,15 +245,3 @@\n-  \/\/ Map a Java-signature return type into return register-value\n-  \/\/ machine registers for 0, 1 and 2 returned values.\n-  const TypeTuple *range = C->tf()->range();\n-  if( range->cnt() > TypeFunc::Parms ) { \/\/ If not a void function\n-    \/\/ Get ideal-register return type\n-    uint ireg = range->field_at(TypeFunc::Parms)->ideal_reg();\n-    \/\/ Get machine return register\n-    uint sop = C->start()->Opcode();\n-    OptoRegPair regs = return_value(ireg);\n-\n-    \/\/ And mask for same\n-    _return_value_mask = RegMask(regs.first());\n-    if( OptoReg::is_valid(regs.second()) )\n-      _return_value_mask.Insert(regs.second());\n-  }\n+  \/\/ Map Java-signature return types into return register-value\n+  \/\/ machine registers.\n+  _return_values_mask = return_values_mask(C->tf());\n@@ -223,1 +255,1 @@\n-  const TypeTuple *domain = C->tf()->domain();\n+  const TypeTuple *domain = C->tf()->domain_cc();\n@@ -527,0 +559,1 @@\n+\n@@ -785,1 +818,1 @@\n-  uint ret_edge_cnt = TypeFunc::Parms + ((C->tf()->range()->cnt() == TypeFunc::Parms) ? 0 : 1);\n+  uint ret_edge_cnt = C->tf()->range_cc()->cnt();\n@@ -787,4 +820,3 @@\n-  \/\/ Returns have 0 or 1 returned values depending on call signature.\n-  \/\/ Return register is specified by return_value in the AD file.\n-  if (ret_edge_cnt > TypeFunc::Parms)\n-    ret_rms[TypeFunc::Parms+0] = _return_value_mask;\n+  for (i = TypeFunc::Parms; i < ret_edge_cnt; i++) {\n+    ret_rms[i] = _return_values_mask[i-TypeFunc::Parms];\n+  }\n@@ -857,1 +889,1 @@\n-  int proj_cnt = C->tf()->domain()->cnt();\n+  int proj_cnt = C->tf()->domain_cc()->cnt();\n@@ -1129,1 +1161,5 @@\n-              m = n->in(0)->as_Multi()->match( n->as_Proj(), this );\n+              RegMask* mask = NULL;\n+              if (n->in(0)->is_Call() && n->in(0)->as_Call()->tf()->returns_inline_type_as_fields()) {\n+                mask = return_values_mask(n->in(0)->as_Call()->tf());\n+              }\n+              m = n->in(0)->as_Multi()->match(n->as_Proj(), this, mask);\n@@ -1268,1 +1304,1 @@\n-    domain = call->tf()->domain();\n+    domain = call->tf()->domain_cc();\n@@ -1347,1 +1383,4 @@\n-  int argcnt = cnt - TypeFunc::Parms;\n+  \/\/ Null entry point is a special cast where the target of the call\n+  \/\/ is in a register.\n+  int adj = (call != NULL && call->entry_point() == NULL) ? 1 : 0;\n+  int argcnt = cnt - TypeFunc::Parms - adj;\n@@ -1353,1 +1392,1 @@\n-      sig_bt[i] = domain->field_at(i+TypeFunc::Parms)->basic_type();\n+      sig_bt[i] = domain->field_at(i+TypeFunc::Parms+adj)->basic_type();\n@@ -1394,1 +1433,1 @@\n-      RegMask *rm = &mcall->_in_rms[i+TypeFunc::Parms];\n+      RegMask *rm = &mcall->_in_rms[i+TypeFunc::Parms+adj];\n@@ -1412,1 +1451,1 @@\n-      if (OptoReg::is_valid(reg1))\n+      if (OptoReg::is_valid(reg1)) {\n@@ -1414,0 +1453,1 @@\n+      }\n@@ -1416,1 +1456,1 @@\n-      if (OptoReg::is_valid(reg2))\n+      if (OptoReg::is_valid(reg2)) {\n@@ -1418,0 +1458,1 @@\n+      }\n@@ -1433,1 +1474,1 @@\n-    uint r_cnt = mcall->tf()->range()->cnt();\n+    uint r_cnt = mcall->tf()->range_sig()->cnt();\n@@ -1454,1 +1495,1 @@\n-         (mcall->jvms()->debug_start() + mcall->_jvmadj == mcall->tf()->domain()->cnt()), \"\");\n+         (mcall->jvms()->debug_start() + mcall->_jvmadj == mcall->tf()->domain_cc()->cnt()), \"\");\n@@ -2137,1 +2178,1 @@\n-      for (int i = n->req() - 1; i >= 0; --i) { \/\/ For my children\n+      for (int i = n->len() - 1; i >= 0; --i) { \/\/ For my children\n@@ -2461,0 +2502,7 @@\n+    case Op_ClearArray: {\n+      Node* pair = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair);\n+      n->set_req(3, n->in(4));\n+      n->del_req(4);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":80,"deletions":32,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -243,1 +246,1 @@\n-               tp->isa_aryptr() &&        tp->offset() == Type::OffsetBot &&\n+        tp->isa_aryptr() &&        tp->offset() == Type::OffsetBot &&\n@@ -911,0 +914,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -1006,1 +1010,1 @@\n-      uint shift  = exact_log2(type2aelembytes(ary_elem));\n+      uint shift  = ary_t->is_flat() ? ary_t->flat_log_elem_size() : exact_log2(type2aelembytes(ary_elem));\n@@ -1127,1 +1131,1 @@\n-        const TypeVect* out_vt = as_LoadVector()->vect_type();\n+        const TypeVect* out_vt = is_Load() ? as_LoadVector()->vect_type() : as_StoreVector()->vect_type();\n@@ -1145,0 +1149,6 @@\n+      assert(memory_type() != T_PRIMITIVE_OBJECT, \"should not be used for inline types\");\n+      Node* default_value = ld_alloc->in(AllocateNode::DefaultValue);\n+      if (default_value != NULL) {\n+        return default_value;\n+      }\n+      assert(ld_alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n@@ -1212,0 +1222,17 @@\n+  \/\/ Loading from an InlineType? The InlineType has the values of\n+  \/\/ all fields as input. Look for the field with matching offset.\n+  Node* addr = in(Address);\n+  intptr_t offset;\n+  Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);\n+  if (base != NULL && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+    Node* value = base->as_InlineType()->field_value_by_offset((int)offset, true);\n+    if (value != NULL) {\n+      if (Opcode() == Op_LoadN) {\n+        \/\/ Encode oop value if we are loading a narrow oop\n+        assert(!phase->type(value)->isa_narrowoop(), \"should already be decoded\");\n+        value = phase->transform(new EncodePNode(value, bottom_type()));\n+      }\n+      return value;\n+    }\n+  }\n+\n@@ -1936,0 +1963,1 @@\n+        && t->isa_inlinetype() == NULL\n@@ -1971,0 +1999,2 @@\n+            \/\/ Default value load\n+            tp->is_instptr()->instance_klass() == ciEnv::current()->Class_klass() ||\n@@ -1976,1 +2006,3 @@\n-    \/\/ Optimize loads from constant fields.\n+    BasicType bt = memory_type();\n+\n+    \/\/ Optimize loads from constant fields.\n@@ -1980,1 +2012,19 @@\n-      const Type* con_type = Type::make_constant_from_field(const_oop->as_instance(), off, is_unsigned(), memory_type());\n+      ciType* mirror_type = const_oop->as_instance()->java_mirror_type();\n+      if (mirror_type != NULL) {\n+        const Type* const_oop = NULL;\n+        ciInlineKlass* vk = mirror_type->is_inlinetype() ? mirror_type->as_inline_klass() : NULL;\n+        \/\/ Fold default value loads\n+        if (vk != NULL && off == vk->default_value_offset()) {\n+          const_oop = TypeInstPtr::make(vk->default_instance());\n+        }\n+        \/\/ Fold class mirror loads\n+        if (off == java_lang_Class::primary_mirror_offset()) {\n+          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n+        } else if (off == java_lang_Class::secondary_mirror_offset()) {\n+          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n+        }\n+        if (const_oop != NULL) {\n+          return (bt == T_NARROWOOP) ? const_oop->make_narrowoop() : const_oop;\n+        }\n+      }\n+      const Type* con_type = Type::make_constant_from_field(const_oop->as_instance(), off, is_unsigned(), bt);\n@@ -1995,15 +2045,31 @@\n-  } else if (tp->base() == Type::RawPtr && adr->is_Load() && off == 0) {\n-    \/* With mirrors being an indirect in the Klass*\n-     * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))\n-     * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).\n-     *\n-     * So check the type and klass of the node before the LoadP.\n-     *\/\n-    Node* adr2 = adr->in(MemNode::Address);\n-    const TypeKlassPtr* tkls = phase->type(adr2)->isa_klassptr();\n-    if (tkls != NULL && !StressReflectiveCode) {\n-      if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n-        ciKlass* klass = tkls->exact_klass();\n-        assert(adr->Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n-        assert(Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n-        return TypeInstPtr::make(klass->java_mirror());\n+  } else if (tp->base() == Type::RawPtr && !StressReflectiveCode) {\n+    if (adr->is_Load() && off == 0) {\n+      \/* With mirrors being an indirect in the Klass*\n+       * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))\n+       * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).\n+       *\n+       * So check the type and klass of the node before the LoadP.\n+       *\/\n+      Node* adr2 = adr->in(MemNode::Address);\n+      const TypeKlassPtr* tkls = phase->type(adr2)->isa_klassptr();\n+      if (tkls != NULL) {\n+        if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n+          ciKlass* klass = tkls->exact_klass();\n+          assert(adr->Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n+          assert(Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n+          return TypeInstPtr::make(klass->java_mirror());\n+        }\n+      }\n+    } else {\n+      \/\/ Check for a load of the default value offset from the InlineKlassFixedBlock:\n+      \/\/ LoadI(LoadP(inline_klass, adr_inlineklass_fixed_block_offset), default_value_offset_offset)\n+      intptr_t offset = 0;\n+      Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);\n+      if (base != NULL && base->is_Load() && offset == in_bytes(InlineKlass::default_value_offset_offset())) {\n+        const TypeKlassPtr* tkls = phase->type(base->in(MemNode::Address))->isa_klassptr();\n+        if (tkls != NULL && tkls->is_loaded() && tkls->klass_is_exact() && tkls->exact_klass()->is_inlinetype() &&\n+            tkls->offset() == in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())) {\n+          assert(base->Opcode() == Op_LoadP, \"must load an oop from klass\");\n+          assert(Opcode() == Op_LoadI, \"must load an int from fixed block\");\n+          return TypeInt::make(tkls->exact_klass()->as_inline_klass()->default_value_offset());\n+        }\n@@ -2115,1 +2181,0 @@\n-\n@@ -2118,1 +2183,10 @@\n-    return TypeX::make(markWord::prototype().value());\n+    if (EnableValhalla) {\n+      \/\/ The mark word may contain property bits (inline, flat, null-free)\n+      Node* klass_node = alloc->in(AllocateNode::KlassNode);\n+      const TypeKlassPtr* tkls = phase->type(klass_node)->is_klassptr();\n+      if (tkls->is_loaded() && tkls->klass_is_exact()) {\n+        return TypeX::make(tkls->exact_klass()->prototype_header().value());\n+      }\n+    } else {\n+      return TypeX::make(markWord::prototype().value());\n+    }\n@@ -2269,1 +2343,2 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,\n+                          const TypeKlassPtr* tk) {\n@@ -2316,1 +2391,2 @@\n-      ciType* t = tinst->java_mirror_type();\n+      bool null_free = false;\n+      ciType* t = tinst->java_mirror_type(&null_free);\n@@ -2326,1 +2402,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          return TypeKlassPtr::make(ciArrayKlass::make(t, null_free));\n@@ -2345,1 +2421,1 @@\n-  const TypeAryPtr *tary = tp->isa_aryptr();\n+  const TypeAryPtr* tary = tp->isa_aryptr();\n@@ -2571,0 +2647,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -2621,1 +2698,1 @@\n-  {\n+  if (phase->C->get_adr_type(phase->C->get_alias_index(adr_type())) != TypeAryPtr::INLINES) {\n@@ -2641,0 +2718,1 @@\n+             (Opcode() == Op_StoreL && st->Opcode() == Op_StoreN) ||\n@@ -2737,2 +2815,1 @@\n-  if (result == this &&\n-      ReduceFieldZeroing && phase->type(val)->is_zero_type()) {\n+  if (result == this && ReduceFieldZeroing) {\n@@ -2740,1 +2817,3 @@\n-    if (mem->is_Proj() && mem->in(0)->is_Allocate()) {\n+    if (mem->is_Proj() && mem->in(0)->is_Allocate() &&\n+        (phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::DefaultValue) == val)) {\n+      assert(!phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::DefaultValue) == NULL, \"storing null to inline type array is forbidden\");\n@@ -2744,1 +2823,1 @@\n-    if (result == this) {\n+    if (result == this && phase->type(val)->is_zero_type()) {\n@@ -2929,3 +3008,7 @@\n-    Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-    set_req_X(MemNode::OopStore, mem, phase);\n-    return this;\n+    if (oop_alias_idx() != phase->C->get_alias_index(TypeAryPtr::INLINES) ||\n+        phase->C->flattened_accesses_share_alias()) {\n+      \/\/ The alias that was recorded is no longer accurate enough.\n+      Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n+      set_req_X(MemNode::OopStore, mem, phase);\n+      return this;\n+    }\n@@ -3090,1 +3173,1 @@\n-    return new ClearArrayNode(in(0), in(1), in(2), in(3), true);\n+    return new ClearArrayNode(in(0), in(1), in(2), in(3), in(4), true);\n@@ -3108,1 +3191,1 @@\n-  Node *zero = phase->makecon(TypeLong::ZERO);\n+  Node *val = in(4);\n@@ -3110,1 +3193,1 @@\n-  mem = new StoreLNode(in(0),mem,adr,atp,zero,MemNode::unordered,false);\n+  mem = new StoreLNode(in(0), mem, adr, atp, val, MemNode::unordered, false);\n@@ -3115,1 +3198,1 @@\n-    mem = new StoreLNode(in(0),mem,adr,atp,zero,MemNode::unordered,false);\n+    mem = new StoreLNode(in(0), mem, adr, atp, val, MemNode::unordered, false);\n@@ -3149,0 +3232,2 @@\n+                                   Node* val,\n+                                   Node* raw_val,\n@@ -3159,1 +3244,7 @@\n-    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    if (val != NULL) {\n+      assert(phase->type(val)->isa_narrowoop(), \"should be narrow oop\");\n+      mem = new StoreNNode(ctl, mem, adr, atp, val, MemNode::unordered);\n+    } else {\n+      assert(raw_val == NULL, \"val may not be null\");\n+      mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    }\n@@ -3166,1 +3257,1 @@\n-  return clear_memory(ctl, mem, dest, phase->MakeConX(offset), end_offset, phase);\n+  return clear_memory(ctl, mem, dest, raw_val, phase->MakeConX(offset), end_offset, phase);\n@@ -3170,0 +3261,1 @@\n+                                   Node* raw_val,\n@@ -3192,1 +3284,4 @@\n-  mem = new ClearArrayNode(ctl, mem, zsize, adr, false);\n+  if (raw_val == NULL) {\n+    raw_val = phase->MakeConX(0);\n+  }\n+  mem = new ClearArrayNode(ctl, mem, zsize, adr, raw_val, false);\n@@ -3197,0 +3292,2 @@\n+                                   Node* val,\n+                                   Node* raw_val,\n@@ -3211,1 +3308,1 @@\n-    mem = clear_memory(ctl, mem, dest,\n+    mem = clear_memory(ctl, mem, dest, val, raw_val,\n@@ -3218,1 +3315,7 @@\n-    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    if (val != NULL) {\n+      assert(phase->type(val)->isa_narrowoop(), \"should be narrow oop\");\n+      mem = new StoreNNode(ctl, mem, adr, atp, val, MemNode::unordered);\n+    } else {\n+      assert(raw_val == NULL, \"val may not be null\");\n+      mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    }\n@@ -3363,1 +3466,1 @@\n-Node *MemBarNode::match( const ProjNode *proj, const Matcher *m ) {\n+Node *MemBarNode::match(const ProjNode *proj, const Matcher *m, const RegMask* mask) {\n@@ -3650,1 +3753,3 @@\n-  if (init == NULL || init->is_complete())  return false;\n+  if (init == NULL || init->is_complete()) {\n+    return false;\n+  }\n@@ -3828,0 +3933,6 @@\n+                if (base->is_Phi()) {\n+                  \/\/ In rare case, base may be a PhiNode and it may read\n+                  \/\/ the same memory slice between InitializeNode and store.\n+                  failed = true;\n+                  break;\n+                }\n@@ -4412,0 +4523,2 @@\n+                                              allocation()->in(AllocateNode::DefaultValue),\n+                                              allocation()->in(AllocateNode::RawDefaultValue),\n@@ -4471,0 +4584,2 @@\n+                                            allocation()->in(AllocateNode::DefaultValue),\n+                                            allocation()->in(AllocateNode::RawDefaultValue),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":160,"deletions":45,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -129,0 +129,4 @@\n+#ifdef ASSERT\n+  void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }\n+#endif\n+\n@@ -548,1 +552,0 @@\n-\n@@ -1087,0 +1090,1 @@\n+  bool _word_copy_only;\n@@ -1088,2 +1092,3 @@\n-  ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, bool is_large)\n-    : Node(ctrl,arymem,word_cnt,base), _is_large(is_large) {\n+  ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, Node* val, bool is_large)\n+    : Node(ctrl, arymem, word_cnt, base, val), _is_large(is_large),\n+      _word_copy_only(val->bottom_type()->isa_long() && (!val->bottom_type()->is_long()->is_con() || val->bottom_type()->is_long()->get_con() != 0)) {\n@@ -1101,0 +1106,1 @@\n+  bool word_copy_only() const { return _word_copy_only; }\n@@ -1107,0 +1113,2 @@\n+                            Node* val,\n+                            Node* raw_val,\n@@ -1111,0 +1119,2 @@\n+                            Node* val,\n+                            Node* raw_val,\n@@ -1115,0 +1125,1 @@\n+                            Node* raw_val,\n@@ -1166,1 +1177,1 @@\n-  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+  virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -200,0 +200,12 @@\n+  \/\/ Code pattern on return from a call that returns an __Value.  Can\n+  \/\/ be optimized away if the return value turns out to be an oop.\n+  if (op == Op_AndX &&\n+      in(1) != NULL &&\n+      in(1)->Opcode() == Op_CastP2X &&\n+      in(1)->in(1) != NULL &&\n+      phase->type(in(1)->in(1))->isa_oopptr() &&\n+      t2->isa_intptr_t()->_lo >= 0 &&\n+      t2->isa_intptr_t()->_hi <= MinObjAlignmentInBytesMask) {\n+    return add_id();\n+  }\n+\n@@ -708,0 +720,8 @@\n+\n+    \/\/ Check if this is part of an inline type test\n+    if (con == markWord::inline_type_pattern && in(1)->is_Load() &&\n+        phase->type(in(1)->in(MemNode::Address))->is_inlinetypeptr() &&\n+        phase->type(in(1)->in(MemNode::Address))->is_ptr()->offset() == oopDesc::mark_offset_in_bytes()) {\n+      assert(EnableValhalla, \"should only be used for inline types\");\n+      return in(2); \/\/ Obj is known to be an inline type\n+    }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -575,0 +575,3 @@\n+  if (n->is_InlineType()) {\n+    C->add_inline_type(n);\n+  }\n@@ -658,0 +661,3 @@\n+  if (is_InlineType()) {\n+    compile->remove_inline_type(this);\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+class FlatArrayCheckNode;\n@@ -116,0 +117,1 @@\n+class MachPrologNode;\n@@ -122,0 +124,1 @@\n+class MachVEPNode;\n@@ -166,0 +169,1 @@\n+class InlineTypeNode;\n@@ -667,0 +671,1 @@\n+        DEFINE_CLASS_ID(Blackhole,        MemBar, 2)\n@@ -688,0 +693,2 @@\n+      DEFINE_CLASS_ID(MachProlog,       Mach, 8)\n+      DEFINE_CLASS_ID(MachVEP,          Mach, 9)\n@@ -714,0 +721,1 @@\n+      DEFINE_CLASS_ID(InlineType, Type, 8)\n@@ -750,3 +758,4 @@\n-        DEFINE_CLASS_ID(FastLock,   Cmp, 0)\n-        DEFINE_CLASS_ID(FastUnlock, Cmp, 1)\n-        DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)\n+        DEFINE_CLASS_ID(FastLock,       Cmp, 0)\n+        DEFINE_CLASS_ID(FastUnlock,     Cmp, 1)\n+        DEFINE_CLASS_ID(SubTypeCheck,   Cmp, 2)\n+        DEFINE_CLASS_ID(FlatArrayCheck, Cmp, 3)\n@@ -851,0 +860,1 @@\n+  DEFINE_CLASS_QUERY(Blackhole)\n@@ -879,0 +889,1 @@\n+  DEFINE_CLASS_QUERY(FlatArrayCheck)\n@@ -911,0 +922,1 @@\n+  DEFINE_CLASS_QUERY(MachProlog)\n@@ -917,0 +929,1 @@\n+  DEFINE_CLASS_QUERY(MachVEP)\n@@ -941,0 +954,1 @@\n+  DEFINE_CLASS_QUERY(InlineType)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -290,3 +291,3 @@\n-  assert(_stub == NULL, \"There can only be one entry barrier stub\");\n-  _stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-  return _stub;\n+  C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+  _stubs.append(stub);\n+  return stub;\n@@ -296,1 +297,1 @@\n-  if (_stub == NULL) {\n+  if (_stubs.is_empty()) {\n@@ -302,5 +303,6 @@\n-  \/\/ Make sure there is enough space in the code buffer\n-  if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return;\n-  }\n+  for (C2EntryBarrierStub* stub : _stubs) {\n+    \/\/ Make sure there is enough space in the code buffer\n+    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n@@ -308,6 +310,7 @@\n-  intptr_t before = masm.offset();\n-  masm.emit_entry_barrier_stub(_stub);\n-  intptr_t after = masm.offset();\n-  int actual_size = (int)(after - before);\n-  int expected_size = masm.entry_barrier_stub_size();\n-  assert(actual_size == expected_size, \"Estimated size is wrong, expected %d, was %d\", expected_size, actual_size);\n+    intptr_t before = masm.offset();\n+    masm.emit_entry_barrier_stub(stub);\n+    intptr_t after = masm.offset();\n+    int actual_size = (int)(after - before);\n+    int expected_size = masm.entry_barrier_stub_size();\n+    assert(actual_size == expected_size, \"Estimated size is wrong, expected %d, was %d\", expected_size, actual_size);\n+  }\n@@ -349,1 +352,9 @@\n-    _orig_pc_slot = C->fixed_slots() - (sizeof(address) \/ VMRegImpl::stack_slot_size);\n+    int fixed_slots = C->fixed_slots();\n+    if (C->needs_stack_repair()) {\n+      fixed_slots -= 2;\n+    }\n+    \/\/ TODO 8284443 Only reserve extra slot if needed\n+    if (InlineTypeReturnedAsFields) {\n+      fixed_slots -= 2;\n+    }\n+    _orig_pc_slot = fixed_slots - (sizeof(address) \/ VMRegImpl::stack_slot_size);\n@@ -390,1 +401,2 @@\n-  MachPrologNode *prolog = new MachPrologNode();\n+  Label verified_entry;\n+  MachPrologNode* prolog = new MachPrologNode(&verified_entry);\n@@ -396,3 +408,2 @@\n-\n-  if( C->is_osr_compilation() ) {\n-    if( PoisonOSREntry ) {\n+  if (C->is_osr_compilation()) {\n+    if (PoisonOSREntry) {\n@@ -403,3 +414,14 @@\n-    if( C->method() && !C->method()->flags().is_static() ) {\n-      \/\/ Insert unvalidated entry point\n-      C->cfg()->insert( broot, 0, new MachUEPNode() );\n+    if (C->method()) {\n+      if (C->method()->has_scalarized_args()) {\n+        \/\/ Add entry point to unpack all inline type arguments\n+        C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ true, \/* receiver_only *\/ false));\n+        if (!C->method()->is_static()) {\n+          \/\/ Add verified\/unverified entry points to only unpack inline type receiver at interface calls\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ false, \/* receiver_only *\/ false));\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ true,  \/* receiver_only *\/ true));\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ false, \/* receiver_only *\/ true));\n+        }\n+      } else if (!C->method()->is_static()) {\n+        \/\/ Insert unvalidated entry point\n+        C->cfg()->insert(broot, 0, new MachUEPNode());\n+      }\n@@ -407,1 +429,0 @@\n-\n@@ -447,0 +468,25 @@\n+  if (!C->is_osr_compilation() && C->has_scalarized_args()) {\n+    \/\/ Compute the offsets of the entry points required by the inline type calling convention\n+    if (!C->method()->is_static()) {\n+      \/\/ We have entries at the beginning of the method, implemented by the first 4 nodes.\n+      \/\/ Entry                     (unverified) @ offset 0\n+      \/\/ Verified_Inline_Entry_RO\n+      \/\/ Inline_Entry              (unverified)\n+      \/\/ Verified_Inline_Entry\n+      uint offset = 0;\n+      _code_offsets.set_value(CodeOffsets::Entry, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(0))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(1))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Inline_Entry, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(2))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, offset);\n+    } else {\n+      _code_offsets.set_value(CodeOffsets::Entry, -1); \/\/ will be patched later\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, 0);\n+    }\n+  }\n+\n@@ -607,1 +653,3 @@\n-          mcall->method_set((intptr_t)mcall->entry_point());\n+          if (mcall->entry_point() != NULL) {\n+            mcall->method_set((intptr_t)mcall->entry_point());\n+          }\n@@ -862,0 +910,17 @@\n+      uint first_ind = spobj->first_index(sfpt->jvms());\n+      \/\/ Nullable, scalarized inline types have an is_init input\n+      \/\/ that needs to be checked before using the field values.\n+      ScopeValue* is_init = NULL;\n+      if (cik->is_inlinetype()) {\n+        Node* init_node = sfpt->in(first_ind++);\n+        assert(init_node != NULL, \"is_init node not found\");\n+        if (!init_node->is_top()) {\n+          const TypeInt* init_type = init_node->bottom_type()->is_int();\n+          if (init_node->is_Con()) {\n+            is_init = new ConstantIntValue(init_type->get_con());\n+          } else {\n+            OptoReg::Name init_reg = C->regalloc()->get_reg_first(init_node);\n+            is_init = new_loc_value(C->regalloc(), init_reg, Location::normal);\n+          }\n+        }\n+      }\n@@ -863,1 +928,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init);\n@@ -866,1 +931,0 @@\n-      uint first_ind = spobj->first_index(sfpt->jvms());\n@@ -1048,0 +1112,1 @@\n+  bool return_scalarized = false;\n@@ -1068,1 +1133,1 @@\n-    if (mcall->returns_pointer()) {\n+    if (mcall->returns_pointer() || mcall->returns_scalarized()) {\n@@ -1071,0 +1136,3 @@\n+    if (mcall->returns_scalarized()) {\n+      return_scalarized = true;\n+    }\n@@ -1194,0 +1262,1 @@\n+      return_scalarized,\n@@ -1571,2 +1640,4 @@\n-          \/\/ This destination address is NOT PC-relative\n-          mcall->method_set((intptr_t)mcall->entry_point());\n+          if (mcall->entry_point() != NULL) {\n+            \/\/ This destination address is NOT PC-relative\n+            mcall->method_set((intptr_t)mcall->entry_point());\n+          }\n@@ -1736,1 +1807,0 @@\n-\n@@ -3126,0 +3196,13 @@\n+\n+      \/\/ Do not allow a CheckCastPP node whose input is a raw pointer to\n+      \/\/ float past a safepoint.  This can occur when a buffered inline\n+      \/\/ type is allocated in a loop and the CheckCastPP from that\n+      \/\/ allocation is reused outside the loop.  If the use inside the\n+      \/\/ loop is scalarized the CheckCastPP will no longer be connected\n+      \/\/ to the loop safepoint.  See JDK-8264340.\n+      if (m->is_Mach() && m->as_Mach()->ideal_Opcode() == Op_CheckCastPP) {\n+        Node *def = m->in(1);\n+        if (def != NULL && def->bottom_type()->base() == Type::RawPtr) {\n+          last_safept_node->add_prec(m);\n+        }\n+      }\n@@ -3284,0 +3367,19 @@\n+    if (C->has_scalarized_args()) {\n+      \/\/ Inline type entry points (MachVEPNodes) require lots of space for GC barriers and oop verification\n+      \/\/ when loading object fields from the buffered argument. Increase scratch buffer size accordingly.\n+      ciMethod* method = C->method();\n+      int barrier_size = UseZGC ? 200 : (7 DEBUG_ONLY(+ 37));\n+      int arg_num = 0;\n+      if (!method->is_static()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += method->holder()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+      for (ciSignatureStream str(method->signature()); !str.at_return_type(); str.next()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += str.type()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+    }\n@@ -3354,1 +3456,2 @@\n-  if (is_branch) \/\/ Restore label.\n+  \/\/ Restore label.\n+  if (is_branch) {\n@@ -3356,0 +3459,1 @@\n+  }\n@@ -3399,0 +3503,9 @@\n+      if (_code_offsets.value(CodeOffsets::Verified_Inline_Entry) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, _first_block_size);\n+      }\n+      if (_code_offsets.value(CodeOffsets::Verified_Inline_Entry_RO) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, _first_block_size);\n+      }\n+      if (_code_offsets.value(CodeOffsets::Entry) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);\n+      }\n@@ -3403,14 +3516,14 @@\n-                                     entry_bci,\n-                                     &_code_offsets,\n-                                     _orig_pc_slot_offset_in_bytes,\n-                                     code_buffer(),\n-                                     frame_size_in_words(),\n-                                     oop_map_set(),\n-                                     &_handler_table,\n-                                     inc_table(),\n-                                     compiler,\n-                                     has_unsafe_access,\n-                                     SharedRuntime::is_wide_vector(C->max_vector_size()),\n-                                     C->has_monitors(),\n-                                     0,\n-                                     C->rtm_state());\n+                              entry_bci,\n+                              &_code_offsets,\n+                              _orig_pc_slot_offset_in_bytes,\n+                              code_buffer(),\n+                              frame_size_in_words(),\n+                              _oop_map_set,\n+                              &_handler_table,\n+                              inc_table(),\n+                              compiler,\n+                              has_unsafe_access,\n+                              SharedRuntime::is_wide_vector(C->max_vector_size()),\n+                              C->has_monitors(),\n+                              0,\n+                              C->rtm_state());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":159,"deletions":46,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  C2EntryBarrierStub* _stub;\n+  GrowableArray<C2EntryBarrierStub*> _stubs;\n@@ -139,1 +139,1 @@\n-  C2EntryBarrierStubTable() : _stub(NULL) {}\n+  C2EntryBarrierStubTable() {}\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-  Node *fetch_interpreter_state(int index, BasicType bt, Node *local_addrs, Node *local_addrs_base);\n+  Node* fetch_interpreter_state(int index, const Type* type, Node* local_addrs, Node* local_addrs_base);\n@@ -468,1 +468,1 @@\n-  void array_store_check();\n+  Node* array_store_check(Node*& adr, const Type*& elemtype);\n@@ -475,0 +475,1 @@\n+  Node* record_profile_for_speculation_at_array_load(Node* ld);\n@@ -523,1 +524,1 @@\n-  void do_get_xxx(Node* obj, ciField* field, bool is_field);\n+  void do_get_xxx(Node* obj, ciField* field);\n@@ -528,0 +529,2 @@\n+  void do_aconst_init();\n+  void do_withfield();\n@@ -529,1 +532,1 @@\n-  void do_anewarray();\n+  void do_newarray();\n@@ -544,1 +547,6 @@\n-  void    do_if(BoolTest::mask btest, Node* c);\n+  void    do_if(BoolTest::mask btest, Node* c, bool new_path = false, Node** ctrl_taken = NULL);\n+  void    do_acmp(BoolTest::mask btest, Node* left, Node* right);\n+  void    acmp_always_null_input(Node* input, const TypeOopPtr* tinput, BoolTest::mask btest, Node* eq_region);\n+  void    acmp_known_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, ciKlass* input_type, BoolTest::mask btest, Node* eq_region);\n+  Node*   acmp_null_check(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, Node*& null_ctl);\n+  void    acmp_unknown_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, BoolTest::mask btest, Node* eq_region);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/convertnode.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -105,4 +107,10 @@\n-Node *Parse::fetch_interpreter_state(int index,\n-                                     BasicType bt,\n-                                     Node *local_addrs,\n-                                     Node *local_addrs_base) {\n+Node* Parse::fetch_interpreter_state(int index,\n+                                     const Type* type,\n+                                     Node* local_addrs,\n+                                     Node* local_addrs_base) {\n+  BasicType bt = type->basic_type();\n+  if (type == TypePtr::NULL_PTR) {\n+    \/\/ Ptr types are mixed together with T_ADDRESS but NULL is\n+    \/\/ really for T_OBJECT types so correct it.\n+    bt = T_OBJECT;\n+  }\n@@ -120,0 +128,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -150,1 +159,0 @@\n-\n@@ -174,0 +182,6 @@\n+    if (tp->is_inlinetypeptr() && !tp->maybe_null()) {\n+      \/\/ Check inline types for null here to prevent checkcast from adding an\n+      \/\/ exception state before the bytecode entry (use 'bad_type_ctrl' instead).\n+      l = null_check_oop(l, &bad_type_ctrl);\n+      bad_type_exit->control()->add_req(bad_type_ctrl);\n+    }\n@@ -190,1 +204,0 @@\n-\n@@ -228,1 +241,0 @@\n-\n@@ -232,1 +244,1 @@\n-    Node *lock_object = fetch_interpreter_state(index*2, T_OBJECT, monitors_addr, osr_buf);\n+    Node* lock_object = fetch_interpreter_state(index*2, Type::get_const_basic_type(T_OBJECT), monitors_addr, osr_buf);\n@@ -234,2 +246,1 @@\n-    Node *displaced_hdr = fetch_interpreter_state((index*2) + 1, T_ADDRESS, monitors_addr, osr_buf);\n-\n+    Node* displaced_hdr = fetch_interpreter_state((index*2) + 1, Type::get_const_basic_type(T_ADDRESS), monitors_addr, osr_buf);\n@@ -302,7 +313,1 @@\n-    BasicType bt = type->basic_type();\n-    if (type == TypePtr::NULL_PTR) {\n-      \/\/ Ptr types are mixed together with T_ADDRESS but NULL is\n-      \/\/ really for T_OBJECT types so correct it.\n-      bt = T_OBJECT;\n-    }\n-    Node *value = fetch_interpreter_state(index, bt, locals_addr, osr_buf);\n+    Node* value = fetch_interpreter_state(index, type, locals_addr, osr_buf);\n@@ -598,0 +603,21 @@\n+  \/\/ Handle inline type arguments\n+  int arg_size = method()->arg_size();\n+  for (int i = 0; i < arg_size; i++) {\n+    Node* parm = local(i);\n+    const Type* t = _gvn.type(parm);\n+    if (t->is_inlinetypeptr()) {\n+      \/\/ Create InlineTypeNode from the oop and replace the parameter\n+      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n+      set_local(i, vt);\n+    } else if (UseTypeSpeculation && (i == (arg_size - 1)) && !is_osr_parse() &&\n+               method()->has_vararg() && t->isa_aryptr() != NULL && !t->is_aryptr()->is_not_null_free()) {\n+      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flattened)\n+      const TypePtr* spec_type = t->speculative();\n+      spec_type = (spec_type != NULL && spec_type->isa_aryptr() != NULL) ? spec_type : t->is_aryptr();\n+      spec_type = spec_type->remove_speculative()->is_aryptr()->cast_to_not_null_free();\n+      spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, spec_type);\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), parm, t->join_speculative(spec_type)));\n+      set_local(i, cast);\n+    }\n+  }\n+\n@@ -780,2 +806,2 @@\n-  if (tf()->range()->cnt() > TypeFunc::Parms) {\n-    const Type* ret_type = tf()->range()->field_at(TypeFunc::Parms);\n+  if (tf()->range_sig()->cnt() > TypeFunc::Parms) {\n+    const Type* ret_type = tf()->range_sig()->field_at(TypeFunc::Parms);\n@@ -799,0 +825,5 @@\n+    \/\/ Scalarize inline type when returning as fields or inlining non-incrementally\n+    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n+        ret_type->is_inlinetypeptr()) {\n+      ret_type = TypeInlineType::make(ret_type->inline_klass());\n+    }\n@@ -803,1 +834,1 @@\n-    assert((int)(tf()->range()->cnt() - TypeFunc::Parms) == ret_size, \"good tf range\");\n+    assert((int)(tf()->range_sig()->cnt() - TypeFunc::Parms) == ret_size, \"good tf range\");\n@@ -810,1 +841,0 @@\n-\n@@ -815,2 +845,2 @@\n-  int        arg_size = tf->domain()->cnt();\n-  int        max_size = MAX2(arg_size, (int)tf->range()->cnt());\n+  int        arg_size = tf->domain_sig()->cnt();\n+  int        max_size = MAX2(arg_size, (int)tf->range_cc()->cnt());\n@@ -819,0 +849,1 @@\n+  jvms->set_map(map);\n@@ -830,3 +861,20 @@\n-  uint i;\n-  for (i = 0; i < (uint)arg_size; i++) {\n-    Node* parm = initial_gvn()->transform(new ParmNode(start, i));\n+  PhaseGVN& gvn = *initial_gvn();\n+  uint i = 0;\n+  int arg_num = 0;\n+  for (uint j = 0; i < (uint)arg_size; i++) {\n+    const Type* t = tf->domain_sig()->field_at(i);\n+    Node* parm = NULL;\n+    if (t->is_inlinetypeptr() && method()->is_scalarized_arg(arg_num)) {\n+      \/\/ Inline type arguments are not passed by reference: we get an argument per\n+      \/\/ field of the inline type. Build InlineTypeNodes from the inline type arguments.\n+      GraphKit kit(jvms, &gvn);\n+      kit.set_control(map->control());\n+      Node* old_mem = map->memory();\n+      \/\/ Use immutable memory for inline type loads and restore it below\n+      kit.set_all_memory(C->immutable_memory());\n+      parm = InlineTypeNode::make_from_multi(&kit, start, t->inline_klass(), j, \/* in= *\/ true, \/* null_free= *\/ !t->maybe_null());\n+      map->set_control(kit.control());\n+      map->set_memory(old_mem);\n+    } else {\n+      parm = gvn.transform(new ParmNode(start, j++));\n+    }\n@@ -836,0 +884,3 @@\n+    if (i >= TypeFunc::Parms && t != Type::HALF) {\n+      arg_num++;\n+    }\n@@ -842,1 +893,0 @@\n-  jvms->set_map(map);\n@@ -869,1 +919,1 @@\n-  int ret_size = tf()->range()->cnt() - TypeFunc::Parms;\n+  int ret_size = tf()->range_sig()->cnt() - TypeFunc::Parms;\n@@ -873,2 +923,26 @@\n-    ret->add_req(kit.argument(0));\n-    \/\/ Note:  The second dummy edge is not needed by a ReturnNode.\n+    Node* res = kit.argument(0);\n+    if (tf()->returns_inline_type_as_fields()) {\n+      \/\/ Multiple return values (inline type fields): add as many edges\n+      \/\/ to the Return node as returned values.\n+      InlineTypeNode* vt = res->as_InlineType();\n+      ret->add_req_batch(NULL, tf()->range_cc()->cnt() - TypeFunc::Parms);\n+      if (vt->is_allocated(&kit.gvn()) && !StressInlineTypeReturnedAsFields) {\n+        ret->init_req(TypeFunc::Parms, vt->get_oop());\n+      } else {\n+        \/\/ Return the tagged klass pointer to signal scalarization to the caller\n+        Node* tagged_klass = vt->tagged_klass(kit.gvn());\n+        if (!method()->signature()->returns_null_free_inline_type()) {\n+          \/\/ Return null if the inline type is null (IsInit field is not set)\n+          Node* conv   = kit.gvn().transform(new ConvI2LNode(vt->get_is_init()));\n+          Node* shl    = kit.gvn().transform(new LShiftLNode(conv, kit.intcon(63)));\n+          Node* shr    = kit.gvn().transform(new RShiftLNode(shl, kit.intcon(63)));\n+          tagged_klass = kit.gvn().transform(new AndLNode(tagged_klass, shr));\n+        }\n+        ret->init_req(TypeFunc::Parms, tagged_klass);\n+      }\n+      uint idx = TypeFunc::Parms + 1;\n+      vt->pass_fields(&kit, ret, idx, false, method()->signature()->returns_null_free_inline_type());\n+    } else {\n+      ret->add_req(res);\n+      \/\/ Note:  The second dummy edge is not needed by a ReturnNode.\n+    }\n@@ -998,1 +1072,1 @@\n-  if (method()->is_initializer() &&\n+  if (method()->is_object_constructor_or_class_initializer() &&\n@@ -1036,2 +1110,2 @@\n-  if (tf()->range()->cnt() > TypeFunc::Parms) {\n-    const Type* ret_type = tf()->range()->field_at(TypeFunc::Parms);\n+  if (tf()->range_sig()->cnt() > TypeFunc::Parms) {\n+    const Type* ret_type = tf()->range_sig()->field_at(TypeFunc::Parms);\n@@ -1130,1 +1204,1 @@\n-    kit.null_check_receiver_before_call(method());\n+    kit.null_check_receiver_before_call(method(), false);\n@@ -1168,1 +1242,1 @@\n-  uint arg_size = tf()->domain()->cnt();\n+  uint arg_size = tf()->domain_sig()->cnt();\n@@ -1242,0 +1316,1 @@\n+      assert(!_gvn.type(lock_obj)->make_oopptr()->can_be_inline_type(), \"can't be an inline type\");\n@@ -1653,0 +1728,36 @@\n+  \/\/ Check for merge conflicts involving inline types\n+  JVMState* old_jvms = map()->jvms();\n+  int old_bci = bci();\n+  JVMState* tmp_jvms = old_jvms->clone_shallow(C);\n+  tmp_jvms->set_should_reexecute(true);\n+  tmp_jvms->bind_map(map());\n+  \/\/ Execution needs to restart a the next bytecode (entry of next\n+  \/\/ block)\n+  if (target->is_merged() ||\n+      pnum > PhiNode::Input ||\n+      target->is_handler() ||\n+      target->is_loop_head()) {\n+    set_parse_bci(target->start());\n+    for (uint j = TypeFunc::Parms; j < map()->req(); j++) {\n+      Node* n = map()->in(j);                 \/\/ Incoming change to target state.\n+      const Type* t = NULL;\n+      if (tmp_jvms->is_loc(j)) {\n+        t = target->local_type_at(j - tmp_jvms->locoff());\n+      } else if (tmp_jvms->is_stk(j) && j < (uint)sp() + tmp_jvms->stkoff()) {\n+        t = target->stack_type_at(j - tmp_jvms->stkoff());\n+      }\n+      if (t != NULL && t != Type::BOTTOM) {\n+        if (n->is_InlineType() && !t->is_inlinetypeptr()) {\n+          \/\/ Allocate inline type in src block to be able to merge it with oop in target block\n+          map()->set_req(j, n->as_InlineType()->buffer(this));\n+        } else if (!n->is_InlineType() && t->is_inlinetypeptr()) {\n+          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+          map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+        }\n+      }\n+    }\n+  }\n+  old_jvms->bind_map(map());\n+  set_parse_bci(old_bci);\n+\n@@ -1706,0 +1817,1 @@\n+\n@@ -1741,0 +1853,1 @@\n+    bool last_merge = (pnum == PhiNode::Input);\n@@ -1745,1 +1858,1 @@\n-      if (m->is_Phi() && m->as_Phi()->region() == r)\n+      if (m->is_Phi() && m->as_Phi()->region() == r) {\n@@ -1747,1 +1860,3 @@\n-      else\n+      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+        phi = m->as_InlineType()->get_oop()->as_Phi();\n+      } else {\n@@ -1749,0 +1864,1 @@\n+      }\n@@ -1782,1 +1898,24 @@\n-      if (phi != NULL) {\n+      \/\/ Merging two inline types?\n+      if (phi != NULL && phi->bottom_type()->is_inlinetypeptr()) {\n+        \/\/ Reload current state because it may have been updated by ensure_phi\n+        m = map()->in(j);\n+        InlineTypeNode* vtm = m->as_InlineType(); \/\/ Current inline type\n+        InlineTypeNode* vtn = n->as_InlineType(); \/\/ Incoming inline type\n+        assert(vtm->get_oop() == phi, \"Inline type should have Phi input\");\n+        if (TraceOptoParse) {\n+#ifdef ASSERT\n+          tty->print_cr(\"\\nMerging inline types\");\n+          tty->print_cr(\"Current:\");\n+          vtm->dump(2);\n+          tty->print_cr(\"Incoming:\");\n+          vtn->dump(2);\n+          tty->cr();\n+#endif\n+        }\n+        \/\/ Do the merge\n+        vtm->merge_with(&_gvn, vtn, pnum, last_merge);\n+        if (last_merge) {\n+          map()->set_req(j, _gvn.transform_no_reclaim(vtm));\n+          record_for_igvn(vtm);\n+        }\n+      } else if (phi != NULL) {\n@@ -1786,1 +1925,1 @@\n-        if (pnum == PhiNode::Input) {\n+        if (last_merge) {\n@@ -1802,2 +1941,1 @@\n-    if (pnum == PhiNode::Input &&\n-        !r->in(0)) {         \/\/ The occasional useless Region\n+    if (last_merge && !r->in(0)) {         \/\/ The occasional useless Region\n@@ -1955,0 +2093,2 @@\n+      } else if (n->is_InlineType() && n->as_InlineType()->has_phi_inputs(r)) {\n+        n->as_InlineType()->add_new_path(r);\n@@ -1977,0 +2117,4 @@\n+  InlineTypeNode* vt = o->isa_InlineType();\n+  if (vt != NULL && vt->has_phi_inputs(region)) {\n+    return vt->get_oop()->as_Phi();\n+  }\n@@ -1996,2 +2140,2 @@\n-  \/\/ is mixing ints and oops or some such.  Forcing it to top\n-  \/\/ makes it go dead.\n+  \/\/ is already dead or is mixing ints and oops or some such.\n+  \/\/ Forcing it to top makes it go dead.\n@@ -2010,5 +2154,14 @@\n-  PhiNode* phi = PhiNode::make(region, o, t);\n-  gvn().set_type(phi, t);\n-  if (C->do_escape_analysis()) record_for_igvn(phi);\n-  map->set_req(idx, phi);\n-  return phi;\n+  if (vt != NULL && t->is_inlinetypeptr()) {\n+    \/\/ Inline types are merged by merging their field values.\n+    \/\/ Create a cloned InlineTypeNode with phi inputs that\n+    \/\/ represents the merged inline type and update the map.\n+    vt = vt->clone_with_phis(&_gvn, region);\n+    map->set_req(idx, vt);\n+    return vt->get_oop()->as_Phi();\n+  } else {\n+    PhiNode* phi = PhiNode::make(region, o, t);\n+    gvn().set_type(phi, t);\n+    if (C->do_escape_analysis()) record_for_igvn(phi);\n+    map->set_req(idx, phi);\n+    return phi;\n+  }\n@@ -2182,1 +2335,4 @@\n-  set_bci(InvocationEntryBci);\n+  \/\/ vreturn can trigger an allocation so vreturn can throw. Setting\n+  \/\/ the bci here breaks exception handling. Commenting this out\n+  \/\/ doesn't seem to break anything.\n+  \/\/  set_bci(InvocationEntryBci);\n@@ -2189,17 +2345,0 @@\n-  SafePointNode* exit_return = _exits.map();\n-  exit_return->in( TypeFunc::Control  )->add_req( control() );\n-  exit_return->in( TypeFunc::I_O      )->add_req( i_o    () );\n-  Node *mem = exit_return->in( TypeFunc::Memory   );\n-  for (MergeMemStream mms(mem->as_MergeMem(), merged_memory()); mms.next_non_empty2(); ) {\n-    if (mms.is_empty()) {\n-      \/\/ get a copy of the base memory, and patch just this one input\n-      const TypePtr* adr_type = mms.adr_type(C);\n-      Node* phi = mms.force_memory()->as_Phi()->slice_memory(adr_type);\n-      assert(phi->as_Phi()->region() == mms.base_memory()->in(0), \"\");\n-      gvn().set_type_bottom(phi);\n-      phi->del_req(phi->req()-1);  \/\/ prepare to re-patch\n-      mms.set_memory(phi);\n-    }\n-    mms.memory()->add_req(mms.memory2());\n-  }\n-\n@@ -2208,9 +2347,29 @@\n-    \/\/ If returning oops to an interface-return, there is a silent free\n-    \/\/ cast from oop to interface allowed by the Verifier.  Make it explicit\n-    \/\/ here.\n-    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n-    if (tr && tr->is_loaded() &&\n-        tr->is_interface()) {\n-      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() &&\n-          !tp->is_interface()) {\n+    const Type* return_type = phi->bottom_type();\n+    const TypeInstPtr* tr = return_type->isa_instptr();\n+    \/\/ The return_type is set in Parse::build_exits().\n+    if (return_type->isa_inlinetype()) {\n+      \/\/ Inline type is returned as fields, make sure it is scalarized\n+      if (!value->is_InlineType()) {\n+        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), method()->signature()->returns_null_free_inline_type());\n+      }\n+      if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n+        \/\/ Returning from root or an incrementally inlined method. Make sure all non-flattened\n+        \/\/ fields are buffered and re-execute if allocation triggers deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        assert(tf()->returns_inline_type_as_fields(), \"must be returned as fields\");\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(1);\n+        value = value->as_InlineType()->allocate_fields(this);\n+      }\n+    } else if (value->is_InlineType()) {\n+      \/\/ Inline type is returned as oop, make sure it is buffered and re-execute\n+      \/\/ if allocation triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      inc_sp(1);\n+      value = value->as_InlineType()->buffer(this);\n+    } else if (tr && tr->isa_instptr() && tr->is_loaded() && tr->is_interface()) {\n+      \/\/ If returning oops to an interface-return, there is a silent free\n+      \/\/ cast from oop to interface allowed by the Verifier. Make it explicit here.\n+      const TypeInstPtr* tp = value->bottom_type()->isa_instptr();\n+      if (tp && tp->is_loaded() && !tp->is_interface()) {\n@@ -2219,1 +2378,1 @@\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n+        if (tp->higher_equal(TypeInstPtr::NOTNULL)) {\n@@ -2221,0 +2380,1 @@\n+        }\n@@ -2224,1 +2384,1 @@\n-      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n+      \/\/ Handle returns of oop-arrays to an arrays-of-interface return\n@@ -2227,1 +2387,1 @@\n-      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n+      Type::get_arrays_base_elements(return_type, value->bottom_type(), &phi_tip, &val_tip);\n@@ -2230,1 +2390,1 @@\n-        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n+        value = _gvn.transform(new CheckCastPPNode(0, value, return_type));\n@@ -2236,0 +2396,17 @@\n+  SafePointNode* exit_return = _exits.map();\n+  exit_return->in( TypeFunc::Control  )->add_req( control() );\n+  exit_return->in( TypeFunc::I_O      )->add_req( i_o    () );\n+  Node *mem = exit_return->in( TypeFunc::Memory   );\n+  for (MergeMemStream mms(mem->as_MergeMem(), merged_memory()); mms.next_non_empty2(); ) {\n+    if (mms.is_empty()) {\n+      \/\/ get a copy of the base memory, and patch just this one input\n+      const TypePtr* adr_type = mms.adr_type(C);\n+      Node* phi = mms.force_memory()->as_Phi()->slice_memory(adr_type);\n+      assert(phi->as_Phi()->region() == mms.base_memory()->in(0), \"\");\n+      gvn().set_type_bottom(phi);\n+      phi->del_req(phi->req()-1);  \/\/ prepare to re-patch\n+      mms.set_memory(phi);\n+    }\n+    mms.memory()->add_req(mms.memory2());\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":256,"deletions":79,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -39,0 +40,2 @@\n+#include \"opto\/idealKit.hpp\"\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -53,0 +56,17 @@\n+Node* Parse::record_profile_for_speculation_at_array_load(Node* ld) {\n+  \/\/ Feed unused profile data to type speculation\n+  if (UseTypeSpeculation && UseArrayLoadStoreProfile) {\n+    ciKlass* array_type = NULL;\n+    ciKlass* element_type = NULL;\n+    ProfilePtrKind element_ptr = ProfileMaybeNull;\n+    bool flat_array = true;\n+    bool null_free_array = true;\n+    method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+    if (element_type != NULL || element_ptr != ProfileMaybeNull) {\n+      ld = record_profile_for_speculation(ld, element_type, element_ptr);\n+    }\n+  }\n+  return ld;\n+}\n+\n+\n@@ -56,1 +76,0 @@\n-  bool big_val = bt == T_DOUBLE || bt == T_LONG;\n@@ -60,2 +79,92 @@\n-  pop();                      \/\/ index (already used)\n-  Node* array = pop();        \/\/ the array itself\n+  Node* idx = pop();\n+  Node* ary = pop();\n+\n+  \/\/ Handle inline type arrays\n+  const TypeOopPtr* elemptr = elemtype->make_oopptr();\n+  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+  if (ary_t->is_flat()) {\n+    \/\/ Load from flattened inline type array\n+    Node* vt = InlineTypeNode::make_from_flattened(this, elemtype->inline_klass(), ary, adr);\n+    push(vt);\n+    return;\n+  } else if (ary_t->is_null_free()) {\n+    \/\/ Load from non-flattened inline type array (elements can never be null)\n+    bt = T_PRIMITIVE_OBJECT;\n+  } else if (!ary_t->is_not_flat()) {\n+    \/\/ Cannot statically determine if array is flattened, emit runtime check\n+    assert(UseFlatArray && is_reference_type(bt) && elemptr->can_be_inline_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&\n+           (!elemptr->is_inlinetypeptr() || elemptr->inline_klass()->flatten_array()), \"array can't be flattened\");\n+    IdealKit ideal(this);\n+    IdealVariable res(ideal);\n+    ideal.declarations_done();\n+    ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n+      \/\/ non-flattened\n+      assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n+      sync_kit(ideal);\n+      const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n+      Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,\n+                                IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);\n+      if (elemptr->is_inlinetypeptr()) {\n+        assert(elemptr->maybe_null(), \"null free array should be handled above\");\n+        ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), false);\n+      }\n+      ideal.sync_kit(this);\n+      ideal.set(res, ld);\n+    } ideal.else_(); {\n+      \/\/ flattened\n+      sync_kit(ideal);\n+      if (elemptr->is_inlinetypeptr()) {\n+        \/\/ Element type is known, cast and load from flattened representation\n+        ciInlineKlass* vk = elemptr->inline_klass();\n+        assert(vk->flatten_array() && elemptr->maybe_null(), \"never\/always flat - should be optimized\");\n+        ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n+        const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));\n+        Node* casted_adr = array_element_address(cast, idx, T_PRIMITIVE_OBJECT, ary_t->size(), control());\n+        \/\/ Re-execute flattened array load if buffering triggers deoptimization\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(2);\n+        Node* vt = InlineTypeNode::make_from_flattened(this, vk, cast, casted_adr)->buffer(this, false);\n+        ideal.set(res, vt);\n+        ideal.sync_kit(this);\n+      } else {\n+        \/\/ Element type is unknown, emit runtime call\n+\n+        \/\/ Below membars keep this access to an unknown flattened array correctly\n+        \/\/ ordered with other unknown and known flattened array accesses.\n+        insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+        Node* call = NULL;\n+        {\n+          \/\/ Re-execute flattened array load if runtime call triggers deoptimization\n+          PreserveReexecuteState preexecs(this);\n+          jvms()->set_bci(_bci);\n+          jvms()->set_should_reexecute(true);\n+          inc_sp(2);\n+          kill_dead_locals();\n+          call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                                   OptoRuntime::load_unknown_inline_type(),\n+                                   OptoRuntime::load_unknown_inline_Java(),\n+                                   NULL, TypeRawPtr::BOTTOM,\n+                                   ary, idx);\n+        }\n+        make_slow_call_ex(call, env()->Throwable_klass(), false);\n+        Node* buffer = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+\n+        insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+        \/\/ Keep track of the information that the inline type is flattened in arrays\n+        const Type* unknown_value = elemptr->is_instptr()->cast_to_flatten_array();\n+        buffer = _gvn.transform(new CheckCastPPNode(control(), buffer, unknown_value));\n+\n+        ideal.sync_kit(this);\n+        ideal.set(res, buffer);\n+      }\n+    } ideal.end_if();\n+    sync_kit(ideal);\n+    Node* ld = _gvn.transform(ideal.value(res));\n+    ld = record_profile_for_speculation_at_array_load(ld);\n+    push_node(bt, ld);\n+    return;\n+  }\n@@ -67,2 +176,1 @@\n-\n-  Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,\n+  Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,\n@@ -70,4 +178,5 @@\n-  if (big_val) {\n-    push_pair(ld);\n-  } else {\n-    push(ld);\n+  ld = record_profile_for_speculation_at_array_load(ld);\n+  \/\/ Loading a non-flattened inline type\n+  if (elemptr != NULL && elemptr->is_inlinetypeptr()) {\n+    assert(!ary_t->is_null_free() || !elemptr->maybe_null(), \"inline type array elements should never be null\");\n+    ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), !elemptr->maybe_null());\n@@ -75,0 +184,1 @@\n+  push_node(bt, ld);\n@@ -81,2 +191,1 @@\n-  bool big_val = bt == T_DOUBLE || bt == T_LONG;\n-  Node* adr = array_addressing(bt, big_val ? 2 : 1, elemtype);\n+  Node* adr = array_addressing(bt, type2size[bt], elemtype);\n@@ -84,0 +193,1 @@\n+  Node* cast_val = NULL;\n@@ -85,10 +195,2 @@\n-    array_store_check();\n-    if (stopped()) {\n-      return;\n-    }\n-  }\n-  Node* val;                  \/\/ Oop to store\n-  if (big_val) {\n-    val = pop_pair();\n-  } else {\n-    val = pop();\n+    cast_val = array_store_check(adr, elemtype);\n+    if (stopped()) return;\n@@ -96,2 +198,7 @@\n-  pop();                      \/\/ index (already used)\n-  Node* array = pop();        \/\/ the array itself\n+  Node* val = pop_node(bt); \/\/ Value to store\n+  Node* idx = pop();        \/\/ Index in the array\n+  Node* ary = pop();        \/\/ The array itself\n+\n+  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+  const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n+  assert(adr->as_AddP()->in(AddPNode::Base) == ary, \"inconsistent address base\");\n@@ -101,0 +208,121 @@\n+  } else if (bt == T_OBJECT) {\n+    elemtype = elemtype->make_oopptr();\n+    const Type* tval = _gvn.type(cast_val);\n+    \/\/ We may have lost type information for 'val' here due to the casts\n+    \/\/ emitted by the array_store_check code (see JDK-6312651)\n+    \/\/ TODO Remove this code once JDK-6312651 is in.\n+    const Type* tval_init = _gvn.type(val);\n+    \/\/ Based on the value to be stored, try to determine if the array is not null-free and\/or not flat.\n+    \/\/ This is only legal for non-null stores because the array_store_check always passes for null, even\n+    \/\/ if the array is null-free. Null stores are handled in GraphKit::gen_inline_array_null_guard().\n+    bool not_inline = !tval->isa_inlinetype() &&\n+                      ((!tval_init->maybe_null() && !tval_init->is_oopptr()->can_be_inline_type()) ||\n+                       (!tval->maybe_null() && !tval->is_oopptr()->can_be_inline_type()));\n+    bool not_flattened = not_inline || ((tval_init->is_inlinetypeptr() || tval_init->isa_inlinetype()) && !tval_init->inline_klass()->flatten_array());\n+    if (!ary_t->is_not_null_free() && not_inline) {\n+      \/\/ Storing a non-inline type, mark array as not null-free (-> not flat).\n+      ary_t = ary_t->cast_to_not_null_free();\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n+      replace_in_map(ary, cast);\n+      ary = cast;\n+    } else if (!ary_t->is_not_flat() && not_flattened) {\n+      \/\/ Storing a non-flattened value, mark array as not flat.\n+      ary_t = ary_t->cast_to_not_flat();\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n+      replace_in_map(ary, cast);\n+      ary = cast;\n+    }\n+\n+    if (ary_t->is_flat()) {\n+      \/\/ Store to flattened inline type array\n+      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n+      \/\/ Re-execute flattened array store if buffering triggers deoptimization\n+      PreserveReexecuteState preexecs(this);\n+      inc_sp(3);\n+      jvms()->set_should_reexecute(true);\n+      cast_val->as_InlineType()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      return;\n+    } else if (ary_t->is_null_free()) {\n+      \/\/ Store to non-flattened inline type array (elements can never be null)\n+      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n+      if (elemtype->inline_klass()->is_empty()) {\n+        \/\/ Ignore empty inline stores, array is already initialized.\n+        return;\n+      }\n+    } else if (!ary_t->is_not_flat() && (tval != TypePtr::NULL_PTR || StressReflectiveCode)) {\n+      \/\/ Array might be flattened, emit runtime checks (for NULL, a simple inline_array_null_guard is sufficient).\n+      assert(UseFlatArray && !not_flattened && elemtype->is_oopptr()->can_be_inline_type() &&\n+             !ary_t->klass_is_exact() && !ary_t->is_not_null_free(), \"array can't be flattened\");\n+      IdealKit ideal(this);\n+      ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n+        \/\/ non-flattened\n+        assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n+        sync_kit(ideal);\n+        Node* cast_ary = inline_array_null_guard(ary, cast_val, 3);\n+        inc_sp(3);\n+        access_store_at(cast_ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n+        dec_sp(3);\n+        ideal.sync_kit(this);\n+      } ideal.else_(); {\n+        sync_kit(ideal);\n+        \/\/ flattened\n+        Node* null_ctl = top();\n+        Node* val = null_check_oop(cast_val, &null_ctl);\n+        if (null_ctl != top()) {\n+          PreserveJVMState pjvms(this);\n+          inc_sp(3);\n+          set_control(null_ctl);\n+          uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);\n+          dec_sp(3);\n+        }\n+        \/\/ Try to determine the inline klass\n+        ciInlineKlass* vk = NULL;\n+        if (tval->isa_inlinetype() || tval->is_inlinetypeptr()) {\n+          vk = tval->inline_klass();\n+        } else if (tval_init->isa_inlinetype() || tval_init->is_inlinetypeptr()) {\n+          vk = tval_init->inline_klass();\n+        } else if (elemtype->is_inlinetypeptr()) {\n+          vk = elemtype->inline_klass();\n+        }\n+        Node* casted_ary = ary;\n+        if (vk != NULL && !stopped()) {\n+          \/\/ Element type is known, cast and store to flattened representation\n+          assert(vk->flatten_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n+          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n+          const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+          casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));\n+          Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype->size(), control());\n+          if (!val->is_InlineType()) {\n+            assert(!gvn().type(val)->maybe_null(), \"inline type array elements should never be null\");\n+            val = InlineTypeNode::make_from_oop(this, val, vk);\n+          }\n+          \/\/ Re-execute flattened array store if buffering triggers deoptimization\n+          PreserveReexecuteState preexecs(this);\n+          inc_sp(3);\n+          jvms()->set_should_reexecute(true);\n+          val->as_InlineType()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+        } else if (!stopped()) {\n+          \/\/ Element type is unknown, emit runtime call\n+\n+          \/\/ Below membars keep this access to an unknown flattened array correctly\n+          \/\/ ordered with other unknown and known flattened array accesses.\n+          insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+          make_runtime_call(RC_LEAF,\n+                            OptoRuntime::store_unknown_inline_type(),\n+                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),\n+                            \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n+                            val, casted_ary, idx);\n+\n+          insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+        }\n+        ideal.sync_kit(this);\n+      }\n+      ideal.end_if();\n+      sync_kit(ideal);\n+      return;\n+    } else if (!ary_t->is_not_null_free()) {\n+      \/\/ Array is not flattened but may be null free\n+      assert(elemtype->is_oopptr()->can_be_inline_type() && !ary_t->klass_is_exact(), \"array can't be null-free\");\n+      ary = inline_array_null_guard(ary, cast_val, 3, true);\n+    }\n@@ -102,3 +330,3 @@\n-  const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n-\n-  access_store_at(array, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+  inc_sp(3);\n+  access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+  dec_sp(3);\n@@ -205,0 +433,116 @@\n+  \/\/ This could be an access to an inline type array. We can't tell if it's\n+  \/\/ flat or not. Knowing the exact type avoids runtime checks and leads to\n+  \/\/ a much simpler graph shape. Check profile information.\n+  if (!arytype->is_flat() && !arytype->is_not_flat()) {\n+    \/\/ First check the speculative type\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;\n+    ciKlass* array_type = arytype->speculative_type();\n+    if (too_many_traps_or_recompiles(reason) || array_type == NULL) {\n+      \/\/ No speculative type, check profile data at this bci\n+      array_type = NULL;\n+      reason = Deoptimization::Reason_class_check;\n+      if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(reason)) {\n+        ciKlass* element_type = NULL;\n+        ProfilePtrKind element_ptr = ProfileMaybeNull;\n+        bool flat_array = true;\n+        bool null_free_array = true;\n+        method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      }\n+    }\n+    if (array_type != NULL) {\n+      \/\/ Speculate that this array has the exact type reported by profile data\n+      Node* better_ary = NULL;\n+      DEBUG_ONLY(Node* old_control = control();)\n+      Node* slow_ctl = type_check_receiver(ary, array_type, 1.0, &better_ary);\n+      if (stopped()) {\n+        \/\/ The check always fails and therefore profile information is incorrect. Don't use it.\n+        assert(old_control == slow_ctl, \"type check should have been removed\");\n+        set_control(slow_ctl);\n+      } else if (!slow_ctl->is_top()) {\n+        { PreserveJVMState pjvms(this);\n+          set_control(slow_ctl);\n+          uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+        }\n+        replace_in_map(ary, better_ary);\n+        ary = better_ary;\n+        arytype  = _gvn.type(ary)->is_aryptr();\n+        elemtype = arytype->elem();\n+      }\n+    }\n+  } else if (UseTypeSpeculation && UseArrayLoadStoreProfile) {\n+    \/\/ No need to speculate: feed profile data at this bci for the\n+    \/\/ array to type speculation\n+    ciKlass* array_type = NULL;\n+    ciKlass* element_type = NULL;\n+    ProfilePtrKind element_ptr = ProfileMaybeNull;\n+    bool flat_array = true;\n+    bool null_free_array = true;\n+    method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+    if (array_type != NULL) {\n+      ary = record_profile_for_speculation(ary, array_type, ProfileMaybeNull);\n+    }\n+  }\n+\n+  \/\/ We have no exact array type from profile data. Check profile data\n+  \/\/ for a non null-free or non flat array. Non null-free implies non\n+  \/\/ flat so check this one first. Speculating on a non null-free\n+  \/\/ array doesn't help aaload but could be profitable for a\n+  \/\/ subsequent aastore.\n+  if (!arytype->is_null_free() && !arytype->is_not_null_free()) {\n+    bool null_free_array = true;\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_none;\n+    if (arytype->speculative() != NULL &&\n+        arytype->speculative()->is_aryptr()->is_not_null_free() &&\n+        !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      null_free_array = false;\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n+      ciKlass* array_type = NULL;\n+      ciKlass* element_type = NULL;\n+      ProfilePtrKind element_ptr = ProfileMaybeNull;\n+      bool flat_array = true;\n+      method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    if (!null_free_array) {\n+      { \/\/ Deoptimize if null-free array\n+        BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n+        uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+      }\n+      assert(!stopped(), \"null-free array should have been caught earlier\");\n+      Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype->cast_to_not_null_free()));\n+      replace_in_map(ary, better_ary);\n+      ary = better_ary;\n+      arytype = _gvn.type(ary)->is_aryptr();\n+    }\n+  }\n+\n+  if (!arytype->is_flat() && !arytype->is_not_flat()) {\n+    bool flat_array = true;\n+    Deoptimization::DeoptReason reason = Deoptimization::Reason_none;\n+    if (arytype->speculative() != NULL &&\n+        arytype->speculative()->is_aryptr()->is_not_flat() &&\n+        !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      flat_array = false;\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(reason)) {\n+      ciKlass* array_type = NULL;\n+      ciKlass* element_type = NULL;\n+      ProfilePtrKind element_ptr = ProfileMaybeNull;\n+      bool null_free_array = true;\n+      method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    if (!flat_array) {\n+      { \/\/ Deoptimize if flat array\n+        BuildCutout unless(this, flat_array_test(ary, \/* flat = *\/ false), PROB_MAX);\n+        uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+      }\n+      assert(!stopped(), \"flat array should have been caught earlier\");\n+      Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype->cast_to_not_flat()));\n+      replace_in_map(ary, better_ary);\n+      ary = better_ary;\n+      arytype = _gvn.type(ary)->is_aryptr();\n+    }\n+  }\n+\n@@ -1436,1 +1780,1 @@\n-void Parse::do_if(BoolTest::mask btest, Node* c) {\n+void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {\n@@ -1520,2 +1864,2 @@\n-      if (C->eliminate_boxing()) {\n-        \/\/ Mark the successor block as parsed\n+      if (C->eliminate_boxing() && !new_path) {\n+        \/\/ Mark the successor block as parsed (if we haven't created a new path)\n@@ -1527,1 +1871,9 @@\n-        merge(target_bci);\n+        if (new_path) {\n+          \/\/ Merge by using a new path\n+          merge_new_path(target_bci);\n+        } else if (ctrl_taken != NULL) {\n+          \/\/ Don't merge but save taken branch to be wired by caller\n+          *ctrl_taken = control();\n+        } else {\n+          merge(target_bci);\n+        }\n@@ -1536,1 +1888,1 @@\n-  if (stopped()) {\n+  if (stopped() && ctrl_taken == NULL) {\n@@ -1538,1 +1890,1 @@\n-      \/\/ Mark the successor block as parsed\n+      \/\/ Mark the successor block as parsed (if caller does not re-wire control flow)\n@@ -1546,0 +1898,392 @@\n+\n+static ProfilePtrKind speculative_ptr_kind(const TypeOopPtr* t) {\n+  if (t->speculative() == NULL) {\n+    return ProfileUnknownNull;\n+  }\n+  if (t->speculative_always_null()) {\n+    return ProfileAlwaysNull;\n+  }\n+  if (t->speculative_maybe_null()) {\n+    return ProfileMaybeNull;\n+  }\n+  return ProfileNeverNull;\n+}\n+\n+void Parse::acmp_always_null_input(Node* input, const TypeOopPtr* tinput, BoolTest::mask btest, Node* eq_region) {\n+  inc_sp(2);\n+  Node* cast = null_check_common(input, T_OBJECT, true, NULL,\n+                                 !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check) &&\n+                                 speculative_ptr_kind(tinput) == ProfileAlwaysNull);\n+  dec_sp(2);\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      replace_in_map(input, cast);\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    replace_in_map(input, cast);\n+  }\n+}\n+\n+Node* Parse::acmp_null_check(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, Node*& null_ctl) {\n+  inc_sp(2);\n+  null_ctl = top();\n+  Node* cast = null_check_oop(input, &null_ctl,\n+                              input_ptr == ProfileNeverNull || (input_ptr == ProfileUnknownNull && !too_many_traps_or_recompiles(Deoptimization::Reason_null_check)),\n+                              false,\n+                              speculative_ptr_kind(tinput) == ProfileNeverNull &&\n+                              !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check));\n+  dec_sp(2);\n+  assert(!stopped(), \"null input should have been caught earlier\");\n+  return cast;\n+}\n+\n+void Parse::acmp_known_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, ciKlass* input_type, BoolTest::mask btest, Node* eq_region) {\n+  Node* ne_region = new RegionNode(1);\n+  Node* null_ctl;\n+  Node* cast = acmp_null_check(input, tinput, input_ptr, null_ctl);\n+  ne_region->add_req(null_ctl);\n+\n+  Node* slow_ctl = type_check_receiver(cast, input_type, 1.0, &cast);\n+  {\n+    PreserveJVMState pjvms(this);\n+    inc_sp(2);\n+    set_control(slow_ctl);\n+    Deoptimization::DeoptReason reason;\n+    if (tinput->speculative_type() != NULL && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else {\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+  }\n+  ne_region->add_req(control());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      if (null_ctl == top()) {\n+        replace_in_map(input, cast);\n+      }\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    if (null_ctl == top()) {\n+      replace_in_map(input, cast);\n+    }\n+    set_control(_gvn.transform(ne_region));\n+  }\n+}\n+\n+void Parse::acmp_unknown_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, BoolTest::mask btest, Node* eq_region) {\n+  Node* ne_region = new RegionNode(1);\n+  Node* null_ctl;\n+  Node* cast = acmp_null_check(input, tinput, input_ptr, null_ctl);\n+  ne_region->add_req(null_ctl);\n+\n+  {\n+    BuildCutout unless(this, inline_type_test(cast, \/* is_inline = *\/ false), PROB_MAX);\n+    inc_sp(2);\n+    uncommon_trap_exact(Deoptimization::Reason_class_check, Deoptimization::Action_maybe_recompile);\n+  }\n+\n+  ne_region->add_req(control());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      if (null_ctl == top()) {\n+        replace_in_map(input, cast);\n+      }\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    if (null_ctl == top()) {\n+      replace_in_map(input, cast);\n+    }\n+    set_control(_gvn.transform(ne_region));\n+  }\n+}\n+\n+void Parse::do_acmp(BoolTest::mask btest, Node* left, Node* right) {\n+  ciKlass* left_type = NULL;\n+  ciKlass* right_type = NULL;\n+  ProfilePtrKind left_ptr = ProfileUnknownNull;\n+  ProfilePtrKind right_ptr = ProfileUnknownNull;\n+  bool left_inline_type = true;\n+  bool right_inline_type = true;\n+\n+  \/\/ Leverage profiling at acmp\n+  if (UseACmpProfile) {\n+    method()->acmp_profiled_type(bci(), left_type, right_type, left_ptr, right_ptr, left_inline_type, right_inline_type);\n+    if (too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n+      left_type = NULL;\n+      right_type = NULL;\n+      left_inline_type = true;\n+      right_inline_type = true;\n+    }\n+    if (too_many_traps_or_recompiles(Deoptimization::Reason_null_check)) {\n+      left_ptr = ProfileUnknownNull;\n+      right_ptr = ProfileUnknownNull;\n+    }\n+  }\n+\n+  if (UseTypeSpeculation) {\n+    record_profile_for_speculation(left, left_type, left_ptr);\n+    record_profile_for_speculation(right, right_type, right_ptr);\n+  }\n+\n+  if (!EnableValhalla) {\n+    Node* cmp = CmpP(left, right);\n+    cmp = optimize_cmp_with_klass(cmp);\n+    do_if(btest, cmp);\n+    return;\n+  }\n+\n+  \/\/ Check for equality before potentially allocating\n+  if (left == right) {\n+    do_if(btest, makecon(TypeInt::CC_EQ));\n+    return;\n+  }\n+\n+  \/\/ Allocate inline type operands and re-execute on deoptimization\n+  if (left->is_InlineType()) {\n+    if (_gvn.type(right)->is_zero_type() ||\n+        (right->is_InlineType() && _gvn.type(right->as_InlineType()->get_is_init())->is_zero_type())) {\n+      \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+      \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+      Node* cmp = CmpI(left->as_InlineType()->get_is_init(), intcon(0));\n+      do_if(btest, cmp);\n+      return;\n+    } else {\n+      PreserveReexecuteState preexecs(this);\n+      inc_sp(2);\n+      jvms()->set_should_reexecute(true);\n+      left = left->as_InlineType()->buffer(this)->get_oop();\n+    }\n+  }\n+  if (right->is_InlineType()) {\n+    PreserveReexecuteState preexecs(this);\n+    inc_sp(2);\n+    jvms()->set_should_reexecute(true);\n+    right = right->as_InlineType()->buffer(this)->get_oop();\n+  }\n+\n+  \/\/ First, do a normal pointer comparison\n+  const TypeOopPtr* tleft = _gvn.type(left)->isa_oopptr();\n+  const TypeOopPtr* tright = _gvn.type(right)->isa_oopptr();\n+  Node* cmp = CmpP(left, right);\n+  cmp = optimize_cmp_with_klass(cmp);\n+  if (tleft == NULL || !tleft->can_be_inline_type() ||\n+      tright == NULL || !tright->can_be_inline_type()) {\n+    \/\/ This is sufficient, if one of the operands can't be an inline type\n+    do_if(btest, cmp);\n+    return;\n+  }\n+  Node* eq_region = NULL;\n+  if (btest == BoolTest::eq) {\n+    do_if(btest, cmp, true);\n+    if (stopped()) {\n+      return;\n+    }\n+  } else {\n+    assert(btest == BoolTest::ne, \"only eq or ne\");\n+    Node* is_not_equal = NULL;\n+    eq_region = new RegionNode(3);\n+    {\n+      PreserveJVMState pjvms(this);\n+      do_if(btest, cmp, false, &is_not_equal);\n+      if (!stopped()) {\n+        eq_region->init_req(1, control());\n+      }\n+    }\n+    if (is_not_equal == NULL || is_not_equal->is_top()) {\n+      record_for_igvn(eq_region);\n+      set_control(_gvn.transform(eq_region));\n+      return;\n+    }\n+    set_control(is_not_equal);\n+  }\n+\n+  \/\/ Prefer speculative types if available\n+  if (!too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+    if (tleft->speculative_type() != NULL) {\n+      left_type = tleft->speculative_type();\n+    }\n+    if (tright->speculative_type() != NULL) {\n+      right_type = tright->speculative_type();\n+    }\n+  }\n+\n+  if (speculative_ptr_kind(tleft) != ProfileMaybeNull && speculative_ptr_kind(tleft) != ProfileUnknownNull) {\n+    ProfilePtrKind speculative_left_ptr = speculative_ptr_kind(tleft);\n+    if (speculative_left_ptr == ProfileAlwaysNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_assert)) {\n+      left_ptr = speculative_left_ptr;\n+    } else if (speculative_left_ptr == ProfileNeverNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check)) {\n+      left_ptr = speculative_left_ptr;\n+    }\n+  }\n+  if (speculative_ptr_kind(tright) != ProfileMaybeNull && speculative_ptr_kind(tright) != ProfileUnknownNull) {\n+    ProfilePtrKind speculative_right_ptr = speculative_ptr_kind(tright);\n+    if (speculative_right_ptr == ProfileAlwaysNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_assert)) {\n+      right_ptr = speculative_right_ptr;\n+    } else if (speculative_right_ptr == ProfileNeverNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check)) {\n+      right_ptr = speculative_right_ptr;\n+    }\n+  }\n+\n+  if (left_ptr == ProfileAlwaysNull) {\n+    \/\/ Comparison with null. Assert the input is indeed null and we're done.\n+    acmp_always_null_input(left, tleft, btest, eq_region);\n+    return;\n+  }\n+  if (right_ptr == ProfileAlwaysNull) {\n+    \/\/ Comparison with null. Assert the input is indeed null and we're done.\n+    acmp_always_null_input(right, tright, btest, eq_region);\n+    return;\n+  }\n+  if (left_type != NULL && !left_type->is_inlinetype()) {\n+    \/\/ Comparison with an object of known type\n+    acmp_known_non_inline_type_input(left, tleft, left_ptr, left_type, btest, eq_region);\n+    return;\n+  }\n+  if (right_type != NULL && !right_type->is_inlinetype()) {\n+    \/\/ Comparison with an object of known type\n+    acmp_known_non_inline_type_input(right, tright, right_ptr, right_type, btest, eq_region);\n+    return;\n+  }\n+  if (!left_inline_type) {\n+    \/\/ Comparison with an object known not to be an inline type\n+    acmp_unknown_non_inline_type_input(left, tleft, left_ptr, btest, eq_region);\n+    return;\n+  }\n+  if (!right_inline_type) {\n+    \/\/ Comparison with an object known not to be an inline type\n+    acmp_unknown_non_inline_type_input(right, tright, right_ptr, btest, eq_region);\n+    return;\n+  }\n+\n+  \/\/ Pointers are not equal, check if first operand is non-null\n+  Node* ne_region = new RegionNode(6);\n+  Node* null_ctl;\n+  Node* not_null_right = acmp_null_check(right, tright, right_ptr, null_ctl);\n+  ne_region->init_req(1, null_ctl);\n+\n+  \/\/ First operand is non-null, check if it is an inline type\n+  Node* is_value = inline_type_test(not_null_right);\n+  IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);\n+  Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));\n+  ne_region->init_req(2, not_value);\n+  set_control(_gvn.transform(new IfTrueNode(is_value_iff)));\n+\n+  \/\/ The first operand is an inline type, check if the second operand is non-null\n+  Node* not_null_left = acmp_null_check(left, tleft, left_ptr, null_ctl);\n+  ne_region->init_req(3, null_ctl);\n+\n+  \/\/ Check if both operands are of the same class.\n+  Node* kls_left = load_object_klass(not_null_left);\n+  Node* kls_right = load_object_klass(not_null_right);\n+  Node* kls_cmp = CmpP(kls_left, kls_right);\n+  Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));\n+  IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);\n+  Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));\n+  set_control(_gvn.transform(new IfFalseNode(kls_iff)));\n+  ne_region->init_req(4, kls_ne);\n+\n+  if (stopped()) {\n+    record_for_igvn(ne_region);\n+    set_control(_gvn.transform(ne_region));\n+    if (btest == BoolTest::ne) {\n+      {\n+        PreserveJVMState pjvms(this);\n+        int target_bci = iter().get_dest();\n+        merge(target_bci);\n+      }\n+      record_for_igvn(eq_region);\n+      set_control(_gvn.transform(eq_region));\n+    }\n+    return;\n+  }\n+\n+  \/\/ Both operands are values types of the same class, we need to perform a\n+  \/\/ substitutability test. Delegate to ValueObjectMethods::isSubstitutable().\n+  Node* ne_io_phi = PhiNode::make(ne_region, i_o());\n+  Node* mem = reset_memory();\n+  Node* ne_mem_phi = PhiNode::make(ne_region, mem);\n+\n+  Node* eq_io_phi = NULL;\n+  Node* eq_mem_phi = NULL;\n+  if (eq_region != NULL) {\n+    eq_io_phi = PhiNode::make(eq_region, i_o());\n+    eq_mem_phi = PhiNode::make(eq_region, mem);\n+  }\n+\n+  set_all_memory(mem);\n+\n+  kill_dead_locals();\n+  ciMethod* subst_method = ciEnv::current()->ValueObjectMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n+  CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method);\n+  call->set_override_symbolic_info(true);\n+  call->init_req(TypeFunc::Parms, not_null_left);\n+  call->init_req(TypeFunc::Parms+1, not_null_right);\n+  inc_sp(2);\n+  set_edges_for_java_call(call, false, false);\n+  Node* ret = set_results_for_java_call(call, false, true);\n+  dec_sp(2);\n+\n+  \/\/ Test the return value of ValueObjectMethods::isSubstitutable()\n+  Node* subst_cmp = _gvn.transform(new CmpINode(ret, intcon(1)));\n+  Node* ctl = C->top();\n+  if (btest == BoolTest::eq) {\n+    PreserveJVMState pjvms(this);\n+    do_if(btest, subst_cmp);\n+    if (!stopped()) {\n+      ctl = control();\n+    }\n+  } else {\n+    assert(btest == BoolTest::ne, \"only eq or ne\");\n+    PreserveJVMState pjvms(this);\n+    do_if(btest, subst_cmp, false, &ctl);\n+    if (!stopped()) {\n+      eq_region->init_req(2, control());\n+      eq_io_phi->init_req(2, i_o());\n+      eq_mem_phi->init_req(2, reset_memory());\n+    }\n+  }\n+  ne_region->init_req(5, ctl);\n+  ne_io_phi->init_req(5, i_o());\n+  ne_mem_phi->init_req(5, reset_memory());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  set_i_o(_gvn.transform(ne_io_phi));\n+  set_all_memory(_gvn.transform(ne_mem_phi));\n+\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+    set_i_o(_gvn.transform(eq_io_phi));\n+    set_all_memory(_gvn.transform(eq_mem_phi));\n+  }\n+}\n+\n@@ -1786,0 +2530,4 @@\n+        if (obj->is_InlineType()) {\n+          assert(obj->as_InlineType()->is_allocated(&_gvn), \"must be allocated\");\n+          obj = obj->as_InlineType()->get_oop();\n+        }\n@@ -2632,14 +3380,20 @@\n-    if (!_gvn.type(b)->speculative_maybe_null() &&\n-        !too_many_traps(Deoptimization::Reason_speculate_null_check)) {\n-      inc_sp(1);\n-      Node* null_ctl = top();\n-      b = null_check_oop(b, &null_ctl, true, true, true);\n-      assert(null_ctl->is_top(), \"no null control here\");\n-      dec_sp(1);\n-    } else if (_gvn.type(b)->speculative_always_null() &&\n-               !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {\n-      inc_sp(1);\n-      b = null_assert(b);\n-      dec_sp(1);\n-    }\n-    c = _gvn.transform( new CmpPNode(b, a) );\n+    if (b->is_InlineType()) {\n+      \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+      \/\/ input instead of the oop input to avoid keeping buffer allocations alive\n+      c = _gvn.transform(new CmpINode(b->as_InlineType()->get_is_init(), zerocon(T_INT)));\n+    } else {\n+      if (!_gvn.type(b)->speculative_maybe_null() &&\n+          !too_many_traps(Deoptimization::Reason_speculate_null_check)) {\n+        inc_sp(1);\n+        Node* null_ctl = top();\n+        b = null_check_oop(b, &null_ctl, true, true, true);\n+        assert(null_ctl->is_top(), \"no null control here\");\n+        dec_sp(1);\n+      } else if (_gvn.type(b)->speculative_always_null() &&\n+                 !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {\n+        inc_sp(1);\n+        b = null_assert(b);\n+        dec_sp(1);\n+      }\n+      c = _gvn.transform( new CmpPNode(b, a) );\n+    }\n@@ -2656,3 +3410,1 @@\n-    c = _gvn.transform( new CmpPNode(b, a) );\n-    c = optimize_cmp_with_klass(c);\n-    do_if(btest, c);\n+    do_acmp(btest, b, a);\n@@ -2713,1 +3465,1 @@\n-    do_anewarray();\n+    do_newarray();\n@@ -2724,0 +3476,6 @@\n+  case Bytecodes::_aconst_init:\n+    do_aconst_init();\n+    break;\n+  case Bytecodes::_withfield:\n+    do_withfield();\n+    break;\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":808,"deletions":50,"binary":false,"changes":858,"status":"modified"},{"patch":"@@ -1228,6 +1228,0 @@\n-  if (_delay_transform) {\n-    \/\/ Register the node but don't optimize for now\n-    register_new_node_with_optimizer(n);\n-    return n;\n-  }\n-\n@@ -1240,0 +1234,6 @@\n+  if (_delay_transform) {\n+    \/\/ Add the node to the worklist but don't optimize for now\n+    _worklist.push(n);\n+    return n;\n+  }\n+\n@@ -1502,0 +1502,13 @@\n+void PhaseIterGVN::replace_in_uses(Node* n, Node* m) {\n+  assert(n != NULL, \"sanity\");\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    if (u != n) {\n+      rehash_node_delayed(u);\n+      int nb = u->replace_edge(n, m);\n+      --i, imax -= nb;\n+    }\n+  }\n+  assert(n->outcnt() == 0, \"all uses must be deleted\");\n+}\n+\n@@ -1602,0 +1615,9 @@\n+    \/\/ Inline type nodes can have other inline types as users. If an input gets\n+    \/\/ updated, make sure that inline type users get a chance for optimization.\n+    if (use->is_InlineType()) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->is_InlineType())\n+          _worklist.push(u);\n+      }\n+    }\n@@ -1657,0 +1679,8 @@\n+    if (use_op == Op_CastP2X) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->Opcode() == Op_AndX) {\n+          _worklist.push(u);\n+        }\n+      }\n+    }\n@@ -1681,0 +1711,11 @@\n+\n+    \/\/ Give CallStaticJavaNode::remove_useless_allocation a chance to run\n+    if (use->is_Region()) {\n+      Node* c = use;\n+      do {\n+        c = c->unique_ctrl_out_or_null();\n+      } while (c != NULL && c->is_Region());\n+      if (c != NULL && c->is_CallStaticJava() && c->as_CallStaticJava()->uncommon_trap_request() != 0) {\n+        _worklist.push(c);\n+      }\n+    }\n@@ -1848,0 +1889,1 @@\n+  push_cast(worklist, use);\n@@ -1908,0 +1950,12 @@\n+void PhaseCCP::push_cast(Unique_Node_List& worklist, const Node* use) {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_CastP2X) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_AndX) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":60,"deletions":6,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-  virtual void record_for_igvn(Node *n) { }\n+  virtual void record_for_igvn(Node *n) { _worklist.push(n); }\n@@ -521,0 +521,2 @@\n+  void replace_in_uses(Node* n, Node* m);\n+\n@@ -595,0 +597,1 @@\n+  static void push_cast(Unique_Node_List& worklist, const Node* use);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+  flags(SPLIT_INLINES_ARRAY,          \"Split inlines array\") \\\n+  flags(SPLIT_INLINES_ARRAY_IGVN,     \"IGVN after split inlines array\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -112,0 +114,1 @@\n+address OptoRuntime::_load_unknown_inline                         = NULL;\n@@ -155,1 +158,0 @@\n-\n@@ -158,0 +160,1 @@\n+  gen(env, _load_unknown_inline            , load_unknown_inline_type     , load_unknown_inline             ,    0 , true,  false);\n@@ -203,1 +206,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* current))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, bool is_larval, JavaThread* current))\n@@ -223,1 +226,5 @@\n-    oop result = InstanceKlass::cast(klass)->allocate_instance(THREAD);\n+    instanceOop result = InstanceKlass::cast(klass)->allocate_instance(THREAD);\n+    if (is_larval) {\n+      \/\/ Check if this is a larval buffer allocation\n+      result->set_mark(result->mark().enter_larval_state());\n+    }\n@@ -251,1 +258,4 @@\n-  if (array_type->is_typeArray_klass()) {\n+  if (array_type->is_flatArray_klass()) {\n+    Klass* elem_type = FlatArrayKlass::cast(array_type)->element_klass();\n+    result = oopFactory::new_valueArray(elem_type, len, THREAD);\n+  } else if (array_type->is_typeArray_klass()) {\n@@ -257,5 +267,1 @@\n-    \/\/ Although the oopFactory likes to work with the elem_type,\n-    \/\/ the compiler prefers the array_type, since it must already have\n-    \/\/ that latter value in hand for the fast path.\n-    Klass* elem_type = ObjArrayKlass::cast(array_type)->element_klass();\n-    result = oopFactory::new_objArray(elem_type, len, THREAD);\n+    result = ObjArrayKlass::cast(array_type)->allocate(len, THREAD);\n@@ -456,1 +462,1 @@\n-  const Type **fields = TypeTuple::fields(1);\n+  const Type **fields = TypeTuple::fields(2);\n@@ -458,1 +464,2 @@\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms+1] = TypeInt::BOOL;        \/\/ is_larval\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n@@ -576,1 +583,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1628,1 +1635,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1661,1 +1668,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1677,1 +1684,1 @@\n-  return TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain, range);\n@@ -1801,0 +1808,104 @@\n+\n+const TypeFunc *OptoRuntime::store_inline_type_fields_Type() {\n+  \/\/ create input type (domain)\n+  uint total = SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;\n+  const Type **fields = TypeTuple::fields(total);\n+  \/\/ We don't know the number of returned values and their\n+  \/\/ types. Assume all registers available to the return convention\n+  \/\/ are used.\n+  fields[TypeFunc::Parms] = TypePtr::BOTTOM;\n+  uint i = 1;\n+  for (; i < SharedRuntime::java_return_convention_max_int; i++) {\n+    fields[TypeFunc::Parms+i] = TypeInt::INT;\n+  }\n+  for (; i < total; i+=2) {\n+    fields[TypeFunc::Parms+i] = Type::DOUBLE;\n+    fields[TypeFunc::Parms+i+1] = Type::HALF;\n+  }\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+const TypeFunc *OptoRuntime::pack_inline_type_Type() {\n+  \/\/ create input type (domain)\n+  uint total = 1 + SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;\n+  const Type **fields = TypeTuple::fields(total);\n+  \/\/ We don't know the number of returned values and their\n+  \/\/ types. Assume all registers available to the return convention\n+  \/\/ are used.\n+  fields[TypeFunc::Parms] = TypeRawPtr::BOTTOM;\n+  fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;\n+  uint i = 2;\n+  for (; i < SharedRuntime::java_return_convention_max_int+1; i++) {\n+    fields[TypeFunc::Parms+i] = TypeInt::INT;\n+  }\n+  for (; i < total; i+=2) {\n+    fields[TypeFunc::Parms+i] = Type::DOUBLE;\n+    fields[TypeFunc::Parms+i+1] = Type::HALF;\n+  }\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+JRT_BLOCK_ENTRY(void, OptoRuntime::load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current))\n+  JRT_BLOCK;\n+  flatArrayHandle vah(current, array);\n+  oop buffer = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, THREAD);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(buffer);\n+  JRT_BLOCK_END;\n+JRT_END\n+\n+const TypeFunc* OptoRuntime::load_unknown_inline_type() {\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms] = TypeOopPtr::NOTNULL;\n+  fields[TypeFunc::Parms+1] = TypeInt::POS;\n+\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;\n+\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+JRT_LEAF(void, OptoRuntime::store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index))\n+{\n+  assert(buffer != NULL, \"can't store null into flat array\");\n+  array->value_copy_to_index(buffer, index);\n+}\n+JRT_END\n+\n+const TypeFunc* OptoRuntime::store_unknown_inline_type() {\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(3);\n+  fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;\n+  fields[TypeFunc::Parms+1] = TypeOopPtr::NOTNULL;\n+  fields[TypeFunc::Parms+2] = TypeInt::POS;\n+\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":126,"deletions":15,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  static address _load_unknown_inline;\n@@ -144,1 +145,1 @@\n-  static void new_instance_C(Klass* instance_klass, JavaThread* current);\n+  static void new_instance_C(Klass* instance_klass, bool is_larval, JavaThread* current);\n@@ -211,0 +212,1 @@\n+  static address load_unknown_inline_Java()              { return _load_unknown_inline; }\n@@ -302,0 +304,8 @@\n+  static const TypeFunc* store_inline_type_fields_Type();\n+  static const TypeFunc* pack_inline_type_Type();\n+\n+  static void load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current);\n+  static const TypeFunc* load_unknown_inline_type();\n+  static void store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index);\n+  static const TypeFunc* store_unknown_inline_type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -515,2 +516,1 @@\n-        }\n-        else if (m != iff && split_up(m, region, iff)) {\n+        } else if (m != iff && split_up(m, region, iff)) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -318,4 +318,3 @@\n-  CallProjections projs;\n-  call->extract_projections(&projs, false);\n-  if (projs.fallthrough_catchproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_catchproj, call->in(TypeFunc::Control));\n+  CallProjections* projs = call->extract_projections(false);\n+  if (projs->fallthrough_catchproj != NULL) {\n+    C->gvn_replace_by(projs->fallthrough_catchproj, call->in(TypeFunc::Control));\n@@ -323,2 +322,2 @@\n-  if (projs.fallthrough_memproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_memproj, call->in(TypeFunc::Memory));\n+  if (projs->fallthrough_memproj != NULL) {\n+    C->gvn_replace_by(projs->fallthrough_memproj, call->in(TypeFunc::Memory));\n@@ -326,2 +325,2 @@\n-  if (projs.catchall_memproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+  if (projs->catchall_memproj != NULL) {\n+    C->gvn_replace_by(projs->catchall_memproj, C->top());\n@@ -329,2 +328,2 @@\n-  if (projs.fallthrough_ioproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_ioproj, call->in(TypeFunc::I_O));\n+  if (projs->fallthrough_ioproj != NULL) {\n+    C->gvn_replace_by(projs->fallthrough_ioproj, call->in(TypeFunc::I_O));\n@@ -332,2 +331,2 @@\n-  if (projs.catchall_ioproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_ioproj, C->top());\n+  if (projs->catchall_ioproj != NULL) {\n+    C->gvn_replace_by(projs->catchall_ioproj, C->top());\n@@ -335,1 +334,1 @@\n-  if (projs.catchall_catchproj != NULL) {\n+  if (projs->catchall_catchproj != NULL) {\n@@ -338,1 +337,1 @@\n-    for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {\n+    for (SimpleDUIterator i(projs->catchall_catchproj); i.has_next(); i.next()) {\n@@ -345,1 +344,1 @@\n-    C->gvn_replace_by(projs.catchall_catchproj, C->top());\n+    C->gvn_replace_by(projs->catchall_catchproj, C->top());\n@@ -347,2 +346,3 @@\n-  if (projs.resproj != NULL) {\n-    C->gvn_replace_by(projs.resproj, C->top());\n+  if (projs->resproj[0] != NULL) {\n+    assert(projs->nb_resproj == 1, \"unexpected number of results\");\n+    C->gvn_replace_by(projs->resproj[0], C->top());\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -830,1 +831,8 @@\n-Node *CmpLNode::Ideal( PhaseGVN *phase, bool can_reshape ) {\n+\/\/------------------------------Ideal------------------------------------------\n+Node* CmpLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* a = NULL;\n+  Node* b = NULL;\n+  if (is_double_null_check(phase, a, b) && (phase->type(a)->is_zero_type() || phase->type(b)->is_zero_type())) {\n+    \/\/ Degraded to a simple null check, use old acmp\n+    return new CmpPNode(a, b);\n+  }\n@@ -841,0 +849,25 @@\n+\/\/ Match double null check emitted by Compile::optimize_acmp()\n+bool CmpLNode::is_double_null_check(PhaseGVN* phase, Node*& a, Node*& b) const {\n+  if (in(1)->Opcode() == Op_OrL &&\n+      in(1)->in(1)->Opcode() == Op_CastP2X &&\n+      in(1)->in(2)->Opcode() == Op_CastP2X &&\n+      in(2)->bottom_type()->is_zero_type()) {\n+    assert(EnableValhalla, \"unexpected double null check\");\n+    a = in(1)->in(1)->in(1);\n+    b = in(1)->in(2)->in(1);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/------------------------------Value------------------------------------------\n+const Type* CmpLNode::Value(PhaseGVN* phase) const {\n+  Node* a = NULL;\n+  Node* b = NULL;\n+  if (is_double_null_check(phase, a, b) && (!phase->type(a)->maybe_null() || !phase->type(b)->maybe_null())) {\n+    \/\/ One operand is never NULL, emit constant false\n+    return TypeInt::CC_GT;\n+  }\n+  return SubNode::Value(phase);\n+}\n+\n@@ -966,1 +999,16 @@\n-\n+    if (!unrelated_classes) {\n+      \/\/ Handle inline type arrays\n+      if ((r0->flatten_array() && r1->not_flatten_array()) ||\n+          (r1->flatten_array() && r0->not_flatten_array())) {\n+        \/\/ One type is flattened in arrays but the other type is not. Must be unrelated.\n+        unrelated_classes = true;\n+      } else if ((r0->is_not_flat() && r1->is_flat()) ||\n+                 (r1->is_not_flat() && r0->is_flat())) {\n+        \/\/ One type is a non-flattened array and the other type is a flattened array. Must be unrelated.\n+        unrelated_classes = true;\n+      } else if ((r0->is_not_null_free() && r1->is_null_free()) ||\n+                 (r1->is_not_null_free() && r0->is_null_free())) {\n+        \/\/ One type is a nullable array and the other type is a null-free array. Must be unrelated.\n+        unrelated_classes = true;\n+      }\n+    }\n@@ -1051,1 +1099,8 @@\n-Node *CmpPNode::Ideal( PhaseGVN *phase, bool can_reshape ) {\n+Node* CmpPNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ TODO 8284443 in(1) could be cast?\n+  if (in(1)->is_InlineType() && phase->type(in(2))->is_zero_type()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    return new CmpINode(in(1)->as_InlineType()->get_is_init(), phase->intcon(0));\n+  }\n+\n@@ -1123,0 +1178,8 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Do not bypass the klass load from the primary supertype array.\n+  if (superklass->is_obj_array_klass() && !superklass->as_array_klass()->is_elem_null_free() &&\n+      superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return NULL;\n+  }\n+\n@@ -1266,0 +1329,37 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* FlatArrayCheckNode::Value(PhaseGVN* phase) const {\n+  bool all_not_flat = true;\n+  for (uint i = ArrayOrKlass; i < req(); ++i) {\n+    const Type* t = phase->type(in(i));\n+    if (t == Type::TOP) {\n+      return Type::TOP;\n+    }\n+    if (t->is_ptr()->is_flat()) {\n+      \/\/ One of the input arrays is flat, check always passes\n+      return TypeInt::CC_EQ;\n+    } else if (!t->is_ptr()->is_not_flat()) {\n+      \/\/ One of the input arrays might be flat\n+      all_not_flat = false;\n+    }\n+  }\n+  if (all_not_flat) {\n+    \/\/ None of the input arrays can be flat, check always fails\n+    return TypeInt::CC_GT;\n+  }\n+  return TypeInt::CC;\n+}\n+\n+\/\/------------------------------Ideal------------------------------------------\n+Node* FlatArrayCheckNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool changed = false;\n+  \/\/ Remove inputs that are known to be non-flat\n+  for (uint i = ArrayOrKlass; i < req(); ++i) {\n+    const Type* t = phase->type(in(i));\n+    if (t->isa_ptr() && t->is_ptr()->is_not_flat()) {\n+      del_req(i--);\n+      changed = true;\n+    }\n+  }\n+  return changed ? this : NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":103,"deletions":3,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -428,0 +430,1 @@\n+  bool is_inlined = InstanceKlass::cast(k1)->field_is_inlined(slot);\n@@ -429,1 +432,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_inlined);\n@@ -446,1 +449,1 @@\n-  if (m->is_initializer()) {\n+  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n@@ -502,3 +505,12 @@\n-  jboolean ret = sub_klass->is_subtype_of(super_klass) ?\n-                   JNI_TRUE : JNI_FALSE;\n-\n+  jboolean ret;\n+  if (sub_klass == super_klass && sub_klass->is_inline_klass()) {\n+    \/\/ val type is a subtype of ref type\n+    InlineKlass* ik = InlineKlass::cast(sub_klass);\n+    if (sub_mirror == super_mirror || (ik->val_mirror() == sub_mirror && ik->ref_mirror() == super_mirror)) {\n+      ret = JNI_TRUE;\n+    } else {\n+      ret = JNI_FALSE;\n+    }\n+  } else {\n+    ret = sub_klass->is_subtype_of(super_klass) ? JNI_TRUE : JNI_FALSE;\n+  }\n@@ -804,1 +816,2 @@\n-    case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT: push_object(va_arg(_ap, jobject)); break;\n@@ -844,1 +857,2 @@\n-    case T_OBJECT:      push_object((_ap++)->l); break;\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT: push_object((_ap++)->l); break;\n@@ -980,5 +994,19 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n-  obj = JNIHandles::make_local(THREAD, i);\n-  JavaValue jvalue(T_VOID);\n-  JNI_ArgumentPusherArray ap(methodID, args);\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == NULL) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+  }\n+\n+  if (!k->is_inline_klass()) {\n+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+    obj = JNIHandles::make_local(THREAD, i);\n+    JavaValue jvalue(T_VOID);\n+    JNI_ArgumentPusherArray ap(methodID, args);\n+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  } else {\n+    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n+    JNI_ArgumentPusherArray ap(methodID, args);\n+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    obj = jvalue.get_jobject();\n+  }\n@@ -986,1 +1014,1 @@\n-JNI_END\n+  JNI_END\n@@ -998,5 +1026,19 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n-  obj = JNIHandles::make_local(THREAD, i);\n-  JavaValue jvalue(T_VOID);\n-  JNI_ArgumentPusherVaArg ap(methodID, args);\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == NULL) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+  }\n+\n+  if (!k->is_inline_klass()) {\n+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+    obj = JNIHandles::make_local(THREAD, i);\n+    JavaValue jvalue(T_VOID);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  } else {\n+    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    obj = jvalue.get_jobject();\n+  }\n@@ -1016,8 +1058,25 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n-  obj = JNIHandles::make_local(THREAD, i);\n-  va_list args;\n-  va_start(args, methodID);\n-  JavaValue jvalue(T_VOID);\n-  JNI_ArgumentPusherVaArg ap(methodID, args);\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n-  va_end(args);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == NULL) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+  }\n+\n+  if (!k->is_inline_klass()) {\n+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+    obj = JNIHandles::make_local(THREAD, i);\n+    va_list args;\n+    va_start(args, methodID);\n+    JavaValue jvalue(T_VOID);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+    va_end(args);\n+  } else {\n+    va_list args;\n+    va_start(args, methodID);\n+    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n+    JNI_ArgumentPusherVaArg ap(methodID, args);\n+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    va_end(args);\n+    obj = jvalue.get_jobject();\n+  }\n@@ -1774,1 +1833,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_inlined());\n@@ -1784,0 +1843,1 @@\n+  oop res = NULL;\n@@ -1789,2 +1849,12 @@\n-  oop loaded_obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);\n-  jobject ret = JNIHandles::make_local(THREAD, loaded_obj);\n+  if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {\n+    res = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);\n+  } else {\n+    assert(k->is_instance_klass(), \"Only instance can have inlined fields\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    fieldDescriptor fd;\n+    ik->find_field_from_offset(offset, false, &fd);  \/\/ performance bottleneck\n+    InstanceKlass* holder = fd.field_holder();\n+    InlineKlass* field_vklass = InlineKlass::cast(holder->get_inline_type_field_klass(fd.index()));\n+    res = field_vklass->read_inlined_field(o, ik->field_offset(fd.index()), CHECK_NULL);\n+  }\n+  jobject ret = JNIHandles::make_local(THREAD, res);\n@@ -1882,1 +1952,12 @@\n-  HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));\n+  if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {\n+    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));\n+  } else {\n+    assert(k->is_instance_klass(), \"Only instances can have inlined fields\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    fieldDescriptor fd;\n+    ik->find_field_from_offset(offset, false, &fd);\n+    InstanceKlass* holder = fd.field_holder();\n+    InlineKlass* vklass = InlineKlass::cast(holder->get_inline_type_field_klass(fd.index()));\n+    oop v = JNIHandles::resolve_non_null(value);\n+    vklass->write_inlined_field(o, offset, v, CHECK);\n+  }\n@@ -2299,4 +2380,13 @@\n-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-  if (a->is_within_bounds(index)) {\n-    ret = JNIHandles::make_local(THREAD, a->obj_at(index));\n-    return ret;\n+  oop res = NULL;\n+  arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));\n+  if (arr->is_within_bounds(index)) {\n+    if (arr->is_flatArray()) {\n+      flatArrayOop a = flatArrayOop(JNIHandles::resolve_non_null(array));\n+      flatArrayHandle vah(thread, a);\n+      res = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);\n+      assert(res != NULL, \"Must be set in one of two paths above\");\n+    } else {\n+      assert(arr->is_objArray(), \"If not a valueArray. must be an objArray\");\n+      objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+      res = a->obj_at(index);\n+    }\n@@ -2306,1 +2396,1 @@\n-    ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n+    ss.print(\"Index %d out of bounds for length %d\", index,arr->length());\n@@ -2309,0 +2399,2 @@\n+  ret = JNIHandles::make_local(THREAD, res);\n+  return ret;\n@@ -2318,24 +2410,51 @@\n-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-  oop v = JNIHandles::resolve(value);\n-  if (a->is_within_bounds(index)) {\n-    if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n-      a->obj_at_put(index, v);\n-    } else {\n-      ResourceMark rm(THREAD);\n-      stringStream ss;\n-      Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();\n-      ss.print(\"type mismatch: can not store %s to %s[%d]\",\n-               v->klass()->external_name(),\n-               bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),\n-               index);\n-      for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n-        ss.print(\"[]\");\n-      }\n-      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n-    }\n-  } else {\n-    ResourceMark rm(THREAD);\n-    stringStream ss;\n-    ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n-    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n-  }\n+   bool oob = false;\n+   int length = -1;\n+   oop res = NULL;\n+   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));\n+   if (arr->is_within_bounds(index)) {\n+     if (arr->is_flatArray()) {\n+       flatArrayOop a = flatArrayOop(JNIHandles::resolve_non_null(array));\n+       oop v = JNIHandles::resolve(value);\n+       FlatArrayKlass* vaklass = FlatArrayKlass::cast(a->klass());\n+       InlineKlass* element_vklass = vaklass->element_klass();\n+       if (v != NULL && v->is_a(element_vklass)) {\n+         a->value_copy_to_index(v, index);\n+       } else {\n+         ResourceMark rm(THREAD);\n+         stringStream ss;\n+         Klass *kl = FlatArrayKlass::cast(a->klass());\n+         ss.print(\"type mismatch: can not store %s to %s[%d]\",\n+             v->klass()->external_name(),\n+             kl->external_name(),\n+             index);\n+         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n+           ss.print(\"[]\");\n+         }\n+         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+       }\n+     } else {\n+       assert(arr->is_objArray(), \"If not a valueArray. must be an objArray\");\n+       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+       oop v = JNIHandles::resolve(value);\n+       if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n+         a->obj_at_put(index, v);\n+       } else {\n+         ResourceMark rm(THREAD);\n+         stringStream ss;\n+         Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();\n+         ss.print(\"type mismatch: can not store %s to %s[%d]\",\n+             v->klass()->external_name(),\n+             bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),\n+                 index);\n+         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n+           ss.print(\"[]\");\n+         }\n+         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+       }\n+     }\n+   } else {\n+     ResourceMark rm(THREAD);\n+     stringStream ss;\n+     ss.print(\"Index %d out of bounds for length %d\", index, arr->length());\n+     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n+   }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":178,"deletions":59,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -259,1 +259,2 @@\n-      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT)) {\n+      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT) &&\n+      !(fd.field_type() == T_PRIMITIVE_OBJECT && ftype == T_OBJECT)) {\n@@ -296,1 +297,2 @@\n-      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT)) {\n+      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT) &&\n+      !(fd.field_type() == T_PRIMITIVE_OBJECT && ftype == T_OBJECT)) {\n@@ -347,1 +349,1 @@\n-check_is_obj_array(JavaThread* thr, jarray jArray) {\n+check_is_obj_or_inline_array(JavaThread* thr, jarray jArray) {\n@@ -349,1 +351,1 @@\n-  if (!aOop->is_objArray()) {\n+  if (!aOop->is_objArray() && !aOop->is_flatArray()) {\n@@ -469,1 +471,1 @@\n-      name[0] == JVM_SIGNATURE_CLASS &&            \/\/ 'L'\n+      (name[0] == JVM_SIGNATURE_CLASS || name[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) && \/\/ 'L' or 'Q'\n@@ -1609,1 +1611,1 @@\n-      check_is_obj_array(thr, array);\n+      check_is_obj_or_inline_array(thr, array);\n@@ -1623,1 +1625,1 @@\n-      check_is_obj_array(thr, array);\n+      check_is_obj_or_inline_array(thr, array);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -616,1 +617,22 @@\n-  return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;\n+  if (handle == NULL) {\n+    return 0;\n+  }\n+  oop obj = JNIHandles::resolve_non_null(handle);\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+      JavaValue result(T_INT);\n+      JavaCallArguments args;\n+      Handle ho(THREAD, obj);\n+      args.push_oop(ho);\n+      methodHandle method(THREAD, Universe::value_object_hash_code_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in hashCode\", e, false);\n+        }\n+      }\n+      return result.get_jint();\n+  } else {\n+    return ObjectSynchronizer::FastHashCode(THREAD, obj);\n+  }\n@@ -668,0 +690,1 @@\n+       klass->is_inline_klass() ||\n@@ -1181,1 +1204,2 @@\n-    size = InstanceKlass::cast(klass)->local_interfaces()->length();\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    size = ik->local_interfaces()->length();\n@@ -1183,1 +1207,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n@@ -1194,1 +1218,2 @@\n-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n+      InstanceKlass* ik = InstanceKlass::cast(klass);\n+      Klass* k = ik->local_interfaces()->at(index);\n@@ -1229,0 +1254,13 @@\n+JVM_ENTRY(jboolean, JVM_IsIdentityClass(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (EnableValhalla) {\n+    return k->is_array_klass() || k->is_identity_class();\n+  } else {\n+    return k->is_interface() ? JNI_FALSE : JNI_TRUE;\n+  }\n+JVM_END\n+\n@@ -1844,0 +1882,2 @@\n+  bool is_ctor = (method->is_object_constructor() ||\n+                  method->is_static_vnew_factory());\n@@ -1845,1 +1885,1 @@\n-    return (method->is_initializer() && !method->is_static());\n+    return is_ctor;\n@@ -1847,1 +1887,3 @@\n-    return  (!method->is_initializer() && !method->is_overpass());\n+    return (!is_ctor &&\n+            !method->is_class_initializer() &&\n+            !method->is_overpass());\n@@ -1910,0 +1952,2 @@\n+        assert(method->is_object_constructor() ||\n+               method->is_static_vnew_factory(), \"must be\");\n@@ -2192,3 +2236,1 @@\n-  if (!m->is_initializer() || m->is_static()) {\n-    method = Reflection::new_method(m, true, CHECK_NULL);\n-  } else {\n+  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n@@ -2196,0 +2238,2 @@\n+  } else {\n+    method = Reflection::new_method(m, true, CHECK_NULL);\n@@ -2466,0 +2510,37 @@\n+\/\/ Arrays support \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == NULL) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  return ArrayKlass::cast(k)->element_access_is_atomic();\n+JVM_END\n+\n+JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == NULL) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vk = FlatArrayKlass::cast(k);\n+    if (!vk->element_access_is_atomic()) {\n+      \/**\n+       * Need to decide how to implement:\n+       *\n+       * 1) Change to objArrayOop layout, therefore oop->klass() differs so\n+       * then \"<atomic>[Qfoo;\" klass needs to subclass \"[Qfoo;\" to pass through\n+       * \"checkcast\" & \"instanceof\"\n+       *\n+       * 2) Use extra header in the flatArrayOop to flag atomicity required and\n+       * possibly per instance lock structure. Said info, could be placed in\n+       * \"trailer\" rather than disturb the current arrayOop\n+       *\/\n+      Unimplemented();\n+    }\n+  }\n+  return array;\n+JVM_END\n+\n@@ -2628,1 +2709,1 @@\n-  return method->name() == vmSymbols::object_initializer_name();\n+  return method->is_object_constructor();\n@@ -3473,0 +3554,4 @@\n+JVM_LEAF(jboolean, JVM_IsValhallaEnabled(void))\n+  return EnableValhalla ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n@@ -3550,1 +3635,1 @@\n-    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n+    objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3570,0 +3655,1 @@\n+  objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3571,1 +3657,0 @@\n-  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":97,"deletions":12,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2893,3 +2893,3 @@\n-    if (k->is_super()) {\n-      result |= JVM_ACC_SUPER;\n-    }\n+    \/\/ if (k->is_super()) {\n+    \/\/   result |= JVM_ACC_SUPER;\n+    \/\/ }\n@@ -3033,1 +3033,2 @@\n-                                            src_st.access_flags().is_static());\n+                                            src_st.access_flags().is_static(),\n+                                            src_st.field_descriptor().is_inlined());\n@@ -3070,2 +3071,3 @@\n-    Array<InstanceKlass*>* interface_list = InstanceKlass::cast(k)->local_interfaces();\n-    const int result_length = (interface_list == NULL ? 0 : interface_list->length());\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    Array<InstanceKlass*>* interface_list = ik->local_interfaces();\n+    int result_length = (interface_list == NULL ? 0 : interface_list->length());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2314,1 +2314,1 @@\n-  if (sig_type == JVM_SIGNATURE_CLASS) {\n+  if (sig_type == JVM_SIGNATURE_CLASS || sig_type == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -459,1 +459,2 @@\n-  if (ty_sign[0] == JVM_SIGNATURE_CLASS &&\n+  if ((ty_sign[0] == JVM_SIGNATURE_CLASS ||\n+       ty_sign[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) &&\n@@ -537,0 +538,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -684,1 +686,1 @@\n-      if (_type == T_OBJECT) {\n+      if (_type == T_OBJECT || _type == T_PRIMITIVE_OBJECT) {\n@@ -702,1 +704,2 @@\n-      case T_OBJECT: {\n+      case T_OBJECT:\n+      case T_PRIMITIVE_OBJECT: {\n@@ -723,1 +726,2 @@\n-        case T_OBJECT: {\n+        case T_OBJECT:\n+        case T_PRIMITIVE_OBJECT: {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -607,2 +607,1 @@\n-    \/\/ At this stage JVM_CONSTANT_UnresolvedClassInError should not be\n-    \/\/ here\n+    \/\/ At this stage JVM_CONSTANT_UnresolvedClassInError should not be here\n@@ -918,0 +917,12 @@\n+static jvmtiError check_preload_attribute(InstanceKlass* the_class,\n+                                          InstanceKlass* scratch_class) {\n+  Thread* thread = Thread::current();\n+  ResourceMark rm(thread);\n+\n+  \/\/ Check whether the class Preload attribute has been changed.\n+  return check_attribute_arrays(\"Preload\",\n+                                the_class, scratch_class,\n+                                the_class->preload_classes(),\n+                                scratch_class->preload_classes());\n+}\n+\n@@ -997,0 +1008,6 @@\n+  \/\/ Check whether the Preload attribute has been changed.\n+  err = check_preload_attribute(the_class, scratch_class);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n@@ -1966,0 +1983,6 @@\n+  \/\/ rewrite constant pool references in the Preload attribute:\n+  if (!rewrite_cp_refs_in_preload_attribute(scratch_class)) {\n+    \/\/ propagate failure back to caller\n+    return false;\n+  }\n+\n@@ -2114,0 +2137,13 @@\n+\/\/ Rewrite constant pool references in the Preload attribute.\n+bool VM_RedefineClasses::rewrite_cp_refs_in_preload_attribute(\n+       InstanceKlass* scratch_class) {\n+\n+  Array<u2>* preload_classes = scratch_class->preload_classes();\n+  assert(preload_classes != NULL, \"unexpected null preload_classes\");\n+  for (int i = 0; i < preload_classes->length(); i++) {\n+    u2 cp_index = preload_classes->at(i);\n+    preload_classes->at_put(i, find_new_index(cp_index));\n+  }\n+  return true;\n+}\n+\n@@ -2246,0 +2282,2 @@\n+      case Bytecodes::_aconst_init   : \/\/ fall through\n+      case Bytecodes::_withfield      : \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -133,14 +133,15 @@\n-  IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,\n-  IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,\n-  IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,\n-  IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,\n-  CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,\n-  TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,\n-  REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,\n-  REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,\n-  SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,\n-  SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,\n-  LM_UNCONDITIONAL     = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n-  LM_MODULE            = java_lang_invoke_MemberName::MN_MODULE_MODE,\n-  LM_TRUSTED           = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n-  ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE\n+  IS_METHOD             = java_lang_invoke_MemberName::MN_IS_METHOD,\n+  IS_OBJECT_CONSTRUCTOR = java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR,\n+  IS_FIELD              = java_lang_invoke_MemberName::MN_IS_FIELD,\n+  IS_TYPE               = java_lang_invoke_MemberName::MN_IS_TYPE,\n+  CALLER_SENSITIVE      = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,\n+  TRUSTED_FINAL         = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,\n+  FLATTENED             = java_lang_invoke_MemberName::MN_FLATTENED,\n+  REFERENCE_KIND_SHIFT  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,\n+  REFERENCE_KIND_MASK   = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,\n+  SEARCH_SUPERCLASSES   = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,\n+  SEARCH_INTERFACES     = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,\n+  LM_UNCONDITIONAL      = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n+  LM_MODULE             = java_lang_invoke_MemberName::MN_MODULE_MODE,\n+  LM_TRUSTED            = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n+  ALL_KINDS      = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE\n@@ -157,1 +158,1 @@\n-    flags |= IS_CONSTRUCTOR;\n+    flags |= IS_OBJECT_CONSTRUCTOR;\n@@ -176,1 +177,1 @@\n-    case IS_CONSTRUCTOR:\n+    case IS_OBJECT_CONSTRUCTOR:\n@@ -318,2 +319,2 @@\n-    } else if (m->is_initializer()) {\n-      flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial << REFERENCE_KIND_SHIFT);\n+    } else if (m->is_object_constructor()) {\n+      flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial << REFERENCE_KIND_SHIFT);\n@@ -358,0 +359,1 @@\n+  if (fd.is_inlined()) flags |= FLATTENED;;\n@@ -811,1 +813,1 @@\n-  case IS_CONSTRUCTOR:\n+  case IS_OBJECT_CONSTRUCTOR:\n@@ -817,1 +819,1 @@\n-        if (name == vmSymbols::object_initializer_name()) {\n+        if (name == vmSymbols::object_initializer_name() && type->is_void_method_signature()) {\n@@ -819,0 +821,2 @@\n+        } else if (name == vmSymbols::inline_factory_name()) {\n+          LinkResolver::resolve_static_call(result, link_info, false, THREAD);\n@@ -880,1 +884,1 @@\n-  case IS_CONSTRUCTOR:\n+  case IS_OBJECT_CONSTRUCTOR:\n@@ -959,1 +963,1 @@\n-      match_flags &= ~(IS_CONSTRUCTOR | IS_METHOD);\n+      match_flags &= ~(IS_OBJECT_CONSTRUCTOR | IS_METHOD);\n@@ -989,1 +993,1 @@\n-  if ((match_flags & (IS_METHOD | IS_CONSTRUCTOR)) != 0) {\n+  if ((match_flags & (IS_METHOD | IS_OBJECT_CONSTRUCTOR)) != 0) {\n@@ -993,0 +997,1 @@\n+    Symbol* factory_name = vmSymbols::inline_factory_name();\n@@ -994,2 +999,2 @@\n-    bool negate_name_test = false;\n-    \/\/ fix name so that it captures the intention of IS_CONSTRUCTOR\n+    bool ctor_ok = true, sfac_ok = true;\n+    \/\/ fix name so that it captures the intention of IS_OBJECT_CONSTRUCTOR\n@@ -1003,1 +1008,2 @@\n-    } else if (!(match_flags & IS_CONSTRUCTOR)) {\n+      sfac_ok = false;\n+    } else if (!(match_flags & IS_OBJECT_CONSTRUCTOR)) {\n@@ -1005,6 +1011,1 @@\n-      if (name == NULL) {\n-        name = init_name;\n-        negate_name_test = true; \/\/ if we see the name, we *omit* the entry\n-      } else if (name == init_name) {\n-        return 0;               \/\/ no methods of this constructor name\n-      }\n+      ctor_ok = false;  \/\/ but sfac_ok is true\n@@ -1020,1 +1021,1 @@\n-      if (name != NULL && ((m_name != name) ^ negate_name_test))\n+      if (name != NULL && m_name != name)\n@@ -1024,0 +1025,6 @@\n+      if (m_name == init_name) {  \/\/ might be ctor\n+        if (m->is_object_constructor()  && !ctor_ok)  continue;\n+      }\n+      if (m_name == factory_name) { \/\/ might be sfac\n+        if (m->is_static_vnew_factory() && !sfac_ok) continue;\n+      }\n@@ -1115,1 +1122,1 @@\n-    template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \\\n+    template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \\\n@@ -1120,0 +1127,1 @@\n+    template(java_lang_invoke_MemberName,MN_FLATTENED) \\\n@@ -1259,1 +1267,1 @@\n-               (flags & ALL_KINDS) == IS_CONSTRUCTOR) {\n+               (flags & ALL_KINDS) == IS_OBJECT_CONSTRUCTOR) {\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":43,"deletions":35,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -39,0 +41,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -46,0 +51,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -152,1 +158,0 @@\n-\n@@ -228,0 +233,1 @@\n+    assert(_obj == NULL || !_obj->is_inline_type() || _obj->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n@@ -231,1 +237,0 @@\n-\n@@ -244,0 +249,62 @@\n+#ifdef ASSERT\n+\/*\n+ * Get the field descriptor of the field of the given object at the given offset.\n+ *\/\n+static bool get_field_descriptor(oop p, jlong offset, fieldDescriptor* fd) {\n+  bool found = false;\n+  Klass* k = p->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    found = ik->find_field_from_offset((int)offset, false, fd);\n+    if (!found && ik->is_mirror_instance_klass()) {\n+      Klass* k2 = java_lang_Class::as_Klass(p);\n+      if (k2->is_instance_klass()) {\n+        ik = InstanceKlass::cast(k2);\n+        found = ik->find_field_from_offset((int)offset, true, fd);\n+      }\n+    }\n+  }\n+  return found;\n+}\n+#endif \/\/ ASSERT\n+\n+static void assert_and_log_unsafe_value_access(oop p, jlong offset, InlineKlass* vk) {\n+  Klass* k = p->klass();\n+#ifdef ASSERT\n+  if (k->is_instance_klass()) {\n+    assert_field_offset_sane(p, offset);\n+    fieldDescriptor fd;\n+    bool found = get_field_descriptor(p, offset, &fd);\n+    if (found) {\n+      assert(found, \"value field not found\");\n+      assert(fd.is_inlined(), \"field not flat\");\n+    } else {\n+      if (log_is_enabled(Trace, valuetypes)) {\n+        log_trace(valuetypes)(\"not a field in %s at offset \" UINT64_FORMAT_X,\n+                              p->klass()->external_name(), (uint64_t)offset);\n+      }\n+    }\n+  } else if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+    int index = (offset - vak->array_header_in_bytes()) \/ vak->element_byte_size();\n+    address dest = (address)((flatArrayOop)p)->value_at_addr(index, vak->layout_helper());\n+    assert(dest == (cast_from_oop<address>(p) + offset), \"invalid offset\");\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+#endif \/\/ ASSERT\n+  if (log_is_enabled(Trace, valuetypes)) {\n+    if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      int index = (offset - vak->array_header_in_bytes()) \/ vak->element_byte_size();\n+      address dest = (address)((flatArrayOop)p)->value_at_addr(index, vak->layout_helper());\n+      log_trace(valuetypes)(\"%s array type %s index %d element size %d offset \" UINT64_FORMAT_X \" at \" INTPTR_FORMAT,\n+                            p->klass()->external_name(), vak->external_name(),\n+                            index, vak->element_byte_size(), (uint64_t)offset, p2i(dest));\n+    } else {\n+      log_trace(valuetypes)(\"%s field type %s at offset \" UINT64_FORMAT_X,\n+                            p->klass()->external_name(), vk->external_name(), (uint64_t)offset);\n+    }\n+  }\n+}\n+\n@@ -258,0 +325,1 @@\n+  assert(!p->is_inline_type() || p->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n@@ -261,0 +329,65 @@\n+UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  return vk->first_field_offset();\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedField(JNIEnv *env, jobject unsafe, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->field_is_inlined(slot);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n+  return k->is_flatArray_klass();\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  oop v = vk->default_value();\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {\n+  oop base = JNIHandles::resolve(obj);\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  Handle base_h(THREAD, base);\n+  oop v = vk->read_inlined_field(base_h(), offset, CHECK_NULL);\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {\n+  oop base = JNIHandles::resolve(obj);\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  oop v = JNIHandles::resolve(value);\n+  vk->write_inlined_field(base, offset, v, CHECK);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n+  oop v = JNIHandles::resolve_non_null(value);\n+  assert(v->is_inline_type(), \"must be an inline type instance\");\n+  Handle vh(THREAD, v);\n+  InlineKlass* vk = InlineKlass::cast(v->klass());\n+  instanceOop new_value = vk->allocate_instance_buffer(CHECK_NULL);\n+  vk->inline_copy_oop_to_new_oop(vh(),  new_value);\n+  markWord mark = new_value->mark();\n+  new_value->set_mark(mark.enter_larval_state());\n+  return JNIHandles::make_local(THREAD, new_value);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n+  oop v = JNIHandles::resolve(value);\n+  assert(v->mark().is_larval_state(), \"must be a larval value\");\n+  markWord mark = v->mark();\n+  v->set_mark(mark.exit_larval_state());\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n@@ -593,0 +726,5 @@\n+  } else if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+    InlineKlass* vklass = vak->element_klass();\n+    base = vak->array_header_in_bytes();\n+    scale = vak->element_byte_size();\n@@ -628,0 +766,6 @@\n+UNSAFE_ENTRY(jlong, Unsafe_GetObjectSize0(JNIEnv* env, jobject o, jobject obj))\n+  oop p = JNIHandles::resolve(obj);\n+  return p->size() * HeapWordSize;\n+UNSAFE_END\n+\n+\n@@ -846,4 +990,4 @@\n-    {CC \"get\" #Type,      CC \"(\" OBJ \"J)\" #Desc,       FN_PTR(Unsafe_Get##Type)}, \\\n-    {CC \"put\" #Type,      CC \"(\" OBJ \"J\" #Desc \")V\",   FN_PTR(Unsafe_Put##Type)}, \\\n-    {CC \"get\" #Type \"Volatile\",      CC \"(\" OBJ \"J)\" #Desc,       FN_PTR(Unsafe_Get##Type##Volatile)}, \\\n-    {CC \"put\" #Type \"Volatile\",      CC \"(\" OBJ \"J\" #Desc \")V\",   FN_PTR(Unsafe_Put##Type##Volatile)}\n+    {CC \"get\"  #Type,      CC \"(\" OBJ \"J)\" #Desc,                 FN_PTR(Unsafe_Get##Type)}, \\\n+    {CC \"put\"  #Type,      CC \"(\" OBJ \"J\" #Desc \")V\",             FN_PTR(Unsafe_Put##Type)}, \\\n+    {CC \"get\"  #Type \"Volatile\",      CC \"(\" OBJ \"J)\" #Desc,      FN_PTR(Unsafe_Get##Type##Volatile)}, \\\n+    {CC \"put\"  #Type \"Volatile\",      CC \"(\" OBJ \"J\" #Desc \")V\",  FN_PTR(Unsafe_Put##Type##Volatile)}\n@@ -858,0 +1002,9 @@\n+    {CC \"isFlattenedArray\", CC \"(\" CLS \")Z\",                     FN_PTR(Unsafe_IsFlattenedArray)},\n+    {CC \"isFlattenedField0\", CC \"(\" OBJ \")Z\",                    FN_PTR(Unsafe_IsFlattenedField)},\n+    {CC \"getValue\",         CC \"(\" OBJ \"J\" CLS \")\" OBJ,          FN_PTR(Unsafe_GetValue)},\n+    {CC \"putValue\",         CC \"(\" OBJ \"J\" CLS OBJ \")V\",         FN_PTR(Unsafe_PutValue)},\n+    {CC \"uninitializedDefaultValue\", CC \"(\" CLS \")\" OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},\n+    {CC \"makePrivateBuffer\",     CC \"(\" OBJ \")\" OBJ,             FN_PTR(Unsafe_MakePrivateBuffer)},\n+    {CC \"finishPrivateBuffer\",   CC \"(\" OBJ \")\" OBJ,             FN_PTR(Unsafe_FinishPrivateBuffer)},\n+    {CC \"valueHeaderSize\",       CC \"(\" CLS \")J\",                FN_PTR(Unsafe_ValueHeaderSize)},\n+\n@@ -880,0 +1033,1 @@\n+    {CC \"getObjectSize0\",     CC \"(Ljava\/lang\/Object;)J\", FN_PTR(Unsafe_GetObjectSize0)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":160,"deletions":6,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -67,0 +69,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -1866,0 +1869,87 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return NULL;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return NULL;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+class CollectOops : public BasicOopIterateClosure {\n+ public:\n+  GrowableArray<Handle>* array;\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < array->length(); i++) {\n+      result_array->obj_at_put(i, array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    \/\/ Value might be oop, but JLS can't see as Object, just iterate through it...\n+    if (oh != NULL && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      array->append(oh);\n+    }\n+  }\n+\n+  void do_oop(oop* o) { add_oop(HeapAccess<>::oop_load(o)); }\n+  void do_oop(narrowOop* v) { add_oop(HeapAccess<>::oop_load(v)); }\n+};\n+\n+\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  GrowableArray<Handle>* array = new GrowableArray<Handle>(128);\n+  CollectOops collectOops;\n+  collectOops.array = array;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* array = new GrowableArray<Handle>(128);\n+  CollectOops collectOops;\n+  collectOops.array = array;\n+  StackFrameStream sfs(thread, false \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, NULL, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\n@@ -2693,0 +2783,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1980,0 +1980,10 @@\n+  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {\n+    FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);\n+    warning(\"InlineTypePassFieldsAsArgs is not supported on this platform\");\n+  }\n+\n+  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {\n+    FLAG_SET_CMDLINE(InlineTypeReturnedAsFields, false);\n+    warning(\"InlineTypeReturnedAsFields is not supported on this platform\");\n+  }\n+\n@@ -2918,0 +2928,6 @@\n+  if (!EnableValhalla && EnablePrimitiveClasses) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Cannot specify -XX:+EnablePrimitiveClasses without -XX:+EnableValhalla\");\n+    return JNI_EINVAL;\n+  }\n+\n@@ -4062,0 +4078,7 @@\n+  if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive() && !UseSharedSpaces)) {\n+    \/\/ Disable calling convention optimizations if inline types are not supported.\n+    \/\/ Also these aren't useful in -Xint. However, don't disable them when dumping or using\n+    \/\/ the CDS archive, as the values must match between dumptime and runtime.\n+    InlineTypePassFieldsAsArgs = false;\n+    InlineTypeReturnedAsFields = false;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -192,1 +195,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || k->is_inline_klass() || realloc_failures, \"reallocation was missed\");\n@@ -194,1 +197,5 @@\n-      st.print(\" allocation failed\");\n+      if (k->is_inline_klass()) {\n+        st.print(\" is null\");\n+      } else {\n+        st.print(\" allocation failed\");\n+      }\n@@ -228,2 +235,13 @@\n-  bool save_oop_result = chunk->at(0)->scope()->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n-  Handle return_value;\n+  ScopeDesc* scope = chunk->at(0)->scope();\n+  bool save_oop_result = scope->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n+  \/\/ In case of the return of multiple values, we must take care\n+  \/\/ of all oop return values.\n+  GrowableArray<Handle> return_oops;\n+  InlineKlass* vk = NULL;\n+  if (save_oop_result && scope->return_scalarized()) {\n+    vk = InlineKlass::returned_inline_klass(map);\n+    if (vk != NULL) {\n+      vk->save_oop_fields(map, return_oops);\n+      save_oop_result = false;\n+    }\n+  }\n@@ -235,1 +253,1 @@\n-    return_value = Handle(thread, result);\n+    return_oops.push(Handle(thread, result));\n@@ -242,1 +260,1 @@\n-  if (objects != NULL) {\n+  if (objects != NULL || vk != NULL) {\n@@ -247,1 +265,8 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+      if (vk != NULL) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, CHECK_AND_CLEAR_(true));\n+      }\n+      if (objects != NULL) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+        bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, CHECK_AND_CLEAR_(true));\n+      }\n@@ -252,1 +277,8 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+      if (vk != NULL) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, THREAD);\n+      }\n+      if (objects != NULL) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+        bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, THREAD);\n+      }\n@@ -255,2 +287,0 @@\n-    bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal);\n@@ -261,1 +291,1 @@\n-  if (save_oop_result) {\n+  if (save_oop_result || vk != NULL) {\n@@ -263,1 +293,2 @@\n-    deoptee.set_saved_oop_result(&map, return_value());\n+    assert(return_oops.length() == 1, \"no inline type\");\n+    deoptee.set_saved_oop_result(&map, return_oops.pop()());\n@@ -598,1 +629,1 @@\n-  \/\/ If the sender is deoptimized the we must retrieve the address of the handler\n+  \/\/ If the sender is deoptimized we must retrieve the address of the handler\n@@ -1083,2 +1114,12 @@\n-\n-    oop obj = NULL;\n+    \/\/ Check if the object may be null and has an additional is_init input that needs\n+    \/\/ to be checked before using the field values. Skip re-allocation if it is null.\n+    if (sv->maybe_null()) {\n+      assert(k->is_inline_klass(), \"must be an inline klass\");\n+      intptr_t init_value = StackValue::create_stack_value(fr, reg_map, sv->is_init())->get_int();\n+      jint is_init = (jint)*((jint*)&init_value);\n+      if (is_init == 0) {\n+        continue;\n+      }\n+    }\n+\n+    oop obj = NULL;\n@@ -1112,0 +1153,4 @@\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* ak = FlatArrayKlass::cast(k);\n+      \/\/ Inline type array must be zeroed because not all memory is reassigned\n+      obj = ak->allocate(sv->field_size(), THREAD);\n@@ -1141,0 +1186,15 @@\n+\/\/ We're deoptimizing at the return of a call, inline type fields are\n+\/\/ in registers. When we go back to the interpreter, it will expect a\n+\/\/ reference to an inline type instance. Allocate and initialize it from\n+\/\/ the register values here.\n+bool Deoptimization::realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS) {\n+  oop new_vt = vk->realloc_result(map, return_oops, THREAD);\n+  if (new_vt == NULL) {\n+    CLEAR_PENDING_EXCEPTION;\n+    THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);\n+  }\n+  return_oops.clear();\n+  return_oops.push(Handle(THREAD, new_vt));\n+  return false;\n+}\n+\n@@ -1313,0 +1373,1 @@\n+  InstanceKlass* _klass;\n@@ -1317,0 +1378,1 @@\n+    _klass = NULL;\n@@ -1326,1 +1388,1 @@\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {\n@@ -1335,0 +1397,8 @@\n+        if (fs.signature()->is_Q_signature()) {\n+          if (fs.is_inlined()) {\n+            \/\/ Resolve klass of flattened inline type field\n+            field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n+          } else {\n+            field._type = T_OBJECT;\n+          }\n+        }\n@@ -1342,0 +1412,11 @@\n+    BasicType type = fields->at(i)._type;\n+    int offset = base_offset + fields->at(i)._offset;\n+    \/\/ Check for flattened inline type field before accessing the ScopeValue because it might not have any fields\n+    if (type == T_PRIMITIVE_OBJECT) {\n+      \/\/ Recursively re-assign flattened inline type fields\n+      InstanceKlass* vk = fields->at(i)._klass;\n+      assert(vk != NULL, \"must be resolved\");\n+      offset -= InlineKlass::cast(vk)->first_field_offset(); \/\/ Adjust offset to omit oop header\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);\n+      continue; \/\/ Continue because we don't need to increment svIndex\n+    }\n@@ -1345,3 +1426,2 @@\n-    int offset = fields->at(i)._offset;\n-    BasicType type = fields->at(i)._type;\n-      case T_OBJECT: case T_ARRAY:\n+      case T_OBJECT:\n+      case T_ARRAY:\n@@ -1428,0 +1508,14 @@\n+\/\/ restore fields of an eliminated inline type array\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS) {\n+  InlineKlass* vk = vak->element_klass();\n+  assert(vk->flatten_array(), \"should only be used for flattened inline type arrays\");\n+  \/\/ Adjust offset to omit oop header\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT) - InlineKlass::cast(vk)->first_field_offset();\n+  \/\/ Initialize all elements of the flattened inline type array\n+  for (int i = 0; i < sv->field_size(); i++) {\n+    ScopeValue* val = sv->field_at(i);\n+    int offset = base_offset + (i << Klass::layout_helper_log2_element_size(vak->layout_helper()));\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, skip_internal, offset, CHECK);\n+  }\n+}\n+\n@@ -1429,1 +1523,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS) {\n@@ -1434,1 +1528,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->maybe_null(), \"reallocation was missed\");\n@@ -1474,1 +1568,4 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, CHECK);\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, skip_internal, CHECK);\n@@ -1634,1 +1731,1 @@\n-  \/\/ Deoptimize only if the frame comes from compile code.\n+  \/\/ Deoptimize only if the frame comes from compiled code.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":120,"deletions":23,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  static bool realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS);\n@@ -182,1 +183,2 @@\n-  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal);\n+  static void reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS);\n+  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -58,1 +59,1 @@\n-  return is_final() && (is_static() || ik->is_hidden() || ik->is_record());\n+  return is_final() && (is_static() || ik->is_hidden() || ik->is_record() || ik->is_inline_klass());\n@@ -153,3 +154,5 @@\n-  print_on(st);\n-  st->print(\" \");\n-\n+  if (ft != T_PRIMITIVE_OBJECT) {\n+    print_on(st);\n+    st->print(\" \");\n+  }\n+  jint as_int = 0;\n@@ -185,5 +188,10 @@\n-    case T_ARRAY:\n-      if (obj->obj_field(offset()) != NULL) {\n-        obj->obj_field(offset())->print_value_on(st);\n-      } else {\n-        st->print(\"NULL\");\n+    case T_PRIMITIVE_OBJECT:\n+      if (is_inlined()) {\n+        \/\/ Print fields of inlined fields (recursively)\n+        InlineKlass* vk = InlineKlass::cast(field_holder()->get_inline_type_field_klass(index()));\n+        int field_offset = offset() - vk->first_field_offset();\n+        obj = cast_to_oop(cast_from_oop<address>(obj) + field_offset);\n+        st->print_cr(\"Inline type field inlined '%s':\", vk->name()->as_C_string());\n+        FieldPrinter print_field(st, obj);\n+        vk->do_nonstatic_fields(&print_field);\n+        return; \/\/ Do not print underlying representation\n@@ -191,1 +199,2 @@\n-      break;\n+      \/\/ inline type field not inlined, fall through\n+    case T_ARRAY:\n@@ -230,0 +239,1 @@\n+  st->cr();\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+  inline bool is_inlined() const;\n+  inline bool is_inline_type()    const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -62,0 +63,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -350,0 +354,19 @@\n+\n+#ifdef COMPILER1\n+  if (cm->is_compiled_by_c1() && cm->method()->has_scalarized_args() &&\n+      pc() < cm->verified_inline_entry_point()) {\n+    \/\/ The VEP and VIEP(RO) of C1-compiled methods call into the runtime to buffer scalarized value\n+    \/\/ type args. We can't deoptimize at that point because the buffers have not yet been initialized.\n+    \/\/ Also, if the method is synchronized, we first need to acquire the lock.\n+    \/\/ Don't patch the return pc to delay deoptimization until we enter the method body (the check\n+    \/\/ added in LIRGenerator::do_Base will detect the pending deoptimization by checking the original_pc).\n+#if defined ASSERT && !defined AARCH64   \/\/ Stub call site does not look like NativeCall on AArch64\n+    NativeCall* call = nativeCall_before(this->pc());\n+    address dest = call->destination();\n+    assert(dest == Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id) ||\n+           dest == Runtime1::entry_for(Runtime1::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n+#endif\n+    return;\n+  }\n+#endif\n+\n@@ -748,1 +771,1 @@\n-                          OopClosure* f) {\n+                          OopClosure* f, BufferedValueClosure* bvt_f) {\n@@ -760,1 +783,3 @@\n-      _f->do_oop(addr);\n+      if (_f != NULL) {\n+        _f->do_oop(addr);\n+      }\n@@ -772,1 +797,3 @@\n-        _f->do_oop(addr);\n+        if (_f != NULL) {\n+          _f->do_oop(addr);\n+        }\n@@ -947,1 +974,1 @@\n-  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f);\n+  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f, NULL);\n@@ -959,0 +986,17 @@\n+void frame::buffered_values_interpreted_do(BufferedValueClosure* f) {\n+  assert(is_interpreted_frame(), \"Not an interpreted frame\");\n+  Thread *thread = Thread::current();\n+  methodHandle m (thread, interpreter_frame_method());\n+  jint      bci = interpreter_frame_bci();\n+\n+  assert(m->is_method(), \"checking frame value\");\n+  assert(!m->is_native() && bci >= 0 && bci < m->code_size(),\n+         \"invalid bci value\");\n+\n+  InterpreterFrameClosure blk(this, m->max_locals(), m->max_stack(), NULL, f);\n+\n+  \/\/ process locals & expression stack\n+  InterpreterOopMap mask;\n+  m->mask_for(bci, &mask);\n+  mask.iterate_oop(&blk);\n+}\n@@ -1010,0 +1054,1 @@\n+    assert(_offset < _arg_size, \"out of bounds\");\n@@ -1036,5 +1081,1 @@\n-    _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);\n-\n-    int arg_size;\n-    _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &arg_size);\n-    assert(arg_size == _arg_size, \"wrong arg size\");\n+    _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &_arg_size);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":50,"deletions":9,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -437,0 +437,1 @@\n+  void buffered_values_interpreted_do(BufferedValueClosure* f);\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -794,0 +794,18 @@\n+  notproduct(bool, PrintInlineLayout, false,                                \\\n+          \"Print field layout for each inline type\")                        \\\n+                                                                            \\\n+  notproduct(bool, PrintFlatArrayLayout, false,                             \\\n+          \"Print array layout for each inline type array\")                  \\\n+                                                                            \\\n+  product(intx, FlatArrayElementMaxSize, -1,                                \\\n+          \"Max size for flattening inline array elements, <0 no limit\")     \\\n+                                                                            \\\n+  product(intx, InlineFieldMaxFlatSize, 128,                                \\\n+          \"Max size for flattening inline type fields, <0 no limit\")        \\\n+                                                                            \\\n+  product(intx, FlatArrayElementMaxOops, 4,                                 \\\n+          \"Max nof embedded object references in an inline type to flatten, <0 no limit\")  \\\n+                                                                            \\\n+  product(bool, InlineArrayAtomicAccess, false,                             \\\n+          \"Atomic inline array accesses by-default, for all inline arrays\") \\\n+                                                                            \\\n@@ -1975,0 +1993,23 @@\n+  product(bool, EnableValhalla, true,                                       \\\n+          \"Enable experimental Valhalla features\")                          \\\n+                                                                            \\\n+  product(bool, EnablePrimitiveClasses, false,                              \\\n+          \"Enable experimental Valhalla primitive classes\")                 \\\n+                                                                            \\\n+  product_pd(bool, InlineTypePassFieldsAsArgs,                              \\\n+          \"Pass each inline type field as an argument at calls\")            \\\n+                                                                            \\\n+  product_pd(bool, InlineTypeReturnedAsFields,                              \\\n+          \"Return fields instead of an inline type reference\")              \\\n+                                                                            \\\n+  develop(bool, StressInlineTypeReturnedAsFields, false,                    \\\n+          \"Stress return of fields instead of an inline type reference\")    \\\n+                                                                            \\\n+  product(bool, UseArrayMarkWordCheck, NOT_LP64(false) LP64_ONLY(true),     \\\n+          \"Use bits in the mark word to check for flat\/null-free arrays\")   \\\n+                                                                            \\\n+  product(ccstrlist, ForceNonTearable, \"\", DIAGNOSTIC,                      \\\n+          \"List of inline classes which are forced to be atomic \"           \\\n+          \"(whitespace and commas separate names, \"                         \\\n+          \"and leading and trailing stars '*' are wildcards)\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class InlineKlass;\n@@ -131,0 +132,1 @@\n+DEF_HANDLE(flatArray        , is_flatArray_noinline        )\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+  VMRegImpl::set_regName();       \/\/ need this before generate_stubs (for printing oop maps).\n@@ -133,1 +134,0 @@\n-  VMRegImpl::set_regName(); \/\/ need this before generate_stubs (for printing oop maps).\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -151,4 +152,4 @@\n-    case T_BOOLEAN: \/\/ fall through\n-    case T_CHAR   : \/\/ fall through\n-    case T_SHORT  : \/\/ fall through\n-    case T_INT    : \/\/ fall through\n+    case T_BOOLEAN  : \/\/ fall through\n+    case T_CHAR     : \/\/ fall through\n+    case T_SHORT    : \/\/ fall through\n+    case T_INT      : \/\/ fall through\n@@ -156,2 +157,3 @@\n-    case T_OBJECT : \/\/ fall through\n-    case T_ARRAY  : \/\/ fall through\n+    case T_OBJECT   : \/\/ fall through\n+    case T_ARRAY    : \/\/ fall through\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -159,5 +161,5 @@\n-    case T_BYTE   : \/\/ fall through\n-    case T_VOID   : return T_INT;\n-    case T_LONG   : return T_LONG;\n-    case T_FLOAT  : return T_FLOAT;\n-    case T_DOUBLE : return T_DOUBLE;\n+    case T_BYTE     : \/\/ fall through\n+    case T_VOID     : return T_INT;\n+    case T_LONG     : return T_LONG;\n+    case T_FLOAT    : return T_FLOAT;\n+    case T_DOUBLE   : return T_DOUBLE;\n@@ -165,2 +167,3 @@\n-    case T_ARRAY  : \/\/ fall through\n-    case T_OBJECT:  return T_OBJECT;\n+    case T_ARRAY    : \/\/ fall through\n+    case T_OBJECT   : return T_OBJECT;\n+    case T_PRIMITIVE_OBJECT: return T_PRIMITIVE_OBJECT;\n@@ -294,0 +297,13 @@\n+\n+  \/\/ Special case for factory methods\n+  if (EnableValhalla && !constructor_signature->is_void_method_signature()) {\n+    guarantee(klass->is_inline_klass(), \"inline classes must use factory methods\");\n+    JavaValue factory_result(T_OBJECT);\n+    JavaCalls::call_static(&factory_result, klass,\n+                           vmSymbols::inline_factory_name(),\n+                           constructor_signature, args, CHECK_NH);\n+    return Handle(THREAD, factory_result.get_oop());\n+  }\n+\n+  \/\/ main branch of code creates a non-inline object:\n+  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n@@ -395,0 +411,12 @@\n+  jobject value_buffer = NULL;\n+  if (InlineTypeReturnedAsFields && (result->get_type() == T_PRIMITIVE_OBJECT || result->get_type() == T_OBJECT)) {\n+    \/\/ Pre allocate a buffered inline type in case the result is returned\n+    \/\/ flattened by compiled code\n+    InlineKlass* vk = method->returns_inline_type(thread);\n+    if (vk != NULL && vk->can_be_returned_as_fields()) {\n+      oop instance = vk->allocate_instance(CHECK);\n+      value_buffer = JNIHandles::make_local(thread, instance);\n+      result->set_jobject(value_buffer);\n+    }\n+  }\n+\n@@ -445,0 +473,1 @@\n+    JNIHandles::destroy_local(value_buffer);\n@@ -581,0 +610,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -593,1 +623,1 @@\n-  if (is_reference_type(return_type)) return_type = T_OBJECT;\n+  if (return_type == T_ARRAY) return_type = T_OBJECT;\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":44,"deletions":14,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  oop           _return_buffered_value; \/\/ buffered value being returned\n@@ -700,0 +701,3 @@\n+  oop return_buffered_value() const              { return _return_buffered_value; }\n+  void set_return_buffered_value(oop val)        { _return_buffered_value = val; }\n+\n@@ -769,0 +773,1 @@\n+  static ByteSize return_buffered_value_offset() { return byte_offset_of(JavaThread, _return_buffered_value); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -291,0 +293,38 @@\n+bool JNIHandles::is_same_object(jobject handle1, jobject handle2) {\n+  oop obj1 = resolve_no_keepalive(handle1);\n+  oop obj2 = resolve_no_keepalive(handle2);\n+\n+  bool ret = obj1 == obj2;\n+\n+  if (EnableValhalla) {\n+    if (!ret && obj1 != NULL && obj2 != NULL && obj1->klass() == obj2->klass() && obj1->klass()->is_inline_klass()) {\n+      \/\/ The two references are different, they are not null and they are both inline types,\n+      \/\/ a full substitutability test is required, calling ValueObjectMethods.isSubstitutable()\n+      \/\/ (similarly to InterpreterRuntime::is_substitutable)\n+      JavaThread* THREAD = JavaThread::current();\n+      Handle ha(THREAD, obj1);\n+      Handle hb(THREAD, obj2);\n+      JavaValue result(T_BOOLEAN);\n+      JavaCallArguments args;\n+      args.push_oop(ha);\n+      args.push_oop(hb);\n+      methodHandle method(THREAD, Universe::is_substitutable_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        \/\/ Something really bad happened because isSubstitutable() should not throw exceptions\n+        \/\/ If it is an error, just let it propagate\n+        \/\/ If it is an exception, wrap it into an InternalError\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in substitutability test\", e, false);\n+        }\n+      }\n+      ret = result.get_jboolean();\n+    }\n+  }\n+\n+  return ret;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -55,0 +56,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -350,1 +352,5 @@\n-    return oopFactory::new_objArray(k, length, THREAD);\n+    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+      return oopFactory::new_valueArray(k, length, THREAD);\n+    } else {\n+      return oopFactory::new_objArray(k, length, THREAD);\n+    }\n@@ -391,1 +397,5 @@\n-  klass = klass->array_klass(dim, CHECK_NULL);\n+  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+    klass = InlineKlass::cast(klass)->value_array_klass(dim, CHECK_NULL);\n+  } else {\n+    klass = klass->array_klass(dim, CHECK_NULL);\n+  }\n@@ -768,3 +778,0 @@\n-  if (log_is_enabled(Debug, class, resolve)) {\n-    trace_class_resolution(nt);\n-  }\n@@ -776,2 +783,1 @@\n-  assert(!method()->is_initializer() ||\n-         (for_constant_pool_access && method()->is_static()),\n+  assert(!method()->name()->starts_with('<') || for_constant_pool_access,\n@@ -826,1 +832,3 @@\n-  assert(method()->is_initializer(), \"should call new_method instead\");\n+  assert(method()->is_object_constructor() ||\n+         method()->is_static_vnew_factory(),\n+         \"should call new_method instead\");\n@@ -879,1 +887,2 @@\n-  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n+  int modifiers = fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n+  java_lang_reflect_Field::set_modifiers(rh(), modifiers);\n@@ -994,2 +1003,4 @@\n-    \/\/ no need to resolve if method is private or <init>\n-    if (reflected_method->is_private() || reflected_method->name() == vmSymbols::object_initializer_name()) {\n+    \/\/ no need to resolve if method is private, <init> or <vnew>\n+    if (reflected_method->is_private() ||\n+        reflected_method->name() == vmSymbols::object_initializer_name() ||\n+        reflected_method->name() == vmSymbols::inline_factory_name()) {\n@@ -1150,0 +1161,2 @@\n+  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_inline_klass()) {\n+    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_PRIMITIVE_OBJECT;\n@@ -1177,1 +1190,0 @@\n-  assert(method->name() == vmSymbols::object_initializer_name(), \"invalid constructor\");\n@@ -1184,0 +1196,18 @@\n+\n+  \/\/ Special case for factory methods\n+  if (!method->signature()->is_void_method_signature()) {\n+    assert(klass->is_inline_klass(), \"inline classes must use factory methods\");\n+    assert(method->name() == vmSymbols::inline_factory_name(), \"wrong factory method name\");\n+    Handle no_receiver; \/\/ null instead of receiver\n+    BasicType rtype;\n+    if (klass->is_hidden()) {\n+      rtype = T_OBJECT;\n+    } else {\n+      rtype = T_PRIMITIVE_OBJECT;\n+    }\n+    return invoke(klass, method, no_receiver, override, ptypes, rtype, args, false, CHECK_NULL);\n+  }\n+\n+  \/\/ main branch of code creates a non-inline object:\n+  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n+  assert(method->name() == vmSymbols::object_initializer_name(), \"wrong constructor name\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -918,0 +919,1 @@\n+    ResourceMark rm;\n@@ -919,1 +921,2 @@\n-    bool return_oop = nm->method()->is_returning_oop();\n+    Method* method = nm->method();\n+    bool return_oop = method->is_returning_oop();\n@@ -921,1 +924,17 @@\n-    Handle return_value;\n+\n+    GrowableArray<Handle> return_values;\n+    InlineKlass* vk = NULL;\n+    if (return_oop && InlineTypeReturnedAsFields &&\n+        (method->result_type() == T_PRIMITIVE_OBJECT || method->result_type() == T_OBJECT)) {\n+      \/\/ Check if an inline type is returned as fields\n+      vk = InlineKlass::returned_inline_klass(map);\n+      if (vk != NULL) {\n+        \/\/ We're at a safepoint at the return of a method that returns\n+        \/\/ multiple values. We must make sure we preserve the oop values\n+        \/\/ across the safepoint.\n+        assert(vk == method->returns_inline_type(thread()), \"bad inline klass\");\n+        vk->save_oop_fields(map, return_values);\n+        return_oop = false;\n+      }\n+    }\n+\n@@ -928,1 +947,1 @@\n-      return_value = Handle(self, result);\n+      return_values.push(Handle(self, result));\n@@ -942,1 +961,4 @@\n-      caller_fr.set_saved_oop_result(&map, return_value());\n+      assert(return_values.length() == 1, \"only one return value\");\n+      caller_fr.set_saved_oop_result(&map, return_values.pop()());\n+    } else if (vk != NULL) {\n+      vk->restore_oop_results(map, return_values);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -49,0 +50,2 @@\n+#include \"oops\/access.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -53,0 +56,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -54,0 +58,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -89,1 +94,0 @@\n-address             SharedRuntime::_resolve_static_call_entry;\n@@ -110,1 +114,0 @@\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n@@ -1190,0 +1193,15 @@\n+  \/\/ Substitutability test implementation piggy backs on static call resolution\n+  Bytecodes::Code code = caller->java_code_at(bci);\n+  if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {\n+    bc = Bytecodes::_invokestatic;\n+    methodHandle attached_method(THREAD, extract_attached_method(vfst));\n+    assert(attached_method.not_null(), \"must have attached method\");\n+    vmClasses::ValueObjectMethods_klass()->initialize(CHECK_NH);\n+    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);\n+#ifdef ASSERT\n+    Method* is_subst = vmClasses::ValueObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    assert(callinfo.selected_method() == is_subst, \"must be isSubstitutable method\");\n+#endif\n+    return receiver;\n+  }\n+\n@@ -1225,0 +1243,6 @@\n+    } else {\n+      assert(attached_method->has_scalarized_args(), \"invalid use of attached method\");\n+      if (!attached_method->method_holder()->is_inline_klass()) {\n+        \/\/ Ignore the attached method in this case to not confuse below code\n+        attached_method = methodHandle(current, NULL);\n+      }\n@@ -1233,0 +1257,1 @@\n+  bool check_null_and_abstract = true;\n@@ -1245,0 +1270,5 @@\n+    bool caller_is_c1 = false;\n+\n+    if (callerFrame.is_compiled_frame()) {\n+      caller_is_c1 = callerFrame.cb()->is_compiled_by_c1();\n+    }\n@@ -1246,2 +1276,3 @@\n-    if (attached_method.is_null()) {\n-      Method* callee = bytecode.static_target(CHECK_NH);\n+    Method* callee = attached_method();\n+    if (callee == NULL) {\n+      callee = bytecode.static_target(CHECK_NH);\n@@ -1252,7 +1283,15 @@\n-\n-    \/\/ Retrieve from a compiled argument list\n-    receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n-    assert(oopDesc::is_oop_or_null(receiver()), \"\");\n-\n-    if (receiver.is_null()) {\n-      THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);\n+    if (!caller_is_c1 && callee->is_scalarized_arg(0)) {\n+      \/\/ If the receiver is an inline type that is passed as fields, no oop is available\n+      \/\/ Resolve the call without receiver null checking.\n+      assert(attached_method.not_null() && !attached_method->is_abstract(), \"must have non-abstract attached method\");\n+      if (bc == Bytecodes::_invokeinterface) {\n+        bc = Bytecodes::_invokevirtual; \/\/ C2 optimistically replaces interface calls by virtual calls\n+      }\n+      check_null_and_abstract = false;\n+    } else {\n+      \/\/ Retrieve from a compiled argument list\n+      receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n+      assert(oopDesc::is_oop_or_null(receiver()), \"\");\n+      if (receiver.is_null()) {\n+        THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);\n+      }\n@@ -1265,1 +1304,1 @@\n-    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);\n+    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);\n@@ -1274,1 +1313,1 @@\n-  if (has_receiver) {\n+  if (has_receiver && check_null_and_abstract) {\n@@ -1335,1 +1374,1 @@\n-methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, TRAPS) {\n+methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS) {\n@@ -1337,1 +1376,1 @@\n-  callee_method = resolve_sub_helper(is_virtual, is_optimized, THREAD);\n+  callee_method = resolve_sub_helper(is_virtual, is_optimized, caller_is_c1, THREAD);\n@@ -1354,1 +1393,1 @@\n-      callee_method = resolve_sub_helper(is_virtual, is_optimized, THREAD);\n+      callee_method = resolve_sub_helper(is_virtual, is_optimized, caller_is_c1, THREAD);\n@@ -1384,0 +1423,1 @@\n+  bool caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1386,1 +1426,8 @@\n-    assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, \"sanity check\");\n+    Klass* receiver_klass = NULL;\n+    if (!caller_is_c1 && callee_method->is_scalarized_arg(0)) {\n+      \/\/ If the receiver is an inline type that is passed as fields, no oop is available\n+      receiver_klass = callee_method->method_holder();\n+    } else {\n+      assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, \"sanity check\");\n+      receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();\n+    }\n@@ -1388,3 +1435,2 @@\n-    Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();\n-    CompiledIC::compute_monomorphic_entry(callee_method, klass,\n-                     is_optimized, static_bound, is_nmethod, virtual_call_info,\n+    CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,\n+                     is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,\n@@ -1394,1 +1440,1 @@\n-    CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);\n+    CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);\n@@ -1447,1 +1493,1 @@\n-methodHandle SharedRuntime::resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS) {\n+methodHandle SharedRuntime::resolve_sub_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS) {\n@@ -1459,0 +1505,1 @@\n+  *caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1557,0 +1604,2 @@\n+  bool is_optimized = false;\n+  bool caller_is_c1 = false;\n@@ -1558,1 +1607,1 @@\n-    callee_method = SharedRuntime::handle_ic_miss_helper(CHECK_NULL);\n+    callee_method = SharedRuntime::handle_ic_miss_helper(is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1563,2 +1612,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);\n@@ -1605,1 +1653,5 @@\n-      return callee->get_c2i_entry();\n+      if (caller_frame.is_interpreted_frame()) {\n+        return callee->get_c2i_inline_entry();\n+      } else {\n+        return callee->get_c2i_entry();\n+      }\n@@ -1611,0 +1663,3 @@\n+  bool is_static_call = false;\n+  bool is_optimized = false;\n+  bool caller_is_c1 = false;\n@@ -1613,1 +1668,1 @@\n-    callee_method = SharedRuntime::reresolve_call_site(CHECK_NULL);\n+    callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1617,2 +1672,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);\n@@ -1659,0 +1713,1 @@\n+  bool caller_is_c1;\n@@ -1661,1 +1716,1 @@\n-    callee_method = SharedRuntime::resolve_helper(false, false, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(false, false, &caller_is_c1, CHECK_NULL);\n@@ -1689,2 +1744,4 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  address entry = caller_is_c1 ?\n+    callee_method->verified_inline_code_entry() : callee_method->verified_code_entry();\n+  assert(entry != NULL, \"Jump to zero!\");\n+  return entry;\n@@ -1697,0 +1754,1 @@\n+  bool caller_is_c1;\n@@ -1698,1 +1756,1 @@\n-    callee_method = SharedRuntime::resolve_helper(true, false, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(true, false, &caller_is_c1, CHECK_NULL);\n@@ -1702,2 +1760,4 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  address entry = caller_is_c1 ?\n+    callee_method->verified_inline_code_entry() : callee_method->verified_inline_ro_code_entry();\n+  assert(entry != NULL, \"Jump to zero!\");\n+  return entry;\n@@ -1711,0 +1771,1 @@\n+  bool caller_is_c1;\n@@ -1712,1 +1773,1 @@\n-    callee_method = SharedRuntime::resolve_helper(true, true, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(true, true, &caller_is_c1, CHECK_NULL);\n@@ -1716,2 +1777,4 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+  address entry = caller_is_c1 ?\n+    callee_method->verified_inline_code_entry() : callee_method->verified_code_entry();\n+  assert(entry != NULL, \"Jump to zero!\");\n+  return entry;\n@@ -1728,1 +1791,1 @@\n-                                                   bool& needs_ic_stub_refill, TRAPS) {\n+                                                   bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS) {\n@@ -1739,0 +1802,1 @@\n+    is_optimized = true;\n@@ -1776,0 +1840,1 @@\n+                                            caller_nm->is_compiled_by_c1(),\n@@ -1784,1 +1849,1 @@\n-    bool successful = inline_cache->set_to_megamorphic(&call_info, bc, needs_ic_stub_refill, CHECK_false);\n+    bool successful = inline_cache->set_to_megamorphic(&call_info, bc, needs_ic_stub_refill, caller_is_c1, CHECK_false);\n@@ -1800,1 +1865,1 @@\n-methodHandle SharedRuntime::handle_ic_miss_helper(TRAPS) {\n+methodHandle SharedRuntime::handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1820,1 +1885,3 @@\n-    methodHandle callee_method = SharedRuntime::reresolve_call_site(CHECK_(methodHandle()));\n+    bool is_static_call = false;\n+    methodHandle callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));\n+    assert(!is_static_call, \"IC miss at static call?\");\n@@ -1879,0 +1946,1 @@\n+  caller_is_c1 = caller_nm->is_compiled_by_c1();\n@@ -1884,1 +1952,1 @@\n-                                                     bc, call_info, needs_ic_stub_refill, CHECK_(methodHandle()));\n+                                                     bc, call_info, needs_ic_stub_refill, is_optimized, caller_is_c1, CHECK_(methodHandle()));\n@@ -1916,1 +1984,1 @@\n-methodHandle SharedRuntime::reresolve_call_site(TRAPS) {\n+methodHandle SharedRuntime::reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1926,0 +1994,3 @@\n+  if (caller.is_compiled_frame()) {\n+    caller_is_c1 = caller.cb()->is_compiled_by_c1();\n+  }\n@@ -1936,1 +2007,0 @@\n-    bool is_static_call = false;\n@@ -1974,1 +2044,2 @@\n-        bool is_static_call = false;\n+        is_static_call = false;\n+        is_optimized = false;\n@@ -1981,0 +2052,1 @@\n+            is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);\n@@ -2006,1 +2078,0 @@\n-\n@@ -2179,1 +2250,1 @@\n-      address entry_point = callee->verified_entry_point();\n+      address entry_point = cb->is_compiled_by_c1() ? callee->verified_inline_entry_point() : callee->verified_entry_point();\n@@ -2509,1 +2580,1 @@\n-  static int adapter_encoding(BasicType in) {\n+  static BasicType adapter_encoding(BasicType in) {\n@@ -2515,1 +2586,1 @@\n-        \/\/ There are all promoted to T_INT in the calling convention\n+        \/\/ They are all promoted to T_INT in the calling convention\n@@ -2542,1 +2613,1 @@\n-  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n+  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n@@ -2545,0 +2616,1 @@\n+    int total_args_passed = (sig != NULL) ? sig->length() : 0;\n@@ -2562,0 +2634,2 @@\n+    BasicType prev_bt = T_ILLEGAL;\n+    int vt_count = 0;\n@@ -2564,4 +2638,27 @@\n-      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n-        int bt = adapter_encoding(sig_bt[sig_index++]);\n-        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt;\n+      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n+        BasicType bt = T_ILLEGAL;\n+        if (sig_index < total_args_passed) {\n+          bt = sig->at(sig_index++)._bt;\n+          if (bt == T_PRIMITIVE_OBJECT) {\n+            \/\/ Found start of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+            if (sig_index == 1 && has_ro_adapter) {\n+              \/\/ With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching\n+              \/\/ with other adapters that have the same inline type as first argument and no receiver.\n+              bt = T_VOID;\n+            }\n+            vt_count++;\n+          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+            \/\/ Found end of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+            vt_count--;\n+            assert(vt_count >= 0, \"invalid vt_count\");\n+          } else if (vt_count == 0) {\n+            \/\/ Widen fields that are not part of a scalarized inline type argument\n+            bt = adapter_encoding(bt);\n+          }\n+          prev_bt = bt;\n+        }\n+        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n+        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt_val;\n@@ -2571,0 +2668,1 @@\n+    assert(vt_count == 0, \"invalid vt_count\");\n@@ -2635,8 +2733,4 @@\n-        }\n-        switch (v) {\n-          case T_INT:    st.print(\"I\");    break;\n-          case T_LONG:   long_prev = true; break;\n-          case T_FLOAT:  st.print(\"F\");    break;\n-          case T_DOUBLE: st.print(\"D\");    break;\n-          case T_VOID:   break;\n-          default: ShouldNotReachHere();\n+        } else if (v == T_LONG) {\n+          long_prev = true;\n+        } else if (v != T_VOID){\n+          st.print(\"%c\", type2char((BasicType)v));\n@@ -2689,1 +2783,1 @@\n-static AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {\n+static AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n@@ -2692,1 +2786,1 @@\n-  AdapterFingerPrint fp(total_args_passed, sig_bt);\n+  AdapterFingerPrint fp(sig, has_ro_adapter);\n@@ -2726,1 +2820,1 @@\n-const int AdapterHandlerLibrary_size = 16*K;\n+const int AdapterHandlerLibrary_size = 48*K;\n@@ -2768,1 +2862,1 @@\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n@@ -2770,0 +2864,1 @@\n+                                                                wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n@@ -2771,4 +2866,8 @@\n-\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, NULL, true);\n-    BasicType obj_args[] = { T_OBJECT };\n-    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args, true);\n+    CompiledEntrySignature no_args;\n+    no_args.compute_calling_conventions();\n+    _no_arg_handler = create_adapter(no_arg_blob, no_args, true);\n+\n+    CompiledEntrySignature obj_args;\n+    SigEntry::add_entry(&obj_args.sig(), T_OBJECT, NULL);\n+    obj_args.compute_calling_conventions();\n+    _obj_arg_handler = create_adapter(obj_arg_blob, obj_args, true);\n@@ -2778,2 +2877,4 @@\n-    BasicType int_args[] = { T_INT };\n-    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args, true);\n+    CompiledEntrySignature int_args;\n+    SigEntry::add_entry(&int_args.sig(), T_INT, NULL);\n+    int_args.compute_calling_conventions();\n+    _int_arg_handler = create_adapter(int_arg_blob, int_args, true);\n@@ -2781,2 +2882,5 @@\n-    BasicType obj_int_args[] = { T_OBJECT, T_INT };\n-    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args, true);\n+    CompiledEntrySignature obj_int_args;\n+    SigEntry::add_entry(&obj_int_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(&obj_int_args.sig(), T_INT, NULL);\n+    obj_int_args.compute_calling_conventions();\n+    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, obj_int_args, true);\n@@ -2784,2 +2888,5 @@\n-    BasicType obj_obj_args[] = { T_OBJECT, T_OBJECT };\n-    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args, true);\n+    CompiledEntrySignature obj_obj_args;\n+    SigEntry::add_entry(&obj_obj_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(&obj_obj_args.sig(), T_OBJECT, NULL);\n+    obj_obj_args.compute_calling_conventions();\n+    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, obj_obj_args, true);\n@@ -2793,0 +2900,1 @@\n+  return;\n@@ -2805,0 +2913,2 @@\n+                                                      address c2i_inline_entry,\n+                                                      address c2i_inline_ro_entry,\n@@ -2806,0 +2916,1 @@\n+                                                      address c2i_unverified_inline_entry,\n@@ -2807,3 +2918,2 @@\n-  \/\/ Insert an entry into the table\n-  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n-                                 c2i_no_clinit_check_entry);\n+  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n+                              c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -2814,1 +2924,1 @@\n-    return _abstract_method_handler;\n+    return NULL;\n@@ -2821,0 +2931,3 @@\n+      if (InlineTypePassFieldsAsArgs && method->method_holder()->is_inline_klass()) {\n+        return NULL;\n+      }\n@@ -2824,1 +2937,10 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          InlineKlass* vk = ss.as_inline_klass(method->method_holder());\n+          if (vk != NULL) {\n+            return NULL;\n+          }\n+        }\n+        return _obj_arg_handler;\n+      }\n@@ -2835,1 +2957,1 @@\n-             !method->is_static()) {\n+             !method->is_static() && (!InlineTypePassFieldsAsArgs || !method->method_holder()->is_inline_klass())) {\n@@ -2837,1 +2959,10 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          InlineKlass* vk = ss.as_inline_klass(method->method_holder());\n+          if (vk != NULL) {\n+            return NULL;\n+          }\n+        }\n+        return _obj_obj_arg_handler;\n+      }\n@@ -2851,5 +2982,9 @@\n-class AdapterSignatureIterator : public SignatureIterator {\n- private:\n-  BasicType stack_sig_bt[16];\n-  BasicType* sig_bt;\n-  int index;\n+CompiledEntrySignature::CompiledEntrySignature(Method* method) :\n+  _method(method), _num_inline_args(0), _has_inline_recv(false),\n+  _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),\n+  _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),\n+  _c1_needs_stack_repair(false), _c2_needs_stack_repair(false) {\n+  _sig = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig_cc = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig_cc_ro = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+}\n@@ -2857,13 +2992,10 @@\n- public:\n-  AdapterSignatureIterator(Symbol* signature,\n-                           fingerprint_t fingerprint,\n-                           bool is_static,\n-                           int total_args_passed) :\n-    SignatureIterator(signature, fingerprint),\n-    index(0)\n-  {\n-    sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n-    if (!is_static) { \/\/ Pass in receiver first\n-      sig_bt[index++] = T_OBJECT;\n-    }\n-    do_parameters_on(this);\n+\/\/ See if we can save space by sharing the same entry for VIEP and VIEP(RO),\n+\/\/ or the same entry for VEP and VIEP(RO).\n+CodeOffsets::Entries CompiledEntrySignature::c1_inline_ro_entry_type() const {\n+  if (!has_scalarized_args()) {\n+    \/\/ VEP\/VIEP\/VIEP(RO) all share the same entry. There's no packing.\n+    return CodeOffsets::Verified_Entry;\n+  }\n+  if (_method->is_static()) {\n+    \/\/ Static methods don't need VIEP(RO)\n+    return CodeOffsets::Verified_Entry;\n@@ -2872,2 +3004,13 @@\n-  BasicType* basic_types() {\n-    return sig_bt;\n+  if (has_inline_recv()) {\n+    if (num_inline_args() == 1) {\n+      \/\/ Share same entry for VIEP and VIEP(RO).\n+      \/\/ This is quite common: we have an instance method in an InlineKlass that has\n+      \/\/ no inline type args other than <this>.\n+      return CodeOffsets::Verified_Inline_Entry;\n+    } else {\n+      assert(num_inline_args() > 1, \"must be\");\n+      \/\/ No sharing:\n+      \/\/   VIEP(RO) -- <this> is passed as object\n+      \/\/   VEP      -- <this> is passed as fields\n+      return CodeOffsets::Verified_Inline_Entry_RO;\n+    }\n@@ -2876,3 +3019,63 @@\n-#ifdef ASSERT\n-  int slots() {\n-    return index;\n+  \/\/ Either a static method, or <this> is not an inline type\n+  if (args_on_stack_cc() != args_on_stack_cc_ro()) {\n+    \/\/ No sharing:\n+    \/\/ Some arguments are passed on the stack, and we have inserted reserved entries\n+    \/\/ into the VEP, but we never insert reserved entries into the VIEP(RO).\n+    return CodeOffsets::Verified_Inline_Entry_RO;\n+  } else {\n+    \/\/ Share same entry for VEP and VIEP(RO).\n+    return CodeOffsets::Verified_Entry;\n+  }\n+}\n+\n+void CompiledEntrySignature::compute_calling_conventions(bool init) {\n+  \/\/ Iterate over arguments and compute scalarized and non-scalarized signatures\n+  bool has_scalarized = false;\n+  if (_method != NULL) {\n+    InstanceKlass* holder = _method->method_holder();\n+    int arg_num = 0;\n+    if (!_method->is_static()) {\n+      if (holder->is_inline_klass() && InlineKlass::cast(holder)->can_be_passed_as_fields() &&\n+          (init || _method->is_scalarized_arg(arg_num))) {\n+        _sig_cc->appendAll(InlineKlass::cast(holder)->extended_sig());\n+        has_scalarized = true;\n+        _has_inline_recv = true;\n+        _num_inline_args++;\n+      } else {\n+        SigEntry::add_entry(_sig_cc, T_OBJECT, holder->name());\n+      }\n+      SigEntry::add_entry(_sig, T_OBJECT, holder->name());\n+      SigEntry::add_entry(_sig_cc_ro, T_OBJECT, holder->name());\n+      arg_num++;\n+    }\n+    for (SignatureStream ss(_method->signature()); !ss.at_return_type(); ss.next()) {\n+      BasicType bt = ss.type();\n+      if (bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) {\n+        InlineKlass* vk = ss.as_inline_klass(holder);\n+        \/\/ TODO 8284443 Mismatch handling, we need to check parent method args (look at klassVtable::needs_new_vtable_entry)\n+        if (vk != NULL && vk->can_be_passed_as_fields() && (init || _method->is_scalarized_arg(arg_num))) {\n+          _num_inline_args++;\n+          has_scalarized = true;\n+          int last = _sig_cc->length();\n+          int last_ro = _sig_cc_ro->length();\n+          _sig_cc->appendAll(vk->extended_sig());\n+          _sig_cc_ro->appendAll(vk->extended_sig());\n+          if (bt == T_OBJECT) {\n+            \/\/ Nullable inline type argument, insert InlineTypeNode::IsInit field right after T_PRIMITIVE_OBJECT\n+            _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, NULL));\n+            _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, NULL));\n+          }\n+        } else {\n+          SigEntry::add_entry(_sig_cc, T_OBJECT, ss.as_symbol());\n+          SigEntry::add_entry(_sig_cc_ro, T_OBJECT, ss.as_symbol());\n+        }\n+        bt = T_OBJECT;\n+      } else {\n+        SigEntry::add_entry(_sig_cc, ss.type(), ss.as_symbol());\n+        SigEntry::add_entry(_sig_cc_ro, ss.type(), ss.as_symbol());\n+      }\n+      SigEntry::add_entry(_sig, bt, ss.as_symbol());\n+      if (bt != T_VOID) {\n+        arg_num++;\n+      }\n+    }\n@@ -2880,2 +3083,3 @@\n-#endif\n- private:\n+  \/\/ Compute the non-scalarized calling convention\n+  _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig->length());\n+  _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);\n@@ -2884,5 +3088,16 @@\n-  friend class SignatureIterator;  \/\/ so do_parameters_on can call do_type\n-  void do_type(BasicType type) {\n-    sig_bt[index++] = type;\n-    if (type == T_LONG || type == T_DOUBLE) {\n-      sig_bt[index++] = T_VOID; \/\/ Longs & doubles take 2 Java slots\n+  \/\/ Compute the scalarized calling conventions if there are scalarized inline types in the signature\n+  if (has_scalarized && !_method->is_native()) {\n+    _regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc->length());\n+    _args_on_stack_cc = SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);\n+\n+    _regs_cc_ro = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc_ro->length());\n+    _args_on_stack_cc_ro = SharedRuntime::java_calling_convention(_sig_cc_ro, _regs_cc_ro);\n+\n+    _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n+    _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n+\n+    \/\/ Upper bound on stack arguments to avoid hitting the argument limit and\n+    \/\/ bailing out of compilation (\"unsupported incoming calling sequence\").\n+    \/\/ TODO we need a reasonable limit (flag?) here\n+    if (MAX2(_args_on_stack_cc, _args_on_stack_cc_ro) <= 60) {\n+      return; \/\/ Success\n@@ -2891,1 +3106,10 @@\n-};\n+\n+  \/\/ No scalarized args\n+  _sig_cc = _sig;\n+  _regs_cc = _regs;\n+  _args_on_stack_cc = _args_on_stack;\n+\n+  _sig_cc_ro = _sig;\n+  _regs_cc_ro = _regs;\n+  _args_on_stack_cc_ro = _args_on_stack;\n+}\n@@ -2908,2 +3132,9 @@\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n+  CompiledEntrySignature ces(method());\n+  ces.compute_calling_conventions();\n+  if (ces.has_scalarized_args()) {\n+    method->set_has_scalarized_args(true);\n+    method->set_c1_needs_stack_repair(ces.c1_needs_stack_repair());\n+    method->set_c2_needs_stack_repair(ces.c2_needs_stack_repair());\n+  } else if (method->is_abstract()) {\n+    return _abstract_method_handler;\n+  }\n@@ -2911,4 +3142,0 @@\n-  AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(),\n-                              method->is_static(), total_args_passed);\n-  assert(si.slots() == total_args_passed, \"\");\n-  BasicType* sig_bt = si.basic_types();\n@@ -2918,0 +3145,13 @@\n+    if (ces.has_scalarized_args() && method->is_abstract()) {\n+      \/\/ Save a C heap allocated version of the signature for abstract methods with scalarized inline type arguments\n+      address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+      entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n+                                               StubRoutines::throw_AbstractMethodError_entry(),\n+                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                                               wrong_method_abstract, wrong_method_abstract);\n+      GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc_ro().length(), mtInternal);\n+      heap_sig->appendAll(&ces.sig_cc_ro());\n+      entry->set_sig_cc(heap_sig);\n+      return entry;\n+    }\n+\n@@ -2919,1 +3159,1 @@\n-    entry = lookup(total_args_passed, sig_bt);\n+    entry = lookup(&ces.sig_cc(), ces.has_inline_recv());\n@@ -2925,1 +3165,1 @@\n-        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, false);\n+        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, ces, false);\n@@ -2935,1 +3175,1 @@\n-    entry = create_adapter(new_adapter, total_args_passed, sig_bt, \/* allocate_code_blob *\/ true);\n+    entry = create_adapter(new_adapter, ces, \/* allocate_code_blob *\/ true);\n@@ -2946,2 +3186,1 @@\n-                                                           int total_args_passed,\n-                                                           BasicType* sig_bt,\n+                                                           CompiledEntrySignature& ces,\n@@ -2956,5 +3195,0 @@\n-  VMRegPair stack_regs[16];\n-  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n-\n-  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n-  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2968,1 +3202,1 @@\n-  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);\n+  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(&ces.sig_cc(), ces.has_inline_recv());\n@@ -2971,5 +3205,17 @@\n-                                                total_args_passed,\n-                                                comp_args_on_stack,\n-                                                sig_bt,\n-                                                regs,\n-                                                fingerprint);\n+                                                ces.args_on_stack(),\n+                                                &ces.sig(),\n+                                                ces.regs(),\n+                                                &ces.sig_cc(),\n+                                                ces.regs_cc(),\n+                                                &ces.sig_cc_ro(),\n+                                                ces.regs_cc_ro(),\n+                                                fingerprint,\n+                                                new_adapter,\n+                                                allocate_code_blob);\n+\n+  if (ces.has_scalarized_args()) {\n+    \/\/ Save a C heap allocated version of the scalarized signature and store it in the adapter\n+    GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc().length(), mtInternal);\n+    heap_sig->appendAll(&ces.sig_cc());\n+    entry->set_sig_cc(heap_sig);\n+  }\n@@ -2986,1 +3232,0 @@\n-  new_adapter = AdapterBlob::create(&buffer);\n@@ -3028,0 +3273,2 @@\n+  assert(base <= _c2i_inline_entry || _c2i_inline_entry == NULL, \"\");\n+  assert(base <= _c2i_inline_ro_entry || _c2i_inline_ro_entry == NULL, \"\");\n@@ -3029,0 +3276,1 @@\n+  assert(base <= _c2i_unverified_inline_entry || _c2i_unverified_inline_entry == NULL, \"\");\n@@ -3041,0 +3289,4 @@\n+  if (_c2i_inline_entry != NULL)\n+    _c2i_inline_entry += delta;\n+  if (_c2i_inline_ro_entry != NULL)\n+    _c2i_inline_ro_entry += delta;\n@@ -3043,0 +3295,2 @@\n+  if (_c2i_unverified_inline_entry != NULL)\n+    _c2i_unverified_inline_entry += delta;\n@@ -3051,0 +3305,3 @@\n+  if (_sig_cc != NULL) {\n+    delete _sig_cc;\n+  }\n@@ -3137,0 +3394,1 @@\n+      BasicType stack_sig_bt[16];\n@@ -3138,0 +3396,1 @@\n+      BasicType* sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n@@ -3140,5 +3399,13 @@\n-      AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(),\n-                              method->is_static(), total_args_passed);\n-      BasicType* sig_bt = si.basic_types();\n-      assert(si.slots() == total_args_passed, \"\");\n-      BasicType ret_type = si.return_type();\n+      int i = 0;\n+      if (!method->is_static()) {  \/\/ Pass in receiver first\n+        sig_bt[i++] = T_OBJECT;\n+      }\n+      SignatureStream ss(method->signature());\n+      for (; !ss.at_return_type(); ss.next()) {\n+        sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+        if (ss.type() == T_LONG || ss.type() == T_DOUBLE) {\n+          sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+        }\n+      }\n+      assert(i == total_args_passed, \"\");\n+      BasicType ret_type = ss.type();\n@@ -3381,0 +3648,9 @@\n+  if (get_c2i_entry() != NULL) {\n+    st->print(\" c2iVE: \" INTPTR_FORMAT, p2i(get_c2i_inline_entry()));\n+  }\n+  if (get_c2i_entry() != NULL) {\n+    st->print(\" c2iVROE: \" INTPTR_FORMAT, p2i(get_c2i_inline_ro_entry()));\n+  }\n+  if (get_c2i_unverified_entry() != NULL) {\n+    st->print(\" c2iUE: \" INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));\n+  }\n@@ -3382,1 +3658,1 @@\n-    st->print(\" c2iUV: \" INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));\n+    st->print(\" c2iUVE: \" INTPTR_FORMAT, p2i(get_c2i_unverified_inline_entry()));\n@@ -3471,0 +3747,196 @@\n+\n+\/\/ We are at a compiled code to interpreter call. We need backing\n+\/\/ buffers for all inline type arguments. Allocate an object array to\n+\/\/ hold them (convenient because once we're done with it we don't have\n+\/\/ to worry about freeing it).\n+oop SharedRuntime::allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS) {\n+  assert(InlineTypePassFieldsAsArgs, \"no reason to call this\");\n+  ResourceMark rm;\n+\n+  int nb_slots = 0;\n+  InstanceKlass* holder = callee->method_holder();\n+  allocate_receiver &= !callee->is_static() && holder->is_inline_klass() && callee->is_scalarized_arg(0);\n+  if (allocate_receiver) {\n+    nb_slots++;\n+  }\n+  int arg_num = callee->is_static() ? 0 : 1;\n+  for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {\n+    BasicType bt = ss.type();\n+    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+      nb_slots++;\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n+  }\n+  objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);\n+  objArrayHandle array(THREAD, array_oop);\n+  arg_num = callee->is_static() ? 0 : 1;\n+  int i = 0;\n+  if (allocate_receiver) {\n+    InlineKlass* vk = InlineKlass::cast(holder);\n+    oop res = vk->allocate_instance(CHECK_NULL);\n+    array->obj_at_put(i++, res);\n+  }\n+  for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {\n+    BasicType bt = ss.type();\n+    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+      InlineKlass* vk = ss.as_inline_klass(holder);\n+      assert(vk != NULL, \"Unexpected klass\");\n+      oop res = vk->allocate_instance(CHECK_NULL);\n+      array->obj_at_put(i++, res);\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n+  }\n+  return array();\n+}\n+\n+JRT_ENTRY(void, SharedRuntime::allocate_inline_types(JavaThread* current, Method* callee_method, bool allocate_receiver))\n+  methodHandle callee(current, callee_method);\n+  oop array = SharedRuntime::allocate_inline_types_impl(current, callee, allocate_receiver, CHECK);\n+  current->set_vm_result(array);\n+  current->set_vm_result_2(callee()); \/\/ TODO: required to keep callee live?\n+JRT_END\n+\n+\/\/ We're returning from an interpreted method: load each field into a\n+\/\/ register following the calling convention\n+JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res))\n+{\n+  assert(res->klass()->is_inline_klass(), \"only inline types here\");\n+  ResourceMark rm;\n+  RegisterMap reg_map(current,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame stubFrame = current->last_frame();\n+  frame callerFrame = stubFrame.sender(&reg_map);\n+  assert(callerFrame.is_interpreted_frame(), \"should be coming from interpreter\");\n+\n+  InlineKlass* vk = InlineKlass::cast(res->klass());\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  if (regs == NULL) {\n+    \/\/ The fields of the inline klass don't fit in registers, bail out\n+    return;\n+  }\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    address loc = reg_map.location(pair.first(), nullptr);\n+    switch(bt) {\n+    case T_BOOLEAN:\n+      *(jboolean*)loc = res->bool_field(off);\n+      break;\n+    case T_CHAR:\n+      *(jchar*)loc = res->char_field(off);\n+      break;\n+    case T_BYTE:\n+      *(jbyte*)loc = res->byte_field(off);\n+      break;\n+    case T_SHORT:\n+      *(jshort*)loc = res->short_field(off);\n+      break;\n+    case T_INT: {\n+      *(jint*)loc = res->int_field(off);\n+      break;\n+    }\n+    case T_LONG:\n+#ifdef _LP64\n+      *(intptr_t*)loc = res->long_field(off);\n+#else\n+      Unimplemented();\n+#endif\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY: {\n+      *(oop*)loc = res->obj_field(off);\n+      break;\n+    }\n+    case T_FLOAT:\n+      *(jfloat*)loc = res->float_field(off);\n+      break;\n+    case T_DOUBLE:\n+      *(jdouble*)loc = res->double_field(off);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+#ifdef ASSERT\n+  VMRegPair pair = regs->at(0);\n+  address loc = reg_map.location(pair.first(), nullptr);\n+  assert(*(oopDesc**)loc == res, \"overwritten object\");\n+#endif\n+\n+  current->set_vm_result(res);\n+}\n+JRT_END\n+\n+\/\/ We've returned to an interpreted method, the interpreter needs a\n+\/\/ reference to an inline type instance. Allocate it and initialize it\n+\/\/ from field's values in registers.\n+JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* current, intptr_t res))\n+{\n+  ResourceMark rm;\n+  RegisterMap reg_map(current,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame stubFrame = current->last_frame();\n+  frame callerFrame = stubFrame.sender(&reg_map);\n+\n+#ifdef ASSERT\n+  InlineKlass* verif_vk = InlineKlass::returned_inline_klass(reg_map);\n+#endif\n+\n+  if (!is_set_nth_bit(res, 0)) {\n+    \/\/ We're not returning with inline type fields in registers (the\n+    \/\/ calling convention didn't allow it for this inline klass)\n+    assert(!Metaspace::contains((void*)res), \"should be oop or pointer in buffer area\");\n+    current->set_vm_result((oopDesc*)res);\n+    assert(verif_vk == NULL, \"broken calling convention\");\n+    return;\n+  }\n+\n+  clear_nth_bit(res, 0);\n+  InlineKlass* vk = (InlineKlass*)res;\n+  assert(verif_vk == vk, \"broken calling convention\");\n+  assert(Metaspace::contains((void*)res), \"should be klass\");\n+\n+  \/\/ Allocate handles for every oop field so they are safe in case of\n+  \/\/ a safepoint when allocating\n+  GrowableArray<Handle> handles;\n+  vk->save_oop_fields(reg_map, handles);\n+\n+  \/\/ It's unsafe to safepoint until we are here\n+  JRT_BLOCK;\n+  {\n+    JavaThread* THREAD = current;\n+    oop vt = vk->realloc_result(reg_map, handles, CHECK);\n+    current->set_vm_result(vt);\n+  }\n+  JRT_BLOCK_END;\n+}\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":616,"deletions":144,"binary":false,"changes":760,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"asm\/codeBuffer.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -38,0 +40,1 @@\n+class SigEntry;\n@@ -52,1 +55,1 @@\n-  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS);\n+  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS);\n@@ -62,1 +65,0 @@\n-  static address             _resolve_static_call_entry;\n@@ -85,1 +87,0 @@\n-\n@@ -322,1 +323,1 @@\n-  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS);\n@@ -330,1 +331,1 @@\n-                                             bool& needs_ic_stub_refill, TRAPS);\n+                                             bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS);\n@@ -336,1 +337,1 @@\n-  static methodHandle reresolve_call_site(TRAPS);\n+  static methodHandle reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -340,1 +341,1 @@\n-  static methodHandle handle_ic_miss_helper(TRAPS);\n+  static methodHandle handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -349,0 +350,13 @@\n+  static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {\n+    assert(callee_method->verified_code_entry() != NULL, \"Jump to zero!\");\n+    assert(callee_method->verified_inline_code_entry() != NULL, \"Jump to zero!\");\n+    assert(callee_method->verified_inline_ro_code_entry() != NULL, \"Jump to zero!\");\n+    if (caller_is_c1) {\n+      return callee_method->verified_inline_code_entry();\n+    } else if (is_static_call || is_optimized) {\n+      return callee_method->verified_code_entry();\n+    } else {\n+      return callee_method->verified_inline_ro_code_entry();\n+    }\n+  }\n+\n@@ -371,0 +385,8 @@\n+  static int java_calling_convention(const GrowableArray<SigEntry>* sig, VMRegPair* regs) {\n+    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig->length());\n+    int total_args_passed = SigEntry::fill_sig_bt(sig, sig_bt);\n+    return java_calling_convention(sig_bt, regs, total_args_passed);\n+  }\n+  static int java_return_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);\n+  static const uint java_return_convention_max_int;\n+  static const uint java_return_convention_max_float;\n@@ -418,6 +440,11 @@\n-  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *_masm,\n-                                                      int total_args_passed,\n-                                                      int max_arg,\n-                                                      const BasicType *sig_bt,\n-                                                      const VMRegPair *regs,\n-                                                      AdapterFingerPrint* fingerprint);\n+  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *masm,\n+                                                      int comp_args_on_stack,\n+                                                      const GrowableArray<SigEntry>* sig,\n+                                                      const VMRegPair* regs,\n+                                                      const GrowableArray<SigEntry>* sig_cc,\n+                                                      const VMRegPair* regs_cc,\n+                                                      const GrowableArray<SigEntry>* sig_cc_ro,\n+                                                      const VMRegPair* regs_cc_ro,\n+                                                      AdapterFingerPrint* fingerprint,\n+                                                      AdapterBlob*& new_adapter,\n+                                                      bool allocate_code_blob);\n@@ -426,2 +453,1 @@\n-                              int total_args_passed,\n-                              const BasicType *sig_bt,\n+                              const GrowableArray<SigEntry>* sig,\n@@ -501,0 +527,3 @@\n+  static void load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res);\n+  static void store_inline_type_fields_to_buf(JavaThread* current, intptr_t res);\n+\n@@ -511,0 +540,2 @@\n+  static void allocate_inline_types(JavaThread* current, Method* callee, bool allocate_receiver);\n+  static oop allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS);\n@@ -514,0 +545,1 @@\n+  static BufferedInlineTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);\n@@ -619,0 +651,2 @@\n+  address _c2i_inline_entry;\n+  address _c2i_inline_ro_entry;\n@@ -620,0 +654,1 @@\n+  address _c2i_unverified_inline_entry;\n@@ -622,0 +657,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  const GrowableArray<SigEntry>* _sig_cc;\n+\n@@ -630,1 +668,2 @@\n-                      address c2i_unverified_entry,\n+                      address c2i_inline_entry, address c2i_inline_ro_entry,\n+                      address c2i_unverified_entry, address c2i_unverified_inline_entry,\n@@ -635,0 +674,2 @@\n+    _c2i_inline_entry(c2i_inline_entry),\n+    _c2i_inline_ro_entry(c2i_inline_ro_entry),\n@@ -636,1 +677,3 @@\n-    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry)\n+    _c2i_unverified_inline_entry(c2i_unverified_inline_entry),\n+    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry),\n+    _sig_cc(NULL)\n@@ -645,4 +688,7 @@\n-  address get_i2c_entry()                  const { return _i2c_entry; }\n-  address get_c2i_entry()                  const { return _c2i_entry; }\n-  address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }\n-  address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }\n+  address get_i2c_entry()                   const { return _i2c_entry; }\n+  address get_c2i_entry()                   const { return _c2i_entry; }\n+  address get_c2i_inline_entry()            const { return _c2i_inline_entry; }\n+  address get_c2i_inline_ro_entry()         const { return _c2i_inline_ro_entry; }\n+  address get_c2i_unverified_entry()        const { return _c2i_unverified_entry; }\n+  address get_c2i_unverified_inline_entry() const { return _c2i_unverified_inline_entry; }\n+  address get_c2i_no_clinit_check_entry()   const { return _c2i_no_clinit_check_entry; }\n@@ -653,0 +699,4 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  void set_sig_cc(const GrowableArray<SigEntry>* sig)  { _sig_cc = sig; }\n+  const GrowableArray<SigEntry>* get_sig_cc()    const { return _sig_cc; }\n+\n@@ -665,0 +715,2 @@\n+class CompiledEntrySignature;\n+\n@@ -679,2 +731,1 @@\n-                                             int total_args_passed,\n-                                             BasicType* sig_bt,\n+                                             CompiledEntrySignature& ces,\n@@ -686,4 +737,2 @@\n-                                        address i2c_entry,\n-                                        address c2i_entry,\n-                                        address c2i_unverified_entry,\n-                                        address c2i_no_clinit_check_entry = NULL);\n+                                        address i2c_entry, address c2i_entry, address c2i_inline_entry, address c2i_inline_ro_entry,\n+                                        address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry = NULL);\n@@ -702,0 +751,55 @@\n+\/\/ Utility class for computing the calling convention of the 3 types\n+\/\/ of compiled method entries:\n+\/\/     Method::_from_compiled_entry               - sig_cc\n+\/\/     Method::_from_compiled_inline_ro_entry     - sig_cc_ro\n+\/\/     Method::_from_compiled_inline_entry        - sig\n+class CompiledEntrySignature : public StackObj {\n+  Method* _method;\n+  int  _num_inline_args;\n+  bool _has_inline_recv;\n+  GrowableArray<SigEntry> *_sig;\n+  GrowableArray<SigEntry> *_sig_cc;\n+  GrowableArray<SigEntry> *_sig_cc_ro;\n+  VMRegPair* _regs;\n+  VMRegPair* _regs_cc;\n+  VMRegPair* _regs_cc_ro;\n+\n+  int _args_on_stack;\n+  int _args_on_stack_cc;\n+  int _args_on_stack_cc_ro;\n+\n+  bool _c1_needs_stack_repair;\n+  bool _c2_needs_stack_repair;\n+\n+public:\n+  Method* method()                     const { return _method; }\n+\n+  \/\/ Used by Method::_from_compiled_inline_entry\n+  GrowableArray<SigEntry>& sig()       const { return *_sig; }\n+\n+  \/\/ Used by Method::_from_compiled_entry\n+  GrowableArray<SigEntry>& sig_cc()    const { return *_sig_cc; }\n+\n+  \/\/ Used by Method::_from_compiled_inline_ro_entry\n+  GrowableArray<SigEntry>& sig_cc_ro() const { return *_sig_cc_ro; }\n+\n+  VMRegPair* regs()                    const { return _regs; }\n+  VMRegPair* regs_cc()                 const { return _regs_cc; }\n+  VMRegPair* regs_cc_ro()              const { return _regs_cc_ro; }\n+\n+  int args_on_stack()                  const { return _args_on_stack; }\n+  int args_on_stack_cc()               const { return _args_on_stack_cc; }\n+  int args_on_stack_cc_ro()            const { return _args_on_stack_cc_ro; }\n+\n+  int  num_inline_args()               const { return _num_inline_args; }\n+  bool has_inline_recv()               const { return _has_inline_recv; }\n+\n+  bool has_scalarized_args()           const { return _sig != _sig_cc; }\n+  bool c1_needs_stack_repair()         const { return _c1_needs_stack_repair; }\n+  bool c2_needs_stack_repair()         const { return _c2_needs_stack_repair; }\n+  CodeOffsets::Entries c1_inline_ro_entry_type() const;\n+\n+  CompiledEntrySignature(Method* method = NULL);\n+  void compute_calling_conventions(bool init = true);\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":131,"deletions":27,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -52,1 +54,1 @@\n-\/\/ FieldType  = \"B\" | \"C\" | \"D\" | \"F\" | \"I\" | \"J\" | \"S\" | \"Z\" | \"L\" ClassName \";\" | \"[\" FieldType.\n+\/\/ FieldType  = \"B\" | \"C\" | \"D\" | \"F\" | \"I\" | \"J\" | \"S\" | \"Z\" | \"L\" ClassName \";\" | \"Q\" ValueClassName \";\" | \"[\" FieldType.\n@@ -250,0 +252,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -336,0 +339,1 @@\n+  case T_PRIMITIVE_OBJECT:\n@@ -420,0 +424,1 @@\n+  case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n@@ -501,0 +506,14 @@\n+InlineKlass* SignatureStream::as_inline_klass(InstanceKlass* holder) {\n+  ThreadInVMfromUnknown __tiv;\n+  JavaThread* THREAD = JavaThread::current();\n+  Handle class_loader(THREAD, holder->class_loader());\n+  Handle protection_domain(THREAD, holder->protection_domain());\n+  Klass* k = as_klass(class_loader, protection_domain, SignatureStream::CachedOrNull, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Should never throw\");\n+  if (k != NULL && k->is_inline_klass()) {\n+    return InlineKlass::cast(k);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n@@ -540,1 +559,2 @@\n-  return klass->java_mirror();\n+  return has_Q_descriptor() ? InlineKlass::cast(klass)->val_mirror()\n+                            : klass->java_mirror();\n@@ -579,1 +599,0 @@\n-\n@@ -599,1 +618,1 @@\n-bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {\n+bool SignatureVerifier::is_valid_method_signature(const Symbol* sig) {\n@@ -622,1 +641,1 @@\n-bool SignatureVerifier::is_valid_type_signature(Symbol* sig) {\n+bool SignatureVerifier::is_valid_type_signature(const Symbol* sig) {\n@@ -651,0 +670,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -669,0 +689,53 @@\n+\n+\/\/ Adds an argument to the signature\n+void SigEntry::add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* symbol, int offset) {\n+  sig->append(SigEntry(bt, offset, symbol));\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    sig->append(SigEntry(T_VOID, offset, symbol)); \/\/ Longs and doubles take two stack slots\n+  }\n+}\n+\n+\/\/ Returns true if the argument at index 'i' is not an inline type delimiter\n+bool SigEntry::skip_value_delimiters(const GrowableArray<SigEntry>* sig, int i) {\n+  return (sig->at(i)._bt != T_PRIMITIVE_OBJECT &&\n+          (sig->at(i)._bt != T_VOID || sig->at(i-1)._bt == T_LONG || sig->at(i-1)._bt == T_DOUBLE));\n+}\n+\n+\/\/ Fill basic type array from signature array\n+int SigEntry::fill_sig_bt(const GrowableArray<SigEntry>* sig, BasicType* sig_bt) {\n+  int count = 0;\n+  for (int i = 0; i < sig->length(); i++) {\n+    if (skip_value_delimiters(sig, i)) {\n+      sig_bt[count++] = sig->at(i)._bt;\n+    }\n+  }\n+  return count;\n+}\n+\n+\/\/ Create a temporary symbol from the signature array\n+TempNewSymbol SigEntry::create_symbol(const GrowableArray<SigEntry>* sig) {\n+  ResourceMark rm;\n+  int length = sig->length();\n+  char* sig_str = NEW_RESOURCE_ARRAY(char, 2*length + 3);\n+  int idx = 0;\n+  sig_str[idx++] = '(';\n+  for (int i = 0; i < length; i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT || bt == T_VOID) {\n+      \/\/ Ignore\n+    } else {\n+      if (bt == T_ARRAY) {\n+        bt = T_OBJECT; \/\/ We don't know the element type, treat as Object\n+      }\n+      sig_str[idx++] = type2char(bt);\n+      if (bt == T_OBJECT) {\n+        sig_str[idx++] = ';';\n+      }\n+    }\n+  }\n+  sig_str[idx++] = ')';\n+  \/\/ Add a dummy return type. It won't be used but SignatureStream needs it.\n+  sig_str[idx++] = 'V';\n+  sig_str[idx++] = '\\0';\n+  return SymbolTable::new_symbol(sig_str);\n+}\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":78,"deletions":5,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -119,1 +120,1 @@\n-    return (signature_char == JVM_SIGNATURE_CLASS);\n+    return (signature_char == JVM_SIGNATURE_CLASS) || (signature_char == JVM_SIGNATURE_PRIMITIVE_OBJECT);\n@@ -260,1 +261,2 @@\n-    case T_OBJECT:  type_name(\"jobject\" ); break;\n+    case T_OBJECT:\n+    case T_PRIMITIVE_OBJECT:  type_name(\"jobject\" ); break;\n@@ -409,0 +411,1 @@\n+    case T_PRIMITIVE_OBJECT:\n@@ -521,0 +524,4 @@\n+  bool has_Q_descriptor() const {\n+    return has_envelope() && (_signature->char_at(_begin) == JVM_SIGNATURE_PRIMITIVE_OBJECT);\n+  }\n+\n@@ -563,0 +570,1 @@\n+\n@@ -564,0 +572,1 @@\n+  InlineKlass* as_inline_klass(InstanceKlass* holder);\n@@ -567,0 +576,51 @@\n+class SigEntryFilter;\n+typedef GrowableArrayFilterIterator<SigEntry, SigEntryFilter> ExtendedSignature;\n+\n+\/\/ Used for adapter generation. One SigEntry is used per element of\n+\/\/ the signature of the method. Inline type arguments are treated\n+\/\/ specially. See comment for InlineKlass::collect_fields().\n+class SigEntry {\n+ public:\n+  BasicType _bt;\n+  int _offset;\n+  Symbol* _symbol;\n+\n+  SigEntry()\n+    : _bt(T_ILLEGAL), _offset(-1), _symbol(NULL) {}\n+\n+  SigEntry(BasicType bt, int offset, Symbol* symbol)\n+    : _bt(bt), _offset(offset), _symbol(symbol) {}\n+\n+  static int compare(SigEntry* e1, SigEntry* e2) {\n+    if (e1->_offset != e2->_offset) {\n+      return e1->_offset - e2->_offset;\n+    }\n+    assert((e1->_bt == T_LONG && (e2->_bt == T_LONG || e2->_bt == T_VOID)) ||\n+           (e1->_bt == T_DOUBLE && (e2->_bt == T_DOUBLE || e2->_bt == T_VOID)) ||\n+           e1->_bt == T_PRIMITIVE_OBJECT || e2->_bt == T_PRIMITIVE_OBJECT || e1->_bt == T_VOID || e2->_bt == T_VOID, \"bad bt\");\n+    if (e1->_bt == e2->_bt) {\n+      assert(e1->_bt == T_PRIMITIVE_OBJECT || e1->_bt == T_VOID, \"only ones with duplicate offsets\");\n+      return 0;\n+    }\n+    if (e1->_bt == T_VOID ||\n+        e2->_bt == T_PRIMITIVE_OBJECT) {\n+      return 1;\n+    }\n+    if (e1->_bt == T_PRIMITIVE_OBJECT ||\n+        e2->_bt == T_VOID) {\n+      return -1;\n+    }\n+    ShouldNotReachHere();\n+    return 0;\n+  }\n+  static void add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* symbol, int offset = -1);\n+  static bool skip_value_delimiters(const GrowableArray<SigEntry>* sig, int i);\n+  static int fill_sig_bt(const GrowableArray<SigEntry>* sig, BasicType* sig_bt);\n+  static TempNewSymbol create_symbol(const GrowableArray<SigEntry>* sig);\n+};\n+\n+class SigEntryFilter {\n+public:\n+  bool operator()(const SigEntry& entry) { return entry._bt != T_PRIMITIVE_OBJECT && entry._bt != T_VOID; }\n+};\n+\n@@ -632,1 +692,1 @@\n- #ifdef ASSERT\n+#ifdef ASSERT\n@@ -635,2 +695,2 @@\n-    static bool is_valid_method_signature(Symbol* sig);\n-    static bool is_valid_type_signature(Symbol* sig);\n+    static bool is_valid_method_signature(const Symbol* sig);\n+    static bool is_valid_type_signature(const Symbol* sig);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":65,"deletions":5,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -44,7 +44,0 @@\n-template StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMap* reg_map, ScopeValue* sv);\n-template StackValue* StackValue::create_stack_value(const frame* fr, const SmallRegisterMap* reg_map, ScopeValue* sv);\n-\n-template<typename RegisterMapT>\n-StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv) {\n-  return create_stack_value(sv, stack_value_address(fr, reg_map, sv), reg_map);\n-}\n@@ -127,0 +120,4 @@\n+\n+template StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMap* reg_map, ScopeValue* sv);\n+template StackValue* StackValue::create_stack_value(const frame* fr, const SmallRegisterMap* reg_map, ScopeValue* sv);\n+\n@@ -128,1 +125,2 @@\n-StackValue* StackValue::create_stack_value(ScopeValue* sv, address value_addr, const RegisterMapT* reg_map) {\n+StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv) {\n+  address value_addr = stack_value_address(fr, reg_map, sv);\n@@ -227,2 +225,9 @@\n-    Handle ov = ((ObjectValue *)sv)->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    ObjectValue* ov = ((ObjectValue *)sv);\n+    bool scalar_replaced = ov->value().is_null();\n+    if (ov->maybe_null()) {\n+      \/\/ Don't treat inline type as scalar replaced if it is null\n+      intptr_t is_init_value = StackValue::create_stack_value(fr, reg_map, ov->is_init())->get_int();\n+      jint is_init = (jint)*((jint*)&is_init_value);\n+      scalar_replaced &= (is_init != 0);\n+    }\n+    return new StackValue(ov->value(), scalar_replaced ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+address StubRoutines::_load_inline_type_fields_in_regs = NULL;\n+address StubRoutines::_store_inline_type_fields_to_buf = NULL;\n+\n@@ -504,0 +507,1 @@\n+  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,0 +259,3 @@\n+  static address _load_inline_type_fields_in_regs;\n+  static address _store_inline_type_fields_to_buf;\n+\n@@ -452,0 +455,3 @@\n+\n+  static address load_inline_type_fields_in_regs() { return _load_inline_type_fields_in_regs; }\n+  static address store_inline_type_fields_to_buf() { return _store_inline_type_fields_to_buf; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -286,0 +286,14 @@\n+#define CHECK_THROW_NOSYNC_IMSE(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;           \\\n+    ResourceMark rm(THREAD);                \\\n+    THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n+#define CHECK_THROW_NOSYNC_IMSE_0(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;             \\\n+    ResourceMark rm(THREAD);                  \\\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n@@ -312,0 +326,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -360,0 +375,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -479,0 +495,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -528,0 +545,4 @@\n+    if (EnableValhalla && mark.is_inline_type()) {\n+      return;\n+    }\n+    assert(!EnableValhalla || !object->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -591,0 +612,2 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n+\n@@ -601,0 +624,2 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n+\n@@ -621,0 +646,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -640,0 +666,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -678,0 +705,1 @@\n+  CHECK_THROW_NOSYNC_IMSE_0(obj);\n@@ -699,0 +727,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -714,0 +743,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -860,0 +890,4 @@\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+    \/\/ VM should be calling bootstrap method\n+    ShouldNotReachHere();\n+  }\n@@ -973,0 +1007,3 @@\n+  if (EnableValhalla && h_obj->mark().is_inline_type()) {\n+    return false;\n+  }\n@@ -1205,0 +1242,4 @@\n+  if (EnableValhalla) {\n+    guarantee(!object->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -476,0 +476,1 @@\n+    case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -511,0 +511,4 @@\n+\n+void VM_PrintClassLayout::doit() {\n+  PrintClassLayout::print_class_layout(_out, _class_name);\n+}\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -223,1 +225,1 @@\n-  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ObjArrayKlass*)                        \\\n+  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ArrayKlass*)                        \\\n@@ -1227,0 +1229,1 @@\n+           declare_type(FlatArrayKlass, ArrayKlass)                       \\\n@@ -1230,0 +1233,1 @@\n+        declare_type(InlineKlass, InstanceKlass)                          \\\n@@ -1603,0 +1607,1 @@\n+  declare_c2_type(MachVEPNode, MachIdealNode)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintClassLayoutDCmd>(full_export, true, false));\n@@ -145,1 +146,0 @@\n-\n@@ -934,1 +934,25 @@\n-#endif\n+\n+PrintClassLayoutDCmd::PrintClassLayoutDCmd(outputStream* output, bool heap) :\n+                                       DCmdWithParser(output, heap),\n+  _classname(\"classname\", \"Name of class whose layout should be printed. \",\n+             \"STRING\", true) {\n+  _dcmdparser.add_dcmd_argument(&_classname);\n+}\n+\n+void PrintClassLayoutDCmd::execute(DCmdSource source, TRAPS) {\n+  VM_PrintClassLayout printClassLayoutOp(output(), _classname.value());\n+  VMThread::execute(&printClassLayoutOp);\n+}\n+\n+int PrintClassLayoutDCmd::num_arguments() {\n+  ResourceMark rm;\n+  PrintClassLayoutDCmd* dcmd = new PrintClassLayoutDCmd(NULL, false);\n+  if (dcmd != NULL) {\n+    DCmdMark mark(dcmd);\n+    return dcmd->_dcmdparser.num_arguments();\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_SERVICES\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -312,0 +315,22 @@\n+ * HPROF_FLAT_ARRAYS        list of flat arrays\n+ *\n+ *               [flat array sub-records]*\n+ *\n+ *               HPROF_FLAT_ARRAY      flat array\n+ *\n+ *                          id         array object ID (dumped as HPROF_GC_PRIM_ARRAY_DUMP)\n+ *                          id         element class ID (dumped by HPROF_GC_CLASS_DUMP)\n+ *\n+ * HPROF_INLINED_FIELDS     decribes inlined fields\n+ *\n+ *               [class with inlined fields sub-records]*\n+ *\n+ *               HPROF_CLASS_WITH_INLINED_FIELDS\n+ *\n+ *                          id         class ID (dumped as HPROF_GC_CLASS_DUMP)\n+ *\n+ *                          u2         number of instance inlined fields (not including super)\n+ *                          [u2,       inlined field index,\n+ *                           u2,       synthetic field count,\n+ *                           id,       original field name,\n+ *                           id]*      inlined field class ID (dumped by HPROF_GC_CLASS_DUMP)\n@@ -349,0 +374,7 @@\n+  \/\/ inlined object support\n+  HPROF_FLAT_ARRAYS             = 0x12,\n+  HPROF_INLINED_FIELDS          = 0x13,\n+  \/\/ inlined object subrecords\n+  HPROF_FLAT_ARRAY                  = 0x01,\n+  HPROF_CLASS_WITH_INLINED_FIELDS   = 0x01,\n+\n@@ -383,0 +415,65 @@\n+\n+class AbstractDumpWriter;\n+\n+class InlinedObjects {\n+\n+  struct ClassInlinedFields {\n+    const Klass *klass;\n+    uintx base_index;   \/\/ base index of the inlined field names (1st field has index base_index+1).\n+    ClassInlinedFields(const Klass *klass = nullptr, uintx base_index = 0) : klass(klass), base_index(base_index) {}\n+\n+    \/\/ For GrowableArray::find_sorted().\n+    static int compare(const ClassInlinedFields& a, const ClassInlinedFields& b) {\n+      return a.klass - b.klass;\n+    }\n+    \/\/ For GrowableArray::sort().\n+    static int compare(ClassInlinedFields* a, ClassInlinedFields* b) {\n+      return compare(*a, *b);\n+    }\n+  };\n+\n+  uintx _min_string_id;\n+  uintx _max_string_id;\n+\n+  GrowableArray<ClassInlinedFields> *_inlined_field_map;\n+\n+  \/\/ counters for classes with inlined fields and for the fields\n+  int _classes_count;\n+  int _inlined_fields_count;\n+\n+  static InlinedObjects *_instance;\n+\n+  static void inlined_field_names_callback(InlinedObjects* _this, const Klass *klass, uintx base_index, int count);\n+\n+  GrowableArray<oop> *_flat_arrays;\n+\n+public:\n+  InlinedObjects()\n+    : _min_string_id(0), _max_string_id(0),\n+    _inlined_field_map(nullptr),\n+    _classes_count(0), _inlined_fields_count(0),\n+    _flat_arrays(nullptr) {\n+  }\n+\n+  static InlinedObjects* get_instance() {\n+    return _instance;\n+  }\n+\n+  void init();\n+  void release();\n+\n+  void dump_inlined_field_names(AbstractDumpWriter *writer);\n+\n+  uintx get_base_index_for(Klass* k);\n+  uintx get_next_string_id(uintx id);\n+\n+  void dump_classed_with_inlined_fields(AbstractDumpWriter* writer);\n+\n+  void add_flat_array(oop array);\n+  void dump_flat_arrays(AbstractDumpWriter* writer);\n+\n+};\n+\n+InlinedObjects *InlinedObjects::_instance = nullptr;\n+\n+\n@@ -901,2 +998,2 @@\n-  \/\/ returns the size of the instance of the given class\n-  static u4 instance_size(Klass* k);\n+  \/\/ calculates the total size of the all fields of the given class.\n+  static u4 instance_size(InstanceKlass* ik);\n@@ -914,2 +1011,8 @@\n-  \/\/ dump the raw values of the instance fields of the given object\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o);\n+  \/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+  \/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+  \/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass* klass);\n+  \/\/ dump the raw values of the instance fields of the given inlined object;\n+  \/\/ dump_instance_fields wrapper for inlined objects\n+  static void dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, InlineKlass* klass);\n+\n@@ -919,1 +1022,1 @@\n-  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* k, uintx *inlined_fields_index = nullptr);\n@@ -929,0 +1032,2 @@\n+  \/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+  static void dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array);\n@@ -936,0 +1041,3 @@\n+  \/\/ extended version to dump flat arrays as primitive arrays;\n+  \/\/ type_size specifies size of the inlined objects.\n+  static int calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size);\n@@ -949,0 +1057,10 @@\n+\n+  \/\/ helper methods for inlined fields.\n+  static bool is_inlined_field(const FieldStream& fld) {\n+    return fld.field_descriptor().is_inlined();\n+  }\n+  static InlineKlass* get_inlined_field_klass(const FieldStream &fld) {\n+    assert(is_inlined_field(fld), \"must be inlined field\");\n+    InstanceKlass* holder_klass = fld.field_descriptor().field_holder();\n+    return InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n+  }\n@@ -962,0 +1080,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: return HPROF_NORMAL_OBJECT; \/\/ not inlined Q-object, i.e. identity object.\n@@ -992,0 +1111,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n@@ -1030,0 +1150,1 @@\n+\n@@ -1034,0 +1155,1 @@\n+    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ not inlined Q-object, i.e. identity object.\n@@ -1094,3 +1216,2 @@\n-\/\/ returns the size of the instance of the given class\n-u4 DumperSupport::instance_size(Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ calculates the total size of the all fields of the given class.\n+u4 DumperSupport::instance_size(InstanceKlass *ik) {\n@@ -1101,1 +1222,5 @@\n-      size += sig2size(fld.signature());\n+      if (is_inlined_field(fld)) {\n+        size += instance_size(get_inlined_field_klass(fld));\n+      } else {\n+        size += sig2size(fld.signature());\n+      }\n@@ -1113,0 +1238,2 @@\n+      assert(!is_inlined_field(fldc), \"static fields cannot be inlined\");\n+\n@@ -1147,0 +1274,2 @@\n+      assert(!is_inlined_field(fld), \"static fields cannot be inlined\");\n+\n@@ -1175,5 +1304,5 @@\n-\/\/ dump the raw values of the instance fields of the given object\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o) {\n-  InstanceKlass* ik = InstanceKlass::cast(o->klass());\n-\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+\/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+\/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+\/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class.\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass *klass) {\n+  for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n@@ -1181,2 +1310,9 @@\n-      Symbol* sig = fld.signature();\n-      dump_field_value(writer, sig->char_at(0), o, fld.offset());\n+      if (is_inlined_field(fld)) {\n+        InlineKlass* field_klass = get_inlined_field_klass(fld);\n+        \/\/ the field is inlined, so all its fields are stored without headers.\n+        int fields_offset = offset + fld.offset() - field_klass->first_field_offset();\n+        dump_inlined_object_fields(writer, o, offset + fld.offset(), field_klass);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        dump_field_value(writer, sig->char_at(0), o, offset + fld.offset());\n+      }\n@@ -1187,1 +1323,6 @@\n-\/\/ dumps the definition of the instance fields for a given class\n+void DumperSupport::dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, InlineKlass* klass) {\n+  \/\/ the object is inlined, so all its fields are stored without headers.\n+  dump_instance_fields(writer, o, offset - klass->first_field_offset(), klass);\n+}\n+\n+\/\/ gets the count of the instance fields for a given class\n@@ -1192,1 +1333,8 @@\n-    if (!fldc.access_flags().is_static()) field_count++;\n+    if (!fldc.access_flags().is_static()) {\n+      if (is_inlined_field(fldc)) {\n+        \/\/ add \"synthetic\" fields for inlined fields.\n+        field_count += get_instance_fields_count(get_inlined_field_klass(fldc));\n+      } else {\n+        field_count++;\n+      }\n+    }\n@@ -1199,2 +1347,8 @@\n-void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ inlined_fields_id is not-NULL for inlined fields (to get synthetic field name IDs\n+\/\/ by using InlinedObjects::get_next_string_id()).\n+void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* ik, uintx* inlined_fields_id) {\n+  \/\/ inlined_fields_id != NULL means ik is a class of inlined field.\n+  \/\/ Inlined field id pointer for this class; lazyly initialized\n+  \/\/ if the class has inlined field(s) and the caller didn't provide inlined_fields_id.\n+  uintx *this_klass_inlined_fields_id = inlined_fields_id;\n+  uintx inlined_id = 0;\n@@ -1205,1 +1359,23 @@\n-      Symbol* sig = fld.signature();\n+      if (is_inlined_field(fld)) {\n+        \/\/ dump \"synthetic\" fields for inlined fields.\n+        if (this_klass_inlined_fields_id == nullptr) {\n+          inlined_id = InlinedObjects::get_instance()->get_base_index_for(ik);\n+          this_klass_inlined_fields_id = &inlined_id;\n+        }\n+        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld), this_klass_inlined_fields_id);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        Symbol* name = nullptr;\n+        \/\/ Use inlined_fields_id provided by caller.\n+        if (inlined_fields_id != nullptr) {\n+          uintx name_id = InlinedObjects::get_instance()->get_next_string_id(*inlined_fields_id);\n+\n+          \/\/ name_id == 0 is returned on error. use original field signature.\n+          if (name_id != 0) {\n+            *inlined_fields_id = name_id;\n+            name = reinterpret_cast<Symbol*>(name_id);\n+          }\n+        }\n+        if (name == nullptr) {\n+          name = fld.name();\n+        }\n@@ -1207,2 +1383,3 @@\n-      writer->write_symbolID(fld.name());   \/\/ name\n-      writer->write_u1(sig2tag(sig));       \/\/ type\n+        writer->write_symbolID(name);         \/\/ name\n+        writer->write_u1(sig2tag(sig));       \/\/ type\n+      }\n@@ -1230,1 +1407,1 @@\n-  dump_instance_fields(writer, o);\n+  dump_instance_fields(writer, o, 0, ik);\n@@ -1275,1 +1452,1 @@\n-  writer->write_u4(DumperSupport::instance_size(ik));\n+  writer->write_u4(HeapWordSize * ik->size_helper());\n@@ -1329,4 +1506,1 @@\n-int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n-  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n-  assert(type >= T_BOOLEAN && type <= T_OBJECT, \"invalid array element type\");\n-\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size) {\n@@ -1335,7 +1509,0 @@\n-  int type_size;\n-  if (type == T_OBJECT) {\n-    type_size = sizeof(address);\n-  } else {\n-    type_size = type2aelembytes(type);\n-  }\n-\n@@ -1349,0 +1516,1 @@\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n@@ -1355,0 +1523,13 @@\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n+  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+  int type_size;\n+  if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {  \/\/ TODO: FIXME\n+    type_size = sizeof(address);\n+  } else {\n+    type_size = type2aelembytes(type);\n+  }\n+\n+  return calculate_array_max_length(writer, array, type_size, header_size);\n+}\n+\n@@ -1386,0 +1567,40 @@\n+\/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+void DumperSupport::dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array) {\n+  FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* element_klass = array_klass->element_klass();\n+  int element_size = instance_size(element_klass);\n+  \/*                          id         array object ID\n+   *                          u4         stack trace serial number\n+   *                          u4         number of elements\n+   *                          u1         element type\n+   *\/\n+  short header_size = 1 + sizeof(address) + 2 * 4 + 1;\n+\n+  \/\/ TODO: use T_SHORT\/T_INT\/T_LONG if needed to avoid truncation\n+  BasicType type = T_BYTE;\n+  int type_size = type2aelembytes(type);\n+  int length = calculate_array_max_length(writer, array, element_size, header_size);\n+  u4 length_in_bytes = (u4)(length * element_size);\n+  u4 size = header_size + length_in_bytes;\n+\n+  writer->start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);\n+  writer->write_objectID(array);\n+  writer->write_u4(STACK_TRACE_ID);\n+  \/\/ TODO: round up array length for T_SHORT\/T_INT\/T_LONG\n+  writer->write_u4(length * element_size);\n+  writer->write_u1(type2tag(type));\n+\n+  for (int index = 0; index < length; index++) {\n+    \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n+    int offset = (int)((address)array->value_at_addr(index, array_klass->layout_helper())\n+                  - cast_from_oop<address>(array));\n+    dump_inlined_object_fields(writer, array, offset, element_klass);\n+  }\n+\n+  \/\/ TODO: write padding bytes for T_SHORT\/T_INT\/T_LONG\n+\n+  InlinedObjects::get_instance()->add_flat_array(array);\n+\n+  writer->end_sub_record();\n+}\n+\n@@ -1507,0 +1728,264 @@\n+class InlinedFieldNameDumper : public LockedClassesDo {\n+public:\n+  typedef void (*Callback)(InlinedObjects *owner, const Klass *klass, uintx base_index, int count);\n+\n+private:\n+  AbstractDumpWriter* _writer;\n+  InlinedObjects *_owner;\n+  Callback       _callback;\n+  uintx _index;\n+\n+  void dump_inlined_field_names(GrowableArray<Symbol*>* super_names, Symbol* field_name, InlineKlass* klass) {\n+    super_names->push(field_name);\n+    for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+        } else {\n+          \/\/ get next string ID.\n+          uintx next_index = _owner->get_next_string_id(_index);\n+          if (next_index == 0) {\n+            \/\/ something went wrong (overflow?)\n+            \/\/ stop generation; the rest of inlined objects will have original field names.\n+            return;\n+          }\n+          _index = next_index;\n+\n+          \/\/ Calculate length.\n+          int len = fld.name()->utf8_length();\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            len += (*it)->utf8_length() + 1;    \/\/ +1 for \".\".\n+          }\n+\n+          DumperSupport::write_header(_writer, HPROF_UTF8, oopSize + len);\n+          _writer->write_symbolID(reinterpret_cast<Symbol*>(_index));\n+          \/\/ Write the string value.\n+          \/\/ 1) super_names.\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            _writer->write_raw((*it)->bytes(), (*it)->utf8_length());\n+            _writer->write_u1('.');\n+          }\n+          \/\/ 2) field name.\n+          _writer->write_raw(fld.name()->bytes(), fld.name()->utf8_length());\n+        }\n+      }\n+    }\n+    super_names->pop();\n+  }\n+\n+  void dump_inlined_field_names(Symbol* field_name, InlineKlass* field_klass) {\n+    GrowableArray<Symbol*> super_names(4, mtServiceability);\n+    dump_inlined_field_names(&super_names, field_name, field_klass);\n+  }\n+\n+public:\n+  InlinedFieldNameDumper(AbstractDumpWriter* writer, InlinedObjects* owner, Callback callback)\n+    : _writer(writer), _owner(owner), _callback(callback), _index(0)  {\n+  }\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    uintx base_index = _index;\n+    int count = 0;\n+\n+    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+          count++;\n+        }\n+      }\n+    }\n+\n+    if (count != 0) {\n+      _callback(_owner, k, base_index, count);\n+    }\n+  }\n+};\n+\n+class InlinedFieldsDumper : public LockedClassesDo {\n+private:\n+  AbstractDumpWriter* _writer;\n+\n+public:\n+  InlinedFieldsDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    \/\/ We can be at a point where java mirror does not exist yet.\n+    \/\/ So we need to check that the class is at least loaded, to avoid crash from a null mirror.\n+    if (!ik->is_loaded()) {\n+      return;\n+    }\n+\n+    u2 inlined_count = 0;\n+    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld)) {\n+          inlined_count++;\n+        }\n+      }\n+    }\n+    if (inlined_count != 0) {\n+      _writer->write_u1(HPROF_CLASS_WITH_INLINED_FIELDS);\n+\n+      \/\/ class ID\n+      _writer->write_classID(ik);\n+      \/\/ number of inlined fields\n+      _writer->write_u2(inlined_count);\n+      u2 index = 0;\n+      for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+        if (!fld.access_flags().is_static()) {\n+          if (DumperSupport::is_inlined_field(fld)) {\n+            \/\/ inlined field index\n+            _writer->write_u2(index);\n+            \/\/ synthetic field count\n+            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld));\n+            _writer->write_u2(field_count);\n+            \/\/ original field name\n+            _writer->write_symbolID(fld.name());\n+            \/\/ inlined field class ID\n+            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld));\n+\n+            index += field_count;\n+          } else {\n+            index++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\n+void InlinedObjects::init() {\n+  _instance = this;\n+\n+  struct Closure : public SymbolClosure {\n+    uintx _min_id = max_uintx;\n+    uintx _max_id = 0;\n+    Closure() : _min_id(max_uintx), _max_id(0) {}\n+\n+    void do_symbol(Symbol** p) {\n+      uintx val = reinterpret_cast<uintx>(*p);\n+      if (val < _min_id) {\n+        _min_id = val;\n+      }\n+      if (val > _max_id) {\n+        _max_id = val;\n+      }\n+    }\n+  } closure;\n+\n+  SymbolTable::symbols_do(&closure);\n+\n+  _min_string_id = closure._min_id;\n+  _max_string_id = closure._max_id;\n+}\n+\n+void InlinedObjects::release() {\n+  _instance = nullptr;\n+\n+  if (_inlined_field_map != nullptr) {\n+    delete _inlined_field_map;\n+    _inlined_field_map = nullptr;\n+  }\n+  if (_flat_arrays != nullptr) {\n+    delete _flat_arrays;\n+    _flat_arrays = nullptr;\n+  }\n+}\n+\n+void InlinedObjects::inlined_field_names_callback(InlinedObjects* _this, const Klass* klass, uintx base_index, int count) {\n+  if (_this->_inlined_field_map == nullptr) {\n+    _this->_inlined_field_map = new (mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n+  }\n+  _this->_inlined_field_map->append(ClassInlinedFields(klass, base_index));\n+\n+  \/\/ counters for dumping classes with inlined fields\n+  _this->_classes_count++;\n+  _this->_inlined_fields_count += count;\n+}\n+\n+void InlinedObjects::dump_inlined_field_names(AbstractDumpWriter* writer) {\n+  InlinedFieldNameDumper nameDumper(writer, this, inlined_field_names_callback);\n+  ClassLoaderDataGraph::classes_do(&nameDumper);\n+\n+  if (_inlined_field_map != nullptr) {\n+    \/\/ prepare the map for  get_base_index_for().\n+    _inlined_field_map->sort(ClassInlinedFields::compare);\n+  }\n+}\n+\n+uintx InlinedObjects::get_base_index_for(Klass* k) {\n+  if (_inlined_field_map != nullptr) {\n+    bool found = false;\n+    int idx = _inlined_field_map->find_sorted<ClassInlinedFields, ClassInlinedFields::compare>(ClassInlinedFields(k, 0), found);\n+    if (found) {\n+        return _inlined_field_map->at(idx).base_index;\n+    }\n+  }\n+\n+  \/\/ return max_uintx, so get_next_string_id returns 0.\n+  return max_uintx;\n+}\n+\n+uintx InlinedObjects::get_next_string_id(uintx id) {\n+  if (++id == _min_string_id) {\n+    return _max_string_id + 1;\n+  }\n+  return id;\n+}\n+\n+void InlinedObjects::dump_classed_with_inlined_fields(AbstractDumpWriter* writer) {\n+  if (_classes_count != 0) {\n+    \/\/ Record for each class contains tag(u1), class ID and count(u2)\n+    \/\/ for each inlined field index(u2), synthetic fields count(u2), original field name and class ID\n+    int size = _classes_count * (1 + sizeof(address) + 2)\n+             + _inlined_fields_count * (2 + 2 + sizeof(address) + sizeof(address));\n+    DumperSupport::write_header(writer, HPROF_INLINED_FIELDS, (u4)size);\n+\n+    InlinedFieldsDumper dumper(writer);\n+    ClassLoaderDataGraph::classes_do(&dumper);\n+  }\n+}\n+\n+void InlinedObjects::add_flat_array(oop array) {\n+  if (_flat_arrays == nullptr) {\n+    _flat_arrays = new (mtServiceability) GrowableArray<oop>(100, mtServiceability);\n+  }\n+  _flat_arrays->append(array);\n+}\n+\n+void InlinedObjects::dump_flat_arrays(AbstractDumpWriter* writer) {\n+  if (_flat_arrays != nullptr) {\n+    \/\/ For each flat array the record contains tag (u1), object ID and class ID.\n+    int size = _flat_arrays->length() * (1 + sizeof(address) + sizeof(address));\n+\n+    DumperSupport::write_header(writer, HPROF_FLAT_ARRAYS, (u4)size);\n+    for (GrowableArrayIterator<oop> it = _flat_arrays->begin(); it != _flat_arrays->end(); ++it) {\n+      flatArrayOop array = flatArrayOop(*it);\n+      FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+      InlineKlass* element_klass = array_klass->element_klass();\n+      writer->write_u1(HPROF_FLAT_ARRAY);\n+      writer->write_objectID(array);\n+      writer->write_classID(element_klass);\n+    }\n+  }\n+}\n+\n+\n@@ -1729,0 +2214,2 @@\n+  } else if (o->is_flatArray()) {\n+    DumperSupport::dump_flat_array(writer(), flatArrayOop(o));\n@@ -1747,0 +2234,8 @@\n+  } else if (o->is_typeArray()) {\n+    flatArrayOop array = flatArrayOop(o);\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+    assert(type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+    int length = array->length();\n+    \/\/TODO: FIXME\n+    \/\/int type_size = type2aelembytes(type);\n+    \/\/size = (size_t)length * type_size;\n@@ -1819,0 +2314,5 @@\n+\n+  \/\/ Inlined object support.\n+  InlinedObjects          _inlined_objects;\n+  InlinedObjects* inlined_objects() { return &_inlined_objects; }\n+\n@@ -2231,0 +2731,7 @@\n+    \/\/ HPROF_UTF8 records for inlined field names.\n+    inlined_objects()->init();\n+    inlined_objects()->dump_inlined_field_names(writer());\n+\n+    \/\/ HPROF_INLINED_FIELDS\n+    inlined_objects()->dump_classed_with_inlined_fields(writer());\n+\n@@ -2309,0 +2816,3 @@\n+\n+  inlined_objects()->dump_flat_arrays(writer());\n+\n@@ -2311,0 +2821,2 @@\n+\n+  inlined_objects()->release();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":548,"deletions":36,"binary":false,"changes":584,"status":"modified"},{"patch":"@@ -639,0 +639,9 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Prototyping\n+\/\/ \"Code Missing Here\" macro, un-define when integrating back from prototyping stage and break\n+\/\/ compilation on purpose (i.e. \"forget me not\")\n+#define PROTOTYPE\n+#ifdef PROTOTYPE\n+#define CMH(m)\n+#endif\n+\n@@ -724,6 +733,7 @@\n-  T_VOID        = 14,\n-  T_ADDRESS     = 15,\n-  T_NARROWOOP   = 16,\n-  T_METADATA    = 17,\n-  T_NARROWKLASS = 18,\n-  T_CONFLICT    = 19, \/\/ for stack value type with conflicting contents\n+  T_PRIMITIVE_OBJECT = 14,\n+  T_VOID        = 15,\n+  T_ADDRESS     = 16,\n+  T_NARROWOOP   = 17,\n+  T_METADATA    = 18,\n+  T_NARROWKLASS = 19,\n+  T_CONFLICT    = 20, \/\/ for stack value type with conflicting contents\n@@ -744,0 +754,1 @@\n+    F(JVM_SIGNATURE_PRIMITIVE_OBJECT, T_PRIMITIVE_OBJECT, N) \\\n@@ -773,1 +784,1 @@\n-  return (t == T_OBJECT || t == T_ARRAY || (include_narrow_oop && t == T_NARROWOOP));\n+  return (t == T_OBJECT || t == T_ARRAY || t == T_PRIMITIVE_OBJECT || (include_narrow_oop && t == T_NARROWOOP));\n@@ -831,1 +842,2 @@\n-  T_VOID_size        = 0\n+  T_VOID_size        = 0,\n+  T_PRIMITIVE_OBJECT_size = 1\n@@ -861,0 +873,1 @@\n+  T_PRIMITIVE_OBJECT_aelem_bytes = 8,\n@@ -864,0 +877,1 @@\n+  T_PRIMITIVE_OBJECT_aelem_bytes = 4,\n@@ -956,1 +970,1 @@\n-  vtos = 9,             \/\/ tos not cached\n+  vtos = 9,             \/\/ tos not cached,\n@@ -973,1 +987,2 @@\n-    case T_ARRAY  : \/\/ fall through\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n+    case T_ARRAY  :   \/\/ fall through\n@@ -1285,0 +1300,6 @@\n+\/\/ TEMP!!!!\n+\/\/ This should be removed after LW2 arrays are implemented (JDK-8220790).\n+\/\/ It's an alias to (EnableValhalla && (FlatArrayElementMaxSize != 0)),\n+\/\/ which is actually not 100% correct, but works for the current set of C1\/C2\n+\/\/ implementation and test cases.\n+#define UseFlatArray (EnablePrimitiveClasses && (FlatArrayElementMaxSize != 0))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"oops\/array.hpp\"\n+#include \"oops\/oop.hpp\"\n@@ -460,0 +462,6 @@\n+  void appendAll(const Array<E>* l) {\n+    for (int i = 0; i < l->length(); i++) {\n+      this->at_put_grow(this->_len, l->at(i), E());\n+    }\n+  }\n+\n@@ -871,2 +879,2 @@\n-  GrowableArrayFilterIterator(const GrowableArrayIterator<E>& begin, UnaryPredicate filter_predicate) :\n-      _array(begin._array), _position(begin._position), _predicate(filter_predicate) {\n+  GrowableArrayFilterIterator(const GrowableArray<E>* array, UnaryPredicate filter_predicate) :\n+      _array(array), _position(0), _predicate(filter_predicate) {\n@@ -874,1 +882,1 @@\n-    while(_position != _array->length() && !_predicate(_array->at(_position))) {\n+    while(!at_end() && !_predicate(_array->at(_position))) {\n@@ -883,1 +891,1 @@\n-    } while(_position != _array->length() && !_predicate(_array->at(_position)));\n+    } while(!at_end() && !_predicate(_array->at(_position)));\n@@ -908,0 +916,4 @@\n+\n+  bool at_end() const {\n+    return _array == NULL || _position == _array->end()._position;\n+  }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -73,0 +74,215 @@\n+class StringMatcher {\n+ public:\n+  typedef int getc_function_t(const char* &source, const char* limit);\n+\n+ private:\n+  \/\/ These do not get properly inlined.\n+  \/\/ For full performance, this should be a template class\n+  \/\/ parameterized by two function arguments.\n+  getc_function_t* _pattern_getc;\n+  getc_function_t* _string_getc;\n+\n+ public:\n+  StringMatcher(getc_function_t pattern_getc,\n+                getc_function_t string_getc)\n+    : _pattern_getc(pattern_getc),\n+      _string_getc(string_getc)\n+  { }\n+\n+  enum {  \/\/ special results from _pattern_getc\n+    string_match_comma  = -0x100 + ',',\n+    string_match_star   = -0x100 + '*',\n+    string_match_eos    = -0x100 + '\\0'\n+  };\n+\n+ private:\n+  const char*\n+  skip_anchor_word(const char* match,\n+                   const char* match_end,\n+                   int anchor_length,\n+                   const char* pattern,\n+                   const char* pattern_end) {\n+    assert(pattern < pattern_end && anchor_length > 0, \"\");\n+    const char* begp = pattern;\n+    int ch1 = _pattern_getc(begp, pattern_end);\n+    \/\/ note that begp is now advanced over ch1\n+    assert(ch1 > 0, \"regular char only\");\n+    const char* matchp = match;\n+    const char* limitp = match_end - anchor_length;\n+    while (matchp <= limitp) {\n+      int mch = _string_getc(matchp, match_end);\n+      if (mch == ch1) {\n+        const char* patp = begp;\n+        const char* anchorp = matchp;\n+        while (patp < pattern_end) {\n+          char ch = _pattern_getc(patp, pattern_end);\n+          char mch = _string_getc(anchorp, match_end);\n+          if (mch != ch) {\n+            anchorp = NULL;\n+            break;\n+          }\n+        }\n+        if (anchorp != NULL) {\n+          return anchorp;  \/\/ Found a full copy of the anchor.\n+        }\n+        \/\/ That did not work, so restart the search for ch1.\n+      }\n+    }\n+    return NULL;\n+  }\n+\n+ public:\n+  bool string_match(const char* pattern,\n+                    const char* string) {\n+    return string_match(pattern, pattern + strlen(pattern),\n+                        string, string + strlen(string));\n+  }\n+  bool string_match(const char* pattern, const char* pattern_end,\n+                    const char* string, const char* string_end) {\n+    const char* patp = pattern;\n+    switch (_pattern_getc(patp, pattern_end)) {\n+    case string_match_eos:\n+      return false;  \/\/ Empty pattern is always false.\n+    case string_match_star:\n+      if (patp == pattern_end) {\n+        return true;   \/\/ Lone star pattern is always true.\n+      }\n+      break;\n+    }\n+    patp = pattern;  \/\/ Reset after lookahead.\n+    const char* matchp = string;  \/\/ NULL if failing\n+    for (;;) {\n+      int ch = _pattern_getc(patp, pattern_end);\n+      switch (ch) {\n+      case string_match_eos:\n+      case string_match_comma:\n+        \/\/ End of a list item; see if it's a match.\n+        if (matchp == string_end) {\n+          return true;\n+        }\n+        if (ch == string_match_comma) {\n+          \/\/ Get ready to match the next item.\n+          matchp = string;\n+          continue;\n+        }\n+        return false;  \/\/ End of all items.\n+\n+      case string_match_star:\n+        if (matchp != NULL) {\n+          \/\/ Wildcard:  Parse out following anchor word and look for it.\n+          const char* begp = patp;\n+          const char* endp = patp;\n+          int anchor_len = 0;\n+          for (;;) {\n+            \/\/ get as many following regular characters as possible\n+            endp = patp;\n+            ch = _pattern_getc(patp, pattern_end);\n+            if (ch <= 0) {\n+              break;\n+            }\n+            anchor_len += 1;\n+          }\n+          \/\/ Anchor word [begp..endp) does not contain ch, so back up.\n+          \/\/ Now do an eager match to the anchor word, and commit to it.\n+          patp = endp;\n+          if (ch == string_match_eos ||\n+              ch == string_match_comma) {\n+            \/\/ Anchor word is at end of pattern, so treat it as a fixed pattern.\n+            const char* limitp = string_end - anchor_len;\n+            matchp = limitp;\n+            patp = begp;\n+            \/\/ Resume normal scanning at the only possible match position.\n+            continue;\n+          }\n+          \/\/ Find a floating occurrence of the anchor and continue matching.\n+          \/\/ Note:  This is greedy; there is no backtrack here.  Good enough.\n+          matchp = skip_anchor_word(matchp, string_end, anchor_len, begp, endp);\n+        }\n+        continue;\n+      }\n+      \/\/ Normal character.\n+      if (matchp != NULL) {\n+        int mch = _string_getc(matchp, string_end);\n+        if (mch != ch) {\n+          matchp = NULL;\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Match a wildcarded class list to a proposed class name (in internal form).\n+\/\/ Commas or newlines separate multiple possible matches; stars are shell-style wildcards.\n+class ClassListMatcher : public StringMatcher {\n+ public:\n+  ClassListMatcher()\n+    : StringMatcher(pattern_list_getc, class_name_getc)\n+  { }\n+\n+ private:\n+  static int pattern_list_getc(const char* &pattern_ptr,\n+                               const char* pattern_end) {\n+    if (pattern_ptr == pattern_end) {\n+      return string_match_eos;\n+    }\n+    int ch = (unsigned char) *pattern_ptr++;\n+    switch (ch) {\n+    case ' ': case '\\t': case '\\n': case '\\r':\n+    case ',':\n+      \/\/ End of list item.\n+      for (;;) {\n+        switch (*pattern_ptr) {\n+        case ' ': case '\\t': case '\\n': case '\\r':\n+        case ',':\n+          pattern_ptr += 1;  \/\/ Collapse multiple commas or spaces.\n+          continue;\n+        }\n+        break;\n+      }\n+      return string_match_comma;\n+\n+    case '*':\n+      \/\/ Wildcard, matching any number of chars.\n+      while (*pattern_ptr == '*') {\n+        pattern_ptr += 1;  \/\/ Collapse multiple stars.\n+      }\n+      return string_match_star;\n+\n+    case '.':\n+      ch = '\/';   \/\/ Look for internal form of package separator\n+      break;\n+\n+    case '\\\\':\n+      \/\/ Superquote in pattern escapes * , whitespace, and itself.\n+      if (pattern_ptr < pattern_end) {\n+        ch = (unsigned char) *pattern_ptr++;\n+      }\n+      break;\n+    }\n+\n+    assert(ch > 0, \"regular char only\");\n+    return ch;\n+  }\n+\n+  static int class_name_getc(const char* &name_ptr,\n+                             const char* name_end) {\n+    if (name_ptr == name_end) {\n+      return string_match_eos;\n+    }\n+    int ch = (unsigned char) *name_ptr++;\n+    if (ch == '.') {\n+      ch = '\/';   \/\/ Normalize to internal form of package separator\n+    }\n+    return ch;  \/\/ plain character\n+  }\n+};\n+\n+bool StringUtils::class_list_match(const char* class_pattern_list,\n+                                   const char* class_name) {\n+  if (class_pattern_list == NULL || class_name == NULL || class_name[0] == '\\0')\n+    return false;\n+  ClassListMatcher clm;\n+  return clm.string_match(class_pattern_list, class_name);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":216,"deletions":0,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -131,0 +131,6 @@\n+ * Value classes implementing {@link Externalizable} cannot be serialized\n+ * or deserialized, the value object is immutable and the state cannot be restored.\n+ * Use {@link Serializable} {@code writeReplace} to delegate to another serializable\n+ * object such as a record.\n+ *\n+ * Value objects cannot be {@code java.io.Externalizable}.\n@@ -1448,0 +1454,3 @@\n+                if (desc.forClass().isValue())\n+                    throw new NotSerializableException(\"Externalizable not valid for value class \"\n+                            + desc.forClass().getName());\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import jdk.internal.misc.ValhallaFeatures;\n@@ -81,0 +82,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -203,3 +205,3 @@\n-    private static final int ANNOTATION= 0x00002000;\n-    private static final int ENUM      = 0x00004000;\n-    private static final int SYNTHETIC = 0x00001000;\n+    private static final int ANNOTATION = 0x00002000;\n+    private static final int ENUM       = 0x00004000;\n+    private static final int SYNTHETIC  = 0x00001000;\n@@ -237,2 +239,16 @@\n-        String kind = isInterface() ? \"interface \" : isPrimitive() ? \"\" : \"class \";\n-        return kind.concat(getName());\n+        String s = getName();\n+        if (isPrimitive()) {\n+            return s;\n+        }\n+        \/\/ Avoid invokedynamic based String concat, might be not available\n+        \/\/ Prepend type of class\n+        s = (isInterface() ? \"interface \" : \"class \").concat(s);\n+        if (isValue()) {\n+            \/\/ prepend value class type\n+            s = (isPrimitiveClass() ? \"primitive \" : \"value \").concat(s);\n+            if (isPrimitiveClass() && isPrimaryType()) {\n+                \/\/ Append .ref\n+                s = s.concat(\".ref\");\n+            }\n+        }\n+        return s;\n@@ -291,0 +307,2 @@\n+                \/\/ Modifier.toString() below mis-interprets SYNCHRONIZED, STRICT, and VOLATILE bits\n+                modifiers &= ~(Modifier.SYNCHRONIZED | Modifier.STRICT | Modifier.VOLATILE);\n@@ -299,0 +317,3 @@\n+                if (isValue()) {\n+                    sb.append(isPrimitiveClass() ? \"primitive \" : \"value \");\n+                }\n@@ -501,2 +522,2 @@\n-                                            ClassLoader loader,\n-                                            Class<?> caller)\n+                                    ClassLoader loader,\n+                                    Class<?> caller)\n@@ -591,0 +612,136 @@\n+    \/\/ set by VM if this class is an exotic type such as primitive class\n+    \/\/ otherwise, these two fields are null\n+    private transient Class<T> primaryType;\n+    private transient Class<T> secondaryType;\n+\n+    \/**\n+     * Returns {@code true} if this class is a primitive class.\n+     * <p>\n+     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n+     * representing the <em>primitive reference type<\/em> and a\n+     * {@linkplain #isPrimitiveValueType() secondary type} representing\n+     * the <em>primitive value type<\/em>.  The primitive reference type\n+     * and primitive value type can be obtained by calling the\n+     * {@link #asPrimaryType()} and {@link #asValueType} method\n+     * of a primitive class respectively.\n+     * <p>\n+     * A primitive class is a {@linkplain #isValue() value class}.\n+     *\n+     * @return {@code true} if this class is a primitive class, otherwise {@code false}\n+     * @see #isValue()\n+     * @see #asPrimaryType()\n+     * @see #asValueType()\n+     * @since Valhalla\n+     *\/\n+    \/* package *\/ boolean isPrimitiveClass() {\n+        return (this.getModifiers() & PrimitiveClass.PRIMITIVE_CLASS) != 0;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this {@code Class} object represents an identity\n+     * class or interface; otherwise {@code false}}\n+     *\n+     * If this {@code Class} object represents an array type, then this method\n+     * returns {@code true}.\n+     * If this {@code Class} object represents a primitive type, or {@code void},\n+     * then this method returns {@code false}.\n+     *\n+     * @since Valhalla\n+     *\/\n+    public native boolean isIdentity();\n+\n+    \/**\n+     * {@return {@code true} if this {@code Class} object represents a value\n+     * class or interface; otherwise {@code false}}\n+     *\n+     * If this {@code Class} object represents an array type, a primitive type, or\n+     * {@code void}, then this method returns {@code false}.\n+     *\n+     * @since Valhalla\n+     *\/\n+    public boolean isValue() {\n+        return (this.getModifiers() & Modifier.VALUE) != 0;\n+    }\n+\n+    \/**\n+     * Returns a {@code Class} object representing the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this {@code Class} object represents a primitive type or an array type,\n+     * then this method returns this class.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n+     * type of this primitive class.\n+     * <p>\n+     * Otherwise, this {@code Class} object represents a non-primitive class or interface\n+     * and this method returns this class.\n+     *\n+     * @return the {@code Class} representing the primary type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    @IntrinsicCandidate\n+    \/* package *\/ Class<?> asPrimaryType() {\n+        return isPrimitiveClass() ? primaryType : this;\n+    }\n+\n+    \/**\n+     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n+     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n+     *\n+     * @apiNote Alternatively, this method returns null if this class is not\n+     *          a primitive class rather than throwing UOE.\n+     *\n+     * @return the {@code Class} representing the {@linkplain #isPrimitiveValueType()\n+     * primitive value type} of this class if this class is a primitive class\n+     * @throws UnsupportedOperationException if this class or interface\n+     *         is not a primitive class\n+     * @since Valhalla\n+     *\/\n+    @IntrinsicCandidate\n+    \/* package *\/ Class<?> asValueType() {\n+        if (isPrimitiveClass())\n+            return secondaryType;\n+\n+        throw new UnsupportedOperationException(this.getName().concat(\" is not a primitive class\"));\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this {@code Class} object represents a primitive type or an array type,\n+     * then this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive}, then this method returns {@code true} if this {@code Class}\n+     * object represents a primitive reference type, or returns {@code false}\n+     * if this {@code Class} object represents a primitive value type.\n+     * <p>\n+     * If this {@code Class} object represents a non-primitive class or interface,\n+     * then this method returns {@code true}.\n+     *\n+     * @return {@code true} if this {@code Class} object represents\n+     * the primary type of this class or interface\n+     * @since Valhalla\n+     *\/\n+    \/* package *\/ boolean isPrimaryType() {\n+        if (isPrimitiveClass()) {\n+            return this == primaryType;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents\n+     * a {@linkplain #isPrimitiveClass() primitive} value type.\n+     *\n+     * @return {@code true} if this {@code Class} object represents\n+     * the value type of a primitive class\n+     * @since Valhalla\n+     *\/\n+    \/* package *\/ boolean isPrimitiveValueType() {\n+        return isPrimitiveClass() && this == secondaryType;\n+    }\n+\n@@ -1298,0 +1455,2 @@\n+     * The modifiers also include the Java Virtual Machine's constants for\n+     * {@code identity class} and {@code value class}.\n@@ -1332,1 +1491,1 @@\n-    \/**\n+   \/**\n@@ -1365,2 +1524,2 @@\n-                                            getClassAccessFlagsRaw() :\n-                                            getModifiers(),\n+                                            getClassAccessFlagsRaw() & (~0x800) :\n+                                            getModifiers() & (~0x800), \/\/ suppress unspecified bit\n@@ -1370,1 +1529,1 @@\n-    \/**\n+   \/**\n@@ -1380,1 +1539,0 @@\n-\n@@ -1386,1 +1544,0 @@\n-\n@@ -1527,1 +1684,1 @@\n-        boolean isConstructor() { return !isPartial() && \"<init>\".equals(name); }\n+        boolean isObjectConstructor() { return !isPartial() && \"<init>\".equals(name); }\n@@ -1529,1 +1686,5 @@\n-        boolean isMethod() { return !isPartial() && !isConstructor() && !\"<clinit>\".equals(name); }\n+        boolean isValueFactoryMethod() { return !isPartial() && \"<vnew>\".equals(name); }\n+\n+        boolean isMethod() { return !isPartial() && !isObjectConstructor()\n+                                        && !isValueFactoryMethod()\n+                                        && !\"<clinit>\".equals(name); }\n@@ -1588,1 +1749,1 @@\n-            if (!enclosingInfo.isConstructor())\n+            if (!enclosingInfo.isObjectConstructor() && !enclosingInfo.isValueFactoryMethod())\n@@ -1768,1 +1929,1 @@\n-                return cl.getName().concat(\"[]\".repeat(dimensions));\n+                return cl.getTypeName().concat(\"[]\".repeat(dimensions));\n@@ -1771,1 +1932,6 @@\n-        return getName();\n+        if (isPrimitiveClass()) {\n+            \/\/ TODO: null-default\n+            return isPrimaryType() ? getName().concat(\".ref\") : getName();\n+        } else {\n+            return getName();\n+        }\n@@ -3685,1 +3851,1 @@\n-        throw new NoSuchMethodException(methodToString(\"<init>\", parameterTypes));\n+        throw new NoSuchMethodException(methodToString(isValue() ? \"<vnew>\" : \"<init>\", parameterTypes));\n@@ -3990,0 +4156,3 @@\n+        if (isPrimitiveValueType() && obj == null)\n+            throw new NullPointerException(getName() + \" is a primitive value type\");\n+\n@@ -4285,1 +4454,1 @@\n-         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);\n+        return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);\n@@ -4500,1 +4669,3 @@\n-        } else if (isHidden()) {\n+        }\n+        char typeDesc = isPrimitiveValueType() ? 'Q' : 'L';\n+        if (isHidden()) {\n@@ -4504,1 +4675,1 @@\n-                    .append('L')\n+                    .append(typeDesc)\n@@ -4513,1 +4684,1 @@\n-                    .append('L')\n+                    .append(typeDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":194,"deletions":23,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -2658,0 +2658,18 @@\n+\n+            @Override\n+            public Class<?> asPrimaryType(Class<?> clazz) {\n+                return clazz.asPrimaryType();\n+            }\n+            public Class<?> asValueType(Class<?> clazz) {\n+                return clazz.asValueType();\n+            }\n+\n+            public boolean isPrimaryType(Class<?> clazz) {\n+                return clazz.isPrimaryType();\n+            }\n+            public boolean isPrimitiveValueType(Class<?> clazz) {\n+                return clazz.isPrimitiveValueType();\n+            }\n+            public boolean isPrimitiveClass(Class<?> clazz) {\n+                return clazz.isPrimitiveClass();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -80,1 +81,1 @@\n-            if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isConstructor())\n+            if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())\n@@ -82,1 +83,2 @@\n-            mtype = mtype.insertParameterTypes(0, refc);\n+            Class<?> receiverType = PrimitiveClass.isPrimitiveClass(refc) ? PrimitiveClass.asValueType(refc) : refc;\n+            mtype = mtype.insertParameterTypes(0, receiverType);\n@@ -130,1 +132,1 @@\n-        if (member.isConstructor())\n+        if (member.isObjectConstructor() && member.getMethodType().returnType() == void.class)\n@@ -135,1 +137,2 @@\n-        assert(ctor.isConstructor() && ctor.getName().equals(\"<init>\"));\n+        assert(ctor.isObjectConstructor() && !ctor.getDeclaringClass().isValue()) : ctor;\n+\n@@ -137,2 +140,2 @@\n-        ctor = ctor.asConstructor();\n-        assert(ctor.isConstructor() && ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;\n+        ctor = ctor.asObjectConstructor();\n+        assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;\n@@ -552,3 +555,3 @@\n-        private final Class<?> fieldType;\n-        private final Object   staticBase;\n-        private final long     staticOffset;\n+        final Class<?> fieldType;\n+        final Object staticBase;\n+        final long staticOffset;\n@@ -602,0 +605,10 @@\n+    @ForceInline\n+    \/*non-public*\/ static Class<?> fieldType(Object accessorObj) {\n+        return ((Accessor) accessorObj).fieldType;\n+    }\n+\n+    @ForceInline\n+    \/*non-public*\/ static Class<?> staticFieldType(Object accessorObj) {\n+        return ((StaticAccessor) accessorObj).fieldType;\n+    }\n+\n@@ -616,1 +629,1 @@\n-    \/\/ with an extra case added for checked references.\n+    \/\/ with an extra case added for checked references and value field access\n@@ -618,5 +631,6 @@\n-            FT_LAST_WRAPPER    = Wrapper.COUNT-1,\n-            FT_UNCHECKED_REF   = Wrapper.OBJECT.ordinal(),\n-            FT_CHECKED_REF     = FT_LAST_WRAPPER+1,\n-            FT_LIMIT           = FT_LAST_WRAPPER+2;\n-    private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {\n+            FT_LAST_WRAPPER     = Wrapper.COUNT-1,\n+            FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),\n+            FT_CHECKED_REF      = FT_LAST_WRAPPER+1,\n+            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flattened and non-flattened\n+            FT_LIMIT            = FT_LAST_WRAPPER+4;\n+    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {\n@@ -625,0 +639,1 @@\n+                + (isFlatValue ? 1 : 0)\n@@ -629,2 +644,2 @@\n-            = new LambdaForm[afIndex(AF_LIMIT, false, 0)];\n-    static int ftypeKind(Class<?> ftype) {\n+            = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];\n+    static int ftypeKind(Class<?> ftype, boolean isValue) {\n@@ -637,1 +652,2 @@\n-            return FT_CHECKED_REF;\n+            \/\/ null check for value type in addition to check cast\n+            return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;\n@@ -658,1 +674,1 @@\n-            preparedFieldLambdaForm(formOp, isVolatile, ftype);\n+            preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);\n@@ -663,1 +679,1 @@\n-        LambdaForm lform = preparedFieldLambdaForm(formOp, isVolatile, ftype);\n+        LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);\n@@ -670,3 +686,4 @@\n-    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, Class<?> ftype) {\n-        int ftypeKind = ftypeKind(ftype);\n-        int afIndex = afIndex(formOp, isVolatile, ftypeKind);\n+\n+    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class<?> ftype) {\n+        int ftypeKind = ftypeKind(ftype, isValue);\n+        int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);\n@@ -675,1 +692,1 @@\n-        lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind);\n+        lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);\n@@ -682,1 +699,1 @@\n-    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, Wrapper wrapper) {\n+    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {\n@@ -694,1 +711,1 @@\n-                    case OBJECT:  return GET_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n@@ -706,1 +723,1 @@\n-                    case OBJECT:  return GET_REFERENCE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;\n@@ -720,1 +737,1 @@\n-                    case OBJECT:  return PUT_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;\n@@ -732,1 +749,1 @@\n-                    case OBJECT:  return PUT_REFERENCE;\n+                    case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;\n@@ -739,1 +756,6 @@\n-    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {\n+    \/** invoked by GenerateJLIClassesHelper *\/\n+    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {\n+        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);\n+    }\n+\n+    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {\n@@ -743,1 +765,1 @@\n-        boolean needsCast = (ftypeKind == FT_CHECKED_REF);\n+        boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);\n@@ -746,1 +768,1 @@\n-        assert(ftypeKind(needsCast ? String.class : ft) == ftypeKind);\n+        assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);\n@@ -749,1 +771,1 @@\n-        Kind kind = getFieldKind(isGetter, isVolatile, fw);\n+        Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);\n@@ -752,4 +774,8 @@\n-        if (isGetter)\n-            linkerType = MethodType.methodType(ft, Object.class, long.class);\n-        else\n-            linkerType = MethodType.methodType(void.class, Object.class, long.class, ft);\n+        boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;\n+        if (isGetter) {\n+            linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)\n+                                 : MethodType.methodType(ft, Object.class, long.class);\n+        } else {\n+            linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)\n+                                     : MethodType.methodType(void.class, Object.class, long.class, ft);\n+        }\n@@ -786,0 +812,1 @@\n+        final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);\n@@ -796,1 +823,1 @@\n-        assert(outArgs.length == (isGetter ? 3 : 4));\n+        assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));\n@@ -805,0 +832,5 @@\n+        int x = 3;\n+        if (hasValueTypeArg) {\n+            outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])\n+                                                        : new Name(getFunction(NF_fieldType), names[DMH_THIS]);\n+        }\n@@ -806,1 +838,1 @@\n-            outArgs[3] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);\n+            outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);\n@@ -857,1 +889,3 @@\n-            NF_LIMIT = 12;\n+            NF_fieldType = 12,\n+            NF_staticFieldType = 13,\n+            NF_LIMIT = 14;\n@@ -872,0 +906,2 @@\n+    private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);\n+\n@@ -908,3 +944,7 @@\n-                            MemberName.getFactory().resolveOrFail(REF_invokeVirtual, member,\n-                                                                  DirectMethodHandle.class, LM_TRUSTED,\n-                                                                  NoSuchMethodException.class));\n+                        MemberName.getFactory().resolveOrFail(REF_invokeVirtual, member,\n+                                                              DirectMethodHandle.class, LM_TRUSTED,\n+                                                              NoSuchMethodException.class));\n+                case NF_fieldType:\n+                    return getNamedFunction(\"fieldType\", CLS_OBJ_TYPE);\n+                case NF_staticFieldType:\n+                    return getNamedFunction(\"staticFieldType\", CLS_OBJ_TYPE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":83,"deletions":43,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -1018,1 +1018,2 @@\n-        if (member.isConstructor())  return false;\n+        if (member.isObjectConstructor() || member.isStaticValueFactoryMethod())  return false;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -274,0 +274,4 @@\n+        GET_VALUE(\"getValue\"),\n+        PUT_VALUE(\"putValue\"),\n+        GET_VALUE_VOLATILE(\"getValueVolatile\"),\n+        PUT_VALUE_VOLATILE(\"putValueVolatile\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -99,1 +100,2 @@\n-     *  For a constructor, it is always {@code \"<init>\"}.\n+     *  For an identity object constructor, it is {@code \"<init>\"}.\n+     *  For a value class static factory method, it is {@code \"<vnew>\"}.\n@@ -189,2 +191,3 @@\n-        if (isConstructor() && getReferenceKind() == REF_newInvokeSpecial)\n-            return itype.changeReturnType(clazz);\n+        Class<?> c = PrimitiveClass.isPrimitiveClass(clazz) ? PrimitiveClass.asValueType(clazz) : clazz;\n+        if (isObjectConstructor() && getReferenceKind() == REF_newInvokeSpecial)\n+            return itype.changeReturnType(c);\n@@ -192,1 +195,1 @@\n-            return itype.insertParameterTypes(0, clazz);\n+            return itype.insertParameterTypes(0, c);\n@@ -255,1 +258,1 @@\n-        } else if (isConstructor()) {\n+        } else if (isObjectConstructor()) {\n@@ -395,0 +398,2 @@\n+        \/\/ all fields declared in a value type are effectively final\n+        assert(!clazz.isValue() || !isField() || Modifier.isFinal(flags));\n@@ -416,5 +421,6 @@\n-    static final int BRIDGE    = 0x00000040;\n-    static final int VARARGS   = 0x00000080;\n-    static final int SYNTHETIC = 0x00001000;\n-    static final int ANNOTATION= 0x00002000;\n-    static final int ENUM      = 0x00004000;\n+    static final int BRIDGE      = 0x00000040;\n+    static final int VARARGS     = 0x00000080;\n+    static final int SYNTHETIC   = 0x00001000;\n+    static final int ANNOTATION  = 0x00002000;\n+    static final int ENUM        = 0x00004000;\n+\n@@ -434,1 +440,14 @@\n-    static final String CONSTRUCTOR_NAME = \"<init>\";  \/\/ the ever-popular\n+    \/** Query whether this member is a flattened field *\/\n+    public boolean isFlattened() { return (flags & MN_FLATTENED) == MN_FLATTENED; }\n+\n+    \/** Query whether this member is a field of a primitive class. *\/\n+    public boolean isInlineableField()  {\n+        if (isField()) {\n+            Class<?> type = getFieldType();\n+            return PrimitiveClass.isPrimitiveValueType(type) || (type.isValue() && !PrimitiveClass.isPrimitiveClass(type));\n+        }\n+        return false;\n+    }\n+\n+    static final String CONSTRUCTOR_NAME = \"<init>\";\n+    static final String VALUE_FACTORY_NAME = \"<vnew>\";  \/\/ the ever-popular\n@@ -441,6 +460,6 @@\n-            IS_METHOD        = MN_IS_METHOD,        \/\/ method (not constructor)\n-            IS_CONSTRUCTOR   = MN_IS_CONSTRUCTOR,   \/\/ constructor\n-            IS_FIELD         = MN_IS_FIELD,         \/\/ field\n-            IS_TYPE          = MN_IS_TYPE,          \/\/ nested type\n-            CALLER_SENSITIVE = MN_CALLER_SENSITIVE, \/\/ @CallerSensitive annotation detected\n-            TRUSTED_FINAL    = MN_TRUSTED_FINAL;    \/\/ trusted final field\n+            IS_METHOD             = MN_IS_METHOD,              \/\/ method (not object constructor)\n+            IS_OBJECT_CONSTRUCTOR = MN_IS_OBJECT_CONSTRUCTOR,  \/\/ object constructor\n+            IS_FIELD              = MN_IS_FIELD,               \/\/ field\n+            IS_TYPE               = MN_IS_TYPE,                \/\/ nested type\n+            CALLER_SENSITIVE      = MN_CALLER_SENSITIVE,       \/\/ @CallerSensitive annotation detected\n+            TRUSTED_FINAL         = MN_TRUSTED_FINAL;    \/\/ trusted final field\n@@ -449,2 +468,2 @@\n-    static final int ALL_KINDS = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE;\n-    static final int IS_INVOCABLE = IS_METHOD | IS_CONSTRUCTOR;\n+    static final int ALL_KINDS = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE;\n+    static final int IS_INVOCABLE = IS_METHOD | IS_OBJECT_CONSTRUCTOR;\n@@ -461,2 +480,6 @@\n-    public boolean isConstructor() {\n-        return allFlagsSet(IS_CONSTRUCTOR);\n+    public boolean isObjectConstructor() {\n+        return allFlagsSet(IS_OBJECT_CONSTRUCTOR);\n+    }\n+    \/** Query whether this member is an object constructor or static <init> factory *\/\n+    public boolean isStaticValueFactoryMethod() {\n+        return VALUE_FACTORY_NAME.equals(name) && isMethod();\n@@ -464,0 +487,1 @@\n+\n@@ -587,1 +611,1 @@\n-    public MemberName asConstructor() {\n+    public MemberName asObjectConstructor() {\n@@ -623,3 +647,8 @@\n-        this.name = CONSTRUCTOR_NAME;\n-        if (this.type == null)\n-            this.type = new Object[] { void.class, ctor.getParameterTypes() };\n+        this.name = this.clazz.isValue() ? VALUE_FACTORY_NAME : CONSTRUCTOR_NAME;\n+        if (this.type == null) {\n+            Class<?> rtype = void.class;\n+            if (isStatic()) {  \/\/ a value class static factory, not a true constructor\n+                rtype = getDeclaringClass();\n+            }\n+            this.type = new Object[] { rtype, ctor.getParameterTypes() };\n+        }\n@@ -757,1 +786,2 @@\n-     *  It will be a constructor if and only if the name is {@code \"<init>\"}.\n+     *  It will be an object constructor if and only if the name is {@code \"<init>\"}.\n+     *  It will be a value class instance factory method if and only if the name is {@code \"<vnew>\"}.\n@@ -763,1 +793,1 @@\n-        int initFlags = (name != null && name.equals(CONSTRUCTOR_NAME) ? IS_CONSTRUCTOR : IS_METHOD);\n+        int initFlags = CONSTRUCTOR_NAME.equals(name) ? IS_OBJECT_CONSTRUCTOR : IS_METHOD;\n@@ -781,1 +811,1 @@\n-            kindFlags = IS_CONSTRUCTOR;\n+            kindFlags = IS_OBJECT_CONSTRUCTOR;\n@@ -899,1 +929,1 @@\n-        else if (isConstructor())\n+        else if (isObjectConstructor())\n@@ -912,1 +942,1 @@\n-        else if (isConstructor())\n+        else if (isObjectConstructor())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":60,"deletions":30,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -115,8 +115,9 @@\n-            MN_IS_METHOD           = 0x00010000, \/\/ method (not constructor)\n-            MN_IS_CONSTRUCTOR      = 0x00020000, \/\/ constructor\n-            MN_IS_FIELD            = 0x00040000, \/\/ field\n-            MN_IS_TYPE             = 0x00080000, \/\/ nested type\n-            MN_CALLER_SENSITIVE    = 0x00100000, \/\/ @CallerSensitive annotation detected\n-            MN_TRUSTED_FINAL       = 0x00200000, \/\/ trusted final field\n-            MN_REFERENCE_KIND_SHIFT = 24, \/\/ refKind\n-            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n+            MN_IS_METHOD             = 0x00010000, \/\/ method (not object constructor)\n+            MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ object constructor\n+            MN_IS_FIELD              = 0x00040000, \/\/ field\n+            MN_IS_TYPE               = 0x00080000, \/\/ nested type\n+            MN_CALLER_SENSITIVE      = 0x00100000, \/\/ @CallerSensitive annotation detected\n+            MN_TRUSTED_FINAL         = 0x00200000, \/\/ trusted final field\n+            MN_FLATTENED             = 0x00400000, \/\/ flattened field\n+            MN_REFERENCE_KIND_SHIFT  = 24, \/\/ refKind\n+            MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n@@ -124,2 +125,2 @@\n-            MN_SEARCH_SUPERCLASSES = 0x00100000,\n-            MN_SEARCH_INTERFACES   = 0x00200000;\n+            MN_SEARCH_SUPERCLASSES   = 0x00100000,\n+            MN_SEARCH_INTERFACES     = 0x00200000;\n@@ -179,1 +180,1 @@\n-    static boolean refKindIsConstructor(byte refKind) {\n+    static boolean refKindIsObjectConstructor(byte refKind) {\n@@ -607,1 +608,1 @@\n-            sb.append(getCharType(pt));\n+            sb.append(getCharErasedType(pt));\n@@ -609,1 +610,1 @@\n-        sb.append('_').append(getCharType(guardType.returnType()));\n+        sb.append('_').append(getCharErasedType(guardType.returnType()));\n@@ -612,1 +613,1 @@\n-    static char getCharType(Class<?> pt) {\n+    static char getCharErasedType(Class<?> pt) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -708,1 +709,1 @@\n-     * with special names ({@code \"<init>\"} and {@code \"<clinit>\"}).\n+     * with special names ({@code \"<init>\"}, {@code \"<vnew>\"} and {@code \"<clinit>\"}).\n@@ -1626,0 +1627,1 @@\n+            assert PrimitiveClass.isPrimaryType(lookupClass);\n@@ -2743,0 +2745,2 @@\n+         *\n+         *\n@@ -2758,0 +2762,3 @@\n+            if (type.returnType() != void.class) {\n+                throw new NoSuchMethodException(\"Constructors must have void return type: \" + refc.getName());\n+            }\n@@ -3444,1 +3451,1 @@\n-            assert(ctor.isConstructor());\n+            assert(ctor.isObjectConstructor() || ctor.isStaticValueFactoryMethod());\n@@ -3447,1 +3454,10 @@\n-            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+            Class<?> defc = c.getDeclaringClass();\n+            if (ctor.isObjectConstructor()) {\n+                assert(ctor.getMethodType().returnType() == void.class);\n+                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n+            } else {\n+                \/\/ static init factory is a static method\n+                assert(ctor.isMethod() && ctor.getMethodType().returnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n+                assert(!MethodHandleNatives.isCallerSensitive(ctor));  \/\/ must not be caller-sensitive\n+                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n+            }\n@@ -3692,1 +3708,1 @@\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial) {\n+            if (isIllegalMethodName(refKind, name)) {\n@@ -3695,0 +3711,1 @@\n+\n@@ -3714,0 +3731,12 @@\n+        \/*\n+         * \"<init>\" can only be invoked via invokespecial\n+         * \"<vnew>\" factory can only invoked via invokestatic\n+         *\/\n+        boolean isIllegalMethodName(byte refKind, String name) {\n+            if (name.startsWith(\"<\")) {\n+                return MemberName.VALUE_FACTORY_NAME.equals(name) ? refKind != REF_invokeStatic\n+                                                                  : refKind != REF_newInvokeSpecial;\n+            }\n+            return false;\n+        }\n+\n@@ -3716,2 +3745,3 @@\n-            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial)\n-                throw new NoSuchMethodException(\"illegal method name: \"+name);\n+            if (isIllegalMethodName(refKind, name)) {\n+                throw new NoSuchMethodException(\"illegal method name: \" + name + \" \" + refKind);\n+            }\n@@ -3821,1 +3851,1 @@\n-            if (!fullPrivilegeLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && PrimitiveClass.asPrimaryType(defc) != PrimitiveClass.asPrimaryType(refc)) {\n@@ -3829,1 +3859,1 @@\n-            if (m.isConstructor())\n+            if (m.isObjectConstructor())\n@@ -3904,1 +3934,1 @@\n-                               (defc == refc ||\n+                               (PrimitiveClass.asPrimaryType(defc) == PrimitiveClass.asPrimaryType(refc) ||\n@@ -3909,1 +3939,1 @@\n-                           (defc == refc ||\n+                           (PrimitiveClass.asPrimaryType(defc) == PrimitiveClass.asPrimaryType(refc) ||\n@@ -3986,1 +4016,0 @@\n-\n@@ -4130,1 +4159,1 @@\n-            assert(ctor.isConstructor());\n+            assert(ctor.isObjectConstructor());\n@@ -5036,1 +5065,1 @@\n-            if (value == null)\n+            if (!PrimitiveClass.isPrimitiveValueType(type) && value == null)\n@@ -5081,1 +5110,9 @@\n-        return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);\n+        if (type.isPrimitive()) {\n+            return zero(Wrapper.forPrimitiveType(type), type);\n+        } else if (PrimitiveClass.isPrimitiveValueType(type)) {\n+            \/\/ singleton default value\n+            Object value = UNSAFE.uninitializedDefaultValue(type);\n+            return identity(type).bindTo(value);\n+        } else {\n+            return zero(Wrapper.OBJECT, type);\n+        }\n@@ -5111,1 +5148,1 @@\n-        MethodType mtype = methodType(ptype, ptype);\n+        MethodType mtype = MethodType.methodType(ptype, ptype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":52,"deletions":15,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.Objects;\n+\n@@ -40,0 +42,4 @@\n+ * <p>\n+ * The referent must be an {@linkplain Objects#isIdentityObject(Object) identity object}.\n+ * Attempts to create a reference to a {@linkplain Objects#isValueObject value object}\n+ * results in an {@link IdentityException}.\n@@ -509,0 +515,3 @@\n+        if (referent != null) {\n+            Objects.requireIdentity(referent);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.PrimitiveClass;\n@@ -134,0 +135,1 @@\n+        assert PrimitiveClass.isPrimaryType(declaringClass);\n@@ -423,1 +425,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n@@ -429,1 +431,1 @@\n-        return \"method \" + getDeclaringClass().getTypeName() +\n+        return \"method \" + getDeclaringClassTypeName() +\n@@ -492,1 +494,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -552,0 +552,34 @@\n+\n+    \/**\n+     * {@return the primary class for a primitive class}\n+     *\n+     * @param klass a class\n+     *\/\n+    Class<?> asPrimaryType(Class<?> klass);\n+\n+    \/**\n+     * {@return the value type of a primitive class}\n+     *\n+     * @param klass a class\n+     *\/\n+    Class<?> asValueType(Class<?> klass);\n+\n+    \/**\n+     * {@return true if the class is the primary type of a primitive class}\n+     *\n+     * @param klass a class\n+     *\/\n+    boolean isPrimaryType(Class<?> klass);\n+\n+    \/**\n+     * {@return true if the class is the primary type of a primitive class}\n+     *\n+     * @param klass a class\n+     *\/\n+    boolean isPrimitiveValueType(Class<?> klass);\n+\n+    \/**\n+     * Returns {@code true} if this class is a primitive class.\n+     *\/\n+    boolean isPrimitiveClass(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1857,0 +1857,2 @@\n+                case Opcodes.DEFAULT:\n+                case Opcodes.WITHFIELD:\n@@ -2469,0 +2471,1 @@\n+                case Opcodes.WITHFIELD:\n@@ -2475,3 +2478,1 @@\n-                        if (opcode < Opcodes.INVOKEVIRTUAL) {\n-                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n-                        } else {\n+                        if (opcode >= Opcodes.INVOKEVIRTUAL && opcode <= Opcodes.INVOKEINTERFACE) {\n@@ -2481,0 +2482,2 @@\n+                        } else {\n+                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n@@ -2515,0 +2518,1 @@\n+                case Opcodes.DEFAULT:\n@@ -3266,1 +3270,2 @@\n-                    if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n+                    char descType = methodDescriptor.charAt(currentMethodDescritorOffset);\n+                    if (descType == 'L' || descType == 'Q') {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -335,0 +335,1 @@\n+    int ACC_IDENTITY = 0x0020; \/\/ class\n@@ -339,0 +340,1 @@\n+    int ACC_VALUE = 0x0040; \/\/ class\n@@ -344,0 +346,1 @@\n+    int ACC_INLINE = 0x0100; \/\/ inline class\n@@ -346,0 +349,1 @@\n+    int ACC_PRIMITIVE = 0x0800; \/\/ class\n@@ -588,0 +592,2 @@\n+    int DEFAULT = 203; \/\/ visitTypeInsn\n+    int WITHFIELD = 204; \/\/ visitFieldInsn\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-\n@@ -275,0 +274,2 @@\n+    exports jdk.internal.value to  \/\/ Needed by Unsafe\n+        jdk.unsupported;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.value.PrimitiveClass;\n+\n@@ -87,1 +89,1 @@\n-        if (c == 'L') {\n+        if (c == 'L' || c == 'Q') {\n@@ -93,1 +95,2 @@\n-                return Class.forName(name, false, loader);\n+                Class<?> clz = Class.forName(name, false, loader);\n+                return c == 'Q' ? PrimitiveClass.asValueType(clz) : PrimitiveClass.asPrimaryType(clz);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -317,0 +317,14 @@\n+    public R visitWithField(WithFieldTree node, P p) {\n+        R r = scan(node.getField(), p);\n+        r = scanAndReduce(node.getValue(), p, r);\n+        return r;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n@@ -411,0 +425,12 @@\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n+    public R visitDefaultValue(DefaultValueTree node, P p) {\n+        return scan(node.getType(), p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -612,1 +612,2 @@\n-        for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+        Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n@@ -632,1 +633,1 @@\n-        if (methodName == names.init)\n+        if (names.isInitOrVNew(methodName))\n@@ -1148,1 +1149,1 @@\n-                            classType.tsym, classType.getMetadata()) {\n+                                  classType.tsym, classType.getMetadata(), classType.getFlavor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -239,0 +239,2 @@\n+        PRIMITIVE_CLASSES(JDK19, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n+        VALUE_CLASSES(JDK19, Fragments.FeatureValueClasses, DiagKind.PLURAL),\n@@ -294,0 +296,3 @@\n+            if (this == PRIMITIVE_CLASSES) {\n+                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -359,1 +360,1 @@\n-        if (name == name.table.names.init && owner.hasOuterInstance()) {\n+        if (isInitOrVNew() && owner.hasOuterInstance()) {\n@@ -418,0 +419,24 @@\n+    public boolean isPrimitiveClass() {\n+        return (flags() & PRIMITIVE_CLASS) != 0;\n+    }\n+\n+    public boolean isValueClass() {\n+        return !isInterface() && (flags() & VALUE_CLASS) != 0;\n+    }\n+\n+    public boolean isConcreteValueClass() {\n+        return isValueClass() && !isAbstract();\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return !isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+    }\n+\n+    public boolean isValueInterface() {\n+        return isInterface() && (flags() & VALUE_CLASS) != 0;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+    }\n+\n@@ -459,1 +484,13 @@\n-        return name == name.table.names.init;\n+        return name == name.table.names.init && (flags() & STATIC) == 0;\n+    }\n+\n+    \/** Is this symbol a value object factory?\n+     *\/\n+    public boolean isValueObjectFactory() {\n+        return name == name.table.names.vnew && this.type.getReturnType().tsym == this.owner;\n+    }\n+\n+    \/** Is this symbol a constructor or value factory?\n+     *\/\n+    public boolean isInitOrVNew() {\n+        return name.table.names.isInitOrVNew(name);\n@@ -1319,1 +1356,1 @@\n-                new ClassType(Type.noType, null, null),\n+                new ClassType(Type.noType, null, null, TypeMetadata.EMPTY, Flavor.X_Typeof_X),\n@@ -1356,1 +1393,2 @@\n-                                              type.getMetadata());\n+                                              type.getMetadata(),\n+                                              type.getFlavor());\n@@ -1417,0 +1455,8 @@\n+            } finally {\n+                if (this.type != null && this.type.hasTag(CLASS)) {\n+                    ClassType ct = (ClassType) this.type;\n+                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n+                    if (!this.type.isIntersection() && this.erasure_field != null && this.erasure_field.hasTag(CLASS)) {\n+                        ((ClassType) this.erasure_field).flavor = ct.flavor;\n+                    }\n+                }\n@@ -1604,0 +1650,1 @@\n+                classType.flavor = Flavor.X_Typeof_X;\n@@ -1957,1 +2004,1 @@\n-                String s = (name == name.table.names.init)\n+                String s = isInitOrVNew()\n@@ -2019,1 +2066,1 @@\n-            if (isConstructor() || _other.kind != MTH) return false;\n+            if (isInitOrVNew() || _other.kind != MTH) return false;\n@@ -2026,1 +2073,1 @@\n-                types.asSuper(owner.type, other.owner) != null &&\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n@@ -2088,1 +2135,1 @@\n-            if (isConstructor() || _other.kind != MTH) return false;\n+            if (isInitOrVNew() || _other.kind != MTH) return false;\n@@ -2095,1 +2142,1 @@\n-                types.asSuper(owner.type, other.owner) != null) {\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n@@ -2212,1 +2259,1 @@\n-            if (name == name.table.names.init)\n+            if (isInitOrVNew())\n@@ -2385,1 +2432,1 @@\n-                if (refSym.isConstructor()) {\n+                if (refSym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Type.WildcardType;\n@@ -68,0 +69,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -96,0 +98,2 @@\n+    private final boolean allowPrimitiveClasses;\n+\n@@ -278,2 +282,11 @@\n-                if (type.getTag() == ARRAY || type.getTag() == CLASS)\n-                    arg = types.erasure(type);\n+                if (type.getTag() == ARRAY || type.getTag() == CLASS) {\n+                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n+                       I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>\n+                    *\/\n+                    if (allowPrimitiveClasses && type.isPrimitiveClass()) {\n+                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());\n+                        arg = new WildcardType(bounds.size() > 1 ? types.makeIntersectionType(bounds) : objectType, BoundKind.EXTENDS, boundClass);\n+                    } else {\n+                        arg = types.erasure(type);\n+                    }\n+                }\n@@ -657,1 +670,2 @@\n-\n+        Options options = Options.instance(context);\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -239,0 +240,69 @@\n+    public boolean isPrimitiveClass() {\n+        return false;\n+    }\n+\n+    public boolean isValueClass() {\n+        return false;\n+    }\n+\n+    public boolean isValueInterface() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return false;\n+    }\n+\n+    \/\/ Does this type need to be preloaded in the context of the referring class ??\n+    public boolean requiresPreload(Symbol referringClass) {\n+        if (this.tsym == referringClass)\n+            return false; \/\/ pointless\n+        if (this.isReferenceProjection())\n+            return true;\n+        return this.isValueClass() && !this.isPrimitiveClass();\n+    }\n+\n+    \/**\n+     * Return the `flavor' associated with a ClassType.\n+     * @see ClassType.Flavor\n+     *\/\n+    public Flavor getFlavor() {\n+        throw new AssertionError(\"Unexpected call to getFlavor() on a Type that is not a ClassType: \" + this);\n+    }\n+\n+    \/**\n+     * @return true IFF the receiver is a reference projection of a primitive class type and false\n+     * for primitives or plain references\n+     *\/\n+    public boolean isReferenceProjection() {\n+        return false;\n+    }\n+\n+    \/**\n+     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n+     * and null otherwise\n+     *\/\n+    public Type valueProjection() {\n+        return null;\n+    }\n+\n+    \/**\n+     * @return the reference projection type IFF the receiver is a primitive class type\n+     * and null otherwise\n+     *\/\n+    public Type referenceProjection() {\n+        return null;\n+    }\n+\n+    \/**\n+     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n+     *\/\n+    public Type referenceProjectionOrSelf() {\n+        Type projection = referenceProjection();\n+        return projection != null ? projection : this;\n+    }\n+\n@@ -253,1 +323,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.getFlavor()) {\n@@ -949,0 +1019,34 @@\n+    public static class ConstantPoolQType implements PoolConstant {\n+\n+        public final Type type;\n+        final Types types;\n+\n+        public ConstantPoolQType(Type type, Types types) {\n+            this.type = type;\n+            this.types = types;\n+        }\n+\n+        @Override\n+        public Object poolKey(Types types) {\n+            return this;\n+        }\n+\n+        @Override\n+        public int poolTag() {\n+            return ClassFile.CONSTANT_Class;\n+        }\n+\n+        public int hashCode() {\n+            return types.hashCode(type);\n+        }\n+\n+        public boolean equals(Object obj) {\n+            return (obj instanceof ConstantPoolQType) &&\n+                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n+        }\n+\n+        public String toString() {\n+            return type.toString();\n+        }\n+    }\n+\n@@ -952,0 +1056,78 @@\n+        \/**\n+         * The 'flavor' of a ClassType indicates its reference\/primitive projectionness\n+         * viewed against the default nature of the associated class.\n+         *\/\n+        public enum Flavor {\n+\n+            \/**\n+             * Classic reference type. Also reference projection type of a reference-favoring aka\n+             * reference-default primitive class type\n+             *\/\n+            L_TypeOf_L,\n+\n+            \/**\n+             * Reference projection type of a primitive-favoring aka primitive-default\n+             * plain vanilla primitive class type,\n+             *\/\n+            L_TypeOf_Q,\n+\n+            \/**\n+             * Value projection type of a primitive-favoring aka primitive-default\n+             * plain vanilla primitive class type,\n+             *\/\n+            Q_TypeOf_Q,\n+\n+            \/**\n+             * Value projection type of a reference-favoring aka\n+             * reference-default primitive class type\n+             *\/\n+            Q_TypeOf_L,\n+\n+            \/**\n+             * Reference projection type of a class type of an as yet unknown default provenance, 'X' will be\n+             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n+             *\/\n+            L_TypeOf_X,\n+\n+            \/**\n+             * Value projection type of a class type of an as yet unknown default provenance, 'X' will be\n+             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n+             *\/\n+            Q_TypeOf_X,\n+\n+            \/**\n+             *  As yet unknown projection type of an as yet unknown default provenance class.\n+             *\/\n+            X_Typeof_X,\n+\n+            \/**\n+             *  An error type - we don't care to discriminate them any further.\n+             *\/\n+             E_Typeof_X;\n+\n+            \/\/ We don't seem to need X_Typeof_L or X_Typeof_Q so far.\n+\n+            \/\/ Transform a larval form into a more evolved form\n+            public Flavor metamorphose(boolean isPrimtiveClass) {\n+\n+                switch (this) {\n+\n+                    case E_Typeof_X:  \/\/ stunted form\n+                    case L_TypeOf_L:\n+                    case L_TypeOf_Q:\n+                    case Q_TypeOf_L:\n+                    case Q_TypeOf_Q:\n+                            \/\/ These are fully evolved sealed forms or stunted - no futher transformation\n+                            return this;\n+                    case L_TypeOf_X:\n+                            return isPrimtiveClass ? L_TypeOf_Q : L_TypeOf_L;\n+                    case Q_TypeOf_X:\n+                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n+                    case X_Typeof_X:\n+                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n+                    default:\n+                            throw new AssertionError(\"Unexpected class type flavor\");\n+                }\n+            }\n+        }\n+\n@@ -980,0 +1162,13 @@\n+        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n+         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n+        *\/\n+        public ClassType projection;\n+\n+        \/** Is this L of default {L, Q, X} or Q of default {L, Q, X} ?\n+         *\/\n+        public Flavor flavor;\n+\n+        \/*\n+         * Use of this constructor is kinda sorta deprecated, use the other constructor\n+         * that forces the call site to consider and include the class type flavor.\n+         *\/\n@@ -981,1 +1176,1 @@\n-            this(outer, typarams, tsym, TypeMetadata.EMPTY);\n+            this(outer, typarams, tsym, TypeMetadata.EMPTY, Flavor.L_TypeOf_L);\n@@ -985,1 +1180,1 @@\n-                         TypeMetadata metadata) {\n+                         TypeMetadata metadata, Flavor flavor) {\n@@ -992,0 +1187,1 @@\n+            this.flavor = flavor;\n@@ -1000,1 +1196,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md) {\n+            return new ClassType(outer_field, typarams_field, tsym, md, flavor) {\n@@ -1018,1 +1214,1 @@\n-            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {\n+            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata, flavor) {\n@@ -1061,0 +1257,11 @@\n+            boolean isReferenceProjection;\n+            try {\n+                isReferenceProjection = isReferenceProjection();\n+            } catch (CompletionFailure cf) {\n+                isReferenceProjection = false; \/\/ handle missing types gracefully.\n+            }\n+            if (isReferenceProjection) {\n+                buf.append('.');\n+                buf.append(tsym.name.table.names.ref);\n+            }\n+\n@@ -1099,0 +1306,4 @@\n+        public Flavor getFlavor() {\n+            return flavor;\n+        }\n+\n@@ -1115,0 +1326,3 @@\n+            if (outer_field != null && outer_field.isReferenceProjection()) {\n+                outer_field = outer_field.valueProjection();\n+            }\n@@ -1146,0 +1360,74 @@\n+        @Override\n+        public boolean isPrimitiveClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n+        }\n+\n+        @Override\n+        public boolean isValueClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isValueClass();\n+        }\n+\n+        @Override\n+        public boolean isValueInterface() {\n+            return tsym != null && tsym.isValueInterface();\n+        }\n+\n+        @Override\n+        public boolean isIdentityClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+        }\n+\n+        @Override\n+        public boolean isIdentityInterface() {\n+            return isInterface() && tsym.isIdentityInterface();\n+        }\n+\n+        @Override\n+        public boolean isReferenceProjection() {\n+            \/\/ gaurd against over-eager and\/or inopportune completion\n+            if (tsym != null) {\n+                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n+                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n+                }\n+            }\n+            return flavor == Flavor.L_TypeOf_Q;\n+        }\n+\n+        @Override\n+        public Type valueProjection() {\n+            if (!isReferenceProjection())\n+                return null;\n+\n+            if (projection !=  null)\n+                return projection;\n+\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n+            projection.allparams_field = allparams_field;\n+            projection.supertype_field = supertype_field;\n+\n+            projection.interfaces_field = interfaces_field;\n+            projection.all_interfaces_field = all_interfaces_field;\n+            projection.projection = this;\n+            return projection;\n+        }\n+\n+        \/\/ return the reference projection type preserving parameterizations\n+        @Override\n+        public ClassType referenceProjection() {\n+\n+            if (!isPrimitiveClass())\n+                return null;\n+\n+            if (projection != null)\n+                return projection;\n+\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.L_TypeOf_Q);\n+            projection.allparams_field = allparams_field;\n+            projection.supertype_field = supertype_field;\n+\n+            projection.interfaces_field = interfaces_field;\n+            projection.all_interfaces_field = all_interfaces_field;\n+            projection.projection = this;\n+            return projection;\n+        }\n+\n@@ -1194,1 +1482,1 @@\n-            super(outer, List.nil(), tsym, metadata);\n+            super(outer, List.nil(), tsym, metadata, tsym.type.getFlavor());\n@@ -2351,2 +2639,1 @@\n-            super(noType, List.nil(), null);\n-            this.tsym = tsym;\n+            super(noType, List.nil(), tsym, TypeMetadata.EMPTY, Flavor.E_Typeof_X);\n@@ -2357,2 +2644,2 @@\n-                          TypeMetadata metadata) {\n-            super(noType, List.nil(), null, metadata);\n+                          TypeMetadata metadata, Flavor flavor) {\n+            super(noType, List.nil(), null, metadata, flavor);\n@@ -2365,1 +2652,1 @@\n-            return new ErrorType(originalType, tsym, md) {\n+            return new ErrorType(originalType, tsym, md, getFlavor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":298,"deletions":11,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-                    !s.isConstructor())\n+                    !s.isInitOrVNew())\n@@ -245,1 +245,1 @@\n-                    (s.kind == MTH && !s.isConstructor() &&\n+                    (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -247,1 +247,1 @@\n-                    (s.kind == MTH && s.isConstructor()))\n+                    (s.kind == MTH && s.isInitOrVNew()))\n@@ -640,1 +640,1 @@\n-                                                      t.getMetadata());\n+                                                      t.getMetadata(), t.getFlavor());\n@@ -1058,1 +1058,1 @@\n-                    } else if (exsym.isConstructor()) {\n+                    } else if (exsym.isInitOrVNew()) {\n@@ -1165,1 +1165,1 @@\n-                    if (tree.sym.isConstructor()) {\n+                    if (tree.sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import com.sun.tools.javac.comp.LambdaToMethod;\n@@ -95,0 +94,1 @@\n+    final boolean allowPrimitiveClasses;\n@@ -122,0 +122,2 @@\n+        Options options = Options.instance(context);\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -271,1 +273,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n@@ -602,0 +604,11 @@\n+\n+        if (allowPrimitiveClasses) {\n+            boolean tValue = t.isPrimitiveClass();\n+            boolean sValue = s.isPrimitiveClass();\n+            if (tValue != sValue) {\n+                return tValue ?\n+                        isSubtype(t.referenceProjection(), s) :\n+                        !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n+            }\n+        }\n+\n@@ -764,2 +777,4 @@\n-            } else if (abstracts.size() == 1) {\n-                return new FunctionDescriptor(abstracts.first());\n+            }\n+            FunctionDescriptor descRes;\n+            if (abstracts.size() == 1) {\n+                descRes = new FunctionDescriptor(abstracts.first());\n@@ -767,1 +782,1 @@\n-                FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());\n+                descRes = mergeDescriptors(origin, abstracts.toList());\n@@ -786,1 +801,11 @@\n-                return descRes;\n+            \/\/ an interface must be neither an identity interface nor a value interface to be functional.\n+            List<Type> allInterfaces = closure(origin.type);\n+            for (Type iface : allInterfaces) {\n+                if (iface.isValueInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.ValueInterfaceNonfunctional));\n+                }\n+                if (iface.isIdentityInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.IdentityInterfaceNonfunctional));\n+                }\n+            }\n+            return descRes;\n@@ -956,1 +981,1 @@\n-                        t.name != names.init &&\n+                        !names.isInitOrVNew(t.name) &&\n@@ -1027,1 +1052,13 @@\n-                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                    \/\/ if T.ref <: S, then T[] <: S[]\n+                    Type es = elemtype(s);\n+                    Type et = elemtype(t);\n+                    if (allowPrimitiveClasses) {\n+                        if (et.isPrimitiveClass()) {\n+                            et = et.referenceProjection();\n+                            if (es.isPrimitiveClass())\n+                                es = es.referenceProjection();  \/\/ V <: V, surely\n+                        }\n+                    }\n+                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                        return false;\n+                    return true;\n@@ -1124,1 +1161,1 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                         s.hasTag(BOT) || (s.hasTag(CLASS) && (!allowPrimitiveClasses || !s.isPrimitiveClass())) ||\n@@ -1191,0 +1228,1 @@\n+                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1202,2 +1240,11 @@\n-                    else\n-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n+                    else {\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (allowPrimitiveClasses && et.isPrimitiveClass()) {\n+                            et = et.referenceProjection();\n+                            if (es.isPrimitiveClass())\n+                                es = es.referenceProjection();  \/\/ V <: V, surely\n+                        }\n+                        return isSubtypeNoCapture(et, es);\n+                    }\n@@ -1426,1 +1473,2 @@\n-                    && visit(t.getEnclosingType(), s.getEnclosingType())\n+                    && t.isReferenceProjection() == s.isReferenceProjection()\n+                    && visit(getEnclosingType(t), getEnclosingType(s))\n@@ -1429,0 +1477,8 @@\n+                \/\/ where\n+                private Type getEnclosingType(Type t) {\n+                    Type et = t.getEnclosingType();\n+                    if (et.isReferenceProjection()) {\n+                        et = et.valueProjection();\n+                    }\n+                    return et;\n+                }\n@@ -1588,0 +1644,9 @@\n+\n+                    \/\/ -----------------------------------  Unspecified behavior ----------------\n+\n+                    \/* If a primitive class V implements an interface I, then does \"? extends I\" contain V?\n+                       It seems widening must be applied here to answer yes to compile some common code\n+                       patterns.\n+                    *\/\n+\n+                    \/\/ ---------------------------------------------------------------------------\n@@ -1677,1 +1742,1 @@\n-            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n+            if (isSubtype(erasure(ts.type.referenceProjectionOrSelf()), erasure(ss.type))) {\n@@ -1732,1 +1797,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || (s.hasTag(BOT) && (!allowPrimitiveClasses || !t.isPrimitiveClass())))\n@@ -1751,0 +1816,10 @@\n+                    if (allowPrimitiveClasses) {\n+                        if (t.isPrimitiveClass()) {\n+                            \/\/ (s) Value ? == (s) Value.ref\n+                            t = t.referenceProjection();\n+                        }\n+                        if (s.isPrimitiveClass()) {\n+                            \/\/ (Value) t ? == (Value.ref) t\n+                            s = s.referenceProjection();\n+                        }\n+                    }\n@@ -2144,0 +2219,29 @@\n+     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n+     * this method.\n+     *\n+     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n+     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n+     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n+     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n+     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n+     *    really need the cast cannot\/shouldn't be gated on\n+     *\n+     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n+     *\n+     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n+     *    types. When we operate in terms of symbols, there is a loss of type information leading\n+     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n+     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n+     *    may be required at the call site. Also where the concerned symbol corresponds to a\n+     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n+     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n+     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n+     *\n+     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n+     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n+     *    that is NOT what we want. An example of such a hazardous call used to occur in\n+     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n+     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n+     *    These hazardous calls should be rewritten as\n+     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n+     *\n@@ -2156,0 +2260,6 @@\n+\n+        if (allowPrimitiveClasses && t.isPrimitiveClass()) {\n+            \/\/ No man may be an island, but the bell tolls for a value.\n+            return t.tsym == sym ? t : null;\n+        }\n+\n@@ -2286,3 +2396,12 @@\n-        return (sym.flags() & STATIC) != 0\n-            ? sym.type\n-            : memberType.visit(t, sym);\n+\n+        if ((sym.flags() & STATIC) != 0)\n+            return sym.type;\n+\n+        \/* If any primitive class types are involved, switch over to the reference universe,\n+           where the hierarchy is navigable. V and V.ref have identical membership\n+           with no bridging needs.\n+        *\/\n+        if (allowPrimitiveClasses && t.isPrimitiveClass())\n+            t = t.referenceProjection();\n+\n+        return memberType.visit(t, sym);\n@@ -2441,7 +2560,19 @@\n-                Type erased = t.tsym.erasure(Types.this);\n-                if (recurse) {\n-                    erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,\n-                            t.getMetadata().without(Kind.ANNOTATIONS));\n-                    return erased;\n-                } else {\n-                    return combineMetadata(erased, t);\n+                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n+                Type erased = eraseClassType(t, recurse);\n+                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n+                    erased = new ClassType(erased.getEnclosingType(),\n+                            List.nil(), erased.tsym,\n+                            erased.getMetadata(), t.flavor);\n+                }\n+                return erased;\n+            }\n+                \/\/ where\n+                private Type eraseClassType(ClassType t, Boolean recurse) {\n+                    Type erased = t.tsym.erasure(Types.this);\n+                    if (recurse) {\n+                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                                t.getMetadata().without(Kind.ANNOTATIONS));\n+                        return erased;\n+                    } else {\n+                        return combineMetadata(erased, t);\n+                    }\n@@ -2449,1 +2580,0 @@\n-            }\n@@ -2769,1 +2899,1 @@\n-                                         t.getMetadata());\n+                                         t.getMetadata(), t.getFlavor());\n@@ -3940,1 +4070,1 @@\n-                                 class1.tsym);\n+                                 class1.tsym, TypeMetadata.EMPTY, class1.getFlavor());\n@@ -4500,1 +4630,1 @@\n-                                 cls.getMetadata());\n+                                 cls.getMetadata(), cls.getFlavor());\n@@ -4911,0 +5041,1 @@\n+        private boolean encodeTypeSig;\n@@ -4912,1 +5043,1 @@\n-        public UniqueType(Type type, Types types) {\n+        public UniqueType(Type type, Types types, boolean encodeTypeSig) {\n@@ -4915,0 +5046,5 @@\n+            this.encodeTypeSig = encodeTypeSig;\n+        }\n+\n+        public UniqueType(Type type, Types types) {\n+            this(type, types, true);\n@@ -4926,0 +5062,4 @@\n+        public boolean encodeTypeSig() {\n+            return encodeTypeSig;\n+        }\n+\n@@ -5164,1 +5304,4 @@\n-                    append('L');\n+                    if (types.allowPrimitiveClasses && type.isPrimitiveClass())\n+                        append('Q');\n+                    else\n+                        append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":173,"deletions":30,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -170,0 +171,1 @@\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -188,0 +190,4 @@\n+    \/** Switch: allow primitive classes ?\n+     *\/\n+    boolean allowPrimitiveClasses;\n+\n@@ -276,1 +282,1 @@\n-            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n+            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n@@ -803,1 +809,1 @@\n-                List<Type> bounds = List.of(attribType(tvar.bounds.head, env));\n+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n@@ -805,1 +811,1 @@\n-                    bounds = bounds.prepend(attribType(bound, env));\n+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n@@ -1075,1 +1081,1 @@\n-                if (tree.name == names.init) {\n+                if (names.isInitOrVNew(tree.name)) {\n@@ -1190,1 +1196,1 @@\n-                if (tree.name == names.init && owner.type != syms.objectType) {\n+                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n@@ -1193,1 +1199,1 @@\n-                            TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {\n+                            TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {\n@@ -1206,0 +1212,6 @@\n+                    } else if ((env.enclClass.sym.flags() & VALUE_CLASS) != 0 &&\n+                        (tree.mods.flags & GENERATEDCONSTR) == 0 &&\n+                        TreeInfo.isSuperCall(body.stats.head)) {\n+                        \/\/ value constructors are not allowed to call super directly,\n+                        \/\/ but tolerate compiler generated ones, these are ignored during code generation\n+                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInValueCtor);\n@@ -1293,0 +1305,3 @@\n+            \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n+               as these can undergo updates via copy on write.\n+            *\/\n@@ -1294,1 +1309,1 @@\n-                if ((v.flags_field & FINAL) == 0 ||\n+                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isValueClass()) ||\n@@ -1334,1 +1349,2 @@\n-        return false;\n+        \/\/ isValueObject is not included in Object yet so we need a work around\n+        return name == names.isValueObject;\n@@ -1527,1 +1543,1 @@\n-                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n@@ -1543,1 +1559,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n@@ -1885,1 +1901,1 @@\n-        chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));\n+        chk.checkIdentityType(tree.pos(), attribExpr(tree.lock, env));\n@@ -1976,1 +1992,1 @@\n-            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n@@ -2165,1 +2181,2 @@\n-            \/\/ Those were all the cases that could result in a primitive\n+            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n+            \/\/ value conversions bring about a convergence.\n@@ -2167,1 +2184,2 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n+                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n@@ -2178,1 +2196,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n@@ -2181,1 +2199,1 @@\n-            \/\/ both are known to be reference types.  The result is\n+            \/\/ both are known to be reference types (or projections).  The result is\n@@ -2620,0 +2638,4 @@\n+                \/\/ Special treatment for primitive classes: Given an expression v of type V where\n+                \/\/ V is a primitive class, v.getClass() is typed to be Class<? extends |V.ref|>\n+                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n+                                         qualifierType.referenceProjection() : qualifierType.baseType());\n@@ -2621,1 +2643,1 @@\n-                        List.of(new WildcardType(types.erasure(qualifierType.baseType()),\n+                        List.of(new WildcardType(wcb,\n@@ -2625,1 +2647,2 @@\n-                        restype.getMetadata());\n+                        restype.getMetadata(),\n+                        restype.getFlavor());\n@@ -2645,1 +2668,1 @@\n-            if (enclMethod != null && enclMethod.name == names.init) {\n+            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n@@ -2794,0 +2817,10 @@\n+            \/\/ Check that it is an instantiation of a class and not a projection type\n+            if (allowPrimitiveClasses) {\n+                if (clazz.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n+                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n+                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n+                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n+                    }\n+                }\n+            }\n@@ -2818,1 +2851,2 @@\n-                                               clazztype.getMetadata());\n+                                               clazztype.getMetadata(),\n+                                               clazztype.getFlavor());\n@@ -2972,0 +3006,3 @@\n+                    if (allowPrimitiveClasses) {\n+                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    }\n@@ -3044,0 +3081,3 @@\n+        \/\/ Likewise arg can't be null if it is a primitive class instance.\n+        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n+            return arg;\n@@ -3533,1 +3573,2 @@\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n+                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n@@ -3596,0 +3637,1 @@\n+            Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3597,0 +3639,4 @@\n+                \/\/ TODO - a bit hacky but...\n+                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n+                    that.name = names.vnew;\n+                }\n@@ -3602,1 +3648,0 @@\n-                Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3686,1 +3731,1 @@\n-            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n@@ -4364,0 +4409,10 @@\n+        Assert.check(site == tree.selected.type);\n+        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n+            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n+             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n+             * always matching the behavior of Object::getClass\n+             *\/\n+             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n+                 tree.selected.setType(site = site.referenceProjection());\n+             }\n+        }\n@@ -4376,1 +4431,1 @@\n-                return ;\n+                return;\n@@ -4480,1 +4535,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n@@ -4523,0 +4578,2 @@\n+                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n+                    return site.tsym;\n@@ -4626,1 +4683,1 @@\n-                \/\/ except for two situations:\n+                \/\/ except for three situations:\n@@ -4629,0 +4686,3 @@\n+                    if (allowPrimitiveClasses) {\n+                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n+                    }\n@@ -4632,1 +4692,8 @@\n-                    \/\/ (a) If the symbol's type is parameterized, erase it\n+                    \/\/ (a) If symbol is a primitive class and its reference projection\n+                    \/\/ is requested via the .ref notation, then adjust the computed type to\n+                    \/\/ reflect this.\n+                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n+                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n+                    }\n+\n+                    \/\/ (b) If the symbol's type is parameterized, erase it\n@@ -4639,1 +4706,1 @@\n-                    \/\/ (b) If the symbol's type is an inner class, then\n+                    \/\/ (c) If the symbol's type is an inner class, then\n@@ -4659,1 +4726,1 @@\n-                                owntype.getMetadata());\n+                                owntype.getMetadata(), owntype.getFlavor());\n@@ -4722,1 +4789,1 @@\n-            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n+            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n@@ -4976,0 +5043,31 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        if (!allowPrimitiveClasses) {\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n+        }\n+\n+        \/\/ Attribute the qualifier expression, and determine its symbol (if any).\n+        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n+        if (!pkind().contains(KindSelector.TYP_PCK))\n+            site = capture(site); \/\/ Capture field access\n+        if (!allowPrimitiveClasses) {\n+            result = types.createErrorType(names._default, site.tsym, site);\n+        } else {\n+            Symbol sym = switch (site.getTag()) {\n+                case WILDCARD -> throw new AssertionError(tree);\n+                case PACKAGE -> {\n+                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n+                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n+                    yield syms.errSymbol;\n+                }\n+                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n+                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n+            };\n+\n+            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n+                site = types.skipTypeVars(site, true);\n+            }\n+            result = checkId(tree, site, sym, env, resultInfo);\n+        }\n+    }\n+\n@@ -5042,1 +5140,1 @@\n-                                        clazztype.getMetadata());\n+                                        clazztype.getMetadata(), clazztype.getFlavor());\n@@ -5169,1 +5267,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT),\n+                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n@@ -5192,1 +5290,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n@@ -5310,0 +5408,5 @@\n+            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5430,1 +5533,1 @@\n-            } else {\n+            } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n@@ -5485,0 +5588,5 @@\n+                if (c.isValueClass()) {\n+                    Assert.check(env.tree.hasTag(CLASSDEF));\n+                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":142,"deletions":34,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -215,0 +216,4 @@\n+    \/** Are primitive classes allowed\n+     *\/\n+    private final boolean allowPrimitiveClasses;\n+\n@@ -617,0 +622,5 @@\n+        } else {\n+            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n+                if (inferenceContext != infer.emptyContext)\n+                    checkParameterizationByPrimitiveClass(pos, found);\n+            }\n@@ -747,0 +757,51 @@\n+    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+        for (Type st : types.closure(c.type)) {\n+            if (st == null || st.tsym == null || st.tsym.kind == ERR)\n+                continue;\n+            if  (st.tsym == syms.objectType.tsym || st.tsym == syms.recordType.tsym || st.isInterface())\n+                continue;\n+            if (!st.tsym.isAbstract()) {\n+                if (c != st.tsym) {\n+                    log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n+                }\n+                continue;\n+            }\n+            \/\/ dealing with an abstract value or value super class below.\n+            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n+            if ((st.tsym.flags() & HASINITBLOCK) != 0) {\n+                log.error(pos, Errors.AbstractValueClassDeclaresInitBlock(fragment));\n+            }\n+            Type encl = st.getEnclosingType();\n+            if (encl != null && encl.hasTag(CLASS)) {\n+                log.error(pos, Errors.AbstractValueClassCannotBeInner(fragment));\n+            }\n+            for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                case VAR:\n+                    if ((s.flags() & STATIC) == 0) {\n+                        log.error(pos, Errors.InstanceFieldNotAllowed(s, fragment));\n+                    }\n+                    break;\n+                case MTH:\n+                    if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                        log.error(pos, Errors.SuperClassMethodCannotBeSynchronized(s, c, st));\n+                    } else if (s.isInitOrVNew()) {\n+                        MethodSymbol m = (MethodSymbol)s;\n+                        if (m.getParameters().size() > 0) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorCannotTakeArguments(m, fragment));\n+                        } else if (m.getTypeParameters().size() > 0) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorCannotBeGeneric(m, fragment));\n+                        } else if (m.type.getThrownTypes().size() > 0) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorCannotThrow(m, fragment));\n+                        } else if (protection(m.flags()) > protection(m.owner.flags())) {\n+                            log.error(pos, Errors.AbstractValueClassConstructorHasWeakerAccess(m, fragment));\n+                        } else if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n+                                log.error(pos, Errors.AbstractValueClassNoArgConstructorMustBeEmpty(m, fragment));\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -749,2 +810,2 @@\n-    Type checkConstructorRefType(DiagnosticPosition pos, Type t) {\n-        t = checkClassOrArrayType(pos, t);\n+    Type checkConstructorRefType(JCExpression expr, Type t) {\n+        t = checkClassOrArrayType(expr, t);\n@@ -753,1 +814,1 @@\n-                log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));\n+                log.error(expr, Errors.AbstractCantBeInstantiated(t.tsym));\n@@ -756,1 +817,1 @@\n-                log.error(pos, Errors.EnumCantBeInstantiated);\n+                log.error(expr, Errors.EnumCantBeInstantiated);\n@@ -759,1 +820,10 @@\n-                t = checkClassType(pos, t, true);\n+                \/\/ Projection types may not be mentioned in constructor references\n+                if (expr.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n+                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n+                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n+                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n+                        t = types.createErrorType(t);\n+                    }\n+                }\n+                t = checkClassType(expr, t, true);\n@@ -763,1 +833,1 @@\n-                log.error(pos, Errors.GenericArrayCreation);\n+                log.error(expr, Errors.GenericArrayCreation);\n@@ -794,0 +864,1 @@\n+     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -795,2 +866,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        if (t.isReference())\n+    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n+        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n@@ -804,0 +875,31 @@\n+    \/** Check that type is an identity type, i.e. not a primitive\/value type\n+     *  nor its reference projection. When not discernible statically,\n+     *  give it the benefit of doubt and defer to runtime.\n+     *\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    void checkIdentityType(DiagnosticPosition pos, Type t) {\n+        if (t.hasTag(TYPEVAR)) {\n+            t = types.skipTypeVars(t, false);\n+        }\n+        if (t.isIntersection()) {\n+            IntersectionClassType ict = (IntersectionClassType)t;\n+            for (Type component : ict.getExplicitComponents()) {\n+                checkIdentityType(pos, component);\n+            }\n+            return;\n+        }\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+            typeTagError(pos, diags.fragment(Fragments.TypeReqIdentity), t);\n+    }\n+\n+    \/** Check that type is a reference type, i.e. a class, interface or array type\n+     *  or a type variable.\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        return checkRefType(pos, t, true);\n+    }\n+\n@@ -812,1 +914,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head);\n+            l.head = checkRefType(tl.head.pos(), l.head, false);\n@@ -848,0 +950,49 @@\n+    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n+        parameterizationByPrimitiveClassChecker.visit(t, pos);\n+    }\n+\n+    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n+     *  being used as type arguments and issues error against those usages.\n+     *\/\n+    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n+            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n+\n+        @Override\n+        public Void visitType(Type t, DiagnosticPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n+            for (Type targ : t.allparams()) {\n+                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n+                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n+                }\n+                visit(targ, pos);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n+             return null;\n+        }\n+\n+        @Override\n+        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n+            return visit(t.elemtype, pos);\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n+            return visit(t.type, pos);\n+        }\n+    };\n+\n+\n+\n@@ -980,1 +1131,1 @@\n-                (s.isConstructor() ||\n+                (s.isInitOrVNew() ||\n@@ -996,1 +1147,5 @@\n-        return types.upward(t, types.captures(t)).baseType();\n+        Type varType = types.upward(t, types.captures(t)).baseType();\n+        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n+            checkParameterizationByPrimitiveClass(pos, varType);\n+        }\n+        return varType;\n@@ -1019,0 +1174,1 @@\n+        \/\/ TODO - is enum so <init>\n@@ -1194,1 +1350,1 @@\n-            else\n+            else {\n@@ -1196,0 +1352,4 @@\n+                if (sym.owner.type.isValueClass() && (flags & STATIC) == 0) {\n+                    implicit |= FINAL;\n+                }\n+            }\n@@ -1198,1 +1358,1 @@\n-            if (sym.name == names.init) {\n+            if (names.isInitOrVNew(sym.name)) {\n@@ -1221,1 +1381,2 @@\n-                mask = RecordMethodFlags;\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        RecordMethodFlags & ~SYNCHRONIZED : RecordMethodFlags;\n@@ -1223,1 +1384,3 @@\n-                mask = MethodFlags;\n+                \/\/ value objects do not have an associated monitor\/lock\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        MethodFlags & ~SYNCHRONIZED : MethodFlags;\n@@ -1240,1 +1403,1 @@\n-                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? StaticLocalFlags : LocalClassFlags;\n+                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? ExtendedStaticLocalClassFlags : ExtendedLocalClassFlags;\n@@ -1260,2 +1423,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n@@ -1274,0 +1437,17 @@\n+\n+            \/\/ primitive classes are implicitly final value classes.\n+            if ((flags & PRIMITIVE_CLASS) != 0)\n+                implicit |= VALUE_CLASS | FINAL;\n+\n+            \/\/ concrete value classes are implicitly final\n+            if ((flags & (ABSTRACT | INTERFACE | VALUE_CLASS)) == VALUE_CLASS) {\n+                implicit |= FINAL;\n+                if ((flags & NON_SEALED) != 0) {\n+                    \/\/ cant declare a final value class non-sealed\n+                    log.error(pos,\n+                            Errors.ModNotAllowedHere(asFlagSet(NON_SEALED)));\n+                }\n+            }\n+\n+            \/\/ TYPs can't be declared synchronized\n+            mask &= ~SYNCHRONIZED;\n@@ -1302,1 +1482,5 @@\n-                               FINAL | NATIVE | SYNCHRONIZED)\n+                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                 &&\n+                 checkDisjoint(pos, flags,\n+                        IDENTITY_TYPE,\n+                        PRIMITIVE_CLASS | VALUE_CLASS)\n@@ -1312,1 +1496,1 @@\n-                 checkDisjoint(pos, flags,\n+                 checkDisjoint(pos, (flags | implicit), \/\/ complain against volatile & implcitly final entities too.\n@@ -1328,1 +1512,7 @@\n-                                ANNOTATION)) {\n+                                ANNOTATION)\n+                 && checkDisjoint(pos, flags,\n+                                IDENTITY_TYPE,\n+                                ANNOTATION)\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n+                                ANNOTATION) ) {\n@@ -1501,1 +1691,2 @@\n-                tree.selected.type.isParameterized()) {\n+                tree.selected.type.isParameterized() &&\n+                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n@@ -1505,0 +1696,2 @@\n+                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n+                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -1568,1 +1761,1 @@\n-                    env.enclMethod != null && env.enclMethod.name == names.init;\n+                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n@@ -2169,1 +2362,1 @@\n-                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n@@ -2295,0 +2488,39 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        if (allowPrimitiveClasses) {\n+            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+            try {\n+                tree.sym.flags_field |= LOCKED;\n+                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl field = (JCVariableDecl) l.head;\n+                        if (cyclePossible(field.sym)) {\n+                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                        }\n+                    }\n+                }\n+            } finally {\n+                tree.sym.flags_field &= ~LOCKED;\n+            }\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n+        }\n+\n@@ -2543,0 +2775,22 @@\n+\n+        boolean cIsValue = (c.tsym.flags() & VALUE_CLASS) != 0;\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        Type identitySuper = null, valueSuper = null;\n+        for (Type t : types.closure(c)) {\n+            if (t != c) {\n+                if ((t.tsym.flags() & IDENTITY_TYPE) != 0)\n+                    identitySuper = t;\n+                else if ((t.tsym.flags() & VALUE_CLASS) != 0)\n+                    valueSuper = t;\n+                if (cIsValue &&  identitySuper != null) {\n+                    log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, identitySuper));\n+                    break;\n+                } else if (cHasIdentity &&  valueSuper != null) {\n+                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, valueSuper));\n+                    break;\n+                } else if (identitySuper != null && valueSuper != null) {\n+                    log.error(pos, Errors.MutuallyIncompatibleSupers(c, identitySuper, valueSuper));\n+                    break;\n+                }\n+            }\n+        }\n@@ -2660,1 +2914,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -2719,1 +2973,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -3422,1 +3676,1 @@\n-                if (s.kind == MTH && !s.isConstructor())\n+                if (s.kind == MTH && !s.isInitOrVNew())\n@@ -3430,1 +3684,1 @@\n-                if (s.kind == MTH && s.isConstructor())\n+                if (s.kind == MTH && s.isInitOrVNew())\n@@ -3449,1 +3703,1 @@\n-                        (s.kind == MTH && !s.isConstructor() &&\n+                        (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -3451,1 +3705,1 @@\n-                        (s.kind == MTH && s.isConstructor())) {\n+                        (s.kind == MTH && s.isInitOrVNew())) {\n@@ -4749,1 +5003,1 @@\n-                    if (sym.isConstructor() &&\n+                    if (sym.isInitOrVNew() &&\n@@ -4777,1 +5031,1 @@\n-                        if (sym.isConstructor()) {\n+                        if (sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":286,"deletions":32,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;\n+import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;\n@@ -1449,1 +1451,1 @@\n-                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n@@ -1872,0 +1874,8 @@\n+    \/** Enum to model whether constructors allowed to \"leak\" this reference before\n+        all instance fields are DA.\n+     *\/\n+    enum ThisExposability {\n+        ALLOWED,     \/\/ identity Object classes - NOP\n+        BANNED,      \/\/ primitive\/value classes - Error\n+    }\n+\n@@ -1960,0 +1970,3 @@\n+        \/\/ Are constructors allowed to leak this reference ?\n+        ThisExposability thisExposability = ALLOWED;\n+\n@@ -2084,0 +2097,22 @@\n+        void checkEmbryonicThisExposure(JCTree node) {\n+            if (this.thisExposability == ALLOWED || classDef == null)\n+                return;\n+\n+            \/\/ Note: for non-initial constructors, firstadr is post all instance fields.\n+            for (int i = firstadr; i < nextadr; i++) {\n+                VarSymbol sym = vardecls[i].sym;\n+                if (sym.owner != classDef.sym)\n+                    continue;\n+                if ((sym.flags() & (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)\n+                    continue;\n+                if (sym.pos < startPos || sym.adr < firstadr)\n+                    continue;\n+                if (!inits.isMember(sym.adr)) {\n+                    if (this.thisExposability == BANNED) {\n+                        log.error(node, Errors.ThisExposedPrematurely);\n+                    }\n+                    return; \/\/ don't flog a dead horse.\n+                }\n+            }\n+        }\n+\n@@ -2284,0 +2319,1 @@\n+            ThisExposability priorThisExposability = this.thisExposability;\n@@ -2298,0 +2334,6 @@\n+                        this.thisExposability = ALLOWED;\n+                    } else {\n+                        if (tree.sym.owner.type.isValueClass())\n+                            this.thisExposability = BANNED;\n+                        else\n+                            this.thisExposability = ALLOWED;\n@@ -2361,0 +2403,1 @@\n+                this.thisExposability = priorThisExposability;\n@@ -2840,0 +2883,5 @@\n+            if (tree.meth.hasTag(IDENT)) {\n+                JCIdent ident = (JCIdent) tree.meth;\n+                if (ident.name != names._super && !ident.sym.isStatic())\n+                    checkEmbryonicThisExposure(tree);\n+            }\n@@ -2846,0 +2894,6 @@\n+            if (classDef != null && tree.encl == null && tree.clazz.hasTag(IDENT)) {\n+                JCIdent clazz = (JCIdent) tree.clazz;\n+                if (!clazz.sym.isStatic() && clazz.type.getEnclosingType().tsym == classDef.sym) {\n+                    checkEmbryonicThisExposure(tree);\n+                }\n+            }\n@@ -2908,1 +2962,8 @@\n-            super.visitSelect(tree);\n+            ThisExposability priorThisExposability = this.thisExposability;\n+            try {\n+                if (tree.name == names._this && classDef != null && tree.sym.owner == classDef.sym) {\n+                    checkEmbryonicThisExposure(tree);\n+                } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {\n+                    this.thisExposability = ALLOWED;\n+                }\n+                super.visitSelect(tree);\n@@ -2911,1 +2972,4 @@\n-                checkInit(tree.pos(), (VarSymbol)tree.sym);\n+                    checkInit(tree.pos(), (VarSymbol)tree.sym);\n+                }\n+            } finally {\n+                 this.thisExposability = priorThisExposability;\n@@ -2975,0 +3039,3 @@\n+            if (tree.name == names._this) {\n+                checkEmbryonicThisExposure(tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":70,"deletions":3,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-                Name name = msym.name == msym.name.table.names.init ?\n+                Name name = msym.name.table.names.isInitOrVNew(msym.name) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,1 +356,2 @@\n-            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n+            \/\/ TODO - can <vnew> exist in this context?\n+            if ((init = names.isInitOrVNew(owner.name)) || owner.name == names.clinit) {\n@@ -375,1 +376,1 @@\n-                make.QualIdent(lambdaType.getReturnType().tsym),\n+                make.QualIdent(lambdaType.getReturnType().tsym).setType(lambdaType.getReturnType()),\n@@ -1667,1 +1668,2 @@\n-                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n+                Name constructorName = csym.isConcreteValueClass() ? names.vnew : names.init;\n+                for (Symbol s : csym.members_field.getSymbolsByName(constructorName)) {\n@@ -1771,1 +1773,1 @@\n-                    && sym.name != names.init;\n+                    && !names.isInitOrVNew(sym.name);\n@@ -1869,1 +1871,1 @@\n-                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n+                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n@@ -1893,0 +1895,2 @@\n+                } else if (methodName.equals(\"<vnew>\")) {\n+                    methodName = \"vnew\";\n@@ -2347,1 +2351,1 @@\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner() || tree.sym.owner.isValueClass()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final boolean allowPrimitiveClasses;\n@@ -133,0 +134,1 @@\n+        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -826,1 +828,1 @@\n-            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,\n+            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE,\n@@ -1063,1 +1065,1 @@\n-        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (names.isInitOrVNew(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1152,0 +1154,3 @@\n+                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n+                boolean requireReferenceProjection = allowPrimitiveClasses &&\n+                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1167,0 +1172,3 @@\n+                    if (requireReferenceProjection) {\n+                        tree.setType(tree.type.referenceProjection());\n+                    }\n@@ -1170,0 +1178,3 @@\n+                    if (requireReferenceProjection) {\n+                        tree.setType(tree.type.referenceProjection());\n+                    }\n@@ -1267,0 +1278,1 @@\n+                Name constructorName = accOwner.isConcreteValueClass() ? names.vnew : names.init;\n@@ -1269,1 +1281,1 @@\n-                    names.init,\n+                    constructorName,\n@@ -1298,1 +1310,1 @@\n-                ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;\n+                ctag = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, topClass).sym;\n@@ -1313,1 +1325,1 @@\n-        if (sym.name == names.init) {\n+        if (names.isInitOrVNew(sym.name)) {\n@@ -1526,1 +1538,1 @@\n-            (owner.isConstructor() && owner.isAnonymous()) ||\n+            (owner.isInitOrVNew() && owner.isAnonymous()) ||\n@@ -1528,1 +1540,1 @@\n-            (owner.isConstructor() && c.isInner() &&\n+            (owner.isInitOrVNew() && c.isInner() &&\n@@ -1725,1 +1737,1 @@\n-        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n+        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n@@ -1877,1 +1889,1 @@\n-        return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;\n+        return makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, clazz).sym;\n@@ -1929,1 +1941,1 @@\n-        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;\n+        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, outermostClassDef.sym).sym;\n@@ -2109,1 +2121,2 @@\n-        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n+        return (tree == null) ? null :\n+                applyPrimitiveConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);\n@@ -2248,1 +2261,1 @@\n-        tree.mods.flags &= ClassFlags;\n+        tree.mods.flags &= AdjustedClassFlags;\n@@ -2658,0 +2671,1 @@\n+        \/\/ TODO - enum so is always <init>\n@@ -2699,1 +2713,1 @@\n-        if (tree.name == names.init &&\n+        if (names.isInitOrVNew(tree.name) &&\n@@ -2780,1 +2794,1 @@\n-        if (tree.name == names.init && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+        if (names.isInitOrVNew(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n@@ -3022,1 +3036,2 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        \/\/ TODO - is enum so always <init>.\n+        if (names.isInitOrVNew(meth.name) && meth.owner == syms.enumSym)\n@@ -3027,1 +3042,1 @@\n-        if (meth.name==names.init) {\n+        if (names.isInitOrVNew(meth.name)) {\n@@ -3129,0 +3144,11 @@\n+    \/** Apply primitive value\/reference conversions as needed *\/\n+    @SuppressWarnings(\"unchecked\")\n+    <T extends JCExpression> T applyPrimitiveConversionsAsNeeded(T tree, Type type) {\n+        boolean haveValue = tree.type.isPrimitiveClass();\n+        if (haveValue == type.isPrimitiveClass())\n+            return tree;\n+        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n+        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n+        return (T) make.TypeCast(type, tree);\n+    }\n+\n@@ -3532,1 +3558,1 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n@@ -3542,1 +3568,1 @@\n-            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -3625,0 +3651,17 @@\n+    public void visitWithField(JCWithField tree) {\n+        Type fieldType = tree.field.type;\n+        tree.field = translate(tree.field, tree);\n+        tree.value = translate(tree.value, fieldType); \/\/ important to use pre-translation type.\n+\n+        \/\/ If translated field is an Apply, we are\n+        \/\/ seeing an access method invocation. In this case, append\n+        \/\/ right hand side as last argument of the access method.\n+        if (tree.field.hasTag(APPLY)) {\n+            JCMethodInvocation app = (JCMethodInvocation) tree.field;\n+            app.args = List.of(tree.value).prependList(app.args);\n+            result = app;\n+        } else {\n+            result = tree;\n+        }\n+    }\n+\n@@ -4118,0 +4161,5 @@\n+        \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n+         * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n+         * always matching the behavior of Object::getClass\n+         *\/\n+        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n@@ -4119,0 +4167,3 @@\n+        if (needPrimaryMirror && allowPrimitiveClasses && tree.selected.type.isPrimitiveClass()) {\n+            tree.selected.setType(tree.selected.type.referenceProjection());\n+        }\n@@ -4126,1 +4177,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":70,"deletions":19,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1058,1 +1058,2 @@\n-            for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+            Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n+            for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -68,1 +67,0 @@\n-import java.util.function.Consumer;\n@@ -111,0 +109,1 @@\n+    public final boolean allowValueClasses;\n@@ -116,0 +115,1 @@\n+    final boolean allowPrimitiveClasses;\n@@ -152,0 +152,2 @@\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -221,1 +223,1 @@\n-        if (bestSoFar.name == names.init &&\n+        if (names.isInitOrVNew(bestSoFar.name) &&\n@@ -294,1 +296,1 @@\n-        return owner.isConstructor() ||\n+        return owner.isInitOrVNew() ||\n@@ -406,1 +408,1 @@\n-        if (sym.name == names.init && sym.owner != site.tsym) return false;\n+        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n@@ -419,37 +421,56 @@\n-        switch ((short)(sym.flags() & AccessFlags)) {\n-        case PRIVATE:\n-            return\n-                (env.enclClass.sym == sym.owner \/\/ fast special case\n-                 ||\n-                 env.enclClass.sym.outermostClass() ==\n-                 sym.owner.outermostClass())\n-                &&\n-                sym.isInheritedIn(site.tsym, types);\n-        case 0:\n-            return\n-                (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n-                 ||\n-                 env.toplevel.packge == sym.packge())\n-                &&\n-                isAccessible(env, site, checkInner)\n-                &&\n-                sym.isInheritedIn(site.tsym, types)\n-                &&\n-                notOverriddenIn(site, sym);\n-        case PROTECTED:\n-            return\n-                (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n-                 ||\n-                 env.toplevel.packge == sym.packge()\n-                 ||\n-                 isProtectedAccessible(sym, env.enclClass.sym, site)\n-                 ||\n-                 \/\/ OK to select instance method or field from 'super' or type name\n-                 \/\/ (but type names should be disallowed elsewhere!)\n-                 env.info.selectSuper && (sym.flags() & STATIC) == 0 && sym.kind != TYP)\n-                &&\n-                isAccessible(env, site, checkInner)\n-                &&\n-                notOverriddenIn(site, sym);\n-        default: \/\/ this case includes erroneous combinations as well\n-            return isAccessible(env, site, checkInner) && notOverriddenIn(site, sym);\n+        ClassSymbol enclosingCsym = env.enclClass.sym;\n+        if (allowPrimitiveClasses) {\n+            if (sym.kind == MTH || sym.kind == VAR) {\n+                \/* If any primitive class types are involved, ask the same question in the reference universe,\n+                   where the hierarchy is navigable\n+                *\/\n+                if (site.isPrimitiveClass())\n+                    site = site.referenceProjection();\n+            } else if (sym.kind == TYP) {\n+                \/\/ A type is accessible in a reference projection if it was\n+                \/\/ accessible in the value projection.\n+                if (site.isReferenceProjection())\n+                    site = site.valueProjection();\n+            }\n+        }\n+        try {\n+            switch ((short)(sym.flags() & AccessFlags)) {\n+                case PRIVATE:\n+                    return\n+                            (env.enclClass.sym == sym.owner \/\/ fast special case\n+                                    ||\n+                                    env.enclClass.sym.outermostClass() ==\n+                                            sym.owner.outermostClass())\n+                                    &&\n+                                    sym.isInheritedIn(site.tsym, types);\n+                case 0:\n+                    return\n+                            (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n+                                    ||\n+                                    env.toplevel.packge == sym.packge())\n+                                    &&\n+                                    isAccessible(env, site, checkInner)\n+                                    &&\n+                                    sym.isInheritedIn(site.tsym, types)\n+                                    &&\n+                                    notOverriddenIn(site, sym);\n+                case PROTECTED:\n+                    return\n+                            (env.toplevel.packge == sym.owner.owner \/\/ fast special case\n+                                    ||\n+                                    env.toplevel.packge == sym.packge()\n+                                    ||\n+                                    isProtectedAccessible(sym, env.enclClass.sym, site)\n+                                    ||\n+                                    \/\/ OK to select instance method or field from 'super' or type name\n+                                    \/\/ (but type names should be disallowed elsewhere!)\n+                                    env.info.selectSuper && (sym.flags() & STATIC) == 0 && sym.kind != TYP)\n+                                    &&\n+                                    isAccessible(env, site, checkInner)\n+                                    &&\n+                                    notOverriddenIn(site, sym);\n+                default: \/\/ this case includes erroneous combinations as well\n+                    return isAccessible(env, site, checkInner) && notOverriddenIn(site, sym);\n+            }\n+        } finally {\n+            env.enclClass.sym = enclosingCsym;\n@@ -466,1 +487,1 @@\n-        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n@@ -468,4 +489,6 @@\n-        else {\n-            Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n-            return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n-                    !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n+\n+        \/* If any primitive class types are involved, ask the same question in the reference universe,\n+           where the hierarchy is navigable\n+        *\/\n+        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n+            site = site.referenceProjection();\n@@ -473,0 +496,4 @@\n+\n+        Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n+        return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n+                !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n@@ -1692,1 +1719,1 @@\n-                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n@@ -1697,1 +1724,1 @@\n-                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n@@ -1864,1 +1891,1 @@\n-            if (name == names.init) return bestSoFar;\n+            if (names.isInitOrVNew(name)) return bestSoFar;\n@@ -2299,0 +2326,16 @@\n+        return findMemberTypeInternal(env,site, name, c);\n+    }\n+\n+    \/** Find qualified member type.\n+     *  @param env       The current environment.\n+     *  @param site      The original type from where the selection takes\n+     *                   place.\n+     *  @param name      The type's name.\n+     *  @param c         The class to search for the member type. This is\n+     *                   always a superclass or implemented interface of\n+     *                   site's class.\n+     *\/\n+    Symbol findMemberTypeInternal(Env<AttrContext> env,\n+                          Type site,\n+                          Name name,\n+                          TypeSymbol c) {\n@@ -2347,0 +2390,8 @@\n+        return findTypeInternal(env, name);\n+    }\n+\n+    \/** Find an unqualified type symbol.\n+     *  @param env       The current environment.\n+     *  @param name      The type's name.\n+     *\/\n+    Symbol findTypeInternal(Env<AttrContext> env, Name name) {\n@@ -2885,1 +2936,2 @@\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n@@ -2919,0 +2971,1 @@\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2920,1 +2973,1 @@\n-                                    names.init, argtypes,\n+                                    constructorName, argtypes,\n@@ -2943,0 +2996,1 @@\n+        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2944,1 +2998,1 @@\n-                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n@@ -2959,1 +3013,1 @@\n-                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n@@ -3006,1 +3060,2 @@\n-        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n@@ -3015,1 +3070,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n@@ -3057,1 +3112,1 @@\n-        if (!name.equals(names.init)) {\n+        if (!names.isInitOrVNew(name)) {\n@@ -3572,1 +3627,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n@@ -3625,1 +3680,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n@@ -3650,1 +3705,2 @@\n-            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n+            \/\/ TODO - array constructor will be <init>\n+            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3682,1 +3738,1 @@\n-            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3686,1 +3742,1 @@\n-                                site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata());\n+                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n@@ -3776,1 +3832,1 @@\n-                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n@@ -4089,1 +4145,1 @@\n-            boolean isConstructor = name == names.init;\n+            boolean isConstructor = names.isInitOrVNew(name);\n@@ -4181,1 +4237,1 @@\n-                      ws.name == names.init ? ws.owner.name : ws.name,\n+                      names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n@@ -4237,0 +4293,1 @@\n+                boolean isConstructor = names.isInitOrVNew(name);\n@@ -4245,2 +4302,2 @@\n-                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),\n-                        name == names.init ? site.tsym.name : name,\n+                        isConstructor ? KindName.CONSTRUCTOR : kind.absentKind(),\n+                        isConstructor ? site.tsym.name : name,\n@@ -4406,1 +4463,1 @@\n-            if (sym.name == names.init && sym.owner != site.tsym) {\n+            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n@@ -4619,1 +4676,1 @@\n-            if (sname == names.init) sname = s1.owner.name;\n+            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":126,"deletions":69,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-                sym.name != names.init &&\n+                !names.isInitOrVNew(sym.name) &&\n@@ -504,0 +504,7 @@\n+    public void visitWithField(JCWithField tree) {\n+        tree.field = translate(tree.field, null);\n+        tree.value = translate(tree.value, erasure(tree.field.type));\n+        tree.type = erasure(tree.type);\n+        result = retype(tree, tree.type, pt);\n+    }\n+\n@@ -673,0 +680,1 @@\n+        \/\/ TODO - is enum so <init>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -55,0 +56,1 @@\n+import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;\n@@ -1110,0 +1112,11 @@\n+\n+            if (tree.sym != syms.objectType.tsym && tree.sym != syms.recordType.tsym) {\n+                if ((tree.sym.flags() & (ABSTRACT | INTERFACE | VALUE_CLASS)) == 0) {\n+                    tree.sym.flags_field |= IDENTITY_TYPE;\n+                }\n+                if ((tree.sym.flags() & (ABSTRACT | IDENTITY_TYPE | INTERFACE)) == ABSTRACT) {\n+                    if (abstractClassHasImplicitIdentity(tree)) {\n+                        tree.sym.flags_field |= IDENTITY_TYPE;\n+                    }\n+                }\n+            }\n@@ -1112,0 +1125,44 @@\n+            \/\/ where\n+            private boolean abstractClassHasImplicitIdentity(JCClassDecl tree) {\n+\n+                Type t = tree.sym.type;\n+\n+                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n+                    return false;\n+\n+                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n+                    return true;\n+                }\n+\n+                \/\/ No instance fields and no arged constructors both mean inner classes cannot be value class supers.\n+                Type encl = t.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    return true;\n+                }\n+                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0) {\n+                                return true;\n+                            }\n+                            break;\n+                        case MTH:\n+                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                                return true;\n+                            } else if (s.isInitOrVNew()) {\n+                                MethodSymbol m = (MethodSymbol)s;\n+                                if (m.getParameters().size() > 0\n+                                        || m.getTypeParameters().size() > 0\n+                                        || m.type.getThrownTypes().nonEmpty()\n+                                        || (m.flags() & EMPTYNOARGCONSTR) == 0\n+                                        || (Check.protection(m.flags()) > Check.protection(m.owner.flags()))) {\n+                                    return true;\n+                                }\n+                            }\n+                            break;\n+                    }\n+                }\n+                return false;\n+            }\n+\n+\n@@ -1305,1 +1362,2 @@\n-                constructorSymbol = new MethodSymbol(flags, names.init,\n+                Name constructorName = owner().isConcreteValueClass() ? names.vnew : names.init;\n+                constructorSymbol = new MethodSymbol(flags, constructorName,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -285,0 +284,7 @@\n+        public void visitWithField(JCWithField tree) {\n+            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n+            sr.mergeWith(csp(tree.field));\n+            sr.mergeWith(csp(tree.value));\n+            result = sr;\n+        }\n+\n@@ -381,0 +387,7 @@\n+        @Override\n+        public void visitDefaultValue(JCDefaultValue tree) {\n+            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n+            sr.mergeWith(csp(tree.clazz));\n+            result = sr;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     classig    ::= 'L' name [typeargs] ';'\n+ *     classig    ::= 'L' name [typeargs] ';' | 'Q' name [typeargs] ';'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -81,0 +82,1 @@\n+    private final TransValues transValues;\n@@ -117,0 +119,1 @@\n+        transValues = TransValues.instance(context);\n@@ -134,0 +137,2 @@\n+        Source source = Source.instance(context);\n+        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -177,0 +182,2 @@\n+    boolean allowPrimitiveClasses;\n+\n@@ -220,0 +227,14 @@\n+    \/** Insert a reference to given type in the constant pool,\n+     *  checking for an array with too many dimensions;\n+     *  return the reference's index.\n+     *  @param type   The type for which a reference is inserted.\n+     *\/\n+    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n+        checkDimension(pos, type);\n+        if (emitQtype) {\n+            return poolWriter.putClass(new ConstantPoolQType(type, types));\n+        } else {\n+            return poolWriter.putClass(type);\n+        }\n+    }\n+\n@@ -226,1 +247,1 @@\n-        return poolWriter.putClass(checkDimension(pos, type));\n+        return makeRef(pos, type, false);\n@@ -280,1 +301,1 @@\n-        else items.makeMemberItem(msym, name == names.init).invoke();\n+        else items.makeMemberItem(msym, names.isInitOrVNew(name)).invoke();\n@@ -503,1 +524,1 @@\n-        if (md.name == names.init && TreeInfo.isInitialConstructor(md)) {\n+        if (names.isInitOrVNew(md.name) && TreeInfo.isInitialConstructor(md)) {\n@@ -906,1 +927,1 @@\n-            if (meth.isConstructor()) {\n+            if (meth.isInitOrVNew()) {\n@@ -946,0 +967,3 @@\n+                    } else if (env.enclMethod.sym.isValueObjectFactory()) {\n+                        items.makeLocalItem(env.enclMethod.factoryProduct).load();\n+                        code.emitop0(areturn);\n@@ -1000,1 +1024,2 @@\n-                                        poolWriter);\n+                                        poolWriter,\n+                                        allowPrimitiveClasses);\n@@ -1010,1 +1035,1 @@\n-                if (meth.isConstructor() && selfType != syms.objectType)\n+                if (meth.isInitOrVNew() && selfType != syms.objectType)\n@@ -1049,0 +1074,4 @@\n+        Type localType = v.erasure(types);\n+        if (localType.requiresPreload(env.enclClass.sym)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) localType.tsym);\n+        }\n@@ -1097,0 +1126,31 @@\n+    public void visitWithField(JCWithField tree) {\n+        switch(tree.field.getTag()) {\n+            case IDENT:\n+                Symbol sym = ((JCIdent) tree.field).sym;\n+                items.makeThisItem().load();\n+                genExpr(tree.value, tree.field.type).load();\n+                sym = types.binaryQualifier(sym, env.enclClass.type);\n+                code.emitop2(withfield, sym, PoolWriter::putMember);\n+                result = items.makeStackItem(tree.type);\n+                break;\n+            case SELECT:\n+                JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;\n+                sym = TreeInfo.symbol(fieldAccess);\n+                \/\/ JDK-8207332: To maintain the order of side effects, must compute value ahead of field\n+                genExpr(tree.value, tree.field.type).load();\n+                genExpr(fieldAccess.selected, fieldAccess.selected.type).load();\n+                if (Code.width(tree.field.type) == 2) {\n+                    code.emitop0(dup_x2);\n+                    code.emitop0(pop);\n+                } else {\n+                    code.emitop0(swap);\n+                }\n+                sym = types.binaryQualifier(sym, fieldAccess.selected.type);\n+                code.emitop2(withfield, sym, PoolWriter::putMember);\n+                result = items.makeStackItem(tree.type);\n+                break;\n+            default:\n+                Assert.check(false);\n+        }\n+    }\n+\n@@ -2012,1 +2072,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype), type);\n+                code.emitAnewarray(makeRef(pos, elemtype, elemtype.isPrimitiveClass()), type);\n@@ -2238,0 +2298,1 @@\n+        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2240,2 +2301,9 @@\n-           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n-            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n+           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n+            checkDimension(tree.pos(), tree.clazz.type);\n+            if (tree.clazz.type.isPrimitiveClass()) {\n+                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n+            } else {\n+                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n+            }\n+\n@@ -2303,1 +2371,1 @@\n-            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n@@ -2306,1 +2374,1 @@\n-       }\n+        }\n@@ -2362,0 +2430,12 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        if (tree.type.isValueClass()) {\n+            code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n+        } else if (tree.type.isReference()) {\n+            code.emitop0(aconst_null);\n+        } else {\n+            code.emitop0(zero(Code.typecode(tree.type)));\n+        }\n+        result = items.makeStackItem(tree.type);\n+        return;\n+    }\n+\n@@ -2418,0 +2498,1 @@\n+            cdef = transValues.translateTopLevelClass(cdef, make);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":92,"deletions":11,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1738,1 +1738,1 @@\n-                                ((JCMethodDecl) t).sym.name == names.init ||\n+                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Flags.Flag;\n@@ -52,0 +53,1 @@\n+import static com.sun.tools.javac.code.Flags.asFlagSet;\n@@ -60,0 +62,1 @@\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;\n@@ -192,0 +195,2 @@\n+        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n+        this.allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -229,0 +234,8 @@\n+    \/** Switch: are primitive classes allowed in this source level?\n+     *\/\n+     boolean allowPrimitiveClasses;\n+\n+    \/** Switch: are value classes allowed in this source level?\n+     *\/\n+    boolean allowValueClasses;\n+\n@@ -476,0 +489,16 @@\n+    \/** If next input token matches one of the two given tokens, skip it, otherwise report\n+     *  an error.\n+     *\n+     * @return The actual token kind.\n+     *\/\n+    public TokenKind accept2(TokenKind tk1, TokenKind tk2) {\n+        TokenKind returnValue = token.kind;\n+        if (token.kind == tk1 || token.kind == tk2) {\n+            nextToken();\n+        } else {\n+            setErrorEndPos(token.pos);\n+            reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));\n+        }\n+        return returnValue;\n+    }\n+\n@@ -1368,0 +1397,6 @@\n+                            case DEFAULT:\n+                                if (typeArgs != null) return illegal();\n+                                selectExprMode();\n+                                t = to(F.at(pos).DefaultValue(t));\n+                                nextToken();\n+                                break loop;\n@@ -1425,3 +1460,4 @@\n-                        if ((mode & TYPE) == 0 && isUnboundMemberRef()) {\n-                            \/\/this is an unbound method reference whose qualifier\n-                            \/\/is a generic type i.e. A<S>::m\n+                        if ((mode & TYPE) == 0 && isParameterizedTypePrefix()) {\n+                            \/\/this is either an unbound method reference whose qualifier\n+                            \/\/is a generic type i.e. A<S>::m or a default value creation of\n+                            \/\/the form ValueType<S>.default\n@@ -1440,0 +1476,6 @@\n+                                if (token.kind == DEFAULT) {\n+                                    t =  toP(F.at(token.pos).DefaultValue(t));\n+                                    nextToken();\n+                                    selectExprMode();\n+                                    return term3Rest(t, typeArgs);\n+                                }\n@@ -1608,1 +1650,1 @@\n-                } else if (token.kind == NEW && (mode & EXPR) != 0) {\n+                } else if ((token.kind == NEW) && (mode & EXPR) != 0) {\n@@ -1662,1 +1704,2 @@\n-     * method reference or a binary expression. To disambiguate, look for a\n+     * method reference or a default value creation that uses a parameterized type\n+     * or a binary expression. To disambiguate, look for a\n@@ -1666,1 +1709,1 @@\n-    boolean isUnboundMemberRef() {\n+    boolean isParameterizedTypePrefix() {\n@@ -2264,1 +2307,1 @@\n-            accept(CLASS);\n+            TokenKind selector = accept2(CLASS, DEFAULT);\n@@ -2282,1 +2325,5 @@\n-                t = toP(F.at(pos).Select(t, names._class));\n+                if (selector == CLASS) {\n+                    t = toP(F.at(pos).Select(t, names._class));\n+                } else {\n+                    t = toP(F.at(pos).DefaultValue(t));\n+                }\n@@ -2314,0 +2361,1 @@\n+            \/\/ TODO - will be converted in Attr\n@@ -2326,2 +2374,2 @@\n-        List<JCAnnotation> newAnnotations = typeAnnotationsOpt();\n-\n+        final JCModifiers mods = modifiersOpt();\n+        List<JCAnnotation> newAnnotations = mods.annotations;\n@@ -2331,0 +2379,3 @@\n+            if (mods.flags != 0) {\n+                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n+            }\n@@ -2399,0 +2450,3 @@\n+            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            if (badModifiers != 0)\n+                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));\n@@ -2403,1 +2457,5 @@\n-            return classCreatorRest(newpos, null, typeArgs, t);\n+            JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);\n+            if ((newClass.def == null) && (mods.flags != 0)) {\n+                log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n+            }\n+            return newClass;\n@@ -2428,1 +2486,1 @@\n-        return classCreatorRest(newpos, encl, typeArgs, t);\n+        return classCreatorRest(newpos, encl, typeArgs, t, 0);\n@@ -2506,1 +2564,2 @@\n-                                  JCExpression t)\n+                                  JCExpression t,\n+                                  long flags)\n@@ -2513,1 +2572,1 @@\n-            JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n+            JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);\n@@ -2516,1 +2575,2 @@\n-        return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n+        JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n+        return newClass;\n@@ -2749,0 +2809,4 @@\n+        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+            dc = token.comment(CommentStyle.JAVADOC);\n+            return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));\n+        }\n@@ -3322,1 +3386,4 @@\n-                return variableDeclarators(modifiersOpt(), t, stats, true).toList();\n+                pos = token.pos;\n+                JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n+                F.at(pos);\n+                return variableDeclarators(mods, t, stats, true).toList();\n@@ -3419,0 +3486,12 @@\n+                if (isPrimitiveModifier()) {\n+                    flag = Flags.PRIMITIVE_CLASS;\n+                    break;\n+                }\n+                if (isValueModifier()) {\n+                    flag = Flags.VALUE_CLASS;\n+                    break;\n+                }\n+                if (isIdentityModifier()) {\n+                    flag = Flags.IDENTITY_TYPE;\n+                    break;\n+                }\n@@ -3670,0 +3749,19 @@\n+        if (name == names.primitive) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK18;\n+            }\n+        }\n+        if (name == names.value) {\n+            if (allowValueClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n+        if (name == names.identity) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -4107,1 +4205,2 @@\n-                if (methDef.name == names.init && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                \/\/ TODO - specifically for record.\n+                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -4559,0 +4658,78 @@\n+    protected boolean isPrimitiveModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n+            boolean isPrimitiveModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isPrimitiveModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                            || next.name() == names.value || (mode & EXPR) != 0)\n+                        isPrimitiveModifier = true;\n+                    break;\n+            }\n+            if (isPrimitiveModifier) {\n+                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isValueModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.value) {\n+            boolean isValueModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isValueModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value || next.name() == names.identity\n+                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                        isValueModifier = true;\n+                    break;\n+            }\n+            if (isValueModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isIdentityModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.identity) {\n+            boolean isIdentityModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isIdentityModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ identity record R || identity primitive || || identity identity || identity value || new identity Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                            || next.name() == names.value || (mode & EXPR) != 0)\n+                        isIdentityModifier = true;\n+                    break;\n+            }\n+            if (isIdentityModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -4586,1 +4763,4 @@\n-                case IDENTIFIER -> isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;\n+                case IDENTIFIER -> isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) ||\n+                        next.name() == names.sealed ||\n+                        next.name() == names.value ||\n+                        next.name() == names.identity;\n@@ -4617,1 +4797,1 @@\n-            if (!isRecord || name != names.init || token.kind == LPAREN) {\n+            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n@@ -5073,1 +5253,4 @@\n-        if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n+            \/\/ primitive classes are special\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":203,"deletions":20,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -266,0 +266,6 @@\n+compiler.misc.value.interface.nonfunctional=\\\n+    since it is a value interface\n+\n+compiler.misc.identity.interface.nonfunctional=\\\n+    since it is an identity interface\n+\n@@ -712,1 +718,1 @@\n-    improperly formed type, some parameters are missing\n+    improperly formed type, some parameters are missing or misplaced\n@@ -2596,0 +2602,3 @@\n+compiler.misc.type.req.identity=\\\n+    a type with identity\n+\n@@ -3588,0 +3597,3 @@\n+compiler.misc.bad.access.flags=\\\n+    bad access flags combination: {0}\n+\n@@ -3916,0 +3928,88 @@\n+compiler.misc.feature.primitive.classes=\\\n+    primitive classes\n+\n+compiler.misc.feature.value.classes=\\\n+    value classes\n+\n+# 0: symbol\n+compiler.err.cyclic.primitive.class.membership=\\\n+    cyclic primitive class membership involving {0}\n+\n+# 0: string (expected version)\n+compiler.err.primitive.classes.not.supported=\\\n+    primitive classes are not supported\\n\\\n+     (use -source {0} or higher to enable primitive classes and pass compiler option: -XDenablePrimitiveClasses)\n+\n+compiler.err.this.exposed.prematurely=\\\n+    value class instance should not be passed around before being fully initialized\n+\n+# 0: type\n+compiler.err.generic.parameterization.with.primitive.class=\\\n+    Inferred type {0} involves generic parameterization by a primitive class\n+\n+# 0: type, 1: type\n+compiler.err.value.type.has.identity.super.type=\\\n+    The identity type {1} cannot be a supertype of the value type {0}\n+\n+# 0: type, 1: type\n+compiler.err.identity.type.has.value.super.type=\\\n+    The value type {1} cannot be a supertype of the identity type {0}\n+\n+# 0: type, 1: type, 2: type\n+compiler.err.mutually.incompatible.supers=\\\n+    The type {0} has mutually incompatible supertypes: the identity type {1} and the value type {2}\n+\n+# 0: symbol, 1: type\n+compiler.err.concrete.supertype.for.value.class=\\\n+    The concrete class {1} is not allowed to be a super class of the value class {0} either directly or indirectly\n+\n+# 0: symbol, 1: symbol, 2: type\n+compiler.err.super.class.method.cannot.be.synchronized=\\\n+    The method {0} in the super class {2} of the value class {1} is synchronized. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.abstract.value.class.constructor.cannot.take.arguments=\\\n+    {1} defines a constructor {0} that takes arguments. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.abstract.value.class.constructor.cannot.be.generic=\\\n+    {1} defines a generic constructor {0}. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.abstract.value.class.constructor.cannot.throw=\\\n+    {1} defines a constructor {0} that throws an exception. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.abstract.value.class.constructor.has.weaker.access=\\\n+    {1} defines a constructor {0} with a weaker access privilege than the declaring class. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.instance.field.not.allowed=\\\n+    {1} defines an instance field {0}. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.abstract.value.class.no.arg.constructor.must.be.empty=\\\n+    {1} defines a nonempty no-arg constructor {0}. This is disallowed\n+\n+# 0: message segment\n+compiler.err.abstract.value.class.declares.init.block=\\\n+    {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n+\n+# 0: message segment\n+compiler.err.abstract.value.class.cannot.be.inner=\\\n+    {0} is an inner class. This is disallowed.\n+\n+# 0: symbol, 1: type\n+compiler.misc.superclass.of.value.class=\\\n+    The super class {1} of the value class {0}\n+\n+# 0: symbol\n+compiler.misc.abstract.value.class=\\\n+    The abstract value class {0}\n+\n+compiler.err.projection.cant.be.instantiated=\\\n+    Illegal attempt to instantiate a projection type\n+\n+compiler.err.call.to.super.not.allowed.in.value.ctor=\\\n+    call to super not allowed in value class constructor\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":101,"deletions":1,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -218,0 +218,3 @@\n+javac.opt.Xlint.desc.migration=\\\n+    Warn about issues related to migration of JDK classes.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,0 +136,4 @@\n+        \/** Withfields, of type WithField.\n+         *\/\n+        WITHFIELD,\n+\n@@ -260,0 +264,4 @@\n+        \/** Default values, of type DefaultValueTree.\n+         *\/\n+        DEFAULT_VALUE,\n+\n@@ -884,0 +892,3 @@\n+        \/** nascent value that evolves into the return value for a value factory *\/\n+        public VarSymbol factoryProduct;\n+\n@@ -951,0 +962,4 @@\n+\n+        public boolean isInitOrVNew() {\n+            return name.table.names.isInitOrVNew(name);\n+        }\n@@ -1171,0 +1186,30 @@\n+    \/**\n+     * A withfield expression\n+     *\/\n+    public static class JCWithField extends JCExpression implements WithFieldTree {\n+        public JCExpression field;\n+        public JCExpression value;\n+        protected JCWithField(JCExpression field, JCExpression value) {\n+            this.field = field;\n+            this.value = value;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitWithField(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.WITH_FIELD; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getField() { return field; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getValue() { return value; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitWithField(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return WITHFIELD;\n+        }\n+    }\n+\n@@ -1383,0 +1428,26 @@\n+    \/**\n+     * A \"Identifier<TA1, TA2>.default\" construction.\n+     *\/\n+    public static class JCDefaultValue extends JCPolyExpression implements DefaultValueTree {\n+        public JCExpression clazz;\n+\n+        protected JCDefaultValue(JCExpression clazz) {\n+            this.clazz = clazz;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitDefaultValue(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.DEFAULT_VALUE; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getType() { return clazz; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitDefaultValue(this, d);\n+        }\n+        @Override\n+        public Tag getTag() {\n+            return DEFAULT_VALUE;\n+        }\n+    }\n+\n@@ -3440,0 +3511,1 @@\n+        JCDefaultValue DefaultValue(JCExpression type);\n@@ -3512,0 +3584,1 @@\n+        public void visitWithField(JCWithField that)         { visitTree(that); }\n@@ -3517,0 +3590,1 @@\n+        public void visitDefaultValue(JCDefaultValue that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-            if (tree.name == tree.name.table.names.init &&\n+            if (tree.isInitOrVNew() &&\n@@ -603,1 +603,1 @@\n-            if (tree.name == tree.name.table.names.init) {\n+            if (tree.isInitOrVNew()) {\n@@ -736,0 +736,9 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        try {\n+            printExpr(tree.clazz, TreeInfo.postfixPrec);\n+            print(\".default\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n@@ -772,0 +781,12 @@\n+    public void visitWithField(JCWithField tree) {\n+        try {\n+            print(\"__WithField(\");\n+            printExpr(tree.field);\n+            print(\", \");\n+            printExpr(tree.value);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -201,0 +201,7 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDefaultValue(DefaultValueTree node, P p) {\n+        JCDefaultValue t = (JCDefaultValue) node;\n+        JCExpression clazz = copy(t.clazz, p);\n+        return M.at(t.pos).DefaultValue(clazz);\n+    }\n+\n@@ -245,1 +252,2 @@\n-        return M.at(t.pos).Ident(t.name);\n+        JCIdent ident = M.at(t.pos).Ident(t.name);\n+        return ident;\n@@ -361,1 +369,2 @@\n-        return M.at(t.pos).Select(selected, t.name);\n+        JCFieldAccess select = M.at(t.pos).Select(selected, t.name);\n+        return select;\n@@ -565,0 +574,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitWithField(WithFieldTree node, P p) {\n+        JCWithField t = (JCWithField) node;\n+        JCExpression field = copy(t.field, p);\n+        JCExpression value = copy(t.value, p);\n+        return M.at(t.pos).WithField(field, value);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -84,1 +84,12 @@\n-            return name == name.table.names.init;\n+            return name == name.table.names.init || name == name.table.names.vnew;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/** Is tree a value factory declaration?\n+     *\/\n+    public static boolean isValueFactory(JCTree tree) {\n+        if (tree.hasTag(METHODDEF)) {\n+            Name name = ((JCMethodDecl) tree).name;\n+            return name == name.table.names.vnew;\n@@ -112,1 +123,1 @@\n-            if (isConstructor(l.head)) return true;\n+            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n@@ -117,0 +128,1 @@\n+     *  Optionally, check only for no-arg ctor invocation\n@@ -118,1 +130,1 @@\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names) {\n+    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names, boolean argsAllowed) {\n@@ -124,4 +136,6 @@\n-                    Name methName = TreeInfo.name(apply.meth);\n-                    if (methName == names._this ||\n-                        methName == names._super) {\n-                        return methName;\n+                    if (argsAllowed || apply.args.size() == 0) {\n+                        Name methName = TreeInfo.name(apply.meth);\n+                        if (methName == names._this ||\n+                                methName == names._super) {\n+                            return methName;\n+                        }\n@@ -255,2 +269,1 @@\n-        Names names = md.name.table.names;\n-        if (md.name != names.init) return null;\n+        if (!md.isInitOrVNew()) return null;\n@@ -491,0 +504,2 @@\n+            case DEFAULT_VALUE:\n+                return getStartPos(((JCDefaultValue) tree).clazz);\n@@ -638,0 +653,2 @@\n+            case WITHFIELD:\n+                return getEndPos(((JCWithField) tree).value, endPosTable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -266,0 +266,6 @@\n+    public JCWithField WithField(JCExpression field, JCExpression value) {\n+        JCWithField tree = new JCWithField(field, value);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -301,0 +307,6 @@\n+    public JCDefaultValue DefaultValue(JCExpression type) {\n+        JCDefaultValue tree = new JCDefaultValue(type);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -854,7 +866,22 @@\n-                Type outer = t.getEnclosingType();\n-                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n-                        ? Select(Type(outer), t.tsym)\n-                        : QualIdent(t.tsym);\n-                tp = t.getTypeArguments().isEmpty()\n-                        ? clazz\n-                        : TypeApply(clazz, Types(t.getTypeArguments()));\n+                if (t.isReferenceProjection()) {\n+                    \/\/ For parameterized types, we want V.ref<A1 ... An> not V<A1 ... An>.ref\n+                    JCExpression vp = Type(t.valueProjection());\n+                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n+                        \/\/ vp now is V<A1 ... An>, build V.ref<A1 ... An>\n+                        JCFieldAccess f = (JCFieldAccess) Select(((JCTypeApply) vp).clazz, t.tsym);\n+                        f.name = names.ref;\n+                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n+                    } else {\n+                        JCFieldAccess f = (JCFieldAccess) Select(vp, t.tsym);\n+                        f.name = names.ref;\n+                        tp = f;\n+                    }\n+                } else {\n+                    Type outer = t.getEnclosingType();\n+                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n+                            ? Select(Type(outer), t.tsym)\n+                            : QualIdent(t.tsym);\n+                    tp = t.getTypeArguments().isEmpty()\n+                            ? clazz\n+                            : TypeApply(clazz, Types(t.getTypeArguments()));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -157,0 +157,5 @@\n+    public void visitWithField(JCWithField tree) {\n+        scan(tree.field);\n+        scan(tree.value);\n+    }\n+\n@@ -184,0 +189,4 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        scan(tree.clazz);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,0 +183,6 @@\n+    public void visitWithField(JCWithField tree) {\n+        tree.field = translate(tree.field);\n+        tree.value = translate(tree.value);\n+        result = tree;\n+    }\n+\n@@ -401,0 +407,5 @@\n+    public void visitDefaultValue(JCDefaultValue tree) {\n+        tree.clazz = translate(tree.clazz);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    metadataTypeArray = new Type[9];\n+    metadataTypeArray = new Type[11];\n@@ -127,0 +127,2 @@\n+    metadataTypeArray[9] = db.lookupType(\"FlatArrayKlass\");\n+    metadataTypeArray[10] = db.lookupType(\"InlineKlass\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_status._flags\", Integer.class, \"u2\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_status._flags\", Integer.class, \"u4\");\n@@ -319,0 +319,2 @@\n+    final int dataLayoutArrayLoadStoreDataTag = getConstant(\"DataLayout::array_load_store_data_tag\", Integer.class);\n+    final int dataLayoutACmpDataTag = getConstant(\"DataLayout::acmp_data_tag\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-        return getDeclaringClass().isJavaLangObject() && getName().equals(\"<init>\");\n+        return getDeclaringClass().isJavaLangObject() && (getName().equals(\"<init>\") || getName().equals(\"<vnew>\"));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,1 +364,0 @@\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,117 @@\n+\n+static void assert_unlocked_state(markWord mark) {\n+  EXPECT_FALSE(mark.has_displaced_mark_helper());\n+  EXPECT_FALSE(mark.has_locker());\n+  EXPECT_FALSE(mark.has_monitor());\n+  EXPECT_FALSE(mark.is_being_inflated());\n+  EXPECT_FALSE(mark.is_locked());\n+  EXPECT_TRUE(mark.is_unlocked());\n+}\n+\n+static void assert_copy_set_hash(markWord mark) {\n+  const intptr_t hash = 4711;\n+  EXPECT_TRUE(mark.has_no_hash());\n+  markWord copy = mark.copy_set_hash(hash);\n+  EXPECT_EQ(hash, copy.hash());\n+  EXPECT_FALSE(copy.has_no_hash());\n+}\n+\n+static void assert_type(markWord mark) {\n+  EXPECT_FALSE(mark.is_flat_array());\n+  EXPECT_FALSE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_larval_state());\n+  EXPECT_FALSE(mark.is_null_free_array());\n+}\n+\n+TEST_VM(markWord, prototype) {\n+  markWord mark = markWord::prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_type(mark);\n+}\n+\n+static void assert_inline_type(markWord mark) {\n+  EXPECT_FALSE(mark.is_flat_array());\n+  EXPECT_TRUE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_null_free_array());\n+}\n+\n+TEST_VM(markWord, inline_type_prototype) {\n+  markWord mark = markWord::inline_type_prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_FALSE(mark.is_neutral());\n+\n+  assert_inline_type(mark);\n+  EXPECT_FALSE(mark.is_larval_state());\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  markWord larval = mark.enter_larval_state();\n+  EXPECT_TRUE(larval.is_larval_state());\n+  assert_inline_type(larval);\n+  mark = larval.exit_larval_state();\n+  EXPECT_FALSE(mark.is_larval_state());\n+  assert_inline_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+}\n+\n+#if _LP64\n+\n+static void assert_flat_array_type(markWord mark) {\n+  EXPECT_TRUE(mark.is_flat_array());\n+  EXPECT_FALSE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_larval_state());\n+  EXPECT_TRUE(mark.is_null_free_array());\n+}\n+\n+TEST_VM(markWord, flat_array_prototype) {\n+  markWord mark = markWord::flat_array_prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_flat_array_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_flat_array_type(mark);\n+}\n+\n+static void assert_null_free_array_type(markWord mark) {\n+  EXPECT_FALSE(mark.is_flat_array());\n+  EXPECT_FALSE(mark.is_inline_type());\n+  EXPECT_FALSE(mark.is_larval_state());\n+  EXPECT_TRUE(mark.is_null_free_array());\n+}\n+\n+TEST_VM(markWord, null_free_array_prototype) {\n+  markWord mark = markWord::null_free_array_prototype();\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_null_free_array_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_null_free_array_type(mark);\n+}\n+#endif \/\/ _LP64\n+\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+# Valhalla\n+compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java 8294624 generic-aarch64\n+\n@@ -105,0 +108,3 @@\n+# Valhalla\n+runtime\/AccModule\/ConstModule.java 8294051 generic-all\n+\n@@ -126,0 +132,27 @@\n+# Valhalla TODO:\n+serviceability\/sa\/ClhsdbCDSCore.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbFindPC.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbInspect.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbLongConstant.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJdis.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJstack.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintStatics.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSource.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSymbol.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbWhere.java 8190936 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8190936 generic-all\n+serviceability\/sa\/TestClassDump.java 8190936 generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestCpoolForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForLargeArray.java 8190936 generic-all\n+serviceability\/sa\/TestIntConstant.java 8190936 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCore.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8190936 generic-all\n+serviceability\/sa\/TestPrintMdo.java 8190936 generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 8190936 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1210,1 +1210,1 @@\n-    private static void beforeMatching(String irNodePlaceholder, String regex) {\n+    public static void beforeMatching(String irNodePlaceholder, String regex) {\n@@ -1242,1 +1242,1 @@\n-    private static void optoOnly(String irNodePlaceholder, String regex) {\n+    public static void optoOnly(String irNodePlaceholder, String regex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -551,0 +551,12 @@\n+    \/**\n+     * Checks if deopt of {@code m} is stable at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if deopt of {@code m} is stable at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isStableDeopt(Method m, CompLevel compLevel) {\n+        return TestVM.isStableDeopt(m, compLevel);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+    protected static final boolean DEOPT_BARRIERS_ALOT = (Boolean)WHITE_BOX.getVMFlag(\"DeoptimizeNMethodBarriersALot\");\n@@ -253,2 +254,5 @@\n-        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n-            checkAnnotationsInClass(clazz, \"inner\");\n+        \/\/ TODO remove this once JDK-8273591 is fixed\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+                checkAnnotationsInClass(clazz, \"inner\");\n+            }\n@@ -897,3 +901,2 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n-            TestRun.check(compiledByC1(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n-                          m + \" should have been deoptimized by C1\");\n+        if (isStableDeopt(m, CompLevel.C1_SIMPLE)) {\n+            TestRun.check(compiledByC1(m) != TriState.Yes, m + \" should have been deoptimized by C1\");\n@@ -904,3 +907,2 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n-            TestRun.check(compiledByC2(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n-                          m + \" should have been deoptimized by C2\");\n+        if (isStableDeopt(m, CompLevel.C2)) {\n+            TestRun.check(compiledByC2(m) != TriState.Yes, m + \" should have been deoptimized by C2\");\n@@ -913,1 +915,1 @@\n-    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n+    public static boolean isStableDeopt(Method m, CompLevel level) {\n@@ -915,0 +917,1 @@\n+                PER_METHOD_TRAP_LIMIT != 0 && PROFILE_INTERPRETER && !DEOPT_BARRIERS_ALOT &&\n@@ -970,1 +973,1 @@\n-        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS || FLIP_C1_C2 ||\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS || FLIP_C1_C2 || DEOPT_BARRIERS_ALOT ||\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,784 @@\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #42 #11; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #10\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #11\n+    Field #13 #14; \/\/ #12\n+    class #15; \/\/ #13\n+    NameAndType #16 #17; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #15\n+    Utf8 \"rect\"; \/\/ #16\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #17\n+    String #19; \/\/ #18\n+    Utf8 \"\"; \/\/ #19\n+    Field #13 #21; \/\/ #20\n+    NameAndType #22 #23; \/\/ #21\n+    Utf8 \"name\"; \/\/ #22\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n+    Field #8 #25; \/\/ #24\n+    NameAndType #26 #27; \/\/ #25\n+    Utf8 \"p1\"; \/\/ #26\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #27\n+    Field #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #32 #33; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #31\n+    Utf8 \"x\"; \/\/ #32\n+    Utf8 \"I\"; \/\/ #33\n+    Utf8 \"Code\"; \/\/ #34\n+    Utf8 \"LineNumberTable\"; \/\/ #35\n+    Utf8 \"getP1X\"; \/\/ #36\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #37\n+    Utf8 \"getP1\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"NamedRectangleN.java\"; \/\/ #41\n+    Utf8 \"<vnew>\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012AB80007;\n+            0xB5000C2A1212B500;\n+            0x14B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #36; \/\/ name_index\n+      #37; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B4;\n+            0x001CAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  31;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #42 #11; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #10\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #11\n+    Field #13 #14; \/\/ #12\n+    class #15; \/\/ #13\n+    NameAndType #16 #17; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #15\n+    Utf8 \"rect\"; \/\/ #16\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #17\n+    String #19; \/\/ #18\n+    Utf8 \"\"; \/\/ #19\n+    Field #13 #21; \/\/ #20\n+    NameAndType #22 #23; \/\/ #21\n+    Utf8 \"name\"; \/\/ #22\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n+    Field #8 #25; \/\/ #24\n+    NameAndType #26 #27; \/\/ #25\n+    Utf8 \"p1\"; \/\/ #26\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #27\n+    Field #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #32 #33; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #31\n+    Utf8 \"x\"; \/\/ #32\n+    Utf8 \"I\"; \/\/ #33\n+    Utf8 \"Code\"; \/\/ #34\n+    Utf8 \"LineNumberTable\"; \/\/ #35\n+    Utf8 \"getP1X\"; \/\/ #36\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #37\n+    Utf8 \"getP1\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"NamedRectangleP.java\"; \/\/ #41\n+    Utf8 \"<vnew>\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #23; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012AB80007;\n+            0xB5000C2A1212B500;\n+            0x14B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #36; \/\/ name_index\n+      #37; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B4;\n+            0x001CAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  31;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#34) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB4000CB40018B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#35) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleP\n+\n+class compiler\/valhalla\/inlinetypes\/PointN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x1\"; \/\/ #5                \/\/ field name changed from x to x1\n+    Utf8 \"I\"; \/\/ #6\n+    Field #1 #8; \/\/ #7\n+    NameAndType #9 #6; \/\/ #8\n+    Utf8 \"y\"; \/\/ #9\n+    InvokeDynamic 0s #11; \/\/ #10\n+    NameAndType #12 #13; \/\/ #11\n+    Utf8 \"toString\"; \/\/ #12\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/PointN;)Ljava\/lang\/String;\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"<vnew>\"; \/\/ #19\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"PointN.java\"; \/\/ #22\n+    Utf8 \"NestHost\"; \/\/ #23\n+    Utf8 \"BootstrapMethods\"; \/\/ #24\n+    MethodHandle 6b #26; \/\/ #25\n+    Method #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #29\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #30\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #31\n+    Utf8 \"InnerClasses\"; \/\/ #32\n+    class #34; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #34\n+    class #36; \/\/ #35\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #36\n+    Utf8 \"Lookup\"; \/\/ #37\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #12; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA000A0000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #19; \/\/ name_index\n+      #20; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B072A5FCC;\n+            0x00034B10072A5FCC;\n+            0x00074B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                11  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23) { \/\/ NestHost\n+      #14;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#24) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#32) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #33 #35 #37 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/PointN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleN {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #2\n+    Method #4 #5; \/\/ #3\n+    class #6; \/\/ #4\n+    NameAndType #7 #8; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #8\n+    Field #1 #10; \/\/ #9\n+    NameAndType #11 #12; \/\/ #10\n+    Utf8 \"p0\"; \/\/ #11\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Field #1 #14; \/\/ #13\n+    NameAndType #15 #12; \/\/ #14\n+    Utf8 \"p1\"; \/\/ #15\n+    InvokeDynamic 0s #17; \/\/ #16\n+    NameAndType #18 #19; \/\/ #17\n+    Utf8 \"toString\"; \/\/ #18\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleN;)Ljava\/lang\/String;\"; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #25\n+    Utf8 \"SourceFile\"; \/\/ #26\n+    Utf8 \"RectangleN.java\"; \/\/ #27\n+    Utf8 \"NestHost\"; \/\/ #28\n+    Utf8 \"BootstrapMethods\"; \/\/ #29\n+    MethodHandle 6b #31; \/\/ #30\n+    Method #32 #33; \/\/ #31\n+    class #34; \/\/ #32\n+    NameAndType #35 #36; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n+    Utf8 \"InnerClasses\"; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n+    Utf8 \"Lookup\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #15; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #18; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00100000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #25; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014BB800032A;\n+            0x5FCC00094BB80003;\n+            0x2A5FCC000D4B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                13  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#26) { \/\/ SourceFile\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28) { \/\/ NestHost\n+      #20;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#29) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #30; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#37) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #38 #40 #42 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #2\n+    Method #4 #5; \/\/ #3\n+    class #6; \/\/ #4\n+    NameAndType #7 #8; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #8\n+    Field #1 #10; \/\/ #9\n+    NameAndType #11 #12; \/\/ #10\n+    Utf8 \"p0\"; \/\/ #11\n+    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #12\n+    Field #1 #14; \/\/ #13\n+    NameAndType #15 #12; \/\/ #14\n+    Utf8 \"p1\"; \/\/ #15\n+    InvokeDynamic 0s #17; \/\/ #16\n+    NameAndType #18 #19; \/\/ #17\n+    Utf8 \"toString\"; \/\/ #18\n+    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleP;)Ljava\/lang\/String;\"; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #25\n+    Utf8 \"SourceFile\"; \/\/ #26\n+    Utf8 \"RectangleP.java\"; \/\/ #27\n+    Utf8 \"NestHost\"; \/\/ #28\n+    Utf8 \"BootstrapMethods\"; \/\/ #29\n+    MethodHandle 6b #31; \/\/ #30\n+    Method #32 #33; \/\/ #31\n+    class #34; \/\/ #32\n+    NameAndType #35 #36; \/\/ #33\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n+    Utf8 \"InnerClasses\"; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n+    class #41; \/\/ #40\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n+    Utf8 \"Lookup\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #1;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0012; \/\/ access  \/\/ Access flags have been modified to make field p1 private\n+      #15; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #18; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00100000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #25; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014BB800032A;\n+            0x5FCC00094BB80003;\n+            0x2A5FCC000D4B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                4  27;\n+                13  28;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#26) { \/\/ SourceFile\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28) { \/\/ NestHost\n+      #20;\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#29) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #30; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#37) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #38 #40 #42 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleP\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":784,"deletions":0,"binary":false,"changes":784,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.IRNode;\n+\n+public class InlineTypeIRNode {\n+    private static final String PREFIX = \"_#\";\n+    private static final String POSTFIX = \"#I_\";\n+    public static final String ALLOC_G = PREFIX + \"ALLOC_G\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOC_G, InlineTypeRegexes.ALLOC_G);\n+    }\n+\n+    public static final String ALLOCA_G = PREFIX + \"ALLOCA_G\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOCA_G, InlineTypeRegexes.ALLOCA_G);\n+    }\n+\n+    public static final String MYVALUE_ARRAY_KLASS = PREFIX + \"MYVALUE_ARRAY_KLASS\" + POSTFIX;    static {\n+        IRNode.optoOnly(MYVALUE_ARRAY_KLASS, InlineTypeRegexes.MYVALUE_ARRAY_KLASS);\n+    }\n+\n+    public static final String ALLOC = PREFIX + \"ALLOC\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOC, InlineTypeRegexes.ALLOC);\n+    }\n+\n+    public static final String ALLOCA = PREFIX + \"ALLOCA\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(ALLOCA, InlineTypeRegexes.ALLOCA);\n+    }\n+\n+    public static final String LOAD = PREFIX + \"LOAD\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOAD, InlineTypeRegexes.LOAD);\n+    }\n+\n+    public static final String LOADK = PREFIX + \"LOADK\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOADK, InlineTypeRegexes.LOADK);\n+    }\n+\n+    public static final String STORE = PREFIX + \"STORE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(STORE, InlineTypeRegexes.STORE);\n+    }\n+\n+    public static final String LOOP = PREFIX + \"LOOP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOOP, InlineTypeRegexes.LOOP);\n+    }\n+\n+    public static final String COUNTEDLOOP = PREFIX + \"COUNTEDLOOP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(COUNTEDLOOP, InlineTypeRegexes.COUNTEDLOOP);\n+    }\n+\n+    public static final String COUNTEDLOOP_MAIN = PREFIX + \"COUNTEDLOOP_MAIN\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(COUNTEDLOOP_MAIN, InlineTypeRegexes.COUNTEDLOOP_MAIN);\n+    }\n+\n+    public static final String TRAP = PREFIX + \"TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(TRAP, InlineTypeRegexes.TRAP);\n+    }\n+\n+    public static final String LINKTOSTATIC = PREFIX + \"LINKTOSTATIC\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LINKTOSTATIC, InlineTypeRegexes.LINKTOSTATIC);\n+    }\n+\n+    public static final String NPE = PREFIX + \"NPE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(NPE, InlineTypeRegexes.NPE);\n+    }\n+\n+    public static final String CALL = PREFIX + \"CALL\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CALL, InlineTypeRegexes.CALL);\n+    }\n+\n+    public static final String CALL_LEAF = PREFIX + \"CALL_LEAF\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CALL_LEAF, InlineTypeRegexes.CALL_LEAF);\n+    }\n+\n+    public static final String CALL_LEAF_NOFP = PREFIX + \"CALL_LEAF_NOFP\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CALL_LEAF_NOFP, InlineTypeRegexes.CALL_LEAF_NOFP);\n+    }\n+\n+    public static final String CALL_UNSAFE = PREFIX + \"CALL_UNSAFE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CALL_UNSAFE, InlineTypeRegexes.CALL_UNSAFE);\n+    }\n+\n+    public static final String STORE_INLINE_FIELDS = PREFIX + \"STORE_INLINE_FIELDS\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(STORE_INLINE_FIELDS, InlineTypeRegexes.STORE_INLINE_FIELDS);\n+    }\n+\n+    public static final String SCOBJ = PREFIX + \"SCOBJ\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(SCOBJ, InlineTypeRegexes.SCOBJ);\n+    }\n+\n+    public static final String LOAD_UNKNOWN_INLINE = PREFIX + \"LOAD_UNKNOWN_INLINE\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(LOAD_UNKNOWN_INLINE, InlineTypeRegexes.LOAD_UNKNOWN_INLINE);\n+    }\n+\n+    public static final String STORE_UNKNOWN_INLINE = PREFIX + \"STORE_UNKNOWN_INLINE\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(STORE_UNKNOWN_INLINE, InlineTypeRegexes.STORE_UNKNOWN_INLINE);\n+    }\n+\n+    public static final String INLINE_ARRAY_NULL_GUARD = PREFIX + \"INLINE_ARRAY_NULL_GUARD\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(INLINE_ARRAY_NULL_GUARD, InlineTypeRegexes.INLINE_ARRAY_NULL_GUARD);\n+    }\n+\n+    public static final String INTRINSIC_SLOW_PATH = PREFIX + \"INTRINSIC_SLOW_PATH\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(INTRINSIC_SLOW_PATH, InlineTypeRegexes.INTRINSIC_SLOW_PATH);\n+    }\n+\n+    public static final String CLONE_INTRINSIC_SLOW_PATH = PREFIX + \"CLONE_INTRINSIC_SLOW_PATH\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CLONE_INTRINSIC_SLOW_PATH, InlineTypeRegexes.CLONE_INTRINSIC_SLOW_PATH);\n+    }\n+\n+    public static final String CLASS_CHECK_TRAP = PREFIX + \"CLASS_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CLASS_CHECK_TRAP, InlineTypeRegexes.CLASS_CHECK_TRAP);\n+    }\n+\n+    public static final String NULL_CHECK_TRAP = PREFIX + \"NULL_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(NULL_CHECK_TRAP, InlineTypeRegexes.NULL_CHECK_TRAP);\n+    }\n+\n+    public static final String NULL_ASSERT_TRAP = PREFIX + \"NULL_ASSERT_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(NULL_ASSERT_TRAP, InlineTypeRegexes.NULL_ASSERT_TRAP);\n+    }\n+\n+    public static final String RANGE_CHECK_TRAP = PREFIX + \"RANGE_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(RANGE_CHECK_TRAP, InlineTypeRegexes.RANGE_CHECK_TRAP);\n+    }\n+\n+    public static final String UNHANDLED_TRAP = PREFIX + \"UNHANDLED_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(UNHANDLED_TRAP, InlineTypeRegexes.UNHANDLED_TRAP);\n+    }\n+\n+    public static final String PREDICATE_TRAP = PREFIX + \"PREDICATE_TRAP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(PREDICATE_TRAP, InlineTypeRegexes.PREDICATE_TRAP);\n+    }\n+\n+    public static final String MEMBAR = PREFIX + \"MEMBAR\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(MEMBAR, InlineTypeRegexes.MEMBAR);\n+    }\n+\n+    public static final String CHECKCAST_ARRAY = PREFIX + \"CHECKCAST_ARRAY\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CHECKCAST_ARRAY, InlineTypeRegexes.CHECKCAST_ARRAY);\n+    }\n+\n+    public static final String CHECKCAST_ARRAYCOPY = PREFIX + \"CHECKCAST_ARRAYCOPY\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(CHECKCAST_ARRAYCOPY, InlineTypeRegexes.CHECKCAST_ARRAYCOPY);\n+    }\n+\n+    public static final String JLONG_ARRAYCOPY = PREFIX + \"JLONG_ARRAYCOPY\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(JLONG_ARRAYCOPY, InlineTypeRegexes.JLONG_ARRAYCOPY);\n+    }\n+\n+    public static final String FIELD_ACCESS = PREFIX + \"FIELD_ACCESS\" + POSTFIX;\n+    static {\n+        IRNode.optoOnly(FIELD_ACCESS, InlineTypeRegexes.FIELD_ACCESS);\n+    }\n+\n+    public static final String SUBSTITUTABILITY_TEST = PREFIX + \"SUBSTITUTABILITY_TEST\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(SUBSTITUTABILITY_TEST, InlineTypeRegexes.SUBSTITUTABILITY_TEST);\n+    }\n+\n+    public static final String CMPP = PREFIX + \"CMPP\" + POSTFIX;\n+    static {\n+        IRNode.beforeMatching(CMPP, InlineTypeRegexes.CMPP);\n+    }\n+\n+    \/\/ Dummy method to call to force the static initializer blocks to be run before starting the IR framework.\n+    public static void forceStaticInitialization() {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+public class InlineTypeRegexes {\n+    \/\/ Regular expressions used to match nodes in the PrintIdeal output\n+    private static final String START = \"(\\\\d+ (.*\";\n+    private static final String MID = \".*)+ ===.*\";\n+    private static final String END = \")\";\n+    \/\/ Generic allocation\n+    public static final String ALLOC_G = \"(.*call,static.*wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOCA_G = \"(.*call,static.*wrapper for: _new_array_Java\" + END;\n+    \/\/ Inline type allocation\n+    public static final String MYVALUE_ARRAY_KLASS = \"\\\\[(precise )?compiler\/valhalla\/inlinetypes\/MyValue\";\n+    public static final String ALLOC = \"(.*precise compiler\/valhalla\/inlinetypes\/MyValue.*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*_new_instance_Java\" + END;\n+    public static final String ALLOCA = \"(.*\" + MYVALUE_ARRAY_KLASS + \".*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*_new_array_Java\" + END;\n+    public static final String LOAD = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n+    public static final String LOADK = START + \"LoadK\" + MID + END;\n+    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n+    public static final String LOOP = START + \"Loop\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*(unstable_if|predicate)\" + END;\n+    public static final String LINKTOSTATIC = START + \"CallStaticJava\" + MID + \"linkToStatic\" + END;\n+    public static final String NPE = START + \"CallStaticJava\" + MID + \"null_check\" + END;\n+    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n+    public static final String CALL_LEAF = \"(CALL, runtime leaf|call_leaf,runtime)\";\n+    public static final String CALL_LEAF_NOFP = \"(CALL, runtime leaf nofp|call_leaf_nofp,runtime)\";\n+    protected static final String CALL_UNSAFE = START + \"CallStaticJava\" + MID + \"# Static  jdk.internal.misc.Unsafe::\" + END;\n+    public static final String STORE_INLINE_FIELDS = START + \"CallStaticJava\" + MID + \"store_inline_type_fields\" + END;\n+    public static final String SCOBJ = \"(.*# ScObj.*\" + END;\n+    public static final String LOAD_UNKNOWN_INLINE = START + \"CallStaticJava\" + MID + \"_load_unknown_inline\" + END;\n+    public static final String STORE_UNKNOWN_INLINE = \"(.*\" + CALL_LEAF + \".*store_unknown_inline.*\" + END;\n+    public static final String INLINE_ARRAY_NULL_GUARD = \"(.*call,static.*wrapper for: uncommon_trap.*reason='null_check' action='none'.*\" + END;\n+    public static final String INTRINSIC_SLOW_PATH = \"(.*call,static.*wrapper for: uncommon_trap.*reason='intrinsic_or_type_checked_inlining'.*\" + END;\n+    public static final String CLONE_INTRINSIC_SLOW_PATH = \"(.*call,static.*java.lang.Object::clone.*\" + END;\n+    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n+    public static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n+    public static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n+    public static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n+    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n+    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n+    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n+    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    public static final String CHECKCAST_ARRAYCOPY = \"(.*\" + CALL_LEAF_NOFP + \".*checkcast_arraycopy.*\" + END;\n+    public static final String JLONG_ARRAYCOPY = \"(.*\" + CALL_LEAF_NOFP + \".*jlong_disjoint_arraycopy.*\" + END;\n+    public static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n+    public static final String SUBSTITUTABILITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.runtime.ValueObjectMethods::isSubstitutable\" + END;\n+    public static final String CMPP = START + \"(CmpP|CmpN)\" + MID + \"\" + END;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.test.lib.Utils;\n+import compiler.lib.ir_framework.Scenario;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+public class InlineTypes {\n+    public static final int  rI = Utils.getRandomInstance().nextInt() % 1000;\n+    public static final long rL = Utils.getRandomInstance().nextLong() % 1000;\n+    public static final double rD = Utils.getRandomInstance().nextDouble() % 1000;\n+\n+    public static final Scenario[] DEFAULT_SCENARIOS = {\n+            new Scenario(0,\n+                         \"-XX:+EnableValhalla\",\n+                         \"-XX:+EnablePrimitiveClasses\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-XX:-UseACmpProfile\",\n+                         \"-XX:+AlwaysIncrementalInline\",\n+                         \"-XX:FlatArrayElementMaxOops=5\",\n+                         \"-XX:FlatArrayElementMaxSize=-1\",\n+                         \"-XX:-UseArrayLoadStoreProfile\",\n+                         \"-XX:InlineFieldMaxFlatSize=-1\",\n+                         \"-XX:+InlineTypePassFieldsAsArgs\",\n+                         \"-XX:+InlineTypeReturnedAsFields\"\n+            ),\n+            new Scenario(1,\n+                         \"-XX:+EnableValhalla\",\n+                         \"-XX:+EnablePrimitiveClasses\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-XX:-UseACmpProfile\",\n+                         \"-XX:-UseCompressedOops\",\n+                         \"-XX:FlatArrayElementMaxOops=5\",\n+                         \"-XX:FlatArrayElementMaxSize=-1\",\n+                         \"-XX:-UseArrayLoadStoreProfile\",\n+                         \"-XX:InlineFieldMaxFlatSize=-1\",\n+                         \"-XX:-InlineTypePassFieldsAsArgs\",\n+                         \"-XX:-InlineTypeReturnedAsFields\"\n+            ),\n+            new Scenario(2,\n+                         \"-XX:+EnableValhalla\",\n+                         \"-XX:+EnablePrimitiveClasses\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-XX:-UseACmpProfile\",\n+                         \"-XX:-UseCompressedOops\",\n+                         \"-XX:FlatArrayElementMaxOops=0\",\n+                         \"-XX:FlatArrayElementMaxSize=0\",\n+                         \"-XX:-UseArrayLoadStoreProfile\",\n+                         \"-XX:InlineFieldMaxFlatSize=-1\",\n+                         \"-XX:+InlineTypePassFieldsAsArgs\",\n+                         \"-XX:+InlineTypeReturnedAsFields\",\n+                         \"-XX:+StressInlineTypeReturnedAsFields\"\n+            ),\n+            new Scenario(3,\n+                         \"-XX:+EnableValhalla\",\n+                         \"-XX:+EnablePrimitiveClasses\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-DVerifyIR=false\",\n+                         \"-XX:+AlwaysIncrementalInline\",\n+                         \"-XX:FlatArrayElementMaxOops=0\",\n+                         \"-XX:FlatArrayElementMaxSize=0\",\n+                         \"-XX:InlineFieldMaxFlatSize=0\",\n+                         \"-XX:+InlineTypePassFieldsAsArgs\",\n+                         \"-XX:+InlineTypeReturnedAsFields\"\n+            ),\n+            new Scenario(4,\n+                         \"-XX:+EnableValhalla\",\n+                         \"-XX:+EnablePrimitiveClasses\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-DVerifyIR=false\",\n+                         \"-XX:FlatArrayElementMaxOops=-1\",\n+                         \"-XX:FlatArrayElementMaxSize=-1\",\n+                         \"-XX:InlineFieldMaxFlatSize=0\",\n+                         \"-XX:+InlineTypePassFieldsAsArgs\",\n+                         \"-XX:-InlineTypeReturnedAsFields\",\n+                         \"-XX:-ReduceInitialCardMarks\"\n+            ),\n+            new Scenario(5,\n+                         \"-XX:+EnableValhalla\",\n+                         \"-XX:+EnablePrimitiveClasses\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-XX:-UseACmpProfile\",\n+                         \"-XX:+AlwaysIncrementalInline\",\n+                         \"-XX:FlatArrayElementMaxOops=5\",\n+                         \"-XX:FlatArrayElementMaxSize=-1\",\n+                         \"-XX:-UseArrayLoadStoreProfile\",\n+                         \"-XX:InlineFieldMaxFlatSize=-1\",\n+                         \"-XX:-InlineTypePassFieldsAsArgs\",\n+                         \"-XX:-InlineTypeReturnedAsFields\"\n+            )\n+    };\n+\n+    public static TestFramework getFramework() {\n+        InlineTypeIRNode.forceStaticInitialization();\n+        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+        return new TestFramework(walker.getCallerClass()).setDefaultWarmup(251);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ GENERATED FROM THE FOLLOWING JAVA FILE:\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+primitive class MyValue5 {\n+    public int x = 42;\n+\n+    public MyValue5 withField(int x) {\n+        return __WithField(this.x, x);\n+    }\n+\n+    public static MyValue5.ref withField(MyValue5.ref val, int x) {\n+        return __WithField(val.x, x);\n+    }\n+}\n+*\/\n+\n+class compiler\/valhalla\/inlinetypes\/MyValue5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8\n+    Utf8 \"withField\"; \/\/ #9\n+    Utf8 \"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue5;I)Lcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #13\n+    Utf8 \"<vnew>\"; \/\/ #14\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #15\n+    Utf8 \"SourceFile\"; \/\/ #16\n+    Utf8 \"MyValue5.java\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0011; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index\n+      #13; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  11;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #14; \/\/ name_index\n+      #15; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#16) { \/\/ SourceFile\n+      #17;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue5\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,3561 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline type arrays\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestArrays.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestArrays\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestArrays {\n+\n+    public static void main(String[] args) {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[2].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+        scenarios[3].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\", \"-XX:-UncommonNullCast\");\n+        scenarios[4].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n+        scenarios[5].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class, MyValue2.class, MyValue2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Helper methods and classes\n+\n+    protected long hash() {\n+        return hash(rI, rL);\n+    }\n+\n+    protected long hash(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y).hash();\n+    }\n+\n+    static void verify(Object[] src, Object[] dst) {\n+        if (src instanceof MyInterface[] && dst instanceof MyInterface[]) {\n+            for (int i = 0; i < src.length; ++i) {\n+                Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());\n+            }\n+        } else {\n+            for (int i = 0; i < src.length; ++i) {\n+                Asserts.assertEQ(src[i], dst[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue1[] src, MyValue1[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    static void verify(MyValue1[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+        }\n+    }\n+\n+    static void verify(MyValue2[] src, MyValue2[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    static void verify(MyValue2[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+        }\n+    }\n+\n+    static boolean compile_and_run_again_if_deoptimized(RunInfo info) {\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            if (TestFramework.isCompiled(m)) {\n+                TestFramework.compile(m, CompLevel.C2);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    primitive static class NotFlattenable {\n+        private final Object o1 = null;\n+        private final Object o2 = null;\n+        private final Object o3 = null;\n+        private final Object o4 = null;\n+        private final Object o5 = null;\n+        private final Object o6 = null;\n+    }\n+\n+    \/\/ Test inline type array creation and initialization\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {ALLOCA, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {ALLOCA, \"= 1\"},\n+        failOn = LOAD)\n+    public MyValue1[] test1(int len) {\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        int len = Math.abs(rI % 10);\n+        MyValue1[] va = test1(len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash());\n+        }\n+    }\n+\n+    \/\/ Test creation of an inline type array and element access\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public long test2() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = MyValue1.createWithFieldsInline(rI, rL);\n+        return va[0].hash();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        long result = test2();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Test receiving an inline type array from the interpreter,\n+    \/\/ updating its elements in a loop and computing a hash.\n+    @Test\n+    @IR(failOn = ALLOCA)\n+    public long test3(MyValue1[] va) {\n+        long result = 0;\n+        for (int i = 0; i < 10; ++i) {\n+            result += va[i].hash();\n+            va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        MyValue1[] va = new MyValue1[10];\n+        long expected = 0;\n+        for (int i = 0; i < 10; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);\n+            expected += va[i].hash();\n+        }\n+        long result = test3(va);\n+        Asserts.assertEQ(expected, result);\n+        for (int i = 0; i < 10; ++i) {\n+            if (va[i].hash() != hash(rI + 1, rL + 1)) {\n+                Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));\n+            }\n+        }\n+    }\n+\n+    \/\/ Test returning an inline type array received from the interpreter\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    public MyValue1[] test4(MyValue1[] va) {\n+        return va;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        MyValue1[] va = new MyValue1[10];\n+        for (int i = 0; i < 10; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);\n+        }\n+        va = test4(va);\n+        for (int i = 0; i < 10; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));\n+        }\n+    }\n+\n+    \/\/ Merge inline type arrays created from two branches\n+    @Test\n+    public MyValue1[] test5(boolean b) {\n+        MyValue1[] va;\n+        if (b) {\n+            va = new MyValue1[5];\n+            for (int i = 0; i < 5; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            }\n+        } else {\n+            va = new MyValue1[10];\n+            for (int i = 0; i < 10; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);\n+            }\n+        }\n+        long sum = va[0].hashInterpreted();\n+        if (b) {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI, sum);\n+        } else {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1[] va = test5(true);\n+        Asserts.assertEQ(va.length, 5);\n+        Asserts.assertEQ(va[0].hash(), hash(rI, hash()));\n+        for (int i = 1; i < 5; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash());\n+        }\n+        va = test5(false);\n+        Asserts.assertEQ(va.length, 10);\n+        Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));\n+        for (int i = 1; i < 10; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));\n+        }\n+    }\n+\n+    \/\/ Test creation of inline type array with single element\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public MyValue1 test6() {\n+        MyValue1[] va = new MyValue1[1];\n+        return va[0];\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        MyValue1 v = test6();\n+        Asserts.assertEQ(v.hashPrimitive(), va[0].hashPrimitive());\n+    }\n+\n+    \/\/ Test default initialization of inline type arrays\n+    @Test\n+    @IR(failOn = LOAD)\n+    public MyValue1[] test7(int len) {\n+        return new MyValue1[len];\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        int len = Math.abs(rI % 10);\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] var = test7(len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ Test creation of inline type array with zero length\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, LOOP, TRAP})\n+    public MyValue1[] test8() {\n+        return new MyValue1[0];\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        MyValue1[] va = test8();\n+        Asserts.assertEQ(va.length, 0);\n+    }\n+\n+    static MyValue1[] test9_va;\n+\n+    \/\/ Test that inline type array loaded from field has correct type\n+    @Test\n+    @IR(failOn = LOOP)\n+    public long test9() {\n+        return test9_va[0].hash();\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9_va = new MyValue1[1];\n+        test9_va[0] = MyValue1.createWithFieldsInline(rI, rL);\n+        long result = test9();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Multi-dimensional arrays\n+    @Test\n+    public MyValue1[][][] test10(int len1, int len2, int len3) {\n+        MyValue1[][][] arr = new MyValue1[len1][len2][len3];\n+        for (int i = 0; i < len1; i++) {\n+            for (int j = 0; j < len2; j++) {\n+                for (int k = 0; k < len3; k++) {\n+                    arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);\n+                }\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        MyValue1[][][] arr = test10(2, 3, 4);\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                for (int k = 0; k < 4; k++) {\n+                    Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test11(MyValue1[][][] arr, long[] res) {\n+        int l = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            for (int j = 0; j < arr[i].length; j++) {\n+                for (int k = 0; k < arr[i][j].length; k++) {\n+                    res[l] = arr[i][j][k].hash();\n+                    l++;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        MyValue1[][][] arr = new MyValue1[2][3][4];\n+        long[] res = new long[2*3*4];\n+        long[] verif = new long[2*3*4];\n+        int l = 0;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                for (int k = 0; k < 4; k++) {\n+                    arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);\n+                    verif[l] = arr[i][j][k].hash();\n+                    l++;\n+                }\n+            }\n+        }\n+        test11(arr, res);\n+        for (int i = 0; i < verif.length; i++) {\n+            Asserts.assertEQ(res[i], verif[i]);\n+        }\n+    }\n+\n+    \/\/ Array load out of bounds (upper bound) at compile time\n+    @Test\n+    public int test12() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+        }\n+\n+        try {\n+            return va[arraySize + 1].x;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        Asserts.assertEQ(test12(), rI);\n+    }\n+\n+    \/\/ Array load  out of bounds (lower bound) at compile time\n+    @Test\n+    public int test13() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);\n+        }\n+\n+        try {\n+            return va[-arraySize].x;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        Asserts.assertEQ(test13(), rI);\n+    }\n+\n+    \/\/ Array load out of bound not known to compiler (both lower and upper bound)\n+    @Test\n+    public int test14(MyValue1[] va, int index)  {\n+        return va[index].x;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+\n+        int result;\n+        for (int i = -20; i < 20; i++) {\n+            try {\n+                result = test14(va, i);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                result = rI;\n+            }\n+            Asserts.assertEQ(result, rI);\n+        }\n+    }\n+\n+    \/\/ Array store out of bounds (upper bound) at compile time\n+    @Test\n+    public int test15() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        try {\n+            for (int i = 0; i <= arraySize; i++) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+            }\n+            return rI - 1;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        Asserts.assertEQ(test15(), rI);\n+    }\n+\n+    \/\/ Array store out of bounds (lower bound) at compile time\n+    @Test\n+    public int test16() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        try {\n+            for (int i = -1; i <= arraySize; i++) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+            }\n+            return rI - 1;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        Asserts.assertEQ(test16(), rI);\n+    }\n+\n+    \/\/ Array store out of bound not known to compiler (both lower and upper bound)\n+    @Test\n+    public int test17(MyValue1[] va, int index, MyValue1 vt)  {\n+        va[index] = vt;\n+        return va[index].x;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+        int result;\n+        for (int i = -20; i < 20; i++) {\n+            try {\n+                result = test17(va, i, vt);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                result = rI + 1;\n+            }\n+            Asserts.assertEQ(result, rI + 1);\n+        }\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            Asserts.assertEQ(va[i].x, rI + 1);\n+        }\n+    }\n+\n+    \/\/ clone() as stub call\n+    @Test\n+    public MyValue1[] test18(MyValue1[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] result = test18(va);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(result[i].hash(), va[i].hash());\n+        }\n+    }\n+\n+    \/\/ clone() as series of loads\/stores\n+    static MyValue1[] test19_orig = null;\n+\n+    @Test\n+    public MyValue1[] test19() {\n+        MyValue1[] va = new MyValue1[8];\n+        for (int i = 0; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test19_orig = va;\n+\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        MyValue1[] result = test19();\n+        for (int i = 0; i < test19_orig.length; ++i) {\n+            Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with oop fields\n+    @Test\n+    public void test20(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] dst = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test20(src, dst);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with no oop field\n+    @Test\n+    public void test21(MyValue2[] src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test21(src, dst);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with oop field and tightly\n+    \/\/ coupled allocation as dest\n+    @Test\n+    public MyValue1[] test22(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[src.length];\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] dst = test22(src);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with oop fields and tightly\n+    \/\/ coupled allocation as dest\n+    @Test\n+    public MyValue1[] test23(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[src.length + 10];\n+        System.arraycopy(src, 0, dst, 5, src.length);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] dst = test23(src);\n+        for (int i = 5; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array passed as Object\n+    @Test\n+    public void test24(MyValue1[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] dst1 = new MyValue1[len];\n+        Object[] dst2 = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test24(src, dst1);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst1[i].hash());\n+        }\n+        test24(src, dst2);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), ((MyValue1)dst2[i]).hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with no oop field\n+    @Test\n+    public void test25(MyValue2[] src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test25(src, dst);\n+        for (int i = 0; i < 8; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with oop fields\n+    @Test\n+    public void test26(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[] dst = new MyValue1[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test26(src, dst);\n+        for (int i = 0; i < 8; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with oop fields and offsets\n+    @Test\n+    public void test27(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 1, dst, 2, 6);\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[] dst = new MyValue1[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test27(src, dst);\n+        for (int i = 2; i < 8; ++i) {\n+            Asserts.assertEQ(src[i-1].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocations\n+    \/\/ TODO 8252027: Make sure this is optimized with ZGC\n+    @Test\n+    @IR(applyIf = {\"UseZGC\", \"false\"},\n+        failOn = {ALLOCA, LOOP, LOAD, TRAP})\n+    public MyValue2 test28() {\n+        MyValue2[] src = new MyValue2[10];\n+        src[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2[] dst = (MyValue2[])src.clone();\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 result = test28();\n+        Asserts.assertEQ(result.hash(), v.hash());\n+    }\n+\n+    \/\/ non escaping allocations\n+    \/\/ TODO 8227588: shouldn't this have the same IR matching rules as test6?\n+    \/\/ @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOCA, LOOP, LOAD, TRAP})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = {ALLOCA, LOOP, TRAP})\n+    public MyValue2 test29(MyValue2[] src) {\n+        MyValue2[] dst = new MyValue2[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        MyValue2[] src = new MyValue2[10];\n+        for (int i = 0; i < 10; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        MyValue2 v = test29(src);\n+        Asserts.assertEQ(src[0].hash(), v.hash());\n+    }\n+\n+    \/\/ non escaping allocation with uncommon trap that needs\n+    \/\/ eliminated inline type array element as debug info\n+    @Test\n+    public MyValue2 test30(MyValue2[] src, boolean flag) {\n+        MyValue2[] dst = new MyValue2[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        if (flag) { }\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(10000)\n+    public void test30_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[10];\n+        for (int i = 0; i < 10; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        MyValue2 v = test30(src, !info.isWarmUp());\n+        Asserts.assertEQ(src[0].hash(), v.hash());\n+    }\n+\n+\n+    \/\/ non escaping allocation with memory phi\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public long test31(boolean b, boolean deopt, Method m) {\n+        MyValue2[] src = new MyValue2[1];\n+        if (b) {\n+            src[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        } else {\n+            src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return src[0].hash();\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier(RunInfo info) {\n+        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);\n+        long result1 = test31(true, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result1, v1.hash());\n+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI + 1, rD + 1);\n+        long result2 = test31(false, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result2, v2.hash());\n+    }\n+\n+    \/\/ Tests with Object arrays and clone\/arraycopy\n+    \/\/ clone() as stub call\n+    @Test\n+    public Object[] test32(Object[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] result = (MyValue1[])test32(va);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test33(Object[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        Object[] result = test33(va);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());\n+            \/\/ Check that array has correct properties (null-ok)\n+            result[i] = null;\n+        }\n+    }\n+\n+    \/\/ clone() as series of loads\/stores\n+    static Object[] test34_orig = null;\n+\n+    @ForceInline\n+    public Object[] test34_helper(boolean flag) {\n+        Object[] va = null;\n+        if (flag) {\n+            va = new MyValue1[8];\n+            for (int i = 0; i < va.length; ++i) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+            }\n+        } else {\n+            va = new Object[8];\n+        }\n+        return va;\n+    }\n+\n+    @Test\n+    public Object[] test34(boolean flag) {\n+        Object[] va = test34_helper(flag);\n+        test34_orig = va;\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier(RunInfo info) {\n+        test34(false);\n+        for (int i = 0; i < 10; i++) { \/\/ make sure we do deopt\n+            Object[] result = test34(true);\n+            verify(test34_orig, result);\n+            \/\/ Check that array has correct properties (null-free)\n+            try {\n+                result[0] = null;\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            Object[] result = test34(true);\n+            verify(test34_orig, result);\n+            \/\/ Check that array has correct properties (null-free)\n+            try {\n+                result[0] = null;\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array of unknown size\n+    @Test\n+    public void test35(Object src, Object dst, int len) {\n+        System.arraycopy(src, 0, dst, 0, len);\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] dst1 = new MyValue1[len];\n+        Object[] dst2 = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test35(src, dst1, src.length);\n+        verify(src, dst1);\n+        test35(src, dst2, src.length);\n+        verify(src, dst2);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test35(src, dst1, src.length);\n+            verify(src, dst1);\n+        }\n+    }\n+\n+    @Test\n+    public void test36(Object src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test36(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test36(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test37(MyValue2[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test37(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test37(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test38(Object src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test38\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test38_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test38(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test38(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiledByC2(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test39(MyValue2[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test39(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test39(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test40(Object[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test40_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test40(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test40(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiledByC2(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test41(Object src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test41(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test41(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test42(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test42(src, dst);\n+        verify(src, dst);\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest());\n+        }\n+    }\n+\n+    \/\/ short arraycopy()'s\n+    @Test\n+    public void test43(Object src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[] dst = new MyValue1[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test43(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test43(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test44(Object src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test44(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test44(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test45(MyValue2[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test45(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test45(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test46(Object[] src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test46\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test46_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test46(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test46(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiledByC2(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test47(MyValue2[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test47(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test47(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test48(Object[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test48\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test48_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test48(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test48(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiledByC2(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test49(Object src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test49(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test49(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test50(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 0; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test50(src, dst);\n+        verify(src, dst);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1[] test51(MyValue1[] va) {\n+        Object[] res = Arrays.copyOf(va, va.length, MyValue1[].class);\n+        return (MyValue1[]) res;\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] result = test51(va);\n+        verify(va, result);\n+    }\n+\n+    static final MyValue1[] test52_va = new MyValue1[8];\n+\n+    @Test\n+    public MyValue1[] test52() {\n+        Object[] res = Arrays.copyOf(test52_va, 8, MyValue1[].class);\n+        return (MyValue1[]) res;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        for (int i = 0; i < 8; ++i) {\n+            test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] result = test52();\n+        verify(test52_va, result);\n+    }\n+\n+    @Test\n+    public MyValue1[] test53(Object[] va) {\n+        Object[] res = Arrays.copyOf(va, va.length, MyValue1[].class);\n+        return (MyValue1[]) res;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] result = test53(va);\n+        verify(result, va);\n+    }\n+\n+    @Test\n+    public Object[] test54(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        Object[] result = test54(va);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public Object[] test55(Object[] va) {\n+        return Arrays.copyOf(va, va.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        Object[] result = test55(va);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public MyValue1[] test56(Object[] va) {\n+        Object[] res = Arrays.copyOf(va, va.length, MyValue1[].class);\n+        return (MyValue1[]) res;\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        MyValue1[] result = test56(va);\n+        verify(result, va);\n+    }\n+\n+    @Test\n+    public Object[] test57(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length, klass);\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        Object[] result = test57(va, MyValue1[].class);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public Object[] test58(MyValue1[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length, klass);\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Object[] result = test58(va, MyValue1[].class);\n+            verify(va, result);\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            Object[] result = test58(va, MyValue1[].class);\n+            verify(va, result);\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test59(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length+1, MyValue1[].class);\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            verif[i] = va[i];\n+        }\n+        Object[] result = test59(va);\n+        verify(verif, result);\n+    }\n+\n+    @Test\n+    public Object[] test60(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length+1, klass);\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            verif[i] = (MyValue1)va[i];\n+        }\n+        Object[] result = test60(va, MyValue1[].class);\n+        verify(verif, result);\n+    }\n+\n+    @Test\n+    public Object[] test61(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length+1, klass);\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Integer[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = Integer.valueOf(rI);\n+        }\n+        Object[] result = test61(va, Integer[].class);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(va[i], result[i]);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test62_helper(int i, MyValue1[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = oa;\n+        } else {\n+            arr = va;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test62(MyValue1[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test62_helper(i, va, oa);\n+\n+        return Arrays.copyOf(arr, arr.length+1, arr.getClass());\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        Integer[] oa = new Integer[len];\n+        for (int i = 0; i < len; ++i) {\n+            oa[i] = Integer.valueOf(rI);\n+        }\n+        test62_helper(42, va, oa);\n+        Object[] result = test62(va, oa);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(oa[i], result[i]);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test63_helper(int i, MyValue1[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = va;\n+        } else {\n+            arr = oa;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test63(MyValue1[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test63_helper(i, va, oa);\n+\n+        return Arrays.copyOf(arr, arr.length+1, arr.getClass());\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            verif[i] = va[i];\n+        }\n+        Integer[] oa = new Integer[len];\n+        test63_helper(42, va, oa);\n+        Object[] result = test63(va, oa);\n+        verify(verif, result);\n+    }\n+\n+    \/\/ Test default initialization of inline type arrays: small array\n+    @Test\n+    public MyValue1[] test64() {\n+        return new MyValue1[8];\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1[] va = new MyValue1[8];\n+        MyValue1[] var = test64();\n+        for (int i = 0; i < 8; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ Test default initialization of inline type arrays: large array\n+    @Test\n+    public MyValue1[] test65() {\n+        return new MyValue1[32];\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        MyValue1[] va = new MyValue1[32];\n+        MyValue1[] var = test65();\n+        for (int i = 0; i < 32; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ Check init store elimination\n+    @Test\n+    @IR(counts = {ALLOCA, \"= 1\"})\n+    public MyValue1[] test66(MyValue1 vt) {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = vt;\n+        return va;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = test66(vt);\n+        Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());\n+    }\n+\n+    \/\/ Zeroing elimination and arraycopy\n+    @Test\n+    public MyValue1[] test67(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[16];\n+        System.arraycopy(src, 0, dst, 0, 13);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1[] va = new MyValue1[16];\n+        MyValue1[] var = test67(va);\n+        for (int i = 0; i < 16; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ A store with a default value can be eliminated\n+    @Test\n+    public MyValue1[] test68() {\n+        MyValue1[] va = new MyValue1[2];\n+        va[0] = va[1];\n+        return va;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] var = test68();\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ Requires individual stores to init array\n+    @Test\n+    public MyValue1[] test69(MyValue1 vt) {\n+        MyValue1[] va = new MyValue1[4];\n+        va[0] = vt;\n+        va[3] = vt;\n+        return va;\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = new MyValue1[4];\n+        va[0] = vt;\n+        va[3] = vt;\n+        MyValue1[] var = test69(vt);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ A store with a default value can be eliminated: same as test68\n+    \/\/ but store is further away from allocation\n+    @Test\n+    public MyValue1[] test70(MyValue1[] other) {\n+        other[1] = other[0];\n+        MyValue1[] va = new MyValue1[2];\n+        other[0] = va[1];\n+        va[0] = va[1];\n+        return va;\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] var = test70(va);\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());\n+        }\n+    }\n+\n+    \/\/ EA needs to consider oop fields in flattened arrays\n+    @Test\n+    public void test71() {\n+        int len = 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);\n+        }\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+        }\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        test71();\n+    }\n+\n+    \/\/ Test EA with leaf call to 'store_unknown_inline'\n+    @Test\n+    public void test72(Object[] o, boolean b, Object element) {\n+        Object[] arr1 = new Object[10];\n+        Object[] arr2 = new Object[10];\n+        if (b) {\n+            arr1 = o;\n+        }\n+        arr1[0] = element;\n+        arr2[0] = element;\n+    }\n+\n+    @Run(test = \"test72\")\n+    public void test72_verifier() {\n+        Object[] arr = new Object[1];\n+        Object elem = new Object();\n+        test72(arr, true, elem);\n+        test72(arr, false, elem);\n+    }\n+\n+    @Test\n+    public void test73(Object[] oa, MyValue1 v, Object o) {\n+        \/\/ TestLWorld.test38 use a C1 Phi node for the array. This test\n+        \/\/ adds the case where the stored value is a C1 Phi node.\n+        Object o2 = (o == null) ? v : o;\n+        oa[0] = v;  \/\/ The stored value is known to be flattenable\n+        oa[1] = o;  \/\/ The stored value may be flattenable\n+        oa[2] = o2; \/\/ The stored value may be flattenable (a C1 Phi node)\n+        oa[0] = oa; \/\/ The stored value is known to be not flattenable (an Object[])\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);\n+        MyValue1[] arr = new MyValue1[3];\n+        try {\n+            test73(arr, v0, v1);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+        Asserts.assertEQ(arr[0].hash(), v0.hash());\n+        Asserts.assertEQ(arr[1].hash(), v1.hash());\n+        Asserts.assertEQ(arr[2].hash(), v1.hash());\n+    }\n+\n+    public static void test74Callee(MyValue1[] va) { }\n+\n+    \/\/ Tests invoking unloaded method with inline type array in signature\n+    @Test\n+    public void test74(MethodHandle m, MyValue1[] va) throws Throwable {\n+        m.invoke(va);\n+    }\n+\n+    @Run(test = \"test74\")\n+    @Warmup(0)\n+    public void test74_verifier() throws Throwable {\n+        MethodHandle m = MethodHandles.lookup().findStatic(TestArrays.class, \"test74Callee\", MethodType.methodType(void.class, MyValue1[].class));\n+        MyValue1[] va = new MyValue1[0];\n+        test74(m, va);\n+    }\n+\n+    \/\/ Some more array clone tests\n+    @ForceInline\n+    public Object[] test75_helper(int i, MyValue1[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = oa;\n+        } else {\n+            arr = va;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test75(MyValue1[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test75_helper(i, va, oa);\n+        return arr.clone();\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        Integer[] oa = new Integer[len];\n+        for (int i = 0; i < len; ++i) {\n+            oa[i] = Integer.valueOf(rI);\n+        }\n+        test75_helper(42, va, oa);\n+        Object[] result = test75(va, oa);\n+\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(oa[i], result[i]);\n+            \/\/ Check that array has correct properties (null-ok)\n+            result[i] = null;\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test76_helper(int i, MyValue1[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = va;\n+        } else {\n+            arr = oa;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test76(MyValue1[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test76_helper(i, va, oa);\n+        return arr.clone();\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            verif[i] = va[i];\n+        }\n+        Integer[] oa = new Integer[len];\n+        test76_helper(42, va, oa);\n+        Object[] result = test76(va, oa);\n+        verify(verif, result);\n+        \/\/ Check that array has correct properties (null-free)\n+        if (len > 0) {\n+            try {\n+                result[0] = null;\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test77() {\n+        MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);\n+        MyValue1[] arr = new MyValue1[1];\n+\n+        Object[] oa = arr;\n+        Object o1 = v1;\n+        Object o = (o1 == null) ? v0 : o1;\n+\n+        oa[0] = o; \/\/ For C1, due to IfOp optimization, the declared_type of o becomes NULL.\n+\n+        Asserts.assertEQ(arr[0].hash(), v1.hash());\n+    }\n+\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() {\n+        test77();\n+    }\n+\n+    @Test\n+    public long test78(MyValue1 v, int n) {\n+        long x = 0;\n+        for (int i = 0; i<n; i++) {\n+        }\n+\n+        MyValue1[] a = new MyValue1[n];\n+        a[0] = v;\n+        for (int i = 0; i<n; i++) {\n+            x += a[i].hash(); \/\/ C1 PhiSimplifier changes \"a\" from a Phi node to a NewObjectArray node\n+        }\n+\n+        return x;\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test78(v, 1), v.hash());\n+    }\n+\n+    \/\/ Verify that casting an array element to a non-flattenable type marks the array as not-flat\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE})\n+    public Object test79(Object[] array, int i) {\n+        Integer i1 = (Integer)array[0];\n+        Object o = array[1];\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        Integer i = Integer.valueOf(rI);\n+        Integer[] array = new Integer[2];\n+        array[1] = i;\n+        Object result = test79(array, 1);\n+        Asserts.assertEquals(result, i);\n+    }\n+\n+    \/\/ Same as test79 but with not-flattenable inline type\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE})\n+    public Object test80(Object[] array, int i) {\n+        NotFlattenable vt = (NotFlattenable)array[0];\n+        Object o = array[1];\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        NotFlattenable vt = new NotFlattenable();\n+        NotFlattenable[] array = new NotFlattenable[2];\n+        array[1] = vt;\n+        Object result = test80(array, 1);\n+        Asserts.assertEquals(result, vt);\n+    }\n+\n+    \/\/ Verify that writing an object of a non-inline, non-null type to an array marks the array as not-null-free and not-flat\n+    @Test\n+    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public Object test81(Object[] array, Integer v, Object o, int i) {\n+        if (v == null) {\n+          return null;\n+        }\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        Integer i = Integer.valueOf(rI);\n+        Integer[] array1 = new Integer[3];\n+        Object[] array2 = new Object[3];\n+        Object result = test81(array1, i, i, 0);\n+        Asserts.assertEquals(array1[0], i);\n+        Asserts.assertEquals(array1[1], i);\n+        Asserts.assertEquals(array1[2], i);\n+        Asserts.assertEquals(result, i);\n+        result = test81(array2, i, i, 1);\n+        Asserts.assertEquals(array2[0], i);\n+        Asserts.assertEquals(array2[1], i);\n+        Asserts.assertEquals(array2[2], i);\n+        Asserts.assertEquals(result, i);\n+    }\n+\n+    \/\/ Verify that writing an object of a non-flattenable inline type to an array marks the array as not-flat\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE})\n+    public Object test82(Object[] array, NotFlattenable vt, Object o, int i) {\n+        array[0] = vt;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        NotFlattenable vt = new NotFlattenable();\n+        NotFlattenable[] array1 = new NotFlattenable[3];\n+        Object[] array2 = new Object[3];\n+        Object result = test82(array1, vt, vt, 0);\n+        Asserts.assertEquals(array1[0], vt);\n+        Asserts.assertEquals(array1[1], vt);\n+        Asserts.assertEquals(array1[2], vt);\n+        Asserts.assertEquals(result, vt);\n+        result = test82(array2, vt, vt, 1);\n+        Asserts.assertEquals(array2[0], vt);\n+        Asserts.assertEquals(array2[1], vt);\n+        Asserts.assertEquals(array2[2], vt);\n+        Asserts.assertEquals(result, vt);\n+    }\n+\n+    \/\/ Verify that casting an array element to a non-inline type type marks the array as not-null-free and not-flat\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"},\n+        failOn = {ALLOCA_G, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+            failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public void test83(Object[] array, Object o) {\n+        Integer i = (Integer)array[0];\n+        array[1] = o;\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier() {\n+        Integer i = Integer.valueOf(rI);\n+        Integer[] array1 = new Integer[2];\n+        Object[] array2 = new Object[2];\n+        test83(array1, i);\n+        Asserts.assertEquals(array1[1], i);\n+        test83(array2, null);\n+        Asserts.assertEquals(array2[1], null);\n+    }\n+\n+    \/\/ Verify that writing constant null into an array marks the array as not-null-free and not-flat\n+    @Test\n+    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 1\"})\n+    public Object test84(Object[] array, int i) {\n+        array[0] = null;\n+        array[1] = null;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier(RunInfo info) {\n+        NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];\n+        Object[] array2 = new Object[2];\n+        Object result = test84(array1, 0);\n+        Asserts.assertEquals(array1[0], null);\n+        Asserts.assertEquals(result, null);\n+        result = test84(array2, 1);\n+        Asserts.assertEquals(array2[0], null);\n+        Asserts.assertEquals(result, null);\n+        if (!info.isWarmUp()) {\n+            NotFlattenable[] array3 = new NotFlattenable[2];\n+            try {\n+                test84(array3, 1);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test84 but with branches\n+    @Test\n+    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\"})\n+    public void test85(Object[] array, Object o, boolean b) {\n+        if (b) {\n+            array[0] = null;\n+        } else {\n+            array[1] = null;\n+        }\n+        array[1] = o;\n+    }\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier(RunInfo info) {\n+        Integer i = Integer.valueOf(rI);\n+        Integer[] array1 = new Integer[2];\n+        Object[] array2 = new Object[2];\n+        test85(array1, i, true);\n+        Asserts.assertEquals(array1[1], i);\n+        test85(array1, null, false);\n+        Asserts.assertEquals(array1[1], null);\n+        test85(array2, i, true);\n+        Asserts.assertEquals(array2[1], i);\n+        test85(array2, null, false);\n+        Asserts.assertEquals(array2[1], null);\n+        if (!info.isWarmUp()) {\n+            NotFlattenable[] array3 = new NotFlattenable[2];\n+            try {\n+                test85(array3, null, true);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test85 but with not-flattenable inline type array\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\", ALLOC_G, \"= 1\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\"})\n+    public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {\n+        if (b) {\n+            array[0] = null;\n+        } else {\n+            array[1] = null;\n+        }\n+        array[1] = o;\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier(RunInfo info) {\n+        NotFlattenable vt = new NotFlattenable();\n+        NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];\n+        test86(array1, vt, true);\n+        Asserts.assertEquals(array1[1], vt);\n+        test86(array1, null, false);\n+        Asserts.assertEquals(array1[1], null);\n+        if (!info.isWarmUp()) {\n+            NotFlattenable[] array2 = new NotFlattenable[2];\n+            try {\n+                test86(array2, null, true);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test85 but with inline type array\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\", ALLOC_G, \"= 1\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\"})\n+    public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {\n+        if (b) {\n+            array[0] = null;\n+        } else {\n+            array[1] = null;\n+        }\n+        array[1] = o;\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier(RunInfo info) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1.ref[] array1 = new MyValue1.ref[2];\n+        test87(array1, vt, true);\n+        Asserts.assertEquals(array1[1], vt);\n+        test87(array1, null, false);\n+        Asserts.assertEquals(array1[1], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] array2 = new MyValue1[2];\n+            try {\n+                test87(array2, null, true);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Additional correctness tests to make sure we have the required null checks\n+    @Test\n+    public void test88(Object[] array, Integer v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier(RunInfo info) {\n+        Integer[] array1 = new Integer[1];\n+        Object[] array2 = new Object[1];\n+        test88(array1, null);\n+        Asserts.assertEquals(array1[0], null);\n+        test88(array2, null);\n+        Asserts.assertEquals(array2[0], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] array3 = new MyValue1[1];\n+            try {\n+                test88(array3, null);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test89(MyValue1.ref[] array, Integer v) {\n+        Object o = v;\n+        array[0] = (MyValue1.ref)o;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier(RunInfo info) {\n+        MyValue1.ref[] array1 = new MyValue1.ref[1];\n+        test89(array1, null);\n+        Asserts.assertEquals(array1[0], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] array2 = new MyValue1[1];\n+            try {\n+                test89(array2, null);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public boolean test90() {\n+        boolean b = true;\n+\n+        MyValue1[] qArray = new MyValue1[0];\n+        MyValue1.ref[] lArray = new MyValue1.ref[0];\n+\n+        b = b && (qArray instanceof MyValue1[]);\n+        b = b && (lArray instanceof MyValue1.ref[]);\n+\n+        MyValue1[][] qArray2 = new MyValue1[0][0];\n+        MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];\n+\n+        b = b && (qArray2 instanceof MyValue1[][]);\n+        b = b && (lArray2 instanceof MyValue1.ref[][]);\n+\n+        return b;\n+    }\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier() {\n+        Asserts.assertEQ(test90(), true);\n+    }\n+\n+    primitive static final class Test91Value {\n+        public final int f0;\n+        public final int f1;\n+        public final int f2;\n+        public final int f3;\n+        public final int f4;\n+        public final int f5;\n+\n+        public Test91Value(int i) {\n+            this.f0 = i;\n+            this.f1 = i;\n+            this.f2 = i;\n+            this.f3 = i;\n+            this.f4 = i;\n+            this.f5 = i;\n+        }\n+\n+        public void verify() {\n+            if ((f0 != f1) || (f1 != f2) || (f2 != f3) || (f3 != f4) || (f4 != f5)) {\n+                throw new RuntimeException(\"test91 failed\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Test anti-dependencies between loads and stores from flattened array\n+    @Test\n+    public int test91(Test91Value[] array, int lo, int val) {\n+        int i = 3;\n+        while (lo < i) {\n+            Test91Value tmp = array[lo];\n+            array[lo++] = array[i];\n+            array[i--] = tmp;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test91\")\n+    @Warmup(0)\n+    public void test91_verifier() {\n+        Test91Value[] array = new Test91Value[5];\n+        for (int i = 0; i < 5; ++i) {\n+            array[i] = new Test91Value(i);\n+            array[i].verify();\n+        }\n+        Asserts.assertEQ(test91(array, 0, 5), 5);\n+        for (int i = 0; i < 5; ++i) {\n+            array[i].verify();\n+        }\n+    }\n+\n+    @Test\n+    public void test92(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier() {\n+        MyValue1[] a = new MyValue1[1];\n+        MyValue1[] b = new MyValue1[1];\n+        try {\n+            test92(a, null);\n+            throw new RuntimeException(\"Should throw NullPointerException\");\n+        } catch (NullPointerException expected) {}\n+\n+        try {\n+            test92(null, b);\n+            throw new RuntimeException(\"Should throw NullPointerException\");\n+        } catch (NullPointerException expected) {}\n+\n+        a[0] = MyValue1.createWithFieldsInline(rI, rL);\n+        test92(a, b);\n+        verify(a, b);\n+    }\n+\n+    \/\/ Same as test30 but accessing all elements of the non-escaping array\n+    @Test\n+    public long test93(MyValue2[] src, boolean flag) {\n+        MyValue2[] dst = new MyValue2[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        if (flag) {  }\n+        return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +\n+               dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[10];\n+        for (int i = 0; i < 10; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        long res = test93(src, !info.isWarmUp());\n+        long expected = 0;\n+        for (int i = 0; i < 10; ++i) {\n+            expected += src[i].hash();\n+        }\n+        Asserts.assertEQ(res, expected);\n+    }\n+\n+    \/\/ Same as test93 but with variable source array offset\n+    @Test\n+    public long test94(MyValue2[] src, int i, boolean flag) {\n+        MyValue2[] dst = new MyValue2[10];\n+        System.arraycopy(src, i, dst, 0, 1);\n+        if (flag) {  }\n+        return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +\n+               dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();\n+    }\n+\n+    @Run(test = \"test94\")\n+    @Warmup(10000)\n+    public void test94_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[10];\n+        for (int i = 0; i < 10; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        for (int i = 0; i < 10; ++i) {\n+            long res = test94(src, i, !info.isWarmUp());\n+            long expected = src[i].hash() + 9*MyValue2.default.hash();\n+            Asserts.assertEQ(res, expected);\n+        }\n+    }\n+\n+    \/\/ Test propagation of not null-free\/flat information\n+    @Test\n+    @IR(failOn = CHECKCAST_ARRAY)\n+    public MyValue1[] test95(Object[] array) {\n+        array[0] = null;\n+        \/\/ Always throws a ClassCastException because we just successfully\n+        \/\/ stored null and therefore the array can't be an inline type array.\n+        return (MyValue1[])array;\n+    }\n+\n+    @Run(test = \"test95\")\n+    public void test95_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        Integer[] array2 = new Integer[1];\n+        try {\n+            test95(array1);\n+            throw new RuntimeException(\"Should throw NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test95(array2);\n+            throw new RuntimeException(\"Should throw ClassCastException\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test95 but with cmp user of cast result\n+    @Test\n+    @IR(failOn = CHECKCAST_ARRAY)\n+    public boolean test96(Object[] array) {\n+        array[0] = null;\n+        \/\/ Always throws a ClassCastException because we just successfully\n+        \/\/ stored null and therefore the array can't be an inline type array.\n+        MyValue1[] casted = (MyValue1[])array;\n+        return casted != null;\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        Integer[] array2 = new Integer[1];\n+        try {\n+            test96(array1);\n+            throw new RuntimeException(\"Should throw NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test96(array2);\n+            throw new RuntimeException(\"Should throw ClassCastException\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test95 but with instanceof instead of cast\n+    @Test\n+    @IR(failOn = CHECKCAST_ARRAY)\n+    public boolean test97(Object[] array) {\n+        array[0] = 42;\n+        \/\/ Always throws a ClassCastException because we just successfully stored\n+        \/\/ a non-inline value and therefore the array can't be an inline type array.\n+        return array instanceof MyValue1[];\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        Integer[] array2 = new Integer[1];\n+        try {\n+            test97(array1);\n+            throw new RuntimeException(\"Should throw ArrayStoreException\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        boolean res = test97(array2);\n+        Asserts.assertFalse(res);\n+    }\n+\n+    \/\/ Same as test95 but with non-flattenable store\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = CHECKCAST_ARRAY)\n+    public MyValue1[] test98(Object[] array) {\n+        array[0] = NotFlattenable.default;\n+        \/\/ Always throws a ClassCastException because we just successfully stored a\n+        \/\/ non-flattenable value and therefore the array can't be a flat array.\n+        return (MyValue1[])array;\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void test98_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        NotFlattenable[] array2 = new NotFlattenable[1];\n+        try {\n+            test98(array1);\n+            throw new RuntimeException(\"Should throw ArrayStoreException\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test98(array2);\n+            throw new RuntimeException(\"Should throw ClassCastException\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test98 but with cmp user of cast result\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = CHECKCAST_ARRAY)\n+    public boolean test99(Object[] array) {\n+        array[0] = NotFlattenable.default;\n+        \/\/ Always throws a ClassCastException because we just successfully stored a\n+        \/\/ non-flattenable value and therefore the array can't be a flat array.\n+        MyValue1[] casted = (MyValue1[])array;\n+        return casted != null;\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void test99_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        NotFlattenable[] array2 = new NotFlattenable[1];\n+        try {\n+            test99(array1);\n+            throw new RuntimeException(\"Should throw ArrayStoreException\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test99(array2);\n+            throw new RuntimeException(\"Should throw ClassCastException\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test98 but with instanceof instead of cast\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = CHECKCAST_ARRAY)\n+    public boolean test100(Object[] array) {\n+        array[0] = NotFlattenable.default;\n+        \/\/ Always throws a ClassCastException because we just successfully stored a\n+        \/\/ non-flattenable value and therefore the array can't be a flat array.\n+        return array instanceof MyValue1[];\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        NotFlattenable[] array2 = new NotFlattenable[1];\n+        try {\n+            test100(array1);\n+            throw new RuntimeException(\"Should throw ArrayStoreException\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        boolean res = test100(array2);\n+        Asserts.assertFalse(res);\n+    }\n+\n+    \/\/ Test that CHECKCAST_ARRAY matching works as expected\n+    @Test\n+    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    public boolean test101(Object[] array) {\n+        return array instanceof MyValue1[];\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        NotFlattenable[] array2 = new NotFlattenable[1];\n+        Asserts.assertTrue(test101(array1));\n+        Asserts.assertFalse(test101(array2));\n+    }\n+\n+    static final MyValue2[] val_src = new MyValue2[8];\n+    static final MyValue2[] val_dst = new MyValue2[8];\n+    static final Object[]   obj_src = new Object[8];\n+    static final Object[]   obj_null_src = new Object[8];\n+    static final Object[]   obj_dst = new Object[8];\n+\n+    static Object get_val_src() { return val_src; }\n+    static Object get_val_dst() { return val_dst; }\n+    static Class get_val_class() { return MyValue2[].class; }\n+    static Class get_int_class() { return Integer[].class; }\n+    static Object get_obj_src() { return obj_src; }\n+    static Object get_obj_null_src() { return obj_null_src; }\n+    static Object get_obj_dst() { return obj_dst; }\n+    static Class get_obj_class() { return Object[].class; }\n+\n+    static {\n+        for (int i = 0; i < 8; ++i) {\n+            val_src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            obj_src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            obj_null_src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        obj_null_src[0] = null;\n+    }\n+\n+    \/\/ Arraycopy with constant source and destination arrays\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = INTRINSIC_SLOW_PATH)\n+    public void test102() {\n+        System.arraycopy(val_src, 0, obj_dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier() {\n+        test102();\n+        verify(val_src, obj_dst);\n+    }\n+\n+    \/\/ Same as test102 but with MyValue2[] dst\n+    @Test\n+    @IR(failOn = INTRINSIC_SLOW_PATH)\n+    public void test103() {\n+        System.arraycopy(val_src, 0, val_dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test103\")\n+    public void test103_verifier() {\n+        test103();\n+        verify(val_src, val_dst);\n+    }\n+\n+    \/\/ Same as test102 but with Object[] src\n+    @Test\n+    @IR(failOn = INTRINSIC_SLOW_PATH)\n+    public void test104() {\n+        System.arraycopy(obj_src, 0, obj_dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test104\")\n+    public void test104_verifier() {\n+        test104();\n+        verify(obj_src, obj_dst);\n+    }\n+\n+    \/\/ Same as test103 but with Object[] src\n+    @Test\n+    @IR(counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    public void test105() {\n+        System.arraycopy(obj_src, 0, val_dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier() {\n+        test105();\n+        verify(obj_src, val_dst);\n+    }\n+\n+    \/\/ Same as test103 but with Object[] src containing null\n+    @Test\n+    @IR(counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    public void test105_null() {\n+        System.arraycopy(obj_null_src, 0, val_dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test105_null\")\n+    public void test105_null_verifier() {\n+        try {\n+            test105_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Below tests are equal to test102-test105 but hide the src\/dst types until\n+    \/\/ after the arraycopy intrinsic is emitted (with incremental inlining).\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = INTRINSIC_SLOW_PATH)\n+    public void test106() {\n+        System.arraycopy(get_val_src(), 0, get_obj_dst(), 0, 8);\n+    }\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier() {\n+        test106();\n+        verify(val_src, obj_dst);\n+    }\n+\n+    \/\/ TODO 8251971: Should be optimized but we are bailing out because\n+    \/\/ at parse time it looks as if src could be flat and dst could be not flat.\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = INTRINSIC_SLOW_PATH)\n+    public void test107() {\n+        System.arraycopy(get_val_src(), 0, get_val_dst(), 0, 8);\n+    }\n+\n+    @Run(test = \"test107\")\n+    public void test107_verifier() {\n+        test107();\n+        verify(val_src, val_dst);\n+    }\n+\n+    @Test\n+    @IR(failOn = INTRINSIC_SLOW_PATH)\n+    public void test108() {\n+        System.arraycopy(get_obj_src(), 0, get_obj_dst(), 0, 8);\n+    }\n+\n+    @Run(test = \"test108\")\n+    public void test108_verifier() {\n+        test108();\n+        verify(obj_src, obj_dst);\n+    }\n+\n+    @Test\n+    @IR(counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    public void test109() {\n+        System.arraycopy(get_obj_src(), 0, get_val_dst(), 0, 8);\n+    }\n+\n+    @Run(test = \"test109\")\n+    public void test109_verifier() {\n+        test109();\n+        verify(obj_src, val_dst);\n+    }\n+\n+    @Test\n+    @IR(counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    public void test109_null() {\n+        System.arraycopy(get_obj_null_src(), 0, get_val_dst(), 0, 8);\n+    }\n+\n+    @Run(test = \"test109_null\")\n+    public void test109_null_verifier() {\n+        try {\n+            test109_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Arrays.copyOf with constant source and destination arrays\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = {INTRINSIC_SLOW_PATH, CLASS_CHECK_TRAP})\n+    public Object[] test110() {\n+        return Arrays.copyOf(val_src, 8, Object[].class);\n+    }\n+\n+    @Run(test = \"test110\")\n+    public void test110_verifier() {\n+        Object[] res = test110();\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ Same as test110 but with MyValue2[] dst\n+    @Test\n+    @IR(failOn = {INTRINSIC_SLOW_PATH, CLASS_CHECK_TRAP})\n+    public Object[] test111() {\n+        return Arrays.copyOf(val_src, 8, MyValue2[].class);\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        Object[] res = test111();\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ Same as test110 but with Object[] src\n+    @Test\n+    @IR(failOn = {INTRINSIC_SLOW_PATH, CLASS_CHECK_TRAP})\n+    public Object[] test112() {\n+        return Arrays.copyOf(obj_src, 8, Object[].class);\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier() {\n+        Object[] res = test112();\n+        verify(obj_src, res);\n+    }\n+\n+    \/\/ Same as test111 but with Object[] src\n+    @Test\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n+    public Object[] test113() {\n+        return Arrays.copyOf(obj_src, 8, MyValue2[].class);\n+    }\n+\n+    @Run(test = \"test113\")\n+    public void test113_verifier() {\n+        Object[] res = test113();\n+        verify(obj_src, res);\n+    }\n+\n+    \/\/ Same as test111 but with Object[] src containing null\n+    @Test\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n+    public Object[] test113_null() {\n+        return Arrays.copyOf(obj_null_src, 8, MyValue2[].class);\n+    }\n+\n+    @Run(test = \"test113_null\")\n+    public void test113_null_verifier() {\n+        try {\n+            test113_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Below tests are equal to test110-test113 but hide the src\/dst types until\n+    \/\/ after the arraycopy intrinsic is emitted (with incremental inlining).\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {INTRINSIC_SLOW_PATH, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = {INTRINSIC_SLOW_PATH, CLASS_CHECK_TRAP})\n+    public Object[] test114() {\n+        return Arrays.copyOf((Object[])get_val_src(), 8, get_obj_class());\n+    }\n+\n+    @Run(test = \"test114\")\n+    public void test114_verifier() {\n+        Object[] res = test114();\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ TODO 8251971: Should be optimized but we are bailing out because\n+    \/\/ at parse time it looks as if src could be flat and dst could be not flat\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = {INTRINSIC_SLOW_PATH, CLASS_CHECK_TRAP})\n+    public Object[] test115() {\n+        return Arrays.copyOf((Object[])get_val_src(), 8, get_val_class());\n+    }\n+\n+    @Run(test = \"test115\")\n+    public void test115_verifier() {\n+        Object[] res = test115();\n+        verify(val_src, res);\n+    }\n+\n+    @Test\n+    @IR(failOn = {INTRINSIC_SLOW_PATH, CLASS_CHECK_TRAP})\n+    public Object[] test116() {\n+        return Arrays.copyOf((Object[])get_obj_src(), 8, get_obj_class());\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier() {\n+        Object[] res = test116();\n+        verify(obj_src, res);\n+    }\n+\n+    @Test\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n+    public Object[] test117() {\n+        return Arrays.copyOf((Object[])get_obj_src(), 8, get_val_class());\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        Object[] res = test117();\n+        verify(obj_src, res);\n+    }\n+\n+    @Test\n+    @IR(counts = {CLASS_CHECK_TRAP, \" = 1\"})\n+    public Object[] test117_null() {\n+        return Arrays.copyOf((Object[])get_obj_null_src(), 8, get_val_class());\n+    }\n+\n+    @Run(test = \"test117_null\")\n+    public void test117_null_verifier() {\n+        try {\n+            test117_null();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Some more Arrays.copyOf tests with only constant class\n+\n+    @Test\n+    @IR(counts = {CLASS_CHECK_TRAP, \"= 1\"},\n+        failOn = INTRINSIC_SLOW_PATH)\n+    public Object[] test118(Object[] src) {\n+        return Arrays.copyOf(src, 8, MyValue2[].class);\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        Object[] res = test118(obj_src);\n+        verify(obj_src, res);\n+        res = test118(val_src);\n+        verify(val_src, res);\n+        try {\n+            test118(obj_null_src);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test119(Object[] src) {\n+        return Arrays.copyOf(src, 8, Object[].class);\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier() {\n+        Object[] res = test119(obj_src);\n+        verify(obj_src, res);\n+        res = test119(val_src);\n+        verify(val_src, res);\n+    }\n+\n+    @Test\n+    @IR(counts = {CLASS_CHECK_TRAP, \"= 1\"},\n+        failOn = INTRINSIC_SLOW_PATH)\n+    public Object[] test120(Object[] src) {\n+        return Arrays.copyOf(src, 8, Integer[].class);\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test120(arr);\n+        verify(arr, res);\n+        try {\n+            test120(val_src);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test121(Object[] src) {\n+        return Arrays.copyOf(src, 8, MyValue2[].class);\n+    }\n+\n+    @Run(test = \"test121\")\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public void test121_verifier() {\n+        Object[] res = test121(obj_src);\n+        verify(obj_src, res);\n+        res = test121(val_src);\n+        verify(val_src, res);\n+        try {\n+            test121(obj_null_src);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test122(Object[] src) {\n+        return Arrays.copyOf(src, 8, get_val_class());\n+    }\n+\n+    @Run(test = \"test122\")\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public void test122_verifier() {\n+        Object[] res = test122(obj_src);\n+        verify(obj_src, res);\n+        res = test122(val_src);\n+        verify(val_src, res);\n+        try {\n+            test122(obj_null_src);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test123(Object[] src) {\n+        return Arrays.copyOf(src, 8, Integer[].class);\n+    }\n+\n+    @Run(test = \"test123\")\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public void test123_verifier() {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test123(arr);\n+        verify(arr, res);\n+        try {\n+            test123(val_src);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test124(Object[] src) {\n+        return Arrays.copyOf(src, 8, get_int_class());\n+    }\n+\n+    @Run(test = \"test124\")\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public void test124_verifier() {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test124(arr);\n+        verify(arr, res);\n+        try {\n+            test124(val_src);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test125(Object[] src, Class klass) {\n+        return Arrays.copyOf(src, 8, klass);\n+    }\n+\n+    @Run(test = \"test125\")\n+    @Warmup(10000) \/\/ Make sure we hit too_many_traps for the src <: dst check\n+    public void test125_verifier() {\n+        Integer[] arr = new Integer[8];\n+        for (int i = 0; i < 8; ++i) {\n+            arr[i] = rI + i;\n+        }\n+        Object[] res = test125(arr, Integer[].class);\n+        verify((Object[])arr, res);\n+        res = test125(val_src, MyValue2[].class);\n+        verify(val_src, res);\n+        res = test125(obj_src, MyValue2[].class);\n+        verify(val_src, res);\n+        try {\n+            test125(obj_null_src, MyValue2[].class);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            test125(arr, MyValue2[].class);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            test125(val_src, MyValue1[].class);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+\n+    \/\/ Verify that clone from (flat) inline type array not containing oops is always optimized.\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {JLONG_ARRAYCOPY, \"= 1\"},\n+        failOn = {CHECKCAST_ARRAYCOPY, CLONE_INTRINSIC_SLOW_PATH})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        failOn = CLONE_INTRINSIC_SLOW_PATH)\n+    public Object[] test126(MyValue2[] src) {\n+        return src.clone();\n+    }\n+\n+    @Run(test = \"test126\")\n+    public void test126_verifier() {\n+        Object[] res = test126(val_src);\n+        verify(val_src, res);\n+    }\n+\n+    \/\/ Verify correctness of generic_copy stub\n+    @Test\n+    public void test127(Object src, Object dst, int len) {\n+        System.arraycopy(src, 0, dst, 0, len);\n+    }\n+\n+    @Run(test = \"test127\")\n+    public void test127_verifier() {\n+        test127(val_src, obj_dst, 8);\n+        verify(val_src, obj_dst);\n+        test127(val_src, val_dst, 8);\n+        verify(val_src, val_dst);\n+        test127(obj_src, val_dst, 8);\n+        verify(obj_src, val_dst);\n+        try {\n+            test127(obj_null_src, val_dst, 8);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Verify that copyOf with known source and unknown destination class is optimized\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {JLONG_ARRAYCOPY, \"= 1\"},\n+        failOn = CHECKCAST_ARRAYCOPY)\n+    public Object[] test128(MyValue2[] src, Class klass) {\n+        return Arrays.copyOf(src, 8, klass);\n+    }\n+\n+    @Run(test = \"test128\")\n+    public void test128_verifier() {\n+        Object[] res = test128(val_src, MyValue2[].class);\n+        verify(val_src, res);\n+        res = test128(val_src, Object[].class);\n+        verify(val_src, res);\n+        try {\n+            test128(val_src, MyValue1[].class);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Arraycopy with non-array src\/dst\n+    @Test\n+    public void test129(Object src, Object dst, int len) {\n+        System.arraycopy(src, 0, dst, 0, len);\n+    }\n+\n+    @Run(test = \"test129\")\n+    public void test129_verifier() {\n+        try {\n+            test129(new Object(), new Object[0], 0);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            test129(new Object[0], new Object(), 0);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/\/ Empty inline type array access\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    public MyValueEmpty test130(MyValueEmpty[] array) {\n+        array[0] = new MyValueEmpty();\n+        return array[1];\n+    }\n+\n+    @Run(test = \"test130\")\n+    public void test130_verifier() {\n+        MyValueEmpty[] array = new MyValueEmpty[2];\n+        MyValueEmpty empty = test130(array);\n+        Asserts.assertEquals(array[0], MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    static primitive class EmptyContainer {\n+        MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    \/\/ Empty inline type container array access\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    public MyValueEmpty test131(EmptyContainer[] array) {\n+        array[0] = new EmptyContainer();\n+        return array[1].empty;\n+    }\n+\n+    @Run(test = \"test131\")\n+    public void test131_verifier() {\n+        EmptyContainer[] array = new EmptyContainer[2];\n+        MyValueEmpty empty = test131(array);\n+        Asserts.assertEquals(array[0], EmptyContainer.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Empty inline type array access with unknown array type\n+    @Test\n+    public Object test132(Object[] array) {\n+        array[0] = new MyValueEmpty();\n+        return array[1];\n+    }\n+\n+    @Run(test = \"test132\")\n+    public void test132_verifier() {\n+        Object[] array = new MyValueEmpty[2];\n+        Object empty = test132(array);\n+        Asserts.assertEquals(array[0], MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        array = new Object[2];\n+        empty = test132(array);\n+        Asserts.assertEquals(array[0], MyValueEmpty.default);\n+        Asserts.assertEquals(empty, null);\n+    }\n+\n+    \/\/ Empty inline type container array access with unknown array type\n+    @Test\n+    public Object test133(Object[] array) {\n+        array[0] = new EmptyContainer();\n+        return array[1];\n+    }\n+\n+    @Run(test = \"test133\")\n+    public void test133_verifier() {\n+        Object[] array = new EmptyContainer[2];\n+        Object empty = test133(array);\n+        Asserts.assertEquals(array[0], EmptyContainer.default);\n+        Asserts.assertEquals(empty, EmptyContainer.default);\n+        array = new Object[2];\n+        empty = test133(array);\n+        Asserts.assertEquals(array[0], EmptyContainer.default);\n+        Asserts.assertEquals(empty, null);\n+    }\n+\n+    \/\/ Non-escaping empty inline type array access\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    public static MyValueEmpty test134(MyValueEmpty val) {\n+        MyValueEmpty[] array = new MyValueEmpty[1];\n+        array[0] = val;\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test134\")\n+    public void test134_verifier() {\n+        MyValueEmpty empty = test134(MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test accessing a locked (inline type) array\n+    @Test\n+    public Object test135(Object[] array, Object val) {\n+        array[0] = val;\n+        return array[1];\n+    }\n+\n+    @Run(test = \"test135\")\n+    public void test135_verifier() {\n+        MyValue1[] array1 = new MyValue1[2];\n+        array1[1] = MyValue1.createWithFieldsInline(rI, rL);\n+        synchronized (array1) {\n+            Object res = test135(array1, array1[1]);\n+            Asserts.assertEquals(((MyValue1)res).hash(), array1[1].hash());\n+            Asserts.assertEquals(array1[0].hash(), array1[1].hash());\n+        }\n+        Integer[] array2 = new Integer[2];\n+        array2[1] = rI;\n+        synchronized (array2) {\n+            Object res = test135(array2, array2[1]);\n+            Asserts.assertEquals(res, array2[1]);\n+            Asserts.assertEquals(array2[0], array2[1]);\n+        }\n+    }\n+\n+    \/\/ Same as test135 but with locking in compiled method\n+    @Test\n+    public Object test136(Object[] array, Object val) {\n+        Object res = null;\n+        synchronized (array) {\n+            array[0] = val;\n+            res = array[1];\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test136\")\n+    public void test136_verifier() {\n+        MyValue1[] array1 = new MyValue1[2];\n+        array1[1] = MyValue1.createWithFieldsInline(rI, rL);\n+        Object res = test136(array1, array1[1]);\n+        Asserts.assertEquals(((MyValue1)res).hash(), array1[1].hash());\n+        Asserts.assertEquals(array1[0].hash(), array1[1].hash());\n+        Integer[] array2 = new Integer[2];\n+        array2[1] = rI;\n+        res = test136(array2, array2[1]);\n+        Asserts.assertEquals(res, array2[1]);\n+        Asserts.assertEquals(array2[0], array2[1]);\n+    }\n+\n+    Object oFld1, oFld2;\n+\n+    \/\/ Test loop unwswitching with locked (inline type) array accesses\n+    @Test\n+    public void test137(Object[] array1, Object[] array2) {\n+        for (int i = 0; i < array1.length; i++) {\n+            oFld1 = array1[i];\n+            oFld2 = array2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test137\")\n+    public void test137_verifier() {\n+        MyValue1[] array1 = new MyValue1[100];\n+        Arrays.fill(array1, MyValue1.createWithFieldsInline(rI, rL));\n+        Integer[] array2 = new Integer[100];\n+        Arrays.fill(array2, rI);\n+        synchronized (array1) {\n+            test137(array1, array1);\n+            Asserts.assertEquals(oFld1, array1[0]);\n+            Asserts.assertEquals(oFld2, array1[0]);\n+            test137(array1, array2);\n+            Asserts.assertEquals(oFld1, array1[0]);\n+            Asserts.assertEquals(oFld2, array2[0]);\n+            test137(array2, array1);\n+            Asserts.assertEquals(oFld1, array2[0]);\n+            Asserts.assertEquals(oFld2, array1[0]);\n+        }\n+        synchronized (array2) {\n+            test137(array2, array2);\n+            Asserts.assertEquals(oFld1, array2[0]);\n+            Asserts.assertEquals(oFld2, array2[0]);\n+            test137(array1, array2);\n+            Asserts.assertEquals(oFld1, array1[0]);\n+            Asserts.assertEquals(oFld2, array2[0]);\n+            test137(array2, array1);\n+            Asserts.assertEquals(oFld1, array2[0]);\n+            Asserts.assertEquals(oFld2, array1[0]);\n+        }\n+    }\n+\n+    \/\/ Same as test137 but with locking in loop\n+    @Test\n+    public void test138(Object[] array1, Object[] array2) {\n+        for (int i = 0; i < array1.length; i++) {\n+            synchronized (array1) {\n+                oFld1 = array1[i];\n+            }\n+            synchronized (array2) {\n+                oFld2 = array2[i];\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test138\")\n+    public void test138_verifier() {\n+        MyValue1[] array1 = new MyValue1[100];\n+        Arrays.fill(array1, MyValue1.createWithFieldsInline(rI, rL));\n+        Integer[] array2 = new Integer[100];\n+        Arrays.fill(array2, rI);\n+        test138(array1, array1);\n+        Asserts.assertEquals(oFld1, array1[0]);\n+        Asserts.assertEquals(oFld2, array1[0]);\n+        test138(array1, array2);\n+        Asserts.assertEquals(oFld1, array1[0]);\n+        Asserts.assertEquals(oFld2, array2[0]);\n+        test138(array2, array1);\n+        Asserts.assertEquals(oFld1, array2[0]);\n+        Asserts.assertEquals(oFld2, array1[0]);\n+        test138(array2, array2);\n+        Asserts.assertEquals(oFld1, array2[0]);\n+        Asserts.assertEquals(oFld2, array2[0]);\n+        Asserts.assertEquals(oFld2, array2[0]);\n+    }\n+\n+    \/\/ Test load from array that is only known to be non-inline after parsing\n+    @Test\n+    @IR(failOn = {ALLOC_G, ALLOCA_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE,\n+                  STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public Object test139() {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = varray;\n+            varray = iarray;\n+        }\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test139\")\n+    public void test139_verifier() {\n+        Object res = test139();\n+        Asserts.assertEquals(res, null);\n+    }\n+\n+    \/\/ Test store to array that is only known to be non-inline after parsing\n+    @Test\n+    @IR(failOn = {ALLOCA, ALLOC_G, LOOP, LOAD, STORE, TRAP,\n+                  LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public Object[] test140(Object val) {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = varray;\n+            varray = iarray;\n+        }\n+        array[0] = val;\n+        return array;\n+    }\n+\n+    @Run(test = \"test140\")\n+    public void test140_verifier() {\n+        Object[] res = test140(rI);\n+        Asserts.assertEquals(res[0], rI);\n+        res = test140(null);\n+        Asserts.assertEquals(res[0], null);\n+    }\n+\n+    \/\/ Test load from array that is only known to be inline after parsing\n+    \/\/ TODO 8255938\n+    @Test\n+    \/\/ @IR(failOn = {ALLOC_G, ALLOCA_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public Object test141() {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = iarray;\n+            iarray = varray;\n+        }\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test141\")\n+    public void test141_verifier() {\n+        Object res = test141();\n+        Asserts.assertEquals(res, MyValue1.default);\n+    }\n+\n+    \/\/ Test store to array that is only known to be inline after parsing\n+    \/\/ TODO 8255938\n+    @Test\n+    \/\/ @IR(failOn = {ALLOCA, ALLOC_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public Object[] test142(Object val) {\n+        Object[]  array = null;\n+        Object[] iarray = new Integer[1];\n+        Object[] varray = new MyValue1[1];\n+        for (int i = 0; i < 10; i++) {\n+            array = iarray;\n+            iarray = varray;\n+        }\n+        array[0] = val;\n+        return array;\n+    }\n+\n+    @Run(test = \"test142\")\n+    public void test142_verifier(RunInfo info) {\n+        Object[] res = test142(MyValue1.default);\n+        Asserts.assertEquals(res[0], MyValue1.default);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test142(null);\n+                throw new RuntimeException(\"Should throw NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    static interface MyInterface143 {\n+        public int hash();\n+    }\n+\n+    static class MyObject143 implements MyInterface143 {\n+        public int hash() { return 42; }\n+    }\n+\n+    volatile MyInterface143[] array143 = new MyObject143[1];\n+    int len143 = 0;\n+\n+    volatile int vf = 0;\n+\n+    \/\/ Test that triggers an anti dependency failure when array mark word is loaded from immutable memory\n+    @Test\n+    public void test143() {\n+        MyInterface143[] arr = array143;\n+        int tmp = arr.length;\n+        for (int i = 0; i < len143; i++) {\n+            if (arr[i].hash() > 0) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test143\")\n+    @Warmup(0)\n+    public void test143_verifier() {\n+        test143();\n+    }\n+\n+    \/\/ Same as test143 but with two flat array checks that are unswitched\n+    @Test\n+    public void test144() {\n+        MyInterface143[] arr1 = array143;\n+        MyInterface143[] arr2 = array143;\n+        int tmp1 = arr1.length;\n+        int tmp2 = arr2.length;\n+        for (int i = 0; i < len143; i++) {\n+            if (arr1[i].hash() > 0 && arr2[i].hash() > 0) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test144\")\n+    @Warmup(0)\n+    public void test144_verifier() {\n+        test144();\n+    }\n+\n+    \/\/ Test that array load slow path correctly initializes non-flattened field of empty inline type\n+    @Test\n+    public Object test145(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test145\")\n+    public void test145_verifier() {\n+        Object[] array = new EmptyContainer[1];\n+        EmptyContainer empty = (EmptyContainer)test145(array);\n+        Asserts.assertEquals(empty, EmptyContainer.default);\n+    }\n+\n+    \/\/ Test that non-flattened array does not block inline type scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE})\n+    public void test146(boolean b) {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2[] array = { vt };\n+        if (b) {\n+            for (int i = 0; i < 10; ++i) {\n+                if (array != array) {\n+                    array = null;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test146\")\n+    @Warmup(50000)\n+    public void test146_verifier() {\n+        test146(true);\n+    }\n+\n+    \/\/ Test that non-flattened array does not block inline type scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE})\n+    public int test147(boolean deopt) {\n+        \/\/ Both vt and array should be scalarized\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2[] array = new MyValue2[1];\n+\n+        \/\/ Delay scalarization to after loop opts\n+        boolean store = false;\n+        for (int i = 0; i < 5; ++i) {\n+            if (i == 1) {\n+                store = true;\n+            }\n+        }\n+        if (store) {\n+            array[0] = vt;\n+        }\n+\n+        if (deopt) {\n+            \/\/ Uncommon trap referencing array\n+            return array[0].x + 42;\n+        }\n+        return array[0].x;\n+    }\n+\n+    @Run(test = \"test147\")\n+    @Warmup(50000)\n+    public void test147_verifier(RunInfo info) {\n+        int res = test147(!info.isWarmUp());\n+        Asserts.assertEquals(res, MyValue2.createWithFieldsInline(rI, rD).x + (info.isWarmUp() ? 0 : 42));\n+    }\n+\n+    \/\/ Test that correct basic types are used when folding field\n+    \/\/ loads from a scalar replaced array through an arraycopy.\n+    @Test\n+    public void test148(MyValue1 vt) {\n+        MyValue1[] src = new MyValue1[1];\n+        MyValue1[] dst = new MyValue1[1];\n+        src[0] = vt;\n+        System.arraycopy(src, 0, dst, 0, 1);\n+        if (src[0].hash() != dst[0].hash()) {\n+          throw new RuntimeException(\"Unexpected hash\");\n+        }\n+    }\n+\n+    @Run(test = \"test148\")\n+    public void test148_verifier() {\n+        test148(MyValue1.createWithFieldsInline(rI, rL));\n+    }\n+\n+    \/\/ Abstract class without any primitive class implementers\n+    static abstract class MyAbstract149 {\n+        public abstract int get();\n+    }\n+\n+    static class TestClass149 extends MyAbstract149 {\n+        final int x;\n+\n+        public int get() { return x; };\n+\n+        public TestClass149(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    \/\/ Test OSR compilation with array known to be not null-free\/flat\n+    @Test\n+    public int test149(MyAbstract149[] array) {\n+        int res = 0;\n+        \/\/ Trigger OSR compilation\n+        for (int i = 0; i < 10_000; ++i) {\n+            res += array[i % 10].get();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test149\")\n+    public void test149_verifier() {\n+        TestClass149[] array = new TestClass149[10];\n+        for (int i = 0; i < 10; ++i) {\n+            array[i] = new TestClass149(i);\n+        }\n+        Asserts.assertEquals(test149(array), 45000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":3561,"deletions":0,"binary":false,"changes":3561,"status":"added"},{"patch":"@@ -0,0 +1,986 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test the basic inline type implementation in C2\n+ *\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @compile InlineTypes.java\n+ * @compile -XDenablePrimitiveClasses TestBasicFunctionality.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestBasicFunctionality\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestBasicFunctionality {\n+\n+    public static void main(String[] args) {\n+        InlineTypes.getFramework()\n+                   .addScenarios(InlineTypes.DEFAULT_SCENARIOS)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    protected long hash() {\n+        return hash(rI, rL);\n+    }\n+\n+    protected long hash(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y).hash();\n+    }\n+\n+\n+    \/\/ Receive inline type through call to interpreter\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test1() {\n+        MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        long result = test1();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+\n+    \/\/ Receive inline type from interpreter via parameter\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test2(MyValue1 v) {\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);\n+        long result = test2(v);\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+\n+    \/\/ Return incoming inline type without accessing fields\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \"= 1\", STORE, \"= 19\"},\n+        failOn = {LOAD, TRAP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public MyValue1 test3(MyValue1 v) {\n+        return v;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1 v2 = test3(v1);\n+        Asserts.assertEQ(v1.x, v2.x);\n+        Asserts.assertEQ(v1.y, v2.y);\n+    }\n+\n+    \/\/ Create an inline type in compiled code and only use fields.\n+    \/\/ Allocation should go away because inline type does not escape.\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test4() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        long result = test4();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in compiled code and pass it to\n+    \/\/ an inlined compiled method via a call.\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test5() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        return test5Inline(v);\n+    }\n+\n+    @ForceInline\n+    public long test5Inline(MyValue1 v) {\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        long result = test5();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in compiled code and pass it to\n+    \/\/ the interpreter via a call.\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \"= 1\"},\n+        failOn = {LOAD, TRAP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n+    public long test6() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        \/\/ Pass to interpreter\n+        return v.hashInterpreted();\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        long result = test6();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in compiled code and pass it to\n+    \/\/ the interpreter by returning.\n+    @Test\n+    @IR(counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n+    public MyValue1 test7(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y);\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        MyValue1 v = test7(rI, rL);\n+        Asserts.assertEQ(v.hash(), hash());\n+    }\n+\n+    \/\/ Merge inline types created from two branches\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test8(boolean b) {\n+        MyValue1 v;\n+        if (b) {\n+            v = MyValue1.createWithFieldsInline(rI, rL);\n+        } else {\n+            v = MyValue1.createWithFieldsDontInline(rI + 1, rL + 1);\n+        }\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        Asserts.assertEQ(test8(true), hash());\n+        Asserts.assertEQ(test8(false), hash(rI + 1, rL + 1));\n+    }\n+\n+    \/\/ Merge inline types created from two branches\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \"= 1\", LOAD, \"= 19\",\n+                  STORE, \"= 3\"}, \/\/ InitializeNode::coalesce_subword_stores merges stores\n+        failOn = {TRAP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\", STORE, \"= 19\"},\n+        failOn = {LOAD, TRAP})\n+    public MyValue1 test9(boolean b, int localrI, long localrL) {\n+        MyValue1 v;\n+        if (b) {\n+            \/\/ Inline type is not allocated\n+            \/\/ Do not use rI\/rL directly here as null values may cause\n+            \/\/ some redundant null initializations to be optimized out\n+            \/\/ and matching to fail.\n+            v = MyValue1.createWithFieldsInline(localrI, localrL);\n+        } else {\n+            \/\/ Inline type is allocated by the callee\n+            v = MyValue1.createWithFieldsDontInline(rI + 1, rL + 1);\n+        }\n+        \/\/ Need to allocate inline type if 'b' is true\n+        long sum = v.hashInterpreted();\n+        if (b) {\n+            v = MyValue1.createWithFieldsDontInline(rI, sum);\n+        } else {\n+            v = MyValue1.createWithFieldsDontInline(rI, sum + 1);\n+        }\n+        \/\/ Don't need to allocate inline type because both branches allocate\n+        return v;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        MyValue1 v = test9(true, rI, rL);\n+        Asserts.assertEQ(v.x, rI);\n+        Asserts.assertEQ(v.y, hash());\n+        v = test9(false, rI, rL);\n+        Asserts.assertEQ(v.x, rI);\n+        Asserts.assertEQ(v.y, hash(rI + 1, rL + 1) + 1);\n+    }\n+\n+    \/\/ Merge inline types created in a loop (not inlined)\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test10(int x, long y) {\n+        MyValue1 v = MyValue1.createWithFieldsDontInline(x, y);\n+        for (int i = 0; i < 10; ++i) {\n+            v = MyValue1.createWithFieldsDontInline(v.x + 1, v.y + 1);\n+        }\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        long result = test10(rI, rL);\n+        Asserts.assertEQ(result, hash(rI + 10, rL + 10));\n+    }\n+\n+    \/\/ Merge inline types created in a loop (inlined)\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test11(int x, long y) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(x, y);\n+        for (int i = 0; i < 10; ++i) {\n+            v = MyValue1.createWithFieldsInline(v.x + 1, v.y + 1);\n+        }\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        long result = test11(rI, rL);\n+        Asserts.assertEQ(result, hash(rI + 10, rL + 10));\n+    }\n+\n+    \/\/ Test loop with uncommon trap referencing an inline type\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {SCOBJ, \">= 1\", LOAD, \"<= 12\"}) \/\/ TODO 8227588 (loads should be removed)\n+    public long test12(boolean b) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1[] va = new MyValue1[Math.abs(rI) % 10];\n+        for (int i = 0; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        long result = rL;\n+        for (int i = 0; i < 1000; ++i) {\n+            if (b) {\n+                result += v.x;\n+            } else {\n+                \/\/ Uncommon trap referencing v. We delegate allocation to the\n+                \/\/ interpreter by adding a SafePointScalarObjectNode.\n+                result = v.hashInterpreted();\n+                for (int j = 0; j < va.length; ++j) {\n+                    result += va[j].hash();\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier(RunInfo info) {\n+        long result = test12(info.isWarmUp());\n+        Asserts.assertEQ(result, info.isWarmUp() ? rL + (1000 * rI) : ((Math.abs(rI) % 10) + 1) * hash());\n+    }\n+\n+    \/\/ Test loop with uncommon trap referencing an inline type\n+    @Test\n+    public long test13(boolean b) {\n+        MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = new MyValue1[Math.abs(rI) % 10];\n+        for (int i = 0; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+        long result = rL;\n+        for (int i = 0; i < 1000; ++i) {\n+            if (b) {\n+                result += v.x;\n+            } else {\n+                \/\/ Uncommon trap referencing v. Should not allocate\n+                \/\/ but just pass the existing oop to the uncommon trap.\n+                result = v.hashInterpreted();\n+                for (int j = 0; j < va.length; ++j) {\n+                    result += va[j].hashInterpreted();\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier(RunInfo info) {\n+        long result = test13(info.isWarmUp());\n+        Asserts.assertEQ(result, info.isWarmUp() ? rL + (1000 * rI) : ((Math.abs(rI) % 10) + 1) * hash());\n+    }\n+\n+    \/\/ Create an inline type in a non-inlined method and then call a\n+    \/\/ non-inlined method on that inline type.\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC, STORE, TRAP},\n+        counts = {LOAD, \"= 19\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test14() {\n+        MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);\n+        return v.hashInterpreted();\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        long result = test14();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in an inlined method and then call a\n+    \/\/ non-inlined method on that inline type.\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {LOAD, TRAP},\n+        counts = {ALLOC, \"= 1\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {LOAD, TRAP},\n+        counts = {ALLOC, \"= 2\"})\n+    public long test15() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        return v.hashInterpreted();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        long result = test15();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in a non-inlined method and then call an\n+    \/\/ inlined method on that inline type.\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test16() {\n+        MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        long result = test16();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in an inlined method and then call an\n+    \/\/ inlined method on that inline type.\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test17() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        long result = test17();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in compiled code and pass it to the\n+    \/\/ interpreter via a call. The inline type is live at the first call so\n+    \/\/ debug info should include a reference to all its fields.\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \"= 1\"},\n+        failOn = {LOAD, TRAP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n+    public long test18() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        v.hashInterpreted();\n+        return v.hashInterpreted();\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        long result = test18();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type in compiled code and pass it to the\n+    \/\/ interpreter via a call. The inline type is passed twice but\n+    \/\/ should only be allocated once.\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \"= 1\"},\n+        failOn = {LOAD, TRAP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n+    public long test19() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        return sumValue(v, v);\n+    }\n+\n+    @DontCompile\n+    public long sumValue(MyValue1 v, MyValue1 dummy) {\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        long result = test19();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Create an inline type (array) in compiled code and pass it to the\n+    \/\/ interpreter via a call. The inline type is live at the uncommon\n+    \/\/ trap: verify that deoptimization causes the inline type to be\n+    \/\/ correctly allocated.\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \"= 1\", STORE, \"= 1\"},  \/\/ InitializeNode::coalesce_subword_stores merges stores\n+        failOn = {LOAD})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = LOAD)\n+    public long test20(boolean deopt, Method m) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue2[] va = new MyValue2[3];\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+\n+        return v.hashInterpreted() + va[0].hashInterpreted() +\n+               va[1].hashInterpreted() + va[2].hashInterpreted();\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier(RunInfo info) {\n+        MyValue2[] va = new MyValue2[42];\n+        long result = test20(!info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, hash() + va[0].hash() + va[1].hash() + va[2].hash());\n+    }\n+\n+    \/\/ Inline type fields in regular object\n+    MyValue1 val1;\n+    MyValue2 val2;\n+    final MyValue1 val3 = MyValue1.createWithFieldsInline(rI, rL);\n+    static MyValue1 val4;\n+    static final MyValue1 val5 = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    \/\/ Test inline type fields in objects\n+    @Test\n+    @IR(counts = {ALLOC, \"= 2\"},\n+        failOn = TRAP)\n+    public long test21(int x, long y) {\n+        \/\/ Compute hash of inline type fields\n+        long result = val1.hash() + val2.hash() + val3.hash() + val4.hash() + val5.hash();\n+        \/\/ Update fields\n+        val1 = MyValue1.createWithFieldsInline(x, y);\n+        val2 = MyValue2.createWithFieldsInline(x, rD);\n+        val4 = MyValue1.createWithFieldsInline(x, y);\n+        return result;\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        \/\/ Check if hash computed by test18 is correct\n+        val1 = MyValue1.createWithFieldsInline(rI, rL);\n+        val2 = val1.v2;\n+        \/\/ val3 is initialized in the constructor\n+        val4 = val1;\n+        \/\/ val5 is initialized in the static initializer\n+        long hash = val1.hash() + val2.hash() + val3.hash() + val4.hash() + val5.hash();\n+        long result = test21(rI + 1, rL + 1);\n+        Asserts.assertEQ(result, hash);\n+        \/\/ Check if inline type fields were updated\n+        Asserts.assertEQ(val1.hash(), hash(rI + 1, rL + 1));\n+        Asserts.assertEQ(val2.hash(), MyValue2.createWithFieldsInline(rI + 1, rD).hash());\n+        Asserts.assertEQ(val4.hash(), hash(rI + 1, rL + 1));\n+    }\n+\n+    \/\/ Test folding of constant inline type fields\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, LOOP, TRAP})\n+    public long test22() {\n+        \/\/ This should be constant folded\n+        return val5.hash() + val5.v3.hash();\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        long result = test22();\n+        Asserts.assertEQ(result, val5.hash() + val5.v3.hash());\n+    }\n+\n+    \/\/ Test aconst_init\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, LOOP, TRAP})\n+    public long test23() {\n+        MyValue2 v = MyValue2.createDefaultInline();\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        long result = test23();\n+        Asserts.assertEQ(result, MyValue2.createDefaultInline().hash());\n+    }\n+\n+    \/\/ Test aconst_init\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP, TRAP})\n+    public long test24() {\n+        MyValue1 v1 = MyValue1.createDefaultInline();\n+        MyValue1 v2 = MyValue1.createDefaultDontInline();\n+        return v1.hashPrimitive() + v2.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        long result = test24();\n+        Asserts.assertEQ(result, 2 * MyValue1.createDefaultInline().hashPrimitive());\n+    }\n+\n+    \/\/ Test withfield\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, LOOP, TRAP})\n+    public long test25() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        long result = test25();\n+        Asserts.assertEQ(result, MyValue2.createWithFieldsInline(rI, rD).hash());\n+    }\n+\n+    \/\/ Test withfield\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP, TRAP})\n+    public long test26() {\n+        MyValue1 v1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 v2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        return v1.hash() + v2.hash();\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        long result = test26();\n+        Asserts.assertEQ(result, 2 * hash());\n+    }\n+\n+    class TestClass27 {\n+        public MyValue1 v;\n+    }\n+\n+    \/\/ Test allocation elimination of unused object with initialized inline type field\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, LOOP})\n+    public void test27(boolean deopt, Method m) {\n+        TestClass27 unused = new TestClass27();\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        unused.v = v;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier(RunInfo info) {\n+        test27(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    static MyValue3 staticVal3;\n+    static MyValue3 staticVal3_copy;\n+\n+    \/\/ Check elimination of redundant inline type allocations\n+    @Test\n+    @IR(counts = {ALLOC, \"= 1\"})\n+    public MyValue3 test28(MyValue3[] va) {\n+        \/\/ Create inline type and force allocation\n+        MyValue3 vt = MyValue3.create();\n+        va[0] = vt;\n+        staticVal3 = vt;\n+        vt.verify(staticVal3);\n+\n+        \/\/ Inline type is now allocated, make a copy and force allocation.\n+        \/\/ Because copy is equal to vt, C2 should remove this redundant allocation.\n+        MyValue3 copy = MyValue3.setC(vt, vt.c);\n+        va[0] = copy;\n+        staticVal3_copy = copy;\n+        copy.verify(staticVal3_copy);\n+        return copy;\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue3[] va = new MyValue3[1];\n+        MyValue3 vt = test28(va);\n+        staticVal3.verify(vt);\n+        staticVal3.verify(va[0]);\n+        staticVal3_copy.verify(vt);\n+        staticVal3_copy.verify(va[0]);\n+    }\n+\n+    \/\/ Verify that only dominating allocations are re-used\n+    @Test\n+    public MyValue3 test29(boolean warmup) {\n+        MyValue3 vt = MyValue3.create();\n+        if (warmup) {\n+            staticVal3 = vt; \/\/ Force allocation\n+        }\n+        \/\/ Force allocation to verify that above\n+        \/\/ non-dominating allocation is not re-used\n+        MyValue3 copy = MyValue3.setC(vt, vt.c);\n+        staticVal3_copy = copy;\n+        copy.verify(vt);\n+        return copy;\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier(RunInfo info) {\n+        MyValue3 vt = test29(info.isWarmUp());\n+        if (info.isWarmUp()) {\n+            staticVal3.verify(vt);\n+        }\n+    }\n+\n+    \/\/ Verify that C2 recognizes inline type loads and re-uses the oop to avoid allocations\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n+    public MyValue3 test30(MyValue3[] va) {\n+        \/\/ C2 can re-use the oop of staticVal3 because staticVal3 is equal to copy\n+        MyValue3 copy = MyValue3.copy(staticVal3);\n+        va[0] = copy;\n+        staticVal3 = copy;\n+        copy.verify(staticVal3);\n+        return copy;\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() {\n+        staticVal3 = MyValue3.create();\n+        MyValue3[] va = new MyValue3[1];\n+        MyValue3 vt = test30(va);\n+        staticVal3.verify(vt);\n+        staticVal3.verify(va[0]);\n+    }\n+\n+    \/\/ Verify that C2 recognizes inline type loads and re-uses the oop to avoid allocations\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n+    public MyValue3 test31(MyValue3[] va) {\n+        \/\/ C2 can re-use the oop returned by createDontInline()\n+        \/\/ because the corresponding inline type is equal to 'copy'.\n+        MyValue3 copy = MyValue3.copy(MyValue3.createDontInline());\n+        va[0] = copy;\n+        staticVal3 = copy;\n+        copy.verify(staticVal3);\n+        return copy;\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier() {\n+        MyValue3[] va = new MyValue3[1];\n+        MyValue3 vt = test31(va);\n+        staticVal3.verify(vt);\n+        staticVal3.verify(va[0]);\n+    }\n+\n+    \/\/ Verify that C2 recognizes inline type loads and re-uses the oop to avoid allocations\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n+    public MyValue3 test32(MyValue3 vt, MyValue3[] va) {\n+        \/\/ C2 can re-use the oop of vt because vt is equal to 'copy'.\n+        MyValue3 copy = MyValue3.copy(vt);\n+        va[0] = copy;\n+        staticVal3 = copy;\n+        copy.verify(staticVal3);\n+        return copy;\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        MyValue3 vt = MyValue3.create();\n+        MyValue3[] va = new MyValue3[1];\n+        MyValue3 result = test32(vt, va);\n+        staticVal3.verify(vt);\n+        va[0].verify(vt);\n+        result.verify(vt);\n+    }\n+\n+    \/\/ Test correct identification of inline type copies\n+    @Test\n+    public MyValue3 test33(MyValue3[] va) {\n+        MyValue3 vt = MyValue3.copy(staticVal3);\n+        vt = MyValue3.setI(vt, vt.c);\n+        \/\/ vt is not equal to staticVal3, so C2 should not re-use the oop\n+        va[0] = vt;\n+        staticVal3 = vt;\n+        vt.verify(staticVal3);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        staticVal3 = MyValue3.create();\n+        MyValue3[] va = new MyValue3[1];\n+        MyValue3 vt = test33(va);\n+        Asserts.assertEQ(staticVal3.i, (int)staticVal3.c);\n+        Asserts.assertEQ(va[0].i, (int)staticVal3.c);\n+        Asserts.assertEQ(vt.i, (int)staticVal3.c);\n+    }\n+\n+    \/\/ Verify that the default inline type is never allocated.\n+    \/\/ C2 code should load and use the default oop from the java mirror.\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    public MyValue3 test34(MyValue3[] va) {\n+        \/\/ Explicitly create default value\n+        MyValue3 vt = MyValue3.createDefault();\n+        va[0] = vt;\n+        staticVal3 = vt;\n+        vt.verify(vt);\n+\n+        \/\/ Load default value from uninitialized inline type array\n+        MyValue3[] dva = new MyValue3[1];\n+        staticVal3_copy = dva[0];\n+        va[1] = dva[0];\n+        dva[0].verify(dva[0]);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier() {\n+        MyValue3 vt = MyValue3.createDefault();\n+        MyValue3[] va = new MyValue3[2];\n+        va[0] = MyValue3.create();\n+        va[1] = MyValue3.create();\n+        MyValue3 res = test34(va);\n+        res.verify(vt);\n+        staticVal3.verify(vt);\n+        staticVal3_copy.verify(vt);\n+        va[0].verify(vt);\n+        va[1].verify(vt);\n+    }\n+\n+    \/\/ Same as above but manually initialize inline type fields to default.\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    public MyValue3 test35(MyValue3 vt, MyValue3[] va) {\n+        vt = MyValue3.setC(vt, (char)0);\n+        vt = MyValue3.setBB(vt, (byte)0);\n+        vt = MyValue3.setS(vt, (short)0);\n+        vt = MyValue3.setI(vt, 0);\n+        vt = MyValue3.setL(vt, 0);\n+        vt = MyValue3.setO(vt, null);\n+        vt = MyValue3.setF1(vt, 0);\n+        vt = MyValue3.setF2(vt, 0);\n+        vt = MyValue3.setF3(vt, 0);\n+        vt = MyValue3.setF4(vt, 0);\n+        vt = MyValue3.setF5(vt, 0);\n+        vt = MyValue3.setF6(vt, 0);\n+        vt = MyValue3.setV1(vt, MyValue3Inline.createDefault());\n+        va[0] = vt;\n+        staticVal3 = vt;\n+        vt.verify(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier() {\n+        MyValue3 vt = MyValue3.createDefault();\n+        MyValue3[] va = new MyValue3[1];\n+        va[0] = MyValue3.create();\n+        MyValue3 res = test35(va[0], va);\n+        res.verify(vt);\n+        staticVal3.verify(vt);\n+        va[0].verify(vt);\n+    }\n+\n+    \/\/ Merge inline types created from two branches\n+\n+    private Object test36_helper(Object v) {\n+        return v;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test36(boolean b) {\n+        Object o;\n+        if (b) {\n+            o = test36_helper(MyValue1.createWithFieldsInline(rI, rL));\n+        } else {\n+            o = test36_helper(MyValue1.createWithFieldsDontInline(rI + 1, rL + 1));\n+        }\n+        MyValue1 v = (MyValue1)o;\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() {\n+        Asserts.assertEQ(test36(true), hash());\n+        Asserts.assertEQ(test36(false), hash(rI + 1, rL + 1));\n+    }\n+\n+    \/\/ Test correct loading of flattened fields\n+    primitive class Test37Value2 {\n+        final int x = 0;\n+        final int y = 0;\n+    }\n+\n+    primitive class Test37Value1 {\n+        final double d = 0;\n+        final float f = 0;\n+        final Test37Value2 v = new Test37Value2();\n+    }\n+\n+    @Test\n+    public Test37Value1 test37(Test37Value1 vt) {\n+        return vt;\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        Test37Value1 vt = new Test37Value1();\n+        Asserts.assertEQ(test37(vt), vt);\n+    }\n+\n+    \/\/ Test elimination of inline type allocations without a unique CheckCastPP\n+    primitive class Test38Value {\n+        public int i;\n+        public Test38Value(int i) { this.i = i; }\n+    }\n+\n+    static Test38Value test38Field;\n+\n+    @Test\n+    public void test38() {\n+        for (int i = 3; i < 100; ++i) {\n+            int j = 1;\n+            while (++j < 11) {\n+                try {\n+                    test38Field = new Test38Value(i);\n+                } catch (ArithmeticException ae) { }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        test38Field = Test38Value.default;\n+        test38();\n+        Asserts.assertEQ(test38Field, new Test38Value(99));\n+    }\n+\n+    \/\/ Tests split if with inline type Phi users\n+    static primitive class Test39Value {\n+        public int iFld1;\n+        public int iFld2;\n+\n+        public Test39Value(int i1, int i2) { iFld1 = i1; iFld2 = i2; }\n+    }\n+\n+    static int test39A1[][] = new int[400][400];\n+    static double test39A2[] = new double[400];\n+    static Test39Value test39Val = Test39Value.default;\n+\n+    @DontInline\n+    public int[] getArray() {\n+        return new int[400];\n+    }\n+\n+    @Test\n+    public int test39() {\n+        int result = 0;\n+        for (int i = 0; i < 100; ++i) {\n+            switch ((i >>> 1) % 3) {\n+                case 0:\n+                    test39A1[i][i] = i;\n+                    break;\n+                case 1:\n+                    for (int j = 0; j < 100; ++j) {\n+                        test39A1[i] = getArray();\n+                        test39Val = new Test39Value(j, test39Val.iFld2);\n+                    }\n+                    break;\n+                case 2:\n+                    for (float f = 142; f > i; f--) {\n+                        test39A2[i + 1] += 3;\n+                    }\n+                    result += test39Val.iFld1;\n+                    break;\n+            }\n+            double d1 = 1;\n+            while (++d1 < 142) {\n+                test39A1[(i >>> 1) % 400][i + 1] = result;\n+                test39Val = new Test39Value(i, test39Val.iFld2);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test39\")\n+    @Warmup(10)\n+    public void test39_verifier() {\n+        int result = test39();\n+        Asserts.assertEQ(result, 1552);\n+    }\n+\n+    \/\/ Test scalar replacement of inline type array containing inline type with oop fields\n+    @Test\n+    public long test40(boolean b) {\n+        MyValue1[] va = {MyValue1.createWithFieldsInline(rI, rL)};\n+        long result = 0;\n+        for (int i = 0; i < 1000; ++i) {\n+            if (!b) {\n+                result = va[0].hash();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier(RunInfo info) {\n+        long result = test40(info.isWarmUp());\n+        Asserts.assertEQ(result, info.isWarmUp() ? 0 : hash());\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":986,"deletions":0,"binary":false,"changes":986,"status":"added"},{"patch":"@@ -0,0 +1,1277 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+import jdk.internal.value.PrimitiveClass;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline type calling convention optimizations\n+ * @modules java.base\/jdk.internal.value\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestCallingConvention.java\n+ * @run main\/othervm\/timeout=450 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestCallingConvention\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestCallingConvention {\n+\n+    static {\n+        try {\n+            Class<?> clazz = TestCallingConvention.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class), boolean.class);\n+            test32_mh = lookup.findVirtual(clazz, \"test32_interp\", mt);\n+\n+            mt = MethodType.methodType(Object.class, boolean.class);\n+            test33_mh = lookup.findVirtual(clazz, \"test33_interp\", mt);\n+\n+            mt = MethodType.methodType(int.class);\n+            test37_mh = lookup.findVirtual(PrimitiveClass.asValueType(Test37Value.class), \"test\", mt);\n+\n+            mt = MethodType.methodType(MyValue2.class);\n+            test54_mh = lookup.findVirtual(clazz, \"test54_callee\", mt);\n+\n+            mt = MethodType.methodType(MyValue2.class, boolean.class);\n+            test56_mh = lookup.findVirtual(clazz, \"test56_callee\", mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        \/\/ Don't generate bytecodes but call through runtime for reflective calls\n+        scenarios[0].addFlags(\"-Dsun.reflect.inflationThreshold=10000\");\n+        scenarios[1].addFlags(\"-Dsun.reflect.inflationThreshold=10000\");\n+        scenarios[3].addFlags(\"-XX:FlatArrayElementMaxSize=0\");\n+        scenarios[4].addFlags(\"-XX:-UseTLAB\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class,\n+                                     MyValue4.class)\n+                   .start();\n+    }\n+\n+    \/\/ Helper methods and classes\n+\n+    private void deoptimize(String name, Class<?>... params) {\n+        try {\n+            TestFramework.deoptimize(getClass().getDeclaredMethod(name, params));\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ Test interpreter to compiled code with various signatures\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test1(MyValue2 v) {\n+        return v.hash();\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test1(v);\n+        Asserts.assertEQ(result, v.hashInterpreted());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test2(int i1, MyValue2 v, int i2) {\n+        return v.hash() + i1 - i2;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test2(rI, v, 2*rI);\n+        Asserts.assertEQ(result, v.hashInterpreted() - rI);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test3(long l1, MyValue2 v, long l2) {\n+        return v.hash() + l1 - l2;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test3(rL, v, 2*rL);\n+        Asserts.assertEQ(result, v.hashInterpreted() - rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test4(int i, MyValue2 v, long l) {\n+        return v.hash() + i + l;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test4(rI, v, rL);\n+        Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test5(long l, MyValue2 v, int i) {\n+        return v.hash() + i + l;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test5(rL, v, rI);\n+        Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test6(long l, MyValue1 v1, int i, MyValue2 v2) {\n+        return v1.hash() + i + l + v2.hash();\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test6(rL, v1, rI, v2);\n+        Asserts.assertEQ(result, v1.hashInterpreted() + rL + rI + v2.hashInterpreted());\n+    }\n+\n+    \/\/ Test compiled code to interpreter with various signatures\n+    @DontCompile\n+    public long test7_interp(MyValue2 v) {\n+        return v.hash();\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test7(MyValue2 v) {\n+        return test7_interp(v);\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test7(v);\n+        Asserts.assertEQ(result, v.hashInterpreted());\n+    }\n+\n+    @DontCompile\n+    public long test8_interp(int i1, MyValue2 v, int i2) {\n+        return v.hash() + i1 - i2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test8(int i1, MyValue2 v, int i2) {\n+        return test8_interp(i1, v, i2);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test8(rI, v, 2*rI);\n+        Asserts.assertEQ(result, v.hashInterpreted() - rI);\n+    }\n+\n+    @DontCompile\n+    public long test9_interp(long l1, MyValue2 v, long l2) {\n+        return v.hash() + l1 - l2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test9(long l1, MyValue2 v, long l2) {\n+        return test9_interp(l1, v, l2);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test9(rL, v, 2*rL);\n+        Asserts.assertEQ(result, v.hashInterpreted() - rL);\n+    }\n+\n+    @DontCompile\n+    public long test10_interp(int i, MyValue2 v, long l) {\n+        return v.hash() + i + l;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test10(int i, MyValue2 v, long l) {\n+        return test10_interp(i, v, l);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test10(rI, v, rL);\n+        Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);\n+    }\n+\n+    @DontCompile\n+    public long test11_interp(long l, MyValue2 v, int i) {\n+        return v.hash() + i + l;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test11(long l, MyValue2 v, int i) {\n+        return test11_interp(l, v, i);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test11(rL, v, rI);\n+        Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);\n+    }\n+\n+    @DontCompile\n+    public long test12_interp(long l, MyValue1 v1, int i, MyValue2 v2) {\n+        return v1.hash() + i + l + v2.hash();\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test12(long l, MyValue1 v1, int i, MyValue2 v2) {\n+        return test12_interp(l, v1, i, v2);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test12(rL, v1, rI, v2);\n+        Asserts.assertEQ(result, v1.hashInterpreted() + rL + rI + v2.hashInterpreted());\n+    }\n+\n+    \/\/ Test that debug info at a call is correct\n+    @DontCompile\n+    public long test13_interp(MyValue2 v, MyValue1[] va, boolean deopt) {\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            deoptimize(\"test13\", PrimitiveClass.asValueType(MyValue2.class), MyValue1[].class, boolean.class, long.class);\n+        }\n+        return v.hash() + va[0].hash() + va[1].hash();\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test13(MyValue2 v, MyValue1[] va, boolean flag, long l) {\n+        return test13_interp(v, va, flag) + l;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier(RunInfo info) {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue1[] va = new MyValue1[2];\n+        va[0] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        va[1] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        long result = test13(v, va, !info.isWarmUp(), rL);\n+        Asserts.assertEQ(result, v.hashInterpreted() + va[0].hash() + va[1].hash() + rL);\n+    }\n+\n+    \/\/ Test deoptimization at call return with inline type returned in registers\n+    @DontCompile\n+    public MyValue2 test14_interp(boolean deopt) {\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            deoptimize(\"test14\", boolean.class);\n+        }\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @Test\n+    public MyValue2 test14(boolean flag) {\n+        return test14_interp(flag);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier(RunInfo info) {\n+        MyValue2 result = test14(!info.isWarmUp());\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        Asserts.assertEQ(result.hash(), v.hash());\n+    }\n+\n+    \/\/ Return inline types in registers from interpreter -> compiled\n+    final MyValue3 test15_vt = MyValue3.create();\n+    @DontCompile\n+    public MyValue3 test15_interp() {\n+        return test15_vt;\n+    }\n+\n+    MyValue3 test15_vt2;\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, TRAP})\n+    public void test15() {\n+        test15_vt2 = test15_interp();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        test15();\n+        test15_vt.verify(test15_vt2);\n+    }\n+\n+    \/\/ Return inline types in registers from compiled -> interpreter\n+    final MyValue3 test16_vt = MyValue3.create();\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, STORE, TRAP})\n+    public MyValue3 test16() {\n+        return test16_vt;\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        MyValue3 vt = test16();\n+        test16_vt.verify(vt);\n+    }\n+\n+    \/\/ Return inline types in registers from compiled -> compiled\n+    final MyValue3 test17_vt = MyValue3.create();\n+    @DontInline\n+    public MyValue3 test17_comp() {\n+        return test17_vt;\n+    }\n+\n+    MyValue3 test17_vt2;\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, TRAP})\n+    public void test17() {\n+        test17_vt2 = test17_comp();\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier(RunInfo info) throws Exception {\n+        Method helper_m = getClass().getDeclaredMethod(\"test17_comp\");\n+        if (!info.isWarmUp() && TestFramework.isCompiled(helper_m)) {\n+            TestFramework.compile(helper_m, CompLevel.C2);\n+            TestFramework.assertCompiledByC2(helper_m);\n+        }\n+\n+        test17();\n+        test17_vt.verify(test17_vt2);\n+    }\n+\n+    \/\/ Same tests as above but with an inline type that cannot be returned in registers\n+\n+    \/\/ Return inline types in registers from interpreter -> compiled\n+    final MyValue4 test18_vt = MyValue4.create();\n+    @DontCompile\n+    public MyValue4 test18_interp() {\n+        return test18_vt;\n+    }\n+\n+    MyValue4 test18_vt2;\n+    @Test\n+    public void test18() {\n+        test18_vt2 = test18_interp();\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        test18();\n+        test18_vt.verify(test18_vt2);\n+    }\n+\n+    \/\/ Return inline types in registers from compiled -> interpreter\n+    final MyValue4 test19_vt = MyValue4.create();\n+    @Test\n+    public MyValue4 test19() {\n+        return test19_vt;\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        MyValue4 vt = test19();\n+        test19_vt.verify(vt);\n+    }\n+\n+    \/\/ Return inline types in registers from compiled -> compiled\n+    final MyValue4 test20_vt = MyValue4.create();\n+    @DontInline\n+    public MyValue4 test20_comp() {\n+        return test20_vt;\n+    }\n+\n+    MyValue4 test20_vt2;\n+    @Test\n+    public void test20() {\n+        test20_vt2 = test20_comp();\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier(RunInfo info) throws Exception {\n+        Method helper_m = getClass().getDeclaredMethod(\"test20_comp\");\n+        if (!info.isWarmUp() && TestFramework.isCompiled(helper_m)) {\n+            TestFramework.compile(helper_m, CompLevel.C2);\n+            TestFramework.assertCompiledByC2(helper_m);\n+        }\n+        test20();\n+        test20_vt.verify(test20_vt2);\n+    }\n+\n+    \/\/ Test no result from inlined method for incremental inlining\n+    final MyValue3 test21_vt = MyValue3.create();\n+    public MyValue3 test21_inlined() {\n+        throw new RuntimeException();\n+    }\n+\n+    @Test\n+    public MyValue3 test21() {\n+        try {\n+            return test21_inlined();\n+        } catch (RuntimeException ex) {\n+            return test21_vt;\n+        }\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        MyValue3 vt = test21();\n+        test21_vt.verify(vt);\n+    }\n+\n+    \/\/ Test returning a non-flattened inline type as fields\n+    MyValue3.ref test22_vt = MyValue3.create();\n+\n+    @Test\n+    public MyValue3 test22() {\n+        return (MyValue3) test22_vt;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        MyValue3 vt = test22();\n+        test22_vt.verify(vt);\n+    }\n+\n+    \/\/ Test calling a method that has circular register\/stack dependencies when unpacking inline type arguments\n+    primitive class TestValue23 {\n+        final double f1;\n+        TestValue23(double val) {\n+            f1 = val;\n+        }\n+    }\n+\n+    static double test23Callee(int i1, int i2, int i3, int i4, int i5, int i6,\n+                               TestValue23 v1, TestValue23 v2, TestValue23 v3, TestValue23 v4, TestValue23 v5, TestValue23 v6, TestValue23 v7, TestValue23 v8,\n+                               double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8) {\n+        return i1 + i2 + i3 + i4 + i5 + i6 + v1.f1 + v2.f1 + v3.f1 + v4.f1 + v5.f1 + v6.f1 + v7.f1 + v8.f1 + d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8;\n+    }\n+\n+    @Test\n+    public double test23(int i1, int i2, int i3, int i4, int i5, int i6,\n+                         TestValue23 v1, TestValue23 v2, TestValue23 v3, TestValue23 v4, TestValue23 v5, TestValue23 v6, TestValue23 v7, TestValue23 v8,\n+                         double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8) {\n+        return test23Callee(i1, i2, i3, i4, i5, i6,\n+                            v1, v2, v3, v4, v5, v6, v7, v8,\n+                            d1, d2, d3, d4, d5, d6, d7, d8);\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        TestValue23 vt = new TestValue23(rI);\n+        double res1 = test23(rI, rI, rI, rI, rI, rI,\n+                            vt, vt, vt, vt, vt, vt, vt, vt,\n+                            rI, rI, rI, rI, rI, rI, rI, rI);\n+        double res2 = test23Callee(rI, rI, rI, rI, rI, rI,\n+                                   vt, vt, vt, vt, vt, vt, vt, vt,\n+                                   rI, rI, rI, rI, rI, rI, rI, rI);\n+        double res3 = 6*rI + 8*rI + 8*rI;\n+        Asserts.assertEQ(res1, res2);\n+        Asserts.assertEQ(res2, res3);\n+    }\n+\n+    \/\/ Should not return a nullable inline type as fields\n+    @Test\n+    public MyValue2.ref test24() {\n+        return null;\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        MyValue2.ref vt = test24();\n+        Asserts.assertEQ(vt, null);\n+    }\n+\n+    \/\/ Same as test24 but with control flow and inlining\n+    @ForceInline\n+    public MyValue2.ref test26_callee(boolean b) {\n+        if (b) {\n+            return null;\n+        } else {\n+            return MyValue2.createWithFieldsInline(rI, rD);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue2.ref test26(boolean b) {\n+        return test26_callee(b);\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        MyValue2.ref vt = test26(true);\n+        Asserts.assertEQ(vt, null);\n+        vt = test26(false);\n+        Asserts.assertEQ(vt.hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+    }\n+\n+    \/\/ Test calling convention with deep hierarchy of flattened fields\n+    final primitive class Test27Value1 {\n+        final Test27Value2 valueField;\n+\n+        private Test27Value1(Test27Value2 val2) {\n+            valueField = val2;\n+        }\n+\n+        @DontInline\n+        public int test(Test27Value1 val1) {\n+            return valueField.test(valueField) + val1.valueField.test(valueField);\n+        }\n+    }\n+\n+    final primitive class Test27Value2 {\n+        final Test27Value3 valueField;\n+\n+        private Test27Value2(Test27Value3 val3) {\n+            valueField = val3;\n+        }\n+\n+        @DontInline\n+        public int test(Test27Value2 val2) {\n+            return valueField.test(valueField) + val2.valueField.test(valueField);\n+        }\n+    }\n+\n+    final primitive class Test27Value3 {\n+        final int x;\n+\n+        private Test27Value3(int x) {\n+            this.x = x;\n+        }\n+\n+        @DontInline\n+        public int test(Test27Value3 val3) {\n+            return x + val3.x;\n+        }\n+    }\n+\n+    @Test\n+    public int test27(Test27Value1 val) {\n+        return val.test(val);\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        Test27Value3 val3 = new Test27Value3(rI);\n+        Test27Value2 val2 = new Test27Value2(val3);\n+        Test27Value1 val1 = new Test27Value1(val2);\n+        int result = test27(val1);\n+        Asserts.assertEQ(result, 8*rI);\n+    }\n+\n+    static final MyValue1.ref test28Val = MyValue1.createWithFieldsDontInline(rI, rL);\n+\n+    @Test\n+    public String test28() {\n+        return test28Val.toString();\n+    }\n+\n+    @Run(test = \"test28\")\n+    @Warmup(0)\n+    public void test28_verifier() {\n+        String result = test28();\n+    }\n+\n+    \/\/ Test calling a method returning an inline type as fields via reflection\n+    MyValue3 test29_vt = MyValue3.create();\n+\n+    @Test\n+    public MyValue3 test29() {\n+        return test29_vt;\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() throws Exception {\n+        MyValue3 vt = (MyValue3)TestCallingConvention.class.getDeclaredMethod(\"test29\").invoke(this);\n+        test29_vt.verify(vt);\n+    }\n+\n+    @Test\n+    public MyValue3 test30(MyValue3[] array) {\n+        MyValue3 result = MyValue3.create();\n+        array[0] = result;\n+        return result;\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() throws Exception {\n+        MyValue3[] array = new MyValue3[1];\n+        MyValue3 vt = (MyValue3)TestCallingConvention.class.getDeclaredMethod(\"test30\", MyValue3[].class).invoke(this, (Object)array);\n+        array[0].verify(vt);\n+    }\n+\n+    MyValue3 test31_vt;\n+\n+    @Test\n+    public MyValue3 test31() {\n+        MyValue3 result = MyValue3.create();\n+        test31_vt = result;\n+        return result;\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier() throws Exception {\n+        MyValue3 vt = (MyValue3)TestCallingConvention.class.getDeclaredMethod(\"test31\").invoke(this);\n+        test31_vt.verify(vt);\n+    }\n+\n+    \/\/ Test deoptimization at call return with inline type returned in registers.\n+    \/\/ Same as test14, except the interpreted method is called via a MethodHandle.\n+    static MethodHandle test32_mh;\n+\n+    @DontCompile\n+    public MyValue2 test32_interp(boolean deopt) {\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            deoptimize(\"test32\", boolean.class);\n+        }\n+        return MyValue2.createWithFieldsInline(rI+32, rD);\n+    }\n+\n+    @Test\n+    public MyValue2 test32(boolean flag) throws Throwable {\n+        return (MyValue2)test32_mh.invokeExact(this, flag);\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier(RunInfo info) throws Throwable {\n+        MyValue2 result = test32(!info.isWarmUp());\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI+32, rD);\n+        Asserts.assertEQ(result.hash(), v.hash());\n+    }\n+\n+    \/\/ Same as test32, except the return type is not flattenable.\n+    static MethodHandle test33_mh;\n+\n+    @DontCompile\n+    public Object test33_interp(boolean deopt) {\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            deoptimize(\"test33\", boolean.class);\n+        }\n+        return MyValue2.createWithFieldsInline(rI+33, rD);\n+    }\n+\n+    @Test\n+    public MyValue2 test33(boolean flag) throws Throwable {\n+        Object o = test33_mh.invokeExact(this, flag);\n+        return (MyValue2)o;\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier(RunInfo info) throws Throwable {\n+        MyValue2 result = test33(!info.isWarmUp());\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI+33, rD);\n+        Asserts.assertEQ(result.hash(), v.hash());\n+    }\n+\n+    \/\/ Test selection of correct entry point in SharedRuntime::handle_wrong_method\n+    static boolean test34_deopt = false;\n+\n+    @DontInline\n+    public static long test34_callee(MyValue2 vt, int i1, int i2, int i3, int i4) {\n+        Asserts.assertEQ(i1, rI);\n+        Asserts.assertEQ(i2, rI);\n+        Asserts.assertEQ(i3, rI);\n+        Asserts.assertEQ(i4, rI);\n+\n+        if (test34_deopt) {\n+            \/\/ uncommon trap\n+            int result = 0;\n+            for (int i = 0; i < 10; ++i) {\n+                result += rL;\n+            }\n+            return vt.hash() + i1 + i2 + i3 + i4 + result;\n+        }\n+        return vt.hash() + i1 + i2 + i3 + i4;\n+    }\n+\n+    @Test\n+    public static long test34(MyValue2 vt, int i1, int i2, int i3, int i4) {\n+        return test34_callee(vt, i1, i2, i3, i4);\n+    }\n+\n+    @Run(test = \"test34\")\n+    @Warmup(10000) \/\/ Make sure test34_callee is compiled\n+    public void test34_verifier(RunInfo info) {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test34(vt, rI, rI, rI, rI);\n+        Asserts.assertEQ(result, vt.hash()+4*rI);\n+        if (!info.isWarmUp()) {\n+            test34_deopt = true;\n+            for (int i = 0; i < 100; ++i) {\n+                result = test34(vt, rI, rI, rI, rI);\n+                Asserts.assertEQ(result, vt.hash()+4*rI+10*rL);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test OSR compilation of method with scalarized argument\n+    @Test\n+    public static long test35(MyValue2 vt, int i1, int i2, int i3, int i4) {\n+        int result = 0;\n+        \/\/ Trigger OSR compilation\n+        for (int i = 0; i < 10_000; ++i) {\n+            result += i1;\n+        }\n+        return vt.hash() + i1 + i2 + i3 + i4 + result;\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier() {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        long result = test35(vt, rI, rI, rI, rI);\n+        Asserts.assertEQ(result, vt.hash()+10004*rI);\n+    }\n+\n+    \/\/ Same as test31 but with GC in callee to verify that the\n+    \/\/ pre-allocated buffer for the returned inline type remains valid.\n+    MyValue3 test36_vt;\n+\n+    @Test\n+    public MyValue3 test36() {\n+        MyValue3 result = MyValue3.create();\n+        test36_vt = result;\n+        System.gc();\n+        return result;\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() throws Exception {\n+        MyValue3 vt = (MyValue3)TestCallingConvention.class.getDeclaredMethod(\"test36\").invoke(this);\n+        test36_vt.verify(vt);\n+    }\n+\n+    \/\/ Test method resolution with scalarized inline type receiver at invokespecial\n+    static final MethodHandle test37_mh;\n+\n+    primitive class Test37Value {\n+        int x = rI;\n+\n+        @DontInline\n+        public int test() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    public int test37(Test37Value vt) throws Throwable {\n+        \/\/ Generates invokespecial call of Test37Value::test\n+        return (int)test37_mh.invokeExact(vt);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() throws Throwable {\n+        Test37Value vt = new Test37Value();\n+        int res = test37(vt);\n+        Asserts.assertEQ(res, rI);\n+    }\n+\n+    \/\/ Test passing\/returning an empty inline type\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public MyValueEmpty test38(MyValueEmpty vt) {\n+        return vt.copy(vt);\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        MyValueEmpty vt = new MyValueEmpty();\n+        MyValueEmpty res = test38(vt);\n+        Asserts.assertEQ(res, vt);\n+    }\n+\n+    static primitive class LargeValueWithOops {\n+        \/\/ Use all 6 int registers + 50\/2 on stack = 29\n+        Object o1 = null;\n+        Object o2 = null;\n+        Object o3 = null;\n+        Object o4 = null;\n+        Object o5 = null;\n+        Object o6 = null;\n+        Object o7 = null;\n+        Object o8 = null;\n+        Object o9 = null;\n+        Object o10 = null;\n+        Object o11 = null;\n+        Object o12 = null;\n+        Object o13 = null;\n+        Object o14 = null;\n+        Object o15 = null;\n+        Object o16 = null;\n+        Object o17 = null;\n+        Object o18 = null;\n+        Object o19 = null;\n+        Object o20 = null;\n+        Object o21 = null;\n+        Object o22 = null;\n+        Object o23 = null;\n+        Object o24 = null;\n+        Object o25 = null;\n+        Object o26 = null;\n+        Object o27 = null;\n+        Object o28 = null;\n+        Object o29 = null;\n+    }\n+\n+    static primitive class LargeValueWithoutOops {\n+        \/\/ Use all 6 int registers + 50\/2 on stack = 29\n+        int i1 = 0;\n+        int i2 = 0;\n+        int i3 = 0;\n+        int i4 = 0;\n+        int i5 = 0;\n+        int i6 = 0;\n+        int i7 = 0;\n+        int i8 = 0;\n+        int i9 = 0;\n+        int i10 = 0;\n+        int i11 = 0;\n+        int i12 = 0;\n+        int i13 = 0;\n+        int i14 = 0;\n+        int i15 = 0;\n+        int i16 = 0;\n+        int i17 = 0;\n+        int i18 = 0;\n+        int i19 = 0;\n+        int i20 = 0;\n+        int i21 = 0;\n+        int i22 = 0;\n+        int i23 = 0;\n+        int i24 = 0;\n+        int i25 = 0;\n+        int i26 = 0;\n+        int i27 = 0;\n+        int i28 = 0;\n+        int i29 = 0;\n+        \/\/ Use all 7 float registers\n+        double d1 = 0;\n+        double d2 = 0;\n+        double d3 = 0;\n+        double d4 = 0;\n+        double d5 = 0;\n+        double d6 = 0;\n+        double d7 = 0;\n+        double d8 = 0;\n+    }\n+\n+    \/\/ Test passing\/returning a large inline type with oop fields\n+    @Test\n+    public static LargeValueWithOops test39(LargeValueWithOops vt) {\n+        return vt;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        LargeValueWithOops vt = new LargeValueWithOops();\n+        LargeValueWithOops res = test39(vt);\n+        Asserts.assertEQ(res, vt);\n+    }\n+\n+    \/\/ Test passing\/returning a large inline type with only int\/float fields\n+    @Test\n+    public static LargeValueWithoutOops test40(LargeValueWithoutOops vt) {\n+        return vt;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        LargeValueWithoutOops vt = new LargeValueWithoutOops();\n+        LargeValueWithoutOops res = test40(vt);\n+        Asserts.assertEQ(res, vt);\n+    }\n+\n+    \/\/ Test passing\/returning an empty inline type together with non-empty\n+    \/\/ inline types such that only some inline type arguments are scalarized.\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public MyValueEmpty test41(MyValue1 vt1, MyValueEmpty vt2, MyValue1 vt3) {\n+        return vt2.copy(vt2);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        MyValueEmpty res = test41(MyValue1.default, MyValueEmpty.default, MyValue1.default);\n+        Asserts.assertEQ(res, MyValueEmpty.default);\n+    }\n+\n+    \/\/ More empty inline type tests with containers\n+\n+    static primitive class EmptyContainer {\n+        private MyValueEmpty empty;\n+\n+        @ForceInline\n+        EmptyContainer(MyValueEmpty empty) {\n+            this.empty = empty;\n+        }\n+\n+        @ForceInline\n+        MyValueEmpty getInline() { return empty; }\n+\n+        @DontInline\n+        MyValueEmpty getNoInline() { return empty; }\n+    }\n+\n+    static primitive class MixedContainer {\n+        public int val;\n+        private EmptyContainer empty;\n+\n+        @ForceInline\n+        MixedContainer(int val, EmptyContainer empty) {\n+            this.val = val;\n+            this.empty = empty;\n+        }\n+\n+        @ForceInline\n+        EmptyContainer getInline() { return empty; }\n+\n+        @DontInline\n+        EmptyContainer getNoInline() { return empty; }\n+    }\n+\n+    \/\/ Empty inline type return\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public MyValueEmpty test42() {\n+        EmptyContainer c = new EmptyContainer(MyValueEmpty.default);\n+        return c.getInline();\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier() {\n+        MyValueEmpty empty = test42();\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Empty inline type container return\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public EmptyContainer test43(EmptyContainer c) {\n+        return c;\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier() {\n+        EmptyContainer c = test43(EmptyContainer. default);\n+        Asserts.assertEquals(c, EmptyContainer.default);\n+    }\n+\n+    \/\/ Empty inline type container (mixed) return\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public MixedContainer test44() {\n+        MixedContainer c = new MixedContainer(rI, EmptyContainer.default);\n+        c = new MixedContainer(rI, c.getInline());\n+        return c;\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier() {\n+        MixedContainer c = test44();\n+        Asserts.assertEquals(c, new MixedContainer(rI, EmptyContainer.default));\n+    }\n+\n+    \/\/ Empty inline type container argument\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public EmptyContainer test45(EmptyContainer c) {\n+        return new EmptyContainer(c.getInline());\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier() {\n+        EmptyContainer empty = test45(EmptyContainer.default);\n+        Asserts.assertEquals(empty, EmptyContainer.default);\n+    }\n+\n+    \/\/ Empty inline type container and mixed container arguments\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public MyValueEmpty test46(EmptyContainer c1, MixedContainer c2, MyValueEmpty empty) {\n+        c2 = new MixedContainer(c2.val, c1);\n+        return c2.getNoInline().getNoInline();\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        MyValueEmpty empty = test46(EmptyContainer.default, MixedContainer.default, MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ No receiver and only empty argument\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public static MyValueEmpty test47(MyValueEmpty empty) {\n+        return empty;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        MyValueEmpty empty = test47(MyValueEmpty.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ No receiver and only empty container argument\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public static MyValueEmpty test48(EmptyContainer empty) {\n+        return empty.getNoInline();\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        MyValueEmpty empty = test48(EmptyContainer.default);\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test conditional inline type return with incremental inlining\n+    public MyValue3 test49_inlined1(boolean b) {\n+        if (b) {\n+            return MyValue3.create();\n+        } else {\n+            return MyValue3.create();\n+        }\n+    }\n+\n+    public MyValue3 test49_inlined2(boolean b) {\n+        return test49_inlined1(b);\n+    }\n+\n+    @Test\n+    public void test49(boolean b) {\n+        test49_inlined2(b);\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        test49(true);\n+        test49(false);\n+    }\n+\n+    \/\/ Variant of test49 with result verification (triggered different failure mode)\n+    final MyValue3 test50_vt = MyValue3.create();\n+    final MyValue3 test50_vt2 = test50_vt;\n+\n+    public MyValue3 test50_inlined1(boolean b) {\n+        if (b) {\n+            return test50_vt;\n+        } else {\n+            return test50_vt2;\n+        }\n+    }\n+\n+    public MyValue3 test50_inlined2(boolean b) {\n+        return test50_inlined1(b);\n+    }\n+\n+    @Test\n+    public void test50(boolean b) {\n+        MyValue3 vt = test50_inlined2(b);\n+        test50_vt.verify(vt);\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        test50(true);\n+        test50(false);\n+    }\n+\n+    \/\/ Test stack repair with stack slots reserved for monitors\n+    private static final Object lock1 = new Object();\n+    private static final Object lock2 = new Object();\n+    private static final Object lock3 = new Object();\n+\n+    @DontInline\n+    static void test51_callee() { }\n+\n+    @Test\n+    public void test51(MyValue1 val) {\n+        synchronized (lock1) {\n+            test51_callee();\n+        }\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test51(vt);\n+    }\n+\n+    @DontInline\n+    static void test52_callee() { }\n+\n+    @Test\n+    public void test52(MyValue1 val) {\n+        synchronized (lock1) {\n+            synchronized (lock2) {\n+                test52_callee();\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test52(vt);\n+    }\n+\n+    @DontInline\n+    static void test53_callee() { }\n+\n+    @Test\n+    public void test53(MyValue1 val) {\n+        synchronized (lock1) {\n+            synchronized (lock2) {\n+                synchronized (lock3) {\n+                    test53_callee();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test53(vt);\n+    }\n+\n+    static MethodHandle test54_mh;\n+\n+    @DontInline\n+    public MyValue2.ref test54_callee() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that method handle invocation does not block scalarization of return value\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test54(Method m, boolean b1, boolean b2) throws Throwable {\n+        MyInterface obj = MyValue2.createWithFieldsInline(rI, rD);\n+        if (b1) {\n+            obj = (MyValue2.ref)test54_mh.invokeExact(this);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.hash();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test54\")\n+    @Warmup(10000)\n+    public void test54_verifier(RunInfo info) throws Throwable {\n+        Asserts.assertEQ(test54(info.getTest(), true, false), -1L);\n+        Asserts.assertEQ(test54(info.getTest(), false, false), -1L);\n+        if (!info.isWarmUp()) {\n+            MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+            Asserts.assertEQ(test54(info.getTest(), true, true), v.hash());\n+        }\n+    }\n+\n+    @DontInline\n+    public MyValue2.ref test55_callee() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test scalarization of nullable return value that is unused\n+    @Test\n+    public void test55() {\n+        test55_callee();\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        test55();\n+    }\n+\n+    static MethodHandle test56_mh;\n+\n+    @DontInline\n+    public MyValue2.ref test56_callee(boolean b) {\n+        return b ? MyValue2.createWithFieldsInline(rI, rD) : null;\n+    }\n+\n+    \/\/ Test that scalarization of nullable return works properly for method handle calls\n+    @Test\n+    public MyValue2.ref test56(boolean b) throws Throwable {\n+        return (MyValue2.ref)test56_mh.invokeExact(this, b);\n+    }\n+\n+    @Run(test = \"test56\")\n+    @Warmup(10000)\n+    public void test56_verifier(RunInfo info) throws Throwable {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        Asserts.assertEQ(test56(true).hash(), vt.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEQ(test56(false), null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":1277,"deletions":0,"binary":false,"changes":1277,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue1\n+    version 65:0\n+{\n+    static Field cnt:I;\n+    final Field x:I;\n+    final Field vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+    final Field vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+        getstatic cnt:I;\n+        iconst_1;\n+        iadd;\n+        putstatic cnt:I;\n+\n+        aconst_init compiler\/valhalla\/inlinetypes\/MyValue1;\n+\n+        getstatic cnt:I;\n+        withfield x:I;\n+\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        withfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        withfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+\n+        areturn;\n+    }\n+\n+    public Method hash:\"()I\" stack 2 {\n+        aload_0;\n+        getfield x:I;\n+\n+        aload_0;\n+        getfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n+        iadd;\n+\n+        aload_0;\n+        getfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n+        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n+        iadd;\n+\n+        ireturn;\n+    }\n+\n+    public Method testWithField:\"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield x:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue2\n+    version 65:0\n+{\n+    static Field cnt:I;\n+    final Field x:I;\n+\n+    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\" stack 2 {\n+        getstatic cnt:I;\n+        iconst_1;\n+        iadd;\n+        putstatic cnt:I;\n+\n+        aconst_init compiler\/valhalla\/inlinetypes\/MyValue2;\n+\n+        getstatic cnt:I;\n+        withfield x:I;\n+\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBufferingClasses.jasm","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,1634 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+\n+import jdk.internal.value.PrimitiveClass;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for inline types\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.value\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestIntrinsics.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestIntrinsics\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestIntrinsics {\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        for (Scenario scenario: scenarios) {\n+            scenario.addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                    \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\");\n+            \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n+            scenario.addFlags(\"-XX:-DeoptimizeALot\");\n+        }\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:PerMethodSpecTrapLimit=0\", \"-XX:PerMethodTrapLimit=0\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Test correctness of the Class::isAssignableFrom intrinsic\n+    @Test\n+    public boolean test1(Class<?> supercls, Class<?> subcls) {\n+        return supercls.isAssignableFrom(subcls);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), \"test1_1 failed\");\n+        Asserts.assertTrue(test1(PrimitiveClass.asPrimaryType(MyValue1.class), PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_2 failed\");\n+        Asserts.assertTrue(test1(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class)), \"test1_3 failed\");\n+        Asserts.assertTrue(test1(PrimitiveClass.asPrimaryType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class)), \"test1_4 failed\");\n+        Asserts.assertFalse(test1(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_5 failed\");\n+        Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), \"test1_6 failed\");\n+        Asserts.assertTrue(test1(Object.class, PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_7 failed\");\n+        Asserts.assertTrue(test1(Object.class, PrimitiveClass.asValueType(MyValue1.class)), \"test1_8 failed\");\n+        Asserts.assertTrue(!test1(PrimitiveClass.asPrimaryType(MyValue1.class), Object.class), \"test1_9 failed\");\n+        Asserts.assertTrue(!test1(PrimitiveClass.asValueType(MyValue1.class), Object.class), \"test1_10 failed\");\n+    }\n+\n+    \/\/ Verify that Class::isAssignableFrom checks with statically known classes are folded\n+    @Test\n+    @IR(failOn = {LOADK})\n+    public boolean test2() {\n+        boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);\n+        boolean check2 = PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n+        boolean check3 = PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n+        boolean check4 = PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n+        boolean check5 = !PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n+        boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);\n+        boolean check7 = Object.class.isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n+        boolean check8 = Object.class.isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n+        boolean check9 = !PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(Object.class);\n+        boolean check10 = !PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(Object.class);\n+        return check1 && check2 && check3 && check4 && check5 && check6 && check7 && check8 && check9 && check10;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        Asserts.assertTrue(test2(), \"test2 failed\");\n+    }\n+\n+    \/\/ Test correctness of the Class::getSuperclass intrinsic\n+    @Test\n+    public Class<?> test3(Class<?> cls) {\n+        return cls.getSuperclass();\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        Asserts.assertTrue(test3(Object.class) == null, \"test3_1 failed\");\n+        Asserts.assertTrue(test3(PrimitiveClass.asPrimaryType(MyValue1.class)) == MyAbstract.class, \"test3_2 failed\");\n+        Asserts.assertTrue(test3(PrimitiveClass.asValueType(MyValue1.class)) == MyAbstract.class, \"test3_3 failed\");\n+        Asserts.assertTrue(test3(Class.class) == Object.class, \"test3_4 failed\");\n+    }\n+\n+    \/\/ Verify that Class::getSuperclass checks with statically known classes are folded\n+    @Test\n+    @IR(failOn = {LOADK})\n+    public boolean test4() {\n+        boolean check1 = Object.class.getSuperclass() == null;\n+        boolean check2 = PrimitiveClass.asPrimaryType(MyValue1.class).getSuperclass() == MyAbstract.class;\n+        boolean check3 = PrimitiveClass.asValueType(MyValue1.class).getSuperclass() == MyAbstract.class;\n+        boolean check4 = Class.class.getSuperclass() == Object.class;\n+        return check1 && check2 && check3 && check4;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        Asserts.assertTrue(test4(), \"test4 failed\");\n+    }\n+\n+    \/\/ Test toString() method\n+    @Test\n+    public String test5(MyValue1 v) {\n+        return v.toString();\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1 v = MyValue1.createDefaultInline();\n+        test5(v);\n+    }\n+\n+    \/\/ Test hashCode() method\n+    @Test\n+    public int test6(MyValue1 v) {\n+        return v.hashCode();\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test6(v);\n+        Asserts.assertEQ(res, v.hashCode());\n+    }\n+\n+    \/\/ Test default inline type array creation via reflection\n+    @Test\n+    public Object[] test7(Class<?> componentType, int len) {\n+        Object[] va = (Object[])Array.newInstance(componentType, len);\n+        return va;\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        long hash = MyValue1.createDefaultDontInline().hashPrimitive();\n+        Object[] va = test7(PrimitiveClass.asValueType(MyValue1.class), len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);\n+        }\n+    }\n+\n+    \/\/ Class.isInstance\n+    @Test\n+    public boolean test8(Class c, MyValue1 vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test8(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Asserts.assertTrue(result);\n+        result = test8(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    public boolean test9(Class c, MyValue1 vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test9(MyValue2.class, vt);\n+        Asserts.assertFalse(result);\n+        result = test9(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Class.cast\n+    @Test\n+    public Object test10(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test10(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public Object test11(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            test11(MyValue2.class, vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test12(MyValue1 vt) {\n+        return PrimitiveClass.asValueType(MyValue1.class).cast(vt);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test12(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public Object test13(MyValue1 vt) {\n+        return MyValue2.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            test13(vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ inline type array creation via reflection\n+    @Test\n+    public void test14(int len, long hash) {\n+        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);\n+        }\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        long hash = MyValue1.createDefaultDontInline().hashPrimitive();\n+        test14(len, hash);\n+    }\n+\n+    \/\/ Test hashCode() method\n+    @Test\n+    public int test15(Object v) {\n+        return v.hashCode();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test15(v);\n+        Asserts.assertEQ(res, v.hashCode());\n+    }\n+\n+    @Test\n+    public int test16(Object v) {\n+        return System.identityHashCode(v);\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test16(v);\n+        Asserts.assertEQ(res, System.identityHashCode((Object)v));\n+    }\n+\n+    @Test\n+    public int test17(Object v) {\n+        return System.identityHashCode(v);\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        Integer v = Integer.valueOf(rI);\n+        int res = test17(v);\n+        Asserts.assertEQ(res, System.identityHashCode(v));\n+    }\n+\n+    @Test\n+    public int test18(Object v) {\n+        return System.identityHashCode(v);\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        Object v = null;\n+        int res = test18(v);\n+        Asserts.assertEQ(res, System.identityHashCode(v));\n+    }\n+\n+    \/\/ hashCode() and toString() with different inline types\n+    @Test\n+    public int test19(MyValue1 vt1, MyValue1 vt2, boolean b) {\n+        MyValue1 res = b ? vt1 : vt2;\n+        return res.hashCode();\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test19(vt, vt, true);\n+        Asserts.assertEQ(res, vt.hashCode());\n+        res = test19(vt, vt, false);\n+        Asserts.assertEQ(res, vt.hashCode());\n+    }\n+\n+    @Test\n+    public String test20(MyValue1 vt1, MyValue1 vt2, boolean b) {\n+        MyValue1 res = b ? vt1 : vt2;\n+        return res.toString();\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        String res = test20(vt, vt, true);\n+        Asserts.assertEQ(res, vt.toString());\n+        res = test20(vt, vt, false);\n+        Asserts.assertEQ(res, vt.toString());\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long X_OFFSET;\n+    private static final long Y_OFFSET;\n+    private static final long V1_OFFSET;\n+    private static final boolean V1_FLATTENED;\n+    static {\n+        try {\n+            Field xField = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"x\");\n+            X_OFFSET = U.objectFieldOffset(xField);\n+            Field yField = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"y\");\n+            Y_OFFSET = U.objectFieldOffset(yField);\n+            Field v1Field = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"v1\");\n+            V1_OFFSET = U.objectFieldOffset(v1Field);\n+            V1_FLATTENED = U.isFlattened(v1Field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test21(MyValue1 v) {\n+       return U.getInt(v, X_OFFSET);\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test21(v);\n+        Asserts.assertEQ(res, v.x);\n+    }\n+\n+    MyValue1 test22_vt;\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    public void test22(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        U.putInt(v, X_OFFSET, rI);\n+        v = U.finishPrivateBuffer(v);\n+        test22_vt = v;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        test22(v.setX(v, 0));\n+        Asserts.assertEQ(test22_vt.hash(), v.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test23(MyValue1 v, long offset) {\n+        return U.getInt(v, offset);\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test23(v, X_OFFSET);\n+        Asserts.assertEQ(res, v.x);\n+    }\n+\n+    MyValue1 test24_vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test24(long offset) {\n+        return U.getInt(test24_vt, offset);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int res = test24(X_OFFSET);\n+        Asserts.assertEQ(res, test24_vt.x);\n+    }\n+\n+    \/\/ Test copyOf intrinsic with allocated inline type in it's debug information\n+    final primitive class Test25Value {\n+        final int x;\n+        public Test25Value() {\n+            this.x = 42;\n+        }\n+    }\n+\n+    final Test25Value[] test25Array = new Test25Value[10];\n+\n+    @Test\n+    public Test25Value[] test25(Test25Value element) {\n+        Object[] newArray = Arrays.copyOf(test25Array, test25Array.length + 1);\n+        newArray[test25Array.length] = element;\n+        return (Test25Value[]) newArray;\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        Test25Value vt = new Test25Value();\n+        test25(vt);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD_I) \/\/ Load of the default value should be folded\n+    public Object test26() {\n+        Class<?>[] ca = new Class<?>[1];\n+        for (int i = 0; i < 1; ++i) {\n+          \/\/ Folds during loop opts\n+          ca[i] = PrimitiveClass.asValueType(MyValue1.class);\n+        }\n+        return Array.newInstance(ca[0], 1);\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        Object[] res = (Object[])test26();\n+        Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());\n+    }\n+\n+    \/\/ Load non-flattenable inline type field with unsafe\n+    MyValue1.ref test27_vt;\n+    private static final long TEST27_OFFSET;\n+    static {\n+        try {\n+            Field field = TestIntrinsics.class.getDeclaredField(\"test27_vt\");\n+            TEST27_OFFSET = U.objectFieldOffset(field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1.ref test27() {\n+        return (MyValue1.ref)U.getReference(this, TEST27_OFFSET);\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        test27_vt = null;\n+        MyValue1.ref res = test27();\n+        Asserts.assertEQ(res, null);\n+        test27_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        res = test27();\n+        Asserts.assertEQ(res.hash(), test24_vt.hash());\n+    }\n+\n+    \/\/ Mismatched type\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test28(MyValue1 v) {\n+        return U.getByte(v, X_OFFSET);\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test28(v);\n+        if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {\n+            Asserts.assertEQ(res, (int)((byte)v.x));\n+        } else {\n+            Asserts.assertEQ(res, (int)((byte)Integer.reverseBytes(v.x)));\n+        }\n+    }\n+\n+    \/\/ Wrong alignment\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public long test29(MyValue1 v) {\n+        \/\/ Read the field that's guaranteed to not be last in the\n+        \/\/ inline type so we don't read out of bounds.\n+        if (X_OFFSET < Y_OFFSET) {\n+            return U.getInt(v, X_OFFSET+1);\n+        }\n+        return U.getLong(v, Y_OFFSET+1);\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        long res = test29(v);\n+        if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {\n+            if (X_OFFSET < Y_OFFSET) {\n+                Asserts.assertEQ(((int)res) << 8, (v.x >> 8) << 8);\n+            } else {\n+                Asserts.assertEQ(res << 8, (v.y >> 8) << 8);\n+            }\n+        } else {\n+            if (X_OFFSET < Y_OFFSET) {\n+                Asserts.assertEQ(((int)res), v.x >>> 8);\n+            } else {\n+                Asserts.assertEQ(res, v.y >>> 8);\n+            }\n+        }\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from inline type\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test30(MyValue1 v) {\n+        if (V1_FLATTENED) {\n+            return U.getValue(v, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+        }\n+        return (MyValue2)U.getReference(v, V1_OFFSET);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier(RunInfo info) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue2 res = test30(v);\n+        Asserts.assertEQ(res.hash(), v.v1.hash());\n+    }\n+\n+    MyValue1 test31_vt;\n+    private static final long TEST31_VT_OFFSET;\n+    private static final boolean TEST31_VT_FLATTENED;\n+    static {\n+        try {\n+            Field test31_vt_Field = TestIntrinsics.class.getDeclaredField(\"test31_vt\");\n+            TEST31_VT_OFFSET = U.objectFieldOffset(test31_vt_Field);\n+            TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from object\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test31() {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.getValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class));\n+        }\n+        return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier() {\n+        test31_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test31();\n+        Asserts.assertEQ(res.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in object\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public void test32(MyValue1 vt) {\n+        if (TEST31_VT_FLATTENED) {\n+            U.putValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), vt);\n+        } else {\n+            U.putReference(this, TEST31_VT_OFFSET, vt);\n+        }\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+        test32(vt);\n+        Asserts.assertEQ(vt.hash(), test31_vt.hash());\n+    }\n+\n+    private static final int TEST33_BASE_OFFSET;\n+    private static final int TEST33_INDEX_SCALE;\n+    private static final boolean TEST33_FLATTENED_ARRAY;\n+    static {\n+        try {\n+            TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);\n+            TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);\n+            TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    \/\/ getValue to retrieve flattened field from array\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test33(MyValue1[] arr) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class));\n+        }\n+        return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        arr[1] = vt;\n+        MyValue1 res = test33(arr);\n+        Asserts.assertEQ(res.hash(), vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in array\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public void test34(MyValue1[] arr, MyValue1 vt) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), vt);\n+        } else {\n+            U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);\n+        }\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test34(arr, vt);\n+        Asserts.assertEQ(arr[1].hash(), vt.hash());\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from object with unknown\n+    \/\/ container type\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test35(Object o) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.getValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class));\n+        }\n+        return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier() {\n+        test31_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test35(this);\n+        Asserts.assertEQ(res.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from object at unknown\n+    \/\/ offset\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test36(long offset) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.getValue(this, offset, PrimitiveClass.asValueType(MyValue1.class));\n+        }\n+        return (MyValue1)U.getReference(this, offset);\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() {\n+        test31_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test36(TEST31_VT_OFFSET);\n+        Asserts.assertEQ(res.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in object with unknown\n+    \/\/ container\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public void test37(Object o, MyValue1 vt) {\n+        if (TEST31_VT_FLATTENED) {\n+            U.putValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), vt);\n+        } else {\n+            U.putReference(o, TEST31_VT_OFFSET, vt);\n+        }\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+        test37(this, vt);\n+        Asserts.assertEQ(vt.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in object, non inline argument\n+    \/\/ to store\n+    @Test\n+    @IR(counts = {CALL_UNSAFE, \"= 1\"})\n+    public void test38(Object o) {\n+        if (TEST31_VT_FLATTENED) {\n+            U.putValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), o);\n+        } else {\n+            U.putReference(this, TEST31_VT_OFFSET, o);\n+        }\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+        test38(vt);\n+        Asserts.assertEQ(vt.hash(), test31_vt.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test39(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        U.putInt(v, X_OFFSET, rI);\n+        v = U.finishPrivateBuffer(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test39(v.setX(v, 0));\n+        Asserts.assertEQ(res.hash(), v.hash());\n+    }\n+\n+    \/\/ Test default inline type array creation via reflection\n+    @Test\n+    public Object[] test40(Class<?> componentType, int len) {\n+        Object[] va = (Object[])Array.newInstance(componentType, len);\n+        return va;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        Object[] va = test40(PrimitiveClass.asPrimaryType(MyValue1.class), len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Class.isInstance\n+    @Test\n+    public boolean test41(Class c, MyValue1.ref vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test41(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        Asserts.assertTrue(result);\n+        result = test41(PrimitiveClass.asPrimaryType(MyValue1.class), null);\n+        Asserts.assertFalse(result);\n+        result = test41(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Asserts.assertTrue(result);\n+        result = test41(PrimitiveClass.asValueType(MyValue1.class), null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    public boolean test42(Class c, MyValue1.ref vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test42(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+        Asserts.assertFalse(result);\n+        result = test42(PrimitiveClass.asPrimaryType(MyValue2.class), null);\n+        Asserts.assertFalse(result);\n+        result = test42(PrimitiveClass.asValueType(MyValue2.class), vt);\n+        Asserts.assertFalse(result);\n+        result = test42(PrimitiveClass.asValueType(MyValue2.class), null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Class.cast\n+    @Test\n+    public Object test43(Class c, MyValue1.ref vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test43(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        Asserts.assertEQ(result, vt);\n+        result = test43(PrimitiveClass.asPrimaryType(MyValue1.class), null);\n+        Asserts.assertEQ(result, null);\n+        result = test43(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Asserts.assertEQ(result, vt);\n+        try {\n+            test43(PrimitiveClass.asValueType(MyValue1.class), null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n+        result = test43(Integer.class, null);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    @Test\n+    public Object test44(Class c, MyValue1.ref vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            test44(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+        Object res = test44(PrimitiveClass.asPrimaryType(MyValue2.class), null);\n+        Asserts.assertEQ(res, null);\n+        try {\n+            test44(PrimitiveClass.asValueType(MyValue2.class), vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+        try {\n+            test44(PrimitiveClass.asValueType(MyValue2.class), null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test45(MyValue1.ref vt) {\n+        return PrimitiveClass.asPrimaryType(MyValue1.class).cast(vt);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test45(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test45(null);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    @Test\n+    public Object test46(MyValue1.ref vt) {\n+        return PrimitiveClass.asPrimaryType(MyValue2.class).cast(vt);\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test46(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test46(vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test47(MyValue1.ref vt) {\n+        return PrimitiveClass.asValueType(MyValue1.class).cast(vt);\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test47(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        try {\n+            test47(null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test48(Class c, MyValue1.ref vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test48(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        try {\n+            test48(PrimitiveClass.asValueType(MyValue1.class), null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test49(MyValue1 vt) {\n+        return PrimitiveClass.asPrimaryType(MyValue1.class).cast(vt);\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test49(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public Object test50(Class c, Object obj) {\n+        return c.cast(obj);\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1[] va  = new MyValue1[42];\n+        MyValue1.ref[] vba = new MyValue1.ref[42];\n+        Object result = test50(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test50(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test50(MyValue1[].class, va);\n+        Asserts.assertEQ(result, va);\n+        result = test50(MyValue1.ref[].class, vba);\n+        Asserts.assertEQ(result, vba);\n+        result = test50(MyValue1.ref[].class, va);\n+        Asserts.assertEQ(result, va);\n+        try {\n+            test50(PrimitiveClass.asValueType(MyValue1.class), null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n+        try {\n+            test50(MyValue1[].class, vba);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ inline type array creation via reflection\n+    @Test\n+    public void test51(int len) {\n+        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asPrimaryType(MyValue1.class), len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        test51(len);\n+    }\n+\n+    \/\/ multidimensional inline type array creation via reflection\n+    @Test\n+    public Object[][] test52(int len, int val) {\n+        MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n+        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);\n+        Object[][] result;\n+        if (val == 1) {\n+            va1[0] = new MyValue1[1];\n+            result = va1;\n+        } else {\n+            va2[0] = new MyValue1.ref[1];\n+            result = va2;\n+        }\n+        if (val == 1) {\n+            Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());\n+        } else {\n+            Asserts.assertEQ(result[0][0], null);\n+            result[0][0] = null;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        test52(1, 1);\n+        test52(1, 2);\n+    }\n+\n+    @Test\n+    public Object[][] test53(Class<?> c1, Class<?> c2, int len, int val) {\n+        MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n+        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);\n+        Object[][] va3 = (Object[][])Array.newInstance(c1, len);\n+        Object[][] va4 = (Object[][])Array.newInstance(c2, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va1[i], null);\n+            Asserts.assertEQ(va2[i], null);\n+            Asserts.assertEQ(va3[i], null);\n+            Asserts.assertEQ(va4[i], null);\n+            va1[i] = new MyValue1[1];\n+            va2[i] = new MyValue1.ref[1];\n+            va3[i] = new MyValue1[1];\n+            va4[i] = new MyValue1.ref[1];\n+            Asserts.assertEQ(va1[i][0].hash(), ((MyValue1)va3[i][0]).hash());\n+            Asserts.assertEQ(va2[i][0], null);\n+            Asserts.assertEQ(va4[i][0], null);\n+        }\n+        Object[][] result;\n+        if (val == 1) {\n+            result = va1;\n+        } else if (val == 2) {\n+            result = va2;\n+        } else if (val == 3) {\n+            result = va3;\n+        } else {\n+            result = va4;\n+        }\n+        if ((val == 1 || val == 3) && len > 0) {\n+            Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());\n+        } else if (len > 0) {\n+            Asserts.assertEQ(result[0][0], null);\n+            result[0][0] = null;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        test53(MyValue1[].class, MyValue1.ref[].class, len, 1);\n+        test53(MyValue1[].class, MyValue1.ref[].class, len, 2);\n+        test53(MyValue1[].class, MyValue1.ref[].class, len, 3);\n+        test53(MyValue1[].class, MyValue1.ref[].class, len, 4);\n+    }\n+\n+    \/\/ TODO 8239003 Re-enable\n+    \/*\n+    \/\/ Same as test39 but Unsafe.putInt to buffer is not intrinsified\/compiled\n+    @DontCompile\n+    public void test54_callee(Object v) { \/\/ Use Object here to make sure the argument is not scalarized (otherwise larval information is lost)\n+        U.putInt(v, X_OFFSET, rI);\n+    }\n+\n+    @Test\n+    public MyValue1 test54(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        test54_callee(v);\n+        v = U.finishPrivateBuffer(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test54\")\n+    @Warmup(10000) \/\/ Fill up the TLAB to trigger slow path allocation\n+    public void test54_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test54(v.setX(v, 0));\n+        Asserts.assertEQ(res.hash(), v.hash());\n+    }\n+    *\/\n+\n+    static final MyValue1 test55_vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    \/\/ Same as test30 but with constant field holder\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test55() {\n+        if (V1_FLATTENED) {\n+            return U.getValue(test55_vt, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+        }\n+        return (MyValue2)U.getReference(test55_vt, V1_OFFSET);\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        MyValue2 res = test55();\n+        Asserts.assertEQ(res.hash(), test55_vt.v1.hash());\n+    }\n+\n+    \/\/ Test OptimizePtrCompare part of Escape Analysis\n+    @Test\n+    public void test56(int idx) {\n+        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), 1);\n+        if (va[idx] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        test56(0);\n+    }\n+\n+    \/\/ Same as test56 but with load from known array index\n+    @Test\n+    public void test57() {\n+        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), 1);\n+        if (va[0] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        test57();\n+    }\n+\n+    \/\/ Test unsafe allocation\n+    @Test\n+    public boolean test58(Class<?> c1, Class<?> c2) throws Exception {\n+        Object obj1 = U.allocateInstance(c1);\n+        Object obj2 = U.allocateInstance(c2);\n+        return obj1 == obj2;\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier() throws Exception {\n+        boolean res = test58(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class));\n+        Asserts.assertTrue(res);\n+        res = test58(Object.class, PrimitiveClass.asValueType(MyValue1.class));\n+        Asserts.assertFalse(res);\n+        res = test58(PrimitiveClass.asValueType(MyValue1.class), Object.class);\n+        Asserts.assertFalse(res);\n+    }\n+\n+    \/\/ Test synchronization on unsafe inline type allocation\n+    @Test\n+    public void test59(Class<?> c) throws Exception {\n+        Object obj = U.allocateInstance(c);\n+        synchronized (obj) {\n+\n+        }\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() throws Exception {\n+        test59(Integer.class);\n+        try {\n+            test59(PrimitiveClass.asValueType(MyValue1.class));\n+            throw new RuntimeException(\"test59 failed: synchronization on inline type should not succeed\");\n+        } catch (IllegalMonitorStateException e) {\n+\n+        }\n+    }\n+\n+    \/\/ Test mark word load optimization on unsafe inline type allocation\n+    @Test\n+    public boolean test60(Class<?> c1, Class<?> c2, boolean b1, boolean b2) throws Exception {\n+        Object obj1 = b1 ? new Object() : U.allocateInstance(c1);\n+        Object obj2 = b2 ? new Object() : U.allocateInstance(c2);\n+        return obj1 == obj2;\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() throws Exception {\n+        Asserts.assertTrue(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), false, false));\n+        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), MyValue2.class, false, false));\n+        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), false, true));\n+        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), true, false));\n+        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), true, true));\n+    }\n+\n+    \/\/ Test asPrimaryType intrinsic with non-value mirror\n+    @Test\n+    public Class<?> test61(Class<?> c) {\n+        if (PrimitiveClass.asPrimaryType(c) != Integer.class) {\n+            throw new RuntimeException(\"Unexpected class\");\n+        }\n+        return PrimitiveClass.asPrimaryType(Integer.class);\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        Class<?> result = test61(Integer.class);\n+        Asserts.assertEQ(result, Integer.class);\n+    }\n+\n+    \/\/ Test asValueType intrinsic with non-value mirror\n+    @Test\n+    public Class<?> test62(Class<?> c) {\n+        try {\n+            PrimitiveClass.asValueType(c);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (UnsupportedOperationException ex) {\n+            \/\/ Expected\n+        }\n+        return PrimitiveClass.asValueType(Integer.class);\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        try {\n+            test62(Integer.class);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (UnsupportedOperationException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object\n+    @Test\n+    public boolean test63(MyValue1 oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.default;\n+\n+        boolean res = test63(test31_vt, vt);\n+        \/\/ Checks are disabled for non-flattened field because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertTrue(res);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+\n+        res = test63(MyValue1.default, MyValue1.default);\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertFalse(res);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in array\n+    @Test\n+    public boolean test64(MyValue1[] arr, MyValue1 oldVal, Object newVal) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.compareAndSetValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        boolean res = test64(arr, arr[1], vt);\n+        \/\/ Checks are disabled for non-flattened array because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertTrue(res);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+\n+        res = test64(arr, MyValue1.default, MyValue1.default);\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertFalse(res);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object with unknown container\n+    @Test\n+    public boolean test65(Object o, Object oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(o, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.default;\n+\n+        boolean res = test65(this, test31_vt, vt);\n+        Asserts.assertTrue(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test65(this, MyValue1.default, MyValue1.default);\n+        Asserts.assertFalse(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public boolean test66(Object oldVal, Object newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.default;\n+\n+        boolean res = test66(test31_vt, vt);\n+        Asserts.assertTrue(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test66(MyValue1.default, MyValue1.default);\n+        Asserts.assertFalse(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object\n+    @Test\n+    public Object test67(MyValue1 oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.default;\n+        test31_vt = oldVal;\n+\n+        Object res = test67(test31_vt, vt);\n+        \/\/ Checks are disabled for non-flattened field because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertEQ(res, oldVal);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+\n+        res = test67(MyValue1.default, MyValue1.default);\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertEQ(res, vt);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in array\n+    @Test\n+    public Object test68(MyValue1[] arr, MyValue1 oldVal, Object newVal) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.compareAndExchangeValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        Object res = test68(arr, arr[1], vt);\n+        \/\/ Checks are disabled for non-flattened array because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertEQ(res, MyValue1.default);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+\n+        res = test68(arr, MyValue1.default, MyValue1.default);\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertEQ(res, vt);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object with unknown container\n+    @Test\n+    public Object test69(Object o, Object oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(o, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.default;\n+        test31_vt = oldVal;\n+\n+        Object res = test69(this, test31_vt, vt);\n+        Asserts.assertEQ(res, oldVal);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test69(this, MyValue1.default, MyValue1.default);\n+        Asserts.assertEQ(res, vt);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public Object test70(Object oldVal, Object newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.default;\n+        test31_vt = oldVal;\n+\n+        Object res = test70(test31_vt, vt);\n+        Asserts.assertEQ(res, oldVal);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test70(MyValue1.default, MyValue1.default);\n+        Asserts.assertEQ(res, vt);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from (nullable) inline type\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test71(boolean b, MyValue1.val v1, MyValue1.ref v2) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v1, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+            }\n+            return (MyValue2)U.getReference(v1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v2, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+            }\n+            return (MyValue2)U.getReference(v2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test71(true, v, v), v.v1);\n+        Asserts.assertEQ(test71(false, v, v), v.v1);\n+    }\n+\n+    \/\/ Same as test71 but with non-constant offset\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test72(boolean b, MyValue1.val v1, MyValue1.ref v2, long offset) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v1, offset, PrimitiveClass.asValueType(MyValue2.class));\n+            }\n+            return (MyValue2)U.getReference(v1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v2, offset, PrimitiveClass.asValueType(MyValue2.class));\n+            }\n+            return (MyValue2)U.getReference(v2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test72\")\n+    public void test72_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test72(true, v, v, V1_OFFSET), v.v1);\n+        Asserts.assertEQ(test72(false, v, v, V1_OFFSET), v.v1);\n+    }\n+\n+    static final MyValue1.val test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n+    static final MyValue1.ref test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+\n+    \/\/ Same as test72 but with constant base\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test73(boolean b, long offset) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getValue(test73_value1, offset, PrimitiveClass.asValueType(MyValue2.class));\n+            }\n+            return (MyValue2)U.getReference(test73_value1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getValue(test73_value2, offset, PrimitiveClass.asValueType(MyValue2.class));\n+            }\n+            return (MyValue2)U.getReference(test73_value2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        Asserts.assertEQ(test73(true, V1_OFFSET), test73_value1.v1);\n+        Asserts.assertEQ(test73(false, V1_OFFSET), test73_value2.v1);\n+    }\n+\n+    static primitive class EmptyInline {\n+\n+    }\n+\n+    static primitive class ByteInline {\n+        byte x = 0;\n+    }\n+\n+    @Test\n+    public void test74(EmptyInline[] emptyArray) {\n+        System.arraycopy(emptyArray, 0, emptyArray, 10, 10);\n+        System.arraycopy(emptyArray, 0, emptyArray, 20, 10);\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        EmptyInline[] emptyArray = new EmptyInline[100];\n+        test74(emptyArray);\n+        for (EmptyInline empty : emptyArray) {\n+            Asserts.assertEQ(empty, EmptyInline.default);\n+        }\n+    }\n+\n+    @Test\n+    public void test75(EmptyInline[] emptyArray) {\n+        System.arraycopy(emptyArray, 0, emptyArray, 10, 10);\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        EmptyInline[] emptyArray = new EmptyInline[100];\n+        test75(emptyArray);\n+        for (EmptyInline empty : emptyArray) {\n+            Asserts.assertEQ(empty, EmptyInline.default);\n+        }\n+    }\n+\n+    @Test\n+    public void test76(ByteInline[] byteArray) {\n+        System.arraycopy(byteArray, 0, byteArray, 10, 10);\n+        System.arraycopy(byteArray, 0, byteArray, 20, 10);\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() {\n+        ByteInline[] byteArray = new ByteInline[100];\n+        test76(byteArray);\n+        for (ByteInline b : byteArray) {\n+            Asserts.assertEQ(b, ByteInline.default);\n+        }\n+    }\n+\n+    @Test\n+    public void test77(ByteInline[] byteArray) {\n+        System.arraycopy(byteArray, 0, byteArray, 10, 10);\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() {\n+        ByteInline[] byteArray = new ByteInline[100];\n+        test77(byteArray);\n+        for (ByteInline b : byteArray) {\n+            Asserts.assertEQ(b, ByteInline.default);\n+        }\n+    }\n+\n+    @Test\n+    public Object test78(MyValue1.ref vt) {\n+        return Integer.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        Object result = test78(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test78(MyValue1.createWithFieldsInline(rI, rL));\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ TODO 8284443 Fix this in GraphKit::gen_checkcast\n+    \/*\n+    @Test\n+    public Object test79(MyValue1.ref vt) {\n+        Object tmp = vt;\n+        return (Integer)tmp;\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        Object result = test79(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test79(MyValue1.createWithFieldsInline(rI, rL));\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+    *\/\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1634,"deletions":0,"binary":false,"changes":1634,"status":"added"},{"patch":"@@ -0,0 +1,4386 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import jdk.experimental.bytecode.TypeTag;\n+import java.util.Arrays;\n+\n+import jdk.internal.value.PrimitiveClass;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @modules java.base\/jdk.internal.value\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile -XDenablePrimitiveClasses MyValue5.jcod\n+ * @compile -XDenablePrimitiveClasses TestLWorld.java\n+ * @run main\/othervm\/timeout=450 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestLWorld\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestLWorld {\n+\n+    public static void main(String[] args) {\n+        \/\/ Make sure Test140Value is loaded but not linked\n+        Class<?> class1 = Test140Value.class;\n+        \/\/ Make sure Test141Value is linked but not initialized\n+        Class<?> class2 = Test141Value.class;\n+        class2.getDeclaredFields();\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Helper methods\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);\n+\n+    protected long hash() {\n+        return testValue1.hash();\n+    }\n+\n+    \/\/ Test passing an inline type as an Object\n+    @DontInline\n+    public Object test1_dontinline1(Object o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test1_dontinline2(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public Object test1_inline1(Object o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test1_inline2(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test1() {\n+        MyValue1 vt = testValue1;\n+        vt = (MyValue1)test1_dontinline1(vt);\n+        vt =           test1_dontinline2(vt);\n+        vt = (MyValue1)test1_inline1(vt);\n+        vt =           test1_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        Asserts.assertEQ(test1().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from Object and inline type fields\n+    Object objectField1 = null;\n+    Object objectField2 = null;\n+    Object objectField3 = null;\n+    Object objectField4 = null;\n+    Object objectField5 = null;\n+    Object objectField6 = null;\n+\n+    MyValue1 valueField1 = testValue1;\n+    MyValue1 valueField2 = testValue1;\n+    MyValue1.ref valueField3 = testValue1;\n+    MyValue1 valueField4;\n+    MyValue1.ref valueField5;\n+\n+    static MyValue1.ref staticValueField1 = testValue1;\n+    static MyValue1 staticValueField2 = testValue1;\n+    static MyValue1 staticValueField3;\n+    static MyValue1.ref staticValueField4;\n+\n+    @DontInline\n+    public Object readValueField5() {\n+        return (Object)valueField5;\n+    }\n+\n+    @DontInline\n+    public Object readStaticValueField4() {\n+        return (Object)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test2(MyValue1 vt1, Object vt2) {\n+        objectField1 = vt1;\n+        objectField2 = (MyValue1)vt2;\n+        objectField3 = testValue1;\n+        objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        objectField5 = valueField1;\n+        objectField6 = valueField3;\n+        valueField1 = (MyValue1)objectField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)objectField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5() != null || readStaticValueField4() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)objectField1).hash() + ((MyValue1)objectField2).hash() +\n+               ((MyValue1)objectField3).hash() + ((MyValue1)objectField4).hash() +\n+               ((MyValue1)objectField5).hash() + ((MyValue1)objectField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test2(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    \/\/ Test merging inline types and objects\n+    @Test\n+    public Object test3(int state) {\n+        Object res = null;\n+        if (state == 0) {\n+            res = Integer.valueOf(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        } else if (state == 6) {\n+            res = MyValue2.createWithFieldsInline(rI, rD);\n+        } else if (state == 7) {\n+            res = testValue2;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        objectField1 = valueField1;\n+        Object result = null;\n+        result = test3(0);\n+        Asserts.assertEQ((Integer)result, rI);\n+        result = test3(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(5);\n+        Asserts.assertEQ(result, null);\n+        result = test3(6);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+        result = test3(7);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+    }\n+\n+    \/\/ Test merging inline types and objects in loops\n+    @Test\n+    public Object test4(int iters) {\n+        Object res = Integer.valueOf(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof Integer) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        Integer result1 = (Integer)test4(0);\n+        Asserts.assertEQ(result1, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test4(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in object variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP})\n+    public long test5(MyValue1 arg, boolean deopt, Method m) {\n+        Object vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        Object vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        Object vt3 = arg;\n+        Object vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier(RunInfo info) {\n+        long result = test5(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with objects\n+    @Test\n+    public boolean test6(Object arg) {\n+        Object vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (Object)valueField1 || vt == objectField1 || vt == null ||\n+            arg == vt || (Object)valueField1 == vt || objectField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        boolean result = test6(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ merge of inline type and non-inline type\n+    @Test\n+    public Object test7(boolean flag) {\n+        Object res = null;\n+        if (flag) {\n+            res = valueField1;\n+        } else {\n+            res = objectField1;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        test7(true);\n+        test7(false);\n+    }\n+\n+    @Test\n+    public Object test8(boolean flag) {\n+        Object res = null;\n+        if (flag) {\n+            res = objectField1;\n+        } else {\n+            res = valueField1;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        test8(true);\n+        test8(false);\n+    }\n+\n+    \/\/ merge of inline types in a loop, stored in an object local\n+    @Test\n+    public Object test9() {\n+        Object o = valueField1;\n+        for (int i = 1; i < 100; i *= 2) {\n+            MyValue1 v = (MyValue1)o;\n+            o = MyValue1.setX(v, v.x + 1);\n+        }\n+        return o;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9();\n+    }\n+\n+    \/\/ merge of inline types in an object local\n+    @ForceInline\n+    public Object test10_helper() {\n+        return valueField1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test10(boolean flag) {\n+        Object o = null;\n+        if (flag) {\n+            o = valueField1;\n+        } else {\n+            o = test10_helper();\n+        }\n+        valueField1 = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        test10(true);\n+        test10(false);\n+    }\n+\n+    \/\/ Interface tests\n+\n+    @DontInline\n+    public MyInterface test11_dontinline1(MyInterface o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test11_dontinline2(MyInterface o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public MyInterface test11_inline1(MyInterface o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test11_inline2(MyInterface o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    public MyValue1 test11() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        vt = (MyValue1)test11_dontinline1(vt);\n+        vt =           test11_dontinline2(vt);\n+        vt = (MyValue1)test11_inline1(vt);\n+        vt =           test11_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        Asserts.assertEQ(test11().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from interface and inline type fields\n+    MyInterface interfaceField1 = null;\n+    MyInterface interfaceField2 = null;\n+    MyInterface interfaceField3 = null;\n+    MyInterface interfaceField4 = null;\n+    MyInterface interfaceField5 = null;\n+    MyInterface interfaceField6 = null;\n+\n+    @DontInline\n+    public MyInterface readValueField5AsInterface() {\n+        return (MyInterface)valueField5;\n+    }\n+\n+    @DontInline\n+    public MyInterface readStaticValueField4AsInterface() {\n+        return (MyInterface)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test12(MyValue1 vt1, MyInterface vt2) {\n+        interfaceField1 = vt1;\n+        interfaceField2 = (MyValue1)vt2;\n+        interfaceField3 = MyValue1.createWithFieldsInline(rI, rL);\n+        interfaceField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        interfaceField5 = valueField1;\n+        interfaceField6 = valueField3;\n+        valueField1 = (MyValue1)interfaceField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)interfaceField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +\n+               ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +\n+               ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test12(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    class MyObject1 implements MyInterface {\n+        public int x;\n+\n+        public MyObject1(int x) {\n+            this.x = x;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Test merging inline types and interfaces\n+    @Test\n+    public MyInterface test13(int state) {\n+        MyInterface res = null;\n+        if (state == 0) {\n+            res = new MyObject1(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        objectField1 = valueField1;\n+        MyInterface result = null;\n+        result = test13(0);\n+        Asserts.assertEQ(((MyObject1)result).x, rI);\n+        result = test13(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(5);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ Test merging inline types and interfaces in loops\n+    @Test\n+    public MyInterface test14(int iters) {\n+        MyInterface res = new MyObject1(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof MyObject1) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        MyObject1 result1 = (MyObject1)test14(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test14(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in interface variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP})\n+    public long test15(MyValue1 arg, boolean deopt, Method m) {\n+        MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyInterface vt3 = arg;\n+        MyInterface vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier(RunInfo info) {\n+        long result = test15(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with interfaces\n+    @Test\n+    public boolean test16(Object arg) {\n+        MyInterface vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (MyInterface)valueField1 || vt == interfaceField1 || vt == null ||\n+            arg == vt || (MyInterface)valueField1 == vt || interfaceField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        boolean result = test16(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Test subtype check when casting to inline type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test17(MyValue1 vt, Object obj) {\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test17(vt, Integer.valueOf(rI));\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public MyValue1 test18(MyValue1 vt) {\n+        Object obj = vt;\n+        vt = (MyValue1)obj;\n+        return vt;\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test18(vt);\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test19(MyValue1 vt) {\n+        Object obj = vt;\n+        try {\n+            MyValue2 vt2 = (MyValue2)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        test19(valueField1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test20(MyValue1 vt) {\n+        Object obj = vt;\n+        try {\n+            Integer i = (Integer)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        test20(valueField1);\n+    }\n+\n+    \/\/ Array tests\n+\n+    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,\n+                                                                      testValue1,\n+                                                                      testValue1};\n+\n+    private static final MyValue1[][] testValue1Array2 = new MyValue1[][] {testValue1Array,\n+                                                                           testValue1Array,\n+                                                                           testValue1Array};\n+\n+    private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,\n+                                                                      testValue2,\n+                                                                      testValue2};\n+\n+    private static final Integer[] testIntegerArray = new Integer[42];\n+\n+    \/\/ Test load from (flattened) inline type array disguised as object array\n+    @Test\n+    public Object test21(Object[] oa, int index) {\n+        return oa[index];\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test load from (flattened) inline type array disguised as interface array\n+    @Test\n+    public Object test22Interface(MyInterface[] ia, int index) {\n+        return ia[index];\n+    }\n+\n+    @Run(test = \"test22Interface\")\n+    public void test22Interface_verifier() {\n+        MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test load from (flattened) inline type array disguised as abstract array\n+    @Test\n+    public Object test22Abstract(MyAbstract[] ia, int index) {\n+        return ia[index];\n+    }\n+\n+    @Run(test = \"test22Abstract\")\n+    public void test22Abstract_verifier() {\n+        MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test23_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test23(Object[] oa, MyValue1 vt, int index) {\n+        test23_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test23(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test23(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test24_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test24(Object[] oa, MyValue1 vt, int index) {\n+        test24_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test24(testIntegerArray, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test25_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test25(Object[] oa, MyValue1 vt, int index) {\n+        test25_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test25(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as interface array\n+    @ForceInline\n+    public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {\n+      test26Interface_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test26Interface\")\n+    public void test26Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test26Interface(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test26Interface(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {\n+        test27Interface_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test27Interface\")\n+    public void test27Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test27Interface(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as abstract array\n+    @ForceInline\n+    public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {\n+      test26Abstract_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test26Abstract\")\n+    public void test26Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test26Abstract(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test26Abstract(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {\n+        test27Abstract_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test27Abstract\")\n+    public void test27Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test27Abstract(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test object store to (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test28_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test28(Object[] oa, Object o, int index) {\n+        test28_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test28(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test28(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test29_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test29(Object[] oa, Object o, int index) {\n+        test29_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test29(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test30_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test30(Object[] oa, Object o, int index) {\n+        test30_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test30(testIntegerArray, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as interface array\n+    @ForceInline\n+    public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test31Interface(MyInterface[] ia, MyInterface i, int index) {\n+        test31Interface_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test31Interface\")\n+    public void test31Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test31Interface(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test31Interface(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test32Interface(MyInterface[] ia, MyInterface i, int index) {\n+        test32Interface_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test32Interface\")\n+    public void test32Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test32Interface(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as abstract array\n+    @ForceInline\n+    public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {\n+        test31Abstract_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test31Abstract\")\n+    public void test31Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test31Abstract(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test31Abstract(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {\n+        test32Abstract_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test32Abstract\")\n+    public void test32Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test32Abstract(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test writing null to a (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test33_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test33(Object[] oa, Object o, int index) {\n+        test33_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test33(testValue1Array, null, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing constant null to a (flattened) inline type array disguised as object array\n+\n+    @ForceInline\n+    public void test34_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test34(Object[] oa, int index) {\n+        test34_inline(oa, null, index);\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test34(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing constant null to a (flattened) inline type array\n+\n+    private static final MethodHandle setArrayElementNull = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementNull\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aconst_null().\n+            aastore().\n+            return_();\n+        });\n+\n+    @Test\n+    public void test35(MyValue1[] va, int index) throws Throwable {\n+        setArrayElementNull.invoke(this, va, index);\n+    }\n+\n+    @Run(test = \"test35\")\n+    @Warmup(10000)\n+    public void test35_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test35(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing an inline type to a null inline type array\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G})\n+    public void test36(MyValue1[] va, MyValue1 vt, int index) {\n+        va[index] = vt;\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test36(null, testValue1Array[index], index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test incremental inlining\n+    @ForceInline\n+    public void test37_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test37(MyValue1[] va, Object o, int index) {\n+        test37_inline(va, o, index);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test37(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test37(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    \/\/ Test merging of inline type arrays\n+\n+    @ForceInline\n+    public Object[] test38_inline() {\n+        return new MyValue1[42];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public Object[] test38(Object[] oa, Object o, int i1, int i2, int num) {\n+        Object[] result = null;\n+        switch (num) {\n+        case 0:\n+            result = test38_inline();\n+            break;\n+        case 1:\n+            result = oa;\n+            break;\n+        case 2:\n+            result = testValue1Array;\n+            break;\n+        case 3:\n+            result = testValue2Array;\n+            break;\n+        case 4:\n+            result = testIntegerArray;\n+            break;\n+        case 5:\n+            result = null;\n+            break;\n+        case 6:\n+            result = testValue1Array2;\n+            break;\n+        }\n+        result[i1] = result[i2];\n+        result[i2] = o;\n+        return result;\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1[] va = new MyValue1[42];\n+        Object[] result = test38(null, testValue1, index, index, 0);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(testValue1Array, testValue1, index, index, 1);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(null, testValue1, index, index, 2);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(null, testValue2, index, index, 3);\n+        Asserts.assertEQ(((MyValue2)result[index]).hash(), testValue2.hash());\n+        try {\n+            result = test38(null, null, index, index, 3);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test38(null, null, index, index, 4);\n+        try {\n+            result = test38(null, testValue1, index, index, 4);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            result = test38(null, testValue1, index, index, 5);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test38(null, testValue1Array, index, index, 6);\n+        Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test39_inline() {\n+        return new MyValue1[42];\n+    }\n+\n+    \/\/ Same as above but merging into Object instead of Object[]\n+    @Test\n+    public Object test39(Object oa, Object o, int i1, int i2, int num) {\n+        Object result = null;\n+        switch (num) {\n+        case 0:\n+            result = test39_inline();\n+            break;\n+        case 1:\n+            result = oa;\n+            break;\n+        case 2:\n+            result = testValue1Array;\n+            break;\n+        case 3:\n+            result = testValue2Array;\n+            break;\n+        case 4:\n+            result = testIntegerArray;\n+            break;\n+        case 5:\n+            result = null;\n+            break;\n+        case 6:\n+            result = testValue1;\n+            break;\n+        case 7:\n+            result = testValue2;\n+            break;\n+        case 8:\n+            result = MyValue1.createWithFieldsInline(rI, rL);\n+            break;\n+        case 9:\n+            result = Integer.valueOf(42);\n+            break;\n+        case 10:\n+            result = testValue1Array2;\n+            break;\n+        }\n+        if (result instanceof Object[]) {\n+            ((Object[])result)[i1] = ((Object[])result)[i2];\n+            ((Object[])result)[i2] = o;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1[] va = new MyValue1[42];\n+        Object result = test39(null, testValue1, index, index, 0);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(testValue1Array, testValue1, index, index, 1);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 2);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(null, testValue2, index, index, 3);\n+        Asserts.assertEQ(((MyValue2[])result)[index].hash(), testValue2.hash());\n+        try {\n+            result = test39(null, null, index, index, 3);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test39(null, null, index, index, 4);\n+        try {\n+            result = test39(null, testValue1, index, index, 4);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        result = test39(null, testValue1, index, index, 5);\n+        Asserts.assertEQ(result, null);\n+        result = test39(null, testValue1, index, index, 6);\n+        Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 7);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+        result = test39(null, testValue1, index, index, 8);\n+        Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 9);\n+        Asserts.assertEQ(((Integer)result), 42);\n+        result = test39(null, testValue1Array, index, index, 10);\n+        Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Test instanceof with inline types and arrays\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC_G})\n+    public long test40(Object o, int index) {\n+        if (o instanceof MyValue1) {\n+          return ((MyValue1)o).hashInterpreted();\n+        } else if (o instanceof MyValue1[]) {\n+          return ((MyValue1[])o)[index].hashInterpreted();\n+        } else if (o instanceof MyValue2) {\n+          return ((MyValue2)o).hash();\n+        } else if (o instanceof MyValue2[]) {\n+          return ((MyValue2[])o)[index].hash();\n+        } else if (o instanceof MyValue1[][]) {\n+          return ((MyValue1[][])o)[index][index].hash();\n+        } else if (o instanceof Long) {\n+          return (long)o;\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        long result = test40(testValue1, 0);\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n+        result = test40(testValue1Array, index);\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n+        result = test40(testValue2, index);\n+        Asserts.assertEQ(result, testValue2.hash());\n+        result = test40(testValue2Array, index);\n+        Asserts.assertEQ(result, testValue2.hash());\n+        result = test40(testValue1Array2, index);\n+        Asserts.assertEQ(result, testValue1.hash());\n+        result = test40(Long.valueOf(42), index);\n+        Asserts.assertEQ(result, 42L);\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    @DontInline\n+    public void test41_dontinline(Object o) {\n+        Asserts.assertEQ(o, rI);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test41() {\n+        MyValue1[] vals = new MyValue1[] {testValue1};\n+        test41_dontinline(vals[0].oa[0]);\n+        test41_dontinline(vals[0].oa[0]);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        test41();\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test42() {\n+        MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};\n+        Asserts.assertEQ(vals[0].hash(), test42VT1.hash());\n+        Asserts.assertEQ(vals[1].hash(), test42VT2.hash());\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        if (!info.isWarmUp()) test42(); \/\/ We need -Xcomp behavior\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test43(boolean deopt, Method m) {\n+        MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};\n+\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+            Asserts.assertEQ(vals[0].hash(), test42VT1.hash());\n+            Asserts.assertEQ(vals[1].hash(), test42VT2.hash());\n+        }\n+\n+        return vals[0].hash();\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        test43(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatible = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementIncompatible\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, PrimitiveClass.asValueType(MyValue2.class)),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aload_3().\n+            aastore().\n+            return_();\n+        });\n+\n+    @Test\n+    public void test44(MyValue1[] va, int index, MyValue2 v) throws Throwable {\n+        setArrayElementIncompatible.invoke(this, va, index, v);\n+    }\n+\n+    @Run(test = \"test44\")\n+    @Warmup(10000)\n+    public void test44_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test44(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    @ForceInline\n+    public void test45_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test45(MyValue1[] va, int index, MyValue2 v) throws Throwable {\n+        test45_inline(va, v, index);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test45(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ instanceof tests with inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test46(MyValue1 vt) {\n+        Object obj = vt;\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test46(vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test47(MyValue1 vt) {\n+        Object obj = vt;\n+        return obj instanceof MyValue2;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test47(vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test48(Object obj) {\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test48(vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test49(Object obj) {\n+        return obj instanceof MyValue2;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test49(vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test50(Object obj) {\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        boolean result = test49(Integer.valueOf(42));\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Inline type with some non-flattened fields\n+    final primitive class Test51Value {\n+        final Object objectField1;\n+        final Object objectField2;\n+        final Object objectField3;\n+        final Object objectField4;\n+        final Object objectField5;\n+        final Object objectField6;\n+\n+        final MyValue1 valueField1;\n+        final MyValue1 valueField2;\n+        final MyValue1.ref valueField3;\n+        final MyValue1 valueField4;\n+        final MyValue1.ref valueField5;\n+\n+        public Test51Value() {\n+            objectField1 = null;\n+            objectField2 = null;\n+            objectField3 = null;\n+            objectField4 = null;\n+            objectField5 = null;\n+            objectField6 = null;\n+            valueField1 = testValue1;\n+            valueField2 = testValue1;\n+            valueField3 = testValue1;\n+            valueField4 = MyValue1.createDefaultDontInline();\n+            valueField5 = MyValue1.createDefaultDontInline();\n+        }\n+\n+        public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,\n+                           MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {\n+            objectField1 = o1;\n+            objectField2 = o2;\n+            objectField3 = o3;\n+            objectField4 = o4;\n+            objectField5 = o5;\n+            objectField6 = o6;\n+            valueField1 = vt1;\n+            valueField2 = vt2;\n+            valueField3 = vt3;\n+            valueField4 = vt4;\n+            valueField5 = vt5;\n+        }\n+\n+        @ForceInline\n+        public long test(Test51Value holder, MyValue1 vt1, Object vt2) {\n+            holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, MyValue1.createWithFieldsDontInline(rI, rL), holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.valueField1, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.valueField3,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);\n+\n+            return ((MyValue1)holder.objectField1).hash() +\n+                   ((MyValue1)holder.objectField2).hash() +\n+                   ((MyValue1)holder.objectField3).hash() +\n+                   ((MyValue1)holder.objectField4).hash() +\n+                   ((MyValue1)holder.objectField5).hash() +\n+                   ((MyValue1)holder.objectField6).hash() +\n+                   holder.valueField1.hash() +\n+                   holder.valueField2.hash() +\n+                   holder.valueField3.hash() +\n+                   holder.valueField4.hashPrimitive();\n+        }\n+    }\n+\n+    \/\/ Same as test2 but with field holder being an inline type\n+    @Test\n+    public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {\n+        return holder.test(holder, vt1, vt2);\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        Test51Value holder = new Test51Value();\n+        Asserts.assertEQ(testValue1.hash(), vt.hash());\n+        Asserts.assertEQ(holder.valueField1.hash(), vt.hash());\n+        long result = test51(holder, vt, vt);\n+        Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());\n+    }\n+\n+    \/\/ Access non-flattened, uninitialized inline type field with inline type holder\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test52(Test51Value holder) {\n+        if ((Object)holder.valueField5 != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        Test51Value vt = Test51Value.default;\n+        test52(vt);\n+    }\n+\n+    \/\/ Merging inline types of different types\n+    @Test\n+    public Object test53(Object o, boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        return b ? vt : o;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        test53(new Object(), false);\n+        MyValue1 result = (MyValue1)test53(new Object(), true);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    @Test\n+    public Object test54(boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        return b ? vt : testValue2;\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        MyValue1 result1 = (MyValue1)test54(true);\n+        Asserts.assertEQ(result1.hash(), hash());\n+        MyValue2 result2 = (MyValue2)test54(false);\n+        Asserts.assertEQ(result2.hash(), testValue2.hash());\n+    }\n+\n+    @Test\n+    public Object test55(boolean b) {\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, rD);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        MyValue1 result1 = (MyValue1)test55(true);\n+        Asserts.assertEQ(result1.hash(), hash());\n+        MyValue2 result2 = (MyValue2)test55(false);\n+        Asserts.assertEQ(result2.hash(), testValue2.hash());\n+    }\n+\n+    \/\/ Test synchronization on inline types\n+    @Test\n+    public void test56(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test56 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        try {\n+            test56(testValue1);\n+            throw new RuntimeException(\"test56 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test57_inline(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test57 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test57(MyValue1 vt) {\n+        test57_inline(vt);\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        try {\n+            test57(testValue1);\n+            throw new RuntimeException(\"test57 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test58_inline(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test58 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test58() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test58_inline(vt);\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier() {\n+        try {\n+            test58();\n+            throw new RuntimeException(\"test58 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public void test59(Object o, boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object sync = b ? vt : o;\n+        synchronized (sync) {\n+            if (b) {\n+                throw new RuntimeException(\"test59 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() {\n+        test59(new Object(), false);\n+        try {\n+            test59(new Object(), true);\n+            throw new RuntimeException(\"test59 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public void test60(boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object sync = b ? vt : testValue2;\n+        synchronized (sync) {\n+            throw new RuntimeException(\"test60 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        try {\n+            test60(false);\n+            throw new RuntimeException(\"test60 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test60(true);\n+            throw new RuntimeException(\"test60 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test catching the IllegalMonitorStateException in compiled code\n+    @Test\n+    public void test61(Object vt) {\n+        boolean thrown = false;\n+        try {\n+            synchronized (vt) {\n+                throw new RuntimeException(\"test61 failed: no exception thrown\");\n+            }\n+        } catch (IllegalMonitorStateException ex) {\n+            thrown = true;\n+        }\n+        if (!thrown) {\n+            throw new RuntimeException(\"test61 failed: no exception thrown\");\n+        }\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        test61(testValue1);\n+    }\n+\n+    @Test\n+    public void test62(Object o) {\n+        try {\n+            synchronized (o) { }\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+            return;\n+        }\n+        throw new RuntimeException(\"test62 failed: no exception thrown\");\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        test62(testValue1);\n+    }\n+\n+    \/\/ Test synchronization without any instructions in the synchronized block\n+    @Test\n+    public void test63(Object o) {\n+        synchronized (o) { }\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        try {\n+            test63(testValue1);\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+            return;\n+        }\n+        throw new RuntimeException(\"test63 failed: no exception thrown\");\n+    }\n+\n+    \/\/ type system test with interface and inline type\n+    @ForceInline\n+    public MyInterface test64Interface_helper(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyInterface test64Interface(MyValue1 vt) {\n+        return test64Interface_helper(vt);\n+    }\n+\n+    @Run(test = \"test64Interface\")\n+    public void test64Interface_verifier() {\n+        test64Interface(testValue1);\n+    }\n+\n+    \/\/ type system test with abstract and inline type\n+    @ForceInline\n+    public MyAbstract test64Abstract_helper(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyAbstract test64Abstract(MyValue1 vt) {\n+        return test64Abstract_helper(vt);\n+    }\n+\n+    @Run(test = \"test64Abstract\")\n+    public void test64Abstract_verifier() {\n+        test64Abstract(testValue1);\n+    }\n+\n+    \/\/ Array store tests\n+    @Test\n+    public void test65(Object[] array, MyValue1 vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        Object[] array = new Object[1];\n+        test65(array, testValue1);\n+        Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test66(Object[] array, MyValue1 vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1[] array = new MyValue1[1];\n+        test66(array, testValue1);\n+        Asserts.assertEQ(array[0].hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test67(Object[] array, Object vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1[] array = new MyValue1[1];\n+        test67(array, testValue1);\n+        Asserts.assertEQ(array[0].hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test68(Object[] array, Integer o) {\n+        array[0] = o;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        Integer[] array = new Integer[1];\n+        test68(array, 1);\n+        Asserts.assertEQ(array[0], Integer.valueOf(1));\n+    }\n+\n+    \/\/ Test convertion between an inline type and java.lang.Object without an allocation\n+    @ForceInline\n+    public Object test69_sum(Object a, Object b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test69(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test69_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        int result = test69(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Same as test69 but with an Interface\n+    @ForceInline\n+    public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test70Interface(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test70Interface_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test70Interface\")\n+    public void test70Interface_verifier() {\n+        int result = test70Interface(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Same as test69 but with an Abstract\n+    @ForceInline\n+    public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test70Abstract(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test70Abstract_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test70Abstract\")\n+    public void test70Abstract_verifier() {\n+        int result = test70Abstract(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Test that allocated inline type is not used in non-dominated path\n+    public MyValue1 test71_inline(Object obj) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test71() {\n+        return test71_inline(null);\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        MyValue1 vt = test71();\n+        Asserts.assertEquals(vt.hash(), hash());\n+    }\n+\n+    \/\/ Test calling a method on an uninitialized inline type\n+    final primitive class Test72Value {\n+        final int x = 42;\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Make sure Test72Value is loaded but not initialized\n+    public void unused(Test72Value vt) { }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public int test72() {\n+        Test72Value vt = Test72Value.default;\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test72\")\n+    @Warmup(0)\n+    public void test72_verifier() {\n+        int result = test72();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Tests for loading\/storing unkown values\n+    @Test\n+    public Object test73(Object[] va) {\n+        return va[0];\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        MyValue1 vt = (MyValue1)test73(testValue1Array);\n+        Asserts.assertEquals(testValue1Array[0].hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public void test74(Object[] va, Object vt) {\n+        va[0] = vt;\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        test74(va, testValue1);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Verify that mixing instances and arrays with the clone api\n+    \/\/ doesn't break anything\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public Object test75(Object o) {\n+        MyValue1[] va = new MyValue1[1];\n+        Object[] next = va;\n+        Object[] arr = va;\n+        for (int i = 0; i < 10; i++) {\n+            arr = next;\n+            next = new Integer[1];\n+        }\n+        return arr[0];\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        test75(42);\n+    }\n+\n+    \/\/ Casting a null Integer to a (non-nullable) inline type should throw a NullPointerException\n+    @ForceInline\n+    public MyValue1 test76_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test76(Integer i) throws Throwable {\n+        return test76_helper(i);\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() throws Throwable {\n+        try {\n+            test76(null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test76 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting an Integer to a (non-nullable) inline type should throw a ClassCastException\n+    @ForceInline\n+    public MyValue1 test77_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test77(Integer i) throws Throwable {\n+        return test77_helper(i);\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() throws Throwable {\n+        try {\n+            test77(Integer.valueOf(42));\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test77 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting a null Integer to a nullable inline type should not throw\n+    @ForceInline\n+    public MyValue1.ref test78_helper(Object o) {\n+        return (MyValue1.ref)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test78(Integer i) throws Throwable {\n+        return test78_helper(i);\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() throws Throwable {\n+        try {\n+            test78(null); \/\/ Should not throw\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test78 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting an Integer to a nullable inline type should throw a ClassCastException\n+    @ForceInline\n+    public MyValue1.ref test79_helper(Object o) {\n+        return (MyValue1.ref)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test79(Integer i) throws Throwable {\n+        return test79_helper(i);\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() throws Throwable {\n+        try {\n+            test79(Integer.valueOf(42));\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test79 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Test flattened field with non-flattenend (but flattenable) inline type field\n+    static primitive class Small {\n+        final int i;\n+        final Big big; \/\/ Too big to be flattened\n+\n+        private Small() {\n+            i = rI;\n+            big = new Big();\n+        }\n+    }\n+\n+    static primitive class Big {\n+        long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9;\n+        long l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;\n+        long l20,l21,l22,l23,l24,l25,l26,l27,l28,l29;\n+\n+        private Big() {\n+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = rL;\n+            l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = rL+1;\n+            l20 = l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = rL+2;\n+        }\n+    }\n+\n+    Small small = new Small();\n+    Small smallDefault;\n+    Big big = new Big();\n+    Big bigDefault;\n+\n+    @Test\n+    public long test80() {\n+        return small.i + small.big.l0 + smallDefault.i + smallDefault.big.l29 + big.l0 + bigDefault.l29;\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() throws Throwable {\n+        long result = test80();\n+        Asserts.assertEQ(result, rI + 2*rL);\n+    }\n+\n+    \/\/ Test scalarization with exceptional control flow\n+    public int test81Callee(MyValue1 vt)  {\n+        return vt.x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public int test81()  {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        int result = 0;\n+        for (int i = 0; i < 10; i++) {\n+            try {\n+                result += test81Callee(vt);\n+            } catch (NullPointerException npe) {\n+                result += rI;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        int result = test81();\n+        Asserts.assertEQ(result, 10*rI);\n+    }\n+\n+    \/\/ Test check for null free array when storing to inline tpye array\n+    @Test\n+    public void test82(Object[] dst, Object v) {\n+        dst[0] = v;\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier(RunInfo info) {\n+        MyValue2[] dst = new MyValue2[1];\n+        test82(dst, testValue2);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test82(dst, null);\n+                throw new RuntimeException(\"No ArrayStoreException thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test83(Object[] dst, Object v, boolean flag) {\n+        if (dst == null) { \/\/ null check\n+        }\n+        if (flag) {\n+            if (dst.getClass() == MyValue1[].class) { \/\/ trigger split if\n+            }\n+        } else {\n+            dst = new MyValue2[1]; \/\/ constant null free property\n+        }\n+        dst[0] = v;\n+    }\n+\n+    @Run(test = \"test83\")\n+    @Warmup(10000)\n+    public void test83_verifier(RunInfo info) {\n+        MyValue2[] dst = new MyValue2[1];\n+        test83(dst, testValue2, false);\n+        test83(dst, testValue2, true);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test83(dst, null, true);\n+                throw new RuntimeException(\"No ArrayStoreException thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    private void rerun_and_recompile_for(Method m, int num, Runnable test) {\n+        for (int i = 1; i < num; i++) {\n+            test.run();\n+\n+            if (!TestFramework.isCompiled(m)) {\n+                TestFramework.compile(m, CompLevel.C2);\n+            }\n+        }\n+    }\n+\n+    \/\/ Tests for the Loop Unswitching optimization\n+    \/\/ Should make 2 copies of the loop, one for non flattened arrays, one for other cases.\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 1\"})\n+    public void test84(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test84\")\n+    @Warmup(0)\n+    public void test84_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[100];\n+        Arrays.fill(src, testValue2);\n+        MyValue2[] dst = new MyValue2[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () ->  { test84(src, dst);\n+                                         Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 4\"})\n+    public void test85(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test85\")\n+    @Warmup(0)\n+    public void test85_verifier(RunInfo info) {\n+        Object[] src = new Object[100];\n+        Arrays.fill(src, new Object());\n+        src[0] = null;\n+        Object[] dst = new Object[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test85(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP, \"= 2\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    public void test86(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test86\")\n+    @Warmup(0)\n+    public void test86_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[100];\n+        Arrays.fill(src, testValue2);\n+        Object[] dst = new Object[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test86(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 1\"})\n+    public void test87(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test87\")\n+    @Warmup(0)\n+    public void test87_verifier(RunInfo info) {\n+        Object[] src = new Object[100];\n+        Arrays.fill(src, testValue2);\n+        MyValue2[] dst = new MyValue2[100];\n+\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test87(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 0\"})\n+    public void test88(Object[] src1, Object[] dst1, Object[] src2, Object[] dst2) {\n+        for (int i = 0; i < src1.length; i++) {\n+            dst1[i] = src1[i];\n+            dst2[i] = src2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test88\")\n+    @Warmup(0)\n+    public void test88_verifier(RunInfo info) {\n+        MyValue2[] src1 = new MyValue2[100];\n+        Arrays.fill(src1, testValue2);\n+        MyValue2[] dst1 = new MyValue2[100];\n+        Object[] src2 = new Object[100];\n+        Arrays.fill(src2, new Object());\n+        Object[] dst2 = new Object[100];\n+\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test88(src1, dst1, src2, dst2);\n+                                        Asserts.assertTrue(Arrays.equals(src1, dst1));\n+                                        Asserts.assertTrue(Arrays.equals(src2, dst2)); });\n+    }\n+\n+    @Test\n+    public boolean test89(Object obj) {\n+        return obj.getClass() == Integer.class;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        Asserts.assertTrue(test89(Integer.valueOf(42)));\n+        Asserts.assertFalse(test89(new Object()));\n+    }\n+\n+    @Test\n+    public Integer test90(Object obj) {\n+        return (Integer)obj;\n+    }\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier() {\n+        test90(Integer.valueOf(42));\n+        try {\n+            test90(new Object());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public boolean test91(Object obj) {\n+        return obj.getClass() == MyValue2[].class;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        Asserts.assertTrue(test91(new MyValue2[1]));\n+        Asserts.assertFalse(test91(new MyValue2.ref[1]));\n+        Asserts.assertFalse(test91(new Object()));\n+    }\n+\n+    static primitive class Test92Value {\n+        final int field;\n+        public Test92Value() {\n+            field = 0x42;\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, ALLOC_G, MEMBAR})\n+    public Object test92(Object[] array) {\n+        \/\/ Dummy loops to ensure we run enough passes of split if\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+              for (int k = 0; k < 2; k++) {\n+              }\n+            }\n+        }\n+\n+        return (Integer)array[0];\n+    }\n+\n+    @Run(test = \"test92\")\n+    @Warmup(10000)\n+    public void test92_verifier() {\n+        Object[] array = new Object[1];\n+        array[0] = 0x42;\n+        Object result = test92(array);\n+        Asserts.assertEquals(result, 0x42);\n+    }\n+\n+    \/\/ If the class check succeeds, the flattened array check that\n+    \/\/ precedes will never succeed and the flat array branch should\n+    \/\/ trigger an uncommon trap.\n+    @Test\n+    public Object test93(Object[] array) {\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+            }\n+        }\n+\n+        Object v = (Integer)array[0];\n+        return v;\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object[] array = new Object[1];\n+            array[0] = 0x42;\n+            Object result = test93(array);\n+            Asserts.assertEquals(result, 0x42);\n+        } else {\n+            Object[] array = new Test92Value[1];\n+            Method m = info.getTest();\n+            int extra = 3;\n+            for (int j = 0; j < extra; j++) {\n+                for (int i = 0; i < 10; i++) {\n+                    try {\n+                        test93(array);\n+                    } catch (ClassCastException cce) {\n+                    }\n+                }\n+                boolean compiled = TestFramework.isCompiled(m);\n+                boolean compilationSkipped = info.isCompilationSkipped();\n+                Asserts.assertTrue(compilationSkipped || compiled || (j != extra-1));\n+                if (!compilationSkipped && !compiled) {\n+                    TestFramework.compile(m, CompLevel.ANY);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\", LOOP, \"= 1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, ALLOC_G, MEMBAR})\n+    public int test94(Object[] array) {\n+        int res = 0;\n+        for (int i = 1; i < 4; i *= 2) {\n+            Object v = array[i];\n+            res += (Integer)v;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test94\")\n+    @Warmup(10000)\n+    public void test94_verifier() {\n+        Object[] array = new Object[4];\n+        array[0] = 0x42;\n+        array[1] = 0x42;\n+        array[2] = 0x42;\n+        array[3] = 0x42;\n+        int result = test94(array);\n+        Asserts.assertEquals(result, 0x42 * 2);\n+    }\n+\n+    @Test\n+    public boolean test95(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test95\")\n+    @Warmup(10000)\n+    public void test95_verifier() {\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        Asserts.assertTrue(test95(o1, o1));\n+        Asserts.assertTrue(test95(null, null));\n+        Asserts.assertFalse(test95(o1, null));\n+        Asserts.assertFalse(test95(o1, o2));\n+    }\n+\n+    @Test\n+    public boolean test96(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test96\")\n+    @Warmup(10000)\n+    public void test96_verifier(RunInfo info) {\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        Asserts.assertTrue(test96(o1, o1));\n+        Asserts.assertFalse(test96(o1, o2));\n+        if (!info.isWarmUp()) {\n+            Asserts.assertTrue(test96(null, null));\n+            Asserts.assertFalse(test96(o1, null));\n+        }\n+    }\n+\n+    \/\/ Abstract class tests\n+\n+    @DontInline\n+    public MyAbstract test97_dontinline1(MyAbstract o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test97_dontinline2(MyAbstract o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public MyAbstract test97_inline1(MyAbstract o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test97_inline2(MyAbstract o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    public MyValue1 test97() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        vt = (MyValue1)test97_dontinline1(vt);\n+        vt =           test97_dontinline2(vt);\n+        vt = (MyValue1)test97_inline1(vt);\n+        vt =           test97_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        Asserts.assertEQ(test97().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from abstract and inline type fields\n+    MyAbstract abstractField1 = null;\n+    MyAbstract abstractField2 = null;\n+    MyAbstract abstractField3 = null;\n+    MyAbstract abstractField4 = null;\n+    MyAbstract abstractField5 = null;\n+    MyAbstract abstractField6 = null;\n+\n+    @DontInline\n+    public MyAbstract readValueField5AsAbstract() {\n+        return (MyAbstract)valueField5;\n+    }\n+\n+    @DontInline\n+    public MyAbstract readStaticValueField4AsAbstract() {\n+        return (MyAbstract)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test98(MyValue1 vt1, MyAbstract vt2) {\n+        abstractField1 = vt1;\n+        abstractField2 = (MyValue1)vt2;\n+        abstractField3 = MyValue1.createWithFieldsInline(rI, rL);\n+        abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        abstractField5 = valueField1;\n+        abstractField6 = valueField3;\n+        valueField1 = (MyValue1)abstractField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)abstractField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +\n+               ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +\n+               ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void test98_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test98(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    class MyObject2 extends MyAbstract {\n+        public int x;\n+\n+        public MyObject2(int x) {\n+            this.x = x;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Test merging inline types and abstract classes\n+    @Test\n+    public MyAbstract test99(int state) {\n+        MyAbstract res = null;\n+        if (state == 0) {\n+            res = new MyObject2(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void test99_verifier() {\n+        objectField1 = valueField1;\n+        MyAbstract result = null;\n+        result = test99(0);\n+        Asserts.assertEQ(((MyObject2)result).x, rI);\n+        result = test99(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(5);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ Test merging inline types and abstract classes in loops\n+    @Test\n+    public MyAbstract test100(int iters) {\n+        MyAbstract res = new MyObject2(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof MyObject2) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier() {\n+        MyObject2 result1 = (MyObject2)test100(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test100(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in abstract class variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, LOOP})\n+    public long test101(MyValue1 arg, boolean deopt, Method m) {\n+        MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyAbstract vt3 = arg;\n+        MyAbstract vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier(RunInfo info) {\n+        long result = test101(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with abstract classes\n+    @Test\n+    public boolean test102(Object arg) {\n+        MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||\n+            arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier() {\n+        boolean result = test102(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ An abstract class with a non-static field can never be implemented by an inline type\n+    abstract class NoValueImplementors1 {\n+        int field = 42;\n+    }\n+\n+    class MyObject3 extends NoValueImplementors1 {\n+\n+    }\n+\n+    class MyObject4 extends NoValueImplementors1 {\n+\n+    }\n+\n+    \/\/ Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test103\")\n+    public void test103_verifier() {\n+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];\n+        MyObject3[] array2 = new MyObject3[3];\n+        MyObject4[] array3 = new MyObject4[3];\n+        NoValueImplementors1 result = test103(array1, 0);\n+        Asserts.assertEquals(result, array1[0]);\n+\n+        result = test103(array2, 1);\n+        Asserts.assertEquals(result, array1[1]);\n+\n+        result = test103(array3, 2);\n+        Asserts.assertEquals(result, array1[2]);\n+    }\n+\n+    \/\/ Storing to an abstract class array does not require a flatness\/null check if the abstract class has a non-static field\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test104\")\n+    public void test104_verifier() {\n+        MyObject4 v = new MyObject4();\n+        MyObject3 o = new MyObject3();\n+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];\n+        MyObject3[] array2 = new MyObject3[3];\n+        MyObject4[] array3 = new MyObject4[3];\n+        NoValueImplementors1 result = test104(array1, v, o, 0);\n+        Asserts.assertEquals(array1[0], v);\n+        Asserts.assertEquals(array1[1], v);\n+        Asserts.assertEquals(array1[2], o);\n+        Asserts.assertEquals(result, v);\n+\n+        result = test104(array2, o, o, 1);\n+        Asserts.assertEquals(array2[0], o);\n+        Asserts.assertEquals(array2[1], o);\n+        Asserts.assertEquals(array2[2], o);\n+        Asserts.assertEquals(result, o);\n+\n+        result = test104(array3, v, null, 1);\n+        Asserts.assertEquals(array3[0], v);\n+        Asserts.assertEquals(array3[1], v);\n+        Asserts.assertEquals(array3[2], null);\n+        Asserts.assertEquals(result, v);\n+    }\n+\n+    \/\/ An abstract class with a single, non-inline implementor\n+    abstract class NoValueImplementors2 {\n+\n+    }\n+\n+    class MyObject5 extends NoValueImplementors2 {\n+\n+    }\n+\n+    \/\/ Loading from an abstract class array does not require a flatness check if the abstract class has no inline implementor\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier() {\n+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];\n+        MyObject5[] array2 = new MyObject5[3];\n+        NoValueImplementors2 result = test105(array1, 0);\n+        Asserts.assertEquals(result, array1[0]);\n+\n+        result = test105(array2, 1);\n+        Asserts.assertEquals(result, array1[1]);\n+    }\n+\n+    \/\/ Storing to an abstract class array does not require a flatness\/null check if the abstract class has no inline implementor\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier() {\n+        MyObject5 v = new MyObject5();\n+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];\n+        MyObject5[] array2 = new MyObject5[3];\n+        NoValueImplementors2 result = test106(array1, v, null, 0);\n+        Asserts.assertEquals(array1[0], v);\n+        Asserts.assertEquals(array1[1], v);\n+        Asserts.assertEquals(array1[2], null);\n+        Asserts.assertEquals(result, v);\n+\n+        result = test106(array2, v, v, 1);\n+        Asserts.assertEquals(array2[0], v);\n+        Asserts.assertEquals(array2[1], v);\n+        Asserts.assertEquals(array2[2], v);\n+        Asserts.assertEquals(result, v);\n+    }\n+\n+    \/\/ More tests for the Loop Unswitching optimization (similar to test84 and following)\n+    Object oFld1, oFld2;\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 2\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 3\", LOAD_UNKNOWN_INLINE, \"= 2\"})\n+    public void test107(Object[] src1, Object[] src2) {\n+        for (int i = 0; i < src1.length; i++) {\n+            oFld1 = src1[i];\n+            oFld2 = src2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test107\")\n+    @Warmup(0)\n+    public void test107_verifier(RunInfo info) {\n+        MyValue2[] src1 = new MyValue2[100];\n+        Arrays.fill(src1, testValue2);\n+        Object[] src2 = new Object[100];\n+        Object obj = new Object();\n+        Arrays.fill(src2, obj);\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test107(src1, src2);\n+                                        Asserts.assertEquals(oFld1, testValue2);\n+                                        Asserts.assertEquals(oFld2, obj);\n+                                        test107(src2, src1);\n+                                        Asserts.assertEquals(oFld1, obj);\n+                                        Asserts.assertEquals(oFld2, testValue2);  });\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 9\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 12\"})\n+    public void test108(Object[] dst1, Object[] dst2, Object o1, Object o2) {\n+        for (int i = 0; i < dst1.length; i++) {\n+            dst1[i] = o1;\n+            dst2[i] = o2;\n+        }\n+    }\n+\n+    @Run(test = \"test108\")\n+    @Warmup(0)\n+    public void test108_verifier(RunInfo info) {\n+        MyValue2[] dst1 = new MyValue2[100];\n+        Object[] dst2 = new Object[100];\n+        Object o1 = new Object();\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test108(dst1, dst2, testValue2, o1);\n+                                        for (int i = 0; i < dst1.length; i++) {\n+                                            Asserts.assertEquals(dst1[i], testValue2);\n+                                            Asserts.assertEquals(dst2[i], o1);\n+                                        }\n+                                        test108(dst2, dst1, o1, testValue2);\n+                                        for (int i = 0; i < dst1.length; i++) {\n+                                            Asserts.assertEquals(dst1[i], testValue2);\n+                                            Asserts.assertEquals(dst2[i], o1);\n+                                        } });\n+    }\n+\n+    \/\/ Escape analysis tests\n+\n+    static interface WrapperInterface {\n+        long value();\n+\n+        final static WrapperInterface ZERO = new LongWrapper(0);\n+\n+        @ForceInline\n+        static WrapperInterface wrap(long val) {\n+            return (val == 0L) ? ZERO : new LongWrapper(val);\n+        }\n+    }\n+\n+    @ForceCompileClassInitializer\n+    static primitive class LongWrapper implements WrapperInterface {\n+        final static LongWrapper ZERO = new LongWrapper(0);\n+        private long val;\n+\n+        @ForceInline\n+        LongWrapper(long val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        static LongWrapper wrap(long val) {\n+            return (val == 0L) ? ZERO : new LongWrapper(val);\n+        }\n+\n+        @ForceInline\n+        public long value() {\n+            return val;\n+        }\n+    }\n+\n+    static class InterfaceBox {\n+        WrapperInterface content;\n+\n+        @ForceInline\n+        InterfaceBox(WrapperInterface content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox box_sharp(long val) {\n+            return new InterfaceBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox box(long val) {\n+            return new InterfaceBox(WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class ObjectBox {\n+        Object content;\n+\n+        @ForceInline\n+        ObjectBox(Object content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static ObjectBox box_sharp(long val) {\n+            return new ObjectBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static ObjectBox box(long val) {\n+            return new ObjectBox(WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class RefBox {\n+        LongWrapper.ref content;\n+\n+        @ForceInline\n+        RefBox(LongWrapper.ref content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static RefBox box_sharp(long val) {\n+            return new RefBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static RefBox box(long val) {\n+            return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class InlineBox {\n+        LongWrapper content;\n+\n+        @ForceInline\n+        InlineBox(long val) {\n+            this.content = LongWrapper.wrap(val);\n+        }\n+\n+        @ForceInline\n+        static InlineBox box(long val) {\n+            return new InlineBox(val);\n+        }\n+    }\n+\n+    static class GenericBox<T> {\n+        T content;\n+\n+        @ForceInline\n+        static GenericBox<LongWrapper.ref> box_sharp(long val) {\n+            GenericBox<LongWrapper.ref> res = new GenericBox<>();\n+            res.content = LongWrapper.wrap(val);\n+            return res;\n+        }\n+\n+        @ForceInline\n+        static GenericBox<WrapperInterface> box(long val) {\n+            GenericBox<WrapperInterface> res = new GenericBox<>();\n+            res.content = WrapperInterface.wrap(val);\n+            return res;\n+        }\n+    }\n+\n+    long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};\n+\n+    \/\/ Test removal of allocations when inline type instance is wrapped into box object\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test109() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test109\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test109_verifier() {\n+        long res = test109();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+\/\/ TODO 8293541\n+\/\/    @IR(failOn = {ALLOC_G, MEMBAR},\n+\/\/        counts = {PREDICATE_TRAP, \"= 1\"})\n+    @IR(failOn = {ALLOC_G, MEMBAR})\n+    public long test109_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test109_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test109_sharp_verifier() {\n+        long res = test109_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with ObjectBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test110() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test110\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test110_verifier() {\n+        long res = test110();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+\/\/ TODO 8293541\n+\/\/    @IR(failOn = {ALLOC_G, MEMBAR},\n+\/\/        counts = {PREDICATE_TRAP, \"= 1\"})\n+    @IR(failOn = {ALLOC_G, MEMBAR})\n+    public long test110_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test110_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test110_sharp_verifier() {\n+        long res = test110_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with RefBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test111() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += RefBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        long res = test111();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test111_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += RefBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test111_sharp\")\n+    public void test111_sharp_verifier() {\n+        long res = test111_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with InlineBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test112() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InlineBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier() {\n+        long res = test112();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with GenericBox\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test113() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += GenericBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test113\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test113_verifier() {\n+        long res = test113();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test113_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += GenericBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test113_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test113_sharp_verifier() {\n+        long res = test113_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    static interface WrapperInterface2 {\n+        public long value();\n+\n+        static final InlineWrapper.ref ZERO = new InlineWrapper(0);\n+\n+        @ForceInline\n+        public static WrapperInterface2 wrap(long val) {\n+            return (val == 0) ? ZERO.content : new LongWrapper2(val);\n+        }\n+\n+        @ForceInline\n+        public static WrapperInterface2 wrap_default(long val) {\n+            return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);\n+        }\n+    }\n+\n+    static primitive class LongWrapper2 implements WrapperInterface2 {\n+        private long val;\n+\n+        @ForceInline\n+        public LongWrapper2(long val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        public long value() {\n+            return val;\n+        }\n+    }\n+\n+    static primitive class InlineWrapper {\n+        WrapperInterface2 content;\n+\n+        @ForceInline\n+        public InlineWrapper(long val) {\n+            content = new LongWrapper2(val);\n+        }\n+    }\n+\n+    static class InterfaceBox2 {\n+        WrapperInterface2 content;\n+\n+        @ForceInline\n+        public InterfaceBox2(long val, boolean def) {\n+            this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox2 box(long val) {\n+            return new InterfaceBox2(val, false);\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox2 box_default(long val) {\n+            return new InterfaceBox2(val, true);\n+        }\n+    }\n+\n+    \/\/ Same as tests above but with ZERO hidden in field of another inline type\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test114() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox2.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test114\")\n+    @Warmup(10000)\n+    public void test114_verifier() {\n+        long res = test114();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test114 but with .default instead of ZERO field\n+    @Test\n+    @IR(failOn = {ALLOC_G, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test115() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox2.box_default(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test115\")\n+    @Warmup(10000)\n+    public void test115_verifier() {\n+        long res = test115();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    static MyValueEmpty     fEmpty1;\n+    static MyValueEmpty.ref fEmpty2 = MyValueEmpty.default;\n+           MyValueEmpty     fEmpty3;\n+           MyValueEmpty.ref fEmpty4 = MyValueEmpty.default;\n+\n+    \/\/ Test fields loads\/stores with empty inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G, TRAP})\n+    public void test116() {\n+        fEmpty1 = fEmpty4;\n+        fEmpty2 = fEmpty1;\n+        fEmpty3 = fEmpty2;\n+        fEmpty4 = fEmpty3;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier() {\n+        test116();\n+        Asserts.assertEquals(fEmpty1, fEmpty2);\n+        Asserts.assertEquals(fEmpty2, fEmpty3);\n+        Asserts.assertEquals(fEmpty3, fEmpty4);\n+    }\n+\n+    \/\/ Test array loads\/stores with empty inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty.ref[] arr2) {\n+        arr1[0] = arr2[0];\n+        arr2[0] = new MyValueEmpty();\n+        return arr1[0];\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        MyValueEmpty[] arr1 = new MyValueEmpty[]{MyValueEmpty.default};\n+        MyValueEmpty res = test117(arr1, arr1);\n+        Asserts.assertEquals(res, MyValueEmpty.default);\n+        Asserts.assertEquals(arr1[0], MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test acmp with empty inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public boolean test118(MyValueEmpty v1, MyValueEmpty.ref v2, Object o1) {\n+        return (v1 == v2) && (v2 == o1);\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        boolean res = test118(MyValueEmpty.default, MyValueEmpty.default, new MyValueEmpty());\n+        Asserts.assertTrue(res);\n+    }\n+\n+    static primitive class EmptyContainer {\n+        private MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    static primitive class MixedContainer {\n+        public int val = rI;\n+        private EmptyContainer empty = EmptyContainer.default;\n+    }\n+\n+    \/\/ Test re-allocation of empty inline type array during deoptimization\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test119(boolean deopt, Method m) {\n+        MyValueEmpty[]   array1 = new MyValueEmpty[]{MyValueEmpty.default};\n+        EmptyContainer[] array2 = new EmptyContainer[]{EmptyContainer.default};\n+        MixedContainer[] array3 = new MixedContainer[]{MixedContainer.default};\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        Asserts.assertEquals(array1[0], MyValueEmpty.default);\n+        Asserts.assertEquals(array2[0], EmptyContainer.default);\n+        Asserts.assertEquals(array3[0], MixedContainer.default);\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier(RunInfo info) {\n+        test119(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    \/\/ Test removal of empty inline type field stores\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    public void test120(MyValueEmpty empty) {\n+        fEmpty1 = empty;\n+        fEmpty3 = empty;\n+        \/\/ fEmpty2 and fEmpty4 could be null, store can't be removed\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        test120(MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty1, MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty2, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test removal of empty inline type field loads\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    public boolean test121() {\n+        return fEmpty1.equals(fEmpty3);\n+        \/\/ fEmpty2 and fEmpty4 could be null, load can't be removed\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        boolean res = test121();\n+        Asserts.assertTrue(res);\n+    }\n+\n+    \/\/ Verify that empty inline type field loads check for null holder\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValueEmpty test122(TestLWorld t) {\n+        return t.fEmpty3;\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        MyValueEmpty res = test122(this);\n+        Asserts.assertEquals(res, MyValueEmpty.default);\n+        try {\n+            test122(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Verify that empty inline type field stores check for null holder\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test123(TestLWorld t) {\n+        t.fEmpty3 = MyValueEmpty.default;\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier() {\n+        test123(this);\n+        Asserts.assertEquals(fEmpty3, MyValueEmpty.default);\n+        try {\n+            test123(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ acmp doesn't need substitutability test when one input is known\n+    \/\/ not to be a value type\n+    @Test\n+    @IR(failOn = SUBSTITUTABILITY_TEST)\n+    public boolean test124(Integer o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier() {\n+        test124(42, 42);\n+        test124(42, testValue1);\n+    }\n+\n+    \/\/ acmp doesn't need substitutability test when one input null\n+    @Test\n+    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    public boolean test125(Object o1) {\n+        Object o2 = null;\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test125\")\n+    public void test125_verifier() {\n+        test125(testValue1);\n+        test125(null);\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after loop opts\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test126(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test126\")\n+    @Warmup(10000)\n+    public void test126_verifier(RunInfo info) {\n+        long res = test126(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test126(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test126 but with interface type\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test127(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test127\")\n+    @Warmup(10000)\n+    public void test127_verifier(RunInfo info) {\n+        long res = test127(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test127(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after CCP\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test128(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test128\")\n+    @Warmup(10000)\n+    public void test128_verifier(RunInfo info) {\n+        long res = test128(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test128(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test128 but with interface type\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test129(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 0; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test129\")\n+    @Warmup(10000)\n+    public void test129_verifier(RunInfo info) {\n+        long res = test129(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test129(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Lock on inline type (known after inlining)\n+    @ForceInline\n+    public Object test130_inlinee() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD},\n+        \/\/ LockNode keeps MyValue1 allocation alive up until macro expansion which in turn keeps MyValue2\n+        \/\/ alloc alive. Although the MyValue1 allocation is removed (unused), MyValue2 is expanded first\n+        \/\/ and therefore stays.\n+        counts = {ALLOC, \"<= 1\", STORE, \"<= 1\"})\n+    public void test130() {\n+        Object obj = test130_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test130 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test130\")\n+    public void test130_verifier() {\n+        try {\n+            test130();\n+            throw new RuntimeException(\"test130 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test130 but with field load instead of allocation\n+    @ForceInline\n+    public Object test131_inlinee() {\n+        return testValue1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test131() {\n+        Object obj = test131_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test131 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test131\")\n+    public void test131_verifier() {\n+        try {\n+            test131();\n+            throw new RuntimeException(\"test131 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test locking on object that is known to be an inline type only after CCP\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public void test132() {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        Object obj = Integer.valueOf(42);\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            obj = vt;\n+        }\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test132 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test132\")\n+    @Warmup(10000)\n+    public void test132_verifier() {\n+        try {\n+            test132();\n+            throw new RuntimeException(\"test132 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test conditional locking on inline type and non-escaping object\n+    @Test\n+    public void test133(boolean b) {\n+        Object obj = b ? Integer.valueOf(42) : MyValue2.createWithFieldsInline(rI, rD);\n+        synchronized (obj) {\n+            if (!b) {\n+                throw new RuntimeException(\"test133 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test133\")\n+    public void test133_verifier() {\n+        test133(true);\n+        try {\n+            test133(false);\n+            throw new RuntimeException(\"test133 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Variant with non-scalarized inline type\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public static void test134(boolean b) {\n+        Object obj = null;\n+        if (b) {\n+            obj = MyValue2.createWithFieldsInline(rI, rD);\n+        }\n+        synchronized (obj) {\n+\n+        }\n+    }\n+\n+    @Run(test = \"test134\")\n+    public void test134_verifier() {\n+        try {\n+            test134(true);\n+            throw new RuntimeException(\"test134 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test that acmp of the same inline object is removed\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test135() {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        return val == val;\n+    }\n+\n+    @Run(test = \"test135\")\n+    public void test135_verifier() {\n+        Asserts.assertTrue(test135());\n+    }\n+\n+    \/\/ Same as test135 but with .ref\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test136(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val == val;\n+    }\n+\n+    @Run(test = \"test136\")\n+    public void test136_verifier() {\n+        Asserts.assertTrue(test136(false));\n+        Asserts.assertTrue(test136(true));\n+    }\n+\n+    \/\/ Test that acmp of different inline objects with same content is removed\n+    @Test\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test137(int i) {\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(i, rD);\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test137\")\n+    public void test137_verifier() {\n+        Asserts.assertTrue(test137(rI));\n+    }\n+\n+    \/\/ Same as test137 but with .ref\n+    @Test\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    public static boolean test138(int i, boolean b) {\n+        MyValue2.ref val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2.ref val2 = MyValue2.createWithFieldsInline(i, rD);\n+        if (b) {\n+            val1 = null;\n+            val2 = null;\n+        }\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test138\")\n+    public void test138_verifier() {\n+        Asserts.assertTrue(test138(rI, false));\n+        Asserts.assertTrue(test138(rI, true));\n+    }\n+\n+    static primitive class Test139Value {\n+        Object obj = null;\n+        MyValueEmpty empty = MyValueEmpty.default;\n+    }\n+\n+    static primitive class Test139Wrapper {\n+        Test139Value value = Test139Value.default;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public MyValueEmpty test139() {\n+        Test139Wrapper w = new Test139Wrapper();\n+        return w.value.empty;\n+    }\n+\n+    @Run(test = \"test139\")\n+    public void test139_verifier() {\n+        MyValueEmpty empty = test139();\n+        Asserts.assertEquals(empty, MyValueEmpty.default);\n+    }\n+\n+    \/\/ Test calling a method on a loaded but not linked inline type\n+    final primitive class Test140Value {\n+        final int x = 42;\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public int test140() {\n+        Test140Value vt = Test140Value.default;\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test140\")\n+    @Warmup(0)\n+    public void test140_verifier() {\n+        int result = test140();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Test calling a method on a linked but not initialized inline type\n+    final primitive class Test141Value {\n+        final int x = 42;\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public int test141() {\n+        Test141Value vt = Test141Value.default;\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test141\")\n+    @Warmup(0)\n+    public void test141_verifier() {\n+        int result = test141();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Test that virtual calls on inline type receivers are properly inlined\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n+    public long test142() {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test142\")\n+    public void test142_verifier() {\n+        long res = test142();\n+        Asserts.assertEquals(res, testValue2.hash());\n+    }\n+\n+    public int intField;\n+\n+    private static final MethodHandle withfieldWithInvalidHolder = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"withfieldWithInvalidHolder\",\n+        MethodType.methodType(void.class, TestLWorld.class, int.class),\n+        CODE -> {\n+            CODE.\n+            aload_0().\n+            iload_1().\n+            withfield(TestLWorld.class, \"intField\", \"I\").\n+            return_();\n+        });\n+\n+    \/\/ Test withfield on identity class\n+    @Test\n+    public void test143() throws Throwable {\n+        withfieldWithInvalidHolder.invoke(this, 0);\n+    }\n+\n+    @Run(test = \"test143\")\n+    @Warmup(10000)\n+    public void test143_verifier() throws Throwable {\n+        try {\n+            test143();\n+            throw new RuntimeException(\"IncompatibleClassChangeError expected\");\n+        } catch (IncompatibleClassChangeError e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test merging of buffered default and non-default inline types\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public Object test144(int i) {\n+        if (i == 0) {\n+            return MyValue1.default;\n+        } else if (i == 1) {\n+            return testValue1;\n+        } else {\n+            return MyValue1.default;\n+        }\n+    }\n+\n+    @Run(test = \"test144\")\n+    public void test144_verifier() {\n+        Asserts.assertEquals(test144(0), MyValue1.default);\n+        Asserts.assertEquals(test144(1), testValue1);\n+        Asserts.assertEquals(test144(2), MyValue1.default);\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatibleRef = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementIncompatibleRef\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, PrimitiveClass.asPrimaryType(MyValue2.class)),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aload_3().\n+            aastore().\n+            return_();\n+        });\n+\n+    \/\/ Same as test44 but with .ref store to array\n+    @Test\n+    public void test145(MyValue1[] va, int index, MyValue2.ref v) throws Throwable {\n+        setArrayElementIncompatibleRef.invoke(this, va, index, v);\n+    }\n+\n+    @Run(test = \"test145\")\n+    @Warmup(10000)\n+    public void test145_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test145(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test inline type connected to result node\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test146(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    @Run(test = \"test146\")\n+    @Warmup(10000)\n+    public void test146_verifier() {\n+        Asserts.assertEQ(test146(testValue1), testValue1);\n+    }\n+\n+    \/\/ Same as test146 but with .ref cast\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test147(Object obj) {\n+        return (MyValue1.ref)obj;\n+    }\n+\n+    @Run(test = \"test147\")\n+    @Warmup(10000)\n+    public void test147_verifier() {\n+        Asserts.assertEQ(test147(testValue1), testValue1);\n+        Asserts.assertEQ(test147(null), null);\n+    }\n+\n+    @ForceInline\n+    public Object test148_helper(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    \/\/ Same as test146 but with helper method\n+    @Test\n+    public Object test148(Object obj) {\n+        return test148_helper(obj);\n+    }\n+\n+    @Run(test = \"test148\")\n+    @Warmup(10000)\n+    public void test148_verifier() {\n+        Asserts.assertEQ(test148(testValue1), testValue1);\n+    }\n+\n+    @ForceInline\n+    public Object test149_helper(Object obj) {\n+        return (MyValue1.ref)obj;\n+    }\n+\n+    \/\/ Same as test147 but with helper method\n+    @Test\n+    public Object test149(Object obj) {\n+        return test149_helper(obj);\n+    }\n+\n+    @Run(test = \"test149\")\n+    @Warmup(10000)\n+    public void test149_verifier() {\n+        Asserts.assertEQ(test149(testValue1), testValue1);\n+        Asserts.assertEQ(test149(null), null);\n+    }\n+\n+    \/\/ Test post-parse call devirtualization with inline type receiver\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test150() {\n+        MyValue2 val = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test150\")\n+    public void test150_verifier() {\n+        Asserts.assertEquals(test150(), testValue2.hash());\n+    }\n+\n+    \/\/ Same as test150 but with val not being allocated in the scope of the method\n+    @Test\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test151(MyValue2 val) {\n+        MyAbstract receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 100; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test151\")\n+    @Warmup(0) \/\/ Make sure there is no receiver type profile\n+    public void test151_verifier() {\n+        Asserts.assertEquals(test151(testValue2), testValue2.hash());\n+    }\n+\n+    static interface MyInterface2 {\n+        public int val();\n+    }\n+\n+    static abstract class MyAbstract2 implements MyInterface2 {\n+\n+    }\n+\n+    static class MyClass152 extends MyAbstract2 {\n+        private int val;\n+\n+        @ForceInline\n+        public MyClass152(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public int val() {\n+            return val;\n+        }\n+    }\n+\n+    static primitive class MyValue152 extends MyAbstract2 {\n+        private int unused = 0; \/\/ Make sure sub-offset of val is field non-zero\n+        private int val;\n+\n+        @ForceInline\n+        public MyValue152(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public int val() {\n+            return val;\n+        }\n+    }\n+\n+    static primitive class MyWrapper152 {\n+        private int unused = 0; \/\/ Make sure sub-offset of val field is non-zero\n+        MyValue152 val;\n+\n+        @ForceInline\n+        public MyWrapper152(MyInterface2 val) {\n+            this.val = (MyValue152)val;\n+        }\n+    }\n+\n+    \/\/ Test that checkcast with speculative type does not break scalarization in return\n+    @Test\n+    public MyWrapper152 test152(MyInterface2 val) {\n+        return new MyWrapper152(val);\n+    }\n+\n+    @Run(test = \"test152\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test152_verifier() {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test152(val).val, val);\n+    }\n+\n+    @DontInline\n+    static void test153_helper(MyWrapper152 arg) {\n+\n+    }\n+\n+    \/\/ Test that checkcast with speculative type does not prevent scalarization in args\n+    @Test\n+    public void test153(MyInterface2 val) {\n+        test153_helper(new MyWrapper152(val));\n+    }\n+\n+    @Run(test = \"test153\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test153_verifier() {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        test153(val);\n+    }\n+\n+    \/\/ Test that checkcast with speculative type enables scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test154(Method m, MyInterface2 val, boolean b1, boolean b2) {\n+        MyInterface2 obj = new MyValue152(rI);\n+        if (b1) {\n+            \/\/ Speculative cast to MyValue152 enables scalarization\n+            obj = (MyAbstract2)val;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.val();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test154\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test154_verifier(RunInfo info) {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test154(info.getTest(), val, false, false), -1);\n+        Asserts.assertEquals(test154(info.getTest(), val, true, false), -1);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test154(info.getTest(), val, false, true), rI);\n+        }\n+    }\n+\n+    \/\/ Same as test154 but with null val\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test155(Method m, MyInterface2 val, boolean b1, boolean b2) {\n+        MyInterface2 obj = new MyValue152(rI);\n+        if (b1) {\n+            \/\/ Speculative cast to MyValue152 enables scalarization\n+            obj = (MyAbstract2)val;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.val();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test155\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test155_verifier(RunInfo info) {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test155(info.getTest(), val, false, false), -1);\n+        Asserts.assertEquals(test155(info.getTest(), val, true, false), -1);\n+        Asserts.assertEquals(test155(info.getTest(), null, true, false), -1);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test155(info.getTest(), val, false, true), rI);\n+        }\n+    }\n+\n+    \/\/ Test withfield directly operating on inline type arg (instead of on defaultvalue)\n+    @Test\n+    public MyValue5 test156(MyValue5 vt) {\n+        return vt.withField(rI);\n+    }\n+\n+    @Run(test = \"test156\")\n+    @Warmup(10000)\n+    public void test156_verifier() {\n+        Asserts.assertEquals(test156(new MyValue5()).x, rI);\n+    }\n+\n+    final static MyValue1 test157Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Test merging buffered inline type from field load with non-buffered inline type\n+    @Test\n+    public MyValue1 test157(long val) {\n+        return (val == 0L) ? test157Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test157\")\n+    public void test157_verifier() {\n+        Asserts.assertEquals(test157(0), test157Cache);\n+        Asserts.assertEquals(test157(rL).hash(), testValue1.hash());\n+    }\n+\n+    static MyValue1 test158Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Same as test157 but with non-final field load\n+    @Test\n+    public MyValue1 test158(long val) {\n+        return (val == 0L) ? test158Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test158\")\n+    public void test158_verifier() {\n+        Asserts.assertEquals(test158(0), test158Cache);\n+        Asserts.assertEquals(test158(rL).hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Test null check on withfield receiver\n+    @Test\n+    public MyValue5.ref test159(MyValue5.ref vt) {\n+        return MyValue5.withField(vt, rI);\n+    }\n+\n+    @Run(test = \"test159\")\n+    @Warmup(10000)\n+    public void test159_verifier(RunInfo info) {\n+        Asserts.assertEquals(test159(new MyValue5()).x, rI);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test159(null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify that cast that with incompatible types is properly handled\n+    @Test\n+    public void test160(Integer arg) {\n+        Object tmp = arg;\n+        MyValue1 res = (MyValue1)tmp;\n+    }\n+\n+    @Run(test = \"test160\")\n+    @Warmup(10000)\n+    public void test160_verifier(RunInfo info) {\n+        try {\n+            test160(42);\n+            throw new RuntimeException(\"No CCE thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test160(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":4386,"deletions":0,"binary":false,"changes":4386,"status":"added"},{"patch":"@@ -0,0 +1,1131 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline type specific profiling\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestLWorldProfiling.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestLWorldProfiling\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestLWorldProfiling {\n+\n+    public static void main(String[] args) {\n+        final Scenario[] scenarios = {\n+                new Scenario(0,\n+                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\",\n+                        \"-XX:-MonomorphicArrayCheck\"),\n+                new Scenario(1,\n+                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:+UseArrayLoadStoreProfile\",\n+                        \"-XX:+UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\"),\n+                new Scenario(2,\n+                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=222\",\n+                        \"-XX:-MonomorphicArrayCheck\"),\n+                new Scenario(3,\n+                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\",\n+                        \"-XX:-MonomorphicArrayCheck\",\n+                        \"-XX:TieredStopAtLevel=4\",\n+                        \"-XX:-TieredCompilation\"),\n+                new Scenario(4,\n+                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:+UseArrayLoadStoreProfile\",\n+                        \"-XX:+UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=0\",\n+                        \"-XX:TieredStopAtLevel=4\",\n+                        \"-XX:-TieredCompilation\"),\n+                new Scenario(5,\n+                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \"-XX:FlatArrayElementMaxSize=-1\",\n+                        \"-XX:-UseArrayLoadStoreProfile\",\n+                        \"-XX:-UseACmpProfile\",\n+                        \"-XX:TypeProfileLevel=222\",\n+                        \"-XX:-MonomorphicArrayCheck\",\n+                        \"-XX:TieredStopAtLevel=4\",\n+                        \"-XX:-TieredCompilation\")\n+        };\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\")\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class)\n+                   .start();\n+    }\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);\n+    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1};\n+    private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2};\n+    private static final Integer[] testIntegerArray = new Integer[] {42};\n+    private static final Long[] testLongArray = new Long[] {42L};\n+    private static final Double[] testDoubleArray = new Double[] {42.0D};\n+    private static final MyValue1.ref[] testValue1NotFlatArray = new MyValue1.ref[] {testValue1};\n+    private static final MyValue1[][] testValue1ArrayArray = new MyValue1[][] {testValue1Array};\n+\n+    \/\/ Wrap these variables into helper class because\n+    \/\/ WhiteBox API needs to be initialized by TestFramework first.\n+    static class WBFlags {\n+        static final boolean UseACmpProfile = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"UseACmpProfile\");\n+        static final boolean TieredCompilation = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"TieredCompilation\");\n+        static final boolean ProfileInterpreter = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"ProfileInterpreter\");\n+        static final boolean UseArrayLoadStoreProfile = (Boolean) WhiteBox.getWhiteBox().getVMFlag(\"UseArrayLoadStoreProfile\");\n+        static final long TypeProfileLevel = (Long) WhiteBox.getWhiteBox().getVMFlag(\"TypeProfileLevel\");\n+    }\n+\n+    \/\/ aaload\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIfAnd={\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test1(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    public void test1_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object o = test1(testValue1Array);\n+            Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+        } else {\n+            Object o = test1(testValue2Array);\n+            Asserts.assertEQ(((MyValue2)o).hash(), testValue2.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test2(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(10000)\n+    public void test2_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object o = test2(testIntegerArray);\n+            Asserts.assertEQ(o, 42);\n+        } else {\n+            Object o = test2(testLongArray);\n+            Asserts.assertEQ(o, 42L);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test3(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(10000)\n+    public void test3_verifier() {\n+        Object o = test3(testValue1Array);\n+        Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+        o = test3(testValue2Array);\n+        Asserts.assertEQ(((MyValue2)o).hash(), testValue2.hash());\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test4(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(10000)\n+    public void test4_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object o = test4(testIntegerArray);\n+            Asserts.assertEQ(o, 42);\n+            o = test4(testLongArray);\n+            Asserts.assertEQ(o, 42L);\n+        } else {\n+            Object o = test4(testValue2Array);\n+            Asserts.assertEQ(((MyValue2)o).hash(), testValue2.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test5(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(10000)\n+    public void test5_verifier() {\n+        Object o = test5(testValue1Array);\n+        Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+        o = test5(testValue1NotFlatArray);\n+        Asserts.assertEQ(((MyValue1)o).hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Check that profile data that's useless at the aaload is\n+    \/\/ leveraged at a later point\n+    @DontInline\n+    public void test6_no_inline() {\n+    }\n+\n+\n+    public void test6_helper(Number[] arg) {\n+        if (arg instanceof Long[]) {\n+            test6_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        counts = {CALL, \"= 3\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\", RANGE_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {CALL, \"= 4\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n+    public Object test6(Number[] array) {\n+        Number v = array[0];\n+        test6_helper(array);\n+        return v;\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(10000)\n+    public void test6_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test6_helper(testLongArray);\n+            test6_helper(testDoubleArray);\n+        }\n+        test6(testIntegerArray);\n+    }\n+\n+    @DontInline\n+    public void test7_no_inline() {\n+    }\n+\n+\n+    public void test7_helper(Number arg) {\n+        if (arg instanceof Long) {\n+            test7_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        counts = {CALL, \"= 4\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\", RANGE_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n+    public Object test7(Number[] array) {\n+        Number v = array[0];\n+        test7_helper(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(10000)\n+    public void test7_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test7_helper(42L);\n+            test7_helper(42.0D);\n+        }\n+        test7(testIntegerArray);\n+    }\n+\n+    @DontInline\n+    public void test8_no_inline() {\n+    }\n+\n+    public void test8_helper(Object arg) {\n+        if (arg instanceof Long) {\n+            test8_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {CALL, \"= 5\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\",\n+                  RANGE_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {CALL, \"= 5\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 2\"})\n+    public Object test8(Object[] array) {\n+        Object v = array[0];\n+        test8_helper(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(10000)\n+    public void test8_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test8_helper(42L);\n+            test8_helper(42.0D);\n+        }\n+        test8(testValue1Array);\n+        test8(testValue1NotFlatArray);\n+    }\n+\n+    \/\/ aastore\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test9(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(10000)\n+    public void test9_verifier() {\n+        test9(testValue1Array, testValue1);\n+        Asserts.assertEQ(testValue1Array[0].hash(), testValue1.hash());\n+    }\n+\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test10(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test10\")\n+    @Warmup(10000)\n+    public void test10_verifier() {\n+        test10(testIntegerArray, 42);\n+    }\n+\n+    @Test\n+    @IR(counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test11(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(10000)\n+    public void test11_verifier() {\n+        test11(testValue1Array, testValue1);\n+        test11(testValue2Array, testValue2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test12(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test12\")\n+    @Warmup(10000)\n+    public void test12_verifier() {\n+        test12(testIntegerArray, 42);\n+        test12(testLongArray, 42L);\n+    }\n+\n+    @Test\n+    @IR(counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test13(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(10000)\n+    public void test13_verifier() {\n+        test13(testValue1Array, testValue1);\n+        test13(testValue1NotFlatArray, testValue1);\n+    }\n+\n+    \/\/ MonomorphicArrayCheck\n+    @Test\n+    public void test14(Number[] array, Number v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test14\")\n+    @Warmup(10000)\n+    public void test14_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            test14(testIntegerArray, 42);\n+        } else {\n+            Method m = info.getTest();\n+            boolean deopt = false;\n+            for (int i = 0; i < 100; i++) {\n+                test14(testIntegerArray, 42);\n+                if (!info.isCompilationSkipped() && !TestFramework.isCompiled(m)) {\n+                    deopt = true;\n+                }\n+            }\n+            if (deopt && TestFramework.isStableDeopt(m, CompLevel.C2) && !WBFlags.TieredCompilation && WBFlags.ProfileInterpreter &&\n+                (WBFlags.UseArrayLoadStoreProfile || WBFlags.TypeProfileLevel == 222)) {\n+                throw new RuntimeException(\"Monomorphic array check should rely on profiling and be accurate\");\n+            }\n+        }\n+    }\n+\n+    \/\/ null free array profiling\n+\n+    primitive static class NotFlattenable {\n+        private final Object o1 = null;\n+        private final Object o2 = null;\n+        private final Object o3 = null;\n+        private final Object o4 = null;\n+        private final Object o5 = null;\n+        private final Object o6 = null;\n+    }\n+\n+    private static final NotFlattenable notFlattenable = new NotFlattenable();\n+    private static final NotFlattenable[] testNotFlattenableArray = new NotFlattenable[] { notFlattenable };\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        counts = {NULL_CHECK_TRAP, \"= 2\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIfAnd = {\"UseArrayLoadStoreProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test15(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test15\")\n+    @Warmup(10000)\n+    public void test15_verifier() {\n+        test15(testNotFlattenableArray, notFlattenable);\n+        try {\n+            test15(testNotFlattenableArray, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {NULL_CHECK_TRAP, \"= 2\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test16(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test16\")\n+    @Warmup(10000)\n+    public void test16_verifier() {\n+        test16(testNotFlattenableArray, notFlattenable);\n+        try {\n+            test16(testNotFlattenableArray, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        test16(testIntegerArray, 42);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {NULL_CHECK_TRAP, \"= 1\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test17(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Run(test = \"test17\")\n+    @Warmup(10000)\n+    public void test17_verifier() {\n+        test17(testIntegerArray, 42);\n+        test17(testIntegerArray, null);\n+        testIntegerArray[0] = 42;\n+        test17(testLongArray, 42L);\n+    }\n+\n+    public void test18_helper(Object[] array, Object v) {\n+        array[0] = v;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        counts = {NULL_CHECK_TRAP, \"= 1\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test18(Object[] array, Object v1) {\n+        Object v2 = array[0];\n+        test18_helper(array, v1);\n+        return v2;\n+    }\n+\n+    @Run(test = \"test18\")\n+    @Warmup(10000)\n+    public void test18_verifier() {\n+        test18_helper(testValue1Array, testValue1); \/\/ pollute profile\n+        test18(testIntegerArray, 42);\n+        test18(testIntegerArray, null);\n+        testIntegerArray[0] = 42;\n+        test18(testLongArray, 42L);\n+    }\n+\n+    \/\/ maybe null free, not flat\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {LOAD_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public Object test19(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test19\")\n+    @Warmup(10000)\n+    public void test19_verifier() {\n+        Object o = test19(testIntegerArray);\n+        Asserts.assertEQ(o, 42);\n+        o = test19(testNotFlattenableArray);\n+        Asserts.assertEQ(o, notFlattenable);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+        failOn = {STORE_UNKNOWN_INLINE})\n+    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"false\"},\n+        counts = {STORE_UNKNOWN_INLINE, \"= 1\"})\n+    public void test20(Object[] array, Object o) {\n+        array[0] = o;\n+    }\n+\n+    @Run(test = \"test20\")\n+    @Warmup(10000)\n+    public void test20_verifier() {\n+        test20(testIntegerArray, 42);\n+        test20(testNotFlattenableArray, notFlattenable);\n+    }\n+\n+    \/\/ acmp tests\n+\n+    \/\/ branch frequency profiling causes not equal branch to be optimized out\n+    @Test\n+    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    public boolean test21(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test21\")\n+    @Warmup(10000)\n+    public void test21_verifier() {\n+        test21(42, 42);\n+        test21(testValue1, testValue1);\n+    }\n+\n+    \/\/ Input profiled non null\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test22(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test22\")\n+    @Warmup(10000)\n+    public void test22_verifier(RunInfo info) {\n+        test22(42, null);\n+        test22(42.0, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test22(42, 42.0);\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test23(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test23\")\n+    @Warmup(10000)\n+    public void test23_verifier(RunInfo info) {\n+        test23(null, 42);\n+        test23(null, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test23(42, 42.0);\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test24(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test24\")\n+    @Warmup(10000)\n+    public void test24_verifier(RunInfo info) {\n+        test24(42, null);\n+        test24(42.0, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test24(42, 42.0);\n+             if (WBFlags.UseACmpProfile) {\n+                 TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_ASSERT_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test25(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test25\")\n+    @Warmup(10000)\n+    public void test25_verifier(RunInfo info) {\n+        test25(null, 42);\n+        test25(null, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            test25(42, 42.0);\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    \/\/ Input profiled not inline type with known type\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test26(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test26\")\n+    @Warmup(10000)\n+    public void test26_verifier(RunInfo info) {\n+        test26(42, 42);\n+        test26(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test26(42.0, 42);\n+            }\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = { NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test27(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test27\")\n+    @Warmup(10000)\n+    public void test27_verifier(RunInfo info) {\n+        test27(42, 42);\n+        test27(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test27(42, 42.0);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test28(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test28\")\n+    @Warmup(10000)\n+    public void test28_verifier(RunInfo info) {\n+        test28(42, 42);\n+        test28(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test28(42.0, 42);\n+            }\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test29(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test29\")\n+    @Warmup(10000)\n+    public void test29_verifier(RunInfo info) {\n+        test29(42, 42);\n+        test29(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test29(42, 42.0);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test30(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(10000)\n+    public void test30_verifier(RunInfo info) {\n+        test30(42, 42);\n+        test30(42, 42.0);\n+        test30(null, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test30(42.0, 42);\n+            }\n+            if (WBFlags.UseACmpProfile || WBFlags.TypeProfileLevel != 0) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test31(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test31\")\n+    @Warmup(10000)\n+    public void test31_verifier(RunInfo info) {\n+        test31(42, 42);\n+        test31(42.0, 42);\n+        test31(42, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test31(42, 42.0);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    \/\/ Input profiled not inline type with unknown type\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test32(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test32\")\n+    @Warmup(10000)\n+    public void test32_verifier(RunInfo info) {\n+        test32(42, 42);\n+        test32(42, testValue1);\n+        test32(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test32(testValue1, 42);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test33(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test33\")\n+    @Warmup(10000)\n+    public void test33_verifier(RunInfo info) {\n+        test33(42, 42);\n+        test33(testValue1, 42);\n+        test33(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test33(42, testValue1);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test34(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test34\")\n+    @Warmup(10000)\n+    public void test34_verifier(RunInfo info) {\n+        test34(42, 42);\n+        test34(42, testValue1);\n+        test34(42.0, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test34(testValue1, 42);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {NULL_CHECK_TRAP, \"= 1\", CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test35(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @Run(test = \"test35\")\n+    @Warmup(10000)\n+    public void test35_verifier(RunInfo info) {\n+        test35(42, 42);\n+        test35(testValue1, 42);\n+        test35(42, 42.0);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test35(42, testValue1);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test36(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test36\")\n+    @Warmup(10000)\n+    public void test36_verifier(RunInfo info) {\n+        test36(42, 42.0);\n+        test36(42.0, testValue1);\n+        test36(null, 42);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test36(testValue1, 42);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseACmpProfile\", \"true\"},\n+        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP})\n+    @IR(applyIf = {\"UseACmpProfile\", \"false\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public boolean test37(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test37\")\n+    @Warmup(10000)\n+    public void test37_verifier(RunInfo info) {\n+        test37(42.0, 42);\n+        test37(testValue1, 42.0);\n+        test37(42, null);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiledByC2(m);\n+            for (int i = 0; i < 10; i++) {\n+                test37(42, testValue1);\n+            }\n+            if (WBFlags.UseACmpProfile) {\n+                TestFramework.assertDeoptimizedByC2(m);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that acmp profile data that's unused at the acmp is fed to\n+    \/\/ speculation and leverage later\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public void test38(Object o1, Object o2, Object o3) {\n+        if (o1 == o2) {\n+            test38_helper2();\n+        }\n+        test38_helper(o1, o3);\n+    }\n+\n+    public void test38_helper(Object o1, Object o2) {\n+        if (o1 == o2) {\n+        }\n+    }\n+\n+    public void test38_helper2() {\n+    }\n+\n+    @Run(test = \"test38\")\n+    @Warmup(10000)\n+    public void test38_verifier() {\n+        test38(42, 42, 42);\n+        test38_helper(testValue1, testValue2);\n+    }\n+\n+\n+    @Test\n+    @IR(applyIfOr = {\"UseACmpProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n+        failOn = {SUBSTITUTABILITY_TEST},\n+        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    @IR(applyIfAnd = {\"UseACmpProfile\", \"false\", \"TypeProfileLevel\", \"!= 222\"},\n+        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+    public void test39(Object o1, Object o2, Object o3) {\n+        if (o1 == o2) {\n+            test39_helper2();\n+        }\n+        test39_helper(o2, o3);\n+    }\n+\n+    public void test39_helper(Object o1, Object o2) {\n+        if (o1 == o2) {\n+        }\n+    }\n+\n+    public void test39_helper2() {\n+    }\n+\n+    @Run(test = \"test39\")\n+    @Warmup(10000)\n+    public void test39_verifier() {\n+        test39(42, 42, 42);\n+        test39_helper(testValue1, testValue2);\n+    }\n+\n+    \/\/ Test array access with polluted array type profile\n+    static abstract class Test40Abstract { }\n+    static class Test40Class extends Test40Abstract { }\n+    static primitive class Test40Inline extends Test40Abstract { }\n+\n+    @ForceInline\n+    public Object test40_access(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Test\n+    public Object test40(Test40Abstract[] array) {\n+        return test40_access(array);\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(10000)\n+    public void test40_verifier(RunInfo info) {\n+        \/\/ Make sure multiple implementors of Test40Abstract are loaded\n+        Test40Inline tmp1 = new Test40Inline();\n+        Test40Class tmp2 = new Test40Class();\n+        if (info.isWarmUp()) {\n+            \/\/ Pollute profile with Object[] (exact)\n+            test40_access(new Object[1]);\n+        } else {\n+            \/\/ When inlining test40_access, profiling contradicts actual type of array\n+            test40(new Test40Class[1]);\n+        }\n+    }\n+\n+    \/\/ Same as test40 but with array store\n+    @ForceInline\n+    public void test41_access(Object[] array, Object val) {\n+        array[0] = val;\n+    }\n+\n+    @Test\n+    public void test41(Test40Inline[] array, Object val) {\n+        test41_access(array, val);\n+    }\n+\n+    @Run(test = \"test41\")\n+    @Warmup(10000)\n+    public void test41_verifier(RunInfo info) {\n+        \/\/ Make sure multiple implementors of Test40Abstract are loaded\n+        Test40Inline tmp1 = new Test40Inline();\n+        Test40Class tmp2 = new Test40Class();\n+        if (info.isWarmUp()) {\n+            \/\/ Pollute profile with exact Object[]\n+            test41_access(new Object[1], new Object());\n+        } else {\n+            \/\/ When inlining test41_access, profiling contradicts actual type of array\n+            test41(new Test40Inline[1], new Test40Inline());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":1131,"deletions":0,"binary":false,"changes":1131,"status":"added"},{"patch":"@@ -0,0 +1,510 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import jdk.internal.value.PrimitiveClass;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @modules java.base\/jdk.internal.value\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestMethodHandles.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestMethodHandles\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestMethodHandles {\n+\n+    static {\n+        try {\n+            Class<?> clazz = TestMethodHandles.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue3.class));\n+            test1_mh = lookup.findVirtual(clazz, \"test1_target\", mt);\n+            test2_mh = lookup.findVirtual(clazz, \"test2_target\", mt);\n+            test3_mh = lookup.findVirtual(clazz, \"test3_target\", mt);\n+\n+            MethodType test4_mt1 = MethodType.methodType(int.class, PrimitiveClass.asValueType(MyValue1.class));\n+            MethodType test4_mt2 = MethodType.methodType(PrimitiveClass.asValueType(MyValue1.class));\n+            MethodHandle test4_mh1 = lookup.findStatic(clazz, \"test4_helper1\", test4_mt1);\n+            MethodHandle test4_mh2 = lookup.findStatic(clazz, \"test4_helper2\", test4_mt2);\n+            test4_mh = MethodHandles.filterReturnValue(test4_mh2, test4_mh1);\n+\n+            MethodType test5_mt = MethodType.methodType(int.class, PrimitiveClass.asValueType(MyValue1.class));\n+            test5_mh = lookup.findVirtual(clazz, \"test5_target\", test5_mt);\n+\n+            MethodType test6_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue3.class));\n+            MethodHandle test6_mh1 = lookup.findVirtual(clazz, \"test6_target1\", test6_mt);\n+            MethodHandle test6_mh2 = lookup.findVirtual(clazz, \"test6_target2\", test6_mt);\n+            MethodType boolean_mt = MethodType.methodType(boolean.class);\n+            MethodHandle test6_mh_test = lookup.findVirtual(clazz, \"test6_test\", boolean_mt);\n+            test6_mh = MethodHandles.guardWithTest(test6_mh_test, test6_mh1, test6_mh2);\n+\n+            MethodType myvalue2_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class));\n+            test7_mh1 = lookup.findStatic(clazz, \"test7_target1\", myvalue2_mt);\n+            MethodHandle test7_mh2 = lookup.findStatic(clazz, \"test7_target2\", myvalue2_mt);\n+            MethodHandle test7_mh_test = lookup.findStatic(clazz, \"test7_test\", boolean_mt);\n+            test7_mh = MethodHandles.guardWithTest(test7_mh_test,\n+                                                    MethodHandles.invoker(myvalue2_mt),\n+                                                    MethodHandles.dropArguments(test7_mh2, 0, MethodHandle.class));\n+\n+            MethodHandle test8_mh1 = lookup.findStatic(clazz, \"test8_target1\", myvalue2_mt);\n+            test8_mh2 = lookup.findStatic(clazz, \"test8_target2\", myvalue2_mt);\n+            MethodHandle test8_mh_test = lookup.findStatic(clazz, \"test8_test\", boolean_mt);\n+            test8_mh = MethodHandles.guardWithTest(test8_mh_test,\n+                                                    MethodHandles.dropArguments(test8_mh1, 0, MethodHandle.class),\n+                                                    MethodHandles.invoker(myvalue2_mt));\n+\n+            MethodType test9_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue3.class));\n+            MethodHandle test9_mh1 = lookup.findVirtual(clazz, \"test9_target1\", test9_mt);\n+            MethodHandle test9_mh2 = lookup.findVirtual(clazz, \"test9_target2\", test9_mt);\n+            MethodHandle test9_mh3 = lookup.findVirtual(clazz, \"test9_target3\", test9_mt);\n+            MethodType test9_mt2 = MethodType.methodType(boolean.class);\n+            MethodHandle test9_mh_test1 = lookup.findVirtual(clazz, \"test9_test1\", test9_mt2);\n+            MethodHandle test9_mh_test2 = lookup.findVirtual(clazz, \"test9_test2\", test9_mt2);\n+            test9_mh = MethodHandles.guardWithTest(test9_mh_test1,\n+                                                    test9_mh1,\n+                                                    MethodHandles.guardWithTest(test9_mh_test2, test9_mh2, test9_mh3));\n+\n+            MethodType test10_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class));\n+            MethodHandle test10_mh1 = lookup.findStatic(clazz, \"test10_target1\", test10_mt);\n+            test10_mh2 = lookup.findStatic(clazz, \"test10_target2\", test10_mt);\n+            test10_mh3 = lookup.findStatic(clazz, \"test10_target3\", test10_mt);\n+            MethodType test10_mt2 = MethodType.methodType(boolean.class);\n+            MethodType test10_mt3 = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class));\n+            MethodHandle test10_mh_test1 = lookup.findStatic(clazz, \"test10_test1\", test10_mt2);\n+            MethodHandle test10_mh_test2 = lookup.findStatic(clazz, \"test10_test2\", test10_mt2);\n+            test10_mh = MethodHandles.guardWithTest(test10_mh_test1,\n+                                                    MethodHandles.dropArguments(test10_mh1, 0, MethodHandle.class, MethodHandle.class),\n+                                                    MethodHandles.guardWithTest(test10_mh_test2,\n+                                                                                MethodHandles.dropArguments(MethodHandles.invoker(test10_mt3), 1, MethodHandle.class),\n+                                                                                MethodHandles.dropArguments(MethodHandles.invoker(test10_mt3), 0, MethodHandle.class))\n+                                                    );\n+\n+            MethodHandle test11_mh1 = lookup.findStatic(clazz, \"test11_target1\", myvalue2_mt);\n+            test11_mh2 = lookup.findStatic(clazz, \"test11_target2\", myvalue2_mt);\n+            MethodHandle test11_mh_test = lookup.findStatic(clazz, \"test11_test\", boolean_mt);\n+            test11_mh = MethodHandles.guardWithTest(test11_mh_test,\n+                                                    MethodHandles.dropArguments(test11_mh1, 0, MethodHandle.class),\n+                                                    MethodHandles.invoker(myvalue2_mt));\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+\n+        \/\/ Prevent inlining through MethodHandle linkTo adapters to stress the calling convention\n+        scenarios[2].addFlags(\"-DVerifyIR=false\",\n+                              \"-XX:CompileCommand=dontinline,java.lang.invoke.DirectMethodHandle::internalMemberName\");\n+        scenarios[4].addFlags(\"-XX:CompileCommand=dontinline,java.lang.invoke.DirectMethodHandle::internalMemberName\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    \/\/ Everything inlined\n+    final MyValue3 test1_vt = MyValue3.create();\n+\n+    @ForceInline\n+    MyValue3 test1_target() {\n+        return test1_vt;\n+    }\n+\n+    static final MethodHandle test1_mh;\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, STORE, CALL})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC, \"= 1\", STORE, \"= 14\"})\n+    public MyValue3 test1() throws Throwable {\n+        return (MyValue3)test1_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    public void test1_verifier() throws Throwable {\n+        MyValue3 vt = test1();\n+        test1_vt.verify(vt);\n+    }\n+\n+    \/\/ Leaf method not inlined but returned type is known\n+    final MyValue3 test2_vt = MyValue3.create();\n+    @DontInline\n+    MyValue3 test2_target() {\n+        return test2_vt;\n+    }\n+\n+    static final MethodHandle test2_mh;\n+\n+    @Test\n+    public MyValue3 test2() throws Throwable {\n+        return (MyValue3)test2_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier(RunInfo info) throws Throwable {\n+        if (!info.isWarmUp()) {\n+            Method helper_m = getClass().getDeclaredMethod(\"test2_target\");\n+            if (!TestFramework.isCompiled(helper_m)) {\n+                TestFramework.compile(helper_m, CompLevel.C2);\n+            }\n+        }\n+        MyValue3 vt = test2();\n+        test2_vt.verify(vt);\n+    }\n+\n+    \/\/ Leaf method not inlined and returned type not known\n+    final MyValue3 test3_vt = MyValue3.create();\n+    @DontInline\n+    MyValue3 test3_target() {\n+        return test3_vt;\n+    }\n+\n+    static final MethodHandle test3_mh;\n+\n+    @Test\n+    public MyValue3 test3() throws Throwable {\n+        return (MyValue3)test3_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier(RunInfo info) throws Throwable {\n+        \/\/ hack so C2 doesn't know the target of the invoke call\n+        Class c = Class.forName(\"java.lang.invoke.DirectMethodHandle\");\n+        Method m = c.getDeclaredMethod(\"internalMemberName\", Object.class);\n+        WhiteBox.getWhiteBox().testSetDontInlineMethod(m, info.isWarmUp());\n+        MyValue3 vt = test3();\n+        test3_vt.verify(vt);\n+    }\n+\n+    \/\/ When test75_helper1 is inlined in test75, the method handle\n+    \/\/ linker that called it is passed a pointer to a copy of vt\n+    \/\/ stored in memory. The method handle linker needs to load the\n+    \/\/ fields from memory before it inlines test75_helper1.\n+    static public int test4_helper1(MyValue1 vt) {\n+        return vt.x;\n+    }\n+\n+    static MyValue1 test4_vt = MyValue1.createWithFieldsInline(rI, rL);\n+    static public MyValue1 test4_helper2() {\n+        return test4_vt;\n+    }\n+\n+    static final MethodHandle test4_mh;\n+\n+    @Test\n+    public int test4() throws Throwable {\n+        return (int)test4_mh.invokeExact();\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() throws Throwable {\n+        int i = test4();\n+        Asserts.assertEQ(i, test4_vt.x);\n+    }\n+\n+    \/\/ Test method handle call with inline type argument\n+    public int test5_target(MyValue1 vt) {\n+        return vt.x;\n+    }\n+\n+    static final MethodHandle test5_mh;\n+    MyValue1 test5_vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    @Test\n+    public int test5() throws Throwable {\n+        return (int)test5_mh.invokeExact(this, test5_vt);\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() throws Throwable {\n+        int i = test5();\n+        Asserts.assertEQ(i, test5_vt.x);\n+    }\n+\n+    \/\/ Return of target1 and target2 merged in a Lambda Form as an\n+    \/\/ Object. Shouldn't cause any allocation\n+    final MyValue3 test6_vt1 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test6_target1() {\n+        return test6_vt1;\n+    }\n+\n+    final MyValue3 test6_vt2 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test6_target2() {\n+        return test6_vt2;\n+    }\n+\n+    boolean test6_bool = true;\n+    @ForceInline\n+    boolean test6_test() {\n+        return test6_bool;\n+    }\n+\n+    static final MethodHandle test6_mh;\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, ALLOCA, STORE, STORE_INLINE_FIELDS})\n+    public MyValue3 test6() throws Throwable {\n+        return (MyValue3)test6_mh.invokeExact(this);\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() throws Throwable {\n+        test6_bool = !test6_bool;\n+        MyValue3 vt = test6();\n+        vt.verify(test6_bool ? test6_vt1 : test6_vt2);\n+    }\n+\n+    \/\/ Similar as above but with the method handle for target1 not\n+    \/\/ constant. Shouldn't cause any allocation.\n+    @ForceInline\n+    static MyValue2 test7_target1() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test7_target2() {\n+        return MyValue2.createWithFieldsInline(rI+1, rD+1);\n+    }\n+\n+    static boolean test7_bool = true;\n+    @ForceInline\n+    static boolean test7_test() {\n+        return test7_bool;\n+    }\n+\n+    static final MethodHandle test7_mh;\n+    static MethodHandle test7_mh1;\n+\n+    @Test\n+    public long test7() throws Throwable {\n+        return ((MyValue2)test7_mh.invokeExact(test7_mh1)).hash();\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() throws Throwable {\n+        test7_bool = !test7_bool;\n+        long hash = test7();\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test7_bool ? 0 : 1), rD+(test7_bool ? 0 : 1)).hash());\n+    }\n+\n+    \/\/ Same as above but with the method handle for target2 not\n+    \/\/ constant. Shouldn't cause any allocation.\n+    @ForceInline\n+    static MyValue2 test8_target1() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test8_target2() {\n+        return MyValue2.createWithFieldsInline(rI+1, rD+1);\n+    }\n+\n+    static boolean test8_bool = true;\n+    @ForceInline\n+    static boolean test8_test() {\n+        return test8_bool;\n+    }\n+\n+    static final MethodHandle test8_mh;\n+    static MethodHandle test8_mh2;\n+\n+    @Test\n+    public long test8() throws Throwable {\n+        return ((MyValue2)test8_mh.invokeExact(test8_mh2)).hash();\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() throws Throwable {\n+        test8_bool = !test8_bool;\n+        long hash = test8();\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test8_bool ? 0 : 1), rD+(test8_bool ? 0 : 1)).hash());\n+    }\n+\n+    \/\/ Return of target1, target2 and target3 merged in Lambda Forms\n+    \/\/ as an Object. Shouldn't cause any allocation\n+    final MyValue3 test9_vt1 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test9_target1() {\n+        return test9_vt1;\n+    }\n+\n+    final MyValue3 test9_vt2 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test9_target2() {\n+        return test9_vt2;\n+    }\n+\n+    final MyValue3 test9_vt3 = MyValue3.create();\n+    @ForceInline\n+    MyValue3 test9_target3() {\n+        return test9_vt3;\n+    }\n+\n+    boolean test9_bool1 = true;\n+    @ForceInline\n+    boolean test9_test1() {\n+        return test9_bool1;\n+    }\n+\n+    boolean test9_bool2 = true;\n+    @ForceInline\n+    boolean test9_test2() {\n+        return test9_bool2;\n+    }\n+\n+    static final MethodHandle test9_mh;\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC, ALLOCA, STORE, STORE_INLINE_FIELDS})\n+   public MyValue3 test9() throws Throwable {\n+        return (MyValue3)test9_mh.invokeExact(this);\n+    }\n+\n+    static int test9_i = 0;\n+    @Run(test = \"test9\")\n+    public void test9_verifier() throws Throwable {\n+        test9_i++;\n+        test9_bool1 = (test9_i % 2) == 0;\n+        test9_bool2 = (test9_i % 3) == 0;\n+        MyValue3 vt = test9();\n+        vt.verify(test9_bool1 ? test9_vt1 : (test9_bool2 ? test9_vt2 : test9_vt3));\n+    }\n+\n+    \/\/ Same as above but with non constant target2 and target3\n+    @ForceInline\n+    static MyValue2 test10_target1() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test10_target2() {\n+        return MyValue2.createWithFieldsInline(rI+1, rD+1);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test10_target3() {\n+        return MyValue2.createWithFieldsInline(rI+2, rD+2);\n+    }\n+\n+    static boolean test10_bool1 = true;\n+    @ForceInline\n+    static boolean test10_test1() {\n+        return test10_bool1;\n+    }\n+\n+    static boolean test10_bool2 = true;\n+    @ForceInline\n+    static boolean test10_test2() {\n+        return test10_bool2;\n+    }\n+\n+    static final MethodHandle test10_mh;\n+    static MethodHandle test10_mh2;\n+    static MethodHandle test10_mh3;\n+\n+    @Test\n+    public long test10() throws Throwable {\n+        return ((MyValue2)test10_mh.invokeExact(test10_mh2, test10_mh3)).hash();\n+    }\n+\n+    static int test10_i = 0;\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() throws Throwable {\n+        test10_i++;\n+        test10_bool1 = (test10_i % 2) == 0;\n+        test10_bool2 = (test10_i % 3) == 0;\n+        long hash = test10();\n+        int i = rI + (test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));\n+        double d = rD + (test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(i, d).hash());\n+    }\n+\n+    static int test11_i = 0;\n+\n+    @ForceInline\n+    static MyValue2 test11_target1() {\n+        return MyValue2.createWithFieldsInline(rI+test11_i, rD+test11_i);\n+    }\n+\n+    @ForceInline\n+    static MyValue2 test11_target2() {\n+        return MyValue2.createWithFieldsInline(rI-test11_i, rD-test11_i);\n+    }\n+\n+    @ForceInline\n+    static boolean test11_test() {\n+        return (test11_i % 100) == 0;\n+    }\n+\n+    static final MethodHandle test11_mh;\n+    static MethodHandle test11_mh2;\n+\n+    \/\/ Check that a buffered inline type returned by a compiled lambda form\n+    \/\/ is properly handled by the caller.\n+    @Test\n+    public long test11() throws Throwable {\n+        return ((MyValue2)test11_mh.invokeExact(test11_mh2)).hash();\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(11000)\n+    public void test11_verifier() throws Throwable {\n+        test11_i++;\n+        long hash = test11();\n+        boolean b = (test11_i % 100) == 0;\n+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+test11_i * (b ? 1 : -1), rD+test11_i * (b ? 1 : -1)).hash());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":510,"deletions":0,"binary":false,"changes":510,"status":"added"},{"patch":"@@ -0,0 +1,3273 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rD;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable inline type arrays\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestNullableArrays.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestNullableArrays\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestNullableArrays {\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[2].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n+        scenarios[5].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Helper methods\n+\n+    protected long hash() {\n+        return hash(rI, rL);\n+    }\n+\n+    protected long hash(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y).hash();\n+    }\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    \/\/ Test nullable inline type array creation and initialization\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {ALLOCA, \"= 1\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {ALLOCA, \"= 1\"},\n+        failOn = LOAD)\n+    public MyValue1.ref[] test1(int len) {\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        if (len > 0) {\n+            va[0] = null;\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        int len = Math.abs(rI % 10);\n+        MyValue1.ref[] va = test1(len);\n+        if (len > 0) {\n+            Asserts.assertEQ(va[0], null);\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash());\n+        }\n+    }\n+\n+    \/\/ Test creation of an inline type array and element access\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public long test2() {\n+        MyValue1.ref[] va = new MyValue1.ref[1];\n+        va[0] = MyValue1.createWithFieldsInline(rI, rL);\n+        return va[0].hash();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        long result = test2();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Test receiving an inline type array from the interpreter,\n+    \/\/ updating its elements in a loop and computing a hash.\n+    @Test\n+    @IR(failOn = {ALLOCA})\n+    public long test3(MyValue1.ref[] va) {\n+        long result = 0;\n+        for (int i = 0; i < 10; ++i) {\n+            if (va[i] != null) {\n+                result += va[i].hash();\n+            }\n+            va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        }\n+        va[0] = null;\n+        return result;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        MyValue1.ref[] va = new MyValue1.ref[10];\n+        long expected = 0;\n+        for (int i = 1; i < 10; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);\n+            expected += va[i].hash();\n+        }\n+        long result = test3(va);\n+        Asserts.assertEQ(expected, result);\n+        Asserts.assertEQ(va[0], null);\n+        for (int i = 1; i < 10; ++i) {\n+            if (va[i].hash() != hash(rI + 1, rL + 1)) {\n+                Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));\n+            }\n+        }\n+    }\n+\n+    \/\/ Test returning an inline type array received from the interpreter\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    public MyValue1.ref[] test4(MyValue1.ref[] va) {\n+        return va;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        MyValue1.ref[] va = new MyValue1.ref[10];\n+        for (int i = 0; i < 10; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);\n+        }\n+        va = test4(va);\n+        for (int i = 0; i < 10; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));\n+        }\n+    }\n+\n+    \/\/ Merge inline type arrays created from two branches\n+    @Test\n+    public MyValue1.ref[] test5(boolean b) {\n+        MyValue1.ref[] va;\n+        if (b) {\n+            va = new MyValue1.ref[5];\n+            for (int i = 0; i < 5; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            }\n+            va[4] = null;\n+        } else {\n+            va = new MyValue1.ref[10];\n+            for (int i = 0; i < 10; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);\n+            }\n+            va[9] = null;\n+        }\n+        long sum = va[0].hashInterpreted();\n+        if (b) {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI, sum);\n+        } else {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1.ref[] va = test5(true);\n+        Asserts.assertEQ(va.length, 5);\n+        Asserts.assertEQ(va[0].hash(), hash(rI, hash()));\n+        for (int i = 1; i < 4; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash());\n+        }\n+        Asserts.assertEQ(va[4], null);\n+        va = test5(false);\n+        Asserts.assertEQ(va.length, 10);\n+        Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));\n+        for (int i = 1; i < 9; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));\n+        }\n+        Asserts.assertEQ(va[9], null);\n+    }\n+\n+    \/\/ Test creation of inline type array with single element\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public MyValue1.ref test6() {\n+        MyValue1.ref[] va = new MyValue1.ref[1];\n+        return va[0];\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1.ref[] va = new MyValue1.ref[1];\n+        MyValue1.ref v = test6();\n+        Asserts.assertEQ(v, null);\n+    }\n+\n+    \/\/ Test default initialization of inline type arrays\n+    @Test\n+    @IR(failOn = LOAD)\n+    public MyValue1.ref[] test7(int len) {\n+        return new MyValue1.ref[len];\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        int len = Math.abs(rI % 10);\n+        MyValue1.ref[] va = test7(len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+            va[i] = null;\n+        }\n+    }\n+\n+    \/\/ Test creation of inline type array with zero length\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, LOOP, TRAP})\n+    public MyValue1.ref[] test8() {\n+        return new MyValue1.ref[0];\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        MyValue1.ref[] va = test8();\n+        Asserts.assertEQ(va.length, 0);\n+    }\n+\n+    static MyValue1.ref[] test9_va;\n+\n+    \/\/ Test that inline type array loaded from field has correct type\n+    @Test\n+    @IR(failOn = LOOP)\n+    public long test9() {\n+        return test9_va[0].hash();\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9_va = new MyValue1.ref[1];\n+        test9_va[0] = testValue1;\n+        long result = test9();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Multi-dimensional arrays\n+    @Test\n+    public MyValue1.ref[][][] test10(int len1, int len2, int len3) {\n+        MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];\n+        for (int i = 0; i < len1; i++) {\n+            for (int j = 0; j < len2; j++) {\n+                for (int k = 0; k < len3; k++) {\n+                    arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);\n+                    if (k == 0) {\n+                        arr[i][j][k] = null;\n+                    }\n+                }\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        MyValue1.ref[][][] arr = test10(2, 3, 4);\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                for (int k = 0; k < 4; k++) {\n+                    if (k == 0) {\n+                        Asserts.assertEQ(arr[i][j][k], null);\n+                    } else {\n+                        Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());\n+                    }\n+                    arr[i][j][k] = null;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test11(MyValue1.ref[][][] arr, long[] res) {\n+        int l = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            for (int j = 0; j < arr[i].length; j++) {\n+                for (int k = 0; k < arr[i][j].length; k++) {\n+                    if (arr[i][j][k] != null) {\n+                        res[l] = arr[i][j][k].hash();\n+                    }\n+                    arr[i][j][k] = null;\n+                    l++;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];\n+        long[] res = new long[2*3*4];\n+        long[] verif = new long[2*3*4];\n+        int l = 0;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                for (int k = 0; k < 4; k++) {\n+                    if (j != 2) {\n+                        arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);\n+                        verif[l] = arr[i][j][k].hash();\n+                    }\n+                    l++;\n+                }\n+            }\n+        }\n+        test11(arr, res);\n+        for (int i = 0; i < verif.length; i++) {\n+            Asserts.assertEQ(res[i], verif[i]);\n+        }\n+    }\n+\n+    \/\/ Array load out of bounds (upper bound) at compile time\n+    @Test\n+    public int test12() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+        }\n+\n+        try {\n+            return va[arraySize + 1].x;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        Asserts.assertEQ(test12(), rI);\n+    }\n+\n+    \/\/ Array load  out of bounds (lower bound) at compile time\n+    @Test\n+    public int test13() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);\n+        }\n+\n+        try {\n+            return va[-arraySize].x;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        Asserts.assertEQ(test13(), rI);\n+    }\n+\n+    \/\/ Array load out of bound not known to compiler (both lower and upper bound)\n+    @Test\n+    public int test14(MyValue1.ref[] va, int index)  {\n+        return va[index].x;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+\n+        int result;\n+        for (int i = -20; i < 20; i++) {\n+            try {\n+                result = test14(va, i);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                result = rI;\n+            }\n+            Asserts.assertEQ(result, rI);\n+        }\n+    }\n+\n+    \/\/ Array store out of bounds (upper bound) at compile time\n+    @Test\n+    public int test15() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+\n+        try {\n+            for (int i = 0; i <= arraySize; i++) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+            }\n+            return rI - 1;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        Asserts.assertEQ(test15(), rI);\n+    }\n+\n+    \/\/ Array store out of bounds (lower bound) at compile time\n+    @Test\n+    public int test16() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+\n+        try {\n+            for (int i = -1; i <= arraySize; i++) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+            }\n+            return rI - 1;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        Asserts.assertEQ(test16(), rI);\n+    }\n+\n+    \/\/ Array store out of bound not known to compiler (both lower and upper bound)\n+    @Test\n+    public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {\n+        va[index] = vt;\n+        return va[index].x;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+        int result;\n+        for (int i = -20; i < 20; i++) {\n+            try {\n+                result = test17(va, i, vt);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                result = rI + 1;\n+            }\n+            Asserts.assertEQ(result, rI + 1);\n+        }\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            Asserts.assertEQ(va[i].x, rI + 1);\n+        }\n+    }\n+\n+    \/\/ clone() as stub call\n+    @Test\n+    public MyValue1.ref[] test18(MyValue1.ref[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va1 = new MyValue1.ref[len];\n+        MyValue1[]  va2 = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va1[i] = testValue1;\n+            va2[i] = testValue1;\n+        }\n+        MyValue1.ref[] result1 = test18(va1);\n+        if (len > 0) {\n+            Asserts.assertEQ(result1[0], null);\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(result1[i].hash(), va1[i].hash());\n+        }\n+        \/\/ make sure we do deopt: GraphKit::new_array assumes an\n+        \/\/ array of references\n+        for (int j = 0; j < 10; j++) {\n+            MyValue1.ref[] result2 = test18(va2);\n+\n+            for (int i = 0; i < len; ++i) {\n+                Asserts.assertEQ(result2[i].hash(), va2[i].hash());\n+            }\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            MyValue1.ref[] result2 = test18(va2);\n+            for (int i = 0; i < len; ++i) {\n+                Asserts.assertEQ(result2[i].hash(), va2[i].hash());\n+            }\n+        }\n+    }\n+\n+    \/\/ clone() as series of loads\/stores\n+    static MyValue1.ref[] test19_orig = null;\n+\n+    @Test\n+    public MyValue1.ref[] test19() {\n+        MyValue1.ref[] va = new MyValue1.ref[8];\n+        for (int i = 1; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test19_orig = va;\n+\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        MyValue1.ref[] result = test19();\n+        Asserts.assertEQ(result[0], null);\n+        for (int i = 1; i < test19_orig.length; ++i) {\n+            Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with oop fields\n+    @Test\n+    public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] src1 = new MyValue1.ref[len];\n+        MyValue1.ref[] src2 = new MyValue1.ref[len];\n+        MyValue1[]  src3 = new MyValue1[len];\n+        MyValue1[]  src4 = new MyValue1[len];\n+        MyValue1.ref[] dst1 = new MyValue1.ref[len];\n+        MyValue1[]  dst2 = new MyValue1[len];\n+        MyValue1.ref[] dst3 = new MyValue1.ref[len];\n+        MyValue1[]  dst4 = new MyValue1[len];\n+        if (len > 0) {\n+            src2[0] = testValue1;\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test20(src1, dst1);\n+        test20(src2, dst2);\n+        test20(src3, dst3);\n+        test20(src4, dst4);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+            Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+            Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with no oop field\n+    @Test\n+    public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2.ref[] src1 = new MyValue2.ref[len];\n+        MyValue2.ref[] src2 = new MyValue2.ref[len];\n+        MyValue2[]  src3 = new MyValue2[len];\n+        MyValue2[]  src4 = new MyValue2[len];\n+        MyValue2.ref[] dst1 = new MyValue2.ref[len];\n+        MyValue2[]  dst2 = new MyValue2[len];\n+        MyValue2.ref[] dst3 = new MyValue2.ref[len];\n+        MyValue2[]  dst4 = new MyValue2[len];\n+        if (len > 0) {\n+            src2[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test21(src1, dst1);\n+        test21(src2, dst2);\n+        test21(src3, dst3);\n+        test21(src4, dst4);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+            Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+            Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with oop field and tightly\n+    \/\/ coupled allocation as dest\n+    @Test\n+    public MyValue1.ref[] test22(MyValue1.ref[] src) {\n+        MyValue1.ref[] dst = new MyValue1.ref[src.length];\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] src1 = new MyValue1.ref[len];\n+        MyValue1[]  src2 = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+        }\n+        MyValue1.ref[] dst1 = test22(src1);\n+        MyValue1.ref[] dst2 = test22(src2);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array with oop fields and tightly\n+    \/\/ coupled allocation as dest\n+    @Test\n+    public MyValue1.ref[] test23(MyValue1.ref[] src) {\n+        MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];\n+        System.arraycopy(src, 0, dst, 5, src.length);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] src1 = new MyValue1.ref[len];\n+        MyValue1[] src2 = new MyValue1[len];\n+        for (int i = 0; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+        }\n+        MyValue1.ref[] dst1 = test23(src1);\n+        MyValue1.ref[] dst2 = test23(src2);\n+        for (int i = 0; i < 5; ++i) {\n+            Asserts.assertEQ(dst1[i], null);\n+            Asserts.assertEQ(dst2[i], null);\n+        }\n+        for (int i = 5; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of inline type array passed as Object\n+    @Test\n+    public void test24(MyValue1.ref[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] src1 = new MyValue1.ref[len];\n+        MyValue1.ref[] src2 = new MyValue1.ref[len];\n+        MyValue1[]  src3 = new MyValue1[len];\n+        MyValue1[]  src4 = new MyValue1[len];\n+        MyValue1.ref[] dst1 = new MyValue1.ref[len];\n+        MyValue1[]  dst2 = new MyValue1[len];\n+        MyValue1.ref[] dst3 = new MyValue1.ref[len];\n+        MyValue1[]  dst4 = new MyValue1[len];\n+        if (len > 0) {\n+            src2[0] = testValue1;\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test24(src1, dst1);\n+        test24(src2, dst2);\n+        test24(src3, dst3);\n+        test24(src4, dst4);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+            Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+            Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with no oop field\n+    @Test\n+    public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        MyValue2.ref[] src1 = new MyValue2.ref[8];\n+        MyValue2.ref[] src2 = new MyValue2.ref[8];\n+        MyValue2[]  src3 = new MyValue2[8];\n+        MyValue2[]  src4 = new MyValue2[8];\n+        MyValue2.ref[] dst1 = new MyValue2.ref[8];\n+        MyValue2[]  dst2 = new MyValue2[8];\n+        MyValue2.ref[] dst3 = new MyValue2.ref[8];\n+        MyValue2[]  dst4 = new MyValue2[8];\n+        src2[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        for (int i = 1; i < 8; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test25(src1, dst1);\n+        test25(src2, dst2);\n+        test25(src3, dst3);\n+        test25(src4, dst4);\n+        Asserts.assertEQ(dst1[0], null);\n+        Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+        Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+        Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        for (int i = 1; i < 8; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with oop fields\n+    @Test\n+    public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        MyValue1.ref[] src1 = new MyValue1.ref[8];\n+        MyValue1.ref[] src2 = new MyValue1.ref[8];\n+        MyValue1[]  src3 = new MyValue1[8];\n+        MyValue1[]  src4 = new MyValue1[8];\n+        MyValue1.ref[] dst1 = new MyValue1.ref[8];\n+        MyValue1[]  dst2 = new MyValue1[8];\n+        MyValue1.ref[] dst3 = new MyValue1.ref[8];\n+        MyValue1[]  dst4 = new MyValue1[8];\n+        src2[0] = testValue1;\n+        for (int i = 1; i < 8; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test26(src1, dst1);\n+        test26(src2, dst2);\n+        test26(src3, dst3);\n+        test26(src4, dst4);\n+        Asserts.assertEQ(dst1[0], null);\n+        Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+        Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+        Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        for (int i = 1; i < 8; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with oop fields and offsets\n+    @Test\n+    public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+        System.arraycopy(src, 1, dst, 2, 6);\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        MyValue1.ref[] src1 = new MyValue1.ref[8];\n+        MyValue1.ref[] src2 = new MyValue1.ref[8];\n+        MyValue1[]  src3 = new MyValue1[8];\n+        MyValue1[]  src4 = new MyValue1[8];\n+        MyValue1.ref[] dst1 = new MyValue1.ref[8];\n+        MyValue1[]  dst2 = new MyValue1[8];\n+        MyValue1.ref[] dst3 = new MyValue1.ref[8];\n+        MyValue1[]  dst4 = new MyValue1[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test27(src1, dst1);\n+        test27(src2, dst2);\n+        test27(src3, dst3);\n+        test27(src4, dst4);\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(dst1[i], null);\n+            Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());\n+            Asserts.assertEQ(dst3[i], null);\n+            Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());\n+        }\n+        for (int i = 2; i < 8; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocations\n+    \/\/ TODO 8252027: Make sure this is optimized with ZGC\n+    @Test\n+    @IR(applyIf = {\"UseZGC\", \"false\"},\n+        failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public MyValue2.ref test28() {\n+        MyValue2.ref[] src = new MyValue2.ref[10];\n+        src[0] = null;\n+        MyValue2.ref[] dst = (MyValue2.ref[])src.clone();\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2.ref result = test28();\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ non escaping allocations\n+    \/\/ TODO 8227588: shouldn't this have the same IR matching rules as test6?\n+    @Test\n+    @IR(failOn = {ALLOCA, LOOP, TRAP})\n+    public MyValue2.ref test29(MyValue2.ref[] src) {\n+        MyValue2.ref[] dst = new MyValue2.ref[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier(RunInfo info) {\n+        MyValue2.ref[] src1 = new MyValue2.ref[10];\n+        MyValue2.val[] src2 = new MyValue2.val[10];\n+        for (int i = 0; i < 10; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        MyValue2.ref v = test29(src1);\n+        Asserts.assertEQ(src1[0].hash(), v.hash());\n+        if (!info.isWarmUp()) {\n+            v = test29(src2);\n+            Asserts.assertEQ(src2[0].hash(), v.hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocation with uncommon trap that needs\n+    \/\/ eliminated inline type array element as debug info\n+    @Test\n+    public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {\n+        MyValue2.ref[] dst = new MyValue2.ref[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        if (flag) { }\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(10000)\n+    public void test30_verifier(RunInfo info) {\n+        MyValue2.ref[] src1 = new MyValue2.ref[10];\n+        MyValue2.val[] src2 = new MyValue2.val[10];\n+        for (int i = 0; i < 10; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        MyValue2.ref v = test30(src1, !info.isWarmUp());\n+        Asserts.assertEQ(src1[0].hash(), v.hash());\n+        if (!info.isWarmUp()) {\n+            v = test30(src2, true);\n+            Asserts.assertEQ(src2[0].hash(), v.hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocation with memory phi\n+    @Test\n+    \/\/ TODO 8227588\n+    \/\/ @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)\n+    public long test31(boolean b, boolean deopt, Method m) {\n+        MyValue2.ref[] src = new MyValue2.ref[1];\n+        if (b) {\n+            src[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        } else {\n+            src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return src[0].hash();\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier(RunInfo info) {\n+        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);\n+        long result1 = test31(true, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result1, v1.hash());\n+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        long result2 = test31(false, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result2, v2.hash());\n+    }\n+\n+    \/\/ Tests with Object arrays and clone\/arraycopy\n+    \/\/ clone() as stub call\n+    @Test\n+    public Object[] test32(Object[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va1 = new MyValue1.ref[len];\n+        MyValue1[] va2 = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va1[i] = testValue1;\n+            va2[i] = testValue1;\n+        }\n+        MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);\n+        MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);\n+        if (len > 0) {\n+            Asserts.assertEQ(result1[0], null);\n+            Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)result1[i]).hash(), ((MyValue1)va1[i]).hash());\n+            Asserts.assertEQ(((MyValue1)result2[i]).hash(), ((MyValue1)va2[i]).hash());\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test33(Object[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test33(va);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());\n+        }\n+    }\n+\n+    \/\/ clone() as series of loads\/stores\n+    static Object[] test34_orig = null;\n+\n+    @ForceInline\n+    public Object[] test34_helper(boolean flag) {\n+        Object[] va = null;\n+        if (flag) {\n+            va = new MyValue1.ref[8];\n+            for (int i = 0; i < va.length; ++i) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+            }\n+        } else {\n+            va = new Object[8];\n+        }\n+        return va;\n+    }\n+\n+    @Test\n+    public Object[] test34(boolean flag) {\n+        Object[] va = test34_helper(flag);\n+        test34_orig = va;\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier(RunInfo info) {\n+        test34(false);\n+        for (int i = 0; i < 10; i++) { \/\/ make sure we do deopt\n+            Object[] result = test34(true);\n+            verify(test34_orig, result);\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            Object[] result = test34(true);\n+            verify(test34_orig, result);\n+        }\n+    }\n+\n+    static void verify(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue1.ref[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue2.ref[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static boolean compile_and_run_again_if_deoptimized(RunInfo info) {\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            if (TestFramework.isCompiled(m)) {\n+                TestFramework.compile(m, CompLevel.C2);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ arraycopy() of inline type array of unknown size\n+    @Test\n+    public void test35(Object src, Object dst, int len) {\n+        System.arraycopy(src, 0, dst, 0, len);\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] src = new MyValue1.ref[len];\n+        MyValue1.ref[] dst = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = testValue1;\n+        }\n+        test35(src, dst, src.length);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test35(src, dst, src.length);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test36(Object src, MyValue2.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2.ref[] src = new MyValue2.ref[len];\n+        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test36(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test36(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test37(MyValue2.ref[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2.ref[] src = new MyValue2.ref[len];\n+        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test37(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test37(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test38(Object src, MyValue2.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test38\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test38_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test38(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test38(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test39(MyValue2.ref[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2.ref[] src = new MyValue2.ref[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test39(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test39(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test40(Object[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test40_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test40(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test40(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test41(Object src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2.ref[] src = new MyValue2.ref[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test41(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test41(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test42(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test42(src, dst);\n+        verify(src, dst);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    \/\/ short arraycopy()'s\n+    @Test\n+    public void test43(Object src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        MyValue1.ref[] src = new MyValue1.ref[8];\n+        MyValue1.ref[] dst = new MyValue1.ref[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = testValue1;\n+        }\n+        test43(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test43(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test44(Object src, MyValue2.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        MyValue2.ref[] src = new MyValue2.ref[8];\n+        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test44(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test44(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test45(MyValue2.ref[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        MyValue2.ref[] src = new MyValue2.ref[8];\n+        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test45(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test45(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test46(Object[] src, MyValue2.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test46\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test46_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test46(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test46(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test47(MyValue2.ref[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier(RunInfo info) {\n+        MyValue2.ref[] src = new MyValue2.ref[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test47(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test47(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test48(Object[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test48\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test48_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test48(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test48(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test49(Object src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier(RunInfo info) {\n+        MyValue2.ref[] src = new MyValue2.ref[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test49(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test49(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test50(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test50(src, dst);\n+        verify(src, dst);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref[] test51(MyValue1.ref[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        MyValue1.ref[] result = test51(va);\n+        verify(va, result);\n+    }\n+\n+    static final MyValue1.ref[] test52_va = new MyValue1.ref[8];\n+\n+    @Test\n+    public MyValue1.ref[] test52() {\n+        return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        for (int i = 1; i < 8; ++i) {\n+            test52_va[i] = testValue1;\n+        }\n+        MyValue1.ref[] result = test52();\n+        verify(test52_va, result);\n+    }\n+\n+    @Test\n+    public MyValue1.ref[] test53(Object[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        MyValue1.ref[] result = test53(va);\n+        verify(result, va);\n+    }\n+\n+    @Test\n+    public Object[] test54(MyValue1.ref[] va) {\n+        return Arrays.copyOf(va, va.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test54(va);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public Object[] test55(Object[] va) {\n+        return Arrays.copyOf(va, va.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test55(va);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public MyValue1.ref[] test56(Object[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        MyValue1.ref[] result = test56(va);\n+        verify(result, va);\n+    }\n+\n+   @Test\n+    public Object[] test57(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length, klass);\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test57(va, MyValue1.ref[].class);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public Object[] test58(MyValue1.ref[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length, klass);\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        for (int i = 1; i < 10; i++) {\n+            Object[] result = test58(va, MyValue1.ref[].class);\n+            verify(va, result);\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            Object[] result = test58(va, MyValue1.ref[].class);\n+            verify(va, result);\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test59(MyValue1.ref[] va) {\n+        return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1.ref[] verif = new MyValue1.ref[len+1];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = va[i];\n+        }\n+        Object[] result = test59(va);\n+        verify(verif, result);\n+    }\n+\n+    @Test\n+    public Object[] test60(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length+1, klass);\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1.ref[] verif = new MyValue1.ref[len+1];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = (MyValue1)va[i];\n+        }\n+        Object[] result = test60(va, MyValue1.ref[].class);\n+        verify(verif, result);\n+    }\n+\n+    @Test\n+    public Object[] test61(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length+1, klass);\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Integer[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = Integer.valueOf(rI);\n+        }\n+        Object[] result = test61(va, Integer[].class);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(va[i], result[i]);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = oa;\n+        } else {\n+            arr = va;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test62(MyValue1.ref[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test62_helper(i, va, oa);\n+\n+        return Arrays.copyOf(arr, arr.length+1, arr.getClass());\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        Integer[] oa = new Integer[len];\n+        for (int i = 1; i < len; ++i) {\n+            oa[i] = Integer.valueOf(rI);\n+        }\n+        test62_helper(42, va, oa);\n+        Object[] result = test62(va, oa);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(oa[i], result[i]);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = va;\n+        } else {\n+            arr = oa;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test63(MyValue1.ref[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test63_helper(i, va, oa);\n+\n+        return Arrays.copyOf(arr, arr.length+1, arr.getClass());\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1.ref[] verif = new MyValue1.ref[len+1];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = va[i];\n+        }\n+        Integer[] oa = new Integer[len];\n+        test63_helper(42, va, oa);\n+        Object[] result = test63(va, oa);\n+        verify(verif, result);\n+    }\n+\n+    \/\/ Test default initialization of inline type arrays: small array\n+    @Test\n+    public MyValue1.ref[] test64() {\n+        return new MyValue1.ref[8];\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1.ref[] va = test64();\n+        for (int i = 0; i < 8; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Test default initialization of inline type arrays: large array\n+    @Test\n+    public MyValue1.ref[] test65() {\n+        return new MyValue1.ref[32];\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        MyValue1.ref[] va = test65();\n+        for (int i = 0; i < 32; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Check init store elimination\n+    @Test\n+    @IR(counts = {ALLOCA, \"= 1\"})\n+    public MyValue1.ref[] test66(MyValue1.ref vt) {\n+        MyValue1.ref[] va = new MyValue1.ref[1];\n+        va[0] = vt;\n+        return va;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1.ref[] va = test66(vt);\n+        Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());\n+    }\n+\n+    \/\/ Zeroing elimination and arraycopy\n+    @Test\n+    public MyValue1.ref[] test67(MyValue1.ref[] src) {\n+        MyValue1.ref[] dst = new MyValue1.ref[16];\n+        System.arraycopy(src, 0, dst, 0, 13);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1.ref[] va = new MyValue1.ref[16];\n+        MyValue1.ref[] var = test67(va);\n+        for (int i = 0; i < 16; ++i) {\n+            Asserts.assertEQ(var[i], null);\n+        }\n+    }\n+\n+    \/\/ A store with a default value can be eliminated\n+    @Test\n+    public MyValue1.ref[] test68() {\n+        MyValue1.ref[] va = new MyValue1.ref[2];\n+        va[0] = va[1];\n+        return va;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        MyValue1.ref[] va = test68();\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Requires individual stores to init array\n+    @Test\n+    public MyValue1.ref[] test69(MyValue1.ref vt) {\n+        MyValue1.ref[] va = new MyValue1.ref[4];\n+        va[0] = vt;\n+        va[3] = vt;\n+        return va;\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1.ref[] va = new MyValue1.ref[4];\n+        va[0] = vt;\n+        va[3] = vt;\n+        MyValue1.ref[] var = test69(vt);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(va[i], var[i]);\n+        }\n+    }\n+\n+    \/\/ A store with a default value can be eliminated: same as test68\n+    \/\/ but store is farther away from allocation\n+    @Test\n+    public MyValue1.ref[] test70(MyValue1.ref[] other) {\n+        other[1] = other[0];\n+        MyValue1.ref[] va = new MyValue1.ref[2];\n+        other[0] = va[1];\n+        va[0] = va[1];\n+        return va;\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        MyValue1.ref[] va = new MyValue1.ref[2];\n+        MyValue1.ref[] var = test70(va);\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(va[i], var[i]);\n+        }\n+    }\n+\n+    \/\/ EA needs to consider oop fields in flattened arrays\n+    @Test\n+    public void test71() {\n+        int len = 10;\n+        MyValue2.ref[] src = new MyValue2.ref[len];\n+        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);\n+        }\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+        for (int i = 0; i < len; ++i) {\n+            if (src[i] == null) {\n+                Asserts.assertEQ(dst[i], null);\n+            } else {\n+                Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        test71();\n+    }\n+\n+    \/\/ Test EA with leaf call to 'store_unknown_value'\n+    @Test\n+    public void test72(Object[] o, boolean b, Object element) {\n+        Object[] arr1 = new Object[10];\n+        Object[] arr2 = new Object[10];\n+        if (b) {\n+            arr1 = o;\n+        }\n+        arr1[0] = element;\n+        arr2[0] = element;\n+    }\n+\n+    @Run(test = \"test72\")\n+    public void test72_verifier() {\n+        Object[] arr = new Object[1];\n+        Object elem = new Object();\n+        test72(arr, true, elem);\n+        test72(arr, false, elem);\n+    }\n+\n+    @Test\n+    public void test73(Object[] oa, MyValue1.ref v, Object o) {\n+        \/\/ TestLWorld.test38 use a C1 Phi node for the array. This test\n+        \/\/ adds the case where the stored value is a C1 Phi node.\n+        Object o2 = (o == null) ? v : o;\n+        oa[0] = v;  \/\/ The stored value is known to be flattenable\n+        oa[1] = o;  \/\/ The stored value may be flattenable\n+        oa[2] = o2; \/\/ The stored value may be flattenable (a C1 Phi node)\n+        oa[0] = oa; \/\/ The stored value is known to be not flattenable (an Object[])\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);\n+        MyValue1.ref[] arr = new MyValue1.ref[3];\n+        try {\n+            test73(arr, v0, v1);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException t) {\n+            \/\/ expected\n+        }\n+        Asserts.assertEQ(arr[0].hash(), v0.hash());\n+        Asserts.assertEQ(arr[1].hash(), v1.hash());\n+        Asserts.assertEQ(arr[2].hash(), v1.hash());\n+    }\n+\n+    \/\/ Some more array clone tests\n+    @ForceInline\n+    public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = oa;\n+        } else {\n+            arr = va;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test74(MyValue1.ref[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test74_helper(i, va, oa);\n+        return arr.clone();\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        Integer[] oa = new Integer[len];\n+        for (int i = 1; i < len; ++i) {\n+            oa[i] = Integer.valueOf(rI);\n+        }\n+        test74_helper(42, va, oa);\n+        Object[] result = test74(va, oa);\n+\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(oa[i], result[i]);\n+            \/\/ Check that array has correct properties (null-ok)\n+            result[i] = null;\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = va;\n+        } else {\n+            arr = oa;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test75(MyValue1.ref[] va, Integer[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test75_helper(i, va, oa);\n+        return arr.clone();\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1.ref[] verif = new MyValue1.ref[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = va[i];\n+        }\n+        Integer[] oa = new Integer[len];\n+        test75_helper(42, va, oa);\n+        Object[] result = test75(va, oa);\n+        verify(verif, result);\n+        if (len > 0) {\n+            \/\/ Check that array has correct properties (null-ok)\n+            result[0] = null;\n+        }\n+    }\n+\n+    \/\/ Test mixing nullable and non-nullable arrays\n+    @Test\n+    public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {\n+        Object[] result = null;\n+        if (n == 0) {\n+            result = vva;\n+        } else if (n == 1) {\n+            result = vba;\n+        } else if (n == 2) {\n+            result = new MyValue1[42];\n+        } else if (n == 3) {\n+            result = new MyValue1.ref[42];\n+        }\n+        result[0] = vt;\n+        out[0] = result[1];\n+        return result;\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() {\n+        MyValue1 vt = testValue1;\n+        Object[] out = new Object[1];\n+        MyValue1[] vva = new MyValue1[42];\n+        MyValue1[] vva_r = new MyValue1[42];\n+        vva_r[0] = vt;\n+        MyValue1.ref[] vba = new MyValue1.ref[42];\n+        MyValue1.ref[] vba_r = new MyValue1.ref[42];\n+        vba_r[0] = vt;\n+        Object[] result = test76(vva, vba, vt, out, 0);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test76(vva, vba, vt, out, 1);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+        result = test76(vva, vba, vt, out, 2);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test76(vva, vba, vt, out, 3);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+    }\n+\n+    @Test\n+    public Object[] test77(boolean b) {\n+        Object[] va;\n+        if (b) {\n+            va = new MyValue1.ref[5];\n+            for (int i = 0; i < 5; ++i) {\n+                va[i] = testValue1;\n+            }\n+        } else {\n+            va = new MyValue1[10];\n+            for (int i = 0; i < 10; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);\n+            }\n+        }\n+        long sum = ((MyValue1)va[0]).hashInterpreted();\n+        if (b) {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI, sum);\n+        } else {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() {\n+        Object[] va = test77(true);\n+        Asserts.assertEQ(va.length, 5);\n+        Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));\n+        for (int i = 1; i < 5; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());\n+        }\n+        va = test77(false);\n+        Asserts.assertEQ(va.length, 10);\n+        Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));\n+        for (int i = 1; i < 10; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));\n+        }\n+    }\n+\n+    \/\/ Same as test76 but with non inline type array cases\n+    @Test\n+    public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {\n+        Object[] result = null;\n+        if (n == 0) {\n+            result = vva;\n+        } else if (n == 1) {\n+            result = vba;\n+        } else if (n == 2) {\n+            result = new MyValue1[42];\n+        } else if (n == 3) {\n+            result = new MyValue1.ref[42];\n+        } else if (n == 4) {\n+            result = new Integer[42];\n+        }\n+        result[0] = val;\n+        out[0] = result[1];\n+        return result;\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        MyValue1 vt = testValue1;\n+        Integer i = Integer.valueOf(42);\n+        Object[] out = new Object[1];\n+        MyValue1[] vva = new MyValue1[42];\n+        MyValue1[] vva_r = new MyValue1[42];\n+        vva_r[0] = vt;\n+        MyValue1.ref[] vba = new MyValue1.ref[42];\n+        MyValue1.ref[] vba_r = new MyValue1.ref[42];\n+        vba_r[0] = vt;\n+        Object[] result = test78(vva, vba, vt, out, 0);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test78(vva, vba, vt, out, 1);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+        result = test78(vva, vba, vt, out, 2);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test78(vva, vba, vt, out, 3);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+        result = test78(vva, vba, i, out, 4);\n+        Asserts.assertEQ(result[0], i);\n+        Asserts.assertEQ(out[0], null);\n+    }\n+\n+    \/\/ Test widening conversions from [Q to [L\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public static MyValue1.ref[] test79(MyValue1[] va) {\n+        return va;\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = testValue1;\n+        MyValue1.ref[] res = test79(va);\n+        Asserts.assertEquals(res[0].hash(), testValue1.hash());\n+        try {\n+            res[0] = null;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        res[0] = testValue1;\n+        test79(null); \/\/ Should not throw NPE\n+    }\n+\n+    \/\/ Same as test79 but with explicit cast and Object return\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public static Object[] test80(MyValue1[] va) {\n+        return (MyValue1.ref[])va;\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = testValue1;\n+        Object[] res = test80(va);\n+        Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());\n+        try {\n+            res[0] = null;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        res[0] = testValue1;\n+        test80(null); \/\/ Should not throw NPE\n+    }\n+\n+    \/\/ Test mixing widened and boxed array type\n+    @Test\n+    public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {\n+        MyValue1.ref[] result = b ? va1 : va2;\n+        try {\n+            result[0] = vt;\n+        } catch (NullPointerException npe) {\n+            \/\/ Ignored\n+        }\n+        return result[1].hash();\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1.ref[] vaB = new MyValue1.ref[2];\n+        va[1] = testValue1;\n+        vaB[1] = testValue1;\n+        long res = test81(va, vaB, testValue1, true, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test81(va, vaB, testValue1, false, false);\n+        Asserts.assertEquals(vaB[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test81(va, va, testValue1, false, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+    }\n+\n+    \/\/ Same as test81 but more cases and null writes\n+    @Test\n+    public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {\n+        MyValue1.ref[] result = null;\n+        if (i == 0) {\n+            result = va1;\n+        } else if (i == 1) {\n+            result = va2;\n+        } else if (i == 2) {\n+            result = new MyValue1.ref[2];\n+            result[1] = vt1;\n+        } else if (i == 3) {\n+            result = new MyValue1[2];\n+            result[1] = vt1;\n+        }\n+        try {\n+            result[0] = (i <= 1) ? null : vt2;\n+            if (shouldThrow) {\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            }\n+        } catch (NullPointerException npe) {\n+            Asserts.assertTrue(shouldThrow, \"NullPointerException thrown\");\n+        }\n+        result[0] = vt1;\n+        return result[1].hash();\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1.ref[] vaB = new MyValue1.ref[2];\n+        va[1] = testValue1;\n+        vaB[1] = testValue1;\n+        long res = test82(va, vaB, testValue1, testValue1, 0, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, vaB, testValue1, testValue1, 1, false);\n+        Asserts.assertEquals(vaB[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, va, testValue1, testValue1, 1, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, va, testValue1, null, 2, false);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, va, testValue1, null, 3, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, STORE})\n+    public static long test83(MyValue1[] va) {\n+        MyValue1.ref[] result = va;\n+        return result[0].hash();\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier() {\n+        MyValue1[] va = new MyValue1[42];\n+        va[0] = testValue1;\n+        long res = test83(va);\n+        Asserts.assertEquals(res, testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, LOOP, STORE, TRAP})\n+    public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {\n+        MyValue1.ref[] result = new MyValue1[2];\n+        result[0] = vt1;\n+        result[1] = vt2;\n+        return result;\n+    }\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        MyValue1.ref[] res = test84(testValue1, testValue1);\n+        Asserts.assertEquals(res[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res[1].hash(), testValue1.hash());\n+        try {\n+            test84(testValue1, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public static long test85(MyValue1.ref[] va, MyValue1 val) {\n+        va[0] = val;\n+        return va[1].hash();\n+    }\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        va[1] = testValue1;\n+        vab[1] = testValue1;\n+        long res = test85(va, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        res = test85(vab, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(vab[0].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Same as test85 but with ref value\n+    @Test\n+    public static long test86(MyValue1.ref[] va, MyValue1.ref val) {\n+        va[0] = val;\n+        return va[1].hash();\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        va[1] = testValue1;\n+        vab[1] = testValue1;\n+        long res = test86(va, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        try {\n+            test86(va, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        res = test86(vab, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(vab[0].hash(), testValue1.hash());\n+        res = test86(vab, null);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(vab[0], null);\n+    }\n+\n+    \/\/ Test initialization of nullable array with constant\n+    @Test\n+    public long test87() {\n+        MyValue1.ref[] va = new MyValue1.ref[1];\n+        va[0] = testValue1;\n+        return va[0].hash();\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier() {\n+        long result = test87();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Test narrowing conversion from [L to [Q\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public static MyValue1[] test88(MyValue1.ref[] va) {\n+        return (MyValue1[])va;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = testValue1;\n+        MyValue1[] res = test88(va);\n+        Asserts.assertEquals(res[0].hash(), testValue1.hash());\n+        res[0] = testValue1;\n+        test88(null); \/\/ Should not throw NPE\n+        try {\n+            test88(new MyValue1.ref[1]);\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException cce) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test88 but with explicit cast and Object argument\n+    @Test\n+    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    public static MyValue1[] test89(Object[] va) {\n+        return (MyValue1[])va;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = testValue1;\n+        MyValue1[] res = test89(va);\n+        Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());\n+        res[0] = testValue1;\n+        test89(null); \/\/ Should not throw NPE\n+        try {\n+            test89(new MyValue1.ref[1]);\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException cce) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ More cast tests\n+    @Test\n+    public static MyValue1.ref[] test90(Object va) {\n+        return (MyValue1.ref[])va;\n+    }\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        MyValue1.ref[] vab = new MyValue1.ref[1];\n+        try {\n+          \/\/ Trigger some ClassCastExceptions so C2 does not add an uncommon trap\n+          test90(new Integer[0]);\n+        } catch (ClassCastException cce) {\n+          \/\/ Expected\n+        }\n+        test90(va);\n+        test90(vab);\n+        test90(null);\n+    }\n+\n+    @Test\n+    public static MyValue1.ref[] test91(Object[] va) {\n+        return (MyValue1.ref[])va;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        MyValue1.ref[] vab = new MyValue1.ref[1];\n+        try {\n+          \/\/ Trigger some ClassCastExceptions so C2 does not add an uncommon trap\n+          test91(new Integer[0]);\n+        } catch (ClassCastException cce) {\n+          \/\/ Expected\n+        }\n+        test91(va);\n+        test91(vab);\n+        test91(null);\n+    }\n+\n+    \/\/ Test if arraycopy intrinsic correctly checks for flattened source array\n+    @Test\n+    public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 2);\n+    }\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier() {\n+        MyValue1[]  va = new MyValue1[2];\n+        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        va[0] = testValue1;\n+        vab[0] = testValue1;\n+        test92(va, vab);\n+        Asserts.assertEquals(va[0], vab[0]);\n+        Asserts.assertEquals(va[1], vab[1]);\n+    }\n+\n+    @Test\n+    public static void test93(Object src, MyValue1.ref[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 2);\n+    }\n+\n+    @Run(test = \"test93\")\n+    public void test93_verifier() {\n+        MyValue1[]  va = new MyValue1[2];\n+        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        va[0] = testValue1;\n+        vab[0] = testValue1;\n+        test93(va, vab);\n+        Asserts.assertEquals(va[0], vab[0]);\n+        Asserts.assertEquals(va[1], vab[1]);\n+    }\n+\n+    \/\/ Test non-escaping allocation with arraycopy\n+    \/\/ that does not modify loaded array element.\n+    @Test\n+    public static long test94() {\n+        MyValue1.ref[] src = new MyValue1.ref[8];\n+        MyValue1[]  dst = new MyValue1[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = testValue1;\n+        }\n+        System.arraycopy(src, 1, dst, 2, 6);\n+        return dst[0].hash();\n+    }\n+\n+    @Run(test = \"test94\")\n+    public static void test94_verifier() {\n+        long result = test94();\n+        Asserts.assertEquals(result, MyValue1.default.hash());\n+    }\n+\n+    \/\/ Test meeting constant TypeInstPtr with InlineTypeNode\n+    @ForceInline\n+    public long test95_callee() {\n+        MyValue1.ref[] va = new MyValue1.ref[1];\n+        va[0] = testValue1;\n+        return va[0].hashInterpreted();\n+    }\n+\n+    @Test\n+    public long test95() {\n+        return test95_callee();\n+    }\n+\n+    @Run(test = \"test95\")\n+    @Warmup(0)\n+    public void test95_verifier() {\n+        long result = test95();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Matrix multiplication test to exercise type flow analysis with nullable inline type arrays\n+    primitive static class Complex {\n+        private final double re;\n+        private final double im;\n+\n+        Complex(double re, double im) {\n+            this.re = re;\n+            this.im = im;\n+        }\n+\n+        public Complex add(Complex that) {\n+            return new Complex(this.re + that.re, this.im + that.im);\n+        }\n+\n+        public Complex mul(Complex that) {\n+            return new Complex(this.re * that.re - this.im * that.im,\n+                               this.re * that.im + this.im * that.re);\n+        }\n+    }\n+\n+    @Test\n+    public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {\n+        int size = A.length;\n+        Complex.ref[][] R = new Complex.ref[size][size];\n+        for (int i = 0; i < size; i++) {\n+            for (int k = 0; k < size; k++) {\n+                Complex.ref aik = A[i][k];\n+                for (int j = 0; j < size; j++) {\n+                    R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));\n+                }\n+            }\n+        }\n+        return R;\n+    }\n+\n+    static Complex.ref[][] test96_A = new Complex.ref[10][10];\n+    static Complex.ref[][] test96_B = new Complex.ref[10][10];\n+    static Complex.ref[][] test96_R;\n+\n+    static {\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                test96_A[i][j] = new Complex(rI, rI);\n+                test96_B[i][j] = new Complex(rI, rI);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        Complex.ref[][] result = test96(test96_A, test96_B);\n+        if (test96_R == null) {\n+            test96_R = result;\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                Asserts.assertEQ(result[i][j], test96_R[i][j]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test loads from vararg arrays\n+    @Test\n+    @IR(failOn = {LOAD_UNKNOWN_INLINE})\n+    public static Object test97(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test97\")\n+    public static void test97_verifier() {\n+        Object obj = new Object();\n+        Object result = test97(obj);\n+        Asserts.assertEquals(result, obj);\n+        Integer[] myInt = new Integer[1];\n+        myInt[0] = rI;\n+        result = test97((Object[])myInt);\n+        Asserts.assertEquals(result, rI);\n+    }\n+\n+    @Test\n+    public static Object test98(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test98\")\n+    public static void test98_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        Object result = test98(obj);\n+        Asserts.assertEquals(result, obj);\n+        Integer[] myInt = new Integer[1];\n+        myInt[0] = rI;\n+        result = test98((Object[])myInt);\n+        Asserts.assertEquals(result, rI);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = new MyValue1[1];\n+            MyValue1.ref[] vab = new MyValue1.ref[1];\n+            result = test98((Object[])va);\n+            Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());\n+            result = test98((Object[])vab);\n+            Asserts.assertEquals(result, null);\n+        }\n+    }\n+\n+    @Test\n+    public static Object test99(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test99\")\n+    public static void test99_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        Object result = test99(obj);\n+        Asserts.assertEquals(result, obj);\n+        Integer[] myInt = new Integer[1];\n+        myInt[0] = rI;\n+        result = test99((Object[])myInt);\n+        Asserts.assertEquals(result, rI);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test99((Object[])null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static Object test100(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test100\")\n+    public static void test100_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        Object result = test100(obj);\n+        Asserts.assertEquals(result, obj);\n+        Integer[] myInt = new Integer[1];\n+        myInt[0] = rI;\n+        result = test100((Object[])myInt);\n+        Asserts.assertEquals(result, rI);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test100();\n+                throw new RuntimeException(\"No AIOOBE thrown\");\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Test stores to varag arrays\n+    @Test\n+    @IR(failOn = STORE_UNKNOWN_INLINE)\n+    public static void test101(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test101\")\n+    public static void test101_verifier() {\n+        Object obj = new Object();\n+        test101(obj, obj);\n+        Integer[] myInt = new Integer[1];\n+        test101(rI, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], rI);\n+        test101(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+    }\n+\n+    @Test\n+    public static void test102(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public static void test102_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test102(obj, obj);\n+        Integer[] myInt = new Integer[1];\n+        test102(rI, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], rI);\n+        test102(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = new MyValue1[1];\n+            MyValue1.ref[] vab = new MyValue1.ref[1];\n+            test102(testValue1, (Object[])va);\n+            Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+            test102(testValue1, (Object[])vab);\n+            Asserts.assertEquals(vab[0].hash(), testValue1.hash());\n+            test102(null, (Object[])vab);\n+            Asserts.assertEquals(vab[0], null);\n+        }\n+    }\n+\n+    @Test\n+    public static void test103(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test103\")\n+    public static void test103_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test103(obj, obj);\n+        Integer[] myInt = new Integer[1];\n+        test103(rI, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], rI);\n+        test103(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = new MyValue1[1];\n+            try {\n+                test103(null, (Object[])va);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static void test104(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test104\")\n+    public static void test104_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test104(obj, obj);\n+        Integer[] myInt = new Integer[1];\n+        test104(rI, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], rI);\n+        test104(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test104(testValue1);\n+                throw new RuntimeException(\"No AIOOBE thrown\");\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static void test105(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test105\")\n+    public static void test105_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test105(obj, obj);\n+        Integer[] myInt = new Integer[1];\n+        test105(rI, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], rI);\n+        test105(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test105(testValue1, (Object[])null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static Object[] test106(Object[] dst, Object... args) {\n+        \/\/ Access array to speculate on non-flatness\n+        if (args[0] == null) {\n+            args[0] = testValue1;\n+        }\n+        System.arraycopy(args, 0, dst, 0, args.length);\n+        System.arraycopy(dst, 0, args, 0, dst.length);\n+        Object[] clone = args.clone();\n+        if (clone[0] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+        return Arrays.copyOf(args, args.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test106\")\n+    public static void test106_verifier(RunInfo info) {\n+        Object[] dst = new Object[1];\n+        Object obj = new Object();\n+        Object[] result = test106(dst, obj);\n+        Asserts.assertEquals(result[0], obj);\n+        Integer[] myInt = new Integer[1];\n+        myInt[0] = rI;\n+        result = test106(myInt, (Object[])myInt);\n+        Asserts.assertEquals(result[0], rI);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = new MyValue1[1];\n+            MyValue1.ref[] vab = new MyValue1.ref[1];\n+            result = test106(va, (Object[])va);\n+            Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());\n+            result = test106(vab, (Object[])vab);\n+            Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    \/\/ Test that allocation is not replaced by non-dominating allocation\n+    @ForceInline\n+    public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {\n+        try {\n+            va[0] = vt;\n+        } catch (NullPointerException npe) { }\n+        return va[1].hash();\n+    }\n+\n+    @Test\n+    public void test107() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1.ref[] tmp = new MyValue1.ref[2];\n+        long res1 = test107_helper(va, testValue1);\n+        long res2 = test107_helper(va, testValue1);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res1, MyValue1.default.hash());\n+        Asserts.assertEquals(res2, MyValue1.default.hash());\n+    }\n+\n+    @Run(test = \"test107\")\n+    public void test107_verifier() {\n+        test107();\n+    }\n+\n+    @Test\n+    public Object test108(MyValue1.ref[] src, boolean flag) {\n+        MyValue1.ref[] dst = new MyValue1.ref[8];\n+        System.arraycopy(src, 1, dst, 2, 6);\n+        if (flag) {} \/\/ uncommon trap\n+        return dst[2];\n+    }\n+\n+    @Run(test = \"test108\")\n+    @Warmup(10000)\n+    public void test108_verifier(RunInfo info) {\n+        MyValue1.ref[] src = new MyValue1.ref[8];\n+        test108(src, !info.isWarmUp());\n+    }\n+\n+    \/\/ Test LoadNode::can_see_arraycopy_value optimization\n+    @Test\n+    public static void test109() {\n+        MyValue1[] src = new MyValue1[1];\n+        MyValue1.ref[] dst = new MyValue1.ref[1];\n+        src[0] = testValue1;\n+        System.arraycopy(src, 0, dst, 0, 1);\n+        Asserts.assertEquals(src[0], dst[0]);\n+    }\n+\n+    @Run(test = \"test109\")\n+    public void test109_verifier() {\n+        test109();\n+    }\n+\n+    \/\/ Same as test109 but with Object destination array\n+    @Test\n+    public static void test110() {\n+        MyValue1[] src = new MyValue1[1];\n+        Object[] dst = new Object[1];\n+        src[0] = testValue1;\n+        System.arraycopy(src, 0, dst, 0, 1);\n+        Asserts.assertEquals(src[0], dst[0]);\n+    }\n+\n+    @Run(test = \"test110\")\n+    public void test110_verifier() {\n+        test110();\n+    }\n+\n+    \/\/ Same as test109 but with Arrays.copyOf\n+    @Test\n+    public static void test111() {\n+        MyValue1[] src = new MyValue1[1];\n+        src[0] = testValue1;\n+        MyValue1.ref[] dst = Arrays.copyOf(src, src.length, MyValue1.ref[].class);\n+        Asserts.assertEquals(src[0], dst[0]);\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        test111();\n+    }\n+\n+    MyValue1.ref[] refArray = new MyValue1.ref[2];\n+    MyValue1[] flatArray = new MyValue1[1];\n+\n+    \/\/ Test scalarization of .ref\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public int test112(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test112(true), refArray[0].x);\n+        Asserts.assertEquals(test112(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test112(false), testValue1.x);\n+                test112(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test112 but with call to hash()\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test113(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test113\")\n+    public void test113_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test113(true), refArray[0].hash());\n+        Asserts.assertEquals(test113(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test113(false), testValue1.hash());\n+                test113(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test114(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test114\")\n+    public void test114_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test114(true).hash(), refArray[0].hash());\n+        Asserts.assertEquals(test114(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            Asserts.assertEquals(test114(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test115(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refArray[0];\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test115\")\n+    public void test115_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test115(true, false, info.getTest()), refArray[0].x);\n+        Asserts.assertEquals(test115(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test115(false, false, info.getTest()), testValue1.x);\n+                test115(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test115(true, true, info.getTest()), refArray[0].x);\n+            Asserts.assertEquals(test115(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test116(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refArray[0];\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test116(true, false, info.getTest()).hash(), refArray[0].hash());\n+        Asserts.assertEquals(test116(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            Asserts.assertEquals(test116(true, false, info.getTest()), null);\n+            refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test116(true, true, info.getTest()).hash(), refArray[0].hash());\n+            Asserts.assertEquals(test116(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test117(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test117(true), testValue1.x);\n+        try {\n+            test117(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test118(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test118(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test118(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test119(boolean b) {\n+        MyValue1.ref val = refArray[0];\n+        if (b) {\n+            val = null;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test119(false), testValue1.x);\n+        try {\n+            test119(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test120(boolean b) {\n+        MyValue1.ref val = refArray[0];\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test120(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test120(true), null);\n+    }\n+\n+    @ForceInline\n+    public Object test121_helper() {\n+        return flatArray[0];\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G, STORE})\n+    public void test121(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = refArray[0];\n+        } else {\n+            o = test121_helper();\n+        }\n+        flatArray[0] = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        refArray[0] = testValue1;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatArray[0] = vt;\n+        test121(false);\n+        Asserts.assertEquals(flatArray[0].hash(), vt.hash());\n+        test121(true);\n+        Asserts.assertEquals(flatArray[0].hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test122_helper() {\n+        return refArray[0];\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G, STORE})\n+    public void test122(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = flatArray[0];\n+        } else {\n+            o = test122_helper();\n+        }\n+        flatArray[0] = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        refArray[0] = testValue1;\n+        test122(false);\n+        Asserts.assertEquals(flatArray[0].hash(), testValue1.hash());\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatArray[0] = vt;\n+        test122(true);\n+        Asserts.assertEquals(flatArray[0].hash(), vt.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test123_helper() {\n+        return refArray[0];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test123(boolean b, MyValue1.ref val, Method m, boolean deopt) {\n+        MyValue1.ref[] array = new MyValue1.ref[1];\n+        array[0] = val;\n+        Object res = null;\n+        if (b) {\n+            res = array[0];\n+        } else {\n+            res = test123_helper();\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)res).hash();\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.default;\n+        Asserts.assertEquals(test123(true, testValue1, info.getTest(), false), testValue1.hash());\n+        Asserts.assertEquals(test123(false, testValue1, info.getTest(), false), MyValue1.default.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test123(true, testValue1, info.getTest(), true), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test124_helper(MyValue2.ref val) {\n+        MyValue2.ref[] array = new MyValue2.ref[1];\n+        array[0] = val;\n+        return array[0];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test124(boolean b, MyValue2.ref val, Method m, boolean deopt) {\n+        Object res = null;\n+        if (b) {\n+            res = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        } else {\n+            res = test124_helper(val);\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue2)res).hash();\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.default;\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        Asserts.assertEquals(test124(true, val1, info.getTest(), false), val2.hash());\n+        Asserts.assertEquals(test124(false, val1, info.getTest(), false), val1.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test124(true, val1, info.getTest(), true), val2.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test125_helper(Object[] array, MyValue2.ref val) {\n+        array[0] = val;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test125(boolean b, MyValue2.ref val, Method m, boolean deopt) {\n+        Object[] res = new MyValue2.ref[1];\n+        if (b) {\n+            res[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        } else {\n+            test125_helper(res, val);\n+        }\n+        val = ((MyValue2)res[0]);\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test125\")\n+    public void test125_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.default;\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        Asserts.assertEquals(test125(true, val1, info.getTest(), false), val2.hash());\n+        Asserts.assertEquals(test125(false, val1, info.getTest(), false), val1.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test125(true, val1, info.getTest(), true), val2.hash());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":3273,"deletions":0,"binary":false,"changes":3273,"status":"added"},{"patch":"@@ -0,0 +1,2739 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.experimental.bytecode.TypeTag;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import jdk.internal.value.PrimitiveClass;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable inline types.\n+ * @modules java.base\/jdk.internal.value\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile -XDenablePrimitiveClasses TestNullableInlineTypes.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestNullableInlineTypes\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestNullableInlineTypes {\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+        try {\n+            Class<?> clazz = TestNullableInlineTypes.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType test18_mt = MethodType.methodType(void.class, MyValue1.ref.class);\n+            test18_mh1 = lookup.findStatic(clazz, \"test18_target1\", test18_mt);\n+            test18_mh2 = lookup.findStatic(clazz, \"test18_target2\", test18_mt);\n+\n+            MethodType test19_mt = MethodType.methodType(void.class, MyValue1.ref.class);\n+            test19_mh1 = lookup.findStatic(clazz, \"test19_target1\", test19_mt);\n+            test19_mh2 = lookup.findStatic(clazz, \"test19_target2\", test19_mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,\n+                                                                      testValue1,\n+                                                                      testValue1};\n+\n+    MyValue1.ref nullField;\n+    MyValue1 valueField1 = testValue1;\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test1(MyValue1.ref vt) {\n+        long result = 0;\n+        try {\n+            result = vt.hash();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        long result = test1(null);\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test2(MyValue1.ref vt) {\n+        long result = 0;\n+        try {\n+            result = vt.hashInterpreted();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        long result = test2(nullField);\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test3() {\n+        long result = 0;\n+        try {\n+            if ((Object)nullField != null) {\n+                throw new RuntimeException(\"nullField should be null\");\n+            }\n+            result = nullField.hash();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        long result = test3();\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test4() {\n+        try {\n+            valueField1 = (MyValue1) nullField;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        test4();\n+    }\n+\n+    @Test\n+    \/\/ TODO 8284443 When passing vt to test5_inline and incrementally inlining, we lose the oop\n+    @IR(applyIfOr = {\"InlineTypePassFieldsAsArgs\", \"false\", \"AlwaysIncrementalInline\", \"false\"},\n+        failOn = {ALLOC})\n+    public MyValue1.ref test5(MyValue1.ref vt) {\n+        try {\n+            Object o = vt;\n+            vt = (MyValue1)o;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        \/\/ Should not throw\n+        vt = test5_dontinline(vt);\n+        vt = test5_inline(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1.ref vt = test5(nullField);\n+        Asserts.assertEquals(vt, null);\n+    }\n+\n+    @DontInline\n+    public MyValue1.ref test5_dontinline(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test5_inline(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test6(Object obj) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1 vt = test6(null);\n+        Asserts.assertEquals(vt.hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref getNullInline() {\n+        return null;\n+    }\n+\n+    @DontInline\n+    public MyValue1.ref getNullDontInline() {\n+        return null;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test7() {\n+        nullField = getNullInline();     \/\/ Should not throw\n+        nullField = getNullDontInline(); \/\/ Should not throw\n+        try {\n+            valueField1 = (MyValue1) getNullInline();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            valueField1 = (MyValue1) getNullDontInline();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        test7();\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test8() {\n+        try {\n+            valueField1 = (MyValue1) nullField;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        test8();\n+    }\n+\n+    \/\/ merge of 2 inline types, one being null\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test9(boolean flag) {\n+        MyValue1 v;\n+        if (flag) {\n+            v = valueField1;\n+        } else {\n+            v = (MyValue1) nullField;\n+        }\n+        valueField1 = v;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9(true);\n+        try {\n+            test9(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ null constant\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test10(boolean flag) {\n+        MyValue1.ref val = flag ? valueField1 : null;\n+        valueField1 = (MyValue1) val;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        test10(true);\n+        try {\n+            test10(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ null constant\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test11(boolean flag) {\n+        MyValue1.ref val = flag ? null : valueField1;\n+        valueField1 = (MyValue1) val;\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        test11(false);\n+        try {\n+            test11(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ null return\n+    int test12_cnt;\n+\n+    @DontInline\n+    public MyValue1.ref test12_helper() {\n+        test12_cnt++;\n+        return nullField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test12() {\n+        valueField1 = (MyValue1) test12_helper();\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        try {\n+            test12_cnt = 0;\n+            test12();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (test12_cnt != 1) {\n+            throw new RuntimeException(\"call executed twice\");\n+        }\n+    }\n+\n+    \/\/ null return at virtual call\n+    class A {\n+        public MyValue1.ref test13_helper() {\n+            return nullField;\n+        }\n+    }\n+\n+    class B extends A {\n+        public MyValue1 test13_helper() {\n+            return (MyValue1) nullField;\n+        }\n+    }\n+\n+    class C extends A {\n+        public MyValue1.ref test13_helper() {\n+            return nullField;\n+        }\n+    }\n+\n+    class D extends C {\n+        public MyValue1 test13_helper() {\n+            return (MyValue1) nullField;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test13(A a) {\n+        valueField1 = (MyValue1) a.test13_helper();\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        A a = new A();\n+        A b = new B();\n+        A c = new C();\n+        A d = new D();\n+        try {\n+            test13(a);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test13(b);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test13(c);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test13(d);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test writing null to a (flattened) inline type array\n+    @ForceInline\n+    public void test14_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test14(MyValue1[] va, int index) {\n+        test14_inline(va, nullField, index);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test14(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), testValue1.hash());\n+    }\n+\n+    @DontInline\n+    MyValue1.ref getNullField1() {\n+        return nullField;\n+    }\n+\n+    @DontInline\n+    MyValue1 getNullField2() {\n+        return (MyValue1) nullField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test15() {\n+        nullField = getNullField1(); \/\/ should not throw\n+        try {\n+            valueField1 = (MyValue1) getNullField1();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            valueField1 = getNullField2();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        test15();\n+    }\n+\n+    @DontInline\n+    public boolean test16_dontinline(MyValue1.ref vt) {\n+        return vt == null;\n+    }\n+\n+    \/\/ Test c2c call passing null for an inline type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test16(Object arg) throws Exception {\n+        Method test16method = getClass().getMethod(\"test16_dontinline\", MyValue1.ref.class);\n+        return (boolean)test16method.invoke(this, arg);\n+    }\n+\n+    @Run(test = \"test16\")\n+    @Warmup(10000) \/\/ Warmup to make sure 'test17_dontinline' is compiled\n+    public void test16_verifier() throws Exception {\n+        boolean res = test16(null);\n+        Asserts.assertTrue(res);\n+    }\n+\n+    \/\/ Test scalarization of default inline type with non-flattenable field\n+    final primitive class Test17Value {\n+        public final MyValue1.ref valueField;\n+\n+        @ForceInline\n+        public Test17Value(MyValue1.ref valueField) {\n+            this.valueField = valueField;\n+        }\n+    }\n+\n+    @Test\n+    \/\/ TODO 8284443 When passing testValue1 to the constructor in scalarized form and incrementally inlining, we lose the oop\n+    @IR(applyIfOr = {\"InlineTypePassFieldsAsArgs\", \"false\", \"AlwaysIncrementalInline\", \"false\"},\n+        failOn = {ALLOC})\n+    public Test17Value test17(boolean b) {\n+        Test17Value vt1 = Test17Value.default;\n+        Test17Value vt2 = new Test17Value(testValue1);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        test17(true);\n+        test17(false);\n+    }\n+\n+    static final MethodHandle test18_mh1;\n+    static final MethodHandle test18_mh2;\n+\n+    static MyValue1.ref nullValue;\n+\n+    @DontInline\n+    static void test18_target1(MyValue1.ref vt) {\n+        nullValue = vt;\n+    }\n+\n+    @ForceInline\n+    static void test18_target2(MyValue1.ref vt) {\n+        nullValue = vt;\n+    }\n+\n+    \/\/ Test passing null for an inline type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test18() throws Throwable {\n+        test18_mh1.invokeExact(nullValue);\n+        test18_mh2.invokeExact(nullValue);\n+    }\n+\n+    @Run(test = \"test18\")\n+    @Warmup(11000) \/\/ Make sure lambda forms get compiled\n+    public void test18_verifier() {\n+        try {\n+            test18();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"test18 failed\", t);\n+        }\n+    }\n+\n+    static MethodHandle test19_mh1;\n+    static MethodHandle test19_mh2;\n+\n+    @DontInline\n+    static void test19_target1(MyValue1.ref vt) {\n+        nullValue = vt;\n+    }\n+\n+    @ForceInline\n+    static void test19_target2(MyValue1.ref vt) {\n+        nullValue = vt;\n+    }\n+\n+    \/\/ Same as test12 but with non-final mh\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test19() throws Throwable {\n+        test19_mh1.invokeExact(nullValue);\n+        test19_mh2.invokeExact(nullValue);\n+    }\n+\n+    @Run(test = \"test19\")\n+    @Warmup(11000) \/\/ Make sure lambda forms get compiled\n+    public void test19_verifier() {\n+        try {\n+            test19();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"test19 failed\", t);\n+        }\n+    }\n+\n+    \/\/ Same as test12\/13 but with constant null\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test20(MethodHandle mh) throws Throwable {\n+        mh.invoke(null);\n+    }\n+\n+    @Run(test = \"test20\")\n+    @Warmup(11000) \/\/ Make sure lambda forms get compiled\n+    public void test20_verifier() {\n+        try {\n+            test20(test18_mh1);\n+            test20(test18_mh2);\n+            test20(test19_mh1);\n+            test20(test19_mh2);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"test20 failed\", t);\n+        }\n+    }\n+\n+    \/\/ Test writing null to a flattenable\/non-flattenable inline type field in an inline type\n+    final primitive class Test21Value {\n+        final MyValue1.ref valueField1;\n+        final MyValue1 valueField2;\n+        final MyValue1.ref alwaysNull = null;\n+\n+        @ForceInline\n+        public Test21Value(MyValue1.ref valueField1, MyValue1 valueField2) {\n+            this.valueField1 = testValue1;\n+            this.valueField2 = testValue1;\n+        }\n+\n+        @ForceInline\n+        public Test21Value test1() {\n+            return new Test21Value(alwaysNull, this.valueField2); \/\/ Should not throw NPE\n+        }\n+\n+        @ForceInline\n+        public Test21Value test2() {\n+            return new Test21Value(this.valueField1, (MyValue1) alwaysNull); \/\/ Should throw NPE\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public Test21Value test21(Test21Value vt) {\n+        vt = vt.test1();\n+        try {\n+            vt = vt.test2();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        test21(Test21Value.default);\n+    }\n+\n+    @DontInline\n+    public MyValue1 test22_helper() {\n+        return (MyValue1) nullField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test22() {\n+        valueField1 = test22_helper();\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        try {\n+            test22();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= 0\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC})\n+    public void test23(MyValue1[] arr, MyValue1.ref b) {\n+        arr[0] = (MyValue1) b;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        MyValue1[] arr = new MyValue1[2];\n+        MyValue1.ref b = null;\n+        try {\n+            test23(arr, b);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static MyValue1.ref nullBox;\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test24() {\n+        return (MyValue1) nullBox;\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        try {\n+            test24();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @DontInline\n+    public void test25_callee(MyValue1 val) { }\n+\n+    \/\/ Test that when checkcasting from null-ok to null-free and back to null-ok we\n+    \/\/ keep track of the information that the inline type can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test25(boolean b, MyValue1.ref vt1, MyValue1 vt2) {\n+        vt1 = (MyValue1)vt1;\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate here\n+        test25_callee((MyValue1) vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier(RunInfo info) {\n+        int res = test25(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test25(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test25(false, null, testValue1);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that chains of casts are folded and don't trigger an allocation\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public MyValue3 test26(MyValue3 vt) {\n+        return ((MyValue3)((Object)((MyValue3.ref)(MyValue3)((MyValue3.ref)((Object)vt)))));\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        MyValue3 vt = MyValue3.create();\n+        MyValue3 result = test26(vt);\n+        Asserts.assertEquals(result, vt);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public MyValue3.ref test27(MyValue3.ref vt) {\n+        return ((MyValue3.ref)((Object)((MyValue3)(MyValue3.ref)((MyValue3)((Object)vt)))));\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        MyValue3 vt = MyValue3.create();\n+        MyValue3 result = (MyValue3) test27(vt);\n+        Asserts.assertEquals(result, vt);\n+    }\n+\n+    \/\/ Some more casting tests\n+    @Test\n+    public MyValue1.ref test28(MyValue1 vt, MyValue1.ref vtBox, int i) {\n+        MyValue1.ref result = null;\n+        if (i == 0) {\n+            result = (MyValue1.ref)vt;\n+            result = null;\n+        } else if (i == 1) {\n+            result = (MyValue1.ref)vt;\n+        } else if (i == 2) {\n+            result = vtBox;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue1.ref result = test28(testValue1, null, 0);\n+        Asserts.assertEquals(result, null);\n+        result = test28(testValue1, testValue1, 1);\n+        Asserts.assertEquals(result, testValue1);\n+        result = test28(testValue1, null, 2);\n+        Asserts.assertEquals(result, null);\n+        result = test28(testValue1, testValue1, 2);\n+        Asserts.assertEquals(result, testValue1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test29(MyValue1 vt, MyValue1.ref vtBox) {\n+        long result = 0;\n+        for (int i = 0; i < 100; ++i) {\n+            MyValue1.ref box;\n+            if (i == 0) {\n+                box = (MyValue1.ref)vt;\n+                box = null;\n+            } else if (i < 99) {\n+                box = (MyValue1.ref)vt;\n+            } else {\n+                box = vtBox;\n+            }\n+            if (box != null) {\n+                result += box.hash();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        long result = test29(testValue1, null);\n+        Asserts.assertEquals(result, testValue1.hash()*98);\n+        result = test29(testValue1, testValue1);\n+        Asserts.assertEquals(result, testValue1.hash()*99);\n+    }\n+\n+    \/\/ Test null check of inline type receiver with incremental inlining\n+    public long test30_callee(MyValue1.ref vt) {\n+        long result = 0;\n+        try {\n+            result = vt.hashInterpreted();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public long test30() {\n+        return test30_callee(nullField);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() {\n+        long result = test30();\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    \/\/ Test casting null to unloaded inline type\n+    final primitive class Test31Value {\n+        private final int i = 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test31(Object o) {\n+        try {\n+            o = (Test31Value)o;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier() {\n+        test31(null);\n+    }\n+\n+    private static final MyValue1.ref constNullRefField = null;\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1.ref test32() {\n+        return constNullRefField;\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        MyValue1.ref result = test32();\n+        Asserts.assertEquals(result, null);\n+    }\n+\n+    static primitive class Test33Value1 {\n+        int x = 0;\n+    }\n+\n+    static primitive class Test33Value2 {\n+        Test33Value1.ref vt;\n+\n+        public Test33Value2() {\n+            vt = new Test33Value1();\n+        }\n+    }\n+\n+    public static final Test33Value2 test33Val = new Test33Value2();\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public Test33Value2 test33() {\n+        return test33Val;\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        Test33Value2 result = test33();\n+        Asserts.assertEquals(result, test33Val);\n+    }\n+\n+    \/\/ Verify that static nullable inline-type fields are not\n+    \/\/ treated as never-null by C2 when initialized at compile time.\n+    private static MyValue1.ref test34Val;\n+\n+    @Test\n+    public void test34(MyValue1 vt) {\n+        if (test34Val == null) {\n+            test34Val = vt;\n+        }\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier(RunInfo info) {\n+        test34(testValue1);\n+        if (!info.isWarmUp()) {\n+            test34Val = null;\n+            test34(testValue1);\n+            Asserts.assertEquals(test34Val, testValue1);\n+        }\n+    }\n+\n+    \/\/ Same as test17 but with non-allocated inline type at withfield\n+    @Test\n+    public Test17Value test35(boolean b) {\n+        Test17Value vt1 = Test17Value.default;\n+        if ((Object)vt1.valueField != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        MyValue1 vt3 = MyValue1.createWithFieldsInline(rI, rL);\n+        Test17Value vt2 = new Test17Value(vt3);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier() {\n+        test35(true);\n+        test35(false);\n+    }\n+\n+    \/\/ Test that when explicitly null checking an inline type, we keep\n+    \/\/ track of the information that the inline type can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test37(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {\n+        if (vt1 == null) {\n+            return 0;\n+        }\n+        \/\/ vt1 should be scalarized because it's always non-null\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate vt2 here\n+        test25_callee(vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        int res = test37(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test37(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+    }\n+\n+    \/\/ Test that when explicitly null checking an inline type receiver,\n+    \/\/ we keep track of the information that the inline type can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test38(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {\n+        vt1.hash(); \/\/ Inlined - Explicit null check\n+        \/\/ vt1 should be scalarized because it's always non-null\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate vt2 here\n+        test25_callee(vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        int res = test38(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test38(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+    }\n+\n+    \/\/ Test that when implicitly null checking an inline type receiver,\n+    \/\/ we keep track of the information that the inline type can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test39(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {\n+        vt1.hashInterpreted(); \/\/ Not inlined - Implicit null check\n+        \/\/ vt1 should be scalarized because it's always non-null\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate vt2 here\n+        test25_callee(vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        int res = test39(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test39(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+    }\n+\n+    \/\/ Test NPE when casting constant null to inline type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test40() {\n+        Object NULL = null;\n+        return (MyValue1)NULL;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        try {\n+            test40();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    MyValue1.ref refField;\n+    MyValue1 flatField;\n+\n+    \/\/ Test scalarization of .ref\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public int test41(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test41(true), refField.x);\n+        Asserts.assertEquals(test41(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test41(false), testValue1.x);\n+                test41(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test41 but with call to hash()\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test42(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test42(true), refField.hash());\n+        Asserts.assertEquals(test42(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test42(false), testValue1.hash());\n+                test42(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test43(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test43(true).hash(), refField.hash());\n+        Asserts.assertEquals(test43(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test43(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test44(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refField;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test44(true, false, info.getTest()), refField.x);\n+        Asserts.assertEquals(test44(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test44(false, false, info.getTest()), testValue1.x);\n+                test44(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test44(true, true, info.getTest()), refField.x);\n+            Asserts.assertEquals(test44(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test45(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refField;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test45(true, false, info.getTest()).hash(), refField.hash());\n+        Asserts.assertEquals(test45(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test45(true, false, info.getTest()), null);\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test45(true, true, info.getTest()).hash(), refField.hash());\n+            Asserts.assertEquals(test45(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test46(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        Asserts.assertEquals(test46(true), testValue1.x);\n+        try {\n+            test46(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test47(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        Asserts.assertEquals(test47(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test47(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test48(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        Asserts.assertEquals(test48(false), testValue1.x);\n+        try {\n+            test48(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test49(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        Asserts.assertEquals(test49(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test49(true), null);\n+    }\n+\n+    @ForceInline\n+    public Object test50_helper() {\n+        return flatField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, TRAP})\n+    public void test50(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = testValue1;\n+        } else {\n+            o = test50_helper();\n+        }\n+        flatField = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatField = vt;\n+        test50(false);\n+        Asserts.assertEquals(flatField.hash(), vt.hash());\n+        test50(true);\n+        Asserts.assertEquals(flatField.hash(), testValue1.hash());\n+    }\n+\n+    static final primitive class MyValue1Wrapper {\n+        final MyValue1.ref vt;\n+\n+        @ForceInline\n+        public MyValue1Wrapper(MyValue1.ref vt) {\n+            this.vt = vt;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return (vt != null) ? vt.hash() : 0;\n+        }\n+    }\n+\n+    MyValue1Wrapper wrapperField;\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public long test51(boolean b) {\n+        MyValue1Wrapper.ref val = MyValue1Wrapper.default;\n+        if (b) {\n+            val = wrapperField;\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        wrapperField = new MyValue1Wrapper(testValue1);\n+        Asserts.assertEquals(test51(true), wrapperField.hash());\n+        Asserts.assertEquals(test51(false), MyValue1Wrapper.default.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public boolean test52(boolean b) {\n+        MyValue1.ref val = MyValue1.default;\n+        if (b) {\n+            val = null;\n+        }\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        return w.vt == null;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        Asserts.assertTrue(test52(true));\n+        Asserts.assertFalse(test52(false));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public boolean test53(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        return w.vt == null;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        Asserts.assertTrue(test53(true));\n+        Asserts.assertFalse(test53(false));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test54(boolean b1, boolean b2) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = null;\n+        }\n+        MyValue1Wrapper.ref w = MyValue1Wrapper.default;\n+        if (b2) {\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.hash();\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        MyValue1Wrapper w = new MyValue1Wrapper(MyValue1.createWithFieldsInline(rI, rL));\n+        Asserts.assertEquals(test54(false, false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test54(false, true), w.hash());\n+        Asserts.assertEquals(test54(true, false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test54(true, true), 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public int test55(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test55(true), refField.x);\n+        Asserts.assertEquals(test55(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test55(false), testValue1.x);\n+                test55(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test56(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt.hash();\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test56(true), refField.hash());\n+        Asserts.assertEquals(test56(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test56(false), testValue1.hash());\n+                test56(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test57(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test57(true).hash(), refField.hash());\n+        Asserts.assertEquals(test57(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test57(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test58(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b1) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test58(true, false, info.getTest()), refField.x);\n+        Asserts.assertEquals(test58(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test58(false, false, info.getTest()), testValue1.x);\n+                test58(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test58(true, true, info.getTest()), refField.x);\n+            Asserts.assertEquals(test58(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test59(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b1) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test59(true, false, info.getTest()).hash(), refField.hash());\n+        Asserts.assertEquals(test59(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test59(true, false, info.getTest()), null);\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test59(true, true, info.getTest()).hash(), refField.hash());\n+            Asserts.assertEquals(test59(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test60(boolean b) {\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        if (b) {\n+            MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        Asserts.assertEquals(test60(true), testValue1.x);\n+        try {\n+            test60(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test61(boolean b) {\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        if (b) {\n+            MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        Asserts.assertEquals(test61(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test61(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test62(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(null);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        Asserts.assertEquals(test62(false), testValue1.x);\n+        try {\n+            test62(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test63(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(null);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        Asserts.assertEquals(test63(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test63(true), null);\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test64_helper() {\n+        return flatField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, TRAP})\n+    public void test64(boolean b) {\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        if (b) {\n+            w = new MyValue1Wrapper(testValue1);\n+        } else {\n+            w = new MyValue1Wrapper(test64_helper());\n+        }\n+        flatField = w.vt;\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatField = vt;\n+        test64(false);\n+        Asserts.assertEquals(flatField.hash(), vt.hash());\n+        test64(true);\n+        Asserts.assertEquals(flatField.hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public long test65(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        if (val != null) {\n+            return val.hashPrimitive();\n+        }\n+        return 42;\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        Asserts.assertEquals(test65(true), 42L);\n+        Asserts.assertEquals(test65(false), MyValue1.createWithFieldsInline(rI, rL).hashPrimitive());\n+    }\n+\n+    @ForceInline\n+    public Object test66_helper(Object arg) {\n+        return arg;\n+    }\n+\n+    \/\/ Test that .ref arg does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test66(boolean b1, boolean b2, MyValue1.ref arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test66_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test66(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test66(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test66(false, false, arg, info.getTest()), testValue1.x);\n+                test66(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test66(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test66(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @DontInline\n+    public MyValue1.ref test67_helper1() {\n+        return refField;\n+    }\n+\n+    @ForceInline\n+    public Object test67_helper2() {\n+        return test67_helper1();\n+    }\n+\n+    \/\/ Test that .ref return does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test67(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test67_helper2();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test67(true, false, info.getTest()), refField.hash());\n+        Asserts.assertEquals(test67(false, false, info.getTest()), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test67(false, false, info.getTest()), testValue1.hash());\n+                test67(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test67(true, true, info.getTest()), refField.hash());\n+            Asserts.assertEquals(test67(false, true, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test68_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Test that scalarization enabled by cast is applied to parsing map\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test68(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test68_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test68(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test68(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test68(false, false, arg, info.getTest()), testValue1.x);\n+                test68(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test68(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test68(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test69_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with ClassCastException\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test69(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test69_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test69\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test69_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test69(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test69(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test69(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test69(false, false, arg, info.getTest()), testValue1.x);\n+                test69(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test69(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test69(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test70_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with ClassCastException and frequent NullPointerException\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test70(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test70_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test70\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test70_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test70(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test70(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test70(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test70(false, false, arg, info.getTest()), testValue1.x);\n+            test70(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test70(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test70(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test71_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with .ref cast\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test71(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test71_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).x;\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test71(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test71(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test71(false, false, arg, info.getTest()), testValue1.x);\n+                test71(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test71(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test71(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test72_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test71 but with ClassCastException and hash() call\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test72(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test72_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    @Run(test = \"test72\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test72_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test72(true, false, arg, info.getTest()), arg.hash());\n+        Asserts.assertEquals(test72(false, false, arg, info.getTest()), testValue1.hash());\n+        try {\n+            test72(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test72(false, false, arg, info.getTest()), testValue1.hash());\n+                test72(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test72(true, true, arg, info.getTest()), arg.hash());\n+            Asserts.assertEquals(test72(false, true, arg, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test73_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test71 but with ClassCastException and frequent NullPointerException\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test73(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test73_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).x;\n+    }\n+\n+    @Run(test = \"test73\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test73_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test73(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test73(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test73(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test73(false, false, arg, info.getTest()), testValue1.x);\n+            test73(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test73(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test73(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test74_helper(Object arg) {\n+        return (MyValue1.ref)arg;\n+    }\n+\n+    \/\/ Same as test73 but result of cast is used and hash() is called\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test74(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test74_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    @Run(test = \"test74\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test74_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test74(true, false, arg, info.getTest()), arg.hash());\n+        Asserts.assertEquals(test74(false, false, arg, info.getTest()), testValue1.hash());\n+        try {\n+            test74(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test74(false, false, arg, info.getTest()), testValue1.hash());\n+            test74(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test74(true, true, arg, info.getTest()), arg.hash());\n+            Asserts.assertEquals(test74(false, true, arg, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    \/\/ Test new merge path being added for exceptional control flow\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1.ref test75(MyValue1.ref vt, Object obj) {\n+        try {\n+            vt = (MyValue1.ref)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        MyValue1.ref vt = testValue1;\n+        MyValue1.ref result = test75(vt, Integer.valueOf(rI));\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test76_helper() {\n+        return constNullRefField;\n+    }\n+\n+    \/\/ Test that constant null .ref field does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test76(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test76_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier(RunInfo info) {\n+        Asserts.assertEquals(test76(false, false, info.getTest()), testValue1.hash());\n+        try {\n+            test76(true, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test76(false, true, info.getTest()), testValue1.hash());\n+            try {\n+                test76(true, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    private static final Object constObjectValField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+\n+    @ForceInline\n+    public Object test77_helper() {\n+        return constObjectValField;\n+    }\n+\n+    \/\/ Test that constant object field with inline type content does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test77(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test77_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier(RunInfo info) {\n+        Asserts.assertEquals(test77(true, false, info.getTest()), ((MyValue1)constObjectValField).hash());\n+        Asserts.assertEquals(test77(false, false, info.getTest()), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+          Asserts.assertEquals(test77(true, false, info.getTest()), ((MyValue1)constObjectValField).hash());\n+          Asserts.assertEquals(test77(false, false, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test78_helper() {\n+        return null;\n+    }\n+\n+    \/\/ Test that constant null does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test78(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test78_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier(RunInfo info) {\n+        Asserts.assertEquals(test78(false, false, info.getTest()), testValue1.hash());\n+        try {\n+            test78(true, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test78(false, true, info.getTest()), testValue1.hash());\n+            try {\n+                test78(true, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test79_helper() {\n+        return null;\n+    }\n+\n+    \/\/ Same as test78 but will trigger different order of PhiNode inputs\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test79(boolean b1, boolean b2, Method m) {\n+        Object val = test79_helper();\n+        if (b1) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier(RunInfo info) {\n+        Asserts.assertEquals(test79(true, false, info.getTest()), testValue1.hash());\n+        try {\n+            test79(false, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test79(true, true, info.getTest()), testValue1.hash());\n+            try {\n+                test79(false, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test80_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test that phi nodes referencing themselves (loops) do not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test80() {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        for (int i = 0; i < 100; ++i) {\n+            val = test80_helper(val, i);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    private long test80Result = 0;\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        if (test80Result == 0) {\n+            test80Result = test80();\n+        }\n+        Asserts.assertEquals(test80(), test80Result);\n+    }\n+\n+    @ForceInline\n+    public Object test81_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test nested loops\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test81() {\n+        Object val = null;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test81_helper(val, i + j + k);\n+                }\n+                val = test81_helper(val, i + j);\n+            }\n+            val = test81_helper(val, i);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    private long test81Result = 0;\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        if (test81Result == 0) {\n+            test81Result = test81();\n+        }\n+        Asserts.assertEquals(test81(), test81Result);\n+    }\n+\n+    @ForceInline\n+    public Object test82_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test loops with casts\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test82() {\n+        Object val = null;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test82_helper(val, i + j + k);\n+                }\n+                if (val != null) {\n+                    val = test82_helper(val, i + j);\n+                }\n+            }\n+            val = test82_helper(val, i);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    private long test82Result = 0;\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        if (test82Result == 0) {\n+            test82Result = test81();\n+        }\n+        Asserts.assertEquals(test82(), test82Result);\n+    }\n+\n+    @ForceInline\n+    public Object test83_helper(boolean b) {\n+        if (b) {\n+            return MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Test that CastPP does not block sclarization in safepoints\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test83(boolean b, Method m) {\n+        Object val = test83_helper(b);\n+        if (val != null) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return ((MyValue1.ref)val).hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier(RunInfo info) {\n+        Asserts.assertEquals(test83(false, info.getTest()), 0L);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test83(true, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test84_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return new MyValue1Wrapper(MyValue1.createWithFieldsInline(i, i));\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Same as test80 but with wrapper\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test84() {\n+        Object val = new MyValue1Wrapper(MyValue1.createWithFieldsInline(rI, rL));\n+        for (int i = 0; i < 100; ++i) {\n+            val = test84_helper(val, i);\n+        }\n+        return ((MyValue1Wrapper.ref)val).vt.hash();\n+    }\n+\n+    private long test84Result = 0;\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        if (test84Result == 0) {\n+            test84Result = test84();\n+        }\n+        Asserts.assertEquals(test84(), test84Result);\n+    }\n+\n+    @ForceInline\n+    public Object test85_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return new MyValue1Wrapper(MyValue1.createWithFieldsInline(i, i));\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Same as test81 but with wrapper\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test85() {\n+        Object val = new MyValue1Wrapper(null);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test85_helper(val, i + j + k);\n+                }\n+                val = test85_helper(val, i + j);\n+            }\n+            val = test85_helper(val, i);\n+        }\n+        return ((MyValue1Wrapper.ref)val).vt.hash();\n+    }\n+\n+    private long test85Result = 0;\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        if (test85Result == 0) {\n+            test85Result = test85();\n+        }\n+        Asserts.assertEquals(test85(), test85Result);\n+    }\n+\n+    static final class ObjectWrapper {\n+        public Object obj;\n+\n+        @ForceInline\n+        public ObjectWrapper(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    \/\/ Test scalarization with phi referencing itself\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC, STORE},\n+        counts = {LOAD, \" = 4\"}) \/\/ 4 loads from the non-flattened MyValue1.v4 fields\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, STORE})\n+    public long test86(MyValue1 vt) {\n+        ObjectWrapper val = new ObjectWrapper(vt);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                val.obj = val.obj;\n+            }\n+        }\n+        return ((MyValue1.ref)val.obj).hash();\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        test86(testValue1);\n+        Asserts.assertEquals(test86(testValue1), testValue1.hash());\n+    }\n+\n+    public static primitive class Test87C0 {\n+        int x = rI;\n+    }\n+\n+    public static primitive class Test87C1 {\n+        Test87C0 field = Test87C0.default;\n+    }\n+\n+    public static primitive class Test87C2 {\n+        Test87C1 field = Test87C1.default;\n+    }\n+\n+    \/\/ Test merging .val and .ref in return\n+    @Test\n+    public Test87C1 test87(boolean b, Test87C2.val v1, Test87C2.ref v2) {\n+        if (b) {\n+            return v1.field;\n+        } else {\n+            return v2.field;\n+        }\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier() {\n+        Test87C2 v = new Test87C2();\n+        Asserts.assertEQ(test87(true, v, v), v.field);\n+        Asserts.assertEQ(test87(false, v, v), v.field);\n+    }\n+\n+    static primitive class Test88Value {\n+        int x = 0;\n+    }\n+\n+    static class Test88MyClass {\n+        int x = 0;\n+        int y = rI;\n+    }\n+\n+    @ForceInline\n+    Object test88Helper() {\n+        return new Test88Value();\n+    }\n+\n+    \/\/ Test LoadNode::Identity optimization with always failing checkcast\n+    @Test\n+    public int test88() {\n+        Object obj = test88Helper();\n+        return ((Test88MyClass)obj).y;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        try {\n+            test88();\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test88 but with Phi\n+    @Test\n+    public int test89(boolean b) {\n+        Test88MyClass obj = b ? (Test88MyClass)test88Helper() : (Test88MyClass)test88Helper();\n+        return obj.y;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        try {\n+            test89(false);\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test89(true);\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean test90_inline(MyValue1.ref vt) {\n+        return vt == null;\n+    }\n+\n+    \/\/ Test scalarization with speculative NULL type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test90(Method m) throws Exception {\n+        Object arg = null;\n+        return (boolean)m.invoke(this, arg);\n+    }\n+\n+    @Run(test = \"test90\")\n+    @Warmup(10000)\n+    public void test90_verifier() throws Exception {\n+        Method m = getClass().getMethod(\"test90_inline\", MyValue1.ref.class);\n+        Asserts.assertTrue(test90(m));\n+    }\n+\n+    \/\/ Test that scalarization does not introduce redundant\/unused checks\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, CMPP})\n+    public Object test91(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        Asserts.assertEQ(test91(testValue1), testValue1);\n+    }\n+\n+    MyValue1.ref test92Field = testValue1;\n+\n+    \/\/ Same as test91 but with field access\n+    @Test\n+    @IR(failOn = {ALLOC, CMPP})\n+    public Object test92() {\n+        return test92Field;\n+    }\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier() {\n+        Asserts.assertEQ(test92(), testValue1);\n+    }\n+\n+    private static final MethodHandle refCheckCast = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"refCheckCast\",\n+        MethodType.methodType(PrimitiveClass.asPrimaryType(MyValue2.class), TestNullableInlineTypes.class, PrimitiveClass.asPrimaryType(MyValue1.class)),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            checkcast(PrimitiveClass.asPrimaryType(MyValue2.class)).\n+            return_(TypeTag.A);\n+        });\n+\n+    \/\/ Test checkcast that only passes with null\n+    @Test\n+    public Object test93(MyValue1.ref vt) throws Throwable {\n+        return refCheckCast.invoke(this, vt);\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier() throws Throwable {\n+        Asserts.assertEQ(test93(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue1.ref test94_helper1(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test94_helper2(MyValue1.ref vt) {\n+        return test94_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test94_helper3(Object vt) {\n+        return test94_helper2((MyValue1.ref)vt);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of arguments\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC_G, \" = 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation\n+    public MyValue1.ref test94(MyValue1.ref vt) {\n+        MyValue1.ref res = test94_helper1(vt);\n+        vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test94_helper1(vt);\n+        test94_helper2(vt);\n+        test94_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test94\")\n+    public void test94_verifier() {\n+        Asserts.assertEQ(test94(testValue1), testValue1);\n+        Asserts.assertEQ(test94(null), null);\n+    }\n+\n+    @DontInline\n+    public static MyValue1.ref test95_helper1(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public static MyValue1.ref test95_helper2(MyValue1.ref vt) {\n+        return test95_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public static MyValue1.ref test95_helper3(Object vt) {\n+        return test95_helper2((MyValue1.ref)vt);\n+    }\n+\n+    \/\/ Same as test94 but with static methods to trigger simple adapter logic\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC_G, \" = 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation\n+    public static MyValue1.ref test95(MyValue1.ref vt) {\n+        MyValue1.ref res = test95_helper1(vt);\n+        vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test95_helper1(vt);\n+        test95_helper2(vt);\n+        test95_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test95\")\n+    public void test95_verifier() {\n+        Asserts.assertEQ(test95(testValue1), testValue1);\n+        Asserts.assertEQ(test95(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue2.ref test96_helper1(boolean b) {\n+        return b ? null : MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    public MyValue2.ref test96_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValue2.ref test96_helper3(boolean b) {\n+        return b ? null : MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of return values\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC_G})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC_G, \" = 1\"})\n+    public MyValue2.ref test96(int c, boolean b) {\n+        MyValue2.ref res = null;\n+        if (c == 1) {\n+            res = test96_helper1(b);\n+        } else if (c == 2) {\n+            res = test96_helper2();\n+        } else if (c == 3) {\n+            res = test96_helper3(b);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        Asserts.assertEQ(test96(0, false), null);\n+        Asserts.assertEQ(test96(1, false).hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test96(1, true), null);\n+        Asserts.assertEQ(test96(2, false), null);\n+        Asserts.assertEQ(test96(3, false).hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test96(3, true), null);\n+    }\n+\n+    @DontInline\n+    public MyValue3.ref test97_helper1(boolean b) {\n+        return b ? null: MyValue3.create();\n+    }\n+\n+    @ForceInline\n+    public MyValue3.ref test97_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValue3.ref test97_helper3(boolean b) {\n+        return b ? null: MyValue3.create();\n+    }\n+\n+    MyValue3 test97_res1;\n+    MyValue3 test97_res3;\n+\n+    \/\/ Same as test96 but with MyValue3 return\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        counts = {ALLOC_G, \" = 1\"}) \/\/ 1 Object allocation\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValue3 allocation + 1 Object allocation\n+    public MyValue3.ref test97(int c, boolean b) {\n+        MyValue3.ref res = null;\n+        if (c == 1) {\n+            res = test97_helper1(b);\n+            if (res != null) {\n+                test97_res1 = res;\n+            }\n+        } else if (c == 2) {\n+            res = test97_helper2();\n+        } else if (c == 3) {\n+            res = test97_helper3(b);\n+            if (res != null) {\n+                test97_res3 = res;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        Asserts.assertEQ(test97(0, false), null);\n+        Asserts.assertEQ(test97(1, false), test97_res1);\n+        Asserts.assertEQ(test97(1, true), null);\n+        Asserts.assertEQ(test97(2, false), null);\n+        Asserts.assertEQ(test97(3, false), test97_res3);\n+        Asserts.assertEQ(test97(3, true), null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":2739,"deletions":0,"binary":false,"changes":2739,"status":"added"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @compile -XDenablePrimitiveClasses TestOnStackReplacement.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestOnStackReplacement\n+ *\/\n+\n+public class TestOnStackReplacement {\n+\n+\n+    public static void main(String[] args) throws Throwable {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:FlatArrayElementMaxSize=0\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    \/\/ Helper methods\n+\n+    protected long hash() {\n+        return hash(rI, rL);\n+    }\n+\n+    protected long hash(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y).hash();\n+    }\n+\n+    \/\/ Test OSR compilation\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public long test1() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1[] va = new MyValue1[Math.abs(rI) % 3];\n+        for (int i = 0; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        long result = 0;\n+        \/\/ Long loop to trigger OSR compilation\n+        for (int i = 0; i < 50_000; ++i) {\n+            \/\/ Reference local inline type in interpreter state\n+            result = v.hash();\n+            for (int j = 0; j < va.length; ++j) {\n+                result += va[j].hash();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(0)\n+    public void test1_verifier() {\n+        long result = test1();\n+        Asserts.assertEQ(result, ((Math.abs(rI) % 3) + 1) * hash());\n+    }\n+\n+    \/\/ Test loop peeling\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public void test2() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(0, 1);\n+        \/\/ Trigger OSR compilation and loop peeling\n+        for (int i = 0; i < 50_000; ++i) {\n+            if (v.x != i || v.y != i + 1) {\n+                \/\/ Uncommon trap\n+                throw new RuntimeException(\"test2 failed\");\n+            }\n+            v = MyValue1.createWithFieldsInline(i + 1, i + 2);\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(0)\n+    public void test2_verifier() {\n+        test2();\n+    }\n+\n+    \/\/ Test loop peeling and unrolling\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test3() {\n+        MyValue1 v1 = MyValue1.createWithFieldsInline(0, 0);\n+        MyValue1 v2 = MyValue1.createWithFieldsInline(1, 1);\n+        \/\/ Trigger OSR compilation and loop peeling\n+        for (int i = 0; i < 50_000; ++i) {\n+            if (v1.x != 2*i || v2.x != i+1 || v2.y != i+1) {\n+                \/\/ Uncommon trap\n+                throw new RuntimeException(\"test3 failed\");\n+            }\n+            v1 = MyValue1.createWithFieldsInline(2*(i+1), 0);\n+            v2 = MyValue1.createWithFieldsInline(i+2, i+2);\n+        }\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(0)\n+    public void test3_verifier() {\n+        test3();\n+    }\n+\n+    \/\/ OSR compilation with Object local\n+    @DontCompile\n+    public Object test4_init() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @DontCompile\n+    public Object test4_body() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public Object test4() {\n+        Object vt = test4_init();\n+        for (int i = 0; i < 50_000; i++) {\n+            if (i % 2 == 1) {\n+                vt = test4_body();\n+            }\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(0)\n+    public void test4_verifier() {\n+        test4();\n+    }\n+\n+    \/\/ OSR compilation with null inline type local\n+\n+    MyValue1.ref nullField;\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test5() {\n+        MyValue1.ref vt = nullField;\n+        for (int i = 0; i < 50_000; i++) {\n+            if (vt != null) {\n+                throw new RuntimeException(\"test5 failed: vt should be null\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(0)\n+    public void test5_verifier() {\n+        test5();\n+    }\n+\n+    \/\/ Test OSR in method with inline type receiver\n+    primitive class Test6Value {\n+        public int f = 0;\n+\n+        public int test() {\n+            int res = 0;\n+            for (int i = 1; i < 20_000; ++i) {\n+                res -= i;\n+            }\n+            return res;\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test6() {\n+        Test6Value tmp = new Test6Value();\n+        for (int i = 0; i < 100; ++i) {\n+            tmp.test();\n+        }\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(0)\n+    public void test6_verifier() {\n+        test6();\n+    }\n+\n+    \/\/ Similar to test6 but with more fields and reserved stack entry\n+    static primitive class Test7Value1 {\n+        public int i1 = rI;\n+        public int i2 = rI;\n+        public int i3 = rI;\n+        public int i4 = rI;\n+        public int i5 = rI;\n+        public int i6 = rI;\n+    }\n+\n+    static primitive class Test7Value2 {\n+        public int i1 = rI;\n+        public int i2 = rI;\n+        public int i3 = rI;\n+        public int i4 = rI;\n+        public int i5 = rI;\n+        public int i6 = rI;\n+        public int i7 = rI;\n+        public int i8 = rI;\n+        public int i9 = rI;\n+        public int i10 = rI;\n+        public int i11 = rI;\n+        public int i12 = rI;\n+        public int i13 = rI;\n+        public int i14 = rI;\n+        public int i15 = rI;\n+        public int i16 = rI;\n+        public int i17 = rI;\n+        public int i18 = rI;\n+        public int i19 = rI;\n+        public int i20 = rI;\n+        public int i21 = rI;\n+\n+        public Test7Value1 vt = new Test7Value1();\n+\n+        public int test(String[] args) {\n+            int res = 0;\n+            for (int i = 1; i < 20_000; ++i) {\n+                res -= i;\n+            }\n+            return res;\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test7() {\n+        Test7Value2 tmp = new Test7Value2();\n+        for (int i = 0; i < 10; ++i) {\n+            tmp.test(null);\n+        }\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(0)\n+    public void test7_verifier() {\n+        test7();\n+    }\n+\n+    \/\/ Test OSR with scalarized inline type return\n+    MyValue3 test8_vt;\n+\n+    @DontInline\n+    public MyValue3 test8_callee(int len) {\n+        test8_vt = MyValue3.create();\n+        int val = 0;\n+        for (int i = 0; i < len; ++i) {\n+            val = i;\n+        }\n+        test8_vt = test8_vt.setI(test8_vt, val);\n+        return test8_vt;\n+    }\n+\n+    @Test\n+    public int test8(int start) {\n+        MyValue3 vt = test8_callee(start);\n+        test8_vt.verify(vt);\n+        int result = 0;\n+        for (int i = 0; i < 50_000; ++i) {\n+            result += i;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(2)\n+    public void test8_verifier() {\n+        test8(1);\n+        test8(50_000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -0,0 +1,958 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.experimental.bytecode.TypeTag;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+import jdk.internal.value.PrimitiveClass;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @modules java.base\/jdk.internal.value\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile -XDenablePrimitiveClasses TestValueClasses.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestValueClasses\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestValueClasses {\n+\n+    public static void main(String[] args) {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        \/\/ Don't generate bytecodes but call through runtime for reflective calls\n+        scenarios[0].addFlags(\"-Dsun.reflect.inflationThreshold=10000\");\n+        scenarios[1].addFlags(\"-Dsun.reflect.inflationThreshold=10000\");\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\");\n+        scenarios[4].addFlags(\"-XX:-UseTLAB\", \"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValueClass1.class,\n+                                     MyValueClass2.class,\n+                                     MyValueClass2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    private static final MyValueClass1 testValue1 = MyValueClass1.createWithFieldsInline(rI, rL);\n+\n+    MyValueClass1 nullValField = null;\n+    MyValueClass1 testField1;\n+    MyValueClass1 testField2;\n+    MyValueClass1 testField3;\n+    MyValueClass1 testField4;\n+    static MyValueClass1 testField5;\n+    static MyValueClass1 testField6;\n+    static MyValueClass1 testField7;\n+    static MyValueClass1 testField8;\n+\n+    \/\/ Test field loads\n+    @Test\n+    public long test1(boolean b) {\n+        MyValueClass1 val1 = b ? testField3 : MyValueClass1.createWithFieldsInline(rI, rL);\n+        MyValueClass1 val2 = b ? testField7 : MyValueClass1.createWithFieldsInline(rI, rL);\n+        long res = 0;\n+        res += testField1.hash();\n+        res += ((Object)testField2 == null) ? 42 : testField2.hash();\n+        res += val1.hash();\n+        res += testField4.hash();\n+\n+        res += testField5.hash();\n+        res += ((Object)testField6 == null) ? 42 : testField6.hash();\n+        res += val2.hash();\n+        res += testField8.hash();\n+        return res;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        testField1 = testValue1;\n+        testField2 = nullValField;\n+        testField3 = testValue1;\n+        testField4 = testValue1;\n+\n+        testField5 = testValue1;\n+        testField6 = nullValField;\n+        testField7 = testValue1;\n+        testField8 = testValue1;\n+        long res = test1(true);\n+        Asserts.assertEquals(res, 2*42 + 6*testValue1.hash());\n+\n+        testField2 = testValue1;\n+        testField6 = testValue1;\n+        res = test1(false);\n+        Asserts.assertEquals(res, 8*testValue1.hash());\n+    }\n+\n+    \/\/ Test field stores\n+    @Test\n+    public MyValueClass1 test2(MyValueClass1 val1) {\n+        MyValueClass1 ret = MyValueClass1.createWithFieldsInline(rI, rL);\n+        MyValueClass1 val2 = MyValueClass1.setV4(testValue1, null);\n+        testField1 = testField4;\n+        testField2 = val1;\n+        testField3 = val2;\n+\n+        testField5 = ret;\n+        testField6 = val1;\n+        testField7 = val2;\n+        testField8 = testField4;\n+        return ret;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        testField4 = testValue1;\n+        MyValueClass1 ret = test2(null);\n+        MyValueClass1 val2 = MyValueClass1.setV4(testValue1, null);\n+        Asserts.assertEquals(testField1, testValue1);\n+        Asserts.assertEquals(testField2, null);\n+        Asserts.assertEquals(testField3, val2);\n+\n+        Asserts.assertEquals(testField5, ret);\n+        Asserts.assertEquals(testField6, null);\n+        Asserts.assertEquals(testField7, val2);\n+        Asserts.assertEquals(testField8, testField4);\n+\n+        testField4 = null;\n+        test2(null);\n+        Asserts.assertEquals(testField1, testField4);\n+        Asserts.assertEquals(testField8, testField4);\n+    }\n+\n+    \/\/ Non-primitive Wrapper\n+    static class Test3Wrapper {\n+        MyValueClass1 val;\n+\n+        public Test3Wrapper(MyValueClass1 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Test scalarization in safepoint debug info and re-allocation on deopt\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test3(boolean deopt, boolean b1, boolean b2, Method m) {\n+        MyValueClass1 ret = MyValueClass1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            ret = null;\n+        }\n+        if (b2) {\n+            ret = MyValueClass1.setV4(ret, null);\n+        }\n+        Test3Wrapper wrapper = new Test3Wrapper(ret);\n+        if (deopt) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        long res = ((Object)ret != null && (Object)ret.v4 != null) ? ret.hash() : 42;\n+        res += ((Object)wrapper.val != null && (Object)wrapper.val.v4 != null) ? wrapper.val.hash() : 0;\n+        return res;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier(RunInfo info) {\n+        Asserts.assertEquals(test3(false, false, false, info.getTest()), 2*testValue1.hash());\n+        Asserts.assertEquals(test3(false, true, false, info.getTest()), 42L);\n+        if (!info.isWarmUp()) {\n+            switch (rI % 4) {\n+            case 0:\n+                Asserts.assertEquals(test3(true, false, false, info.getTest()), 2*testValue1.hash());\n+                break;\n+            case 1:\n+                Asserts.assertEquals(test3(true, true, false, info.getTest()), 42L);\n+                break;\n+            case 2:\n+                Asserts.assertEquals(test3(true, false, true, info.getTest()), 42L);\n+                break;\n+            case 3:\n+                try {\n+                    Asserts.assertEquals(test3(true, true, true, info.getTest()), 42L);\n+                    throw new RuntimeException(\"NullPointerException expected\");\n+                } catch (NullPointerException e) {\n+                    \/\/ Expected\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ Test scalarization in safepoint debug info and re-allocation on deopt\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public boolean test4(boolean deopt, boolean b, Method m) {\n+        MyValueClass1 val = b ? null : MyValueClass1.createWithFieldsInline(rI, rL);\n+        Test3Wrapper wrapper = new Test3Wrapper(val);\n+        if (deopt) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return (Object)wrapper.val == null;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier(RunInfo info) {\n+        Asserts.assertTrue(test4(false, true, info.getTest()));\n+        Asserts.assertFalse(test4(false, false, info.getTest()));\n+        if (!info.isWarmUp()) {\n+            switch (rI % 2) {\n+                case 0:\n+                    Asserts.assertTrue(test4(true, true, info.getTest()));\n+                    break;\n+                case 1:\n+                    Asserts.assertFalse(test4(false, false, info.getTest()));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    static value class SmallNullable2 {\n+        float f1;\n+        double f2;\n+\n+        @ForceInline\n+        public SmallNullable2() {\n+            f1 = (float)rL;\n+            f2 = (double)rL;\n+        }\n+    }\n+\n+    static value class SmallNullable1 {\n+        char c;\n+        byte b;\n+        short s;\n+        int i;\n+        SmallNullable2 vt;\n+\n+        @ForceInline\n+        public SmallNullable1(boolean useNull) {\n+            c = (char)rL;\n+            b = (byte)rL;\n+            s = (short)rL;\n+            i = (int)rL;\n+            vt = useNull ? null : new SmallNullable2();\n+        }\n+    }\n+\n+    @DontCompile\n+    public SmallNullable1 test5_interpreted(boolean b1, boolean b2) {\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @DontInline\n+    public SmallNullable1 test5_compiled(boolean b1, boolean b2) {\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    SmallNullable1 test5_field1;\n+    SmallNullable1 test5_field2;\n+\n+    \/\/ Test scalarization in returns\n+    @Test\n+    public SmallNullable1 test5(boolean b1, boolean b2) {\n+        SmallNullable1 ret = test5_interpreted(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test5 failed\");\n+        }\n+        test5_field1 = ret;\n+        ret = test5_compiled(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test5 failed\");\n+        }\n+        test5_field2 = ret;\n+        return ret;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        SmallNullable1 vt = new SmallNullable1(false);\n+        Asserts.assertEquals(test5(true, false), null);\n+        Asserts.assertEquals(test5_field1, null);\n+        Asserts.assertEquals(test5_field2, null);\n+        Asserts.assertEquals(test5(false, false), vt);\n+        Asserts.assertEquals(test5_field1, vt);\n+        Asserts.assertEquals(test5_field2, vt);\n+        vt = new SmallNullable1(true);\n+        Asserts.assertEquals(test5(true, true), null);\n+        Asserts.assertEquals(test5_field1, null);\n+        Asserts.assertEquals(test5_field2, null);\n+        Asserts.assertEquals(test5(false, true), vt);\n+        Asserts.assertEquals(test5_field1, vt);\n+        Asserts.assertEquals(test5_field2, vt);\n+    }\n+\n+    static value class Empty2 {\n+\n+    }\n+\n+    static value class Empty1 {\n+        Empty2 empty2 = Empty2.default;\n+    }\n+\n+    static value class Container {\n+        int x = 0;\n+        Empty1 empty1;\n+        Empty2 empty2 = Empty2.default;\n+\n+        @ForceInline\n+        public Container(Empty1 val) {\n+            empty1 = val;\n+        }\n+    }\n+\n+    @DontInline\n+    public static Empty1 test6_helper1(Empty1 vt) {\n+        return vt;\n+    }\n+\n+    @DontInline\n+    public static Empty2 test6_helper2(Empty2 vt) {\n+        return vt;\n+    }\n+\n+    @DontInline\n+    public static Container test6_helper3(Container vt) {\n+        return vt;\n+    }\n+\n+    \/\/ Test scalarization in calls and returns with empty nullable inline types\n+    @Test\n+    public Empty1 test6(Empty1 vt) {\n+        Empty1 empty1 = test6_helper1(vt);\n+        test6_helper2((empty1 != null) ? empty1.empty2 : null);\n+        Container c = test6_helper3(new Container(empty1));\n+        return c.empty1;\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(10000) \/\/ Warmup to make sure helper methods are compiled as well\n+    public void test6_verifier() {\n+        Asserts.assertEQ(test6(Empty1.default), Empty1.default);\n+        Asserts.assertEQ(test6(null), null);\n+    }\n+\n+    @DontCompile\n+    public void test7_helper2(boolean doit) {\n+        if (doit) {\n+            \/\/ uncommon trap\n+            try {\n+                TestFramework.deoptimize(getClass().getDeclaredMethod(\"test7\", boolean.class, boolean.class, boolean.class));\n+            } catch (NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test deoptimization at call return with inline type returned in registers\n+    @DontInline\n+    public SmallNullable1 test7_helper1(boolean deopt, boolean b1, boolean b2) {\n+        test7_helper2(deopt);\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @Test\n+    public SmallNullable1 test7(boolean flag, boolean b1, boolean b2) {\n+        return test7_helper1(flag, b1, b2);\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(10000)\n+    public void test7_verifier(RunInfo info) {\n+        boolean b1 = ((rI % 3) == 0);\n+        boolean b2 = ((rI % 3) == 1);\n+        SmallNullable1 result = test7(!info.isWarmUp(), b1, b2);\n+        SmallNullable1 vt = new SmallNullable1(b2);\n+        Asserts.assertEQ(result, b1 ? null : vt);\n+    }\n+\n+    \/\/ Test calling a method returning a nullable inline type as fields via reflection\n+    @Test\n+    public SmallNullable1 test8(boolean b1, boolean b2) {\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() throws Exception {\n+        Method m = getClass().getDeclaredMethod(\"test8\", boolean.class, boolean.class);\n+        Asserts.assertEQ(m.invoke(this, false, true), new SmallNullable1(true));\n+        Asserts.assertEQ(m.invoke(this, false, false), new SmallNullable1(false));\n+        Asserts.assertEQ(m.invoke(this, true, false), null);\n+    }\n+\n+    \/\/ Test value classes as arg\/return\n+    @Test\n+    public SmallNullable1 test9(MyValueClass1 vt1, MyValueClass1 vt2, boolean b1, boolean b2) {\n+        Asserts.assertEQ(vt1, testValue1);\n+        if (b1) {\n+            Asserts.assertEQ(vt2, null);\n+        } else {\n+            Asserts.assertEQ(vt2, testValue1);\n+        }\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        Asserts.assertEQ(test9(testValue1, testValue1, false, true), new SmallNullable1(true));\n+        Asserts.assertEQ(test9(testValue1, testValue1, false, false), new SmallNullable1(false));\n+        Asserts.assertEQ(test9(testValue1, null, true, false), null);\n+    }\n+\n+    \/\/ Class.cast\n+    @Test\n+    public Object test10(Class c, MyValueClass1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        Asserts.assertEQ(test10(MyValueClass1.class, testValue1), testValue1);\n+        Asserts.assertEQ(test10(PrimitiveClass.asPrimaryType(MyValueClass1.class), null), null);\n+        Asserts.assertEQ(test10(PrimitiveClass.asPrimaryType(MyValueClass2.class), null), null);\n+        Asserts.assertEQ(test10(Integer.class, null), null);\n+        try {\n+            test10(PrimitiveClass.asPrimaryType(MyValueClass2.class), testValue1);\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test acmp\n+    @Test\n+    public boolean test12(MyValueClass1 vt1, MyValueClass1 vt2) {\n+        return vt1 == vt2;\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        Asserts.assertTrue(test12(testValue1, testValue1));\n+        Asserts.assertTrue(test12(null, null));\n+        Asserts.assertFalse(test12(testValue1, null));\n+        Asserts.assertFalse(test12(null, testValue1));\n+        Asserts.assertFalse(test12(testValue1, MyValueClass1.default));\n+    }\n+\n+    \/\/ Same as test13 but with Object argument\n+    @Test\n+    public boolean test13(Object obj, MyValueClass1 vt2) {\n+        return obj == vt2;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        Asserts.assertTrue(test13(testValue1, testValue1));\n+        Asserts.assertTrue(test13(null, null));\n+        Asserts.assertFalse(test13(testValue1, null));\n+        Asserts.assertFalse(test13(null, testValue1));\n+        Asserts.assertFalse(test13(testValue1, MyValueClass1.default));\n+    }\n+\n+    static MyValueClass1 test14_field1;\n+    static MyValueClass1 test14_field2;\n+\n+    \/\/ Test buffer checks emitted by acmp followed by buffering\n+    @Test\n+    public boolean test14(MyValueClass1 vt1, MyValueClass1 vt2) {\n+        \/\/ Trigger buffer checks\n+        if (vt1 != vt2) {\n+            throw new RuntimeException(\"Should be equal\");\n+        }\n+        if (vt2 != vt1) {\n+            throw new RuntimeException(\"Should be equal\");\n+        }\n+        \/\/ Trigger buffering\n+        test14_field1 = vt1;\n+        test14_field2 = vt2;\n+        return vt1 == null;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        Asserts.assertFalse(test14(testValue1, testValue1));\n+        Asserts.assertTrue(test14(null, null));\n+    }\n+\n+    @DontInline\n+    public MyValueClass1 test15_helper1(MyValueClass1 vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValueClass1 test15_helper2(MyValueClass1 vt) {\n+        return test15_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public MyValueClass1 test15_helper3(Object vt) {\n+        return test15_helper2((MyValueClass1)vt);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of arguments\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC_G, \" = 7\"}) \/\/ 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC_G, \" = 8\"}) \/\/ 1 MyValueClass1 allocation + 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation\n+    public MyValueClass1 test15(MyValueClass1 vt) {\n+        MyValueClass1 res = test15_helper1(vt);\n+        vt = MyValueClass1.createWithFieldsInline(rI, rL);\n+        test15_helper1(vt);\n+        test15_helper2(vt);\n+        test15_helper3(vt);\n+        vt.dontInline(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        Asserts.assertEQ(test15(testValue1), testValue1);\n+        Asserts.assertEQ(test15(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValueClass2 test16_helper1(boolean b) {\n+        return b ? null : MyValueClass2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    public MyValueClass2 test16_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValueClass2 test16_helper3(boolean b) {\n+        return b ? null : MyValueClass2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of return values\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        counts = {ALLOC_G, \" = 1\"}) \/\/ 1 MyValueClass2Inline allocation\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValueClass2 + 1 MyValueClass2Inline allocation\n+    public MyValueClass2 test16(int c, boolean b) {\n+        MyValueClass2 res = null;\n+        if (c == 1) {\n+            res = test16_helper1(b);\n+        } else if (c == 2) {\n+            res = test16_helper2();\n+        } else if (c == 3) {\n+            res = test16_helper3(b);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        Asserts.assertEQ(test16(0, false), null);\n+        Asserts.assertEQ(test16(1, false).hash(), MyValueClass2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test16(1, true), null);\n+        Asserts.assertEQ(test16(2, false), null);\n+        Asserts.assertEQ(test16(3, false).hash(), MyValueClass2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test16(3, true), null);\n+    }\n+\n+    static primitive class MyPrimitive17 {\n+        MyValueClass1 nonFlattened;\n+\n+        public MyPrimitive17(MyValueClass1 val) {\n+            this.nonFlattened = val;\n+        }\n+    }\n+\n+    static value class MyValue17 {\n+        MyPrimitive17 flattened;\n+\n+        public MyValue17(boolean b) {\n+            this.flattened = new MyPrimitive17(b ? null : testValue1);\n+        }\n+    }\n+\n+    @DontCompile\n+    public MyValue17 test17_interpreted(boolean b1, boolean b2) {\n+        return b1 ? null : new MyValue17(b2);\n+    }\n+\n+    @DontInline\n+    public MyValue17 test17_compiled(boolean b1, boolean b2) {\n+        return b1 ? null : new MyValue17(b2);\n+    }\n+\n+    MyValue17 test17_field1;\n+    MyValue17 test17_field2;\n+\n+    \/\/ Test handling of null when mixing value and primitive classes\n+    @Test\n+    public MyValue17 test17(boolean b1, boolean b2) {\n+        MyValue17 ret = test17_interpreted(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test17 failed\");\n+        }\n+        test17_field1 = ret;\n+        ret = test17_compiled(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test17 failed\");\n+        }\n+        test17_field2 = ret;\n+        return ret;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        MyValue17 vt = new MyValue17(false);\n+        Asserts.assertEquals(test17(true, false), null);\n+        Asserts.assertEquals(test17_field1, null);\n+        Asserts.assertEquals(test17_field2, null);\n+        Asserts.assertEquals(test17(false, false), vt);\n+        Asserts.assertEquals(test17_field1, vt);\n+        Asserts.assertEquals(test17_field2, vt);\n+        vt = new MyValue17(true);\n+        Asserts.assertEquals(test17(true, true), null);\n+        Asserts.assertEquals(test17_field1, null);\n+        Asserts.assertEquals(test17_field2, null);\n+        Asserts.assertEquals(test17(false, true), vt);\n+        Asserts.assertEquals(test17_field1, vt);\n+        Asserts.assertEquals(test17_field2, vt);\n+    }\n+\n+    \/\/ Uses all registers available for returning values on x86_64\n+    static value class UseAllRegs {\n+        long l1;\n+        long l2;\n+        long l3;\n+        long l4;\n+        long l5;\n+        long l6;\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+        double d6;\n+        double d7;\n+        double d8;\n+\n+        @ForceInline\n+        public UseAllRegs(long l1, long l2, long l3, long l4, long l5, long l6,\n+                          double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8) {\n+            this.l1 = l1;\n+            this.l2 = l2;\n+            this.l3 = l3;\n+            this.l4 = l4;\n+            this.l5 = l5;\n+            this.l6 = l6;\n+            this.d1 = d1;\n+            this.d2 = d2;\n+            this.d3 = d3;\n+            this.d4 = d4;\n+            this.d5 = d5;\n+            this.d6 = d6;\n+            this.d7 = d7;\n+            this.d8 = d8;\n+        }\n+    }\n+\n+    @DontInline\n+    public UseAllRegs test18_helper1(UseAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    @DontCompile\n+    public UseAllRegs test18_helper2(UseAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    static boolean test18_b;\n+\n+    \/\/ Methods with no arguments (no stack slots reserved for incoming args)\n+    @DontInline\n+    public static UseAllRegs test18_helper3() {\n+        return test18_b ? null : new UseAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12, rL + 13, rL + 14);\n+    }\n+\n+    @DontCompile\n+    public static UseAllRegs test18_helper4() {\n+        return test18_b ? null : test18_helper3();\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    public UseAllRegs test18(boolean b, long val1, long l1, long val2, long l2, long val3, long l3, long val4, long l4, long val5, long l5, long val6, long l6,\n+                             long val7, double d1, long val8, double d2, long val9, double d3, long val10, double d4, long val11, double d5, long val12, double d6, long val13, double d7, long val14, double d8, long val15) {\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        UseAllRegs val = b ? null : new UseAllRegs(l1, l2, l3, l4, l5, l6, d1, d2, d3, d4, d5, d6, d7, d8);\n+        val = test18_helper1(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        val = test18_helper2(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        Asserts.assertEquals(test18_helper3(), val);\n+        Asserts.assertEquals(test18_helper4(), val);\n+        return val;\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        UseAllRegs val = new UseAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12, rL + 13, rL + 14);\n+        test18_b = false;\n+        Asserts.assertEquals(test18(false, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL, rL + 6,\n+                                    rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL + 13, rL, rL + 14, rL), val);\n+        test18_b = true;\n+        Asserts.assertEquals(test18(true, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL, rL + 6,\n+                                    rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL + 13, rL, rL + 14, rL), null);\n+    }\n+\n+    @DontInline\n+    static public UseAllRegs test19_helper() {\n+        return new UseAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12, rL + 13, rL + 14);\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    static public void test19(long a, long b, long c, long d, long e, long f) {\n+        if (test19_helper() == null) {\n+            throw new RuntimeException(\"test19 failed: Unexpected null\");\n+        }\n+        if ((a & b & c & d & e & f) != 0) {\n+            throw new RuntimeException(\"test19 failed: Unexpected argument values\");\n+        }\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        test19(0, 0, 0, 0, 0, 0);\n+    }\n+\n+    \/\/ Uses almost all registers available for returning values on x86_64\n+    static value class UseAlmostAllRegs {\n+        long l1;\n+        long l2;\n+        long l3;\n+        long l4;\n+        long l5;\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+        double d6;\n+        double d7;\n+\n+        @ForceInline\n+        public UseAlmostAllRegs(long l1, long l2, long l3, long l4, long l5,\n+                                double d1, double d2, double d3, double d4, double d5, double d6, double d7) {\n+            this.l1 = l1;\n+            this.l2 = l2;\n+            this.l3 = l3;\n+            this.l4 = l4;\n+            this.l5 = l5;\n+            this.d1 = d1;\n+            this.d2 = d2;\n+            this.d3 = d3;\n+            this.d4 = d4;\n+            this.d5 = d5;\n+            this.d6 = d6;\n+            this.d7 = d7;\n+        }\n+    }\n+\n+    @DontInline\n+    public UseAlmostAllRegs test20_helper1(UseAlmostAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    @DontCompile\n+    public UseAlmostAllRegs test20_helper2(UseAlmostAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    static boolean test20_b;\n+\n+    \/\/ Methods with no arguments (no stack slots reserved for incoming args)\n+    @DontInline\n+    public static UseAlmostAllRegs test20_helper3() {\n+        return test20_b ? null : new UseAlmostAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12);\n+    }\n+\n+    @DontCompile\n+    public static UseAlmostAllRegs test20_helper4() {\n+        return test20_b ? null : test20_helper3();\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    public UseAlmostAllRegs test20(boolean b, long val1, long l1, long val2, long l2, long val3, long l3, long val4, long l4, long val5, long l5, long val6,\n+                                   long val7, double d1, long val8, double d2, long val9, double d3, long val10, double d4, long val11, double d5, long val12, double d6, long val13, double d7, long val14, long val15) {\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        UseAlmostAllRegs val = b ? null : new UseAlmostAllRegs(l1, l2, l3, l4, l5, d1, d2, d3, d4, d5, d6, d7);\n+        val = test20_helper1(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        val = test20_helper2(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        Asserts.assertEquals(test20_helper3(), val);\n+        Asserts.assertEquals(test20_helper4(), val);\n+        return val;\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        UseAlmostAllRegs val = new UseAlmostAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12);\n+        test20_b = false;\n+        Asserts.assertEquals(test20(false, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL,\n+                                    rL, rL + 6, rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL), val);\n+        test20_b = true;\n+        Asserts.assertEquals(test20(true, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL,\n+                                    rL, rL + 6, rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL), null);\n+    }\n+\n+    @DontInline\n+    static public UseAlmostAllRegs test21_helper() {\n+        return new UseAlmostAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12);\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    static public void test21(long a, long b, long c, long d, long e, long f) {\n+        if (test21_helper() == null) {\n+            throw new RuntimeException(\"test21 failed: Unexpected null\");\n+        }\n+        if ((a & b & c & d & e & f) != 0) {\n+            throw new RuntimeException(\"test21 failed: Unexpected argument values\");\n+        }\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        test21(0, 0, 0, 0, 0, 0);\n+    }\n+\n+    static value class ManyOopsValue {\n+        Integer i1 = 1;\n+        Integer i2 = 2;\n+        Integer i3 = 3;\n+        Integer i4 = 4;\n+        Integer i5 = 5;\n+        Integer i6 = 6;\n+        Integer i7 = 7;\n+        Integer i8 = 8;\n+        Integer i9 = 9;\n+        Integer i10 = 10;\n+        Integer i11 = 11;\n+        Integer i12 = 12;\n+        Integer i13 = 13;\n+        Integer i14 = 14;\n+        Integer i15 = 15;\n+\n+        @DontInline\n+        public int sum() {\n+            return i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 + i13 + i14 + i15;\n+        }\n+    }\n+\n+    \/\/ Verify that C2 scratch buffer size is large enough to hold many GC barriers used by the entry points\n+    @Test\n+    static public int test22(ManyOopsValue val) {\n+        return val.sum();\n+    }\n+\n+    @Run(test = \"test22\")\n+    @Warmup(10_000)\n+    public void test22_verifier() {\n+        Asserts.assertEquals(test22(new ManyOopsValue()), 120);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":958,"deletions":0,"binary":false,"changes":958,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler\/valhalla\/inlinetypes;\n+\n+public final primitive value class FooValue\n+    version 65:0\n+{\n+    public final Field x:I;\n+    public final Field y:I;\n+\n+    \/\/ escape with putstatic\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test1:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; putstatic TestWithfieldC1.foo_static:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape with putfield\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test2:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_1;\n+        aload_1; iconst_1; withfield FooValue.x:I; astore_1;\n+        aload_1; iconst_1; withfield FooValue.y:I; astore_1;\n+\n+        aload_0; aload_1; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_1; areturn;\n+    }\n+\n+    \/\/ escape with function call\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test3:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape and then branch backwards\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test4:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        iconst_1; istore_1;\n+\n+        loop: stack_frame_type append; locals_map class \"Qcompiler\/valhalla\/inlinetypes\/FooValue;\", int;\n+            \/\/ iterate two times\n+            iload_1; iconst_2; if_icmpgt end;\n+\n+            aload_0; iload_1; withfield x:I; astore_0;\n+            aload_0; iload_1; withfield y:I; astore_0;\n+\n+            aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+            iinc 1,1; goto loop;\n+\n+        end: stack_frame_type same;\n+            aload_0; areturn;\n+    }\n+\n+    \/\/ escape using a different local variable\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test5:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        aconst_init FooValue; astore_1;\n+        aload_0; astore_1;\n+\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_1; areturn;\n+    }\n+\n+    \/\/ escape using aastore\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test6:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 3 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        getstatic TestWithfieldC1.foo_static_arr:\"[Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+        iconst_0; aload_0; aastore;\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ Copying a value into different local slots -- disable withfield optimization\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test7:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n+        aconst_init FooValue; astore_0;\n+        aconst_init FooValue; astore_1;\n+        aload_0; astore_1;\n+\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_0; areturn;\n+    }\n+\n+    \/\/ escape by invoking non-static method\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test8:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n+        aconst_init FooValue; astore_0;\n+        aload_0; iconst_1; withfield x:I; astore_0;\n+        aload_0; iconst_1; withfield y:I; astore_0;\n+\n+        aload_0; invokevirtual non_static_method:\"()V\";\n+\n+        aload_0; iconst_2; withfield x:I; astore_0;\n+        aload_0; iconst_2; withfield y:I; astore_0;\n+\n+        aload_0; areturn;\n+    }\n+\n+    @+compiler\/lib\/ir_framework\/DontInline{}\n+    private Method non_static_method:\"()V\" stack 1 {\n+        aload_0;\n+        invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n+        return;\n+    }\n+\n+    \/\/ duplicate reference with local variables\n+    @+compiler\/lib\/ir_framework\/ForceInline{}\n+    static Method test9:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 3 {\n+        aconst_init FooValue; astore_1;\n+        aload_1; iconst_1; withfield x:I; astore_1;\n+        aload_1; iconst_1; withfield y:I; astore_1;\n+\n+        aload_1; astore_2;\n+\n+        aload_1; iconst_2; withfield x:I; astore_1;\n+        aload_1; iconst_2; withfield y:I; astore_1;\n+\n+        aload_2; iconst_3; withfield x:I; astore_2;\n+        aload_2; iconst_3; withfield y:I; astore_2;\n+\n+        aload_0; aload_2; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n+\n+        aload_1; areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1Classes.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -165,1 +165,1 @@\n-        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s*\\\\[Verified Entry Point\\\\]\\\\s*  # \\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n+        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s[^{]+\\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ These classes are based on the following source.  The return type of factory\n+\/\/ method <vnew> in class HiddenPoint was changed to java.lang.Object because\n+\/\/ HiddenPoint will be defined as an inline hidden class.\n+\/\/\n+\/\/  inline class HiddenPoint {\n+\/\/      int x;\n+\/\/      int y;\n+\/\/\n+\/\/      HiddenPoint() {\n+\/\/          this.x = 0;\n+\/\/          this.y = 0;\n+\/\/      }\n+\/\/      public String getValue() {\n+\/\/          return \"x: \" + x + \", y: \" + y;\n+\/\/      }\n+\/\/  }\n+\n+class HiddenPoint {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [40] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"HiddenPoint\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1B\n+    NameAndType #5 #6; \/\/ #4     at 0x20\n+    Utf8 \"x\"; \/\/ #5     at 0x25\n+    Utf8 \"I\"; \/\/ #6     at 0x29\n+    Field #1 #8; \/\/ #7     at 0x2D\n+    NameAndType #9 #6; \/\/ #8     at 0x32\n+    Utf8 \"y\"; \/\/ #9     at 0x37\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x3B\n+    NameAndType #12 #13; \/\/ #11     at 0x40\n+    Utf8 \"makeConcatWithConstants\"; \/\/ #12     at 0x45\n+    Utf8 \"(II)Ljava\/lang\/String;\"; \/\/ #13     at 0x5F\n+    class #15; \/\/ #14     at 0x78\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15     at 0x7B\n+    Utf8 \"getValue\"; \/\/ #16     at 0x8E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #17     at 0x99\n+    Utf8 \"Code\"; \/\/ #18     at 0xB0\n+    Utf8 \"LineNumberTable\"; \/\/ #19     at 0xB7\n+    Utf8 \"<vnew>\"; \/\/ #20     at 0xC9\n+    Utf8 \"()Ljava\/lang\/Object;\"; \/\/ #21     at 0xD2\n+    Utf8 \"SourceFile\"; \/\/ #22     at 0xE4\n+    Utf8 \"HiddenPoint.java\"; \/\/ #23     at 0xF1\n+    Utf8 \"BootstrapMethods\"; \/\/ #24     at 0x0104\n+    MethodHandle 6b #26; \/\/ #25     at 0x0117\n+    Method #27 #28; \/\/ #26     at 0x011B\n+    class #29; \/\/ #27     at 0x0120\n+    NameAndType #12 #30; \/\/ #28     at 0x0123\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\"; \/\/ #29     at 0x0128\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #30     at 0x014F\n+    String #32; \/\/ #31     at 0x01EA\n+    Utf8 \"x: , y: \"; \/\/ #32     at 0x01ED\n+    Utf8 \"InnerClasses\"; \/\/ #33     at 0x01FA\n+    class #35; \/\/ #34     at 0x0209\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #35     at 0x020C\n+    class #37; \/\/ #36     at 0x0234\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #37     at 0x0237\n+    Utf8 \"Lookup\"; \/\/ #38     at 0x0258\n+    Utf8 \"Preload\"; \/\/ #39     at 0x0261\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_VALUE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0x0275\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x027D\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index       : y\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0287\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index       : getValue\n+      #17; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#18, 38) { \/\/ Code at 0x028F\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[14]{\n+            0x2AB400032AB40007;\n+            0xBA000A0000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#19, 6) { \/\/ LineNumberTable at 0x02AF\n+              [1] { \/\/ line_number_table\n+                0  10; \/\/  at 0x02BB\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x02BB\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index       : <vnew>\n+      #21; \/\/ descriptor_index : ()LHiddenPoint;\n+      [1] { \/\/ Attributes\n+        Attr(#18, 56) { \/\/ Code at 0x02C3\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#19, 18) { \/\/ LineNumberTable at 0x02E9\n+              [4] { \/\/ line_number_table\n+                0  5; \/\/  at 0x02F5\n+                4  6; \/\/  at 0x02F9\n+                11  7; \/\/  at 0x02FD\n+                18  8; \/\/  at 0x0301\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#22, 2) { \/\/ SourceFile at 0x0303\n+      #23;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#24, 8) { \/\/ BootstrapMethods at 0x030B\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [1] { \/\/ bootstrap_arguments\n+            #31; \/\/  at 0x0319\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#33, 10) { \/\/ InnerClasses at 0x0319\n+      [1] { \/\/ classes\n+        #34 #36 #38 25; \/\/  at 0x0329\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#39, 4) { \/\/ Preload at 0x0329\n+      0x00010001;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class HiddenPoint\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This class provides two static methods equivalent to this Java source code:\n+ * void createArray0() {\n+ *     Element0 array = new Element0[10][10]; \/\/ Element0 is expected to be an inline type\n+ * }\n+ * void createArray1() {\n+ *     Element1 array = new Element1[10][10]; \/\/ Element1 is expected to be a reference type\n+ * }\n+ *\/\n+\n+class MultiANewArrayTypeCheck {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"[[QElement0;\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"[[LElement1;\"; \/\/ #10\n+    class #12; \/\/ #11\n+    Utf8 \"MultiANewArrayTypeCheck\"; \/\/ #12\n+    Utf8 \"Code\"; \/\/ #13\n+    Utf8 \"LineNumberTable\"; \/\/ #14\n+    Utf8 \"createArray0\"; \/\/ #15\n+    Utf8 \"createArray1\"; \/\/ #16\n+    Utf8 \"SourceFile\"; \/\/ #17\n+    Utf8 \"MultiANewArrayTypeCheck.java\"; \/\/ #18\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #11;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x100A100AC5000702;\n+            0x4BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                9  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #16; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x100A100AC5000902;\n+            0x4BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                9  9;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#17) { \/\/ SourceFile\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MultiANewArrayTypeCheck\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTypeCheck.jcod","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/TestPrimitiveClass\n+    version 65:0\n+{\n+    final Field nullableField:   \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+    final Field nullfreeField:   \"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ flattened\n+    final Field nullField:       \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ src of null\n+    final Field nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ not flattened\n+    final Field nullBigField:    \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ src of null\n+\n+    public Method withNullableField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullableField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        areturn;\n+    }\n+\n+    public Method withNullfreeField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullfreeField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        areturn;\n+    }\n+\n+    public Method withNullfreeBigField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+        stack 2\n+    {\n+        aload_0;\n+        aload_1;\n+        withfield nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\";\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullabilityClasses.jasm","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClass version 65:0 {\n+\n+    Field field:\"Qruntime\/valhalla\/inlinetypes\/MyValue;\";\n+\n+    public Method \"<init>\":\"()V\"\n+      stack 1 locals 1\n+    {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public Method test:\"()V\" stack 2 locals 1 {\n+        aload_0;\n+        aconst_null;\n+        putfield Field field:\"Qruntime\/valhalla\/inlinetypes\/MyValue;\";\n+        return;\n+    }\n+}\n+\n+super public final class runtime\/valhalla\/inlinetypes\/MyValue version 65:0 {\n+    Field foo:I = 42;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchClasses.jasm","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The test class is based in the Java source code below, but the constant\n+\/\/ pool entry #33 (used by the Preload attribute) has been modified to\n+\/\/ contain the name of a non-existing class.\n+\/\/\n+\/\/ public class ValuePreloadClient1 {\n+\/\/     PreloadValue0 value;\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         System.out.print(\"Success\");\n+\/\/     }\n+\/\/ }\n+\n+ class ValuePreloadClient1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/System\"; \/\/ #10\n+    Utf8 \"out\"; \/\/ #11\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"Success\"; \/\/ #14\n+    Method #16 #17; \/\/ #15\n+    class #18; \/\/ #16\n+    NameAndType #19 #20; \/\/ #17\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18\n+    Utf8 \"print\"; \/\/ #19\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"ValuePreloadClient1\"; \/\/ #22\n+    Utf8 \"value\"; \/\/ #23\n+    Utf8 \"LPreloadValue0;\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"main\"; \/\/ #27\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"ValuePreloadClient1.java\"; \/\/ #30\n+    Utf8 \"Preload\"; \/\/ #31\n+    class #33; \/\/ #32\n+    Utf8 \"PreloadValue1\"; \/\/ #33\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#31) { \/\/ Preload\n+      0x00010020;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class ValuePreloadClient1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadClient1.jcod","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldOwner\n+    version 65:0\n+{\n+    NestHost runtime\/valhalla\/inlinetypes\/WithFieldNestHost;\n+\n+    public final Field c:C;\n+    protected final Field l:J;\n+    final Field d:D;\n+    private final Field i:I;\n+\n+    public Method checkFields:\"(CJDI)V\" stack 4 {\n+        aload_0;\n+        getfield c:C;\n+        invokestatic java\/lang\/Character.valueOf:\"(C)Ljava\/lang\/Character;\";\n+        iload_1;\n+        invokestatic java\/lang\/Character.valueOf:\"(C)Ljava\/lang\/Character;\";\n+        ldc \"unexpected c value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield l:J;\n+        invokestatic java\/lang\/Long.valueOf:\"(J)Ljava\/lang\/Long;\";\n+        lload_2;\n+        invokestatic java\/lang\/Long.valueOf:\"(J)Ljava\/lang\/Long;\";\n+        ldc \"unexpected l value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield d:D;\n+        invokestatic java\/lang\/Double.valueOf:\"(D)Ljava\/lang\/Double;\";\n+        dload 4;\n+        invokestatic java\/lang\/Double.valueOf:\"(D)Ljava\/lang\/Double;\";\n+        ldc \"unexpected d value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield i:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload 6;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"unexpected i value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        return;\n+    }\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldNestmate\n+    version 65:0\n+{\n+    NestHost runtime\/valhalla\/inlinetypes\/WithFieldNestHost;\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldNestHost\n+    version 65:0\n+{\n+    NestMembers runtime\/valhalla\/inlinetypes\/WithFieldOwner, runtime\/valhalla\/inlinetypes\/WithFieldNestmate;\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldSamePackage\n+    version 65:0\n+{\n+\n+    public static Method withC:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;C)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.c:C;\n+        areturn;\n+    }\n+\n+    public static Method withL:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;J)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        lload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.l:J;\n+        areturn;\n+    }\n+\n+    public static Method withD:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;D)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 3\n+    {\n+        aload_0;\n+        dload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.d:D;\n+        areturn;\n+    }\n+\n+    public static Method withI:\"(Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;I)Qruntime\/valhalla\/inlinetypes\/WithFieldOwner;\"\n+        stack 2\n+    {\n+        aload_0;\n+        iload_1;\n+        withfield runtime\/valhalla\/inlinetypes\/WithFieldOwner.i:I;\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTestClasses.jasm","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/WithFieldPoint\n+    version 65:0\n+{\n+\n+    private final Field x:I;\n+    private final Field y:I;\n+\n+    public static Method make:\"(II)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\"\n+        stack 4\n+    {\n+        aconst_init runtime\/valhalla\/inlinetypes\/WithFieldPoint;\n+        dup;\n+        iconst_0;\n+        iconst_0;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        iload_0;\n+        withfield x:I;\n+        dup;\n+        iload_0;\n+        iconst_0;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        iload_1;\n+        withfield y:I;\n+        dup;\n+        iload_0;\n+        iload_1;\n+        invokevirtual checkFields:\"(II)V\";\n+\n+        areturn;\n+    }\n+\n+    public Method getX:\"()I\" stack 1 {\n+        aload_0;\n+        getfield x:I;\n+        ireturn;\n+    }\n+\n+    public Method getY:\"()I\" stack 1 {\n+        aload_0;\n+        getfield y:I;\n+        ireturn;\n+    }\n+\n+    public Method withX:\"(I)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield x:I;\n+        areturn;\n+    }\n+\n+    public Method withY:\"(I)Qruntime\/valhalla\/inlinetypes\/WithFieldPoint;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield y:I;\n+        areturn;\n+    }\n+\n+    public Method checkFields:\"(II)V\" stack 3 {\n+        aload_0;\n+        getfield x:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload_1;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"invalid x value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        aload_0;\n+        getfield y:I;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        iload_2;\n+        invokestatic java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        ldc \"invalid y value\";\n+        invokestatic jdk\/test\/lib\/Asserts.assertEquals:\"(Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/String;)V\";\n+\n+        return;\n+    }\n+\n+}\n+\n+public final primitive value class runtime\/valhalla\/inlinetypes\/AllTypes\n+    version 65:0\n+{\n+\n+    public final Field z:Z;\n+    public final Field b:B;\n+    public final Field s:S;\n+    public final Field c:C;\n+    public final Field i:I;\n+    public final Field l:J;\n+    public final Field f:F;\n+    public final Field d:D;\n+    public final Field o:\"Ljava\/lang\/Object;\";\n+    public final Field p:\"Qruntime\/valhalla\/inlinetypes\/Point;\";\n+\n+    public Method set_z:\"(Z)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield z:Z;\n+        areturn;\n+    }\n+\n+    public Method set_b:\"(B)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield b:B;\n+        areturn;\n+    }\n+\n+    public Method set_s:\"(S)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield s:S;\n+        areturn;\n+    }\n+\n+    public Method set_c:\"(C)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield c:C;\n+        areturn;\n+    }\n+\n+    public Method set_i:\"(I)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        withfield i:I;\n+        areturn;\n+    }\n+\n+    public Method set_l:\"(J)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 3 {\n+        aload_0;\n+        lload_1;\n+        withfield l:J;\n+        areturn;\n+    }\n+\n+    public Method set_f:\"(F)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        fload_1;\n+        withfield f:F;\n+        areturn;\n+    }\n+\n+    public Method set_d:\"(D)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 3 {\n+        aload_0;\n+        dload_1;\n+        withfield d:D;\n+        areturn;\n+    }\n+\n+    public Method set_o:\"(Ljava\/lang\/Object;)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        aload_1;\n+        withfield o:\"Ljava\/lang\/Object;\";\n+        areturn;\n+    }\n+\n+    public Method set_p:\"(Qruntime\/valhalla\/inlinetypes\/Point;)Qruntime\/valhalla\/inlinetypes\/AllTypes;\" stack 2 {\n+        aload_0;\n+        aload_1;\n+        withfield p:\"Qruntime\/valhalla\/inlinetypes\/Point;\";\n+        areturn;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldTestClasses.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,581 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ These tests are based on this .java file.  Each test case changed an access\n+\/\/ flag to cause a ClassFormatError exception when loading the class.\n+\/*\n+public abstract value class AbstractV {\n+\n+    static int x = 3;\n+\n+    public static synchronized void meth() {\n+        System.out.println(\"hi\");\n+    }\n+}\n+*\/\n+\n+\/\/ Removed ACC_STATIC from field access flags.\n+class AbstractVField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVField\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVField.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0441; \/\/ access [ ACC_PUBLIC ACC_ABSTRACT ACC_VALUE ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0000; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVField\n+\n+\n+\/\/ Added ACC_FINAL to class access flags.\n+class AbstractVFinal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVFinal\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVFinal.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0451; \/\/ access [ ACC_FINAL ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVFinal\n+\n+\n+\/\/ Added ACC_INTERFACE to class access flags\n+class AbstractVintf {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVintf\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVintf.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0641; \/\/ access [ ACC_INTERFACE ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0029; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVintf\n+\n+\n+\/\/ Changed the access flags for synchronized method meth() to not be static.\n+class AbstractVMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"AbstractVMethod\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"AbstractVMethod.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0441; \/\/ access [ ACC_PUBLIC ACC_VALUE ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x016F\n+      0x0021; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractVMethod\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCCFETests.jcod","additions":581,"deletions":0,"binary":false,"changes":581,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This is an abstract class that cannot be a super class for value classes\n+\/\/ because ACC_IDENTITY is set in its class access flags.\n+\/\/ It's based on the following source:\n+\/*\n+public abstract class NonPVSuper {\n+\n+    static int x = 3;\n+\n+    public static void meth() {\n+        System.out.println(\"hi\");\n+    }\n+}\n+*\/\n+class NonPVSuper {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [33] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"hi\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x7F\n+    class #18; \/\/ #16     at 0x84\n+    NameAndType #19 #20; \/\/ #17     at 0x87\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x8C\n+    Utf8 \"println\"; \/\/ #19     at 0xA2\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xAC\n+    Field #22 #23; \/\/ #21     at 0xC4\n+    class #24; \/\/ #22     at 0xC9\n+    NameAndType #25 #26; \/\/ #23     at 0xCC\n+    Utf8 \"NonPVSuper\"; \/\/ #24     at 0xD1\n+    Utf8 \"x\"; \/\/ #25     at 0xDE\n+    Utf8 \"I\"; \/\/ #26     at 0xE2\n+    Utf8 \"Code\"; \/\/ #27     at 0xE6\n+    Utf8 \"LineNumberTable\"; \/\/ #28     at 0xED\n+    Utf8 \"meth\"; \/\/ #29     at 0xFF\n+    Utf8 \"<clinit>\"; \/\/ #30     at 0x0106\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x0111\n+    Utf8 \"NonPVSuper.java\"; \/\/ #32     at 0x011E\n+  } \/\/ Constant Pool\n+\n+  0x0421; \/\/ access [ ACC_PUBLIC ACC_IDENTITY ACC_ABSTRACT ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x013A\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index       : x\n+      #26; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0144\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x014C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x0163\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016F\n+      0x0009; \/\/ access\n+      #29; \/\/ name_index       : meth\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 37) { \/\/ Code at 0x0177\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 10) { \/\/ LineNumberTable at 0x0192\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x019E\n+                8  8; \/\/  at 0x01A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x01A2\n+      0x0008; \/\/ access\n+      #30; \/\/ name_index       : <clinit>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#27, 29) { \/\/ Code at 0x01AA\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[5]{\n+            0x06B30015B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#28, 6) { \/\/ LineNumberTable at 0x01C1\n+              [1] { \/\/ line_number_table\n+                0  4; \/\/  at 0x01CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x01CF\n+      #32;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NonPVSuper\n+\n+\n+\/\/ Dot is a value class that tries to inherit from a super class (NonPVSuper)\n+\/\/ that has access flag ACC_IDENTITY set.\n+\/\/ Dot is based on the following source:\n+\/*\n+public value final class Dot extends NonPVSuper {\n+    int x = 3;\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+class Dot {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [18] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"Dot\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"NonPVSuper\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x35\n+    Utf8 \"()I\"; \/\/ #10     at 0x3C\n+    Utf8 \"Code\"; \/\/ #11     at 0x42\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x49\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x5B\n+    Utf8 \"()LDot;\"; \/\/ #14     at 0x64\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x6E\n+    Utf8 \"Dot.java\"; \/\/ #16     at 0x7B\n+    Utf8 \"Preload\"; \/\/ #17     at 0x86\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9A\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xA4\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xAC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xC3\n+              [1] { \/\/ line_number_table\n+                0  5; \/\/  at 0xCF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xCF\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <vnew>\n+      #14; \/\/ descriptor_index : ()LDot;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 41) { \/\/ Code at 0xD7\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B062A5FCC;\n+            0x00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 10) { \/\/ LineNumberTable at 0xF6\n+              [2] { \/\/ line_number_table\n+                0  1; \/\/  at 0x0102\n+                4  2; \/\/  at 0x0106\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0108\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#17, 4) { \/\/ Preload at 0x0110\n+      0x00010001;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class Dot\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCICCETests.jcod","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,588 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ These test classes contains variations of Q-type signature uses which should\n+ only work with +EnablePrimitiveClasses\n+\n+ The original source with all the illegal cases looks like this, then below\n+ are classes with a single aspect declared (for each line in the prototype\n+ class listed)\n+\n+ public class PrimitiveUsers {\n+    MyPrimitive p;\n+    public static void staticCheckQArg(MyPrimitive p) {}\n+    public static MyPrimitive staticCheckQReturn() { return MyPrimitive.default; }\n+    public void checkQArg(MyPrimitive p) {}\n+    public MyPrimitive checkQReturn() { return MyPrimitive.default; }\n+ }\n+*\/\n+\n+\/\/ Use Q-signature field...\n+\n+class PrimitiveUsersField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveUsersField\"; \/\/ #8\n+    Utf8 \"p\"; \/\/ #9\n+    Utf8 \"QMyPrimitive;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"PrimitiveUsersField.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersField\n+\n+\n+\/\/ Static method q-sig in arg\n+\n+class PrimitiveUsersStaticQArg {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveUsersStaticQArg\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"staticCheckQArg\"; \/\/ #11\n+    Utf8 \"(QMyPrimitive;)V\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"PrimitiveUsersStaticQArg.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersStaticQArg\n+\n+\/\/ Static method q-sig in return\n+\n+class PrimitiveUsersStaticQReturn {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"MyPrimitive\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"PrimitiveUsersStaticQReturn\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"staticCheckQReturn\"; \/\/ #13\n+    Utf8 \"()QMyPrimitive;\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"PrimitiveUsersStaticQReturn.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #9;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index\n+      #14; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xCB0007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersStaticQReturn\n+\n+\/\/ Method with q-sig in arg\n+\n+class PrimitiveUsersQArg {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveUsersQArg\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"checkQArg\"; \/\/ #11\n+    Utf8 \"(QMyPrimitive;)V\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"PrimitiveUsersQArg.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersQArg\n+\n+\/\/ Method with q-sig in return\n+\n+class PrimitiveUsersQReturn {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"MyPrimitive\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"PrimitiveUsersQReturn\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"checkQReturn\"; \/\/ #13\n+    Utf8 \"()QMyPrimitive;\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"PrimitiveUsersQReturn.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #9;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #13; \/\/ name_index\n+      #14; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB0007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveUsersQReturn\n+\n+\n+\/\/ Legal primitive class MyPrimitive for enabled use cases\n+\n+class MyPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"MyPrimitive\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"(I)QMyPrimitive;\"; \/\/ #6\n+    Field #2 #8; \/\/ #7\n+    NameAndType #9 #10; \/\/ #8\n+    Utf8 \"id\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    class #12; \/\/ #11\n+    Utf8 \"java\/lang\/Object\"; \/\/ #12\n+    Utf8 \"()QMyPrimitive;\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"SourceFile\"; \/\/ #16\n+    Utf8 \"MyPrimitive.java\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access\n+  #2;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #13; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x03B800014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00024C1A2B5FCC;\n+            0x00074C2BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#16) { \/\/ SourceFile\n+      #17;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyPrimitive\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/PrimitiveUsers.jcod","additions":588,"deletions":0,"binary":false,"changes":588,"status":"added"},{"patch":"@@ -0,0 +1,2696 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This file contains multiple illegal inline type classes that should cause\n+\/\/ ClassFormatError exceptions when attempted to be loaded.\n+\/\/\n+\/\/ Many of these test were originally generated from this Java file and then\n+\/\/ modified to cause ClassFormatError or ClassCircularityError exceptions.  The\n+\/\/ '(bad)' comments in most of the tests show where the modifications were made.\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_ABSTRACT set.\n+\/\/\n+class ValueAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueAbstract\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueAbstract;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueAbstract\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueAbstract;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueAbstract.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x0C30; \/\/ access [  ACC_PRIMITIVE ACC_ABSTRACT(bad) ACC_SUPER ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueAbstract\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_ENUM set.\n+\/\/\n+class ValueEnum {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueEnum\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueEnum;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueEnum\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueEnum;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueEnum.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x04850; \/\/ access [  ACC_VALUE ACC_PRIMITIVE ACC_ENUM(bad) ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueEnum\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that inline type fields must be final.\n+\/\/\n+class ValueFieldNotFinal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #23; \/\/ #1     at 0x0A\n+    Field #3 #24; \/\/ #2     at 0x0F\n+    class #9; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #25; \/\/ #5     at 0x1C\n+    Field #3 #26; \/\/ #6     at 0x21\n+    class #27; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"ValueFieldNotFinal\"; \/\/ #9     at 0x2E\n+    Utf8 \"ValueTypes\"; \/\/ #10     at 0x36\n+    Utf8 \"LValueFieldNotFinal;\"; \/\/ #11     at 0x43\n+    Utf8 \"int_v\"; \/\/ #12     at 0x4D\n+    Utf8 \"I\"; \/\/ #13     at 0x55\n+    Utf8 \"<init>\"; \/\/ #14     at 0x59\n+    Utf8 \"()V\"; \/\/ #15     at 0x62\n+    Utf8 \"Code\"; \/\/ #16     at 0x68\n+    Utf8 \"LineNumberTable\"; \/\/ #17     at 0x6F\n+    Utf8 \"makeValueFieldNotFinal\"; \/\/ #18     at 0x81\n+    Utf8 \"(I)LValueFieldNotFinal;\"; \/\/ #19     at 0x8D\n+    Utf8 \"<clinit>\"; \/\/ #20     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xA5\n+    Utf8 \"ValueFieldNotFinal.java\"; \/\/ #22     at 0xB2\n+    NameAndType #14 #15; \/\/ #23     at 0xBF\n+    NameAndType #12 #13; \/\/ #24     at 0xC4\n+    NameAndType #18 #19; \/\/ #25     at 0xC9\n+    NameAndType #8 #11; \/\/ #26     at 0xCE\n+    Utf8 \"java\/lang\/Object\"; \/\/ #27     at 0xD3\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF0\n+      0x0118; \/\/ access\n+      #8; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xF8\n+      0x0000; \/\/ access [ Field not ACC_FINAL(bad) ]\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [3] { \/\/ methods\n+    { \/\/ Member at 0x0102\n+      0x0000; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 42) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[10]{\n+            0x2AB700012A04B500;\n+            0x02B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0126\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x0132\n+                4  5; \/\/  at 0x0136\n+                9  6; \/\/  at 0x013A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x013A\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 44) { \/\/ Code at 0x0142\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 14) { \/\/ LineNumberTable at 0x0160\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x016C\n+                4  9; \/\/  at 0x0170\n+                10  10; \/\/  at 0x0174\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0174\n+      0x0008; \/\/ access\n+      #20; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#16, 33) { \/\/ Code at 0x017C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1204B80005B30006;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#17, 6) { \/\/ LineNumberTable at 0x0197\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x01A3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x01A5\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#10, 4) { \/\/ ValueTypes at 0x01AD\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class ValueFieldNotFinal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that class modifiers cannot have both ACC_PRIMITIVE and ACC_INTERFACE set.\n+\/\/\n+class ValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LValueInterface;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x3C\n+    Utf8 \"I\"; \/\/ #11     at 0x44\n+    Utf8 \"<init>\"; \/\/ #12     at 0x48\n+    Utf8 \"()V\"; \/\/ #13     at 0x51\n+    Utf8 \"Code\"; \/\/ #14     at 0x57\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5E\n+    Utf8 \"makeValueInterface\"; \/\/ #16     at 0x70\n+    Utf8 \"(I)LValueInterface;\"; \/\/ #17     at 0x80\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x91\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x9C\n+    Utf8 \"ValueInterface.java\"; \/\/ #20     at 0xA9\n+    NameAndType #12 #13; \/\/ #21     at 0xBA\n+    NameAndType #10 #11; \/\/ #22     at 0xBF\n+    Utf8 \"ValueInterface\"; \/\/ #23     at 0xC4\n+    NameAndType #16 #17; \/\/ #24     at 0xD0\n+    NameAndType #8 #9; \/\/ #25     at 0xD5\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xDA\n+  } \/\/ Constant Pool\n+\n+  0x0A30; \/\/ access [ ACC_PRIMITIVE ACC_INTERFACE(bad) ACC_SUPER ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xF7\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xFF\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0141\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0149\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0167\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0173\n+                4  9; \/\/  at 0x0177\n+                10  10; \/\/  at 0x017B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x01AC\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueInterface\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that inline type instance methods cannot be synchronized.\n+\/\/\n+\/\/ final inline class ValueMethodSynch {\n+\/\/     final int int_v;\n+\/\/\n+\/\/     ValueMethodSynch() { int_v = 1; }\n+\/\/\n+\/\/     int getInt(int x) { return x; }\n+\/\/ }\n+\n+class ValueMethodSynch {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"getInt\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)I\"; \/\/ #10     at 0x39\n+    Utf8 \"Code\"; \/\/ #11     at 0x40\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x47\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x59\n+    Utf8 \"()I\"; \/\/ #14     at 0x64\n+    Utf8 \"equals\"; \/\/ #15     at 0x6A\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x73\n+    Utf8 \"toString\"; \/\/ #17     at 0x8B\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0x96\n+    Utf8 \"<init>\"; \/\/ #19     at 0xAD\n+    Utf8 \"()QValueMethodSynch;\"; \/\/ #20     at 0xB6\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xCD\n+    Utf8 \"ValueMethodSynch.java\"; \/\/ #22     at 0xDA\n+    Utf8 \"ValueMethodSynch\"; \/\/ #23     at 0xF2\n+    NameAndType #7 #8; \/\/ #24     at 0x0105\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010A\n+    MethodHandle 6b #31; \/\/ #26     at 0x011D\n+    NameAndType #13 #32; \/\/ #27     at 0x0121\n+    NameAndType #15 #33; \/\/ #28     at 0x0126\n+    NameAndType #17 #34; \/\/ #29     at 0x012B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0130\n+    Method #35 #36; \/\/ #31     at 0x0143\n+    Utf8 \"(QValueMethodSynch;)I\"; \/\/ #32     at 0x0148\n+    Utf8 \"(QValueMethodSynch;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x0160\n+    Utf8 \"(QValueMethodSynch;)Ljava\/lang\/String;\"; \/\/ #34     at 0x018A\n+    class #37; \/\/ #35     at 0x01B3\n+    NameAndType #38 #42; \/\/ #36     at 0x01B6\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01BB\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01E4\n+    class #44; \/\/ #39     at 0x01FA\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01FD\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x0206\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0215\n+    class #45; \/\/ #43     at 0x028B\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x028E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02B6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02E1\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02EB\n+      0x0020; \/\/ access [ ACC_SYNCHRONIZED(bad) ]\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 26) { \/\/ Code at 0x02F3\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[2]{\n+            0x1BAC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0307\n+              [1] { \/\/ LineNumberTable\n+                0  9; \/\/  at 0x0313\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0313\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031B\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0334\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0340\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x0348\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0362\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x036E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036E\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0376\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x038F\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039B\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A3\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C2\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03CE\n+                4  5; \/\/  at 0x03D2\n+                11  6; \/\/  at 0x03D6\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03D8\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E0\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F0\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F0\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class ValueMethodSynch\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Inline types Circ and Circ2 have fields of each other's type.  This should\n+\/\/ cause a ClassCircularityError exception when one of them is being loaded.\n+\/\/\n+\/\/ The inline types are based on these two Java classes:\n+\/\/\n+\/\/ final inline class Circ {\n+\/\/     static final Circ VT = makeCirc(0x01234567);\n+\/\/     final int int_v;\n+\/\/     final Circ2 v2;\n+\/\/     Circ() {\n+\/\/         int_v = 1;\n+\/\/         v2 = Circ2.default;\n+\/\/     }\n+\/\/     static Circ makeCirc(int x) {\n+\/\/         Circ v = Circ.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/----------------------------------------------------------------\n+\/\/ final inline class Circ2 {\n+\/\/     static final Circ2 VT = makeCirc2('\\u0123');\n+\/\/     final char char_v;\n+\/\/     final Circ vv;\n+\/\/     Circ2() {\n+\/\/         char_v = 'z';\n+\/\/         vv = Circ.default;\n+\/\/     }\n+\/\/     static Circ2 makeCirc2(char c) {\n+\/\/         Circ2 v = Circ2.default;\n+\/\/         v = __WithField(v.char_v, c);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+class Circ {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    class #36; \/\/ #3     at 0x12\n+    Field #1 #37; \/\/ #4     at 0x15\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1A\n+    InvokeDynamic 0s #41; \/\/ #6     at 0x1F\n+    InvokeDynamic 0s #42; \/\/ #7     at 0x24\n+    int 0x01234567; \/\/ #8     at 0x29\n+    Method #1 #43; \/\/ #9     at 0x2E\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCirc;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x49\n+    Utf8 \"I\"; \/\/ #15     at 0x51\n+    Utf8 \"v2\"; \/\/ #16     at 0x55\n+    Utf8 \"QCirc2;\"; \/\/ #17     at 0x5A\n+    Utf8 \"makeCirc\"; \/\/ #18     at 0x65\n+    Utf8 \"(I)QCirc;\"; \/\/ #19     at 0x6F\n+    Utf8 \"Code\"; \/\/ #20     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x82\n+    Utf8 \"hashCode\"; \/\/ #22     at 0x94\n+    Utf8 \"()I\"; \/\/ #23     at 0x9F\n+    Utf8 \"equals\"; \/\/ #24     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xAE\n+    Utf8 \"toString\"; \/\/ #26     at 0xC6\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xD1\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0xE8\n+    Utf8 \"()V\"; \/\/ #29     at 0xF3\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0xF9\n+    Utf8 \"()QCirc;\"; \/\/ #31     at 0x0102\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x010D\n+    Utf8 \"Circ.java\"; \/\/ #33     at 0x011A\n+    Utf8 \"Circ\"; \/\/ #34     at 0x0126\n+    NameAndType #14 #15; \/\/ #35     at 0x012D\n+    Utf8 \"Circ2\"; \/\/ #36     at 0x0132\n+    NameAndType #16 #17; \/\/ #37     at 0x013A\n+    Utf8 \"BootstrapMethods\"; \/\/ #38     at 0x013F\n+    MethodHandle 6b #46; \/\/ #39     at 0x0152\n+    NameAndType #22 #47; \/\/ #40     at 0x0156\n+    NameAndType #24 #48; \/\/ #41     at 0x015B\n+    NameAndType #26 #49; \/\/ #42     at 0x0160\n+    NameAndType #18 #19; \/\/ #43     at 0x0165\n+    NameAndType #12 #13; \/\/ #44     at 0x016A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x016F\n+    Method #50 #51; \/\/ #46     at 0x0182\n+    Utf8 \"(QCirc;)I\"; \/\/ #47     at 0x0187\n+    Utf8 \"(QCirc;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x0193\n+    Utf8 \"(QCirc;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01B1\n+    class #52; \/\/ #50     at 0x01CE\n+    NameAndType #53 #57; \/\/ #51     at 0x01D1\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x01D6\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x01FF\n+    class #59; \/\/ #54     at 0x0215\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0218\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x0221\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x0230\n+    class #60; \/\/ #58     at 0x02A6\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02A9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x02D1\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x02FC\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0304\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030C\n+      0x0010; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0316\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x031E\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x033D\n+              [3] { \/\/ LineNumberTable\n+                0  12; \/\/  at 0x0349\n+                4  13; \/\/  at 0x034D\n+                11  14; \/\/  at 0x0351\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0351\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x0359\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0372\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x037E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x037E\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x0386\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00060000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03A0\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03AC\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03AC\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03B4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00070000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03CD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03D9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03D9\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 33) { \/\/ Code at 0x03E1\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[9]{\n+            0x1208B80009B3000A;\n+            0xB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03FC\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0408\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0408\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 58) { \/\/ Code at 0x0410\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[22]{\n+            0xCB00014B042A5FCC;\n+            0x00024BCB00032A5F;\n+            0xCC00044B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 18) { \/\/ LineNumberTable at 0x0438\n+              [4] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0444\n+                4  7; \/\/  at 0x0448\n+                11  8; \/\/  at 0x044C\n+                20  9; \/\/  at 0x0450\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x0452\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x045A\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x046A\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#38, 6) { \/\/ BootstrapMethods at 0x046A\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #39; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class Circ\n+\n+class Circ2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [60] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #33; \/\/ #1     at 0x0A\n+    Field #1 #34; \/\/ #2     at 0x0D\n+    class #35; \/\/ #3     at 0x12\n+    Field #1 #36; \/\/ #4     at 0x15\n+    InvokeDynamic 0s #39; \/\/ #5     at 0x1A\n+    InvokeDynamic 0s #40; \/\/ #6     at 0x1F\n+    InvokeDynamic 0s #41; \/\/ #7     at 0x24\n+    Method #1 #42; \/\/ #8     at 0x29\n+    Field #1 #43; \/\/ #9     at 0x2E\n+    class #44; \/\/ #10     at 0x33\n+    Utf8 \"VT\"; \/\/ #11     at 0x36\n+    Utf8 \"QCirc2;\"; \/\/ #12     at 0x3B\n+    Utf8 \"char_v\"; \/\/ #13     at 0x45\n+    Utf8 \"C\"; \/\/ #14     at 0x4E\n+    Utf8 \"vv\"; \/\/ #15     at 0x52\n+    Utf8 \"QCirc;\"; \/\/ #16     at 0x57\n+    Utf8 \"makeCirc2\"; \/\/ #17     at 0x60\n+    Utf8 \"(C)QCirc2;\"; \/\/ #18     at 0x6C\n+    Utf8 \"Code\"; \/\/ #19     at 0x79\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0x80\n+    Utf8 \"hashCode\"; \/\/ #21     at 0x92\n+    Utf8 \"()I\"; \/\/ #22     at 0x9D\n+    Utf8 \"equals\"; \/\/ #23     at 0xA3\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAC\n+    Utf8 \"toString\"; \/\/ #25     at 0xC4\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #26     at 0xCF\n+    Utf8 \"<clinit>\"; \/\/ #27     at 0xE6\n+    Utf8 \"()V\"; \/\/ #28     at 0xF1\n+    Utf8 \"<vnew>\"; \/\/ #29     at 0xF7\n+    Utf8 \"()QCirc2;\"; \/\/ #30     at 0x0100\n+    Utf8 \"SourceFile\"; \/\/ #31     at 0x010C\n+    Utf8 \"Circ2.java\"; \/\/ #32     at 0x0119\n+    Utf8 \"Circ2\"; \/\/ #33     at 0x0126\n+    NameAndType #13 #14; \/\/ #34     at 0x012E\n+    Utf8 \"Circ\"; \/\/ #35     at 0x0133\n+    NameAndType #15 #16; \/\/ #36     at 0x013A\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x013F\n+    MethodHandle 6b #45; \/\/ #38     at 0x0152\n+    NameAndType #21 #46; \/\/ #39     at 0x0156\n+    NameAndType #23 #47; \/\/ #40     at 0x015B\n+    NameAndType #25 #48; \/\/ #41     at 0x0160\n+    NameAndType #17 #18; \/\/ #42     at 0x0165\n+    NameAndType #11 #12; \/\/ #43     at 0x016A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #44     at 0x016F\n+    Method #49 #50; \/\/ #45     at 0x0182\n+    Utf8 \"(QCirc2;)I\"; \/\/ #46     at 0x0187\n+    Utf8 \"(QCirc2;Ljava\/lang\/Object;)Z\"; \/\/ #47     at 0x0194\n+    Utf8 \"(QCirc2;)Ljava\/lang\/String;\"; \/\/ #48     at 0x01B3\n+    class #51; \/\/ #49     at 0x01D1\n+    NameAndType #52 #56; \/\/ #50     at 0x01D4\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #51     at 0x01D9\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #52     at 0x0202\n+    class #58; \/\/ #53     at 0x0218\n+    Utf8 \"Lookup\"; \/\/ #54     at 0x021B\n+    Utf8 \"InnerClasses\"; \/\/ #55     at 0x0224\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #56     at 0x0233\n+    class #59; \/\/ #57     at 0x02A9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #58     at 0x02AC\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #59     at 0x02D4\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #10;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x02FF\n+      0x0018; \/\/ access\n+      #11; \/\/ name_cpx\n+      #12; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0307\n+      0x0010; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030F\n+      0x0010; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0319\n+      0x0008; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 45) { \/\/ Code at 0x0321\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 14) { \/\/ LineNumberTable at 0x0340\n+              [3] { \/\/ LineNumberTable\n+                0  12; \/\/  at 0x034C\n+                4  13; \/\/  at 0x0350\n+                11  14; \/\/  at 0x0354\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0354\n+      0x0011; \/\/ access\n+      #21; \/\/ name_cpx\n+      #22; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 31) { \/\/ Code at 0x035C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x0375\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0381\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0381\n+      0x0011; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 32) { \/\/ Code at 0x0389\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00060000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x03A3\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03AF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03AF\n+      0x0011; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 31) { \/\/ Code at 0x03B7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00070000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x03D0\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03DC\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03DC\n+      0x0008; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 34) { \/\/ Code at 0x03E4\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[10]{\n+            0x110123B80008B300;\n+            0x09B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x0400\n+              [1] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x040C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x040C\n+      0x0008; \/\/ access\n+      #29; \/\/ name_cpx\n+      #30; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#19, 59) { \/\/ Code at 0x0414\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B107A2A5F;\n+            0xCC00024BCB00032A;\n+            0x5FCC00044B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 18) { \/\/ LineNumberTable at 0x043D\n+              [4] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0449\n+                4  7; \/\/  at 0x044D\n+                12  8; \/\/  at 0x0451\n+                21  9; \/\/  at 0x0455\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#31, 2) { \/\/ SourceFile at 0x0457\n+      #32;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#55, 10) { \/\/ InnerClasses at 0x045F\n+      [1] { \/\/ InnerClasses\n+        #53 #57 #54 25; \/\/  at 0x046F\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x046F\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class Circ2\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Inline types CircStaticA and CircStaticB have static fields of each other's\n+\/\/ type.  This should cause a ClassCircularityError exception when one of them\n+\/\/ is being loaded.\n+\/\/\n+\/\/ The inline types are based on these two Java classes:\n+\/\/\n+\/\/ final inline class CircStaticA {\n+\/\/     static final CircStaticA VT = makeCircStaticA(0x01234567);\n+\/\/     final int int_v;\n+\/\/     static final CircStaticB v2 = CircStaticB.default;\n+\/\/     CircStaticA() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static CircStaticA makeCircStaticA(int x) {\n+\/\/         CircStaticA v = CircStaticA.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/----------------------------------------------------------------\n+\/\/ final inline class CircStaticB {\n+\/\/     static final CircStaticB VT = makeCircStaticB(0x01234567);\n+\/\/     final int int_v;\n+\/\/     static final CircStaticA v2 = CircStaticA.default;\n+\/\/     CircStaticB() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static CircStaticB makeCircStaticB(int x) {\n+\/\/         CircStaticB v = CircStaticB.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\n+class CircStaticA {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #38; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #39; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1C\n+    int 0x01234567; \/\/ #6     at 0x21\n+    Method #1 #41; \/\/ #7     at 0x26\n+    Field #1 #42; \/\/ #8     at 0x2B\n+    class #43; \/\/ #9     at 0x30\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCircStaticA;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x50\n+    Utf8 \"I\"; \/\/ #15     at 0x58\n+    Utf8 \"v2\"; \/\/ #16     at 0x5C\n+    Utf8 \"QCircStaticB;\"; \/\/ #17     at 0x61\n+    Utf8 \"makeCircStaticA\"; \/\/ #18     at 0x71\n+    Utf8 \"(I)QCircStaticA;\"; \/\/ #19     at 0x83\n+    Utf8 \"Code\"; \/\/ #20     at 0x96\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x9D\n+    Utf8 \"hashCode\"; \/\/ #22     at 0xAF\n+    Utf8 \"()I\"; \/\/ #23     at 0xBA\n+    Utf8 \"equals\"; \/\/ #24     at 0xC0\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xC9\n+    Utf8 \"toString\"; \/\/ #26     at 0xE1\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xEC\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0x0103\n+    Utf8 \"()V\"; \/\/ #29     at 0x010E\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0x0114\n+    Utf8 \"()QCircStaticA;\"; \/\/ #31     at 0x011D\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x012F\n+    Utf8 \"CircStaticA.java\"; \/\/ #33     at 0x013C\n+    Utf8 \"CircStaticA\"; \/\/ #34     at 0x014F\n+    NameAndType #14 #15; \/\/ #35     at 0x015D\n+    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0162\n+    MethodHandle 6b #46; \/\/ #37     at 0x0175\n+    NameAndType #22 #47; \/\/ #38     at 0x0179\n+    NameAndType #24 #48; \/\/ #39     at 0x017E\n+    NameAndType #26 #49; \/\/ #40     at 0x0183\n+    NameAndType #18 #19; \/\/ #41     at 0x0188\n+    NameAndType #12 #13; \/\/ #42     at 0x018D\n+    Utf8 \"CircStaticB\"; \/\/ #43     at 0x0192\n+    NameAndType #16 #17; \/\/ #44     at 0x01A0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x01A5\n+    Method #50 #51; \/\/ #46     at 0x01B8\n+    Utf8 \"(QCircStaticA;)I\"; \/\/ #47     at 0x01BD\n+    Utf8 \"(QCircStaticA;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x01D0\n+    Utf8 \"(QCircStaticA;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01F5\n+    class #52; \/\/ #50     at 0x0219\n+    NameAndType #53 #57; \/\/ #51     at 0x021C\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x0221\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x024A\n+    class #59; \/\/ #54     at 0x0260\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0263\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x026C\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x027B\n+    class #60; \/\/ #58     at 0x02F1\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02F4\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x031C\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x0347\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x034F\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0357\n+      0x0018; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0361\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0369\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0388\n+              [3] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x0394\n+                4  12; \/\/  at 0x0398\n+                11  13; \/\/  at 0x039C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039C\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03A4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03BD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C9\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x03D1\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03EB\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F7\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03FF\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0418\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0424\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0424\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 43) { \/\/ Code at 0x042C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[15]{\n+            0x1206B80007B30008;\n+            0xCB0009B3000AB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 10) { \/\/ LineNumberTable at 0x044D\n+              [2] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0459\n+                8  4; \/\/  at 0x045D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x045D\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0465\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0484\n+              [3] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0490\n+                4  7; \/\/  at 0x0494\n+                11  8; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x049A\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x04A2\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x04B2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#36, 6) { \/\/ BootstrapMethods at 0x04B2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #37; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class CircStaticA\n+\n+class CircStaticB {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [61] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #34; \/\/ #1     at 0x0A\n+    Field #1 #35; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #38; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #39; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #40; \/\/ #5     at 0x1C\n+    int 0x01234567; \/\/ #6     at 0x21\n+    Method #1 #41; \/\/ #7     at 0x26\n+    Field #1 #42; \/\/ #8     at 0x2B\n+    class #43; \/\/ #9     at 0x30\n+    Field #1 #44; \/\/ #10     at 0x33\n+    class #45; \/\/ #11     at 0x38\n+    Utf8 \"VT\"; \/\/ #12     at 0x3B\n+    Utf8 \"QCircStaticB;\"; \/\/ #13     at 0x40\n+    Utf8 \"int_v\"; \/\/ #14     at 0x50\n+    Utf8 \"I\"; \/\/ #15     at 0x58\n+    Utf8 \"v2\"; \/\/ #16     at 0x5C\n+    Utf8 \"QCircStaticA;\"; \/\/ #17     at 0x61\n+    Utf8 \"makeCircStaticB\"; \/\/ #18     at 0x71\n+    Utf8 \"(I)QCircStaticB;\"; \/\/ #19     at 0x83\n+    Utf8 \"Code\"; \/\/ #20     at 0x96\n+    Utf8 \"LineNumberTable\"; \/\/ #21     at 0x9D\n+    Utf8 \"hashCode\"; \/\/ #22     at 0xAF\n+    Utf8 \"()I\"; \/\/ #23     at 0xBA\n+    Utf8 \"equals\"; \/\/ #24     at 0xC0\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xC9\n+    Utf8 \"toString\"; \/\/ #26     at 0xE1\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #27     at 0xEC\n+    Utf8 \"<clinit>\"; \/\/ #28     at 0x0103\n+    Utf8 \"()V\"; \/\/ #29     at 0x010E\n+    Utf8 \"<vnew>\"; \/\/ #30     at 0x0114\n+    Utf8 \"()QCircStaticB;\"; \/\/ #31     at 0x011D\n+    Utf8 \"SourceFile\"; \/\/ #32     at 0x012F\n+    Utf8 \"CircStaticB.java\"; \/\/ #33     at 0x013C\n+    Utf8 \"CircStaticB\"; \/\/ #34     at 0x014F\n+    NameAndType #14 #15; \/\/ #35     at 0x015D\n+    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0162\n+    MethodHandle 6b #46; \/\/ #37     at 0x0175\n+    NameAndType #22 #47; \/\/ #38     at 0x0179\n+    NameAndType #24 #48; \/\/ #39     at 0x017E\n+    NameAndType #26 #49; \/\/ #40     at 0x0183\n+    NameAndType #18 #19; \/\/ #41     at 0x0188\n+    NameAndType #12 #13; \/\/ #42     at 0x018D\n+    Utf8 \"CircStaticA\"; \/\/ #43     at 0x0192\n+    NameAndType #16 #17; \/\/ #44     at 0x01A0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #45     at 0x01A5\n+    Method #50 #51; \/\/ #46     at 0x01B8\n+    Utf8 \"(QCircStaticB;)I\"; \/\/ #47     at 0x01BD\n+    Utf8 \"(QCircStaticB;Ljava\/lang\/Object;)Z\"; \/\/ #48     at 0x01D0\n+    Utf8 \"(QCircStaticB;)Ljava\/lang\/String;\"; \/\/ #49     at 0x01F5\n+    class #52; \/\/ #50     at 0x0219\n+    NameAndType #53 #57; \/\/ #51     at 0x021C\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #52     at 0x0221\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #53     at 0x024A\n+    class #59; \/\/ #54     at 0x0260\n+    Utf8 \"Lookup\"; \/\/ #55     at 0x0263\n+    Utf8 \"InnerClasses\"; \/\/ #56     at 0x026C\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #57     at 0x027B\n+    class #60; \/\/ #58     at 0x02F1\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #59     at 0x02F4\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #60     at 0x031C\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ fields\n+    { \/\/ Member at 0x0347\n+      0x0018; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x034F\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0357\n+      0x0018; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0361\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0369\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C1A2B5FCC;\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0388\n+              [3] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x0394\n+                4  12; \/\/  at 0x0398\n+                11  13; \/\/  at 0x039C\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039C\n+      0x0011; \/\/ access\n+      #22; \/\/ name_cpx\n+      #23; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03A4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03BD\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C9\n+      0x0011; \/\/ access\n+      #24; \/\/ name_cpx\n+      #25; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 32) { \/\/ Code at 0x03D1\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x03EB\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F7\n+      0x0011; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 31) { \/\/ Code at 0x03FF\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 6) { \/\/ LineNumberTable at 0x0418\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0424\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0424\n+      0x0008; \/\/ access\n+      #28; \/\/ name_cpx\n+      #29; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 43) { \/\/ Code at 0x042C\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[15]{\n+            0x1206B80007B30008;\n+            0xCB0009B3000AB1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 10) { \/\/ LineNumberTable at 0x044D\n+              [2] { \/\/ LineNumberTable\n+                0  2; \/\/  at 0x0459\n+                8  4; \/\/  at 0x045D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x045D\n+      0x0008; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#20, 45) { \/\/ Code at 0x0465\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#21, 14) { \/\/ LineNumberTable at 0x0484\n+              [3] { \/\/ LineNumberTable\n+                0  6; \/\/  at 0x0490\n+                4  7; \/\/  at 0x0494\n+                11  8; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#32, 2) { \/\/ SourceFile at 0x049A\n+      #33;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#56, 10) { \/\/ InnerClasses at 0x04A2\n+      [1] { \/\/ InnerClasses\n+        #54 #58 #55 25; \/\/  at 0x04B2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#36, 6) { \/\/ BootstrapMethods at 0x04B2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #37; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class CircStaticB\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that an inline type cannot be Cloneable.\n+\/\/\n+\/\/ final inline class ValueCloneable implements Cloneable {\n+\/\/    final int field;\n+\/\/    private ValueCloneable() { field = 0; }\n+\/\/}\n+\n+class ValueCloneable {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #22; \/\/ #1     at 0x0A\n+    Field #1 #23; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #26; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #27; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #28; \/\/ #5     at 0x1C\n+    class #29; \/\/ #6     at 0x21\n+    class #30; \/\/ #7     at 0x24\n+    Utf8 \"field\"; \/\/ #8     at 0x27\n+    Utf8 \"I\"; \/\/ #9     at 0x2F\n+    Utf8 \"hashCode\"; \/\/ #10     at 0x33\n+    Utf8 \"()I\"; \/\/ #11     at 0x3E\n+    Utf8 \"Code\"; \/\/ #12     at 0x44\n+    Utf8 \"LineNumberTable\"; \/\/ #13     at 0x4B\n+    Utf8 \"equals\"; \/\/ #14     at 0x5D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #15     at 0x66\n+    Utf8 \"toString\"; \/\/ #16     at 0x7E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #17     at 0x89\n+    Utf8 \"<vnew>\"; \/\/ #18     at 0xA0\n+    Utf8 \"()QValueCloneable;\"; \/\/ #19     at 0xA9\n+    Utf8 \"SourceFile\"; \/\/ #20     at 0xBE\n+    Utf8 \"ValueCloneable.java\"; \/\/ #21     at 0xCB\n+    Utf8 \"ValueCloneable\"; \/\/ #22     at 0xE1\n+    NameAndType #8 #9; \/\/ #23     at 0xF2\n+    Utf8 \"BootstrapMethods\"; \/\/ #24     at 0xF7\n+    MethodHandle 6b #31; \/\/ #25     at 0x010A\n+    NameAndType #10 #32; \/\/ #26     at 0x010E\n+    NameAndType #14 #33; \/\/ #27     at 0x0113\n+    NameAndType #16 #34; \/\/ #28     at 0x0118\n+    Utf8 \"java\/lang\/Object\"; \/\/ #29     at 0x011D\n+    Utf8 \"java\/lang\/Cloneable\"; \/\/ #30     at 0x0130\n+    Method #35 #36; \/\/ #31     at 0x0146\n+    Utf8 \"(QValueCloneable;)I\"; \/\/ #32     at 0x014B\n+    Utf8 \"(QValueCloneable;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x0161\n+    Utf8 \"(QValueCloneable;)Ljava\/lang\/String;\"; \/\/ #34     at 0x0189\n+    class #37; \/\/ #35     at 0x01B0\n+    NameAndType #38 #42; \/\/ #36     at 0x01B3\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01B8\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01E1\n+    class #44; \/\/ #39     at 0x01F7\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01FA\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0212\n+    class #45; \/\/ #43     at 0x0288\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x028B\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02B3\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [1] { \/\/ Interfaces\n+    #7;\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02E0\n+      0x0010; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [4] { \/\/ methods\n+    { \/\/ Member at 0x02EA\n+      0x0011; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 31) { \/\/ Code at 0x02F2\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x030B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0317\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0317\n+      0x0011; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 32) { \/\/ Code at 0x031F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0339\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0345\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0345\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 31) { \/\/ Code at 0x034D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0366\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0372\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0372\n+      0x0008; \/\/ access\n+      #18; \/\/ name_cpx\n+      #19; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#12, 37) { \/\/ Code at 0x037A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B032A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#13, 6) { \/\/ LineNumberTable at 0x0399\n+              [1] { \/\/ LineNumberTable\n+                0  3; \/\/  at 0x03A5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#20, 2) { \/\/ SourceFile at 0x03A7\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03AF\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03BF\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#24, 6) { \/\/ BootstrapMethods at 0x03BF\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #25; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class ValueCloneable\n+\n+\n+\/\/ Test that a class with an old class file version cannot contain a Q signature.\n+class OldClassWithQSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [29] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"OldClassWithQSig\"; \/\/ #1     at 0x0A\n+    class #1; \/\/ #2     at 0x1A\n+    Utf8 \"java\/lang\/Object\"; \/\/ #3     at 0x1D\n+    class #3; \/\/ #4     at 0x30\n+    Utf8 \"inlineclasses.scala\"; \/\/ #5     at 0x33\n+    Utf8 \"Lscala\/reflect\/ScalaSignature;\"; \/\/ #6     at 0x49\n+    Utf8 \"bytes\"; \/\/ #7     at 0x6A\n+    Utf8 \"i1QB\\t!AAC\\bI\\t\\tQ!!Q\\nEAQ!YQ\\\"T=J]2Lg.Z\\\"mCN(\\\"q*W;z}\\r1C\\n!\\tQQ\\\"D\\fa!B:dC2\\fB\\b\\f\\te.*fM\\t.F!\\tQ!#\\tJ;%Aj]&$h\\b3AA!)qba#\"; \/\/ #8     at 0x72\n+    Utf8 \"i\"; \/\/ #9     at 0x0128\n+    Utf8 \"I\"; \/\/ #10     at 0x012C\n+    Utf8 \"()I\"; \/\/ #11     at 0x0130\n+    NameAndType #9 #10; \/\/ #12     at 0x0136\n+    Field #2 #12; \/\/ #13     at 0x013B\n+    Utf8 \"this\"; \/\/ #14     at 0x0140\n+    Utf8 \"QOldClassWithQSig;\"; \/\/ #15     at 0x0147\n+    Utf8 \"<init>\"; \/\/ #16     at 0x0159\n+    Utf8 \"(I)V\"; \/\/ #17     at 0x0162\n+    Utf8 \"()V\"; \/\/ #18     at 0x0169\n+    NameAndType #16 #18; \/\/ #19     at 0x016F\n+    Method #4 #19; \/\/ #20     at 0x0174\n+    Utf8 \"Code\"; \/\/ #21     at 0x0179\n+    Utf8 \"LineNumberTable\"; \/\/ #22     at 0x0180\n+    Utf8 \"LocalVariableTable\"; \/\/ #23     at 0x0192\n+    Utf8 \"MethodParameters\"; \/\/ #24     at 0x01A7\n+    Utf8 \"SourceFile\"; \/\/ #25     at 0x01BA\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #26     at 0x01C7\n+    Utf8 \"ScalaInlineInfo\"; \/\/ #27     at 0x01E3\n+    Utf8 \"ScalaSig\"; \/\/ #28     at 0x01F5\n+  } \/\/ Constant Pool\n+\n+  0x0121; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x020A\n+      0x0012; \/\/ access\n+      #9; \/\/ name_index       : i\n+      #10; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0214\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : i\n+      #11; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#21, 47) { \/\/ Code at 0x021C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB4000DAC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#22, 6) { \/\/ LineNumberTable at 0x0233\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0x023F\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23, 12) { \/\/ LocalVariableTable at 0x023F\n+              [1] { \/\/ LocalVariableTable\n+                0 5 14 15 0; \/\/  at 0x0251\n+              }\n+            } \/\/ end LocalVariableTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0251\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index       : <init>\n+      #17; \/\/ descriptor_index : (I)V\n+      [2] { \/\/ Attributes\n+        Attr(#21, 70) { \/\/ Code at 0x0259\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[10]{\n+            0x2A1BB5000D2AB700;\n+            0x14B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#22, 14) { \/\/ LineNumberTable at 0x0275\n+              [3] { \/\/ line_number_table\n+                0  1; \/\/  at 0x0281\n+                5  3; \/\/  at 0x0285\n+                9  1; \/\/  at 0x0289\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23, 22) { \/\/ LocalVariableTable at 0x0289\n+              [2] { \/\/ LocalVariableTable\n+                0 10 14 15 0; \/\/  at 0x029B\n+                0 10 9 10 1; \/\/  at 0x02A5\n+              }\n+            } \/\/ end LocalVariableTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#24, 5) { \/\/ MethodParameters at 0x02A5\n+          [1]b { \/\/ MethodParameters\n+            #9  0x0010; \/\/  at 0x02B0\n+          }\n+        } \/\/ end MethodParameters\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#25, 2) { \/\/ SourceFile at 0x02B2\n+      #5;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#26, 11) { \/\/ RuntimeVisibleAnnotations at 0x02BA\n+      [1] { \/\/ annotations\n+        {  \/\/  annotation\n+          #6;\n+          [1] { \/\/ element_value_pairs\n+            {  \/\/  element value pair\n+              #7;\n+              {  \/\/  element_value\n+                's';\n+                #8;\n+              }  \/\/  element_value\n+            }  \/\/  element value pair\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27, 14) { \/\/ ScalaInlineInfo at 0x02CB\n+      0x0100000200100011;\n+      0x000009000B00;\n+    } \/\/ end ScalaInlineInfo\n+    ;\n+    Attr(#28, 3) { \/\/ ScalaSig at 0x02DF\n+      0x050200;\n+    } \/\/ end ScalaSig\n+  } \/\/ Attributes\n+} \/\/ end class OldClassWithQSig\n+\n+\n+\/\/ Test that a class with an old class file version cannot contain an array Q signature.\n+class OldClassWithQArraySig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"java\/lang\/Integer\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x50\n+    class #12; \/\/ #10     at 0x55\n+    NameAndType #13 #14; \/\/ #11     at 0x58\n+    Utf8 \"OldClassWithQArraySig\"; \/\/ #12     at 0x5D\n+    Utf8 \"ia\"; \/\/ #13     at 0x65\n+    Utf8 \"[Qjava\/lang\/Integer;\"; \/\/ #14     at 0x6A\n+    Utf8 \"Code\"; \/\/ #15     at 0x81\n+    Utf8 \"LineNumberTable\"; \/\/ #16     at 0x88\n+    Utf8 \"runIt\"; \/\/ #17     at 0x9A\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0xA2\n+    Utf8 \"OldClassWithQArraySig.java\"; \/\/ #19     at 0xAF\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xC6\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : ia\n+      #14; \/\/ descriptor_index : [Qjava\/lang\/Integer;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD0\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#15, 29) { \/\/ Code at 0xD8\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#16, 6) { \/\/ LineNumberTable at 0xEF\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFB\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFB\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index       : runIt\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#15, 37) { \/\/ Code at 0x0103\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0x2A05BD0007B50009;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#16, 10) { \/\/ LineNumberTable at 0x011E\n+              [2] { \/\/ line_number_table\n+                0  6; \/\/  at 0x012A\n+                8  7; \/\/  at 0x012E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x0130\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class OldClassWithQArraySig\n+\n+\n+\/\/ This class has a super_cpx of zero.  This should cause a ClassFormatError\n+\/\/ exception when this class is loaded.\n+class SuperIsZero {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [15] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"SuperIsZero\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1A\n+    NameAndType #5 #6; \/\/ #4     at 0x1F\n+    Utf8 \"x\"; \/\/ #5     at 0x24\n+    Utf8 \"I\"; \/\/ #6     at 0x28\n+    class #8; \/\/ #7     at 0x2C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x2F\n+    Utf8 \"<init>\"; \/\/ #9     at 0x42\n+    Utf8 \"()QSuperIsZero;\"; \/\/ #10     at 0x4B\n+    Utf8 \"Code\"; \/\/ #11     at 0x5C\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x63\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x75\n+    Utf8 \"SuperIsZero.java\"; \/\/ #14     at 0x82\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #0;\/\/ super_cpx \/\/ !!! changed 7 to 0\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9E\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xA8\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <init>\n+      #10; \/\/ descriptor_index : ()QSuperIsZero;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0xB0\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B082A5FCC;\n+            0x00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0xCF\n+              [3] { \/\/ line_number_table\n+                0  4; \/\/  at 0xDB\n+                4  5; \/\/  at 0xDF\n+                11  6; \/\/  at 0xE3\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0xE5\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SuperIsZero\n+\n+\n+\/\/ This class file tests that a ClassFormatError exception is thrown for an old\n+\/\/ class file (version 49) containing a Q signature.  This file is based on the\n+\/\/ following Java code, except the signature for method callDot() was changed\n+\/\/ to \"(QDot;)V\";.\n+\/*\n+public class QInOldClass {\n+\n+    public static void callDot(Dot d) {\n+        System.out.println(\"Hi Dot\");\n+    }\n+\n+}\n+*\/\n+class QInOldClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  49; \/\/ version\n+  [32] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"java\/lang\/System\"; \/\/ #10     at 0x46\n+    Utf8 \"out\"; \/\/ #11     at 0x59\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12     at 0x5F\n+    String #14; \/\/ #13     at 0x77\n+    Utf8 \"Hi Dot\"; \/\/ #14     at 0x7A\n+    Method #16 #17; \/\/ #15     at 0x83\n+    class #18; \/\/ #16     at 0x88\n+    NameAndType #19 #20; \/\/ #17     at 0x8B\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18     at 0x90\n+    Utf8 \"println\"; \/\/ #19     at 0xA6\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20     at 0xB0\n+    class #22; \/\/ #21     at 0xC8\n+    Utf8 \"QInOldClass\"; \/\/ #22     at 0xCB\n+    Utf8 \"Code\"; \/\/ #23     at 0xD6\n+    Utf8 \"LineNumberTable\"; \/\/ #24     at 0xDD\n+    Utf8 \"callDot\"; \/\/ #25     at 0xEF\n+    Utf8 \"(QDot;)V\"; \/\/ #26     at 0xF9\n+    Utf8 \"SourceFile\"; \/\/ #27     at 0x0104\n+    Utf8 \"QInOldClass.java\"; \/\/ #28     at 0x0111\n+    Utf8 \"Preload\"; \/\/ #29     at 0x0121\n+    class #31; \/\/ #30     at 0x012B\n+    Utf8 \"Dot\"; \/\/ #31     at 0x012E\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0140\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#23, 29) { \/\/ Code at 0x0148\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 6) { \/\/ LineNumberTable at 0x015F\n+              [1] { \/\/ line_number_table\n+                0  2; \/\/  at 0x016B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016B\n+      0x0009; \/\/ access\n+      #25; \/\/ name_index       : callDot\n+      #26; \/\/ descriptor_index : (LDot;)V\n+      [1] { \/\/ Attributes\n+        Attr(#23, 37) { \/\/ Code at 0x0173\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 10) { \/\/ LineNumberTable at 0x018E\n+              [2] { \/\/ line_number_table\n+                0  5; \/\/  at 0x019A\n+                8  6; \/\/  at 0x019E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#27, 2) { \/\/ SourceFile at 0x01A0\n+      #28;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#29, 4) { \/\/ Preload at 0x01A8\n+      0x0001001E;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class QInOldClass\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":2696,"deletions":0,"binary":false,"changes":2696,"status":"added"},{"patch":"@@ -0,0 +1,832 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ class ValueClassExtendingIdentityClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingIdentityClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"IdentityAbstract\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingIdentityClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingIdentityClass.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingIdentityClass\n+\n+class ValueClassExtendingAbstractClassWithField {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingAbstractClassWithField\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"AbstractWithField\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingAbstractClassWithField;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingAbstractClassWithField.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingAbstractClassWithField\n+\n+class ValueClassExtendingAbstractClassWithSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassExtendingAbstractClassWithSynchMethod\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"AbstractWithSynchMethod\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClassExtendingAbstractClassWithSynchMethod;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"ValueClassExtendingAbstractClassWithSynchMethod.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassExtendingAbstractClassWithSynchMethod\n+\n+class ValueClassImplementingIdentityInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClassImplementingIdentityInterface\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"IdentityInterface\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LValueClassImplementingIdentityInterface;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClassImplementingIdentityInterface.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClassImplementingIdentityInterface\n+\n+class IdentityClassExtendingValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"ValueAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClassExtendingValueClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"IdentityClassExtendingValueClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class IdentityClassExtendingValueClass\n+\n+class IdentityClassImplementingValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClassImplementingValueInterface\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"ValueInterface\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"IdentityClassImplementingValueInterface.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #9;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class IdentityClassImplementingValueInterface\n+\n+class AbstractClassWithFieldExtendingValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"ValueAbstract\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldExtendingValueClass\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"AbstractClassWithFieldExtendingValueClass.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0420; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldExtendingValueClass\n+\n+class AbstractClassWithFieldImplementingValueInterface {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldImplementingValueInterface\"; \/\/ #8\n+    class #10; \/\/ #9\n+    Utf8 \"ValueInterface\"; \/\/ #10\n+    Utf8 \"i\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    Utf8 \"Code\"; \/\/ #13\n+    Utf8 \"LineNumberTable\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"AbstractClassWithFieldImplementingValueInterface.java\"; \/\/ #16\n+  } \/\/ Constant Pool\n+\n+  0x0420; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #9;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#14) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldImplementingValueInterface\n+\n+class AbstractClassWithFieldWithNoIdentityModifier {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithFieldWithNoIdentityModifier\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"AbstractClassWithFieldWithNoIdentityModifier.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0400; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithFieldWithNoIdentityModifier\n+\n+class AbstractClassWithSynchMethodWithNoIdentityModifier {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithSynchMethodWithNoIdentityModifier\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"foo\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"AbstractClassWithSynchMethodWithNoIdentityModifier.java\"; \/\/ #13\n+  } \/\/ Constant Pool\n+\n+  0x0400; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0020; \/\/ access\n+      #11; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithSynchMethodWithNoIdentityModifier\n+\n+class AbstractClassWithBothModifiers {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClassWithBothModifiers\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractClassWithBothModifiers.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0460; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClassWithBothModifiers\n+\n+class ConcreteClassWithNoModifiers {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ConcreteClassWithNoModifiers\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ConcreteClassWithNoModifiers.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0000; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ConcreteClassWithNoModifiers\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/ClassesWithInvalidModifiers.jcod","additions":832,"deletions":0,"binary":false,"changes":832,"status":"added"},{"patch":"@@ -0,0 +1,2637 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ The test cases in this .jcod file are based on this .java file:\n+\/\/ public primitive final class Point extends AbstractClass {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private Point() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/ }\n+\n+\/\/ Primitive class with a super class that is not abstract.\n+class PrimitiveSuperNotAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperNotAbstract\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperNotAbstract;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperNotAbstract;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperNotAbstract;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"NotAbstract\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperNotAbstract;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperNotAbstract.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperNotAbstract\n+\n+\n+\n+\/\/ Primitive class with a super class that has instance fields.\n+class PrimitiveSuperHasNonStaticFields {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperHasNonStaticFields\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperHasNonStaticFields;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"HasNonStaticFields\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperHasNonStaticFields;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperHasNonStaticFields.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperHasNonStaticFields\n+\n+\n+\n+\/\/ primitive value class with a super class whose super class has a syncronized instance method.\n+class PrimitiveSuperHasSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperHasSynchMethod\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperHasSynchMethod;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"ValidSuper\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperHasSynchMethod;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperHasSynchMethod.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperHasSynchMethod\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has arguments.\n+class PrimitiveSuperCtorHasArgs {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperCtorHasArgs\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperCtorHasArgs;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorHasArgs\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperCtorHasArgs;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperCtorHasArgs.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperCtorHasArgs\n+\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has a non-empty\n+\/\/ method body.\n+class PrimitiveSuperCtorIsNotEmpty {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"PrimitiveSuperCtorIsNotEmpty\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(QPrimitiveSuperCtorIsNotEmpty;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorIsNotEmpty\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()QPrimitiveSuperCtorIsNotEmpty;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"PrimitiveSuperCtorIsNotEmpty.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveSuperCtorIsNotEmpty\n+\n+\/\/ Again for value objects...\n+\n+\/\/ Value class with a super class that is not abstract.\n+class ValueSuperNotAbstract {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperNotAbstract\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperNotAbstract;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperNotAbstract;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperNotAbstract;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"NotAbstract\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperNotAbstract;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperNotAbstract.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperNotAbstract\n+\n+\n+\n+\/\/ Value class with a super class that has instance fields.\n+class ValueSuperHasNonStaticFields {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperHasNonStaticFields\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperHasNonStaticFields;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperHasNonStaticFields;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperHasNonStaticFields;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"HasNonStaticFields\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperHasNonStaticFields;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperHasNonStaticFields.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperHasNonStaticFields\n+\n+\n+\n+\/\/ primitive value class with a super class whose super class has a syncronized instance method.\n+class ValueSuperHasSynchMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperHasSynchMethod\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperHasSynchMethod;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperHasSynchMethod;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperHasSynchMethod;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"ValidSuper\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperHasSynchMethod;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperHasSynchMethod.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperHasSynchMethod\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has arguments.\n+class ValueSuperCtorHasArgs {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperCtorHasArgs\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperCtorHasArgs;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperCtorHasArgs;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperCtorHasArgs;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorHasArgs\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperCtorHasArgs;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperCtorHasArgs.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperCtorHasArgs\n+\n+\n+\n+\/\/ primitive value class with a super class containing a constructor that has a non-empty\n+\/\/ method body.\n+class ValueSuperCtorIsNotEmpty {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [51] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueSuperCtorIsNotEmpty\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"x\"; \/\/ #5     at 0x2A\n+    Utf8 \"I\"; \/\/ #6     at 0x2E\n+    Field #1 #8; \/\/ #7     at 0x32\n+    NameAndType #9 #6; \/\/ #8     at 0x37\n+    Utf8 \"y\"; \/\/ #9     at 0x3C\n+    InvokeDynamic 0s #11; \/\/ #10     at 0x40\n+    NameAndType #12 #13; \/\/ #11     at 0x45\n+    Utf8 \"hashCode\"; \/\/ #12     at 0x4A\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;)I\"; \/\/ #13     at 0x55\n+    InvokeDynamic 0s #15; \/\/ #14     at 0x6D\n+    NameAndType #16 #17; \/\/ #15     at 0x72\n+    Utf8 \"equals\"; \/\/ #16     at 0x77\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;Ljava\/lang\/Object;)Z\"; \/\/ #17     at 0x80\n+    InvokeDynamic 0s #19; \/\/ #18     at 0xAA\n+    NameAndType #20 #21; \/\/ #19     at 0xAF\n+    Utf8 \"toString\"; \/\/ #20     at 0xB4\n+    Utf8 \"(LValueSuperCtorIsNotEmpty;)Ljava\/lang\/String;\"; \/\/ #21     at 0xBF\n+    class #23; \/\/ #22     at 0xE8\n+    Utf8 \"CtorIsNotEmpty\"; \/\/ #23     at 0xEB\n+    class #25; \/\/ #24     at 0xF9\n+    Utf8 \"Unused\"; \/\/ #25     at 0xFC\n+    Utf8 \"getX\"; \/\/ #26     at 0x0115\n+    Utf8 \"()I\"; \/\/ #27     at 0x011C\n+    Utf8 \"Code\"; \/\/ #28     at 0x0122\n+    Utf8 \"LineNumberTable\"; \/\/ #29     at 0x0129\n+    Utf8 \"getY\"; \/\/ #30     at 0x013B\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #31     at 0x0142\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32     at 0x015A\n+    Utf8 \"<vnew>\"; \/\/ #33     at 0x0171\n+    Utf8 \"()LValueSuperCtorIsNotEmpty;\"; \/\/ #34     at 0x017A\n+    Utf8 \"SourceFile\"; \/\/ #35     at 0x0191\n+    Utf8 \"ValueSuperCtorIsNotEmpty.java\"; \/\/ #36     at 0x019E\n+    Utf8 \"BootstrapMethods\"; \/\/ #37     at 0x01B6\n+    MethodHandle 6b #39; \/\/ #38     at 0x01C9\n+    Method #40 #41; \/\/ #39     at 0x01CD\n+    class #42; \/\/ #40     at 0x01D2\n+    NameAndType #43 #44; \/\/ #41     at 0x01D5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #42     at 0x01DA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #43     at 0x0203\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #44     at 0x0219\n+    Utf8 \"InnerClasses\"; \/\/ #45     at 0x028F\n+    class #47; \/\/ #46     at 0x029E\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #47     at 0x02A1\n+    class #49; \/\/ #48     at 0x02C9\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #49     at 0x02CC\n+    Utf8 \"Lookup\"; \/\/ #50     at 0x02ED\n+  } \/\/ Constant Pool\n+\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #22;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0302\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x030A\n+      0x0010; \/\/ access\n+      #9; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [6] { \/\/ methods\n+    { \/\/ Member at 0x0314\n+      0x0001; \/\/ access\n+      #26; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x031C\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x0333\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x033F\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x033F\n+      0x0001; \/\/ access\n+      #30; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 29) { \/\/ Code at 0x0347\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x035E\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x036A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x036A\n+      0x0011; \/\/ access\n+      #12; \/\/ name_cpx\n+      #27; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x0372\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x038B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0397\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0397\n+      0x0011; \/\/ access\n+      #16; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 32) { \/\/ Code at 0x039F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA000E0000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03B9\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03C5\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03C5\n+      0x0011; \/\/ access\n+      #20; \/\/ name_cpx\n+      #32; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 31) { \/\/ Code at 0x03CD\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00120000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 6) { \/\/ LineNumberTable at 0x03E6\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x03F2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03F2\n+      0x000A; \/\/ access\n+      #33; \/\/ name_cpx\n+      #34; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#28, 56) { \/\/ Code at 0x03FA\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00034B032A5FCC00;\n+            0x074B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#29, 18) { \/\/ LineNumberTable at 0x0420\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x042C\n+                4  6; \/\/  at 0x0430\n+                11  7; \/\/  at 0x0434\n+                18  8; \/\/  at 0x0438\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#35, 2) { \/\/ SourceFile at 0x043A\n+      #36;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#37, 6) { \/\/ BootstrapMethods at 0x0442\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #38; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#45, 10) { \/\/ InnerClasses at 0x044E\n+      [1] { \/\/ InnerClasses\n+        #46 #48 #50 25; \/\/  at 0x045E\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class ValueSuperCtorIsNotEmpty\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/InlineClassWithBadSupers.jcod","additions":2637,"deletions":0,"binary":false,"changes":2637,"status":"added"},{"patch":"@@ -0,0 +1,1608 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Many of the jcod classes in this file were derived from this Java inline type:\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ The changes for each test were made to the bytecodes for method makeValue(int x).\n+\/\/ Its bytecodes are:\n+\/\/\n+\/\/  static Value makeValue(int); descriptor: (I)LValue; flags: (0x0008) ACC_STATIC\n+\/\/    Code:\n+\/\/      stack=2, locals=2, args_size=1\n+\/\/         0: aconst_init   #3                  \/\/ class Value\n+\/\/         3: astore_1\n+\/\/         4: aload_1\n+\/\/         5: iload_0\n+\/\/         6: withfield     #2                  \/\/ Field int_v:I\n+\/\/         9: astore_1\n+\/\/        10: aload_1\n+\/\/        11: areturn\n+\n+\n+\/\/ The constant pool index of the aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 0x93.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class defValBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadCP;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadCP;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadCP.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadCP\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00934C2B1ACC00; \/\/ Changed CP index from 3 to 0x93 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54.  Since this class has a\n+\/\/ aconst_init opcode (0xCB), this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class defValBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 2.  Since this index now points to a Field\n+\/\/ entry instead of a Class entry, a VerifyError exception should get thrown.\n+\/\/\n+class defValWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValWrongCPType;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValWrongCPType;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValWrongCPType.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValWrongCPType\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00024C2B1ACC00; \/\/ Changed CP index from 3 to 2 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the cp index no longer points to a cp Class entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of the withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 0x82.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadCP\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadCP\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadCP;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadCP.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 0x82 for opcode 0xCC (withfield)\n+            0x824C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 5 in the Code array was changed to aload_1\n+\/\/ (0x2B).  This should cause a VerifyError because now the first operand on the\n+\/\/ stack for the withfield opcode (0xCC at bytecode position 6) does not match\n+\/\/ the type (int) of the field being assigned to.\n+\/\/\n+class wthFldBadFldVal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldVal\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldVal\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldVal;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldVal.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B2BCC00; \/\/ Changed opcode at bytecode 5 from iload_0 to aload_1\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldVal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 4 in the Code array was changed to iload_1\n+\/\/ (0x1A).  This should cause a VerifyError because the second operand on the stack\n+\/\/ for the withfield opcode (0xCC at bytecode position 6) must be a reference.\n+\/\/\n+class wthFldBadFldRef {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldRef\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldRef\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldRef;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldRef.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C1A1ACC00; \/\/ Changed opcode at bytecode 4 from aload_1 to iload_0\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldRef\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54 and the first opcode in the Code\n+\/\/ attribute was changed to a withfield (0xCC)..  Since withfield opcodes are not\n+\/\/ allowed in classes with major version 54, this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class wthFldBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LwthFldBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LwthFldBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"wthFldBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"wthFldBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCC00034C2B1ACC00; \/\/ Changed the first opcode to 0xCC (withfield) in order to\n+            0x024C2BB0;         \/\/ test withfield opcode with an illegal major version.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 1.  Since this index now points to a Method\n+\/\/ entry instead of a Field entry, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldWrongCPType\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldWrongCPType\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldWrongCPType;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldWrongCPType.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 1 for opcode 0xCC (withfield)\n+            0x014C2BB0;         \/\/ so that the cp index no longer points to a cp Field entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The cp entry for the aconst_init opcode was changed to a reference that\n+\/\/ is not an inline type.\n+\/\/ This should cause a VerifyError because the cp entry for opcode aconst_init\n+\/\/ must be an inline type.\n+\/\/\n+class defValueObj {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"makedefValueObj\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)QdefValueObj;\"; \/\/ #10     at 0x41\n+    Utf8 \"Code\"; \/\/ #11     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x5A\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x6C\n+    Utf8 \"()I\"; \/\/ #14     at 0x77\n+    Utf8 \"equals\"; \/\/ #15     at 0x7D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x86\n+    Utf8 \"toString\"; \/\/ #17     at 0x9E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0xA9\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0xC0\n+    Utf8 \"()QdefValueObj;\"; \/\/ #20     at 0xC9\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xDA\n+    Utf8 \"defValueObj.java\"; \/\/ #22     at 0xE7\n+    Utf8 \"defValueObj\"; \/\/ #23     at 0xF9\n+    NameAndType #7 #8; \/\/ #24     at 0x0106\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010B\n+    MethodHandle 6b #31; \/\/ #26     at 0x011E\n+    NameAndType #13 #32; \/\/ #27     at 0x0122\n+    NameAndType #15 #33; \/\/ #28     at 0x0127\n+    NameAndType #17 #34; \/\/ #29     at 0x012C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0131\n+    Method #35 #36; \/\/ #31     at 0x0144\n+    Utf8 \"(QdefValueObj;)I\"; \/\/ #32     at 0x0149\n+    Utf8 \"(QdefValueObj;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x015B\n+    Utf8 \"(QdefValueObj;)Ljava\/lang\/String;\"; \/\/ #34     at 0x017F\n+    class #37; \/\/ #35     at 0x01A2\n+    NameAndType #38 #42; \/\/ #36     at 0x01A5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01AA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01D3\n+    class #44; \/\/ #39     at 0x01E9\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01EC\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x01F5\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0204\n+    class #45; \/\/ #43     at 0x027A\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x027D\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02A5\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02D0\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02DA\n+      0x0008; \/\/ access\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x02E2\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00044C1A2B5FCC; \/\/ Changed aconst_init's cp index at byte 3 from 3 to 4.\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x0301\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x030D\n+                4  9; \/\/  at 0x0311\n+                11  10; \/\/  at 0x0315\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0315\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0336\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0342\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0342\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x034A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0364\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0370\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0370\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0378\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0391\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039D\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A5\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C4\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03D0\n+                4  5; \/\/  at 0x03D4\n+                11  6; \/\/  at 0x03D8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03DA\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E2\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class defValueObj\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ This class has a withfield opcode with a non-Q type operand.\n+class withfieldL {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldL\"; \/\/ #2     at 0x0D\n+    class #2; \/\/ #3     at 0x17\n+    Field #1 #5; \/\/ #4     at 0x1A\n+    NameAndType #6 #7; \/\/ #5     at 0x1F\n+    Utf8 \"x\"; \/\/ #6     at 0x24\n+    Utf8 \"I\"; \/\/ #7     at 0x28\n+    Field #1 #9; \/\/ #8     at 0x2C\n+    NameAndType #10 #7; \/\/ #9     at 0x31\n+    Utf8 \"y\"; \/\/ #10     at 0x36\n+    class #12; \/\/ #11     at 0x3A\n+    Utf8 \"QwithfieldL;\"; \/\/ #12     at 0x3D\n+    class #14; \/\/ #13     at 0x49\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14     at 0x4C\n+    Utf8 \"makePoint\"; \/\/ #15     at 0x5F\n+    Utf8 \"(II)QwithfieldL;\"; \/\/ #16     at 0x6B\n+    Utf8 \"Code\"; \/\/ #17     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x82\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0x94\n+    Utf8 \"()QwithfieldL;\"; \/\/ #20     at 0x9D\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xAB\n+    Utf8 \"X.java\"; \/\/ #22     at 0xB8\n+    Utf8 \"NestHost\"; \/\/ #23     at 0xC1\n+    class #25; \/\/ #24     at 0xCC\n+    Utf8 \"X\"; \/\/ #25     at 0xCF\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0xD3\n+    Utf8 \"Point\"; \/\/ #27     at 0xE2\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #13;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0xF4\n+      0x0010; \/\/ access\n+      #6; \/\/ name_index       : x\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0xFC\n+      0x0010; \/\/ access\n+      #10; \/\/ name_index       : y\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0106\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index       : makePoint\n+      #16; \/\/ descriptor_index : (II)QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x010E\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[26]{\n+            0xCB0001C000034D1A;\n+            0x2C5FCC00044D1B2C;\n+            0x5FCC00084D2CC000;\n+            0x0BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x013A\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0146\n+                7  5; \/\/  at 0x014A\n+                14  6; \/\/  at 0x014E\n+                21  7; \/\/  at 0x0152\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0152\n+      0x000A; \/\/ access\n+      #19; \/\/ name_index       : <vnew>\n+      #20; \/\/ descriptor_index : ()QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 55) { \/\/ Code at 0x015A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B032A5FCC;\n+            0x0008594BB400082A;\n+            0x5FCC00044B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0183\n+              [3] { \/\/ line_number_table\n+                0  9; \/\/  at 0x018F\n+                4  10; \/\/  at 0x0193\n+                21  11; \/\/  at 0x0197\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0199\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x01A1\n+      #24; \/\/ X at 0x01A9\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 10) { \/\/ InnerClasses at 0x01A9\n+      [1] { \/\/ classes\n+        #1 #24 #27 280; \/\/  at 0x01B9\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class withfieldL\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that a VerifyError exception is thrown when trying to pass a null\n+\/\/ when the formal parameter is an inline type.\n+\/\/\n+\/\/ \/\/ Java program emulating the jcod contents.\n+\/\/ public inline final class NoNullVT {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private NoNullVT() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/\n+\/\/     public boolean isSameNoNullVT(NoNullVT that) {\n+\/\/         return this.getX() == that.getX() && this.getY() == that.getY();\n+\/\/     }\n+\/\/\n+\/\/     public boolean equals(Object o) {\n+\/\/         if(o instanceof NoNullVT) {\n+\/\/             return ((NoNullVT)o).x == x &&  ((NoNullVT)o).y == y;\n+\/\/         } else {\n+\/\/             return false;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     public static NoNullVT createNoNullVT(int x, int y) {\n+\/\/         NoNullVT p = NoNullVT.default;\n+\/\/         p = __WithField(p.x, x);\n+\/\/         p = __WithField(p.y, y);\n+\/\/         return p;\n+\/\/     }\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         String str = null;\n+\/\/         NoNullVT a = createNoNullVT(3, 4);\n+\/\/         NoNullVT b = createNoNullVT(2, 4);\n+\/\/         boolean res = a.isSameNoNullVT(null); \/\/ Should throw VerifyError\n+\/\/     }\n+\/\/ }\n+\n+class NoNullVT {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [63] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #36; \/\/ #1     at 0x0A\n+    Field #1 #37; \/\/ #2     at 0x0D\n+    Field #1 #38; \/\/ #3     at 0x12\n+    Method #1 #39; \/\/ #4     at 0x17\n+    Method #1 #40; \/\/ #5     at 0x1C\n+    class #41; \/\/ #6     at 0x21\n+    Method #1 #42; \/\/ #7     at 0x24\n+    Method #1 #43; \/\/ #8     at 0x29\n+    InvokeDynamic 0s #46; \/\/ #9     at 0x2E\n+    InvokeDynamic 0s #47; \/\/ #10     at 0x33\n+    class #48; \/\/ #11     at 0x38\n+    Utf8 \"x\"; \/\/ #12     at 0x3B\n+    Utf8 \"I\"; \/\/ #13     at 0x3F\n+    Utf8 \"y\"; \/\/ #14     at 0x43\n+    Utf8 \"getX\"; \/\/ #15     at 0x47\n+    Utf8 \"()I\"; \/\/ #16     at 0x4E\n+    Utf8 \"Code\"; \/\/ #17     at 0x54\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x5B\n+    Utf8 \"getY\"; \/\/ #19     at 0x6D\n+    Utf8 \"isSameNoNullVT\"; \/\/ #20     at 0x74\n+    Utf8 \"(QNoNullVT;)Z\"; \/\/ #21     at 0x85\n+    Utf8 \"StackMapTable\"; \/\/ #22     at 0x95\n+    Utf8 \"equals\"; \/\/ #23     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAE\n+    Utf8 \"createNoNullVT\"; \/\/ #25     at 0xC6\n+    Utf8 \"(II)QNoNullVT;\"; \/\/ #26     at 0xD7\n+    Utf8 \"main\"; \/\/ #27     at 0xE8\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28     at 0xEF\n+    Utf8 \"hashCode\"; \/\/ #29     at 0x0108\n+    Utf8 \"toString\"; \/\/ #30     at 0x0113\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x011E\n+    Utf8 \"<vnew>\"; \/\/ #32     at 0x0135\n+    Utf8 \"()QNoNullVT;\"; \/\/ #33     at 0x013E\n+    Utf8 \"SourceFile\"; \/\/ #34     at 0x014D\n+    Utf8 \"NoNullVT.java\"; \/\/ #35     at 0x015A\n+    Utf8 \"NoNullVT\"; \/\/ #36     at 0x016A\n+    NameAndType #12 #13; \/\/ #37     at 0x0175\n+    NameAndType #14 #13; \/\/ #38     at 0x017A\n+    NameAndType #15 #16; \/\/ #39     at 0x017F\n+    NameAndType #19 #16; \/\/ #40     at 0x0184\n+    Utf8 \"QNoNullVT;\"; \/\/ #41     at 0x0189\n+    NameAndType #25 #26; \/\/ #42     at 0x0196\n+    NameAndType #20 #21; \/\/ #43     at 0x019B\n+    Utf8 \"BootstrapMethods\"; \/\/ #44     at 0x01A0\n+    MethodHandle 6b #49; \/\/ #45     at 0x01B3\n+    NameAndType #29 #50; \/\/ #46     at 0x01B7\n+    NameAndType #30 #51; \/\/ #47     at 0x01BC\n+    Utf8 \"java\/lang\/Object\"; \/\/ #48     at 0x01C1\n+    Method #52 #53; \/\/ #49     at 0x01D4\n+    Utf8 \"(QNoNullVT;)I\"; \/\/ #50     at 0x01D9\n+    Utf8 \"(QNoNullVT;)Ljava\/lang\/String;\"; \/\/ #51     at 0x01E9\n+    class #54; \/\/ #52     at 0x020A\n+    NameAndType #55 #59; \/\/ #53     at 0x020D\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #54     at 0x0212\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #55     at 0x023B\n+    class #61; \/\/ #56     at 0x0251\n+    Utf8 \"Lookup\"; \/\/ #57     at 0x0254\n+    Utf8 \"InnerClasses\"; \/\/ #58     at 0x025D\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #59     at 0x026C\n+    class #62; \/\/ #60     at 0x02E2\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #61     at 0x02E5\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #62     at 0x030D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0338\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [9] { \/\/ methods\n+    { \/\/ Member at 0x034A\n+      0x0001; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0352\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40002AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0369\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x0375\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0375\n+      0x0001; \/\/ access\n+      #19; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x037D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0394\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x03A0\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03A0\n+      0x0001; \/\/ access\n+      #20; \/\/ name_cpx\n+      #21; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 63) { \/\/ Code at 0x03A8\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[28]{\n+            0x2AB600042BB60004;\n+            0xA000122AB600052B;\n+            0xB60005A0000704A7;\n+            0x000403AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x03D6\n+              [1] { \/\/ LineNumberTable\n+                0  14; \/\/  at 0x03E2\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 5) { \/\/ StackMapTable at 0x03E2\n+              [2] { \/\/\n+                26b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03ED\n+      0x0001; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 87) { \/\/ Code at 0x03F5\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[43]{\n+            0x2BC100019900252B;\n+            0xC00006B400022AB4;\n+            0x0002A000152BC000;\n+            0x06B400032AB40003;\n+            0xA0000704A7000403;\n+            0xAC03AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0432\n+              [3] { \/\/ LineNumberTable\n+                0  18; \/\/  at 0x043E\n+                7  19; \/\/  at 0x0442\n+                41  21; \/\/  at 0x0446\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 6) { \/\/ StackMapTable at 0x0446\n+              [3] { \/\/\n+                39b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+                0b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0452\n+      0x0009; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x045A\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014D1A2C5FCC;\n+            0x00024D1B2C5FCC00;\n+            0x034D2CB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x0480\n+              [4] { \/\/ LineNumberTable\n+                0  26; \/\/  at 0x048C\n+                4  27; \/\/  at 0x0490\n+                11  28; \/\/  at 0x0494\n+                18  29; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0498\n+      0x0009; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x04A0\n+          2; \/\/ max_stack\n+          5; \/\/ max_locals\n+          Bytes[22]{\n+            0x014C0607B800074D;\n+            0x0507B800074E2C2B; \/\/ Change last nibble from C to B to load null\n+            0xB600083604B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 22) { \/\/ LineNumberTable at 0x04C8\n+              [5] { \/\/ LineNumberTable\n+                0  33; \/\/  at 0x04D4\n+                2  34; \/\/  at 0x04D8\n+                8  35; \/\/  at 0x04DC\n+                14  36; \/\/  at 0x04E0\n+                21  37; \/\/  at 0x04E4\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x04E4\n+      0x0011; \/\/ access\n+      #29; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x04EC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00090000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0505\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0511\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0511\n+      0x0011; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x0519\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0532\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x053E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x053E\n+      0x000A; \/\/ access\n+      #32; \/\/ name_cpx\n+      #33; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x0546\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00024B032A5FCC00;\n+            0x034B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x056C\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x0578\n+                4  6; \/\/  at 0x057C\n+                11  7; \/\/  at 0x0580\n+                18  8; \/\/  at 0x0584\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#34, 2) { \/\/ SourceFile at 0x0586\n+      #35;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#58, 10) { \/\/ InnerClasses at 0x058E\n+      [1] { \/\/ InnerClasses\n+        #56 #60 #57 25; \/\/  at 0x059E\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#44, 6) { \/\/ BootstrapMethods at 0x059E\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #45; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class NoNullVT\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":1608,"deletions":0,"binary":false,"changes":1608,"status":"added"},{"patch":"@@ -0,0 +1,1121 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* This jcod class is based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+ public class withfieldObject {\n+\n+     String y;\n+\n+     public withfieldObject() {\n+         try {\n+             y = \"abc\";  \/\/ Change this putfield to a withfield\n+         } catch (IncompatibleClassChangeError e) {\n+             y = \"cde\";\n+         }\n+     }\n+\n+     public String getfield() {\n+         return y;\n+     }\n+ }\n+*\/\n+\n+class withfieldObject {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [26] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    String #8; \/\/ #7     at 0x39\n+    Utf8 \"abc\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x42\n+    class #12; \/\/ #10     at 0x47\n+    NameAndType #13 #14; \/\/ #11     at 0x4A\n+    Utf8 \"withfieldObject\"; \/\/ #12     at 0x4F\n+    Utf8 \"y\"; \/\/ #13     at 0x60\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #14     at 0x64\n+    class #16; \/\/ #15     at 0x79\n+    Utf8 \"java\/lang\/IncompatibleClassChangeError\"; \/\/ #16     at 0x7C\n+    String #18; \/\/ #17     at 0xA5\n+    Utf8 \"cde\"; \/\/ #18     at 0xA8\n+    Utf8 \"Code\"; \/\/ #19     at 0xAE\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0xB5\n+    Utf8 \"StackMapTable\"; \/\/ #21     at 0xC7\n+    Utf8 \"getfield\"; \/\/ #22     at 0xD7\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #23     at 0xE2\n+    Utf8 \"SourceFile\"; \/\/ #24     at 0xF9\n+    Utf8 \"withfieldObject.java\"; \/\/ #25     at 0x0106\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x0126\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : y\n+      #14; \/\/ descriptor_index : Ljava\/lang\/String;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0130\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#19, 96) { \/\/ Code at 0x0138  \/\/ !!!! Changed 95 -> 96\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[22]{                \/\/ !!!! Changed from 21 -> 22\n+            0x2AB700012A1207CC;     \/\/ !!!! Changed last byte from B5 (putfield) to CC (withfield)\n+            0x000957A7000A4C2A;     \/\/ !!!! Inserted 0x57 (pop) to clear the stack.\n+            0x1211B50009B1;\n+          }\n+          [1] { \/\/ Traps\n+            4 11 14 15; \/\/  at 0x0165  \/\/ !!!! Changed 10 -> 11 and 13 -> 14\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#20, 26) { \/\/ LineNumberTable at 0x0167\n+              [6] { \/\/ line_number_table\n+                0  6; \/\/  at 0x0173\n+                4  8; \/\/  at 0x0177\n+                10  11; \/\/  at 0x017B\n+                13  9; \/\/  at 0x017F\n+                14  10; \/\/  at 0x0183\n+                20  12; \/\/  at 0x0187\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#21, 16) { \/\/ StackMapTable at 0x0187\n+              [2] { \/\/\n+                255b, 14, [1]{7b,10}, [1]{7b,15}; \/\/ full_frame  \/\/ !!!! Changed 13 to 14\n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x019D\n+      0x0001; \/\/ access\n+      #22; \/\/ name_index       : getfield\n+      #23; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#19, 29) { \/\/ Code at 0x01A5\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40009B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 6) { \/\/ LineNumberTable at 0x01BC\n+              [1] { \/\/ line_number_table\n+                0  15; \/\/  at 0x01C8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#24, 2) { \/\/ SourceFile at 0x01CA\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldObject\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   orignal jcod file, search for !!!!.\n+ public class putfieldObject {\n+     String y;\n+     public putfieldObject() {\n+         y = \"abc\";\n+     }\n+     public void withfieldFunc() {\n+         y = \"cde\";  \/\/ Change this putfield to a withfield\n+     }\n+     public String getfield() {\n+         return y;\n+     }\n+ }\n+*\/\n+class putfieldObject {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [24] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    String #8; \/\/ #7     at 0x39\n+    Utf8 \"abc\"; \/\/ #8     at 0x3C\n+    Field #10 #11; \/\/ #9     at 0x42\n+    class #12; \/\/ #10     at 0x47\n+    NameAndType #13 #14; \/\/ #11     at 0x4A\n+    Utf8 \"putfieldObject\"; \/\/ #12     at 0x4F\n+    Utf8 \"y\"; \/\/ #13     at 0x60\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #14     at 0x64\n+    String #16; \/\/ #15     at 0x79\n+    Utf8 \"cde\"; \/\/ #16     at 0x7C\n+    Utf8 \"Code\"; \/\/ #17     at 0x82\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x89\n+    Utf8 \"withfieldFunc\"; \/\/ #19     at 0x9B\n+    Utf8 \"getfield\"; \/\/ #20     at 0xAB\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #21     at 0xB6\n+    Utf8 \"SourceFile\"; \/\/ #22     at 0xCD\n+    Utf8 \"putfieldObject.java\"; \/\/ #23     at 0xDA\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #10;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xFA\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index       : y\n+      #14; \/\/ descriptor_index : Ljava\/lang\/String;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [3] { \/\/ Methods\n+    {  \/\/ method at 0x0104\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#17, 43) { \/\/ Code at 0x010C\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[11]{\n+            0x2AB700012A1207B5;\n+            0x0009B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0129\n+              [3] { \/\/ line_number_table\n+                0  6; \/\/  at 0x0135\n+                4  7; \/\/  at 0x0139\n+                10  8; \/\/  at 0x013D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x013D\n+      0x0001; \/\/ access\n+      #19; \/\/ name_index       : withfieldFunc\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#17, 35) { \/\/ Code at 0x0145\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2A120FCC0009B1;  \/\/ !!!! Change 0xB5 (putfield) to 0xCC (withfield)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 10) { \/\/ LineNumberTable at 0x015E\n+              [2] { \/\/ line_number_table\n+                0  11; \/\/  at 0x016A\n+                6  12; \/\/  at 0x016E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x016E\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index       : getfield\n+      #21; \/\/ descriptor_index : ()Ljava\/lang\/String;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0176\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40009B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x018D\n+              [1] { \/\/ line_number_table\n+                0  15; \/\/  at 0x0199\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#22, 2) { \/\/ SourceFile at 0x019B\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class putfieldObject\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   original jcod file, search for !!!!.\n+public primitive final class putfieldPrimitive {\n+    int x;\n+\n+    public putfieldPrimitive(boolean odd) {\n+        if (odd) {\n+            x = 5;\n+        } else {\n+            x = 6;\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+\n+\/\/ If putfieldPrimitive.<vnew>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ Otherwise, it uses a putfield bytecode.\n+\n+class putfieldPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"putfieldPrimitive\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x3B\n+    Utf8 \"()I\"; \/\/ #10     at 0x42\n+    Utf8 \"Code\"; \/\/ #11     at 0x48\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x4F\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x61\n+    Utf8 \"(Z)QputfieldPrimitive;\"; \/\/ #14     at 0x6A\n+    Utf8 \"StackMapTable\"; \/\/ #15     at 0x75\n+    class #17; \/\/ #16     at 0x85\n+    Utf8 \"QputfieldPrimitive;\"; \/\/ #17     at 0x88\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0x90\n+    Utf8 \"putfieldPrimitive.java\"; \/\/ #19     at 0x9D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xB2\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xBC\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xC4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xDB\n+              [1] { \/\/ line_number_table\n+                0  13; \/\/  at 0xE7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xE7\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <vnew>\n+      #14; \/\/ descriptor_index : (Z)QputfieldPrimitive;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 84) { \/\/ Code at 0xEF  \/\/ !!! Change 83 -> 84\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[29]{             \/\/ !!!! Change 28 -> 29\n+            0xCB00014C1A99000D;\n+            0x082B5FCC00034CA7;\n+            0x000C10062B5FB500;  \/\/ !!!! Change goto target B -> C and 0xCC (withfield) to 0xB5 (putfield)\n+            0x032B4C2BB0;        \/\/ !!!! Inserted 0x2B (aload_1)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#12, 22) { \/\/ LineNumberTable at 0x011D\n+              [5] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0129\n+                4  5; \/\/  at 0x012D\n+                8  6; \/\/  at 0x0131\n+                18  8; \/\/  at 0x0135\n+                26  10; \/\/  at 0x0139\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#15, 9) { \/\/ StackMapTable at 0x0139\n+              [2] { \/\/\n+                252b, 18, [1]z{7b,16}; \/\/ append_frame 1\n+                8b; \/\/ same_frame    \/\/ !!!! change 7 -> 8\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x014A\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class putfieldPrimitive\n+\n+\n+\n+\/* This jcod class is based on this Java code.  To see what changed from the\n+   original jcod file, search for !!!!.\n+public primitive final class withfieldPrimitive {\n+    int x;\n+\n+    public withfieldPrimitive(boolean odd) {\n+        if (odd) {\n+            x = 5;\n+        } else {\n+            x = 6;\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+}\n+*\/\n+\n+\/\/ This class is identical to putfieldPrimitive except for its name.  A new class\n+\/\/ was needed for a fresh constant pool resolution.\n+\/\/ If withfieldPrimitive.<vnew>(bool) is passed TRUE then it uses a withfield bytecode.\n+\/\/ Otherwise, it uses a putfield bytecode.\n+\n+class withfieldPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldPrimitive\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x13\n+    NameAndType #5 #6; \/\/ #4     at 0x18\n+    Utf8 \"x\"; \/\/ #5     at 0x1D\n+    Utf8 \"I\"; \/\/ #6     at 0x21\n+    class #8; \/\/ #7     at 0x25\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x28\n+    Utf8 \"getX\"; \/\/ #9     at 0x3B\n+    Utf8 \"()I\"; \/\/ #10     at 0x42\n+    Utf8 \"Code\"; \/\/ #11     at 0x48\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x4F\n+    Utf8 \"<vnew>\"; \/\/ #13     at 0x61\n+    Utf8 \"(Z)QwithfieldPrimitive;\"; \/\/ #14     at 0x6A\n+    Utf8 \"StackMapTable\"; \/\/ #15     at 0x75\n+    class #17; \/\/ #16     at 0x85\n+    Utf8 \"QwithfieldPrimitive;\"; \/\/ #17     at 0x88\n+    Utf8 \"SourceFile\"; \/\/ #18     at 0x90\n+    Utf8 \"withfieldPrimitive.java\"; \/\/ #19     at 0x9D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xB2\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xBC\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index       : getX\n+      #10; \/\/ descriptor_index : ()I\n+      [1] { \/\/ Attributes\n+        Attr(#11, 29) { \/\/ Code at 0xC4\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0xDB\n+              [1] { \/\/ line_number_table\n+                0  13; \/\/  at 0xE7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xE7\n+      0x0009; \/\/ access\n+      #13; \/\/ name_index       : <vnew>\n+      #14; \/\/ descriptor_index : (Z)QwithfieldPrimitive;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 84) { \/\/ Code at 0xEF  \/\/ !!! Change 83 -> 84\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[29]{             \/\/ !!!! Change 28 -> 29\n+            0xCB00014C1A99000D;\n+            0x082B5FCC00034CA7;\n+            0x000C10062B5FB500;  \/\/ !!!! Change goto target B -> C and 0xCC (withfield) to 0xB5 (putfield)\n+            0x032B4C2BB0;        \/\/ !!!! Inserted 0x2B (aload_1)\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#12, 22) { \/\/ LineNumberTable at 0x011D\n+              [5] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0129\n+                4  5; \/\/  at 0x012D\n+                8  6; \/\/  at 0x0131\n+                18  8; \/\/  at 0x0135\n+                26  10; \/\/  at 0x0139\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#15, 9) { \/\/ StackMapTable at 0x0139\n+              [2] { \/\/\n+                252b, 18, [1]z{7b,16}; \/\/ append_frame 1\n+                8b; \/\/ same_frame    \/\/ !!!! change 7 -> 8\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#18, 2) { \/\/ SourceFile at 0x014A\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldPrimitive\n+\n+\n+\n+\/* This jcod class is based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+public primitive final class withfieldNull {\n+    int x;\n+    public withfieldNull() {\n+        String s = null;\n+        x = 5;\n+    }\n+}\n+*\/\n+\/\/ This class tests a withfield bytecode with a stack operand that is null.\n+class withfieldNull {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [15] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldNull\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x19\n+    NameAndType #5 #6; \/\/ #4     at 0x1E\n+    Utf8 \"x\"; \/\/ #5     at 0x23\n+    Utf8 \"I\"; \/\/ #6     at 0x27\n+    class #8; \/\/ #7     at 0x2B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x2E\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x41\n+    Utf8 \"()QwithfieldNull;\"; \/\/ #10     at 0x4A\n+    Utf8 \"Code\"; \/\/ #11     at 0x5A\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x61\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x73\n+    Utf8 \"withfieldNull.java\"; \/\/ #14     at 0x80\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x9B\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : x\n+      #6; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xA5\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <vnew>\n+      #10; \/\/ descriptor_index : ()QwithfieldNull;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 51) { \/\/ Code at 0xAD\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[15]{\n+            0xCB00014B014C0801; \/\/ !!!! Change 0x2A (aload_0) to 0x01 (aconst_null)\n+            0x5FCC00034B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 18) { \/\/ LineNumberTable at 0xCE\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0xDA\n+                4  5; \/\/  at 0xDE\n+                6  6; \/\/  at 0xE2\n+                13  7; \/\/  at 0xE6\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0xE8\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class withfieldNull\n+\n+\n+\n+\/* Thexe jcod classes are based on this Java code. To see what changed from the\n+   original jcod file search for !!!!.\n+\n+public class WrongPrimWF {\n+\n+    public primitive final class Dot { }\n+\n+    public primitive final class Loc { }\n+\n+    public primitive final class Both {\n+        Dot dot;\n+        Loc loc;\n+        Both(Dot d, Loc l) {\n+            dot = d;   \/\/ this d is changed to l to cause the VerifyError\n+            loc = l;\n+        }\n+    }\n+\n+    public WrongPrimWF() {\n+        Both b = new Both(new Dot(), new Loc());\n+    }\n+}\n+\n+*\/\n+\n+\/\/ Test that a withfield opcode, whose stack operand 'Loc' is a different primitive type\n+\/\/ than the primitive class in its constant pool field_res,f causes a VerifyError exception.\n+class WrongPrimWF$Dot {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1F\n+    NameAndType #5 #6; \/\/ #4     at 0x24\n+    Utf8 \"this$0\"; \/\/ #5     at 0x29\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x32\n+    class #8; \/\/ #7     at 0x42\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x45\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x58\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Dot;\"; \/\/ #10     at 0x61\n+    Utf8 \"Code\"; \/\/ #11     at 0x84\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x8B\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x9D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #14     at 0xAA\n+    Utf8 \"NestHost\"; \/\/ #15     at 0xBD\n+    class #17; \/\/ #16     at 0xC8\n+    Utf8 \"WrongPrimWF\"; \/\/ #17     at 0xCB\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xD9\n+    Utf8 \"Dot\"; \/\/ #19     at 0xE8\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xF8\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x0102\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <vnew>\n+      #10; \/\/ descriptor_index : (LWrongPrimWF;)QWrongPrimWF$Dot;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 37) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C2A2B5FCC;\n+            0x00034C2BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0129\n+              [1] { \/\/ line_number_table\n+                0  3; \/\/  at 0x0135\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0x0137\n+      #14;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#15, 2) { \/\/ NestHost at 0x013F\n+      #16; \/\/ WrongPrimWF at 0x0147\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0147\n+      [1] { \/\/ classes\n+        #1 #16 #19 273; \/\/  at 0x0157\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Dot\n+\n+\n+class WrongPrimWF$Loc {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x1F\n+    NameAndType #5 #6; \/\/ #4     at 0x24\n+    Utf8 \"this$0\"; \/\/ #5     at 0x29\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x32\n+    class #8; \/\/ #7     at 0x42\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8     at 0x45\n+    Utf8 \"<vnew>\"; \/\/ #9     at 0x58\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Loc;\"; \/\/ #10     at 0x61\n+    Utf8 \"Code\"; \/\/ #11     at 0x84\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x8B\n+    Utf8 \"SourceFile\"; \/\/ #13     at 0x9D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #14     at 0xAA\n+    Utf8 \"NestHost\"; \/\/ #15     at 0xBD\n+    class #17; \/\/ #16     at 0xC8\n+    Utf8 \"WrongPrimWF\"; \/\/ #17     at 0xCB\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xD9\n+    Utf8 \"Loc\"; \/\/ #19     at 0xE8\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0xF8\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x0102\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index       : <vnew>\n+      #10; \/\/ descriptor_index : (LWrongPrimWF;)QWrongPrimWF$Loc;\n+      [1] { \/\/ Attributes\n+        Attr(#11, 37) { \/\/ Code at 0x010A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014C2A2B5FCC;\n+            0x00034C2BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0129\n+              [1] { \/\/ line_number_table\n+                0  5; \/\/  at 0x0135\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#13, 2) { \/\/ SourceFile at 0x0137\n+      #14;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#15, 2) { \/\/ NestHost at 0x013F\n+      #16; \/\/ WrongPrimWF at 0x0147\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0147\n+      [1] { \/\/ classes\n+        #1 #16 #19 273; \/\/  at 0x0157\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Loc\n+\n+\n+class WrongPrimWF$Both {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [34] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"WrongPrimWF$Both\"; \/\/ #2     at 0x0D\n+    Field #1 #4; \/\/ #3     at 0x20\n+    NameAndType #5 #6; \/\/ #4     at 0x25\n+    Utf8 \"this$0\"; \/\/ #5     at 0x2A\n+    Utf8 \"LWrongPrimWF;\"; \/\/ #6     at 0x33\n+    Field #1 #8; \/\/ #7     at 0x43\n+    NameAndType #9 #10; \/\/ #8     at 0x48\n+    Utf8 \"dot\"; \/\/ #9     at 0x4D\n+    Utf8 \"QWrongPrimWF$Dot;\"; \/\/ #10     at 0x53\n+    Field #1 #12; \/\/ #11     at 0x67\n+    NameAndType #13 #14; \/\/ #12     at 0x6C\n+    Utf8 \"loc\"; \/\/ #13     at 0x71\n+    Utf8 \"QWrongPrimWF$Loc;\"; \/\/ #14     at 0x77\n+    class #16; \/\/ #15     at 0x8B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16     at 0x8E\n+    Utf8 \"<vnew>\"; \/\/ #17     at 0xA1\n+    Utf8 \"(LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\"; \/\/ #18     at 0xAA\n+    Utf8 \"Code\"; \/\/ #19     at 0xF0\n+    Utf8 \"LineNumberTable\"; \/\/ #20     at 0xF7\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0x0109\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #22     at 0x0116\n+    Utf8 \"NestHost\"; \/\/ #23     at 0x0129\n+    class #25; \/\/ #24     at 0x0134\n+    Utf8 \"WrongPrimWF\"; \/\/ #25     at 0x0137\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0x0145\n+    Utf8 \"Both\"; \/\/ #27     at 0x0154\n+    class #29; \/\/ #28     at 0x015B\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #29     at 0x015E\n+    Utf8 \"Dot\"; \/\/ #30     at 0x0170\n+    class #32; \/\/ #31     at 0x0176\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #32     at 0x0179\n+    Utf8 \"Loc\"; \/\/ #33     at 0x018B\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_PRIMITIVE ACC_VALUE ACC_FINAL ACC_PUBLIC ]\n+  #1;\/\/ this_cpx\n+  #15;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [3] { \/\/ Fields\n+    {  \/\/ field at 0x019B\n+      0x0010; \/\/ access\n+      #9; \/\/ name_index       : dot\n+      #10; \/\/ descriptor_index : QWrongPrimWF$Dot;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x01A3\n+      0x0010; \/\/ access\n+      #13; \/\/ name_index       : loc\n+      #14; \/\/ descriptor_index : QWrongPrimWF$Loc;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0x01AB\n+      0x1010; \/\/ access\n+      #5; \/\/ name_index       : this$0\n+      #6; \/\/ descriptor_index : LWrongPrimWF;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x01B5\n+      0x0008; \/\/ access\n+      #17; \/\/ name_index       : <vnew>\n+      #18; \/\/ descriptor_index : (LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\n+      [1] { \/\/ Attributes\n+        Attr(#19, 63) { \/\/ Code at 0x01BD\n+          2; \/\/ max_stack\n+          4; \/\/ max_locals\n+          Bytes[27]{\n+            0xCB00014E2A2D5FCC;\n+            0x00034E2C2D5FCC00; \/\/ !!!! change 2B (aload_1) to 2C (aload_2) to put Loc on the stack.\n+            0x074E2C2D5FCC000B; \/\/      this should cause a VerifyError because withfield is assigning\n+            0x4E2DB0;           \/\/      to a field of type Dot.\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#20, 18) { \/\/ LineNumberTable at 0x01EA\n+              [4] { \/\/ line_number_table\n+                0  10; \/\/  at 0x01F6\n+                11  11; \/\/  at 0x01FA\n+                18  12; \/\/  at 0x01FE\n+                25  13; \/\/  at 0x0202\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0204\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x020C\n+      #24; \/\/ WrongPrimWF at 0x0214\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 26) { \/\/ InnerClasses at 0x0214\n+      [3] { \/\/ classes\n+        #1 #24 #27 273; \/\/  at 0x0224\n+        #28 #24 #30 273; \/\/  at 0x022C\n+        #31 #24 #33 273; \/\/  at 0x0234\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF$Both\n+\n+\n+class WrongPrimWF {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [34] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Method #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #33 #11; \/\/ #9     at 0x41\n+    Utf8 \"WrongPrimWF$Dot\"; \/\/ #10     at 0x46\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Dot;\"; \/\/ #11     at 0x58\n+    Method #13 #14; \/\/ #12     at 0x7B\n+    class #15; \/\/ #13     at 0x80\n+    NameAndType #33 #16; \/\/ #14     at 0x83\n+    Utf8 \"WrongPrimWF$Loc\"; \/\/ #15     at 0x88\n+    Utf8 \"(LWrongPrimWF;)QWrongPrimWF$Loc;\"; \/\/ #16     at 0x9A\n+    Method #18 #19; \/\/ #17     at 0xBD\n+    class #20; \/\/ #18     at 0xC2\n+    NameAndType #33 #21; \/\/ #19     at 0xC5\n+    Utf8 \"WrongPrimWF$Both\"; \/\/ #20     at 0xCA\n+    Utf8 \"(LWrongPrimWF;QWrongPrimWF$Dot;QWrongPrimWF$Loc;)QWrongPrimWF$Both;\"; \/\/ #21     at 0xDD\n+    class #23; \/\/ #22     at 0x0123\n+    Utf8 \"WrongPrimWF\"; \/\/ #23     at 0x0126\n+    Utf8 \"Code\"; \/\/ #24     at 0x0134\n+    Utf8 \"LineNumberTable\"; \/\/ #25     at 0x013B\n+    Utf8 \"SourceFile\"; \/\/ #26     at 0x014D\n+    Utf8 \"WrongPrimWF.java\"; \/\/ #27     at 0x015A\n+    Utf8 \"NestMembers\"; \/\/ #28     at 0x016D\n+    Utf8 \"InnerClasses\"; \/\/ #29     at 0x017B\n+    Utf8 \"Dot\"; \/\/ #30     at 0x018A\n+    Utf8 \"Loc\"; \/\/ #31     at 0x0190\n+    Utf8 \"Both\"; \/\/ #32     at 0x0196\n+    Utf8 \"<vnew>\"; \/\/ #33\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #22;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0x01A9\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#24, 50) { \/\/ Code at 0x01B1\n+          3; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[18]{\n+            0x2AB700012A2AB800;\n+            0x072AB8000CB80011;\n+            0x4CB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#25, 14) { \/\/ LineNumberTable at 0x01D5\n+              [3] { \/\/ line_number_table\n+                0  16; \/\/  at 0x01E1\n+                4  17; \/\/  at 0x01E5\n+                17  18; \/\/  at 0x01E9\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#26, 2) { \/\/ SourceFile at 0x01EB\n+      #27;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#28, 8) { \/\/ NestMembers at 0x01F3\n+      [3] { \/\/ classes\n+        #18; \/\/ WrongPrimWF$Both at 0x01FD\n+        #13; \/\/ WrongPrimWF$Loc at 0x01FF\n+        #8; \/\/ WrongPrimWF$Dot at 0x0201\n+      }\n+    } \/\/ end NestMembers\n+    ;\n+    Attr(#29, 26) { \/\/ InnerClasses at 0x0201\n+      [3] { \/\/ classes\n+        #8 #22 #30 273; \/\/  at 0x0211\n+        #13 #22 #31 273; \/\/  at 0x0219\n+        #18 #22 #32 273; \/\/  at 0x0221\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongPrimWF\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/withfieldTests\/withfieldTests.jcod","additions":1121,"deletions":0,"binary":false,"changes":1121,"status":"added"},{"patch":"@@ -114,0 +114,1 @@\n+    jdk\/modules \\\n@@ -116,1 +117,9 @@\n-    jni\/nullCaller\n+    jni\/nullCaller \\\n+    valhalla\n+\n+# valhalla lworld tests\n+jdk_valhalla = \\\n+    java\/lang\/invoke \\\n+    valhalla \\\n+    java\/lang\/instrument\/valhalla\n+\n","filename":"test\/jdk\/TEST.groups","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.experimental.bytecode.BytePoolHelper;\n+import jdk.experimental.bytecode.ClassBuilder;\n+import jdk.experimental.bytecode.CodeBuilder;\n@@ -29,0 +32,1 @@\n+import jdk.experimental.bytecode.MethodBuilder;\n@@ -31,0 +35,2 @@\n+import jdk.experimental.bytecode.TypeHelper;\n+import jdk.experimental.bytecode.TypeTag;\n@@ -36,0 +42,1 @@\n+import java.util.Iterator;\n@@ -43,0 +50,2 @@\n+import jdk.internal.value.PrimitiveClass;\n+\n@@ -49,0 +58,4 @@\n+    static String generateClassNameFromLookupClass(MethodHandles.Lookup l) {\n+        return l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+    }\n+\n@@ -50,1 +63,1 @@\n-        String className = l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+        String className = generateClassNameFromLookupClass(l);\n@@ -151,0 +164,211 @@\n+\n+\n+    \/\/ loadCode(MethodHandles.Lookup, String, MethodType, Consumer<? super MethodHandleCodeBuilder<?>>) et al...\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return loadCode(lookup, className, methodName, type, builder);\n+    }\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String descriptor = type.toMethodDescriptorString();\n+        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,\n+                    clazz -> {\n+                        try {\n+                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));\n+                        } catch (ReflectiveOperationException ex) {\n+                            throw new IllegalStateException(ex);\n+                        }\n+                    },\n+                    builder);\n+    }\n+\n+    \/\/ Helper method to load code built with \"buildCode()\"\n+    public static MethodHandle loadCodeBytes(MethodHandles.Lookup lookup, String methodName, MethodType type, byte[] byteCode) {\n+        try {\n+            Class<?> clazz = lookup.defineClass(byteCode);\n+            return lookup.findStatic(clazz, methodName, type);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Failed to loadCodeBytes \\\"\" + methodName + \"\\\"\", t);\n+        }\n+    }\n+\n+\n+    private static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(\n+            MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {\n+        try {\n+            byte[] byteArray = buildCode(lookup, className, methodName, type, builderFunc, builder);\n+            Class<?> clazz = lookup.defineClass(byteArray);\n+            return resFunc.apply(clazz);\n+        } catch (Throwable e) {\n+             throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static byte[] buildCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return buildCode(lookup, className, methodName, type.toMethodDescriptorString(), MethodHandleCodeBuilder::new, builder);\n+    }\n+\n+    public static <C extends CodeBuilder<Class<?>, String, byte[], ?>> byte[] buildCode(\n+        MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Consumer<? super C> builder) {\n+\n+                return new IsolatedMethodBuilder(className, lookup)\n+                    .withSuperclass(Object.class)\n+                    .withMajorVersion(65)\n+                    .withMinorVersion(0)\n+                    .withFlags(Flag.ACC_PUBLIC, Flag.ACC_IDENTITY)\n+                    .withMethod(methodName, type, M ->\n+                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n+                            .withCode(builderFunc, builder)).build();\n+\n+    }\n+\n+    private static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {\n+\n+        private static final Class<?> THIS_CLASS = new Object() { }.getClass();\n+\n+        private IsolatedMethodBuilder(String clazz, MethodHandles.Lookup lookup) {\n+            super(new IsolatedMethodPoolHelper(clazz),\n+                  new IsolatedMethodTypeHelper(lookup));\n+            withThisClass(THIS_CLASS);\n+        }\n+\n+        public Class<?> thisClass() {\n+            return THIS_CLASS;\n+        }\n+\n+        static String classToInternalName(Class<?> c) {\n+            if (c.isArray()) {\n+                return c.descriptorString();\n+            }\n+            return c.getName().replace('.', '\/');\n+        }\n+\n+        private static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {\n+\n+            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+            MethodHandles.Lookup lookup;\n+\n+            private IsolatedMethodTypeHelper(MethodHandles.Lookup lookup) {\n+                this.lookup = lookup;\n+            }\n+\n+            @Override\n+            public String elemtype(String s) {\n+                return basicTypeHelper.elemtype(s);\n+            }\n+\n+            @Override\n+            public String arrayOf(String s) {\n+                return basicTypeHelper.arrayOf(s);\n+            }\n+\n+            @Override\n+            public Iterator<String> parameterTypes(String s) {\n+                return basicTypeHelper.parameterTypes(s);\n+            }\n+\n+            @Override\n+            public String fromTag(TypeTag tag) {\n+                return basicTypeHelper.fromTag(tag);\n+            }\n+\n+            @Override\n+            public String returnType(String s) {\n+                return basicTypeHelper.returnType(s);\n+            }\n+\n+            @Override\n+            public String type(Class<?> aClass) {\n+                return aClass.descriptorString();\n+            }\n+\n+            @Override\n+            public boolean isInlineClass(String desc) {\n+                Class<?> aClass = symbol(desc);\n+                return aClass != null && PrimitiveClass.isPrimitiveValueType(aClass);\n+            }\n+\n+            @Override\n+            public Class<?> symbol(String desc) {\n+                try {\n+                    if (desc.startsWith(\"[\")) {\n+                        return Class.forName(desc.replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                    } else {\n+                        Class<?> c = Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        return basicTypeHelper.isInlineClass(desc) ? PrimitiveClass.asValueType(c) : PrimitiveClass.asPrimaryType(c);\n+                    }\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            @Override\n+            public TypeTag tag(String s) {\n+                return basicTypeHelper.tag(s);\n+            }\n+\n+            @Override\n+            public Class<?> symbolFrom(String s) {\n+                return symbol(s);\n+            }\n+\n+            @Override\n+            public String commonSupertype(String t1, String t2) {\n+                return basicTypeHelper.commonSupertype(t1, t2);\n+            }\n+\n+            @Override\n+            public String nullType() {\n+                return basicTypeHelper.nullType();\n+            }\n+        }\n+\n+        private static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {\n+            final String clazz;\n+\n+            private IsolatedMethodPoolHelper(String clazz) {\n+                super(c -> from(c, clazz), s->s);\n+                this.clazz = clazz;\n+            }\n+\n+            static String from(Class<?> c, String clazz) {\n+                return c == THIS_CLASS ? clazz.replace('.', '\/')\n+                                       : classToInternalName(c);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] build() {\n+            return super.build();\n+        }\n+    }\n+\n+    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {\n+\n+        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+\n+        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {\n+            super(methodBuilder);\n+        }\n+\n+        TypeTag getTagType(String s) {\n+            return basicTypeHelper.tag(s);\n+        }\n+\n+        public T ifcmp(String s, CondKind cond, CharSequence label) {\n+            return super.ifcmp(getTagType(s), cond, label);\n+        }\n+\n+        public T return_(String s) {\n+            return super.return_(getTagType(s));\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":226,"deletions":2,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ Generated from this source:\n+\/\/\n+\/\/ value class ValueImpl implements Runnable {\n+\/\/     public void run() {\n+\/\/         System.out.println(\"ValueImpl::run\");\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ then modified \"<vnew>()LValueImpl;\" to \"$make()Ljava\/lang\/Runnable;\"\n+\n+class ValueImpl {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  65; \/\/ version\n+  [29] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueImpl\"; \/\/ #2     at 0x0D\n+    Field #4 #5; \/\/ #3     at 0x19\n+    class #6; \/\/ #4     at 0x1E\n+    NameAndType #7 #8; \/\/ #5     at 0x21\n+    Utf8 \"java\/lang\/System\"; \/\/ #6     at 0x26\n+    Utf8 \"out\"; \/\/ #7     at 0x39\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #8     at 0x3F\n+    String #10; \/\/ #9     at 0x57\n+    Utf8 \"ValueImpl::run\"; \/\/ #10     at 0x5A\n+    Method #12 #13; \/\/ #11     at 0x6B\n+    class #14; \/\/ #12     at 0x70\n+    NameAndType #15 #16; \/\/ #13     at 0x73\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #14     at 0x78\n+    Utf8 \"println\"; \/\/ #15     at 0x8E\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #16     at 0x98\n+    class #18; \/\/ #17     at 0xB0\n+    Utf8 \"java\/lang\/Object\"; \/\/ #18     at 0xB3\n+    class #20; \/\/ #19     at 0xC6\n+    Utf8 \"java\/lang\/Runnable\"; \/\/ #20     at 0xC9\n+    Utf8 \"run\"; \/\/ #21     at 0xDE\n+    Utf8 \"()V\"; \/\/ #22     at 0xE4\n+    Utf8 \"Code\"; \/\/ #23     at 0xEA\n+    Utf8 \"LineNumberTable\"; \/\/ #24     at 0xF1\n+    Utf8 \"$make\"; \/\/ #25     at 0x0103\n+    Utf8 \"()Ljava\/lang\/Runnable;\"; \/\/ #26     at 0x010C\n+    Utf8 \"SourceFile\"; \/\/ #27     at 0x011C\n+    Utf8 \"ValueImpl.java\"; \/\/ #28     at 0x0129\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #17;\/\/ super_cpx\n+\n+  [1] { \/\/ Interfaces\n+    #19;\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ fields\n+  } \/\/ fields\n+\n+  [2] { \/\/ methods\n+    { \/\/ Member at 0x0148\n+      0x0001; \/\/ access\n+      #21; \/\/ name_cpx\n+      #22; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#23, 37) { \/\/ Code at 0x0150\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[9]{\n+            0xB200031209B6000B;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 10) { \/\/ LineNumberTable at 0x016B\n+              [2] { \/\/ LineNumberTable\n+                0  3; \/\/  at 0x0177\n+                8  4; \/\/  at 0x017B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x017B\n+      0x0008; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#23, 30) { \/\/ Code at 0x0183\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#24, 6) { \/\/ LineNumberTable at 0x019B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x01A7\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#27, 2) { \/\/ SourceFile at 0x01A9\n+      #28;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueImpl\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/ValueImpl.jcod","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER, IDENTITY]\")\n@@ -57,0 +57,2 @@\n+            TestIdentityInterface.class,\n+            TestValueInterface.class,\n@@ -155,0 +157,12 @@\n+            \/\/ Verify IDENTITY, ABSTRACT, FINAL, and access mode\n+            Set<AccessFlag> expected = new HashSet<>(4);\n+            expected.add(AccessFlag.ABSTRACT);\n+            expected.add(AccessFlag.FINAL);\n+\/\/            expected.add(AccessFlag.IDENTITY);  \/\/ NYI Pending: JDK-8294866\n+            if (accessLevel != null)\n+                expected.add(accessLevel);\n+            if (!expected.equals(arrayClass.accessFlags())) {\n+                throw new RuntimeException(\"Unexpected access flags for array: \" + accessClass +\n+                        \": actual: \" + arrayClass.accessFlags() +\n+                        \", expected: \" + expected);\n+            }\n@@ -163,0 +177,1 @@\n+    \/\/ Include cases for classes with identity, value modifier, or no modifier.\n@@ -166,0 +181,5 @@\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, IDENTITY, INTERFACE, ABSTRACT]\")\n+    public      identity interface PublicIdentityInterface {}\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, VALUE, INTERFACE, ABSTRACT]\")\n+    public      value interface PublicValueInterface {}\n+\n@@ -168,0 +188,5 @@\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, IDENTITY, INTERFACE, ABSTRACT]\")\n+    protected   identity interface ProtectedIdentityInterface {}\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, VALUE, INTERFACE, ABSTRACT]\")\n+    protected   value interface ProtectedValueInterface {}\n+\n@@ -170,0 +195,5 @@\n+    @ExpectedClassFlags(\"[PRIVATE, STATIC, IDENTITY, INTERFACE, ABSTRACT]\")\n+    private     identity interface PrivateIdentityInterface {}\n+    @ExpectedClassFlags(\"[PRIVATE, STATIC, VALUE, INTERFACE, ABSTRACT]\")\n+    private     value interface PrivateValueInterface {}\n+\n@@ -172,0 +202,4 @@\n+    @ExpectedClassFlags(\"[STATIC, IDENTITY, INTERFACE, ABSTRACT]\")\n+    \/*package*\/ identity interface PackageIdentityInterface {}\n+    @ExpectedClassFlags(\"[STATIC, VALUE, INTERFACE, ABSTRACT]\")\n+    \/*package*\/ value interface PackageValueInterface {}\n@@ -173,1 +207,1 @@\n-    @ExpectedClassFlags(\"[FINAL]\")\n+    @ExpectedClassFlags(\"[FINAL, IDENTITY]\")\n@@ -175,0 +209,2 @@\n+    @ExpectedClassFlags(\"[FINAL, IDENTITY]\")\n+    \/*package*\/ final identity class TestFinalIdentityClass {}\n@@ -176,1 +212,1 @@\n-    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    @ExpectedClassFlags(\"[IDENTITY, ABSTRACT]\")\n@@ -178,0 +214,2 @@\n+    @ExpectedClassFlags(\"[IDENTITY, ABSTRACT]\")\n+    \/*package*\/ abstract identity class TestAbstractIdentityClass {}\n@@ -182,1 +220,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, IDENTITY, ENUM]\")\n@@ -189,1 +227,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, IDENTITY, ABSTRACT, ENUM]\")\n@@ -198,1 +236,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    @ExpectedClassFlags(\"[PRIVATE, IDENTITY, ABSTRACT]\")\n@@ -200,0 +238,2 @@\n+    @ExpectedClassFlags(\"[PRIVATE, IDENTITY, ABSTRACT]\")\n+    private abstract identity class IdentityFoo {}\n@@ -203,0 +243,4 @@\n+    @ExpectedClassFlags(\"[STATIC, IDENTITY, INTERFACE, ABSTRACT]\")\n+    identity interface StaticTestIdentityInterface {}\n+    @ExpectedClassFlags(\"[STATIC, VALUE, INTERFACE, ABSTRACT]\")\n+    value interface StaticTestValueInterface {}\n@@ -213,0 +257,4 @@\n+@ExpectedClassFlags(\"[SUPER, IDENTITY, INTERFACE, ABSTRACT]\")\n+identity interface TestIdentityInterface {}\n+@ExpectedClassFlags(\"[VALUE, INTERFACE, ABSTRACT]\")\n+value interface TestValueInterface {}\n@@ -215,1 +263,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n+@ExpectedClassFlags(\"[FINAL, SUPER, IDENTITY, ENUM]\")\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":55,"deletions":7,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            \"clone\", \"finalize\", \"getClass\", \"hashCode\",\n+            \"clone\", \"finalize\", \"getClass\", \"hashCode\", \"isValueObject\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,0 +154,14 @@\n+  private native Object[] getObjectsViaKlassOopMaps0(Object thing);\n+  public Object[] getObjectsViaKlassOopMaps(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaKlassOopMaps0(thing);\n+  }\n+\n+  private native Object[] getObjectsViaOopIterator0(Object thing);\n+  public Object[] getObjectsViaOopIterator(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaOopIterator0(thing);\n+  }\n+\n+  public native Object[] getObjectsViaFrameOopIterator(int depth);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}