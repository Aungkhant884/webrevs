{"files":[{"patch":"@@ -2466,1 +2466,4 @@\n-  assert(_modified_nodes == NULL, \"not allowed\");\n+#ifdef ASSERT\n+  Unique_Node_List* modified_nodes = _modified_nodes;\n+  _modified_nodes = NULL;\n+#endif\n@@ -2480,0 +2483,1 @@\n+  DEBUG_ONLY( _modified_nodes = modified_nodes; )\n@@ -2733,0 +2737,8 @@\n+  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n+\n+  if (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual and MH calls.\n+    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n+    process_late_inline_calls_no_inline(igvn);\n+  }\n+\n@@ -2764,8 +2776,1 @@\n-\n-  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n-\n-  if (_late_inlines.length() > 0) {\n-    \/\/ More opportunities to optimize virtual and MH calls.\n-    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n-    process_late_inline_calls_no_inline(igvn);\n-  }\n+  assert(_late_inlines.length() == 0, \"missed optimization opportunity\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -676,1 +676,1 @@\n-    InlineTypeNode* def = make_default(gvn, vk);\n+    Node* def = make_default(gvn, vk);\n@@ -678,1 +678,1 @@\n-      return gvn.transform(new InlineTypePtrNode(def, false));\n+      def = gvn.transform(new InlineTypePtrNode(def->as_InlineType(), false));\n@@ -680,0 +680,1 @@\n+    kit->record_for_igvn(def);\n@@ -696,0 +697,1 @@\n+    kit->record_for_igvn(vt);\n@@ -705,1 +707,1 @@\n-        return make_default(gvn, vk);\n+        vt = make_default(gvn, vk);\n@@ -707,1 +709,1 @@\n-        return InlineTypePtrNode::make_null(gvn, vk);\n+        vt = InlineTypePtrNode::make_null(gvn, vk);\n@@ -709,0 +711,2 @@\n+      kit->record_for_igvn(vt);\n+      return vt;\n@@ -747,0 +751,1 @@\n+  kit->record_for_igvn(vt);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2040,1 +2040,3 @@\n-  case Op_FastLock:      \/\/ Revisit FastLocks for lock coarsening\n+  case Op_CallStaticJava:  \/\/ Give post-parse call devirtualization a chance\n+  case Op_CallDynamicJava:\n+  case Op_FastLock:        \/\/ Revisit FastLocks for lock coarsening\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallDynamicJava\" + MID + IS_REPLACED + END;\n+    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallStaticJava\" + MID + IS_REPLACED + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4096,0 +4096,48 @@\n+\n+    \/\/ Test post-parse call devirtualization with inline type receiver\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test150() {\n+        MyValue2 val = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test150\")\n+    public void test150_verifier() {\n+        Asserts.assertEquals(test150(), testValue2.hash());\n+    }\n+\n+    \/\/ Same as test150 but with val not being allocated in the scope of the method\n+    @Test\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test151(MyValue2 val) {\n+        MyAbstract receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 100; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test151\")\n+    @Warmup(0) \/\/ Make sure there is no receiver type profile\n+    public void test151_verifier() {\n+        Asserts.assertEquals(test151(testValue2), testValue2.hash());\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"}]}