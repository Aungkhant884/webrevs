{"files":[{"patch":"@@ -659,0 +659,2 @@\n+6b65f4e7a975628df51ef755b02642075390041d jdk-15+33\n+c3a4a7ea7c304cabdacdc31741eb94c51351668d jdk-16+7\n","filename":".hgtags","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1102,1 +1102,1 @@\n-    if (UseCompressedOops && CompressedOops::ptrs_base() != NULL) {\n+    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL || UseAOT)) {\n@@ -3746,1 +3746,1 @@\n-  \/\/ Inline Cache Register or methodOop for I2C.\n+  \/\/ Inline Cache Register or Method for I2C.\n@@ -4097,0 +4097,12 @@\n+operand immL_positive_bitmaskI()\n+%{\n+  predicate((n->get_long() != 0)\n+            && ((julong)n->get_long() < 0x80000000ULL)\n+            && is_power_of_2(n->get_long() + 1));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -10240,1 +10252,1 @@\n-          $scale$$constant & 63, MIN(32, (-$scale$$constant) & 63));\n+          $scale$$constant & 63, MIN2(32, (int)((-$scale$$constant) & 63)));\n@@ -12239,0 +12251,44 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+\n+\/\/ We can use ubfiz when masking by a positive number and then left shifting the result.\n+\/\/ We know that the mask is positive because immI_bitmask guarantees it.\n+instruct ubfizwIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)\n+%{\n+  match(Set dst (ConvI2L (LShiftI (AndI src mask) lshift)));\n+  predicate((exact_log2(n->in(1)->in(1)->in(2)->get_int() + 1) + (n->in(1)->in(2)->get_int() & 31)) <= 31);\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"ubfizw $dst, $src, $lshift, $mask\" %}\n+  ins_encode %{\n+    int lshift = $lshift$$constant & 31;\n+    intptr_t mask = $mask$$constant;\n+    int width = exact_log2(mask+1);\n+    __ ubfizw(as_Register($dst$$reg),\n+          as_Register($src$$reg), lshift, width);\n+  %}\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+\n+\/\/ We can use ubfiz when masking by a positive number and then left shifting the result.\n+\/\/ We know that the mask is positive because immL_bitmask guarantees it.\n+instruct ubfizLConvL2I(iRegINoSp dst, iRegL src, immI lshift, immL_positive_bitmaskI mask)\n+%{\n+  match(Set dst (ConvL2I (LShiftL (AndL src mask) lshift)));\n+  predicate((exact_log2_long(n->in(1)->in(1)->in(2)->get_long() + 1) + (n->in(1)->in(2)->get_int() & 63)) <= 31);\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"ubfiz $dst, $src, $lshift, $mask\" %}\n+  ins_encode %{\n+    int lshift = $lshift$$constant & 63;\n+    intptr_t mask = $mask$$constant;\n+    int width = exact_log2_long(mask+1);\n+    __ ubfiz(as_Register($dst$$reg),\n+          as_Register($src$$reg), lshift, width);\n+  %}\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n@@ -12261,0 +12317,36 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+\n+\/\/ If there is a convert L to I block between and AndL and a LShiftI, we can also match ubfiz\n+instruct ubfizLConvL2Ix(iRegINoSp dst, iRegL src, immI lshift, immL_positive_bitmaskI mask)\n+%{\n+  match(Set dst (LShiftI (ConvL2I (AndL src mask)) lshift));\n+  predicate((exact_log2_long(n->in(1)->in(1)->in(2)->get_long() + 1) + (n->in(2)->get_int() & 31)) <= 31);\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"ubfiz $dst, $src, $lshift, $mask\" %}\n+  ins_encode %{\n+    int lshift = $lshift$$constant & 31;\n+    intptr_t mask = $mask$$constant;\n+    int width = exact_log2(mask+1);\n+    __ ubfiz(as_Register($dst$$reg),\n+             as_Register($src$$reg), lshift, width);\n+  %}\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+\n+\/\/ Can skip int2long conversions after AND with small bitmask\n+instruct ubfizIConvI2LAndI(iRegLNoSp dst, iRegI src, immI_bitmask msk)\n+%{\n+  match(Set dst (ConvI2L (AndI src msk)));\n+  ins_cost(INSN_COST);\n+  format %{ \"ubfiz $dst, $src, 0, exact_log2($msk + 1) \" %}\n+  ins_encode %{\n+    __ ubfiz(as_Register($dst$$reg), as_Register($src$$reg), 0, exact_log2($msk$$constant + 1));\n+  %}\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n@@ -15568,1 +15660,1 @@\n-instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_oop)\n+instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_ptr)\n@@ -15570,1 +15662,1 @@\n-  match(TailCall jump_target method_oop);\n+  match(TailCall jump_target method_ptr);\n@@ -15574,1 +15666,1 @@\n-  format %{ \"br $jump_target\\t# $method_oop holds method oop\" %}\n+  format %{ \"br $jump_target\\t# $method_ptr holds method\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":98,"deletions":6,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -216,0 +216,13 @@\n+\/\/ Ensure a valid Address (base + offset) to a stack-slot. If stack access is\n+\/\/ not encodable as a base + (immediate) offset, generate an explicit address\n+\/\/ calculation to hold the address in a temporary register.\n+Address LIR_Assembler::stack_slot_address(int index, uint size, Register tmp, int adjust) {\n+  precond(size == 4 || size == 8);\n+  Address addr = frame_map()->address_for_slot(index, adjust);\n+  precond(addr.getMode() == Address::base_plus_offset);\n+  precond(addr.base() == sp);\n+  precond(addr.offset() > 0);\n+  uint mask = size - 1;\n+  assert((addr.offset() & mask) == 0, \"scaled offsets only\");\n+  return __ legitimize_address(addr, size, tmp);\n+}\n@@ -764,0 +777,5 @@\n+  precond(src->is_register() && dest->is_stack());\n+\n+  uint const c_sz32 = sizeof(uint32_t);\n+  uint const c_sz64 = sizeof(uint64_t);\n+\n@@ -765,0 +783,1 @@\n+    int index = dest->single_stack_ix();\n@@ -766,1 +785,1 @@\n-      __ str(src->as_register(), frame_map()->address_for_slot(dest->single_stack_ix()));\n+      __ str(src->as_register(), stack_slot_address(index, c_sz64, rscratch1));\n@@ -769,1 +788,1 @@\n-      __ str(src->as_register(), frame_map()->address_for_slot(dest->single_stack_ix()));\n+      __ str(src->as_register(), stack_slot_address(index, c_sz64, rscratch1));\n@@ -771,1 +790,1 @@\n-      __ strw(src->as_register(), frame_map()->address_for_slot(dest->single_stack_ix()));\n+      __ strw(src->as_register(), stack_slot_address(index, c_sz32, rscratch1));\n@@ -775,1 +794,2 @@\n-    Address dest_addr_LO = frame_map()->address_for_slot(dest->double_stack_ix(), lo_word_offset_in_bytes);\n+    int index = dest->double_stack_ix();\n+    Address dest_addr_LO = stack_slot_address(index, c_sz64, rscratch1, lo_word_offset_in_bytes);\n@@ -779,2 +799,2 @@\n-    Address dest_addr = frame_map()->address_for_slot(dest->single_stack_ix());\n-    __ strs(src->as_float_reg(), dest_addr);\n+    int index = dest->single_stack_ix();\n+    __ strs(src->as_float_reg(), stack_slot_address(index, c_sz32, rscratch1));\n@@ -783,2 +803,2 @@\n-    Address dest_addr = frame_map()->address_for_slot(dest->double_stack_ix());\n-    __ strd(src->as_double_reg(), dest_addr);\n+    int index = dest->double_stack_ix();\n+    __ strd(src->as_double_reg(), stack_slot_address(index, c_sz64, rscratch1));\n@@ -789,1 +809,0 @@\n-\n@@ -875,2 +894,4 @@\n-  assert(src->is_stack(), \"should not call otherwise\");\n-  assert(dest->is_register(), \"should not call otherwise\");\n+  precond(src->is_stack() && dest->is_register());\n+\n+  uint const c_sz32 = sizeof(uint32_t);\n+  uint const c_sz64 = sizeof(uint64_t);\n@@ -879,0 +900,1 @@\n+    int index = src->single_stack_ix();\n@@ -880,1 +902,1 @@\n-      __ ldr(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()));\n+      __ ldr(dest->as_register(), stack_slot_address(index, c_sz64, rscratch1));\n@@ -883,1 +905,1 @@\n-      __ ldr(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()));\n+      __ ldr(dest->as_register(), stack_slot_address(index, c_sz64, rscratch1));\n@@ -885,1 +907,1 @@\n-      __ ldrw(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()));\n+      __ ldrw(dest->as_register(), stack_slot_address(index, c_sz32, rscratch1));\n@@ -889,1 +911,2 @@\n-    Address src_addr_LO = frame_map()->address_for_slot(src->double_stack_ix(), lo_word_offset_in_bytes);\n+    int index = src->double_stack_ix();\n+    Address src_addr_LO = stack_slot_address(index, c_sz64, rscratch1, lo_word_offset_in_bytes);\n@@ -893,2 +916,2 @@\n-    Address src_addr = frame_map()->address_for_slot(src->single_stack_ix());\n-    __ ldrs(dest->as_float_reg(), src_addr);\n+    int index = src->single_stack_ix();\n+    __ ldrs(dest->as_float_reg(), stack_slot_address(index, c_sz32, rscratch1));\n@@ -897,2 +920,2 @@\n-    Address src_addr = frame_map()->address_for_slot(src->double_stack_ix());\n-    __ ldrd(dest->as_double_reg(), src_addr);\n+    int index = src->double_stack_ix();\n+    __ ldrd(dest->as_double_reg(), stack_slot_address(index, c_sz64, rscratch1));\n@@ -2256,0 +2279,7 @@\n+  if (compilation()->debug_info_recorder()->last_pc_offset() == __ offset()) {\n+    \/\/ As no instructions have been generated yet for this LIR node it's\n+    \/\/ possible that an oop map already exists for the current offset.\n+    \/\/ In that case insert an dummy NOP here to ensure all oop map PCs\n+    \/\/ are unique. See JDK-8237483.\n+    __ nop();\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":49,"deletions":19,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-  \/\/ When we need to use something other than rscratch1 use this\n-  \/\/ method.\n+  \/\/ When we need to use something other than rscratch1 use this method.\n@@ -52,0 +51,3 @@\n+  \/\/ Ensure we have a valid Address (base+offset) to a stack-slot.\n+  Address stack_slot_address(int index, uint shift, Register tmp, int adjust = 0);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -662,4 +662,4 @@\n-static __thread uintptr_t nextfp;\n-static __thread uintptr_t nextpc;\n-static __thread uintptr_t nextsp;\n-static __thread RegisterMap *reg_map;\n+static THREAD_LOCAL uintptr_t nextfp;\n+static THREAD_LOCAL uintptr_t nextpc;\n+static THREAD_LOCAL uintptr_t nextsp;\n+static THREAD_LOCAL RegisterMap *reg_map;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,0 @@\n-  RegSet savedRegs = RegSet::range(r0, r28) - RegSet::of(dst, rscratch1, rscratch2);\n-\n@@ -85,1 +83,1 @@\n-  __ push(savedRegs, sp);\n+  __ push_call_clobbered_registers_except(RegSet::of(dst));\n@@ -92,11 +90,0 @@\n-  int step = 4 * wordSize;\n-  __ mov(rscratch2, -step);\n-  __ sub(sp, sp, step);\n-\n-  for (int i = 28; i >= 4; i -= 4) {\n-    __ st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), __ T1D, Address(__ post(sp, rscratch2)));\n-  }\n-  __ st1(as_FloatRegister(0), as_FloatRegister(1), as_FloatRegister(2),\n-      as_FloatRegister(3), __ T1D, Address(sp));\n-\n@@ -105,5 +92,0 @@\n-  for (int i = 0; i <= 28; i += 4) {\n-    __ ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), __ T1D, Address(__ post(sp, step)));\n-  }\n-\n@@ -115,1 +97,1 @@\n-  __ pop(savedRegs, sp);\n+  __ pop_call_clobbered_registers_except(RegSet::of(dst));\n@@ -174,1 +156,1 @@\n-  __ pusha();\n+  __ push(saved_regs, sp);\n@@ -193,1 +175,2 @@\n-  __ popa();\n+  __ pop(saved_regs, sp);\n+\n@@ -299,7 +282,1 @@\n-  \/\/ We don't use push\/pop_clobbered_registers() - we need to pull out the result from r0.\n-  for (int i = 0; i < 32; i += 2) {\n-    __ stpd(as_FloatRegister(i), as_FloatRegister(i + 1), Address(__ pre(sp,-16)));\n-  }\n-\n-  const RegSet save_regs = RegSet::range(r1, r28);\n-  __ push(save_regs, sp);\n+  __ push_call_clobbered_registers_except(RegSet::of(r0));\n@@ -313,5 +290,1 @@\n-  __ pop(save_regs, sp);\n-\n-  for (int i = 30; i >= 0; i -= 2) {\n-    __ ldpd(as_FloatRegister(i), as_FloatRegister(i + 1), Address(__ post(sp, 16)));\n-  }\n+  __ pop_call_clobbered_registers_except(RegSet::of(r0));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2675,1 +2675,1 @@\n-void MacroAssembler::push_call_clobbered_registers() {\n+void MacroAssembler::push_call_clobbered_registers_except(RegSet exclude) {\n@@ -2677,1 +2677,1 @@\n-  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);\n+  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) - exclude, sp);\n@@ -2690,1 +2690,1 @@\n-void MacroAssembler::pop_call_clobbered_registers() {\n+void MacroAssembler::pop_call_clobbered_registers_except(RegSet exclude) {\n@@ -2697,1 +2697,1 @@\n-  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);\n+  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) - exclude, sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n@@ -485,3 +485,12 @@\n-  \/\/ 64 bits of each vector register.\n-  void push_call_clobbered_registers();\n-  void pop_call_clobbered_registers();\n+  \/\/ 64 bits of each vector register. Additonal registers can be excluded\n+  \/\/ in a passed RegSet.\n+  void push_call_clobbered_registers_except(RegSet exclude);\n+  void pop_call_clobbered_registers_except(RegSet exclude);\n+\n+  void push_call_clobbered_registers() {\n+    push_call_clobbered_registers_except(RegSet());\n+  }\n+  void pop_call_clobbered_registers() {\n+    pop_call_clobbered_registers_except(RegSet());\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4078,1 +4078,1 @@\n-    int prefetchLoopExitCondition = MAX(64, SoftwarePrefetchHintDistance\/2);\n+    int prefetchLoopExitCondition = MAX2(64, SoftwarePrefetchHintDistance\/2);\n@@ -4236,1 +4236,1 @@\n-    int largeLoopExitCondition = MAX(64, SoftwarePrefetchHintDistance)\/(isLL ? 1 : 2);\n+    int largeLoopExitCondition = MAX2(64, SoftwarePrefetchHintDistance)\/(isLL ? 1 : 2);\n@@ -4662,1 +4662,1 @@\n-    const int large_loop_threshold = MAX(64, SoftwarePrefetchHintDistance)\/8 + 4;\n+    const int large_loop_threshold = MAX2(64, SoftwarePrefetchHintDistance)\/8 + 4;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3550,1 +3550,1 @@\n-         \"methodOop must be rmethod for interpreter calling convention\");\n+         \"Method must be rmethod for interpreter calling convention\");\n@@ -3573,1 +3573,1 @@\n-  \/\/ get target methodOop & entry point\n+  \/\/ get target Method & entry point\n@@ -3708,1 +3708,1 @@\n-  \/\/ rmethod,: methodOop to call\n+  \/\/ rmethod,: Method to call\n@@ -3720,1 +3720,1 @@\n-  \/\/ rmethod,: methodOop\n+  \/\/ rmethod,: Method\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,0 +49,24 @@\n+static void save_xmm_registers(MacroAssembler* masm) {\n+    __ subptr(rsp, 64);\n+    __ movdbl(Address(rsp, 0), xmm0);\n+    __ movdbl(Address(rsp, 8), xmm1);\n+    __ movdbl(Address(rsp, 16), xmm2);\n+    __ movdbl(Address(rsp, 24), xmm3);\n+    __ movdbl(Address(rsp, 32), xmm4);\n+    __ movdbl(Address(rsp, 40), xmm5);\n+    __ movdbl(Address(rsp, 48), xmm6);\n+    __ movdbl(Address(rsp, 56), xmm7);\n+}\n+\n+static void restore_xmm_registers(MacroAssembler* masm) {\n+    __ movdbl(xmm0, Address(rsp, 0));\n+    __ movdbl(xmm1, Address(rsp, 8));\n+    __ movdbl(xmm2, Address(rsp, 16));\n+    __ movdbl(xmm3, Address(rsp, 24));\n+    __ movdbl(xmm4, Address(rsp, 32));\n+    __ movdbl(xmm5, Address(rsp, 40));\n+    __ movdbl(xmm6, Address(rsp, 48));\n+    __ movdbl(xmm7, Address(rsp, 56));\n+    __ addptr(rsp, 64);\n+}\n+\n@@ -293,0 +317,1 @@\n+  save_xmm_registers(masm);\n@@ -294,0 +319,1 @@\n+  restore_xmm_registers(masm);\n@@ -371,0 +397,2 @@\n+\n+  save_xmm_registers(masm);\n@@ -372,0 +400,1 @@\n+  restore_xmm_registers(masm);\n@@ -517,9 +546,1 @@\n-    __ subptr(rsp, 64);\n-    __ movdbl(Address(rsp, 0), xmm0);\n-    __ movdbl(Address(rsp, 8), xmm1);\n-    __ movdbl(Address(rsp, 16), xmm2);\n-    __ movdbl(Address(rsp, 24), xmm3);\n-    __ movdbl(Address(rsp, 32), xmm4);\n-    __ movdbl(Address(rsp, 40), xmm5);\n-    __ movdbl(Address(rsp, 48), xmm6);\n-    __ movdbl(Address(rsp, 56), xmm7);\n+    save_xmm_registers(masm);\n@@ -542,9 +563,1 @@\n-    __ movdbl(xmm0, Address(rsp, 0));\n-    __ movdbl(xmm1, Address(rsp, 8));\n-    __ movdbl(xmm2, Address(rsp, 16));\n-    __ movdbl(xmm3, Address(rsp, 24));\n-    __ movdbl(xmm4, Address(rsp, 32));\n-    __ movdbl(xmm5, Address(rsp, 40));\n-    __ movdbl(xmm6, Address(rsp, 48));\n-    __ movdbl(xmm7, Address(rsp, 56));\n-    __ addptr(rsp, 64);\n+    restore_xmm_registers(masm);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -962,1 +962,1 @@\n-  \/\/ The generated handlers do not touch RBX (the method oop).\n+  \/\/ The generated handlers do not touch RBX (the method).\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1934,1 +1934,1 @@\n-\/\/     \/\/ \/\/ Interpreter expects method_oop in EBX, currently a callee-saved register,\n+\/\/     \/\/ \/\/ Interpreter expects method_ptr in EBX, currently a callee-saved register,\n@@ -1936,1 +1936,1 @@\n-\/\/     \/\/ emit_opcode(cbuf, 0x8B);                     \/\/ MOV    imo_reg,ic_reg  # method_oop\n+\/\/     \/\/ emit_opcode(cbuf, 0x8B);                     \/\/ MOV    imo_reg,ic_reg  # method_ptr\n@@ -13317,2 +13317,2 @@\n-instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{\n-  match(TailCall jump_target method_oop );\n+instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_ptr) %{\n+  match(TailCall jump_target method_ptr);\n@@ -13320,1 +13320,1 @@\n-  format %{ \"JMP    $jump_target \\t# EBX holds method oop\" %}\n+  format %{ \"JMP    $jump_target \\t# EBX holds method\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -12777,1 +12777,1 @@\n-instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)\n+instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_ptr)\n@@ -12779,1 +12779,1 @@\n-  match(TailCall jump_target method_oop);\n+  match(TailCall jump_target method_ptr);\n@@ -12782,1 +12782,1 @@\n-  format %{ \"jmp     $jump_target\\t# rbx holds method oop\" %}\n+  format %{ \"jmp     $jump_target\\t# rbx holds method\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,1 +468,1 @@\n-  int           _index;  \/\/ index of the patchable oop or Klass* in nmethod oop or metadata table if needed\n+  int           _index;  \/\/ index of the patchable oop or Klass* in nmethod or metadata table if needed\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-\/\/ method) method oop is passed as an argument. In order to do that it is embedded in the code as\n+\/\/ method) method is passed as an argument. In order to do that it is embedded in the code as\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-    \/\/ methodOopDesc::build_interpreter_method_data(method, CHECK);\n+    \/\/ Method::build_interpreter_method_data(method, CHECK);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -900,1 +900,1 @@\n-      k->set_java_mirror_handle(OopHandle());\n+      k->clear_java_mirror_handle();\n@@ -1132,2 +1132,3 @@\n-  for (int t = 0; t <= T_VOID; t++) {\n-    oop m = Universe::_mirrors[t];\n+  for (int t = T_BOOLEAN; t < T_VOID+1; t++) {\n+    BasicType bt = (BasicType)t;\n+    oop m = Universe::_mirrors[t].resolve();\n@@ -1153,1 +1154,1 @@\n-        type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));\n+        type2name(bt), p2i(m), p2i(archived_m));\n@@ -1155,1 +1156,1 @@\n-      Universe::_mirrors[t] = archived_m;\n+      Universe::replace_mirror(bt, archived_m);\n@@ -1158,21 +1159,0 @@\n-\n-  assert(Universe::_mirrors[T_INT] != NULL &&\n-         Universe::_mirrors[T_FLOAT] != NULL &&\n-         Universe::_mirrors[T_DOUBLE] != NULL &&\n-         Universe::_mirrors[T_BYTE] != NULL &&\n-         Universe::_mirrors[T_BOOLEAN] != NULL &&\n-         Universe::_mirrors[T_CHAR] != NULL &&\n-         Universe::_mirrors[T_LONG] != NULL &&\n-         Universe::_mirrors[T_SHORT] != NULL &&\n-         Universe::_mirrors[T_VOID] != NULL, \"sanity\");\n-\n-  Universe::set_int_mirror(Universe::_mirrors[T_INT]);\n-  Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);\n-  Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);\n-  Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);\n-  Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);\n-  Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);\n-  Universe::set_long_mirror(Universe::_mirrors[T_LONG]);\n-  Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);\n-  Universe::set_void_mirror(Universe::_mirrors[T_VOID]);\n-\n@@ -1212,1 +1192,1 @@\n-      k->set_java_mirror_handle(OopHandle());\n+      k->clear_java_mirror_handle();\n@@ -1219,1 +1199,1 @@\n-    k->set_java_mirror_handle(OopHandle());\n+    k->set_java_mirror(Handle());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1658,1 +1658,1 @@\n-  if (!UseJVMCINativeLibrary && comp->is_jvmci() && !task->should_wait_for_compilation()) {\n+  if (comp->is_jvmci() && !task->should_wait_for_compilation()) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1155,2 +1155,2 @@\n-C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))\n-  JavaThread::resize_all_jvmci_counters(new_size);\n+C2V_VMENTRY_0(jboolean, setCountersSize, (JNIEnv* env, jobject, jint new_size))\n+  return JavaThread::resize_all_jvmci_counters(new_size);\n@@ -1576,1 +1576,1 @@\n-extern \"C\" void jio_printf(const char *fmt, ...);\n+extern \"C\" int jio_printf(const char *fmt, ...);\n@@ -2763,1 +2763,1 @@\n-  {CC \"setCountersSize\",                              CC \"(I)V\",                                                                            FN_PTR(setCountersSize)},\n+  {CC \"setCountersSize\",                              CC \"(I)Z\",                                                                            FN_PTR(setCountersSize)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allStatic.hpp\"\n@@ -353,7 +354,0 @@\n-class AllStatic {\n- public:\n-  AllStatic()  { ShouldNotCallThis(); }\n-  ~AllStatic() { ShouldNotCallThis(); }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -719,13 +719,0 @@\n-static void clear_basic_type_mirrors() {\n-  assert(!HeapShared::is_heap_object_archiving_allowed(), \"Sanity\");\n-  Universe::set_int_mirror(NULL);\n-  Universe::set_float_mirror(NULL);\n-  Universe::set_double_mirror(NULL);\n-  Universe::set_byte_mirror(NULL);\n-  Universe::set_bool_mirror(NULL);\n-  Universe::set_char_mirror(NULL);\n-  Universe::set_long_mirror(NULL);\n-  Universe::set_short_mirror(NULL);\n-  Universe::set_void_mirror(NULL);\n-}\n-\n@@ -1561,1 +1548,1 @@\n-    clear_basic_type_mirrors();\n+    Universe::clear_basic_type_mirrors();\n@@ -2113,1 +2100,1 @@\n-    p = NULL;\n+    *p = NULL;\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -91,15 +91,0 @@\n-#define PRIMITIVE_MIRRORS_DO(func) \\\n-  func(_int_mirror)    \\\n-  func(_float_mirror)  \\\n-  func(_double_mirror) \\\n-  func(_byte_mirror)   \\\n-  func(_bool_mirror)   \\\n-  func(_char_mirror)   \\\n-  func(_long_mirror)   \\\n-  func(_short_mirror)  \\\n-  func(_void_mirror)\n-\n-#define DEFINE_PRIMITIVE_MIRROR(m) \\\n-    oop Universe::m  = NULL;\n-\n-PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)\n@@ -109,1 +94,1 @@\n-oop Universe::_mirrors[T_VOID+1]                      = { NULL \/*, NULL...*\/ };\n+OopHandle Universe::_mirrors[T_VOID+1];\n@@ -121,0 +106,1 @@\n+                           _oom_c_heap,\n@@ -138,1 +124,1 @@\n-oop Universe::_reference_pending_list = NULL;\n+OopHandle Universe::_reference_pending_list;\n@@ -202,0 +188,29 @@\n+oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }\n+oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }\n+oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }\n+oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }\n+oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }\n+oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }\n+oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }\n+oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }\n+oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }\n+\n+oop Universe::java_mirror(BasicType t) {\n+  assert((uint)t < T_VOID+1, \"range check\");\n+  return check_mirror(_mirrors[t].resolve());\n+}\n+\n+\/\/ Used by CDS dumping\n+void Universe::replace_mirror(BasicType t, oop new_mirror) {\n+  Universe::_mirrors[t].replace(new_mirror);\n+}\n+\n+\/\/ Not sure why CDS has to do this\n+void Universe::clear_basic_type_mirrors() {\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    if (!is_reference_type((BasicType)i)) {\n+      Universe::_mirrors[i].replace(NULL);\n+    }\n+  }\n+}\n+\n@@ -214,10 +229,0 @@\n-#define DO_PRIMITIVE_MIRROR(m) \\\n-  f->do_oop((oop*) &m);\n-\n-  PRIMITIVE_MIRRORS_DO(DO_PRIMITIVE_MIRROR);\n-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-    f->do_oop(&_mirrors[i]);\n-  }\n-  assert(_mirrors[0] == NULL && _mirrors[T_BOOLEAN - 1] == NULL, \"checking\");\n-\n-  f->do_oop(&_reference_pending_list);\n@@ -256,7 +261,0 @@\n-#define ASSERT_MIRROR_NULL(m) \\\n-  assert(m == NULL, \"archived mirrors should be NULL\");\n-\n-#define SERIALIZE_MIRROR(m) \\\n-  f->do_oop(&m); \\\n-  if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }\n-\n@@ -266,0 +264,22 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  {\n+    oop mirror_oop;\n+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+      if (f->reading()) {\n+        f->do_oop(&mirror_oop); \/\/ read from archive\n+        assert(oopDesc::is_oop_or_null(mirror_oop), \"is oop\");\n+        \/\/ Only create an OopHandle for non-null mirrors\n+        if (mirror_oop != NULL) {\n+          _mirrors[i] = OopHandle(vm_global(), mirror_oop);\n+        }\n+      } else {\n+        mirror_oop = _mirrors[i].resolve();\n+        f->do_oop(&mirror_oop); \/\/ write to archive\n+      }\n+      if (mirror_oop != NULL) { \/\/ may be null if archived heap is disabled\n+        java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);\n+      }\n+    }\n+  }\n+#endif\n+\n@@ -271,8 +291,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  DEBUG_ONLY(if (DumpSharedSpaces && !HeapShared::is_heap_object_archiving_allowed()) {\n-      PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);\n-    });\n-  PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);\n-#endif\n-\n@@ -295,0 +307,1 @@\n+\n@@ -396,0 +409,3 @@\n+  \/\/ Create a handle for reference_pending_list\n+  _reference_pending_list = OopHandle(vm_global(), NULL);\n+\n@@ -452,3 +468,0 @@\n-#define ASSERT_MIRROR_NOT_NULL(m) \\\n-  assert(m != NULL, \"archived mirrors should not be NULL\");\n-\n@@ -459,1 +472,1 @@\n-        _int_mirror != NULL) {\n+        _mirrors[T_INT].resolve() != NULL) {\n@@ -461,1 +474,8 @@\n-      PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NOT_NULL);\n+\n+      \/\/ check that all mirrors are mapped also\n+      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+        if (!is_reference_type((BasicType)i)) {\n+          oop m = _mirrors[i].resolve();\n+          assert(m != NULL, \"archived mirrors should not be NULL\");\n+        }\n+      }\n@@ -463,1 +483,1 @@\n-      \/\/ _int_mirror could be NULL if archived heap is not mapped.\n+      \/\/ _mirror[T_INT} could be NULL if archived heap is not mapped.\n@@ -466,18 +486,7 @@\n-      _int_mirror     =\n-        java_lang_Class::create_basic_type_mirror(\"int\",    T_INT, CHECK);\n-      _float_mirror   =\n-        java_lang_Class::create_basic_type_mirror(\"float\",  T_FLOAT,   CHECK);\n-      _double_mirror  =\n-        java_lang_Class::create_basic_type_mirror(\"double\", T_DOUBLE,  CHECK);\n-      _byte_mirror    =\n-        java_lang_Class::create_basic_type_mirror(\"byte\",   T_BYTE, CHECK);\n-      _bool_mirror    =\n-        java_lang_Class::create_basic_type_mirror(\"boolean\",T_BOOLEAN, CHECK);\n-      _char_mirror    =\n-        java_lang_Class::create_basic_type_mirror(\"char\",   T_CHAR, CHECK);\n-      _long_mirror    =\n-        java_lang_Class::create_basic_type_mirror(\"long\",   T_LONG, CHECK);\n-      _short_mirror   =\n-        java_lang_Class::create_basic_type_mirror(\"short\",  T_SHORT,   CHECK);\n-      _void_mirror    =\n-        java_lang_Class::create_basic_type_mirror(\"void\",   T_VOID, CHECK);\n+      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+        BasicType bt = (BasicType)i;\n+        if (!is_reference_type(bt)) {\n+          oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+          _mirrors[i] = OopHandle(vm_global(), m);\n+        }\n+      }\n@@ -485,12 +494,0 @@\n-\n-    _mirrors[T_INT]     = _int_mirror;\n-    _mirrors[T_FLOAT]   = _float_mirror;\n-    _mirrors[T_DOUBLE]  = _double_mirror;\n-    _mirrors[T_BYTE]    = _byte_mirror;\n-    _mirrors[T_BOOLEAN] = _bool_mirror;\n-    _mirrors[T_CHAR]    = _char_mirror;\n-    _mirrors[T_LONG]    = _long_mirror;\n-    _mirrors[T_SHORT]   = _short_mirror;\n-    _mirrors[T_VOID]    = _void_mirror;\n-  \/\/_mirrors[T_OBJECT]  = _object_klass->java_mirror();\n-  \/\/_mirrors[T_ARRAY]   = _object_klass->java_mirror();\n@@ -543,1 +540,1 @@\n-  return _reference_pending_list;\n+  return _reference_pending_list.resolve();\n@@ -548,1 +545,1 @@\n-  _reference_pending_list = NULL;\n+  _reference_pending_list.replace(NULL);\n@@ -553,1 +550,1 @@\n-  return _reference_pending_list != NULL;\n+  return _reference_pending_list.peek() != NULL;\n@@ -558,1 +555,1 @@\n-  return Atomic::xchg(&_reference_pending_list, list);\n+  return _reference_pending_list.xchg(list);\n@@ -611,0 +608,4 @@\n+oop Universe::out_of_memory_error_c_heap() {\n+  return gen_out_of_memory_error(out_of_memory_errors()->obj_at(_oom_c_heap));\n+}\n+\n@@ -706,0 +707,3 @@\n+  msg = java_lang_String::create_from_str(\"C heap space\", CHECK);\n+  java_lang_Throwable::set_message(oom_array->obj_at(_oom_c_heap), msg());\n+\n@@ -1054,1 +1058,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":86,"deletions":83,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,12 +98,0 @@\n-\n-  \/\/ Primitive objects\n-  static oop _int_mirror;\n-  static oop _float_mirror;\n-  static oop _double_mirror;\n-  static oop _byte_mirror;\n-  static oop _bool_mirror;\n-  static oop _char_mirror;\n-  static oop _long_mirror;\n-  static oop _short_mirror;\n-  static oop _void_mirror;\n-\n@@ -153,1 +141,1 @@\n-  static oop          _reference_pending_list;\n+  static OopHandle    _reference_pending_list;\n@@ -239,27 +227,18 @@\n-  static oop int_mirror()                   { return check_mirror(_int_mirror); }\n-  static oop float_mirror()                 { return check_mirror(_float_mirror); }\n-  static oop double_mirror()                { return check_mirror(_double_mirror); }\n-  static oop byte_mirror()                  { return check_mirror(_byte_mirror); }\n-  static oop bool_mirror()                  { return check_mirror(_bool_mirror); }\n-  static oop char_mirror()                  { return check_mirror(_char_mirror); }\n-  static oop long_mirror()                  { return check_mirror(_long_mirror); }\n-  static oop short_mirror()                 { return check_mirror(_short_mirror); }\n-  static oop void_mirror()                  { return check_mirror(_void_mirror); }\n-\n-  static void set_int_mirror(oop m)         { _int_mirror = m;    }\n-  static void set_float_mirror(oop m)       { _float_mirror = m;  }\n-  static void set_double_mirror(oop m)      { _double_mirror = m; }\n-  static void set_byte_mirror(oop m)        { _byte_mirror = m;   }\n-  static void set_bool_mirror(oop m)        { _bool_mirror = m;   }\n-  static void set_char_mirror(oop m)        { _char_mirror = m;   }\n-  static void set_long_mirror(oop m)        { _long_mirror = m;   }\n-  static void set_short_mirror(oop m)       { _short_mirror = m;  }\n-  static void set_void_mirror(oop m)        { _void_mirror = m;   }\n-\n-  \/\/ table of same\n-  static oop _mirrors[T_VOID+1];\n-\n-  static oop java_mirror(BasicType t) {\n-    assert((uint)t < T_VOID+1, \"range check\");\n-    return check_mirror(_mirrors[t]);\n-  }\n+  static oop int_mirror();\n+  static oop float_mirror();\n+  static oop double_mirror();\n+  static oop byte_mirror();\n+  static oop bool_mirror();\n+  static oop char_mirror();\n+  static oop long_mirror();\n+  static oop short_mirror();\n+  static oop void_mirror();\n+\n+  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n+  \/\/ but including T_VOID, hence the index including T_VOID\n+  static OopHandle _mirrors[T_VOID+1];\n+\n+  static oop java_mirror(BasicType t);\n+  static void replace_mirror(BasicType t, oop obj);\n+  static void clear_basic_type_mirrors();\n+\n@@ -329,0 +308,1 @@\n+  static oop out_of_memory_error_c_heap();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":21,"deletions":41,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2367,1 +2367,1 @@\n-    \/\/ during rewriting a new method oop is going to be used, and the next time\n+    \/\/ during rewriting a new method is going to be used, and the next time\n@@ -2504,1 +2504,1 @@\n-  \/\/ Relocator returns a new method oop.\n+  \/\/ Relocator returns a new method.\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  assert(_java_mirror.resolve() == NULL, \"should only be used to initialize mirror\");\n+  assert(_java_mirror.is_empty(), \"should only be used to initialize mirror\");\n@@ -64,0 +64,4 @@\n+void Klass::replace_java_mirror(oop mirror) {\n+  _java_mirror.replace(mirror);\n+}\n+\n@@ -198,3 +202,0 @@\n-\/\/ Need to set the _java_mirror field explicitly to not hit an assert that the field\n-\/\/ should be NULL before setting it.\n-                           _java_mirror(NULL),\n@@ -558,1 +559,1 @@\n-  _java_mirror = OopHandle();\n+  clear_java_mirror_handle();\n@@ -612,1 +613,1 @@\n-    _java_mirror = OopHandle();\n+    clear_java_mirror_handle();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -271,6 +271,5 @@\n-  \/\/ Both mirrors are on the ClassLoaderData::_handles list already so no\n-  \/\/ barriers are needed.\n-  void set_java_mirror_handle(OopHandle mirror) { _java_mirror = mirror; }\n-  OopHandle java_mirror_handle() const          {\n-    return _java_mirror;\n-  }\n+  void replace_java_mirror(oop mirror);\n+\n+  \/\/ Set java mirror OopHandle to NULL for CDS\n+  \/\/ This leaves the OopHandle in the CLD, but that's ok, you can't release them.\n+  void clear_java_mirror_handle() { _java_mirror = OopHandle(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-\/\/ Attempt to return method oop to original state.  Clear any pointers\n+\/\/ Attempt to return method to original state.  Clear any pointers\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,6 @@\n-  _body[0] = 0;  \/\/ in case length == 0\n+  \/\/ _body[0..1] are allocated in the header just by coincidence in the current\n+  \/\/ implementation of Symbol. They are read by identity_hash(), so make sure they\n+  \/\/ are initialized.\n+  \/\/ No other code should assume that _body[0..1] are always allocated. E.g., do\n+  \/\/ not unconditionally read base()[0] as that will be invalid for an empty Symbol.\n+  _body[0] = _body[1] = 0;\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1034,8 +1034,0 @@\n-  \/\/ From the TypeFunc signature, generate code to pass arguments\n-  \/\/ from Compiled calling convention to Interpreter's calling convention\n-  void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);\n-\n-  \/\/ From the TypeFunc signature, generate code to pass arguments\n-  \/\/ from Interpreter's calling convention to Compiler's calling convention\n-  void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {\n+Node* PhaseIdealLoop::split_thru_phi(Node* n, Node* region, int policy) {\n@@ -71,0 +71,15 @@\n+  \/\/ Bail out if 'n' is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable\n+  \/\/ phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type\n+  \/\/ range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes\n+  \/\/ of 'n', we need to bail out of one of these divisors could be zero (zero in its type range).\n+  if ((n->Opcode() == Op_DivI || n->Opcode() == Op_ModI) && n->in(0) == NULL\n+      && region->is_CountedLoop() && n->in(2) == region->as_CountedLoop()->phi()) {\n+    Node* phi = region->as_CountedLoop()->phi();\n+    for (uint i = 1; i < phi->req(); i++) {\n+      if (_igvn.type(phi->in(i))->filter_speculative(TypeInt::ZERO) != Type::TOP) {\n+        \/\/ Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.\n+        return NULL;\n+      }\n+    }\n+  }\n+\n@@ -76,2 +91,2 @@\n-  const TypeOopPtr *t_oop = _igvn.type(n)->isa_oopptr();\n-  Node *phi;\n+  const TypeOopPtr* t_oop = _igvn.type(n)->isa_oopptr();\n+  Node* phi;\n@@ -88,1 +103,1 @@\n-    Node *x;\n+    Node* x;\n@@ -99,1 +114,1 @@\n-        Node *in = n->in(j);\n+        Node* in = n->in(j);\n@@ -101,1 +116,1 @@\n-          x->set_req( j, in->in(i) ); \/\/ Use pre-Phi input for the clone\n+          x->set_req(j, in->in(i)); \/\/ Use pre-Phi input for the clone\n@@ -105,1 +120,1 @@\n-    const Type *t = x->Value(&_igvn);\n+    const Type* t = x->Value(&_igvn);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2020,1 +2020,1 @@\n-\/\/ and then expanded into the inline_cache_reg and a method_oop register\n+\/\/ and then expanded into the inline_cache_reg and a method_ptr register\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,1 +413,1 @@\n-  \/\/ and then expanded into the inline_cache_reg and a method_oop register\n+  \/\/ and then expanded into the inline_cache_reg and a method_ptr register\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-  jobject ret = JNIHandles::make_global(ref_handle);\n+  jobject ret = JNIHandles::make_global(ref_handle, AllocFailStrategy::RETURN_NULL);\n@@ -802,1 +802,2 @@\n-  jobject ret = JNIHandles::make_local(THREAD, JNIHandles::resolve(ref));\n+  jobject ret = JNIHandles::make_local(THREAD, JNIHandles::resolve(ref),\n+                                       AllocFailStrategy::RETURN_NULL);\n@@ -1222,1 +1223,2 @@\n-  Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));\n+  oop mirror = JNIHandles::resolve_non_null(clazz);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n@@ -1226,1 +1228,1 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -3161,1 +3163,1 @@\n- HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);\n+  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);\n@@ -3163,2 +3165,5 @@\n-  jweak ret = JNIHandles::make_weak_global(ref_handle);\n- HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);\n+  jweak ret = JNIHandles::make_weak_global(ref_handle, AllocFailStrategy::RETURN_NULL);\n+  if (ret == NULL) {\n+    THROW_OOP_(Universe::out_of_memory_error_c_heap(), NULL);\n+  }\n+  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);\n@@ -3240,0 +3245,6 @@\n+    \/\/ Global refs will be NULL if out-of-memory (no exception is pending)\n+    if (bufferClass == NULL || directBufferClass == NULL || directByteBufferClass == NULL) {\n+      directBufferSupportInitializeFailed = 1;\n+      return false;\n+    }\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1339,1 +1339,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1344,1 +1345,1 @@\n-  objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));\n+  objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));\n@@ -1364,1 +1365,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (!java_lang_Class::is_primitive(mirror)) {\n@@ -1368,1 +1370,1 @@\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1378,1 +1380,2 @@\n-  if (JNIHandles::resolve(cls) == NULL) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (mirror == NULL) {\n@@ -1382,1 +1385,1 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1387,1 +1390,1 @@\n-  oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));\n+  oop pd = java_lang_Class::protection_domain(mirror);\n@@ -1509,1 +1512,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1514,1 +1518,1 @@\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1527,3 +1531,3 @@\n-\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||\n-      ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_instance_klass()) {\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n+  if (java_lang_Class::is_primitive(ofMirror) ||\n+      ! java_lang_Class::as_Klass(ofMirror)->is_instance_klass()) {\n@@ -1534,1 +1538,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));\n+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n@@ -1592,2 +1596,6 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||\n-      ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_instance_klass()) {\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n+  if (java_lang_Class::is_primitive(ofMirror)) {\n+    return NULL;\n+  }\n+  Klass* klass = java_lang_Class::as_Klass(ofMirror);\n+  if (!klass->is_instance_klass()) {\n@@ -1599,2 +1607,1 @@\n-    = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))\n-                          )->compute_enclosing_class(&inner_is_member, CHECK_NULL);\n+    = InstanceKlass::cast(klass)->compute_enclosing_class(&inner_is_member, CHECK_NULL);\n@@ -1610,2 +1617,1 @@\n-  if (java_lang_Class::is_primitive(mirror) ||\n-      !java_lang_Class::as_Klass(mirror)->is_instance_klass()) {\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1614,1 +1620,5 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  if (!klass->is_instance_klass()) {\n+    return NULL;\n+  }\n+  InstanceKlass* k = InstanceKlass::cast(klass);\n@@ -1633,0 +1643,1 @@\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n@@ -1634,2 +1645,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));\n+  if (!java_lang_Class::is_primitive(mirror)) {\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1650,1 +1661,1 @@\n-\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n@@ -1652,2 +1663,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));\n+  if (!java_lang_Class::is_primitive(mirror)) {\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1832,0 +1843,1 @@\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n@@ -1833,2 +1845,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||\n-      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_array_klass()) {\n+  if (java_lang_Class::is_primitive(ofMirror) ||\n+      java_lang_Class::as_Klass(ofMirror)->is_array_klass()) {\n@@ -1840,1 +1852,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));\n+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n@@ -1944,0 +1956,1 @@\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n@@ -1945,2 +1958,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))\n-      || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_array_klass()) {\n+  if (java_lang_Class::is_primitive(ofMirror)\n+      || java_lang_Class::as_Klass(ofMirror)->is_array_klass()) {\n@@ -1952,1 +1965,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));\n+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n@@ -2028,1 +2041,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -2033,1 +2047,1 @@\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -2148,2 +2162,3 @@\n-  assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), \"should not be\");\n-  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));\n+  oop mirror = JNIHandles::resolve_non_null(current);\n+  assert(!java_lang_Class::is_primitive(mirror), \"should not be\");\n+  Klass* c = java_lang_Class::as_Klass(mirror);\n@@ -2178,1 +2193,1 @@\n-\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n@@ -2180,2 +2195,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+  if (!java_lang_Class::is_primitive(mirror)) {\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":53,"deletions":38,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1621,1 +1621,1 @@\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  \/\/ thread. All other usage needs to use a direct handshake for safety.\n@@ -1625,4 +1625,4 @@\n-    \/\/ get java stack frame count at safepoint.\n-    VM_GetFrameCount op(this, state, count_ptr);\n-    VMThread::execute(&op);\n-    err = op.result();\n+    \/\/ get java stack frame count with handshake.\n+    GetFrameCountClosure op(this, state, count_ptr);\n+    bool executed = Handshake::execute_direct(&op, java_thread);\n+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n@@ -1751,1 +1751,1 @@\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  \/\/ thread. All other usage needs to use a direct handshake for safety.\n@@ -1755,4 +1755,4 @@\n-    \/\/ JVMTI get java stack frame location at safepoint.\n-    VM_GetFrameLocation op(this, java_thread, depth, method_ptr, location_ptr);\n-    VMThread::execute(&op);\n-    err = op.result();\n+    \/\/ JVMTI get java stack frame location via direct handshake.\n+    GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);\n+    bool executed = Handshake::execute_direct(&op, java_thread);\n+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n@@ -2253,1 +2253,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -2255,2 +2255,2 @@\n-JvmtiEnv::SetBreakpoint(Method* method_oop, jlocation location) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+JvmtiEnv::SetBreakpoint(Method* method, jlocation location) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -2261,1 +2261,1 @@\n-  if (location >= (jlocation) method_oop->code_size()) {\n+  if (location >= (jlocation) method->code_size()) {\n@@ -2266,1 +2266,1 @@\n-  JvmtiBreakpoint bp(method_oop, location);\n+  JvmtiBreakpoint bp(method, location);\n@@ -2279,1 +2279,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -2281,2 +2281,2 @@\n-JvmtiEnv::ClearBreakpoint(Method* method_oop, jlocation location) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+JvmtiEnv::ClearBreakpoint(Method* method, jlocation location) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -2289,1 +2289,1 @@\n-  if (location >= (jlocation) method_oop->code_size()) {\n+  if (location >= (jlocation) method->code_size()) {\n@@ -2293,1 +2293,1 @@\n-  JvmtiBreakpoint bp(method_oop, location);\n+  JvmtiBreakpoint bp(method, location);\n@@ -2519,20 +2519,23 @@\n-\n-  if (JvmtiExport::can_maintain_original_method_order()) {\n-    \/\/ Use the original method ordering indices stored in the class, so we can emit\n-    \/\/ jmethodIDs in the order they appeared in the class file\n-    for (index = 0; index < result_length; index++) {\n-      Method* m = ik->methods()->at(index);\n-      int original_index = ik->method_ordering()->at(index);\n-      assert(original_index >= 0 && original_index < result_length, \"invalid original method index\");\n-      jmethodID id;\n-      if (jmethodids_found) {\n-        id = m->find_jmethod_id_or_null();\n-        if (id == NULL) {\n-          \/\/ If we find an uninitialized value, make sure there is\n-          \/\/ enough space for all the uninitialized values we might\n-          \/\/ find.\n-          ik->ensure_space_for_methodids(index);\n-          jmethodids_found = false;\n-          id = m->jmethod_id();\n-        }\n-      } else {\n+  int skipped = 0;  \/\/ skip overpass methods\n+\n+  for (index = 0; index < result_length; index++) {\n+    Method* m = ik->methods()->at(index);\n+    \/\/ Depending on can_maintain_original_method_order capability use the original\n+    \/\/ method ordering indices stored in the class, so we can emit jmethodIDs in\n+    \/\/ the order they appeared in the class file or just copy in current order.\n+    int result_index = JvmtiExport::can_maintain_original_method_order() ? ik->method_ordering()->at(index) : index;\n+    assert(result_index >= 0 && result_index < result_length, \"invalid original method index\");\n+    if (m->is_overpass()) {\n+      result_list[result_index] = NULL;\n+      skipped++;\n+      continue;\n+    }\n+    jmethodID id;\n+    if (jmethodids_found) {\n+      id = m->find_jmethod_id_or_null();\n+      if (id == NULL) {\n+        \/\/ If we find an uninitialized value, make sure there is\n+        \/\/ enough space for all the uninitialized values we might\n+        \/\/ find.\n+        ik->ensure_space_for_methodids(index);\n+        jmethodids_found = false;\n@@ -2541,1 +2544,2 @@\n-      result_list[original_index] = id;\n+    } else {\n+      id = m->jmethod_id();\n@@ -2543,15 +2547,11 @@\n-  } else {\n-    \/\/ otherwise just copy in any order\n-    for (index = 0; index < result_length; index++) {\n-      Method* m = ik->methods()->at(index);\n-      jmethodID id;\n-      if (jmethodids_found) {\n-        id = m->find_jmethod_id_or_null();\n-        if (id == NULL) {\n-          \/\/ If we find an uninitialized value, make sure there is\n-          \/\/ enough space for all the uninitialized values we might\n-          \/\/ find.\n-          ik->ensure_space_for_methodids(index);\n-          jmethodids_found = false;\n-          id = m->jmethod_id();\n-        }\n+    result_list[result_index] = id;\n+  }\n+\n+  \/\/ Fill in return value.\n+  if (skipped > 0) {\n+    \/\/ copy results skipping NULL methodIDs\n+    *methods_ptr = (jmethodID*)jvmtiMalloc((result_length - skipped) * sizeof(jmethodID));\n+    *method_count_ptr = result_length - skipped;\n+    for (index = 0, skipped = 0; index < result_length; index++) {\n+      if (result_list[index] == NULL) {\n+        skipped++;\n@@ -2559,1 +2559,1 @@\n-        id = m->jmethod_id();\n+        (*methods_ptr)[index - skipped] = result_list[index];\n@@ -2561,1 +2561,4 @@\n-      result_list[index] = id;\n+    deallocate((unsigned char *)result_list);\n+  } else {\n+    *method_count_ptr = result_length;\n+    *methods_ptr = result_list;\n@@ -2564,3 +2567,0 @@\n-  \/\/ Fill in return value.\n-  *method_count_ptr = result_length;\n-  *methods_ptr = result_list;\n@@ -2954,1 +2954,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -2959,2 +2959,2 @@\n-JvmtiEnv::GetMethodName(Method* method_oop, char** name_ptr, char** signature_ptr, char** generic_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+JvmtiEnv::GetMethodName(Method* method, char** name_ptr, char** signature_ptr, char** generic_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -2967,1 +2967,1 @@\n-    const char* utf8_name = (const char *) method_oop->name()->as_utf8();\n+    const char* utf8_name = (const char *) method->name()->as_utf8();\n@@ -2974,1 +2974,1 @@\n-    const char* utf8_signature = (const char *) method_oop->signature()->as_utf8();\n+    const char* utf8_signature = (const char *) method->signature()->as_utf8();\n@@ -2981,1 +2981,1 @@\n-    Symbol* soop = method_oop->generic_signature();\n+    Symbol* soop = method->generic_signature();\n@@ -2997,1 +2997,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3000,3 +3000,3 @@\n-JvmtiEnv::GetMethodDeclaringClass(Method* method_oop, jclass* declaring_class_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n-  (*declaring_class_ptr) = get_jni_class_non_null(method_oop->method_holder());\n+JvmtiEnv::GetMethodDeclaringClass(Method* method, jclass* declaring_class_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n+  (*declaring_class_ptr) = get_jni_class_non_null(method->method_holder());\n@@ -3007,1 +3007,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3010,3 +3010,3 @@\n-JvmtiEnv::GetMethodModifiers(Method* method_oop, jint* modifiers_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n-  (*modifiers_ptr) = method_oop->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+JvmtiEnv::GetMethodModifiers(Method* method, jint* modifiers_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n+  (*modifiers_ptr) = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n@@ -3017,1 +3017,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3020,2 +3020,2 @@\n-JvmtiEnv::GetMaxLocals(Method* method_oop, jint* max_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+JvmtiEnv::GetMaxLocals(Method* method, jint* max_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -3023,1 +3023,1 @@\n-  (*max_ptr) = method_oop->max_locals();\n+  (*max_ptr) = method->max_locals();\n@@ -3028,1 +3028,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3031,2 +3031,2 @@\n-JvmtiEnv::GetArgumentsSize(Method* method_oop, jint* size_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+JvmtiEnv::GetArgumentsSize(Method* method, jint* size_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -3035,1 +3035,1 @@\n-  (*size_ptr) = method_oop->size_of_parameters();\n+  (*size_ptr) = method->size_of_parameters();\n@@ -3040,1 +3040,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3044,3 +3044,3 @@\n-JvmtiEnv::GetLineNumberTable(Method* method_oop, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n-  if (!method_oop->has_linenumber_table()) {\n+JvmtiEnv::GetLineNumberTable(Method* method, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n+  if (!method->has_linenumber_table()) {\n@@ -3055,1 +3055,1 @@\n-  CompressedLineNumberReadStream stream(method_oop->compressed_linenumber_table());\n+  CompressedLineNumberReadStream stream(method->compressed_linenumber_table());\n@@ -3065,1 +3065,1 @@\n-    CompressedLineNumberReadStream stream(method_oop->compressed_linenumber_table());\n+    CompressedLineNumberReadStream stream(method->compressed_linenumber_table());\n@@ -3082,1 +3082,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3086,1 +3086,1 @@\n-JvmtiEnv::GetMethodLocation(Method* method_oop, jlocation* start_location_ptr, jlocation* end_location_ptr) {\n+JvmtiEnv::GetMethodLocation(Method* method, jlocation* start_location_ptr, jlocation* end_location_ptr) {\n@@ -3088,1 +3088,1 @@\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -3090,2 +3090,2 @@\n-  (*end_location_ptr) = (jlocation) (method_oop->code_size() - 1);\n-  if (method_oop->code_size() == 0) {\n+  (*end_location_ptr) = (jlocation) (method->code_size() - 1);\n+  if (method->code_size() == 0) {\n@@ -3102,1 +3102,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3106,1 +3106,1 @@\n-JvmtiEnv::GetLocalVariableTable(Method* method_oop, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {\n+JvmtiEnv::GetLocalVariableTable(Method* method, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {\n@@ -3108,1 +3108,1 @@\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -3112,1 +3112,1 @@\n-  InstanceKlass* ik = method_oop->method_holder();\n+  InstanceKlass* ik = method->method_holder();\n@@ -3117,1 +3117,1 @@\n-  ConstantPool* constants = method_oop->constants();\n+  ConstantPool* constants = method->constants();\n@@ -3123,1 +3123,1 @@\n-  jint num_entries = method_oop->localvariable_table_length();\n+  jint num_entries = method->localvariable_table_length();\n@@ -3128,1 +3128,1 @@\n-    LocalVariableTableElement* table = method_oop->localvariable_table_start();\n+    LocalVariableTableElement* table = method->localvariable_table_start();\n@@ -3179,1 +3179,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3183,2 +3183,2 @@\n-JvmtiEnv::GetBytecodes(Method* method_oop, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n+JvmtiEnv::GetBytecodes(Method* method, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n@@ -3187,2 +3187,2 @@\n-  methodHandle method(Thread::current(), method_oop);\n-  jint size = (jint)method->code_size();\n+  methodHandle mh(Thread::current(), method);\n+  jint size = (jint)mh->code_size();\n@@ -3196,1 +3196,1 @@\n-  JvmtiClassFileReconstituter::copy_bytecodes(method, *bytecodes_ptr);\n+  JvmtiClassFileReconstituter::copy_bytecodes(mh, *bytecodes_ptr);\n@@ -3202,1 +3202,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3205,3 +3205,3 @@\n-JvmtiEnv::IsMethodNative(Method* method_oop, jboolean* is_native_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n-  (*is_native_ptr) = method_oop->is_native();\n+JvmtiEnv::IsMethodNative(Method* method, jboolean* is_native_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n+  (*is_native_ptr) = method->is_native();\n@@ -3212,1 +3212,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3215,3 +3215,3 @@\n-JvmtiEnv::IsMethodSynthetic(Method* method_oop, jboolean* is_synthetic_ptr) {\n-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);\n-  (*is_synthetic_ptr) = method_oop->is_synthetic();\n+JvmtiEnv::IsMethodSynthetic(Method* method, jboolean* is_synthetic_ptr) {\n+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);\n+  (*is_synthetic_ptr) = method->is_synthetic();\n@@ -3222,1 +3222,1 @@\n-\/\/ method_oop - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n@@ -3225,1 +3225,1 @@\n-JvmtiEnv::IsMethodObsolete(Method* method_oop, jboolean* is_obsolete_ptr) {\n+JvmtiEnv::IsMethodObsolete(Method* method, jboolean* is_obsolete_ptr) {\n@@ -3234,1 +3234,1 @@\n-  if (method_oop == NULL || method_oop->is_obsolete()) {\n+  if (method == NULL || method->is_obsolete()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":118,"deletions":118,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -727,0 +727,1 @@\n+  HandleMark hm;\n@@ -733,1 +734,0 @@\n-  HandleMark hm;\n@@ -903,3 +903,3 @@\n-  assert((SafepointSynchronize::is_at_safepoint() ||\n-          java_thread->is_thread_fully_suspended(false, &debug_bits)),\n-         \"at safepoint or target thread is suspended\");\n+  assert(current_thread == java_thread ||\n+         current_thread == java_thread->active_handshaker(),\n+         \"call by myself or at direct handshake\");\n@@ -1013,1 +1013,0 @@\n-      ResourceMark rm(current_thread);\n@@ -1567,2 +1566,1 @@\n-VM_GetFrameCount::doit() {\n-  _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+GetFrameCountClosure::do_thread(Thread *target) {\n@@ -1570,2 +1568,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(target == jt, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1577,6 +1575,5 @@\n-VM_GetFrameLocation::doit() {\n-  _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  ThreadsListHandle tlh;\n-  if (_java_thread != NULL && tlh.includes(_java_thread)\n-      && !_java_thread->is_exiting() && _java_thread->threadObj() != NULL) {\n-    _result = ((JvmtiEnvBase*)_env)->get_frame_location(_java_thread, _depth,\n+GetFrameLocationClosure::do_thread(Thread *target) {\n+  assert(target->is_Java_thread(), \"just checking\");\n+  JavaThread *jt = (JavaThread *)target;\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n+    _result = ((JvmtiEnvBase*)_env)->get_frame_location(jt, _depth,\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -535,2 +535,2 @@\n-  Method* method_oop = jvf->method();\n-  jint num_entries = method_oop->localvariable_table_length();\n+  Method* method = jvf->method();\n+  jint num_entries = method->localvariable_table_length();\n@@ -543,1 +543,1 @@\n-  LocalVariableTableElement* table = method_oop->localvariable_table_start();\n+  LocalVariableTableElement* table = method->localvariable_table_start();\n@@ -559,1 +559,1 @@\n-  Symbol*   sign_sym  = method_oop->constants()->symbol_at(signature_idx);\n+  Symbol*   sign_sym  = method->constants()->symbol_at(signature_idx);\n@@ -602,1 +602,1 @@\n-  Method* method_oop = jvf->method();\n+  Method* method = jvf->method();\n@@ -605,1 +605,1 @@\n-  if (_index < 0 || _index + extra_slot >= method_oop->max_locals()) {\n+  if (_index < 0 || _index + extra_slot >= method->max_locals()) {\n@@ -638,1 +638,1 @@\n-  Method* method_oop = _jvf->method();\n+  Method* method = _jvf->method();\n@@ -640,1 +640,1 @@\n-    if (method_oop->is_static()) {\n+    if (method->is_static()) {\n@@ -647,1 +647,1 @@\n-  if (method_oop->is_native()) {\n+  if (method->is_native()) {\n@@ -655,1 +655,1 @@\n-  if (method_oop->has_localvariable_table()) {\n+  if (method->has_localvariable_table()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1228,0 +1228,38 @@\n+\/\/ The bug 6214132 caused the verification to fail.\n+\/\/ 1. What's done in RedefineClasses() before verification:\n+\/\/  a) A reference to the class being redefined (_the_class) and a\n+\/\/     reference to new version of the class (_scratch_class) are\n+\/\/     saved here for use during the bytecode verification phase of\n+\/\/     RedefineClasses.\n+\/\/  b) The _java_mirror field from _the_class is copied to the\n+\/\/     _java_mirror field in _scratch_class. This means that a jclass\n+\/\/     returned for _the_class or _scratch_class will refer to the\n+\/\/     same Java mirror. The verifier will see the \"one true mirror\"\n+\/\/     for the class being verified.\n+\/\/ 2. See comments in JvmtiThreadState for what is done during verification.\n+\n+class RedefineVerifyMark : public StackObj {\n+ private:\n+  JvmtiThreadState* _state;\n+  Klass*            _scratch_class;\n+  Handle            _scratch_mirror;\n+\n+ public:\n+\n+  RedefineVerifyMark(Klass* the_class, Klass* scratch_class,\n+                     JvmtiThreadState* state) : _state(state), _scratch_class(scratch_class)\n+  {\n+    _state->set_class_versions_map(the_class, scratch_class);\n+    _scratch_mirror = Handle(_state->get_thread(), _scratch_class->java_mirror());\n+    _scratch_class->replace_java_mirror(the_class->java_mirror());\n+  }\n+\n+  ~RedefineVerifyMark() {\n+    \/\/ Restore the scratch class's mirror, so when scratch_class is removed\n+    \/\/ the correct mirror pointing to it can be cleared.\n+    _scratch_class->replace_java_mirror(_scratch_mirror());\n+    _state->clear_class_versions_map();\n+  }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -911,1 +911,3 @@\n-  ResourceMark rm;\n+  ResourceMark rm(cur);\n+  HandleMark hm(cur);\n+\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  HandleMark hm;\n@@ -1623,0 +1624,2 @@\n+  ResourceMark rm;\n+  HandleMark hm;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-          \"Trace rewriting of method oops during oop map generation\")       \\\n+          \"Trace rewriting of methods during oop map generation\")           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-\n-jobject JNIHandles::make_local(Thread* thread, oop obj) {\n+\/\/ Used by NewLocalRef which requires NULL on out-of-memory\n+jobject JNIHandles::make_local(Thread* thread, oop obj, AllocFailType alloc_failmode) {\n@@ -70,1 +70,1 @@\n-    return thread->active_handles()->allocate_handle(obj);\n+    return thread->active_handles()->allocate_handle(obj, alloc_failmode);\n@@ -106,1 +106,0 @@\n-\n@@ -384,1 +383,1 @@\n-JNIHandleBlock* JNIHandleBlock::allocate_block(Thread* thread)  {\n+JNIHandleBlock* JNIHandleBlock::allocate_block(Thread* thread, AllocFailType alloc_failmode)  {\n@@ -402,1 +401,8 @@\n-      block = new JNIHandleBlock();\n+      if (alloc_failmode == AllocFailStrategy::RETURN_NULL) {\n+        block = new (std::nothrow) JNIHandleBlock();\n+        if (block == NULL) {\n+          return NULL;\n+        }\n+      } else {\n+        block = new JNIHandleBlock();\n+      }\n@@ -502,1 +508,1 @@\n-jobject JNIHandleBlock::allocate_handle(oop obj) {\n+jobject JNIHandleBlock::allocate_handle(oop obj, AllocFailType alloc_failmode) {\n@@ -550,1 +556,1 @@\n-    return allocate_handle(obj);\n+    return allocate_handle(obj, alloc_failmode);\n@@ -561,1 +567,4 @@\n-    _last->_next = JNIHandleBlock::allocate_block(thread);\n+    _last->_next = JNIHandleBlock::allocate_block(thread, alloc_failmode);\n+    if (_last->_next == NULL) {\n+      return NULL;\n+    }\n@@ -566,1 +575,1 @@\n-  return allocate_handle(obj);  \/\/ retry\n+  return allocate_handle(obj, alloc_failmode);  \/\/ retry\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1579,1 +1579,4 @@\n-  jlong* new_counters = NEW_C_HEAP_ARRAY(jlong, new_size, mtJVMCI);\n+  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n+  if (new_counters == NULL) {\n+    return NULL;\n+  }\n@@ -1596,2 +1599,8 @@\n-void JavaThread::resize_counters(int current_size, int new_size) {\n-  _jvmci_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n+bool JavaThread::resize_counters(int current_size, int new_size) {\n+  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n+  if (new_counters == NULL) {\n+    return false;\n+  } else {\n+    _jvmci_counters = new_counters;\n+    return true;\n+  }\n@@ -1603,0 +1612,1 @@\n+  bool _failed;\n@@ -1605,1 +1615,1 @@\n-  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size) { }\n+  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n@@ -1611,1 +1621,6 @@\n-    JavaThread::_jvmci_old_thread_counters = new_counters;\n+    if (new_counters == NULL) {\n+      _failed = true;\n+      return;\n+    } else {\n+      JavaThread::_jvmci_old_thread_counters = new_counters;\n+    }\n@@ -1615,1 +1630,7 @@\n-      tp->resize_counters(JVMCICounterSize, _new_size);\n+      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {\n+        _failed = true;\n+        break;\n+      }\n+    }\n+    if (!_failed) {\n+      JVMCICounterSize = _new_size;\n@@ -1617,1 +1638,2 @@\n-    JVMCICounterSize = _new_size;\n+\n+  bool failed() { return _failed; }\n@@ -1621,1 +1643,1 @@\n-void JavaThread::resize_all_jvmci_counters(int new_size) {\n+bool JavaThread::resize_all_jvmci_counters(int new_size) {\n@@ -1624,0 +1646,1 @@\n+  return !op.failed();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1189,2 +1189,4 @@\n-  void resize_counters(int current_size, int new_size);\n-  static void resize_all_jvmci_counters(int new_size);\n+\n+  bool resize_counters(int current_size, int new_size);\n+\n+  static bool resize_all_jvmci_counters(int new_size);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-  template(GetFrameCount)                         \\\n-  template(GetFrameLocation)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1113,1 +1113,5 @@\n-#define ARRAY_SIZE(array) (sizeof(array)\/sizeof((array)[0]))\n+\/\/ array_size_impl is a function that takes a reference to T[N] and\n+\/\/ returns a reference to char[N].  It is not ODR-used, so not defined.\n+template<typename T, size_t N> char (&array_size_impl(T (&)[N]))[N];\n+\n+#define ARRAY_SIZE(array) sizeof(array_size_impl(array))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,0 +78,4 @@\n+    \/**\n+     * Constructs a {@code TreeScanner}.\n+     *\/\n+    public TreeScanner() {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3135,1 +3135,1 @@\n-        boolean isRecordMember = (s.flags_field & RECORD) != 0 || s.enclClass() != null && s.enclClass().isRecord();\n+        boolean isRecordMember = ((s.flags_field & RECORD) != 0 || s.enclClass() != null && s.enclClass().isRecord());\n@@ -3137,2 +3137,1 @@\n-        boolean isRecordField = isRecordMember &&\n-                (s.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+        boolean isRecordField = (s.flags_field & RECORD) != 0 &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2340,6 +2340,3 @@\n-        if (csym.owner == msym && !csym.isStatic()) {\n-            return true;\n-        } else if (csym.owner.kind == TYP) {\n-            return isInnerClassOfMethod(msym, csym.owner);\n-        } else {\n-            return false;\n+        while (csym.owner != msym) {\n+            if (csym.isStatic()) return false;\n+            csym = csym.owner.enclClass();\n@@ -2347,0 +2344,1 @@\n+        return (csym.owner == msym && !csym.isStatic());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -910,1 +910,1 @@\n-     * Enlarge the number of per thread counters available. Requires a safepoint so\n+     * Attempt to enlarge the number of per thread counters available. Requires a safepoint so\n@@ -914,0 +914,1 @@\n+     * @return false if the resizing failed\n@@ -915,2 +916,2 @@\n-    public void setCountersSize(int newSize) {\n-        compilerToVm.setCountersSize(newSize);\n+    public boolean setCountersSize(int newSize) {\n+        return compilerToVm.setCountersSize(newSize);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}