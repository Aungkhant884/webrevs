{"files":[{"patch":"@@ -826,1 +826,0 @@\n-          vt->set_is_buffered();\n@@ -828,0 +827,1 @@\n+          vt->set_is_buffered(kit.gvn());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1927,1 +1927,0 @@\n-    assert(n == ret_val || !n->is_InlineType(), \"chain of inline type nodes\");\n@@ -2024,0 +2023,2 @@\n+        } else if (u->is_Phi()) {\n+          \/\/ TODO 8302217 Remove this once InlineTypeNodes are reliably pushed through\n@@ -2028,1 +2029,2 @@\n-          vt->dump(-3);\n+          vt->dump(0);\n+          u->dump(0);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,12 +36,0 @@\n-uint InlineTypeNode::size_of() const {\n-  return sizeof(*this);\n-}\n-\n-uint InlineTypeNode::hash() const {\n-  return TypeNode::hash() + _is_buffered;\n-}\n-\n-bool InlineTypeNode::cmp(const Node& n) const {\n-  return TypeNode::cmp(n) && ((InlineTypeNode&)n)._is_buffered == _is_buffered;\n-}\n-\n@@ -52,6 +40,3 @@\n-  if (vt->is_InlineType()) {\n-    \/\/ Use nullable type\n-    const Type* t = Type::get_const_type(inline_klass());\n-    gvn->set_type(vt, t);\n-    vt->as_InlineType()->set_type(t);\n-  }\n+  const Type* t = Type::get_const_type(inline_klass());\n+  gvn->set_type(vt, t);\n+  vt->as_InlineType()->set_type(t);\n@@ -60,3 +45,2 @@\n-  const Type* phi_type = Type::get_const_type(inline_klass());\n-  PhiNode* oop = PhiNode::make(region, vt->get_oop(), phi_type);\n-  gvn->set_type(oop, phi_type);\n+  PhiNode* oop = PhiNode::make(region, vt->get_oop(), t);\n+  gvn->set_type(oop, t);\n@@ -66,0 +50,7 @@\n+  \/\/ Create a PhiNode for merging the is_buffered values\n+  t = Type::get_const_basic_type(T_BOOLEAN);\n+  Node* is_buffered_node = PhiNode::make(region, vt->get_is_buffered(), t);\n+  gvn->set_type(is_buffered_node, t);\n+  gvn->record_for_igvn(is_buffered_node);\n+  vt->set_req(IsBuffered, is_buffered_node);\n+\n@@ -71,3 +62,3 @@\n-    phi_type = Type::get_const_basic_type(T_BOOLEAN);\n-    is_init_node = PhiNode::make(region, vt->get_is_init(), phi_type);\n-    gvn->set_type(is_init_node, phi_type);\n+    t = Type::get_const_basic_type(T_BOOLEAN);\n+    is_init_node = PhiNode::make(region, vt->get_is_init(), t);\n+    gvn->set_type(is_init_node, t);\n@@ -90,3 +81,3 @@\n-      phi_type = Type::get_const_type(type);\n-      value = PhiNode::make(region, value, phi_type);\n-      gvn->set_type(value, phi_type);\n+      t = Type::get_const_type(type);\n+      value = PhiNode::make(region, value, t);\n+      gvn->set_type(value, t);\n@@ -97,1 +88,0 @@\n-  gvn->set_type(vt, vt->bottom_type());\n@@ -125,1 +115,0 @@\n-  _is_buffered = _is_buffered && other->_is_buffered;\n@@ -133,0 +122,8 @@\n+  \/\/ Merge is_buffered inputs\n+  phi = get_is_buffered()->as_Phi();\n+  phi->set_req(pnum, other->get_is_buffered());\n+  if (transform) {\n+    set_req(IsBuffered, gvn->transform(phi));\n+  }\n+\n+  \/\/ Merge is_init inputs\n@@ -169,0 +166,4 @@\n+  phi = get_is_buffered()->as_Phi();\n+  phi->add_req(NULL);\n+  assert(phi->req() == region->req(), \"must be same size as region\");\n+\n@@ -497,1 +498,1 @@\n-  if (_is_buffered) {\n+  if (kit->gvn().find_int_con(get_is_buffered(), 0) == 1) {\n@@ -508,1 +509,1 @@\n-    vt->_is_buffered = true;\n+    vt->set_is_buffered(kit->gvn());\n@@ -579,1 +580,0 @@\n-  vt->_is_buffered = true;\n@@ -581,0 +581,1 @@\n+  vt->set_is_buffered(kit->gvn());\n@@ -592,1 +593,1 @@\n-  if (_is_buffered) {\n+  if (phase->find_int_con(get_is_buffered(), 0) == 1) {\n@@ -695,0 +696,1 @@\n+    set_is_buffered(*phase);\n@@ -741,1 +743,2 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop, null_free, vk->is_empty() && vk->is_initialized());\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop, null_free);\n+  vt->set_is_buffered(gvn, vk->is_empty() && vk->is_initialized());\n@@ -760,1 +763,2 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true, \/* buffered= *\/ vk->is_initialized());\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true);\n+  vt->set_is_buffered(gvn, vk->is_initialized());\n@@ -843,1 +847,2 @@\n-    vt = new InlineTypeNode(vk, not_null_oop, null_free, true);\n+    vt = new InlineTypeNode(vk, not_null_oop, null_free);\n+    vt->set_is_buffered(gvn);\n@@ -867,1 +872,1 @@\n-    vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true, true);\n+    vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true);\n@@ -869,0 +874,1 @@\n+    vt->set_is_buffered(gvn);\n@@ -1151,1 +1157,1 @@\n-    is_init= gvn.transform(new ProjNode(multi->as_Call(), base_input));\n+    is_init = gvn.transform(new ProjNode(multi->as_Call(), base_input));\n@@ -1204,2 +1210,3 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false, \/* buffered= *\/ true);\n-  vt->set_req(IsInit, gvn.intcon(0));\n+  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false);\n+  vt->set_is_buffered(gvn);\n+  vt->set_is_init(gvn, false);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":47,"deletions":40,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -38,7 +38,2 @@\n-  virtual uint hash() const;\n-  virtual bool cmp(const Node &n) const;\n-  virtual uint size_of() const;\n-  bool _is_buffered;\n-\n-  InlineTypeNode(ciInlineKlass* vk, Node* oop, bool null_free, bool is_buffered)\n-      : TypeNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()), _is_buffered(is_buffered) {\n+  InlineTypeNode(ciInlineKlass* vk, Node* oop, bool null_free)\n+      : TypeNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()) {\n@@ -50,5 +45,6 @@\n-  enum { Control,   \/\/ Control input.\n-         Oop,       \/\/ Oop to heap allocated buffer (NULL if not buffered).\n-         IsInit,    \/\/ Needs to be checked for NULL before using the field values.\n-         Values     \/\/ Nodes corresponding to values of the inline type's fields.\n-                    \/\/ Nodes are connected in increasing order of the index of the field they correspond to.\n+  enum { Control,    \/\/ Control input.\n+         Oop,        \/\/ Oop to heap allocated buffer.\n+         IsBuffered, \/\/ True if inline type is heap allocated (or NULL), false otherwise.\n+         IsInit,     \/\/ Needs to be checked for NULL before using the field values.\n+         Values      \/\/ Nodes corresponding to values of the inline type's fields.\n+                     \/\/ Nodes are connected in increasing order of the index of the field they correspond to.\n@@ -110,2 +106,3 @@\n-  void  set_is_init(PhaseGVN& gvn) { set_req(IsInit, gvn.intcon(1)); }\n-  void  set_is_buffered() { _is_buffered = true; }\n+  void  set_is_init(PhaseGVN& gvn, bool init = true) { set_req(IsInit, gvn.intcon(init ? 1 : 0)); }\n+  Node* get_is_buffered() const { return in(IsBuffered); }\n+  void  set_is_buffered(PhaseGVN& gvn, bool buffered = true) { set_req(IsBuffered, gvn.intcon(buffered ? 1 : 0)); }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-  assert(!field->is_null_free() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -365,4 +365,3 @@\n-  InlineTypeNode* new_vt = InlineTypeNode::make_uninitialized(gvn(), gvn().type(holder)->inline_klass());\n-  for (uint i = 2; i < holder->req(); ++i) {\n-    new_vt->set_req(i, holder->in(i));\n-  }\n+  InlineTypeNode* new_vt = holder->clone()->as_InlineType();\n+  new_vt->set_oop(gvn().zerocon(T_PRIMITIVE_OBJECT));\n+  new_vt->set_is_buffered(gvn(), false);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8260034 8260225 8260283 8261037 8261874 8262128 8262831\n- * @summary Generated inline type tests.\n+ * @bug 8260034 8260225 8260283 8261037 8261874 8262128 8262831 8306986\n+ * @summary A selection of generated tests that triggered bugs not covered by other tests.\n@@ -37,1 +37,5 @@\n-primitive class EmptyValue {\n+primitive class EmptyPrimitive {\n+\n+}\n+\n+value class EmptyValue {\n@@ -74,0 +78,4 @@\n+value class MyValue6 {\n+    int x = 42;\n+}\n+\n@@ -75,2 +83,2 @@\n-    EmptyValue f1 = new EmptyValue();\n-    EmptyValue f2 = new EmptyValue();\n+    EmptyPrimitive f1 = new EmptyPrimitive();\n+    EmptyPrimitive f2 = new EmptyPrimitive();\n@@ -78,1 +86,1 @@\n-    void test1(EmptyValue[] array) {\n+    void test1(EmptyPrimitive[] array) {\n@@ -257,0 +265,29 @@\n+    static MyValue6 test17Field = new MyValue6();\n+\n+    void test17() {\n+        for (int i = 0; i < 10; ++i) {\n+            MyValue6 val = new MyValue6();\n+            for (int j = 0; j < 10; ++j) {\n+                test17Field = val;\n+            }\n+        }\n+    }\n+\n+    EmptyValue test18Field;\n+\n+    EmptyValue test18() {\n+        EmptyValue val = new EmptyValue();\n+        test18Field = val;\n+        return test18Field;\n+    }\n+\n+    MyValue1 test19Field = new MyValue1();\n+\n+    public void test19() {\n+        for (int i = 0; i < 10; ++i) {\n+            MyValue1 val = new MyValue1();\n+            for (int j = 0; j < 10; ++j)\n+                test19Field = val;\n+        }\n+    }\n+\n@@ -259,1 +296,1 @@\n-        EmptyValue[] array1 = { new EmptyValue() };\n+        EmptyPrimitive[] array1 = { new EmptyPrimitive() };\n@@ -283,0 +320,3 @@\n+            t.test17();\n+            t.test18();\n+            t.test19();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"}]}