{"files":[{"patch":"@@ -233,0 +233,5 @@\n+        \/**\n+         * Warn about operations on null-restricted and nullable types.\n+         *\/\n+        NULL(\"null\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Optional;\n@@ -47,0 +46,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -750,0 +750,46 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == NullMarker.UNSPECIFIED) {\n+            return this;\n+        } else {\n+            return addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+        }\n+    }\n+\n+    public boolean isNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified() {\n+        return getMetadata(TypeMetadata.NullMarker.class) == null;\n+    }\n+\n+    public boolean sameNullabilityAs(Type t) {\n+        if (isNullUnspecified()) return t.isNullUnspecified();\n+        if (isNonNullable()) return t.isNonNullable();\n+        if (isNullable()) return t.isNullable();\n+        if (isParametric()) return t.isParametric();\n+        throw new AssertionError(\"shouldn't get here\");\n+    }\n+\n+    public boolean hasNarrowerNullabilityThan(Type t) {\n+        if (isNonNullable()) return !t.isNonNullable();\n+        if (isParametric()) return t.isNonNullable() || t.isNullUnspecified();\n+        if (isNullable()) return t.isNullUnspecified();\n+        return false;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1114,0 +1160,8 @@\n+            if (isNullable()) {\n+                buf.append(\"?\");\n+            } else if (isNonNullable()) {\n+                buf.append(\"!\");\n+            } else if (isParametric()) {\n+                buf.append(\"*\");\n+            }\n+\n@@ -1434,0 +1488,7 @@\n+                if (t.isNullable()) {\n+                    sb.append(\"?\");\n+                } else if (t.isNonNullable()) {\n+                    sb.append(\"!\");\n+                } else if (t.isParametric()) {\n+                    sb.append(\"*\");\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression;\n+import com.sun.tools.javac.util.Assert;\n@@ -79,0 +81,5 @@\n+\n+    record NullMarker(JCNullableTypeExpression.NullMarker nullMarker) implements TypeMetadata {\n+        @Override\n+        public String toString() { return \"NULL_MARKER [ \" + nullMarker.typeSuffix() + \" ]\"; }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -121,1 +123,6 @@\n-        noWarnings = new Warner(null);\n+        noWarnings = new Warner(null) {\n+            @Override\n+            public String toString() {\n+                return \"NO_WARNINGS\";\n+            }\n+        };\n@@ -1046,1 +1053,1 @@\n-            } else if (isSubtype(t, s, capture)) {\n+            } else if (isSubtype(t, s, capture, warn)) {\n@@ -1097,1 +1104,8 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        return isSubtype(t, s, capture, noWarnings);\n+    }\n+    public boolean isSubtype(Type t, Type s, boolean capture, Warner warn) {\n+        if (t.equalsIgnoreMetadata(s)) {\n+            Warner warner = !warnStack.isEmpty() ? warnStack.head : warn;\n+            if (warner.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n+                warner.warn(LintCategory.NULL);\n+            }\n@@ -1099,0 +1113,1 @@\n+        }\n@@ -1120,1 +1135,13 @@\n-        return isSubtype.visit(capture ? capture(t) : t, s);\n+        if (warn == warnStack.head ||\n+                \/\/ if warn is noWarnings, then we should be reentering this method while computing the subtype of a,\n+                \/\/ possibly, compound type, so keep the current top of the warnStack\n+                (!warnStack.isEmpty() && warn == noWarnings)) {\n+            return isSubtype.visit(capture ? capture(t) : t, s);\n+        } else {\n+            try {\n+                warnStack = warnStack.prepend(warn);\n+                return isSubtype.visit(capture ? capture(t) : t, s);\n+            } finally {\n+                warnStack = warnStack.tail;\n+            }\n+        }\n@@ -1123,2 +1150,2 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        private IsSubtype isSubtype = new IsSubtype();\n+        class IsSubtype extends TypeRelation {\n@@ -1139,1 +1166,7 @@\n-                 case BOT:\n+                 case BOT: {\n+                     \/* this method can be invoked even from the backend, and warnings can be printed again, so\n+                      * make sure that the caller really wants to warn\n+                      *\/\n+                     if (s.isNonNullable() && warnStack.head.pos() != null) {\n+                         chk.errBangTypes(warnStack.head.pos(), Errors.NonNullableCannotBeAssignedNull);\n+                     }\n@@ -1141,2 +1174,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1207,1 +1241,1 @@\n-                return sup.tsym == s.tsym\n+                boolean result = sup.tsym == s.tsym\n@@ -1212,0 +1246,4 @@\n+                if (result && warnStack.head.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1443,8 +1481,6 @@\n-                return t.tsym == s.tsym\n-                    && visit(getEnclosingType(t), getEnclosingType(s))\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n-            }\n-                \/\/ where\n-                private Type getEnclosingType(Type t) {\n-                    Type et = t.getEnclosingType();\n-                    return et;\n+                boolean equal = t.tsym == s.tsym\n+                        && visit(t.getEnclosingType(), s.getEnclosingType())\n+                        && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (equal && !s.sameNullabilityAs(t)) {\n+                    warner.warn(LintCategory.NULL);\n@@ -1452,0 +1488,2 @@\n+                return equal;\n+            }\n@@ -2449,1 +2487,1 @@\n-                        default: return s.dropMetadata(Annotations.class);\n+                        default: return s.cloneWithMetadata(t.getMetadata()).dropMetadata(Annotations.class);\n@@ -2831,1 +2869,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -3731,1 +3778,1 @@\n-     * (that is, subclasses come first, arbitrarily but fixed\n+     * (that is, subclasses come first, arbitrary but fixed\n@@ -4302,4 +4349,6 @@\n-        if (isSameType(r1.getReturnType(), r2res))\n-            return true;\n-        if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n-            return false;\n+        try {\n+            warnStack = warnStack.prepend(warner);\n+            if (isSameType(r1.getReturnType(), r2res))\n+                return true;\n+            if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n+                return false;\n@@ -4307,3 +4356,7 @@\n-        if (hasSameArgs(r1, r2))\n-            return covariantReturnType(r1.getReturnType(), r2res, warner);\n-        if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n+            if (hasSameArgs(r1, r2))\n+                return covariantReturnType(r1.getReturnType(), r2res, warner);\n+            if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n+                return true;\n+            if (!isSubtype(r1.getReturnType(), erasure(r2res), false, warner))\n+                return false;\n+            warner.warn(LintCategory.UNCHECKED);\n@@ -4311,4 +4364,3 @@\n-        if (!isSubtype(r1.getReturnType(), erasure(r2res)))\n-            return false;\n-        warner.warn(LintCategory.UNCHECKED);\n-        return true;\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":84,"deletions":32,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -729,0 +730,4 @@\n+        if (tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -4396,0 +4401,9 @@\n+        \/\/ check nullness of site\n+        if (site.isNullable()) {\n+            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (site.isParametric()) {\n+            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4719,0 +4733,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -294,0 +294,14 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnBangTypes(DiagnosticPosition pos, Warning warnKey) {\n+        if (lint.isEnabled(LintCategory.NULL)) {\n+            log.warning(LintCategory.NULL, pos, warnKey);\n+        }\n+    }\n+\n+    public void errBangTypes(DiagnosticPosition pos, Error errKey) {\n+        log.error(pos, errKey);\n+    }\n+\n@@ -675,3 +689,6 @@\n-                if (lint.isEnabled(LintCategory.CAST))\n-                    log.warning(LintCategory.CAST,\n-                            tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                if (lint.isEnabled(LintCategory.CAST)) {\n+                    if (!lint.isEnabled(LintCategory.NULL) || !tree.clazz.type.hasNarrowerNullabilityThan(tree.expr.type)) {\n+                        log.warning(LintCategory.CAST,\n+                                tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                    }\n+                }\n@@ -704,1 +721,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -709,1 +726,3 @@\n-             return types.isSubtype(a, bound);\n+             return pos != null ?\n+                     types.isSubtype(a, bound, true, new NullnessWarner(pos)) :\n+                     types.isSubtype(a, bound, true);\n@@ -1197,1 +1216,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1200,1 +1223,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1237,1 +1260,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1589,1 +1612,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1996,0 +2019,9 @@\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+        }\n+        overrideWarner.remove(LintCategory.NULL);\n+        \/\/ at this point we know this will be true but to gather the warnings\n+        types.isSubSignature(mt, ot, overrideWarner);\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+        }\n@@ -4399,0 +4431,20 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            boolean warned = this.warned;\n+            super.warn(lint);\n+            if (warned) return; \/\/ suppress redundant diagnostics\n+            switch (lint) {\n+                case NULL:\n+                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected lint: \" + lint);\n+            }\n+        }\n+    }\n+\n@@ -4427,0 +4479,3 @@\n+                case NULL:\n+                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4433,0 +4488,20 @@\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (expected.isParametric()) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnBangTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -4434,1 +4509,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":85,"deletions":10,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2173,1 +2173,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedNonNullableOrParametricField(sym));\n@@ -2186,0 +2187,7 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (sym.type.isNonNullable() || sym.type.isParametric()));\n+        }\n+\n@@ -2296,0 +2304,9 @@\n+                if (isUninitializedNonNullableOrParametricField(sym)) {\n+                    if (lint.isEnabled(Lint.LintCategory.NULL)) {\n+                        if (sym.type.isNonNullable()) {\n+                            log.warning(pos, Warnings.NonNullableShouldBeInitialized);\n+                        } else {\n+                            log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                        }\n+                    }\n+                } else {\n@@ -2297,0 +2314,1 @@\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -915,0 +915,4 @@\n+            if (pts.head.isNonNullable()) {\n+                code.emitop0(dup);\n+                genNullCheck(l.head);\n+            }\n@@ -1097,0 +1101,4 @@\n+                if (tree.type.isNonNullable()) {\n+                    code.emitop0(dup);\n+                    genNullCheck(tree.init);\n+                }\n@@ -2118,0 +2126,4 @@\n+        if (tree.lhs.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.rhs);\n+        }\n@@ -2323,0 +2335,4 @@\n+        if (tree.clazz.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.expr);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -71,0 +72,1 @@\n+import java.util.function.BiFunction;\n@@ -278,0 +280,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -285,0 +288,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -303,1 +307,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -307,1 +311,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -1153,1 +1157,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1334,0 +1349,1 @@\n+        boolean emotionalMarkersOK = false;\n@@ -1483,0 +1499,6 @@\n+                if (EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    emotionalMarkersOK = true;\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1502,0 +1524,4 @@\n+                            if (EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                setNullMarker(t);\n+                                nextToken();\n+                            }\n@@ -1642,0 +1668,10 @@\n+            if (EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n+                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                } else {\n+                    \/\/ not a type\n+                    break;\n+                }\n+            }\n@@ -1758,1 +1794,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1767,0 +1808,4 @@\n+                        if (isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1851,0 +1896,9 @@\n+    void setNullMarker(JCExpression exp) {\n+        ((JCNullableTypeExpression)exp).setNullMarker(\n+                token.kind == QUES ?\n+                        NullMarker.NULLABLE :\n+                        token.kind == BANG ?\n+                                NullMarker.NOT_NULL :\n+                                NullMarker.PARAMETRIC);\n+    }\n+\n@@ -1916,1 +1970,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -1984,0 +2038,13 @@\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW)) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2028,0 +2095,1 @@\n+                                peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN) ||\n@@ -2087,0 +2155,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -3372,0 +3444,12 @@\n+                    } else if (typeDepth == 0 &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3386,0 +3470,2 @@\n+                case BANG:\n+                    if (!peekToken(lookahead, LPAREN)) break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":91,"deletions":5,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -3183,0 +3183,3 @@\n+compiler.misc.feature.bang.types=\\\n+    bang types\n+\n@@ -4146,0 +4149,29 @@\n+\n+### bang types\n+\n+compiler.err.non.nullable.cannot.be.assigned.null=\\\n+    non-nullable type cannot be assigned null\n+\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+compiler.warn.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -225,0 +225,3 @@\n+javac.opt.Xlint.desc.null=\\\n+    Warn about operations on null-restricted and nullable types.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2639,1 +2639,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2776,1 +2776,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2885,1 +2885,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2910,1 +2910,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2968,0 +2968,34 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public void setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            NULLABLE(\"?\"),\n+            PARAMETRIC(\"*\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+                if (tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+    public void remove(LintCategory lint) {\n+        nonSilentLintSet.remove(lint);\n+        silentLintSet.remove(lint);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -132,0 +132,4 @@\n+    protected void assertOKWithWarning(String warning, int numberOfTimes, String... constructs) {\n+        assertCompile(expandMarkers(constructs), () -> assertCompileSucceededWithWarning(warning, numberOfTimes), false);\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+    public boolean containsWarningKey(String key, int numberOfWarnings) {\n+        return diags.stream()\n+                .filter(d -> d.getKind() == Diagnostic.Kind.WARNING || d.getKind() == Diagnostic.Kind.MANDATORY_WARNING)\n+                .filter(d -> d.getCode().equals(key)).count() == numberOfWarnings;\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/Diagnostics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,0 +193,8 @@\n+        }\n+    }\n+\n+    protected void assertCompileSucceededWithWarning(String warning, int numberOfWarnings) {\n+        if (diags.errorsFound())\n+            fail(\"Expected successful compilation\");\n+        if (!diags.containsWarningKey(warning, numberOfWarnings)) {\n+            fail(String.format(\"Expected compilation warning with %s, found %s\", warning, diags.keys()));\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile BangTypeParsingTest.java\n+ *\/\n+\n+import java.util.function.*;\n+import java.util.*;\n+\n+class Test {\n+    \/\/ fields\n+    Object? o1;\n+    Object! o2;\n+\n+    \/\/ method parameters\n+    void m1(Object? o) { }\n+    void m2(Object! o) { }\n+\n+    \/\/ method returns\n+    Object? m1() { return null; }\n+    Object! m2() { return null; }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Object? o1;\n+        Object! o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Object?> co1;\n+    Consumer<Object!> co2;\n+\n+    \/\/ generics - method param\n+    void m3(Consumer<Object?> co) { }\n+    void m4(Consumer<Object!> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Object?> m3() { return null; }\n+    Consumer<Object!> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Object?> co1;\n+        Consumer<Object!> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Object?> co1 = (Object? co) -> {};\n+        Consumer<Object!> co2 = (Object! co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Object?>> co1 = (Consumer<Object?> co) -> {};\n+        Consumer<Consumer<Object!>> co2 = (Consumer<Object!> co) -> {};\n+        Consumer<Function<Object?, Object!>> co3 = (Function<Object?, Object!> co) -> {};\n+        Consumer<Function<Object!, Object?>> co4 = (Function<Object!, Object?> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Object?>>>> co5 = (Consumer<Consumer<Consumer<Object?>>> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Object!>>>> co6 = (Consumer<Consumer<Consumer<Object!>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Integer! i -> throw new AssertionError();\n+            case String? s -> throw new AssertionError();\n+                default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Integer> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Integer!> i -> { }\n+        }\n+        switch (o) {\n+            case I<Integer?> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Integer>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Integer!>> i -> { }\n+        }\n+        switch (o) {\n+            case I2<I<Integer?>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Integer>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Integer!>>> i -> { }\n+        }\n+        switch (o) {\n+            case I3<I2<I<Integer?>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R?(I<Integer?> i) -> { }\n+        }\n+        switch (o) {\n+            case R!(I<Integer!> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2?(I2<I<Integer?>> i) -> { }\n+        }\n+        switch (o) {\n+            case R2!(I2<I<Integer!>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3?(I3<I2<I<Integer?>>> i) -> { }\n+        }\n+        switch (o) {\n+            case R3!(I3<I2<I<Integer!>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r1 = o instanceof String?;\n+        boolean r2 = o instanceof String!;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r1 = r instanceof R(I<Integer?> i);\n+        boolean r2 = r instanceof R(I<Integer!> i);\n+    }\n+\n+    void testCast(Object o) {\n+        String? s1 = (String?)o;\n+        String! s2 = (String!)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Integer?> i1 = (I<Integer?>)a;\n+        I<Integer!> i2 = (I<Integer!>)a;\n+    }\n+\n+    void testGenericCast2(A a) {\n+        I?<Integer?> i1 = (I?<Integer?>)a;\n+        I!<Integer!> i2 = (I!<Integer!>)a;\n+    }\n+\n+    \/\/ arrays\n+\n+    Object?[]![]?[]! oarr;\n+    Function?<Object?[]![]?, Function<Object?[]![]?, Object?[]![]?>>[]![]? garr;\n+\n+    \/\/ patterns and for-each\n+\n+    void forEachPatterns(List<R> o) {\n+        for (R?(I<Integer?> i) : o) { }\n+        for (R!(I<Integer!> i) : o) { }\n+    }\n+\n+    void forEachPatterns2(List<R2> o) {\n+        for (R2?(I2<I?<Integer?>> i) : o) { }\n+        for (R2 !(I2<I!<Integer!>> i) : o) { }\n+    }\n+\n+    void forEachPatterns3(List<R3> o) {\n+        for (R3?(I3?<I2?<I<Integer?>>> i) : o) { }\n+        for (R3!(I3!<I2!<I<Integer!>>> i) : o) { }\n+    }\n+\n+    void mBad1(Object o) {\n+        String s1 = o instanceof String ? (String)o : null;\n+        String s2 = o instanceof String? ? (String)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        String s1 = o instanceof String ? \"\" : null;\n+        String s2 = o instanceof String? ? \"\" : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case String? s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case String? s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x1 = a instanceof String? && b;\n+        boolean x2 = a instanceof String! && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x1 = a instanceof String? s && b;\n+        boolean x2 = a instanceof String! s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypeParsingTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * BangTypesCompilationTests\n+ *\n+ * @test\n+ * @enablePreview\n+ * @summary compilation tests for bang types\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ * @run testng\/othervm BangTypesCompilationTests\n+ *\/\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.tools.Diagnostic;\n+\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class BangTypesCompilationTests extends CompilationTestCase {\n+    private static String[] EMPTY_OPTIONS = {};\n+    private static String[] LINT_OPTIONS = { \"-Xlint:null\" };\n+\n+    public BangTypesCompilationTests() {\n+        setDefaultFilename(\"Test.java\");\n+    }\n+\n+    enum TestResult {\n+        COMPILE_OK,\n+        COMPILE_WITH_WARNING,\n+        ERROR\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, null);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code, Consumer<Diagnostic<?>> diagConsumer) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, diagConsumer);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String diagsMessage, int diagsCount, TestResult testResult, String code,\n+                    Consumer<Diagnostic<?>> diagConsumer) {\n+        setCompileOptions(compilerOptions);\n+        try {\n+            if (testResult != TestResult.COMPILE_OK) {\n+                if (testResult == TestResult.COMPILE_WITH_WARNING) {\n+                    assertOKWithWarning(diagsMessage, diagsCount, code);\n+                } else {\n+                    assertFail(diagsMessage, code);\n+                }\n+            } else {\n+                if (diagConsumer == null) {\n+                    assertOK(code);\n+                } else {\n+                    assertOK(diagConsumer, code);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            System.err.println(\"error while compiling code:\\n\" + code);\n+            throw t;\n+        }\n+    }\n+\n+    void testList(List<DiagAndCode> testList) {\n+        for (DiagAndCode diagAndCode : testList) {\n+            if (diagAndCode.result == Result.Clean) {\n+                testHelper(LINT_OPTIONS, diagAndCode.code);\n+            } else if (diagAndCode.result == Result.Warning) {\n+                testHelper(LINT_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.COMPILE_WITH_WARNING, diagAndCode.code, null);\n+                testHelper(EMPTY_OPTIONS, diagAndCode.code,\n+                        d -> {\n+                            if (d.getKind() == Diagnostic.Kind.WARNING) {\n+                                \/\/ shouldn't issue any warnings if the -Xlint:null option is not passed\n+                                throw new AssertionError(\"unexpected warning for \" + diagAndCode.code);\n+                            }\n+                        });\n+            } else {\n+                testHelper(EMPTY_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n+            }\n+            if (diagAndCode.result != Result.Error) {\n+                testHelper(EMPTY_OPTIONS, diagAndCode.code);\n+            }\n+        }\n+    }\n+\n+    enum Result { Warning, Error, Clean}\n+\n+    record DiagAndCode(String code, Result result, String diag, int diagsCount) {\n+        DiagAndCode(String code, Result result, String diag) {\n+            this(code, result, diag, 1);\n+        }\n+    }\n+\n+    public void testErrorNonNullableCantBeAssignedNull() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.cannot.be.assigned.null\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String[]! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.cannot.be.assigned.null\")\n+                )\n+        );\n+    }\n+\n+    public void testWarnUninitialized() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String![]![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String[][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String[][][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\")\n+                )\n+        );\n+    }\n+\n+    public void testUncheckedNullnessConversions () {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m(String! s1, String s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m(Object! s1, String s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m(String! s1, String s3) {\n+                                        s3 = s1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends String!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends Object!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        \/\/ wildcards\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends String> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends Object!> ls1, List<? extends String> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends String> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends Object> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    public void testNoWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                     void m(List<? super String!> ls1) {}\n+                                     void test(List<? super String!> ls2) {\n+                                         m(ls2);\n+                                     }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\" \/* no warnings in this case *\/)\n+                )\n+        );\n+    }\n+\n+    public void testOverridingWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                abstract class A {\n+                                    abstract String! lookup(String arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(String arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.1\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                abstract class A {\n+                                    abstract String lookup(String! arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(String arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.2\")\n+                )\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test runtime null checks\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RuntimeNullChecks\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+public class RuntimeNullChecks extends TestRunner {\n+    ToolBox tb;\n+\n+    RuntimeNullChecks() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RuntimeNullChecks t = new RuntimeNullChecks();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testRuntimeChecks(Path base) throws Exception {\n+        for (String code: new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String! o = s; \/\/ NPE at runtime, variable initialization\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String! o;\n+                        o = s; \/\/ NPE at runtime, assignment, it doesn't stress the same code path as the case above\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(String! arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            testHelper(base, code, true, NullPointerException.class);\n+        }\n+    }\n+\n+    private void testHelper(Path base, String testCode, boolean shouldFail, Class<?> expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path testSrc = src.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(testSrc, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's check that we get the expected error\n+            String output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n+                throw new AssertionError(expectedError.getName() + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/bang\/RuntimeNullChecks.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -229,0 +229,11 @@\n+#nullable types\n+compiler.misc.feature.bang.types\n+compiler.warn.accessing.member.of.nullable\n+compiler.warn.narrowing.nullness.conversion\n+compiler.warn.non.nullable.should.be.initialized\n+compiler.warn.accessing.member.of.parametric\n+compiler.warn.parametric.should.be.initialized\n+compiler.err.non.nullable.cannot.be.assigned.null\n+compiler.warn.unchecked.nullness.conversion\n+compiler.warn.overrides.with.different.nullness.1\n+compiler.warn.overrides.with.different.nullness.2\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}