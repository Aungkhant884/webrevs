{"files":[{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,2 @@\n-    --override-methods=summary\n+    --override-methods=summary \\\n+    --no-external-specs-page\n@@ -122,1 +123,2 @@\n-    -html5 -javafx --expand-requires transitive\n+    -html5 -javafx --expand-requires transitive \\\n+    --no-external-specs-page\n","filename":"make\/Docs.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-    common.boot_jdk_version = \"19\";\n+    common.boot_jdk_version = \"20\";\n@@ -1153,1 +1153,1 @@\n-            version: \"7.1.1\",\n+            version: \"7.2\",\n@@ -1155,1 +1155,1 @@\n-            file: \"bundles\/jtreg-7.1.1+1.zip\",\n+            file: \"bundles\/jtreg-7.2+1.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20 21\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"20 21\"\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-JVM_IsThreadAlive\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp\n@@ -172,2 +172,9 @@\n-    JVM_CFLAGS_FEATURES += -flto -fuse-linker-plugin\n-    JVM_LDFLAGS_FEATURES += -flto -fuse-linker-plugin -fno-strict-aliasing\n+    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto -fuse-linker-plugin -fno-strict-aliasing\n+  else ifeq ($(call isCompiler, microsoft), true)\n+    JVM_CFLAGS_FEATURES += -GL\n+    JVM_LDFLAGS_FEATURES += -LTCG:INCREMENTAL\n+  endif\n+else\n+  ifeq ($(call isCompiler, gcc), true)\n+    JVM_LDFLAGS_FEATURES += -O1\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2379,0 +2379,4 @@\n+const int Matcher::superword_max_vector_size(const BasicType bt) {\n+  return Matcher::max_vector_size(bt);\n+}\n+\n@@ -16643,18 +16647,0 @@\n-\/\/ counted loop end branch near Unsigned\n-instruct branchLoopEndU(cmpOpU cmp, rFlagsRegU cr, label lbl)\n-%{\n-  match(CountedLoopEnd cmp cr);\n-\n-  effect(USE lbl);\n-\n-  ins_cost(BRANCH_COST);\n-  \/\/ short variant.\n-  \/\/ ins_short_branch(1);\n-  format %{ \"b$cmp $lbl \\t\/\/ counted loop end unsigned\" %}\n-\n-  ins_encode(aarch64_enc_br_conU(cmp, lbl));\n-\n-  ins_pipe(pipe_branch);\n-%}\n-\n-\/\/ counted loop end branch far unsigned\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1315,1 +1315,1 @@\n-void C2_MacroAssembler::sve_vmaskcast_narrow(PRegister dst, PRegister src,\n+void C2_MacroAssembler::sve_vmaskcast_narrow(PRegister dst, PRegister src, PRegister ptmp,\n@@ -1318,0 +1318,10 @@\n+  \/\/ To ensure the higher order bits of the resultant narrowed vector are 0, an all-zero predicate is\n+  \/\/ passed as the second argument. An example narrowing operation with a given mask would be -\n+  \/\/ 128Long -> 64Int on a 128-bit machine i.e 2L -> 2I\n+  \/\/ Mask (for 2 Longs) : TF\n+  \/\/ Predicate register for the above mask (16 bits) : 00000001 00000000\n+  \/\/ After narrowing (uzp1 dst.b, src.b, ptmp.b) : 0000 0000 0001 0000\n+  \/\/ Which translates to mask for 2 integers as : TF (lower half is considered while upper half is 0)\n+  assert_different_registers(src, ptmp);\n+  assert_different_registers(dst, ptmp);\n+  sve_pfalse(ptmp);\n@@ -1319,1 +1329,1 @@\n-    sve_uzp1(dst, B, src, src);\n+    sve_uzp1(dst, B, src, ptmp);\n@@ -1321,2 +1331,2 @@\n-    sve_uzp1(dst, H, src, src);\n-    sve_uzp1(dst, B, dst, dst);\n+    sve_uzp1(dst, H, src, ptmp);\n+    sve_uzp1(dst, B, dst, ptmp);\n@@ -1324,3 +1334,3 @@\n-    sve_uzp1(dst, S, src, src);\n-    sve_uzp1(dst, H, dst, dst);\n-    sve_uzp1(dst, B, dst, dst);\n+    sve_uzp1(dst, S, src, ptmp);\n+    sve_uzp1(dst, H, dst, ptmp);\n+    sve_uzp1(dst, B, dst, ptmp);\n@@ -1779,1 +1789,1 @@\n-    \/\/ Encode to \"whilelow\" for the remaining cases.\n+    \/\/ Encode to \"whileltw\" for the remaining cases.\n@@ -1781,1 +1791,1 @@\n-    sve_whilelow(dst, size, zr, rscratch1);\n+    sve_whileltw(dst, size, zr, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-  void sve_vmaskcast_narrow(PRegister dst, PRegister src,\n+  void sve_vmaskcast_narrow(PRegister dst, PRegister src, PRegister ptmp,\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-define_pd_global(bool, TrapBasedNullChecks,  false);\n+define_pd_global(bool, TrapBasedNullChecks,     false);\n@@ -39,0 +39,2 @@\n+define_pd_global(bool, DelayCompilerStubsGeneration, COMPILER2_OR_JVMCI);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2020,0 +2020,11 @@\n+\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  ldr(cache, Address(rcpool, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  lsl(index, index, log2i_exact(sizeof(ResolvedIndyEntry)));\n+  add(cache, cache, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n+  lea(cache, Address(cache, index));\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+\n+  void load_resolved_indy_entry(Register cache, Register index);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4497,5 +4497,0 @@\n-void MacroAssembler::load_klass_check_null(Register dst, Register src) {\n-  null_check(src, oopDesc::klass_offset_in_bytes());\n-  load_klass(dst, src);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -891,1 +891,0 @@\n-  void load_klass_check_null(Register dst, Register src);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-        __ load_klass_check_null(temp1_recv_klass, receiver_reg);\n+        __ load_klass(temp1_recv_klass, receiver_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -834,1 +834,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {\n+      (Interpreter::code() != NULL || StubRoutines::final_stubs_code() != NULL)) {\n@@ -842,1 +842,1 @@\n-    if (Interpreter::code() != NULL)\n+    if (Interpreter::code() != NULL) {\n@@ -846,1 +846,2 @@\n-    if (StubRoutines::code1() != NULL)\n+    }\n+    if (StubRoutines::initial_stubs_code() != NULL) {\n@@ -848,1 +849,2 @@\n-                  StubRoutines::code1()->code_begin(), StubRoutines::code1()->code_end(),\n+                  StubRoutines::initial_stubs_code()->code_begin(),\n+                  StubRoutines::initial_stubs_code()->code_end(),\n@@ -850,1 +852,2 @@\n-    if (StubRoutines::code2() != NULL)\n+    }\n+    if (StubRoutines::final_stubs_code() != NULL) {\n@@ -852,1 +855,2 @@\n-                  StubRoutines::code2()->code_begin(), StubRoutines::code2()->code_end(),\n+                  StubRoutines::final_stubs_code()->code_begin(),\n+                  StubRoutines::final_stubs_code()->code_end(),\n@@ -854,0 +858,1 @@\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -812,1 +812,1 @@\n-    const FloatRegister gcvt1 = v6, gcvt2 = v7, gcvt3 = v8;\n+    const FloatRegister gcvt1 = v6, gcvt2 = v7, gcvt3 = v16; \/\/ Note that v8-v15 are callee saved\n@@ -1206,1 +1206,1 @@\n-    const FloatRegister gcvt1 = v6, gcvt2 = v7, gcvt3 = v8;\n+    const FloatRegister gcvt1 = v6, gcvt2 = v7, gcvt3 = v16; \/\/ Note that v8-v15 are callee saved\n@@ -8154,1 +8154,1 @@\n-  void generate_initial() {\n+  void generate_initial_stubs() {\n@@ -8180,0 +8180,6 @@\n+\n+    \/\/ Initialize table for copy memory (arraycopy) check.\n+    if (UnsafeCopyMemory::_table == nullptr) {\n+      UnsafeCopyMemory::create_table(8);\n+    }\n+\n@@ -8211,1 +8217,1 @@\n-  void generate_phase1() {\n+  void generate_continuation_stubs() {\n@@ -8221,1 +8227,1 @@\n-  void generate_all() {\n+  void generate_final_stubs() {\n@@ -8244,4 +8250,0 @@\n-    if (UseSVE == 0) {\n-      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n-    }\n-\n@@ -8251,2 +8253,22 @@\n-    \/\/ countPositives stub for large arrays.\n-    StubRoutines::aarch64::_count_positives = generate_count_positives(StubRoutines::aarch64::_count_positives_long);\n+    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+    if (bs_nm != NULL) {\n+      StubRoutines::aarch64::_method_entry_barrier = generate_method_entry_barrier();\n+    }\n+\n+    StubRoutines::aarch64::_spin_wait = generate_spin_wait();\n+\n+#if defined (LINUX) && !defined (__ARM_FEATURE_ATOMICS)\n+\n+    generate_atomic_entry_points();\n+\n+#endif \/\/ LINUX\n+\n+    StubRoutines::aarch64::set_completed(); \/\/ Inidicate that arraycopy and zero_blocks stubs are generated\n+  }\n+\n+  void generate_compiler_stubs() {\n+#if COMPILER2_OR_JVMCI\n+\n+    if (UseSVE == 0) {\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+    }\n@@ -8259,0 +8281,6 @@\n+    \/\/ byte_array_inflate stub for large arrays.\n+    StubRoutines::aarch64::_large_byte_array_inflate = generate_large_byte_array_inflate();\n+\n+    \/\/ countPositives stub for large arrays.\n+    StubRoutines::aarch64::_count_positives = generate_count_positives(StubRoutines::aarch64::_count_positives_long);\n+\n@@ -8263,7 +8291,0 @@\n-    \/\/ byte_array_inflate stub for large arrays.\n-    StubRoutines::aarch64::_large_byte_array_inflate = generate_large_byte_array_inflate();\n-\n-    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-    if (bs_nm != NULL) {\n-      StubRoutines::aarch64::_method_entry_barrier = generate_method_entry_barrier();\n-    }\n@@ -8356,10 +8377,1 @@\n-\n-    StubRoutines::aarch64::_spin_wait = generate_spin_wait();\n-\n-#if defined (LINUX) && !defined (__ARM_FEATURE_ATOMICS)\n-\n-    generate_atomic_entry_points();\n-\n-#endif \/\/ LINUX\n-\n-    StubRoutines::aarch64::set_completed();\n+#endif \/\/ COMPILER2_OR_JVMCI\n@@ -8369,8 +8381,18 @@\n-  StubGenerator(CodeBuffer* code, int phase) : StubCodeGenerator(code) {\n-    if (phase == 0) {\n-      generate_initial();\n-    } else if (phase == 1) {\n-      generate_phase1(); \/\/ stubs that must be available for the interpreter\n-    } else {\n-      generate_all();\n-    }\n+  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n+    switch(kind) {\n+    case Initial_stubs:\n+      generate_initial_stubs();\n+      break;\n+     case Continuation_stubs:\n+      generate_continuation_stubs();\n+      break;\n+    case Compiler_stubs:\n+      generate_compiler_stubs();\n+      break;\n+    case Final_stubs:\n+      generate_final_stubs();\n+      break;\n+    default:\n+      fatal(\"unexpected stubs kind: %d\", kind);\n+      break;\n+    };\n@@ -8380,6 +8402,2 @@\n-#define UCM_TABLE_MAX_ENTRIES 8\n-void StubGenerator_generate(CodeBuffer* code, int phase) {\n-  if (UnsafeCopyMemory::_table == NULL) {\n-    UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);\n-  }\n-  StubGenerator g(code, phase);\n+void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n+  StubGenerator g(code, kind);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":60,"deletions":42,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -488,4 +488,2 @@\n-  \/\/ Pop N words from the stack\n-  __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);\n-  __ ldr(r1, Address(r1, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n-  __ andr(r1, r1, ConstantPoolCacheEntry::parameter_size_mask);\n+  const Register cache = r1;\n+  const Register index = r2;\n@@ -493,1 +491,12 @@\n-  __ add(esp, esp, r1, Assembler::LSL, 3);\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(cache, index);\n+    __ load_unsigned_short(cache, Address(cache, in_bytes(ResolvedIndyEntry::num_parameters_offset())));\n+    __ add(esp, esp, cache, Assembler::LSL, 3);\n+  } else {\n+    \/\/ Pop N words from the stack\n+    __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+    __ ldr(cache, Address(cache, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+    __ andr(cache, cache, ConstantPoolCacheEntry::parameter_size_mask);\n+\n+    __ add(esp, esp, cache, Assembler::LSL, 3);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -735,2 +735,0 @@\n-  \/\/ check array\n-  __ null_check(array, arrayOopDesc::length_offset_in_bytes());\n@@ -1831,6 +1829,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n@@ -2100,6 +2092,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n@@ -2450,0 +2436,69 @@\n+\/\/ The rmethod register is input and overwritten to be the adapter method for the\n+\/\/ indy call. Link Register (lr) is set to the return address for the adapter and\n+\/\/ an appendix may be pushed to the stack. Registers r0-r3 are clobbered\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register appendix = r0;\n+  const Register cache = r2;\n+  const Register index = r3;\n+  assert_different_registers(method, appendix, cache, index, rcpool);\n+\n+  __ save_bcp();\n+\n+  Label resolved;\n+\n+  __ load_resolved_indy_entry(cache, index);\n+  \/\/ Load-acquire the adapter method to match store-release in ResolvedIndyEntry::fill_in()\n+  __ lea(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  __ ldar(method, method);\n+\n+  \/\/ Compare the method to zero\n+  __ cbnz(method, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(method, code); \/\/ this is essentially Bytecodes::_invokedynamic\n+  __ call_VM(noreg, entry, method);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  \/\/ Load-acquire the adapter method to match store-release in ResolvedIndyEntry::fill_in()\n+  __ lea(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  __ ldar(method, method);\n+\n+#ifdef ASSERT\n+  __ cbnz(method, resolved);\n+  __ stop(\"Should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ tbz(index, ResolvedIndyEntry::has_appendix_shift, L_no_push);\n+\n+  \/\/ Get appendix\n+  __ load_unsigned_short(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter\n+  \/\/ since the parameter_size includes it.\n+  __ push(method);\n+  __ mov(method, index);\n+  __ load_resolved_reference_at_index(appendix, method);\n+  __ verify_oop(appendix);\n+  __ pop(method);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ compute return type\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+  \/\/ load return address\n+  \/\/ Return address is loaded into link register(lr) and not pushed to the stack\n+  \/\/ like x86\n+  {\n+    const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+    __ mov(rscratch1, table_addr);\n+    __ ldr(lr, Address(rscratch1, index, Address::lsl(3)));\n+  }\n+}\n+\n@@ -2456,1 +2511,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2477,1 +2532,1 @@\n-  size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+  size_t index_size = sizeof(u2);\n@@ -3463,1 +3518,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3532,1 +3587,1 @@\n-  __ load_klass_check_null(r0, recv);\n+  __ load_klass(r0, recv);\n@@ -3620,2 +3675,2 @@\n-  \/\/ Get receiver klass into r3 - also a null check\n-  __ load_klass_check_null(r3, r2);\n+  \/\/ Get receiver klass into r3\n+  __ load_klass(r3, r2);\n@@ -3635,1 +3690,1 @@\n-  \/\/ Get receiver klass into r3 - also a null check\n+  \/\/ Get receiver klass into r3\n@@ -3637,1 +3692,1 @@\n-  __ load_klass_check_null(r3, r2);\n+  __ load_klass(r3, r2);\n@@ -3734,1 +3789,1 @@\n-  prepare_invoke(byte_no, rmethod, r0);\n+  load_invokedynamic_entry(rmethod);\n@@ -3860,1 +3915,0 @@\n-  __ null_check(r0, arrayOopDesc::length_offset_in_bytes());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":79,"deletions":25,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -153,1 +153,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -174,1 +174,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -214,1 +214,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -235,1 +235,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -247,1 +247,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -264,1 +264,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -275,1 +275,1 @@\n-  int oop_index = __ oop_recorder()->allocate_oop_index(NULL);\n+  int oop_index = __ oop_recorder()->allocate_oop_index(nullptr);\n@@ -278,1 +278,1 @@\n-  AddressLiteral addrlit((address)NULL, oop_Relocation::spec(oop_index));\n+  AddressLiteral addrlit((address)nullptr, oop_Relocation::spec(oop_index));\n@@ -293,1 +293,1 @@\n-  int index = __ oop_recorder()->allocate_metadata_index(NULL);\n+  int index = __ oop_recorder()->allocate_metadata_index(nullptr);\n@@ -296,1 +296,1 @@\n-  AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(index));\n+  AddressLiteral addrlit((address)nullptr, metadata_Relocation::spec(index));\n@@ -449,4 +449,4 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n-  assert(op->info() == NULL, \"shouldn't have CodeEmitInfo\");\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n+  assert(op->info() == nullptr, \"shouldn't have CodeEmitInfo\");\n@@ -462,1 +462,1 @@\n-      assert(op->ublock() != NULL, \"must have unordered successor\");\n+      assert(op->ublock() != nullptr, \"must have unordered successor\");\n@@ -639,1 +639,1 @@\n-  if (entry_point_toc_addr == NULL) {\n+  if (entry_point_toc_addr == nullptr) {\n@@ -822,4 +822,0 @@\n-          if (VerifyOops) {\n-            BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-            bs->check_oop(_masm, to_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n-          }\n@@ -856,4 +852,0 @@\n-        if (VerifyOops) {\n-          BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-          bs->check_oop(_masm, to_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n-        }\n@@ -925,1 +917,1 @@\n-  if (info != NULL && needs_explicit_null_check) {\n+  if (info != nullptr && needs_explicit_null_check) {\n@@ -945,1 +937,1 @@\n-      if (UseCompressedOops && !wide && c->as_jobject() != NULL) {\n+      if (UseCompressedOops && !wide && c->as_jobject() != nullptr) {\n@@ -969,1 +961,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1022,1 +1014,1 @@\n-          if (const_addr == NULL) {\n+          if (const_addr == nullptr) {\n@@ -1041,1 +1033,1 @@\n-          if (const_addr == NULL) {\n+          if (const_addr == nullptr) {\n@@ -1134,1 +1126,1 @@\n-  if (info != NULL && needs_explicit_null_check) {\n+  if (info != nullptr && needs_explicit_null_check) {\n@@ -1142,1 +1134,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1176,1 +1168,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1179,1 +1171,1 @@\n-  if (info != NULL && !needs_explicit_null_check) {\n+  if (info != nullptr && !needs_explicit_null_check) {\n@@ -1256,1 +1248,1 @@\n-  if (info != NULL && needs_explicit_null_check) {\n+  if (info != nullptr && needs_explicit_null_check) {\n@@ -1264,1 +1256,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1307,1 +1299,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1311,1 +1303,1 @@\n-  if (info != NULL && !needs_explicit_null_check) {\n+  if (info != nullptr && !needs_explicit_null_check) {\n@@ -1354,1 +1346,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1368,1 +1360,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1390,1 +1382,1 @@\n-  AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);\n+  AddressLiteral ic = __ allocate_metadata_address((Metadata *)nullptr);\n@@ -1446,1 +1438,1 @@\n-            if (con == NULL) {\n+            if (con == nullptr) {\n@@ -1456,1 +1448,1 @@\n-          \/\/ We only need, for now, comparison with NULL for metadata.\n+          \/\/ We only need, for now, comparison with null for metadata.\n@@ -1460,1 +1452,1 @@\n-            if (p == NULL) {\n+            if (p == nullptr) {\n@@ -1542,1 +1534,1 @@\n-    lasm->const2reg(src, dst, lir_patch_none, NULL);\n+    lasm->const2reg(src, dst, lir_patch_none, nullptr);\n@@ -1612,1 +1604,1 @@\n-  assert(info == NULL, \"unused on this code path\");\n+  assert(info == nullptr, \"unused on this code path\");\n@@ -1840,1 +1832,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -1845,1 +1837,1 @@\n-  const int frame_resize = frame::abi_reg_args_size - sizeof(frame::jit_abi); \/\/ C calls need larger frame.\n+  const int frame_resize = frame::native_abi_reg_args_size - sizeof(frame::java_abi); \/\/ C calls need larger frame.\n@@ -1851,1 +1843,1 @@\n-  if (op->expected_type() == NULL) {\n+  if (op->expected_type() == nullptr) {\n@@ -1855,1 +1847,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -1886,1 +1878,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass(), \"must be true at this point\");\n@@ -2009,1 +2001,1 @@\n-                                       &cont, copyfunc_addr != NULL ? &copyfunc : &slow, NULL);\n+                                       &cont, copyfunc_addr != nullptr ? &copyfunc : &slow, nullptr);\n@@ -2018,1 +2010,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ Use stub if available.\n+      if (copyfunc_addr != nullptr) { \/\/ Use stub if available.\n@@ -2359,1 +2351,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2361,1 +2353,1 @@\n-  assert(data != NULL,       \"need data for checkcast\");\n+  assert(data != nullptr,       \"need data for checkcast\");\n@@ -2395,2 +2387,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -2400,1 +2392,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -2448,2 +2440,2 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : NULL),\n-                                       failure_target, NULL, RegisterOrConstant(k->super_check_offset()));\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : nullptr),\n+                                       failure_target, nullptr, RegisterOrConstant(k->super_check_offset()));\n@@ -2523,2 +2515,2 @@\n-    ciMethodData* md = NULL;\n-    ciProfileData* data = NULL;\n+    ciMethodData* md = nullptr;\n+    ciProfileData* data = nullptr;\n@@ -2528,1 +2520,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -2561,1 +2553,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &failure, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &failure, nullptr);\n@@ -2650,1 +2642,1 @@\n-                noreg, NULL, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n@@ -2700,1 +2692,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2715,1 +2707,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2744,1 +2736,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2767,1 +2759,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2769,1 +2761,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2797,1 +2789,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2823,1 +2815,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2891,1 +2883,1 @@\n-    assert(info != NULL, \"sanity\");\n+    assert(info != nullptr, \"sanity\");\n@@ -2898,1 +2890,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -3083,1 +3075,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -3122,1 +3114,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -3135,1 +3127,1 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n@@ -3137,1 +3129,1 @@\n-        if (exact_klass != NULL) {\n+        if (exact_klass != nullptr) {\n@@ -3165,1 +3157,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3178,1 +3170,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -3203,1 +3195,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":74,"deletions":82,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -37,1 +37,3 @@\n-define_pd_global(bool, UncommonNullCast,      true);  \/\/ Uncommon-trap NULLs passed to check cast.\n+define_pd_global(bool, UncommonNullCast,      true);  \/\/ Uncommon-trap nulls passed to check cast.\n+\n+define_pd_global(bool, DelayCompilerStubsGeneration, COMPILER2_OR_JVMCI);\n@@ -57,1 +59,1 @@\n-define_pd_global(bool,  VMContinuations, AIX_ONLY(false) NOT_AIX(true));\n+define_pd_global(bool,  VMContinuations, true);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -483,0 +483,11 @@\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+\n+  \/\/ Get address of invokedynamic array\n+  ld_ptr(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset()), R27_constPoolCache);\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  sldi(index, index, log2i_exact(sizeof(ResolvedIndyEntry)));\n+  add(cache, cache, index);\n+}\n+\n@@ -924,1 +935,1 @@\n-    \/\/   monitor->lock()->set_displaced_header(NULL);\n+    \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -985,1 +996,1 @@\n-    \/\/   monitor->lock()->set_displaced_header(NULL);\n+    \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1035,3 +1046,3 @@\n-    \/\/ if ((displaced_header = monitor->displaced_header()) == NULL) {\n-    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.\n-    \/\/   monitor->set_obj(NULL);\n+    \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n+    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n+    \/\/   monitor->set_obj(nullptr);\n@@ -1040,1 +1051,1 @@\n-    \/\/   monitor->set_obj(NULL);\n+    \/\/   monitor->set_obj(nullptr);\n@@ -1066,1 +1077,1 @@\n-    \/\/   monitor->set_obj(NULL);\n+    \/\/   monitor->set_obj(nullptr);\n@@ -1101,1 +1112,1 @@\n-    \/\/ Exchange worked, do monitor->set_obj(NULL);\n+    \/\/ Exchange worked, do monitor->set_obj(nullptr);\n@@ -1163,1 +1174,1 @@\n-  addi(Rscratch2, R15_esp, Interpreter::stackElementSize - frame::abi_reg_args_size);\n+  addi(Rscratch2, R15_esp, Interpreter::stackElementSize - frame::top_ijava_frame_abi_size);\n@@ -1693,1 +1704,1 @@\n-  \/\/ observed the receiver[start_row] is NULL.\n+  \/\/ observed the receiver[start_row] is null.\n@@ -2106,1 +2117,1 @@\n-  if (Interpreter::rethrow_exception_entry() != NULL) {\n+  if (Interpreter::rethrow_exception_entry() != nullptr) {\n@@ -2178,1 +2189,1 @@\n-    \/\/ After thawing the top frame of a continuation we reach here with frame::abi_minframe.\n+    \/\/ After thawing the top frame of a continuation we reach here with frame::java_abi.\n@@ -2203,1 +2214,1 @@\n-    cmpdi(CCR0, R0, frame::abi_reg_args_size + frame::ijava_state_size);\n+    cmpdi(CCR0, R0, frame::top_ijava_frame_abi_size + frame::ijava_state_size);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -146,1 +146,1 @@\n-      __ asm_assert_mem8_isnot_zero(slot_offset + 1*BytesPerWord, OSR_buf, \"locked object is NULL\", __LINE__);\n+      __ asm_assert_mem8_isnot_zero(slot_offset + 1*BytesPerWord, OSR_buf, \"locked object is null\", __LINE__);\n@@ -161,1 +161,1 @@\n-  if (call_addr == NULL) {\n+  if (call_addr == nullptr) {\n@@ -170,1 +170,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -216,1 +216,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -241,1 +241,1 @@\n-  __ z_lg(Z_EXC_PC, _z_abi16(return_pc), Z_SP);\n+  __ z_lg(Z_EXC_PC, _z_common_abi(return_pc), Z_SP);\n@@ -251,1 +251,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -261,1 +261,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -276,1 +276,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -289,1 +289,1 @@\n-  int oop_index = __ oop_recorder()->allocate_oop_index(NULL);\n+  int oop_index = __ oop_recorder()->allocate_oop_index(nullptr);\n@@ -294,1 +294,1 @@\n-  \/\/ The NULL will be dynamically patched later so the sequence to\n+  \/\/ The null will be dynamically patched later so the sequence to\n@@ -311,1 +311,1 @@\n-  int index = __ oop_recorder()->allocate_metadata_index(NULL);\n+  int index = __ oop_recorder()->allocate_metadata_index(nullptr);\n@@ -315,1 +315,1 @@\n-  \/\/ The NULL will be dynamically patched later so the sequence to\n+  \/\/ The null will be dynamically patched later so the sequence to\n@@ -356,3 +356,3 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  { _branch_target_blocks.append(op->block()); }\n-  if (op->ublock() != NULL) { _branch_target_blocks.append(op->ublock()); }\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  { _branch_target_blocks.append(op->block()); }\n+  if (op->ublock() != nullptr) { _branch_target_blocks.append(op->ublock()); }\n@@ -362,1 +362,1 @@\n-    if (op->info() != NULL) { add_debug_info_for_branch(op->info()); }\n+    if (op->info() != nullptr) { add_debug_info_for_branch(op->info()); }\n@@ -367,1 +367,1 @@\n-      assert(op->ublock() != NULL, \"must have unordered successor\");\n+      assert(op->ublock() != nullptr, \"must have unordered successor\");\n@@ -507,1 +507,1 @@\n-  address virtual_call_oop_addr = NULL;\n+  address virtual_call_oop_addr = nullptr;\n@@ -549,1 +549,1 @@\n-      if (c->as_jobject() == NULL) {\n+      if (c->as_jobject() == nullptr) {\n@@ -599,1 +599,1 @@\n-        if (c->as_jobject() == NULL) {\n+        if (c->as_jobject() == nullptr) {\n@@ -669,1 +669,1 @@\n-        if (c->as_jobject() == NULL) {\n+        if (c->as_jobject() == nullptr) {\n@@ -712,1 +712,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -763,1 +763,1 @@\n-      if (const_addr == NULL) {\n+      if (const_addr == nullptr) {\n@@ -781,1 +781,1 @@\n-      if (const_addr == NULL) {\n+      if (const_addr == nullptr) {\n@@ -884,1 +884,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -972,1 +972,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -975,1 +975,1 @@\n-  if (info != NULL) add_debug_info_for_null_check(offset, info);\n+  if (info != nullptr) add_debug_info_for_null_check(offset, info);\n@@ -1077,1 +1077,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1179,1 +1179,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1183,1 +1183,1 @@\n-  if (info != NULL) add_debug_info_for_null_check(offset, info);\n+  if (info != nullptr) add_debug_info_for_null_check(offset, info);\n@@ -1214,1 +1214,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -1229,1 +1229,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1239,1 +1239,1 @@\n-  AddressLiteral meta = __ allocate_metadata_address(NULL);\n+  AddressLiteral meta = __ allocate_metadata_address(nullptr);\n@@ -1292,1 +1292,1 @@\n-        \/\/ We only need, for now, comparison with NULL for metadata.\n+        \/\/ We only need, for now, comparison with null for metadata.\n@@ -1295,1 +1295,1 @@\n-        if (m == NULL) {\n+        if (m == nullptr) {\n@@ -1303,1 +1303,1 @@\n-        if (o == NULL) {\n+        if (o == nullptr) {\n@@ -1314,1 +1314,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -1452,1 +1452,1 @@\n-    const2reg(opr1, result, lir_patch_none, NULL);\n+    const2reg(opr1, result, lir_patch_none, nullptr);\n@@ -1481,1 +1481,1 @@\n-      const2reg(opr2, result, lir_patch_none, NULL);\n+      const2reg(opr2, result, lir_patch_none, nullptr);\n@@ -1491,1 +1491,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n@@ -1938,1 +1938,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -1942,1 +1942,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -1945,1 +1945,1 @@\n-    if (copyfunc_addr == NULL) {\n+    if (copyfunc_addr == nullptr) {\n@@ -2010,1 +2010,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n@@ -2040,1 +2040,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -2118,1 +2118,1 @@\n-      __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &cont, &slow, NULL);\n+      __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &cont, &slow, nullptr);\n@@ -2130,1 +2130,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -2432,2 +2432,3 @@\n-  int offset_in_bytes = param_num * BytesPerWord + FrameMap::first_available_sp_in_frame;\n-  assert(offset_in_bytes < frame_map()->reserved_argument_area_size(), \"invalid offset\");\n+  int offset_in_bytes = param_num * BytesPerWord;\n+  check_reserved_argument_area(offset_in_bytes);\n+  offset_in_bytes += FrameMap::first_available_sp_in_frame;\n@@ -2439,2 +2440,3 @@\n-  int offset_in_bytes = param_num * BytesPerWord + FrameMap::first_available_sp_in_frame;\n-  assert(offset_in_bytes < frame_map()->reserved_argument_area_size(), \"invalid offset\");\n+  int offset_in_bytes = param_num * BytesPerWord;\n+  check_reserved_argument_area(offset_in_bytes);\n+  offset_in_bytes += FrameMap::first_available_sp_in_frame;\n@@ -2457,2 +2459,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -2462,1 +2464,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -2465,1 +2467,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2467,1 +2469,1 @@\n-    assert(data != NULL,                \"need data for type check\");\n+    assert(data != nullptr,                \"need data for type check\");\n@@ -2528,2 +2530,2 @@\n-                                     (need_slow_path ? success_target : NULL),\n-                                     failure_target, NULL,\n+                                     (need_slow_path ? success_target : nullptr),\n+                                     failure_target, nullptr,\n@@ -2573,2 +2575,2 @@\n-    ciMethodData* md = NULL;\n-    ciProfileData* data = NULL;\n+    ciMethodData* md = nullptr;\n+    ciProfileData* data = nullptr;\n@@ -2580,1 +2582,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -2583,1 +2585,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -2585,1 +2587,1 @@\n-      assert(data != NULL,                \"need data for type check\");\n+      assert(data != nullptr,                \"need data for type check\");\n@@ -2614,1 +2616,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -2724,1 +2726,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2732,1 +2734,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2751,1 +2753,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2769,1 +2771,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2771,1 +2773,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2787,1 +2789,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2812,1 +2814,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2866,1 +2868,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2963,1 +2965,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -2985,1 +2987,1 @@\n-    __ asm_assert_ne(\"unexpected null obj\", __LINE__);\n+    __ asm_assert(Assembler::bcondNotZero, \"unexpected null obj\", __LINE__);\n@@ -2992,1 +2994,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -2996,1 +2998,1 @@\n-      __ asm_assert_eq(\"exact klass and actual klass differ\", __LINE__);\n+      __ asm_assert(Assembler::bcondEqual, \"exact klass and actual klass differ\", __LINE__);\n@@ -3004,2 +3006,2 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-        if (exact_klass != NULL) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+        if (exact_klass != nullptr) {\n@@ -3028,1 +3030,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3041,1 +3043,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -3061,1 +3063,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":85,"deletions":83,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -60,1 +60,1 @@\n-  assert(entry != NULL, \"Entry must have been generated by now\");\n+  assert(entry != nullptr, \"Entry must have been generated by now\");\n@@ -96,1 +96,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -277,1 +277,1 @@\n-    z_bre(L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    z_bre(L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -349,0 +349,11 @@\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  get_constant_pool_cache(cache);\n+  z_lg(cache, Address(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  z_sllg(index, index, exact_log2(sizeof(ResolvedIndyEntry)));\n+  z_la(cache, Array<ResolvedIndyEntry>::base_offset_in_bytes(), index, cache);\n+}\n+\n@@ -609,1 +620,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -744,0 +755,5 @@\n+void InterpreterMacroAssembler::get_constant_pool_cache(Register Rdst) {\n+  get_constant_pool(Rdst);\n+  mem2reg_opt(Rdst, Address(Rdst, ConstantPool::cache_offset_in_bytes()));\n+}\n+\n@@ -982,1 +998,1 @@\n-  \/\/   monitor->lock()->set_displaced_header(NULL);\n+  \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1027,1 +1043,1 @@\n-  \/\/   monitor->lock()->set_displaced_header(NULL);\n+  \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1081,3 +1097,3 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == NULL) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n+  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1086,1 +1102,1 @@\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1107,3 +1123,3 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == NULL) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n+  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1121,1 +1137,1 @@\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1163,1 +1179,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1449,1 +1465,1 @@\n-  \/\/ observed the receiver[start_row] is NULL.\n+  \/\/ observed the receiver[start_row] is null.\n@@ -1465,1 +1481,1 @@\n-\/\/   if (row[0].rec != NULL) {\n+\/\/   if (row[0].rec != nullptr) {\n@@ -1468,1 +1484,1 @@\n-\/\/     if (row[1].rec != NULL) {\n+\/\/     if (row[1].rec != nullptr) {\n@@ -1471,1 +1487,1 @@\n-\/\/       if (row[2].rec != NULL) { count.incr(); goto done; } \/\/ overflow\n+\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":36,"deletions":20,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2215,1 +2215,1 @@\n-  int permconst[] = {1, 14};\n+  const int permconst[] = {1, 14};\n@@ -2308,0 +2308,8 @@\n+void C2_MacroAssembler::movsxl(BasicType typ, Register dst) {\n+  if (typ == T_BYTE) {\n+    movsbl(dst, dst);\n+  } else if (typ == T_SHORT) {\n+    movswl(dst, dst);\n+  }\n+}\n+\n@@ -2319,4 +2327,1 @@\n-      if (typ == T_BYTE)\n-        movsbl(dst, dst);\n-      else if (typ == T_SHORT)\n-        movswl(dst, dst);\n+      movsxl(typ, dst);\n@@ -2326,0 +2331,1 @@\n+    movsxl(typ, dst);\n@@ -3311,3 +3317,3 @@\n-  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n-              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n-              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+  const XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+                    vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+                    vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n@@ -6121,0 +6127,11 @@\n+void C2_MacroAssembler::vector_rearrange_int_float(BasicType bt, XMMRegister dst,\n+                                                   XMMRegister shuffle, XMMRegister src, int vlen_enc) {\n+  if (vlen_enc == AVX_128bit) {\n+    vpermilps(dst, src, shuffle, vlen_enc);\n+  } else if (bt == T_INT) {\n+    vpermd(dst, shuffle, src, vlen_enc);\n+  } else {\n+    assert(bt == T_FLOAT, \"\");\n+    vpermps(dst, shuffle, src, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  void movsxl(BasicType typ, Register dst);\n@@ -488,0 +489,3 @@\n+  void vector_rearrange_int_float(BasicType bt, XMMRegister dst, XMMRegister shuffle,\n+                                  XMMRegister src, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+define_pd_global(bool, DelayCompilerStubsGeneration, COMPILER2_OR_JVMCI);\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2300,0 +2300,14 @@\n+\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n+  movptr(cache, Address(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  if (is_power_of_2(sizeof(ResolvedIndyEntry))) {\n+    shll(index, log2i_exact(sizeof(ResolvedIndyEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    imull(index, index, sizeof(ResolvedIndyEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  }\n+  lea(cache, Address(cache, index, Address::times_1, Array<ResolvedIndyEntry>::base_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -335,0 +335,2 @@\n+  void load_resolved_indy_entry(Register cache, Register index);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-#include \"runtime\/flags\/flagSetting.hpp\"\n@@ -77,1 +76,1 @@\n-static Assembler::Condition reverse[] = {\n+static const Assembler::Condition reverse[] = {\n@@ -412,1 +411,1 @@\n-  FlagSetting fs(Debugging, true);\n+  DebuggingContext debugging{};\n@@ -841,1 +840,1 @@\n-  FlagSetting fs(Debugging, true);\n+  DebuggingContext debugging{};\n@@ -5470,5 +5469,0 @@\n-void MacroAssembler::load_klass_check_null(Register dst, Register src, Register tmp) {\n-  null_check(src, oopDesc::klass_offset_in_bytes());\n-  load_klass(dst, src, tmp);\n-}\n-\n@@ -9971,1 +9965,1 @@\n-  BasicType type[] = { T_BYTE, T_SHORT, T_INT, T_LONG};\n+  const BasicType type[] = { T_BYTE, T_SHORT, T_INT, T_LONG};\n@@ -9987,1 +9981,1 @@\n-  BasicType type[] = { T_BYTE, T_SHORT, T_INT, T_LONG};\n+  const BasicType type[] = { T_BYTE, T_SHORT, T_INT, T_LONG};\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -400,1 +400,0 @@\n-  void load_klass_check_null(Register dst, Register src, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-        __ load_klass_check_null(temp1_recv_klass, receiver_reg, temp2);\n+        __ load_klass(temp1_recv_klass, receiver_reg, temp2);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n+      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n@@ -767,1 +767,1 @@\n-    if (Interpreter::code() != nullptr)\n+    if (Interpreter::code() != nullptr) {\n@@ -771,1 +771,2 @@\n-    if (StubRoutines::code1() != nullptr)\n+    }\n+    if (StubRoutines::initial_stubs_code() != nullptr) {\n@@ -773,1 +774,2 @@\n-                  StubRoutines::code1()->code_begin(), StubRoutines::code1()->code_end(),\n+                  StubRoutines::initial_stubs_code()->code_begin(),\n+                  StubRoutines::initial_stubs_code()->code_end(),\n@@ -775,1 +777,2 @@\n-    if (StubRoutines::code2() != nullptr)\n+    }\n+    if (StubRoutines::final_stubs_code() != nullptr) {\n@@ -777,1 +780,2 @@\n-                  StubRoutines::code2()->code_begin(), StubRoutines::code2()->code_end(),\n+                  StubRoutines::final_stubs_code()->code_begin(),\n+                  StubRoutines::final_stubs_code()->code_end(),\n@@ -779,0 +783,1 @@\n+    }\n@@ -1789,3 +1794,5 @@\n-  __ membar(Assembler::Membar_mask_bits(\n-            Assembler::LoadLoad | Assembler::LoadStore |\n-            Assembler::StoreLoad | Assembler::StoreStore));\n+  if (!UseSystemMemoryBarrier) {\n+    __ membar(Assembler::Membar_mask_bits(\n+              Assembler::LoadLoad | Assembler::LoadStore |\n+              Assembler::StoreLoad | Assembler::StoreStore));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1055,1 +1055,1 @@\n-      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n+      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n@@ -1064,1 +1064,1 @@\n-    if (Interpreter::code() != nullptr)\n+    if (Interpreter::code() != nullptr) {\n@@ -1066,1 +1066,2 @@\n-                  Interpreter::code()->code_start(), Interpreter::code()->code_end(),\n+                  Interpreter::code()->code_start(),\n+                  Interpreter::code()->code_end(),\n@@ -1068,1 +1069,2 @@\n-    if (StubRoutines::code1() != nullptr)\n+    }\n+    if (StubRoutines::initial_stubs_code() != nullptr) {\n@@ -1070,1 +1072,2 @@\n-                  StubRoutines::code1()->code_begin(), StubRoutines::code1()->code_end(),\n+                  StubRoutines::initial_stubs_code()->code_begin(),\n+                  StubRoutines::initial_stubs_code()->code_end(),\n@@ -1072,1 +1075,2 @@\n-    if (StubRoutines::code2() != nullptr)\n+    }\n+    if (StubRoutines::final_stubs_code() != nullptr) {\n@@ -1074,1 +1078,2 @@\n-                  StubRoutines::code2()->code_begin(), StubRoutines::code2()->code_end(),\n+                  StubRoutines::final_stubs_code()->code_begin(),\n+                  StubRoutines::final_stubs_code()->code_end(),\n@@ -1076,0 +1081,1 @@\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3883,1 +3883,1 @@\n-void StubGenerator::generate_initial() {\n+void StubGenerator::generate_initial_stubs() {\n@@ -3889,0 +3889,5 @@\n+  \/\/ Initialize table for unsafe copy memeory check.\n+  if (UnsafeCopyMemory::_table == nullptr) {\n+    UnsafeCopyMemory::create_table(16);\n+  }\n+\n@@ -3948,4 +3953,0 @@\n-  if (UsePoly1305Intrinsics) {\n-    StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n-  }\n-\n@@ -3959,4 +3960,0 @@\n-  if (UseAdler32Intrinsics) {\n-     StubRoutines::_updateBytesAdler32 = generate_updateBytesAdler32();\n-  }\n-\n@@ -4120,1 +4117,1 @@\n-void StubGenerator::generate_phase1() {\n+void StubGenerator::generate_continuation_stubs() {\n@@ -4130,2 +4127,2 @@\n-void StubGenerator::generate_all() {\n-  \/\/ Generates all stubs and initializes the entry points\n+void StubGenerator::generate_final_stubs() {\n+  \/\/ Generates the rest of stubs and initializes the entry points\n@@ -4154,1 +4151,27 @@\n-  \/\/ entry points that are platform specific\n+  \/\/ support for verify_oop (must happen after universe_init)\n+  if (VerifyOops) {\n+    StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n+  }\n+\n+  \/\/ data cache line writeback\n+  StubRoutines::_data_cache_writeback = generate_data_cache_writeback();\n+  StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();\n+\n+  \/\/ arraycopy stubs used by compilers\n+  generate_arraycopy_stubs();\n+\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n+    StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();\n+  }\n+\n+  if (UseVectorizedMismatchIntrinsic) {\n+    StubRoutines::_vectorizedMismatch = generate_vectorizedMismatch();\n+  }\n+}\n+\n+void StubGenerator::generate_compiler_stubs() {\n+#if COMPILER2_OR_JVMCI\n+\n+  \/\/ Entry points that are C2 compiler specific.\n+\n@@ -4186,12 +4209,0 @@\n-  \/\/ support for verify_oop (must happen after universe_init)\n-  if (VerifyOops) {\n-    StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n-  }\n-\n-  \/\/ data cache line writeback\n-  StubRoutines::_data_cache_writeback = generate_data_cache_writeback();\n-  StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();\n-\n-  \/\/ arraycopy stubs used by compilers\n-  generate_arraycopy_stubs();\n-\n@@ -4204,0 +4215,8 @@\n+  if (UseAdler32Intrinsics) {\n+     StubRoutines::_updateBytesAdler32 = generate_updateBytesAdler32();\n+  }\n+\n+  if (UsePoly1305Intrinsics) {\n+    StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+  }\n+\n@@ -4208,0 +4227,1 @@\n+\n@@ -4214,0 +4234,1 @@\n+\n@@ -4227,0 +4248,1 @@\n+\n@@ -4259,4 +4281,0 @@\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs_nm != nullptr) {\n-    StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();\n-  }\n@@ -4350,0 +4368,2 @@\n+#endif \/\/ COMPILER2_OR_JVMCI\n+}\n@@ -4351,3 +4371,19 @@\n-  if (UseVectorizedMismatchIntrinsic) {\n-    StubRoutines::_vectorizedMismatch = generate_vectorizedMismatch();\n-  }\n+StubGenerator::StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n+    DEBUG_ONLY( _regs_in_thread = false; )\n+    switch(kind) {\n+    case Initial_stubs:\n+      generate_initial_stubs();\n+      break;\n+     case Continuation_stubs:\n+      generate_continuation_stubs();\n+      break;\n+    case Compiler_stubs:\n+      generate_compiler_stubs();\n+      break;\n+    case Final_stubs:\n+      generate_final_stubs();\n+      break;\n+    default:\n+      fatal(\"unexpected stubs kind: %d\", kind);\n+      break;\n+    };\n@@ -4356,5 +4392,2 @@\n-void StubGenerator_generate(CodeBuffer* code, int phase) {\n-  if (UnsafeCopyMemory::_table == nullptr) {\n-    UnsafeCopyMemory::create_table(16);\n-  }\n-  StubGenerator g(code, phase);\n+void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n+  StubGenerator g(code, kind);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":70,"deletions":37,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -556,3 +556,4 @@\n-  void generate_initial();\n-  void generate_phase1();\n-  void generate_all();\n+  void generate_initial_stubs();\n+  void generate_continuation_stubs();\n+  void generate_compiler_stubs();\n+  void generate_final_stubs();\n@@ -561,10 +562,1 @@\n-  StubGenerator(CodeBuffer* code, int phase) : StubCodeGenerator(code) {\n-    DEBUG_ONLY( _regs_in_thread = false; )\n-    if (phase == 0) {\n-      generate_initial();\n-    } else if (phase == 1) {\n-      generate_phase1(); \/\/ stubs that must be available for the interpreter\n-    } else {\n-      generate_all();\n-    }\n-  }\n+  StubGenerator(CodeBuffer* code, StubsKind kind);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -228,6 +228,11 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n-\n-  const Register flags = cache;\n-  __ movl(flags, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n-  __ andl(flags, ConstantPoolCacheEntry::parameter_size_mask);\n-  __ lea(rsp, Address(rsp, flags, Interpreter::stackElementScale()));\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(cache, index);\n+    __ load_unsigned_short(cache, Address(cache, in_bytes(ResolvedIndyEntry::num_parameters_offset())));\n+    __ lea(rsp, Address(rsp, cache, Interpreter::stackElementScale()));\n+  } else {\n+    __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+    Register flags = cache;\n+    __ movl(flags, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+    __ andl(flags, ConstantPoolCacheEntry::parameter_size_mask);\n+    __ lea(rsp, Address(rsp, flags, Interpreter::stackElementScale()));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -756,2 +756,0 @@\n-  \/\/ check array\n-  __ null_check(array, arrayOopDesc::length_offset_in_bytes());\n@@ -2847,0 +2845,68 @@\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register appendix = rax;\n+  const Register cache = rcx;\n+  const Register index = rdx;\n+  assert_different_registers(method, appendix, cache, index);\n+\n+  __ save_bcp();\n+\n+  Label resolved;\n+\n+  __ load_resolved_indy_entry(cache, index);\n+  __ movptr(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+\n+  \/\/ Compare the method to zero\n+  __ testptr(method, method);\n+  __ jcc(Assembler::notZero, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ movl(method, code); \/\/ this is essentially Bytecodes::_invokedynamic\n+  __ call_VM(noreg, entry, method);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  __ movptr(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+\n+#ifdef ASSERT\n+  __ testptr(method, method);\n+  __ jcc(Assembler::notZero, resolved);\n+  __ stop(\"Should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ testl(index, (1 << ResolvedIndyEntry::has_appendix_shift));\n+  __ jcc(Assembler::zero, L_no_push);\n+\n+  \/\/ Get appendix\n+  __ load_unsigned_short(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter\n+  \/\/ since the parameter_size includes it.\n+  __ load_resolved_reference_at_index(appendix, index);\n+  __ verify_oop(appendix);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ compute return type\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+  \/\/ load return address\n+  {\n+    const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+    ExternalAddress table(table_addr);\n+#ifdef _LP64\n+    __ lea(rscratch1, table);\n+    __ movptr(index, Address(rscratch1, index, Address::times_ptr));\n+#else\n+    __ movptr(index, ArrayAddress(table, Address(noreg, index, Address::times_ptr)));\n+#endif \/\/ _LP64\n+  }\n+\n+  \/\/ push return address\n+  __ push(index);\n+}\n+\n@@ -2853,1 +2919,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2869,1 +2935,1 @@\n-  size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+  size_t index_size = sizeof(u2);\n@@ -3926,1 +3992,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -4017,1 +4083,1 @@\n-  __ load_klass_check_null(rax, recv, rscratch1);\n+  __ load_klass(rax, recv, rscratch1);\n@@ -4108,1 +4174,1 @@\n-  __ load_klass_check_null(rlocals, rcx, rscratch1);\n+  __ load_klass(rlocals, rcx, rscratch1);\n@@ -4130,1 +4196,1 @@\n-  __ load_klass_check_null(rdx, rcx, rscratch1);\n+  __ load_klass(rdx, rcx, rscratch1);\n@@ -4249,2 +4315,1 @@\n-  prepare_invoke(byte_no, rbx_method, rax_callsite);\n-\n+  load_invokedynamic_entry(rbx_method);\n@@ -4390,1 +4455,0 @@\n-  __ null_check(rax, arrayOopDesc::length_offset_in_bytes());\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":75,"deletions":11,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1315,21 +1315,0 @@\n-#if defined(COMPILER2)\n-  if (FLAG_IS_DEFAULT(SuperWordMaxVectorSize)) {\n-    if (FLAG_IS_DEFAULT(UseAVX) && UseAVX > 2 &&\n-        is_intel_skylake() && _stepping >= 5) {\n-      \/\/ Limit auto vectorization to 256 bit (32 byte) by default on Cascade Lake\n-      FLAG_SET_DEFAULT(SuperWordMaxVectorSize, MIN2(MaxVectorSize, (intx)32));\n-    } else {\n-      FLAG_SET_DEFAULT(SuperWordMaxVectorSize, MaxVectorSize);\n-    }\n-  } else {\n-    if (SuperWordMaxVectorSize > MaxVectorSize) {\n-      warning(\"SuperWordMaxVectorSize cannot be greater than MaxVectorSize %i\", (int) MaxVectorSize);\n-      FLAG_SET_DEFAULT(SuperWordMaxVectorSize, MaxVectorSize);\n-    }\n-    if (!is_power_of_2(SuperWordMaxVectorSize)) {\n-      warning(\"SuperWordMaxVectorSize must be a power of 2, setting to MaxVectorSize: %i\", (int) MaxVectorSize);\n-      FLAG_SET_DEFAULT(SuperWordMaxVectorSize, MaxVectorSize);\n-    }\n-  }\n-#endif\n-\n@@ -2097,0 +2076,14 @@\n+#ifdef COMPILER2\n+\/\/ Determine if it's running on Cascade Lake using default options.\n+bool VM_Version::is_default_intel_cascade_lake() {\n+  return FLAG_IS_DEFAULT(UseAVX) &&\n+         FLAG_IS_DEFAULT(MaxVectorSize) &&\n+         UseAVX > 2 &&\n+         is_intel_cascade_lake();\n+}\n+#endif\n+\n+bool VM_Version::is_intel_cascade_lake() {\n+  return is_intel_skylake() && _stepping >= 5;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2174,0 +2174,13 @@\n+\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n+const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  switch (elem_bt) {\n+    case T_BYTE:  return false;\n+    case T_SHORT: return !VM_Version::supports_avx512bw();\n+    case T_INT:   return !VM_Version::supports_avx();\n+    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n@@ -2299,0 +2312,9 @@\n+const int Matcher::superword_max_vector_size(const BasicType bt) {\n+  \/\/ Limit the max vector size for auto vectorization to 256 bits (32 bytes)\n+  \/\/ by default on Cascade Lake\n+  if (VM_Version::is_default_intel_cascade_lake()) {\n+    return MIN2(Matcher::max_vector_size(bt), 32 \/ type2aelembytes(bt));\n+  }\n+  return Matcher::max_vector_size(bt);\n+}\n+\n@@ -8436,11 +8458,0 @@\n-\n-instruct loadShuffleB(vec dst) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (VectorLoadShuffle dst));\n-  format %{ \"vector_load_shuffle $dst, $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8513,1 +8524,1 @@\n-            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            !VM_Version::supports_avx512bw());\n@@ -8524,1 +8535,1 @@\n-      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8539,2 +8550,1 @@\n-      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8587,15 +8597,0 @@\n-instruct loadShuffleS_evex(vec dst, vec src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n-            VM_Version::supports_avx512bw());\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (!VM_Version::supports_avx512vl()) {\n-      vlen_enc = Assembler::AVX_512bit;\n-    }\n-    __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8621,1 +8616,1 @@\n-            Matcher::vector_length(n) == 4 && UseAVX < 2);\n+            Matcher::vector_length(n) == 4 && UseAVX == 0);\n@@ -8632,1 +8627,1 @@\n-    __ pmovzxbd($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8650,2 +8645,2 @@\n- predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n-           Matcher::vector_length(n) == 4 && UseAVX < 2);\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n+            UseAVX == 0);\n@@ -8661,12 +8656,0 @@\n-instruct loadShuffleI_avx(vec dst, vec src) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n-            UseAVX >= 2);\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-  int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8675,1 +8658,1 @@\n-            UseAVX >= 2);\n+            UseAVX > 0);\n@@ -8680,4 +8663,2 @@\n-    if (vlen_enc == Assembler::AVX_128bit) {\n-      vlen_enc = Assembler::AVX_256bit;\n-    }\n-    __ vpermd($dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_rearrange_int_float(bt, $dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister, vlen_enc);\n@@ -8704,2 +8685,1 @@\n-    __ vpmovzxbq($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-    __ vpsllq($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+    __ vpsllq($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8731,14 +8711,0 @@\n-instruct loadShuffleL_evex(vec dst, vec src) %{\n-  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    assert(UseAVX > 2, \"required\");\n-\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":33,"deletions":67,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1243,2 +1243,8 @@\n-    MacroAssembler _masm(cbuf);\n-    __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+    if (cbuf != nullptr) {\n+      MacroAssembler _masm(cbuf);\n+      __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+    } else {\n+      st->print(\"KMOV    %s, [ESP + %d]\", Matcher::regName[dst_first], offset);\n+#endif\n+    }\n@@ -1252,2 +1258,8 @@\n-    MacroAssembler _masm(cbuf);\n-    __ kmov(Address(rsp, offset), as_KRegister(Matcher::_regEncode[src_first]));\n+    if (cbuf != nullptr) {\n+      MacroAssembler _masm(cbuf);\n+      __ kmov(Address(rsp, offset), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+    } else {\n+      st->print(\"KMOV    [ESP + %d], %s\", offset, Matcher::regName[src_first]);\n+#endif\n+    }\n@@ -1271,2 +1283,8 @@\n-    MacroAssembler _masm(cbuf);\n-    __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+    if (cbuf != nullptr) {\n+      MacroAssembler _masm(cbuf);\n+      __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+    } else {\n+      st->print(\"KMOV    %s, %s\", Matcher::regName[dst_first], Matcher::regName[src_first]);\n+#endif\n+    }\n@@ -12681,29 +12699,0 @@\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"J$cop,u  $labl\\t# Loop end\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe( pipe_jcc );\n-%}\n-\n-instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(200);\n-  format %{ \"J$cop,u  $labl\\t# Loop end\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe( pipe_jcc );\n-%}\n-\n@@ -12873,31 +12862,0 @@\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"J$cop,us $labl\\t# Loop end\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe( pipe_jcc );\n-  ins_short_branch(1);\n-%}\n-\n-instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"J$cop,us $labl\\t# Loop end\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe( pipe_jcc );\n-  ins_short_branch(1);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":24,"deletions":66,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -8499,1 +8499,1 @@\n-instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)\n+instruct absI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n@@ -8502,7 +8502,4 @@\n-  effect(TEMP dst, TEMP tmp, KILL cr);\n-  format %{ \"movl $tmp, $src\\n\\t\"\n-            \"sarl $tmp, 31\\n\\t\"\n-            \"movl $dst, $src\\n\\t\"\n-            \"xorl $dst, $tmp\\n\\t\"\n-            \"subl $dst, $tmp\\n\"\n-          %}\n+  effect(TEMP dst, KILL cr);\n+  format %{ \"xorl    $dst, $dst\\t# abs int\\n\\t\"\n+            \"subl    $dst, $src\\n\\t\"\n+            \"cmovll  $dst, $src\" %}\n@@ -8510,5 +8507,3 @@\n-    __ movl($tmp$$Register, $src$$Register);\n-    __ sarl($tmp$$Register, 31);\n-    __ movl($dst$$Register, $src$$Register);\n-    __ xorl($dst$$Register, $tmp$$Register);\n-    __ subl($dst$$Register, $tmp$$Register);\n+    __ xorl($dst$$Register, $dst$$Register);\n+    __ subl($dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::less, $dst$$Register, $src$$Register);\n@@ -8521,1 +8516,1 @@\n-instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)\n+instruct absL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n@@ -8524,7 +8519,4 @@\n-  effect(TEMP dst, TEMP tmp, KILL cr);\n-  format %{ \"movq $tmp, $src\\n\\t\"\n-            \"sarq $tmp, 63\\n\\t\"\n-            \"movq $dst, $src\\n\\t\"\n-            \"xorq $dst, $tmp\\n\\t\"\n-            \"subq $dst, $tmp\\n\"\n-          %}\n+  effect(TEMP dst, KILL cr);\n+  format %{ \"xorl    $dst, $dst\\t# abs long\\n\\t\"\n+            \"subq    $dst, $src\\n\\t\"\n+            \"cmovlq  $dst, $src\" %}\n@@ -8532,5 +8524,3 @@\n-    __ movq($tmp$$Register, $src$$Register);\n-    __ sarq($tmp$$Register, 63);\n-    __ movq($dst$$Register, $src$$Register);\n-    __ xorq($dst$$Register, $tmp$$Register);\n-    __ subq($dst$$Register, $tmp$$Register);\n+    __ xorl($dst$$Register, $dst$$Register);\n+    __ subq($dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::less, $dst$$Register, $src$$Register);\n@@ -13302,29 +13292,0 @@\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,u   $labl\\t# loop end\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(200);\n-  format %{ \"j$cop,u   $labl\\t# loop end\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n@@ -13503,31 +13464,0 @@\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,us  $labl\\t# loop end\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n-instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,us  $labl\\t# loop end\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n@@ -14067,0 +13997,7 @@\n+\/\/ These peephole rules replace mov + I pairs (where I is one of {add, inc, dec,\n+\/\/ sal}) with lea instructions. The {add, sal} rules are beneficial in\n+\/\/ processors with at least partial ALU support for lea\n+\/\/ (supports_fast_2op_lea()), whereas the {inc, dec} rules are only generally\n+\/\/ beneficial for processors with full ALU support\n+\/\/ (VM_Version::supports_fast_3op_lea()) and Intel Cascade Lake.\n+\n@@ -14085,1 +14022,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n@@ -14093,1 +14031,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n@@ -14125,1 +14064,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n@@ -14133,1 +14073,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":31,"deletions":90,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+define_pd_global(bool,  DelayCompilerStubsGeneration, false); \/\/ Don't have compiler's stubs\n+\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4214,1 +4214,1 @@\n-    \"CompressV\", \"ExpandV\", \"CompressM\",\n+    \"CompressV\", \"ExpandV\", \"CompressM\", \"CompressBitsV\", \"ExpandBitsV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+template <typename T>\n+static inline void put_native(address p, T x) {\n+    memcpy((void*)p, &x, sizeof x);\n+}\n+\n@@ -228,1 +233,4 @@\n-  void emit_int16(uint16_t x) { *((uint16_t*) end()) = x; set_end(end() + sizeof(uint16_t)); }\n+  template <typename T>\n+  void emit_native(T x) { put_native(end(), x); set_end(end() + sizeof x); }\n+\n+  void emit_int16(uint16_t x) { emit_native(x); }\n@@ -244,5 +252,1 @@\n-  void emit_int32(uint32_t x) {\n-    address curr = end();\n-    *((uint32_t*) curr) = x;\n-    set_end(curr + sizeof(uint32_t));\n-  }\n+  void emit_int32(uint32_t x) { emit_native(x); }\n@@ -258,5 +262,4 @@\n-  void emit_int64( uint64_t x)  { *((uint64_t*) end()) = x; set_end(end() + sizeof(uint64_t)); }\n-\n-  void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }\n-  void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }\n-  void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }\n+  void emit_int64(uint64_t x)  { emit_native(x); }\n+  void emit_float(jfloat  x)   { emit_native(x); }\n+  void emit_double(jdouble x)  { emit_native(x); }\n+  void emit_address(address x) { emit_native(x); }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4136,2 +4136,4 @@\n-void Range::initialize(Arena* arena) {\n-  _end = new (arena) Range(max_jint, max_jint, NULL);\n+void Range::initialize() {\n+  assert(_end == nullptr, \"Range initialized more than once\");\n+  alignas(Range) static uint8_t end_storage[sizeof(Range)];\n+  _end = ::new(static_cast<void*>(end_storage)) Range(max_jint, max_jint, NULL);\n@@ -4183,3 +4185,5 @@\n-void Interval::initialize(Arena* arena) {\n-  Range::initialize(arena);\n-  _end = new (arena) Interval(-1);\n+void Interval::initialize() {\n+  Range::initialize();\n+  assert(_end == nullptr, \"Interval initialized more than once\");\n+  alignas(Interval) static uint8_t end_storage[sizeof(Interval)];\n+  _end = ::new(static_cast<void*>(end_storage)) Interval(-1);\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1204,3 +1204,2 @@\n-        ConstantPoolCacheEntry* cpce = pool->invokedynamic_cp_cache_entry_at(index);\n-        cpce->set_dynamic_call(pool, info);\n-        appendix = Handle(current, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n+        int indy_index = pool->decode_invokedynamic_index(index);\n+        appendix = Handle(current, pool->cache()->set_dynamic_call(info, indy_index));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,3 +53,7 @@\n-void ValueType::initialize(Arena* arena) {\n-  \/\/ Note: Must initialize all types for each compilation\n-  \/\/       as they are allocated within a ResourceMark!\n+void ValueType::initialize() {\n+#define VALUE_TYPE_STORAGE_NAME(name) name##_storage\n+#define VALUE_TYPE_STORAGE(name, type) alignas(type) static uint8_t VALUE_TYPE_STORAGE_NAME(name)[sizeof(type)]\n+#define VALUE_TYPE(name, type, ...)                                \\\n+  assert(name == nullptr, \"ValueType initialized more than once\"); \\\n+  VALUE_TYPE_STORAGE(name, type);                                  \\\n+  name = ::new(static_cast<void*>(VALUE_TYPE_STORAGE_NAME(name))) type(__VA_ARGS__)\n@@ -57,12 +61,11 @@\n-  \/\/ types\n-  voidType     = new (arena) VoidType();\n-  intType      = new (arena) IntType();\n-  longType     = new (arena) LongType();\n-  floatType    = new (arena) FloatType();\n-  doubleType   = new (arena) DoubleType();\n-  objectType   = new (arena) ObjectType();\n-  arrayType    = new (arena) ArrayType();\n-  instanceType = new (arena) InstanceType();\n-  classType    = new (arena) ClassType();\n-  addressType  = new (arena) AddressType();\n-  illegalType  = new (arena) IllegalType();\n+  VALUE_TYPE(voidType    , VoidType);\n+  VALUE_TYPE(intType     , IntType);\n+  VALUE_TYPE(longType    , LongType);\n+  VALUE_TYPE(floatType   , FloatType);\n+  VALUE_TYPE(doubleType  , DoubleType);\n+  VALUE_TYPE(objectType  , ObjectType);\n+  VALUE_TYPE(arrayType   , ArrayType);\n+  VALUE_TYPE(instanceType, InstanceType);\n+  VALUE_TYPE(classType   , ClassType);\n+  VALUE_TYPE(addressType , AddressType);\n+  VALUE_TYPE(illegalType , IllegalType);\n@@ -70,4 +73,8 @@\n-  intZero     = new (arena) IntConstant(0);\n-  intOne      = new (arena) IntConstant(1);\n-  objectNull  = new (arena) ObjectConstant(ciNullObject::make());\n-};\n+  VALUE_TYPE(intZero     , IntConstant   , 0);\n+  VALUE_TYPE(intOne      , IntConstant   , 1);\n+  VALUE_TYPE(objectNull  , ObjectConstant, ciNullObject::make());\n+\n+#undef VALUE_TYPE\n+#undef VALUE_TYPE_STORAGE\n+#undef VALUE_TYPE_STORAGE_NAME\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -164,2 +164,1 @@\n-  _total_closed_heap_region_size(0),\n-  _total_open_heap_region_size(0),\n+  _total_heap_region_size(0),\n@@ -334,1 +333,1 @@\n-    os::_exit(0);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -384,1 +383,1 @@\n-    os::_exit(0);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -1065,30 +1064,23 @@\n-  \/\/ open and closed archive regions\n-  static void log_heap_regions(const char* which, GrowableArray<MemRegion> *regions) {\n-    for (int i = 0; i < regions->length(); i++) {\n-      address start = address(regions->at(i).start());\n-      address end = address(regions->at(i).end());\n-      log_region(which, start, end, to_requested(start));\n-\n-      while (start < end) {\n-        size_t byte_size;\n-        oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-        if (original_oop != nullptr) {\n-          ResourceMark rm;\n-          log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n-                             p2i(to_requested(start)), original_oop->klass()->external_name());\n-          byte_size = original_oop->size() * BytesPerWord;\n-        } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n-          \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n-          \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n-          log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n-                             p2i(to_requested(start)));\n-          byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n-        } else {\n-          \/\/ We have reached the end of the region\n-          break;\n-        }\n-        address oop_end = start + byte_size;\n-        log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n-        start = oop_end;\n-      }\n-      if (start < end) {\n+  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n+    MemRegion r = heap_info->memregion();\n+    address start = address(r.start());\n+    address end = address(r.end());\n+    log_region(\"heap\", start, end, to_requested(start));\n+\n+    while (start < end) {\n+      size_t byte_size;\n+      oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n+      if (original_oop != nullptr) {\n+        ResourceMark rm;\n+        log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n+                           p2i(to_requested(start)), original_oop->klass()->external_name());\n+        byte_size = original_oop->size() * BytesPerWord;\n+      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n+        \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n+        \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n+        log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n+                           p2i(to_requested(start)));\n+        byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n+      } else {\n+        \/\/ We have reached the end of the region, but have some unused space\n+        \/\/ at the end.\n@@ -1098,0 +1090,1 @@\n+        break;\n@@ -1099,0 +1092,3 @@\n+      address oop_end = start + byte_size;\n+      log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n+      start = oop_end;\n@@ -1101,0 +1097,1 @@\n+\n@@ -1132,2 +1129,1 @@\n-                  GrowableArray<MemRegion> *closed_heap_regions,\n-                  GrowableArray<MemRegion> *open_heap_regions,\n+                  ArchiveHeapInfo* heap_info,\n@@ -1154,5 +1150,2 @@\n-    if (closed_heap_regions != nullptr) {\n-      log_heap_regions(\"closed heap region\", closed_heap_regions);\n-    }\n-    if (open_heap_regions != nullptr) {\n-      log_heap_regions(\"open heap region\", open_heap_regions);\n+    if (heap_info->is_used()) {\n+      log_heap_region(heap_info);\n@@ -1175,5 +1168,1 @@\n-void ArchiveBuilder::write_archive(FileMapInfo* mapinfo,\n-                                   GrowableArray<MemRegion>* closed_heap_regions,\n-                                   GrowableArray<MemRegion>* open_heap_regions,\n-                                   GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_bitmaps,\n-                                   GrowableArray<ArchiveHeapBitmapInfo>* open_heap_bitmaps) {\n+void ArchiveBuilder::write_archive(FileMapInfo* mapinfo, ArchiveHeapInfo* heap_info) {\n@@ -1188,1 +1177,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_bitmaps, open_heap_bitmaps,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), heap_info,\n@@ -1191,11 +1180,2 @@\n-  if (closed_heap_regions != nullptr) {\n-    _total_closed_heap_region_size = mapinfo->write_heap_regions(\n-                                        closed_heap_regions,\n-                                        closed_heap_bitmaps,\n-                                        MetaspaceShared::first_closed_heap_region,\n-                                        MetaspaceShared::max_num_closed_heap_regions);\n-    _total_open_heap_region_size = mapinfo->write_heap_regions(\n-                                        open_heap_regions,\n-                                        open_heap_bitmaps,\n-                                        MetaspaceShared::first_open_heap_region,\n-                                        MetaspaceShared::max_num_open_heap_regions);\n+  if (heap_info->is_used()) {\n+    _total_heap_region_size = mapinfo->write_heap_region(heap_info);\n@@ -1204,1 +1184,1 @@\n-  print_region_stats(mapinfo, closed_heap_regions, open_heap_regions);\n+  print_region_stats(mapinfo, heap_info);\n@@ -1218,1 +1198,1 @@\n-    CDSMapLogger::log(this, mapinfo, closed_heap_regions, open_heap_regions,\n+    CDSMapLogger::log(this, mapinfo, heap_info,\n@@ -1229,3 +1209,1 @@\n-void ArchiveBuilder::print_region_stats(FileMapInfo *mapinfo,\n-                                        GrowableArray<MemRegion>* closed_heap_regions,\n-                                        GrowableArray<MemRegion>* open_heap_regions) {\n+void ArchiveBuilder::print_region_stats(FileMapInfo *mapinfo, ArchiveHeapInfo* heap_info) {\n@@ -1237,2 +1215,1 @@\n-                                _total_closed_heap_region_size +\n-                                _total_open_heap_region_size;\n+                                _total_heap_region_size;\n@@ -1241,2 +1218,1 @@\n-                             _total_closed_heap_region_size +\n-                             _total_open_heap_region_size;\n+                             _total_heap_region_size;\n@@ -1250,3 +1226,2 @@\n-  if (closed_heap_regions != nullptr) {\n-    print_heap_region_stats(closed_heap_regions, \"ca\", total_reserved);\n-    print_heap_region_stats(open_heap_regions, \"oa\", total_reserved);\n+  if (heap_info->is_used()) {\n+    print_heap_region_stats(heap_info, total_reserved);\n@@ -1255,1 +1230,1 @@\n-  log_debug(cds)(\"total    : \" SIZE_FORMAT_W(9) \" [100.0%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used]\",\n+  log_debug(cds)(\"total   : \" SIZE_FORMAT_W(9) \" [100.0%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used]\",\n@@ -1260,1 +1235,1 @@\n-  log_debug(cds)(\"bm  space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used]\",\n+  log_debug(cds)(\"bm space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used]\",\n@@ -1264,10 +1239,6 @@\n-void ArchiveBuilder::print_heap_region_stats(GrowableArray<MemRegion>* regions,\n-                                             const char *name, size_t total_size) {\n-  int arr_len = regions == nullptr ? 0 : regions->length();\n-  for (int i = 0; i < arr_len; i++) {\n-      char* start = (char*)regions->at(i).start();\n-      size_t size = regions->at(i).byte_size();\n-      char* top = start + size;\n-      log_debug(cds)(\"%s%d space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used] at \" INTPTR_FORMAT,\n-                     name, i, size, size\/double(total_size)*100.0, size, p2i(start));\n-  }\n+void ArchiveBuilder::print_heap_region_stats(ArchiveHeapInfo *info, size_t total_size) {\n+  char* start = info->start();\n+  size_t size = info->byte_size();\n+  char* top = start + size;\n+  log_debug(cds)(\"hp space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used] at \" INTPTR_FORMAT,\n+                     size, size\/double(total_size)*100.0, size, p2i(start));\n@@ -1283,2 +1254,2 @@\n-  vm_exit_during_initialization(err_msg(\"Unable to allocate from '%s' region\", name),\n-                                \"Please reduce the number of shared classes.\");\n+  log_error(cds)(\"Unable to allocate from '%s' region: Please reduce the number of shared classes.\", name);\n+  MetaspaceShared::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":55,"deletions":84,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-struct ArchiveHeapBitmapInfo;\n+class ArchiveHeapInfo;\n@@ -242,2 +242,1 @@\n-  size_t _total_closed_heap_region_size;\n-  size_t _total_open_heap_region_size;\n+  size_t _total_heap_region_size;\n@@ -245,3 +244,1 @@\n-  void print_region_stats(FileMapInfo *map_info,\n-                          GrowableArray<MemRegion>* closed_heap_regions,\n-                          GrowableArray<MemRegion>* open_heap_regions);\n+  void print_region_stats(FileMapInfo *map_info, ArchiveHeapInfo* heap_info);\n@@ -249,2 +246,1 @@\n-  void print_heap_region_stats(GrowableArray<MemRegion>* regions,\n-                               const char *name, size_t total_size);\n+  void print_heap_region_stats(ArchiveHeapInfo* heap_info, size_t total_size);\n@@ -413,5 +409,1 @@\n-  void write_archive(FileMapInfo* mapinfo,\n-                     GrowableArray<MemRegion>* closed_heap_regions,\n-                     GrowableArray<MemRegion>* open_heap_regions,\n-                     GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_oopmaps,\n-                     GrowableArray<ArchiveHeapBitmapInfo>* open_heap_oopmaps);\n+  void write_archive(FileMapInfo* mapinfo, ArchiveHeapInfo* heap_info);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-\n@@ -54,6 +53,2 @@\n-size_t ArchiveHeapWriter::_buffer_top;\n-size_t ArchiveHeapWriter::_open_bottom;\n-size_t ArchiveHeapWriter::_open_top;\n-size_t ArchiveHeapWriter::_closed_bottom;\n-size_t ArchiveHeapWriter::_closed_top;\n-size_t ArchiveHeapWriter::_heap_roots_bottom;\n+size_t ArchiveHeapWriter::_buffer_used;\n+size_t ArchiveHeapWriter::_heap_roots_bottom_offset;\n@@ -63,7 +58,2 @@\n-address ArchiveHeapWriter::_requested_open_region_bottom;\n-address ArchiveHeapWriter::_requested_open_region_top;\n-address ArchiveHeapWriter::_requested_closed_region_bottom;\n-address ArchiveHeapWriter::_requested_closed_region_top;\n-\n-ResourceBitMap* ArchiveHeapWriter::_closed_oopmap;\n-ResourceBitMap* ArchiveHeapWriter::_open_oopmap;\n+address ArchiveHeapWriter::_requested_bottom;\n+address ArchiveHeapWriter::_requested_top;\n@@ -83,4 +73,2 @@\n-    _requested_open_region_bottom = nullptr;\n-    _requested_open_region_top = nullptr;\n-    _requested_closed_region_bottom = nullptr;\n-    _requested_closed_region_top = nullptr;\n+    _requested_bottom = nullptr;\n+    _requested_top = nullptr;\n@@ -100,5 +88,1 @@\n-\/\/ For the time being, always support two regions (to be strictly compatible with existing G1\n-\/\/ mapping code. We might eventually use a single region (JDK-8298048).\n-                              GrowableArray<MemRegion>* closed_regions, GrowableArray<MemRegion>* open_regions,\n-                              GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                              GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+                              ArchiveHeapInfo* heap_info) {\n@@ -109,2 +93,2 @@\n-  set_requested_address_for_regions(closed_regions, open_regions);\n-  relocate_embedded_oops(roots, closed_bitmaps, open_bitmaps);\n+  set_requested_address(heap_info);\n+  relocate_embedded_oops(roots, heap_info);\n@@ -136,4 +120,2 @@\n-bool ArchiveHeapWriter::is_in_requested_regions(oop o) {\n-  assert(_requested_open_region_bottom != nullptr, \"do not call before this is initialized\");\n-  assert(_requested_closed_region_bottom != nullptr, \"do not call before this is initialized\");\n-\n+bool ArchiveHeapWriter::is_in_requested_range(oop o) {\n+  assert(_requested_bottom != nullptr, \"do not call before _requested_bottom is initialized\");\n@@ -141,2 +123,1 @@\n-  return (_requested_open_region_bottom <= a && a < _requested_open_region_top) ||\n-         (_requested_closed_region_bottom <= a && a < _requested_closed_region_top);\n+  return (_requested_bottom <= a && a < _requested_top);\n@@ -146,2 +127,2 @@\n-  oop req_obj = cast_to_oop(_requested_open_region_bottom + offset);\n-  assert(is_in_requested_regions(req_obj), \"must be\");\n+  oop req_obj = cast_to_oop(_requested_bottom + offset);\n+  assert(is_in_requested_range(req_obj), \"must be\");\n@@ -171,1 +152,1 @@\n-  return _requested_open_region_bottom + buffered_address_to_offset(buffered_addr);\n+  return _requested_bottom + buffered_address_to_offset(buffered_addr);\n@@ -175,1 +156,1 @@\n-  return requested_obj_from_buffer_offset(_heap_roots_bottom);\n+  return cast_to_oop(_requested_bottom + _heap_roots_bottom_offset);\n@@ -178,1 +159,1 @@\n-address ArchiveHeapWriter::heap_region_requested_bottom(int heap_region_idx) {\n+address ArchiveHeapWriter::requested_address() {\n@@ -180,9 +161,1 @@\n-  switch (heap_region_idx) {\n-  case MetaspaceShared::first_closed_heap_region:\n-    return _requested_closed_region_bottom;\n-  case MetaspaceShared::first_open_heap_region:\n-    return _requested_open_region_bottom;\n-  default:\n-    ShouldNotReachHere();\n-    return nullptr;\n-  }\n+  return _requested_bottom;\n@@ -194,1 +167,1 @@\n-  _open_bottom = _buffer_top = 0;\n+  _buffer_used = 0;\n@@ -206,1 +179,1 @@\n-  int length = roots != nullptr ? roots->length() : 0;\n+  int length = roots->length();\n@@ -216,2 +189,2 @@\n-  size_t new_top = _buffer_top + byte_size;\n-  ensure_buffer_space(new_top);\n+  size_t new_used = _buffer_used + byte_size;\n+  ensure_buffer_space(new_used);\n@@ -219,1 +192,1 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_top);\n+  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n@@ -241,1 +214,1 @@\n-  log_info(cds)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n+  log_info(cds, heap)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n@@ -243,2 +216,2 @@\n-  _heap_roots_bottom = _buffer_top;\n-  _buffer_top = new_top;\n+  _heap_roots_bottom_offset = _buffer_used;\n+  _buffer_used = new_used;\n@@ -248,14 +221,0 @@\n-  copy_source_objs_to_buffer_by_region(\/*copy_open_region=*\/true);\n-  copy_roots_to_buffer(roots);\n-  _open_top = _buffer_top;\n-\n-  \/\/ Align the closed region to the next G1 region\n-  _buffer_top = _closed_bottom = align_up(_buffer_top, HeapRegion::GrainBytes);\n-  copy_source_objs_to_buffer_by_region(\/*copy_open_region=*\/false);\n-  _closed_top = _buffer_top;\n-\n-  log_info(cds, heap)(\"Size of open region   = \" SIZE_FORMAT \" bytes\", _open_top   - _open_bottom);\n-  log_info(cds, heap)(\"Size of closed region = \" SIZE_FORMAT \" bytes\", _closed_top - _closed_bottom);\n-}\n-\n-void ArchiveHeapWriter::copy_source_objs_to_buffer_by_region(bool copy_open_region) {\n@@ -266,5 +225,2 @@\n-    if (info->in_open_region() == copy_open_region) {\n-      \/\/ For region-based collectors such as G1, we need to make sure that we don't have\n-      \/\/ an object that can possible span across two regions.\n-      size_t buffer_offset = copy_one_source_obj_to_buffer(src_obj);\n-      info->set_buffer_offset(buffer_offset);\n+    size_t buffer_offset = copy_one_source_obj_to_buffer(src_obj);\n+    info->set_buffer_offset(buffer_offset);\n@@ -272,2 +228,1 @@\n-      _buffer_offset_to_source_obj_table->put(buffer_offset, src_obj);\n-    }\n+    _buffer_offset_to_source_obj_table->put(buffer_offset, src_obj);\n@@ -275,0 +230,5 @@\n+\n+  copy_roots_to_buffer(roots);\n+\n+  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots\",\n+                _buffer_used, _source_objs->length() + 1, roots->length());\n@@ -301,1 +261,1 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_top);\n+  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n@@ -316,1 +276,1 @@\n-  size_t new_top = _buffer_top + required_byte_size + min_filler_byte_size;\n+  size_t new_used = _buffer_used + required_byte_size + min_filler_byte_size;\n@@ -318,2 +278,2 @@\n-  const size_t cur_min_region_bottom = align_down(_buffer_top, MIN_GC_REGION_ALIGNMENT);\n-  const size_t next_min_region_bottom = align_down(new_top, MIN_GC_REGION_ALIGNMENT);\n+  const size_t cur_min_region_bottom = align_down(_buffer_used, MIN_GC_REGION_ALIGNMENT);\n+  const size_t next_min_region_bottom = align_down(new_used, MIN_GC_REGION_ALIGNMENT);\n@@ -329,1 +289,1 @@\n-    const size_t fill_bytes = filler_end - _buffer_top;\n+    const size_t fill_bytes = filler_end - _buffer_used;\n@@ -335,1 +295,1 @@\n-                        array_length, fill_bytes, _buffer_top);\n+                        array_length, fill_bytes, _buffer_used);\n@@ -338,1 +298,1 @@\n-    _buffer_top = filler_end;\n+    _buffer_used = filler_end;\n@@ -347,0 +307,3 @@\n+  \/\/ For region-based collectors such as G1, the archive heap may be mapped into\n+  \/\/ multiple regions. We need to make sure that we don't have an object that can possible\n+  \/\/ span across two regions.\n@@ -349,2 +312,2 @@\n-  size_t new_top = _buffer_top + byte_size;\n-  assert(new_top > _buffer_top, \"no wrap around\");\n+  size_t new_used = _buffer_used + byte_size;\n+  assert(new_used > _buffer_used, \"no wrap around\");\n@@ -352,2 +315,2 @@\n-  size_t cur_min_region_bottom = align_down(_buffer_top, MIN_GC_REGION_ALIGNMENT);\n-  size_t next_min_region_bottom = align_down(new_top, MIN_GC_REGION_ALIGNMENT);\n+  size_t cur_min_region_bottom = align_down(_buffer_used, MIN_GC_REGION_ALIGNMENT);\n+  size_t next_min_region_bottom = align_down(new_used, MIN_GC_REGION_ALIGNMENT);\n@@ -356,1 +319,1 @@\n-  ensure_buffer_space(new_top);\n+  ensure_buffer_space(new_used);\n@@ -359,2 +322,2 @@\n-  address to = offset_to_buffered_address<address>(_buffer_top);\n-  assert(is_object_aligned(_buffer_top), \"sanity\");\n+  address to = offset_to_buffered_address<address>(_buffer_used);\n+  assert(is_object_aligned(_buffer_used), \"sanity\");\n@@ -364,2 +327,2 @@\n-  size_t buffered_obj_offset = _buffer_top;\n-  _buffer_top = new_top;\n+  size_t buffered_obj_offset = _buffer_used;\n+  _buffer_used = new_used;\n@@ -370,5 +333,2 @@\n-void ArchiveHeapWriter::set_requested_address_for_regions(GrowableArray<MemRegion>* closed_regions,\n-                                                          GrowableArray<MemRegion>* open_regions) {\n-  assert(closed_regions->length() == 0, \"must be\");\n-  assert(open_regions->length() == 0, \"must be\");\n-\n+void ArchiveHeapWriter::set_requested_address(ArchiveHeapInfo* info) {\n+  assert(!info->is_used(), \"only set once\");\n@@ -379,14 +339,2 @@\n-  size_t closed_region_byte_size = _closed_top - _closed_bottom;\n-  size_t open_region_byte_size = _open_top - _open_bottom;\n-  assert(closed_region_byte_size > 0, \"must archived at least one object for closed region!\");\n-  assert(open_region_byte_size > 0, \"must archived at least one object for open region!\");\n-\n-  \/\/ The following two asserts are ensured by copy_source_objs_to_buffer_by_region().\n-  assert(is_aligned(_closed_bottom, HeapRegion::GrainBytes), \"sanity\");\n-  assert(is_aligned(_open_bottom, HeapRegion::GrainBytes), \"sanity\");\n-\n-  _requested_closed_region_bottom = align_down(heap_end - closed_region_byte_size, HeapRegion::GrainBytes);\n-  _requested_open_region_bottom = _requested_closed_region_bottom - (_closed_bottom - _open_bottom);\n-\n-  assert(is_aligned(_requested_closed_region_bottom, HeapRegion::GrainBytes), \"sanity\");\n-  assert(is_aligned(_requested_open_region_bottom, HeapRegion::GrainBytes), \"sanity\");\n+  size_t heap_region_byte_size = _buffer_used;\n+  assert(heap_region_byte_size > 0, \"must archived at least one object!\");\n@@ -394,2 +342,2 @@\n-  _requested_open_region_top = _requested_open_region_bottom + (_open_top - _open_bottom);\n-  _requested_closed_region_top = _requested_closed_region_bottom + (_closed_top - _closed_bottom);\n+  _requested_bottom = align_down(heap_end - heap_region_byte_size, HeapRegion::GrainBytes);\n+  assert(is_aligned(_requested_bottom, HeapRegion::GrainBytes), \"sanity\");\n@@ -397,1 +345,1 @@\n-  assert(_requested_open_region_top <= _requested_closed_region_bottom, \"no overlap\");\n+  _requested_top = _requested_bottom + _buffer_used;\n@@ -399,4 +347,2 @@\n-  closed_regions->append(MemRegion(offset_to_buffered_address<HeapWord*>(_closed_bottom),\n-                                   offset_to_buffered_address<HeapWord*>(_closed_top)));\n-  open_regions->append(  MemRegion(offset_to_buffered_address<HeapWord*>(_open_bottom),\n-                                   offset_to_buffered_address<HeapWord*>(_open_top)));\n+  info->set_memregion(MemRegion(offset_to_buffered_address<HeapWord*>(0),\n+                                offset_to_buffered_address<HeapWord*>(_buffer_used)));\n@@ -408,1 +354,1 @@\n-  assert(is_in_requested_regions(cast_to_oop(p)), \"must be\");\n+  assert(is_in_requested_range(cast_to_oop(p)), \"must be\");\n@@ -411,2 +357,2 @@\n-  assert(addr >= _requested_open_region_bottom, \"must be\");\n-  size_t offset = addr - _requested_open_region_bottom;\n+  assert(addr >= _requested_bottom, \"must be\");\n+  size_t offset = addr - _requested_bottom;\n@@ -424,1 +370,1 @@\n-  assert(is_in_requested_regions(request_oop), \"must be\");\n+  assert(is_in_requested_range(request_oop), \"must be\");\n@@ -448,1 +394,1 @@\n-template <typename T> void ArchiveHeapWriter::relocate_field_in_buffer(T* field_addr_in_buffer) {\n+template <typename T> void ArchiveHeapWriter::relocate_field_in_buffer(T* field_addr_in_buffer, CHeapBitMap* oopmap) {\n@@ -453,1 +399,1 @@\n-    mark_oop_pointer<T>(field_addr_in_buffer);\n+    mark_oop_pointer<T>(field_addr_in_buffer, oopmap);\n@@ -457,1 +403,1 @@\n-template <typename T> void ArchiveHeapWriter::mark_oop_pointer(T* buffered_addr) {\n+template <typename T> void ArchiveHeapWriter::mark_oop_pointer(T* buffered_addr, CHeapBitMap* oopmap) {\n@@ -459,1 +405,0 @@\n-  ResourceBitMap* oopmap;\n@@ -462,10 +407,3 @@\n-  if (request_p >= (T*)_requested_closed_region_bottom) {\n-    assert(request_p < (T*)_requested_closed_region_top, \"sanity\");\n-    oopmap = _closed_oopmap;\n-    requested_region_bottom = _requested_closed_region_bottom;\n-  } else {\n-    assert(request_p >= (T*)_requested_open_region_bottom, \"sanity\");\n-    assert(request_p <  (T*)_requested_open_region_top, \"sanity\");\n-    oopmap = _open_oopmap;\n-    requested_region_bottom = _requested_open_region_bottom;\n-  }\n+  assert(request_p >= (T*)_requested_bottom, \"sanity\");\n+  assert(request_p <  (T*)_requested_top, \"sanity\");\n+  requested_region_bottom = _requested_bottom;\n@@ -504,1 +442,1 @@\n-template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index) {\n+template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap) {\n@@ -506,1 +444,1 @@\n-  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset));\n+  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset), oopmap);\n@@ -512,0 +450,1 @@\n+  CHeapBitMap* _oopmap;\n@@ -514,2 +453,2 @@\n-  EmbeddedOopRelocator(oop src_obj, address buffered_obj) :\n-    _src_obj(src_obj), _buffered_obj(buffered_obj) {}\n+  EmbeddedOopRelocator(oop src_obj, address buffered_obj, CHeapBitMap* oopmap) :\n+    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap) {}\n@@ -523,1 +462,1 @@\n-    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset));\n+    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset), _oopmap);\n@@ -529,2 +468,1 @@\n-                                               GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                                               GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+                                               ArchiveHeapInfo* heap_info) {\n@@ -532,7 +470,2 @@\n-  size_t closed_region_byte_size = _closed_top - _closed_bottom;\n-  size_t open_region_byte_size   = _open_top   - _open_bottom;\n-  ResourceBitMap closed_oopmap(closed_region_byte_size \/ oopmap_unit);\n-  ResourceBitMap open_oopmap  (open_region_byte_size   \/ oopmap_unit);\n-\n-  _closed_oopmap = &closed_oopmap;\n-  _open_oopmap = &open_oopmap;\n+  size_t heap_region_byte_size = _buffer_used;\n+  heap_info->oopmap()->resize(heap_region_byte_size   \/ oopmap_unit);\n@@ -543,3 +476,1 @@\n-\n-    EmbeddedOopRelocator relocator(src_obj, buffered_obj);\n-\n+    EmbeddedOopRelocator relocator(src_obj, buffered_obj, heap_info->oopmap());\n@@ -553,1 +484,1 @@\n-  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_bottom);\n+  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_bottom_offset);\n@@ -558,1 +489,1 @@\n-      relocate_root_at<narrowOop>(requested_roots, i);\n+      relocate_root_at<narrowOop>(requested_roots, i, heap_info->oopmap());\n@@ -560,1 +491,1 @@\n-      relocate_root_at<oop>(requested_roots, i);\n+      relocate_root_at<oop>(requested_roots, i, heap_info->oopmap());\n@@ -564,35 +495,1 @@\n-  closed_bitmaps->append(make_bitmap_info(&closed_oopmap, \/*is_open=*\/false, \/*is_oopmap=*\/true));\n-  open_bitmaps  ->append(make_bitmap_info(&open_oopmap,   \/*is_open=*\/false, \/*is_oopmap=*\/true));\n-\n-  closed_bitmaps->append(compute_ptrmap(\/*is_open=*\/false));\n-  open_bitmaps  ->append(compute_ptrmap(\/*is_open=*\/true));\n-\n-  _closed_oopmap = nullptr;\n-  _open_oopmap = nullptr;\n-}\n-\n-ArchiveHeapBitmapInfo ArchiveHeapWriter::make_bitmap_info(ResourceBitMap* bitmap, bool is_open,  bool is_oopmap) {\n-  size_t size_in_bits = bitmap->size();\n-  size_t size_in_bytes;\n-  uintptr_t* buffer;\n-\n-  if (size_in_bits > 0) {\n-    size_in_bytes = bitmap->size_in_bytes();\n-    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n-    bitmap->write_to(buffer, size_in_bytes);\n-  } else {\n-    size_in_bytes = 0;\n-    buffer = nullptr;\n-  }\n-\n-  log_info(cds, heap)(\"%s @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for %s heap region\",\n-                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n-                      p2i(buffer), size_in_bytes,\n-                      is_open? \"open\" : \"closed\");\n-\n-  ArchiveHeapBitmapInfo info;\n-  info._map = (address)buffer;\n-  info._size_in_bits = size_in_bits;\n-  info._size_in_bytes = size_in_bytes;\n-\n-  return info;\n+  compute_ptrmap(heap_info);\n@@ -611,1 +508,1 @@\n-ArchiveHeapBitmapInfo ArchiveHeapWriter::compute_ptrmap(bool is_open) {\n+void ArchiveHeapWriter::compute_ptrmap(ArchiveHeapInfo* heap_info) {\n@@ -613,3 +510,3 @@\n-  Metadata** bottom = (Metadata**) (is_open ? _requested_open_region_bottom: _requested_closed_region_bottom);\n-  Metadata** top = (Metadata**) (is_open ? _requested_open_region_top: _requested_closed_region_top); \/\/ exclusive\n-  ResourceBitMap ptrmap(top - bottom);\n+  Metadata** bottom = (Metadata**) _requested_bottom;\n+  Metadata** top = (Metadata**) _requested_top; \/\/ exclusive\n+  heap_info->ptrmap()->resize(top - bottom);\n@@ -617,0 +514,1 @@\n+  BitMap::idx_t max_idx = 32; \/\/ paranoid - don't make it too small\n@@ -622,22 +520,21 @@\n-    if (p->in_open_region() == is_open) {\n-      \/\/ requested_field_addr = the address of this field in the requested space\n-      oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-      Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-      assert(bottom <= requested_field_addr && requested_field_addr < top, \"range check\");\n-\n-      \/\/ Mark this field in the bitmap\n-      BitMap::idx_t idx = requested_field_addr - bottom;\n-      ptrmap.set_bit(idx);\n-      num_non_null_ptrs ++;\n-\n-      \/\/ Set the native pointer to the requested address of the metadata (at runtime, the metadata will have\n-      \/\/ this address if the RO\/RW regions are mapped at the default location).\n-\n-      Metadata** buffered_field_addr = requested_addr_to_buffered_addr(requested_field_addr);\n-      Metadata* native_ptr = *buffered_field_addr;\n-      assert(native_ptr != nullptr, \"sanity\");\n-\n-      address buffered_native_ptr = ArchiveBuilder::current()->get_buffered_addr((address)native_ptr);\n-      address requested_native_ptr = ArchiveBuilder::current()->to_requested(buffered_native_ptr);\n-      *buffered_field_addr = (Metadata*)requested_native_ptr;\n-    }\n+    \/\/ requested_field_addr = the address of this field in the requested space\n+    oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+    Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+    assert(bottom <= requested_field_addr && requested_field_addr < top, \"range check\");\n+\n+    \/\/ Mark this field in the bitmap\n+    BitMap::idx_t idx = requested_field_addr - bottom;\n+    heap_info->ptrmap()->set_bit(idx);\n+    num_non_null_ptrs ++;\n+    max_idx = MAX2(max_idx, idx);\n+\n+    \/\/ Set the native pointer to the requested address of the metadata (at runtime, the metadata will have\n+    \/\/ this address if the RO\/RW regions are mapped at the default location).\n+\n+    Metadata** buffered_field_addr = requested_addr_to_buffered_addr(requested_field_addr);\n+    Metadata* native_ptr = *buffered_field_addr;\n+    assert(native_ptr != nullptr, \"sanity\");\n+\n+    address buffered_native_ptr = ArchiveBuilder::current()->get_buffered_addr((address)native_ptr);\n+    address requested_native_ptr = ArchiveBuilder::current()->to_requested(buffered_native_ptr);\n+    *buffered_field_addr = (Metadata*)requested_native_ptr;\n@@ -646,9 +543,3 @@\n-  log_info(cds, heap)(\"compute_ptrmap: marked %d non-null native pointers for %s heap region\",\n-                      num_non_null_ptrs, is_open ? \"open\" : \"closed\");\n-\n-  if (num_non_null_ptrs == 0) {\n-    ResourceBitMap empty;\n-    return make_bitmap_info(&empty, is_open, \/*is_oopmap=*\/ false);\n-  } else {\n-    return make_bitmap_info(&ptrmap, is_open, \/*is_oopmap=*\/ false);\n-  }\n+  heap_info->ptrmap()->resize(max_idx + 1);\n+  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers for heap region (\" SIZE_FORMAT \" bits)\",\n+                      num_non_null_ptrs, size_t(heap_info->ptrmap()->size()));\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":115,"deletions":224,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -577,4 +577,2 @@\n-    for (int cpcindex = 0; cpcindex < cpcache->length(); cpcindex ++) {\n-      int indy_index = ConstantPool::encode_invokedynamic_index(cpcindex);\n-      ConstantPoolCacheEntry* cpce = cpcache->entry_at(cpcindex);\n-      int pool_index = cpce->constant_pool_index();\n+    for (int indy_index = 0; indy_index < cpcache->resolved_indy_entries_length(); indy_index++) {\n+      int pool_index = cpcache->resolved_indy_entry_at(indy_index)->constant_pool_index();\n@@ -582,19 +580,20 @@\n-      if (pool->tag_at(pool_index).is_invoke_dynamic()) {\n-        BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n-        Handle bsm = bootstrap_specifier.resolve_bsm(CHECK);\n-        if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n-          log_debug(cds, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n-          continue;\n-        }\n-        bool matched = is_matching_cp_entry(pool, pool_index, CHECK);\n-        if (matched) {\n-          found = true;\n-          CallInfo info;\n-          bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, CHECK);\n-          if (!is_done) {\n-            \/\/ resolve it\n-            Handle recv;\n-            LinkResolver::resolve_invoke(info, recv, pool, indy_index, Bytecodes::_invokedynamic, CHECK);\n-            break;\n-          }\n-          cpce->set_dynamic_call(pool, info);\n+      BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n+      Handle bsm = bootstrap_specifier.resolve_bsm(CHECK);\n+      if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n+        log_debug(cds, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n+        continue;\n+      }\n+      bool matched = is_matching_cp_entry(pool, pool_index, CHECK);\n+      if (matched) {\n+        found = true;\n+        CallInfo info;\n+        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, CHECK);\n+        if (!is_done) {\n+          \/\/ resolve it\n+          Handle recv;\n+          LinkResolver::resolve_invoke(info,\n+                                       recv,\n+                                       pool,\n+                                       ConstantPool::encode_invokedynamic_index(indy_index),\n+                                       Bytecodes::_invokedynamic, CHECK);\n+          break;\n@@ -602,0 +601,1 @@\n+        cpcache->set_dynamic_call(info, indy_index);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -83,23 +83,0 @@\n-\/\/ Complain and stop. All error conditions occurring during the writing of\n-\/\/ an archive file should stop the process.  Unrecoverable errors during\n-\/\/ the reading of the archive file should stop the process.\n-\n-static void fail_exit(const char *msg, va_list ap) {\n-  \/\/ This occurs very early during initialization: tty is not initialized.\n-  jio_fprintf(defaultStream::error_stream(),\n-              \"An error has occurred while processing the\"\n-              \" shared archive file.\\n\");\n-  jio_vfprintf(defaultStream::error_stream(), msg, ap);\n-  jio_fprintf(defaultStream::error_stream(), \"\\n\");\n-  \/\/ Do not change the text of the below message because some tests check for it.\n-  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n-}\n-\n-\n-void FileMapInfo::fail_stop(const char *msg, ...) {\n-        va_list ap;\n-  va_start(ap, msg);\n-  fail_exit(msg, ap);   \/\/ Never returns.\n-  va_end(ap);           \/\/ for completeness.\n-}\n-\n@@ -437,1 +414,2 @@\n-    FileMapInfo::fail_stop(\"Unable to open file %s.\", cpe->name());\n+    log_error(cds)(\"Unable to open file %s.\", cpe->name());\n+    MetaspaceShared::unrecoverable_loading_error();\n@@ -1167,1 +1145,2 @@\n-        fail_stop(\"%s%s\", mismatch_msg, hint_msg);\n+        log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+        MetaspaceShared::unrecoverable_loading_error();\n@@ -1504,1 +1483,1 @@\n-  for (int i = 0; i <= MetaspaceShared::last_valid_region; i++) {\n+  for (int i = 0; i < MetaspaceShared::n_regions; i++) {\n@@ -1521,1 +1500,2 @@\n-    fail_stop(\"Unable to seek to position \" SIZE_FORMAT, pos);\n+    log_error(cds)(\"Unable to seek to position \" SIZE_FORMAT, pos);\n+    MetaspaceShared::unrecoverable_loading_error();\n@@ -1567,2 +1547,3 @@\n-    fail_stop(\"Unable to create shared archive file %s: (%s).\", _full_path,\n-              os::strerror(errno));\n+    log_error(cds)(\"Unable to create shared archive file %s: (%s).\", _full_path,\n+                   os::strerror(errno));\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -1608,3 +1589,4 @@\n-void FileMapRegion::init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap) {\n-  _oopmap_offset = oopmap._bm_region_offset;\n-  _oopmap_size_in_bits = oopmap._size_in_bits;\n+void FileMapRegion::init_oopmap(size_t offset, size_t size_in_bits) {\n+  _oopmap_offset = offset;\n+  _oopmap_size_in_bits = size_in_bits;\n+}\n@@ -1612,2 +1594,3 @@\n-  _ptrmap_offset = ptrmap._bm_region_offset;\n-  _ptrmap_size_in_bits = ptrmap._size_in_bits;\n+void FileMapRegion::init_ptrmap(size_t offset, size_t size_in_bits) {\n+  _ptrmap_offset = offset;\n+  _ptrmap_size_in_bits = size_in_bits;\n@@ -1652,1 +1635,1 @@\n-    \"rw\", \"ro\", \"bm\", \"ca0\", \"ca1\", \"oa0\", \"oa1\"\n+    \"rw\", \"ro\", \"bm\", \"hp\"\n@@ -1693,1 +1676,1 @@\n-    requested_base = (char*)ArchiveHeapWriter::heap_region_requested_bottom(region);\n+    requested_base = (char*)ArchiveHeapWriter::requested_address();\n@@ -1713,1 +1696,1 @@\n-    log_info(cds)(\"Shared file region (%-3s)  %d: \" SIZE_FORMAT_W(8)\n+    log_info(cds)(\"Shared file region (%s) %d: \" SIZE_FORMAT_W(8)\n@@ -1726,6 +1709,4 @@\n-size_t FileMapInfo::set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_size) {\n-  for (int i = 0; i < bitmaps->length(); i++) {\n-    bitmaps->at(i)._bm_region_offset = curr_size;\n-    curr_size += bitmaps->at(i)._size_in_bytes;\n-  }\n-  return curr_size;\n+static size_t write_bitmap(const CHeapBitMap* map, char* output, size_t offset) {\n+  size_t size_in_bytes = map->size_in_bytes();\n+  map->write_to((BitMap::bm_word_t*)(output + offset), size_in_bytes);\n+  return offset + size_in_bytes;\n@@ -1734,11 +1715,1 @@\n-size_t FileMapInfo::write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_offset, char* buffer) {\n-  for (int i = 0; i < bitmaps->length(); i++) {\n-    memcpy(buffer + curr_offset, bitmaps->at(i)._map, bitmaps->at(i)._size_in_bytes);\n-    curr_offset += bitmaps->at(i)._size_in_bytes;\n-  }\n-  return curr_offset;\n-}\n-\n-char* FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap,\n-                                       GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                                       GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n+char* FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n@@ -1746,1 +1717,0 @@\n-  size_t size_in_bits = ptrmap->size();\n@@ -1749,3 +1719,3 @@\n-  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n-    size_in_bytes = set_bitmaps_offset(closed_bitmaps, size_in_bytes);\n-    size_in_bytes = set_bitmaps_offset(open_bitmaps, size_in_bytes);\n+  if (heap_info->is_used()) {\n+    size_in_bytes += heap_info->oopmap()->size_in_bytes();\n+    size_in_bytes += heap_info->ptrmap()->size_in_bytes();\n@@ -1754,0 +1724,4 @@\n+  \/\/ The bitmap region contains up to 3 parts:\n+  \/\/ ptrmap:              metaspace pointers inside the ro\/rw regions\n+  \/\/ heap_info->oopmap(): Java oop pointers in the heap region\n+  \/\/ heap_info->ptrmap(): metaspace pointers in the heap region\n@@ -1755,2 +1729,6 @@\n-  ptrmap->write_to((BitMap::bm_word_t*)buffer, ptrmap->size_in_bytes());\n-  header()->set_ptrmap_size_in_bits(size_in_bits);\n+  size_t written = 0;\n+  written = write_bitmap(ptrmap, buffer, written);\n+  header()->set_ptrmap_size_in_bits(ptrmap->size());\n+\n+  if (heap_info->is_used()) {\n+    FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -1758,3 +1736,5 @@\n-  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n-    size_t curr_offset = write_bitmaps(closed_bitmaps, ptrmap->size_in_bytes(), buffer);\n-    write_bitmaps(open_bitmaps, curr_offset, buffer);\n+    r->init_oopmap(written, heap_info->oopmap()->size());\n+    written = write_bitmap(heap_info->oopmap(), buffer, written);\n+\n+    r->init_ptrmap(written, heap_info->ptrmap()->size());\n+    written = write_bitmap(heap_info->ptrmap(), buffer, written);\n@@ -1767,65 +1747,5 @@\n-\/\/ Write out the given archive heap memory regions.  GC code combines multiple\n-\/\/ consecutive archive GC regions into one MemRegion whenever possible and\n-\/\/ produces the 'regions' array.\n-\/\/\n-\/\/ If the archive heap memory size is smaller than a single dump time GC region\n-\/\/ size, there is only one MemRegion in the array.\n-\/\/\n-\/\/ If the archive heap memory size is bigger than one dump time GC region size,\n-\/\/ the 'regions' array may contain more than one consolidated MemRegions. When\n-\/\/ the first\/bottom archive GC region is a partial GC region (with the empty\n-\/\/ portion at the higher address within the region), one MemRegion is used for\n-\/\/ the bottom partial archive GC region. The rest of the consecutive archive\n-\/\/ GC regions are combined into another MemRegion.\n-\/\/\n-\/\/ Here's the mapping from (archive heap GC regions) -> (GrowableArray<MemRegion> *regions).\n-\/\/   + We have 1 or more archive heap regions: ah0, ah1, ah2 ..... ahn\n-\/\/   + We have 1 or 2 consolidated heap memory regions: r0 and r1\n-\/\/\n-\/\/ If there's a single archive GC region (ah0), then r0 == ah0, and r1 is empty.\n-\/\/ Otherwise:\n-\/\/\n-\/\/ \"X\" represented space that's occupied by heap objects.\n-\/\/ \"_\" represented unused spaced in the heap region.\n-\/\/\n-\/\/\n-\/\/    |ah0       | ah1 | ah2| ...... | ahn|\n-\/\/    |XXXXXX|__ |XXXXX|XXXX|XXXXXXXX|XXXX|\n-\/\/    |<-r0->|   |<- r1 ----------------->|\n-\/\/            ^^^\n-\/\/             |\n-\/\/             +-- gap\n-size_t FileMapInfo::write_heap_regions(GrowableArray<MemRegion>* regions,\n-                                       GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n-                                       int first_region_id, int max_num_regions) {\n-  assert(max_num_regions <= 2, \"Only support maximum 2 memory regions\");\n-\n-  int arr_len = regions == nullptr ? 0 : regions->length();\n-  if (arr_len > max_num_regions) {\n-    fail_stop(\"Unable to write archive heap memory regions: \"\n-              \"number of memory regions exceeds maximum due to fragmentation. \"\n-              \"Please increase java heap size \"\n-              \"(current MaxHeapSize is \" SIZE_FORMAT \", InitialHeapSize is \" SIZE_FORMAT \").\",\n-              MaxHeapSize, InitialHeapSize);\n-  }\n-\n-  size_t total_size = 0;\n-  for (int i = 0; i < max_num_regions; i++) {\n-    char* start = nullptr;\n-    size_t size = 0;\n-    if (i < arr_len) {\n-      start = (char*)regions->at(i).start();\n-      size = regions->at(i).byte_size();\n-      total_size += size;\n-    }\n-\n-    int region_idx = i + first_region_id;\n-    write_region(region_idx, start, size, false, false);\n-    if (size > 0) {\n-      int oopmap_idx = i * 2;\n-      int ptrmap_idx = i * 2 + 1;\n-      region_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n-                                          bitmaps->at(ptrmap_idx));\n-    }\n-  }\n-  return total_size;\n+size_t FileMapInfo::write_heap_region(ArchiveHeapInfo* heap_info) {\n+  char* start = heap_info->start();\n+  size_t size = heap_info->byte_size();\n+  write_region(MetaspaceShared::hp, start, size, false, false);\n+  return size;\n@@ -1843,1 +1763,1 @@\n-    fail_stop(\"Unable to write to shared archive file.\");\n+    MetaspaceShared::unrecoverable_writing_error(\"Unable to write to shared archive file.\");\n@@ -1884,1 +1804,1 @@\n-      fail_stop(\"Unable to close the shared archive file.\");\n+      MetaspaceShared::unrecoverable_loading_error(\"Unable to close the shared archive file.\");\n@@ -1924,2 +1844,1 @@\n-static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\",\n-                                            \"String1\", \"String2\", \"OpenArchive1\", \"OpenArchive2\" };\n+static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\", \"Heap\" };\n@@ -2146,7 +2065,4 @@\n-static MemRegion *closed_heap_regions = nullptr;\n-static MemRegion *open_heap_regions = nullptr;\n-static int num_closed_heap_regions = 0;\n-static int num_open_heap_regions = 0;\n-\n-bool FileMapInfo::has_heap_regions() {\n-  return (region_at(MetaspaceShared::first_closed_heap_region)->used() > 0);\n+MemRegion FileMapInfo::_mapped_heap_memregion;\n+\n+bool FileMapInfo::has_heap_region() {\n+  return (region_at(MetaspaceShared::hp)->used() > 0);\n@@ -2156,1 +2072,1 @@\n-\/\/ Returns the address range of the archived heap regions computed using the\n+\/\/ Returns the address range of the archived heap region computed using the\n@@ -2160,3 +2076,4 @@\n-MemRegion FileMapInfo::get_heap_regions_requested_range() {\n-  address start = (address) max_uintx;\n-  address end   = nullptr;\n+MemRegion FileMapInfo::get_heap_region_requested_range() {\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  size_t size = r->used();\n+  assert(size > 0, \"must have non-empty heap region\");\n@@ -2164,22 +2081,4 @@\n-  for (int i = MetaspaceShared::first_closed_heap_region;\n-           i <= MetaspaceShared::last_valid_region;\n-           i++) {\n-    FileMapRegion* r = region_at(i);\n-    size_t size = r->used();\n-    if (size > 0) {\n-      address s = heap_region_requested_address(r);\n-      address e = s + size;\n-      log_info(cds)(\"Heap region %s = \" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" = \"  SIZE_FORMAT_W(8) \" bytes\",\n-                    region_name(i), p2i(s), p2i(e), size);\n-      if (start > s) {\n-        start = s;\n-      }\n-      if (end < e) {\n-        end = e;\n-      }\n-    }\n-  }\n-  assert(end != nullptr, \"must have at least one used heap region\");\n-\n-  start = align_down(start, HeapRegion::GrainBytes);\n-  end = align_up(end, HeapRegion::GrainBytes);\n+  address start = heap_region_requested_address();\n+  address end = start + size;\n+  log_info(cds)(\"Requested heap region [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] = \"  SIZE_FORMAT_W(8) \" bytes\",\n+                p2i(start), p2i(end), size);\n@@ -2190,1 +2089,1 @@\n-void FileMapInfo::map_or_load_heap_regions() {\n+void FileMapInfo::map_or_load_heap_region() {\n@@ -2193,1 +2092,1 @@\n-  if (can_use_heap_regions()) {\n+  if (can_use_heap_region()) {\n@@ -2195,1 +2094,1 @@\n-      success = map_heap_regions();\n+      success = map_heap_region();\n@@ -2197,1 +2096,1 @@\n-      success = ArchiveHeapLoader::load_heap_regions(this);\n+      success = ArchiveHeapLoader::load_heap_region(this);\n@@ -2213,2 +2112,2 @@\n-bool FileMapInfo::can_use_heap_regions() {\n-  if (!has_heap_regions()) {\n+bool FileMapInfo::can_use_heap_region() {\n+  if (!has_heap_region()) {\n@@ -2260,1 +2159,2 @@\n-address FileMapInfo::heap_region_dumptime_address(FileMapRegion* r) {\n+address FileMapInfo::heap_region_dumptime_address() {\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -2262,1 +2162,0 @@\n-  r->assert_is_heap_region();\n@@ -2267,1 +2166,1 @@\n-    return heap_region_requested_address(r);\n+    return heap_region_requested_address();\n@@ -2273,1 +2172,1 @@\n-address FileMapInfo::heap_region_requested_address(FileMapRegion* r) {\n+address FileMapInfo::heap_region_requested_address() {\n@@ -2275,1 +2174,1 @@\n-  r->assert_is_heap_region();\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -2301,1 +2200,1 @@\n-address FileMapInfo::heap_region_mapped_address(FileMapRegion* r) {\n+address FileMapInfo::heap_region_mapped_address() {\n@@ -2303,2 +2202,1 @@\n-  r->assert_is_heap_region();\n-  return heap_region_requested_address(r) + ArchiveHeapLoader::mapped_heap_delta();\n+  return heap_region_requested_address() + ArchiveHeapLoader::mapped_heap_delta();\n@@ -2308,16 +2206,38 @@\n-\/\/\n-\/\/ Map the closed and open archive heap objects to the runtime java heap.\n-\/\/\n-\/\/ The shared objects are mapped at (or close to ) the java heap top in\n-\/\/ closed archive regions. The mapped objects contain no out-going\n-\/\/ references to any other java heap regions. GC does not write into the\n-\/\/ mapped closed archive heap region.\n-\/\/\n-\/\/ The open archive heap objects are mapped below the shared objects in\n-\/\/ the runtime java heap. The mapped open archive heap data only contains\n-\/\/ references to the shared objects and open archive objects initially.\n-\/\/ During runtime execution, out-going references to any other java heap\n-\/\/ regions may be added. GC may mark and update references in the mapped\n-\/\/ open archive objects.\n-void FileMapInfo::map_heap_regions_impl() {\n-  \/\/ G1 -- always map at the very top of the heap to avoid fragmentation.\n+bool FileMapInfo::map_heap_region() {\n+  init_heap_region_relocation();\n+\n+  if (_heap_pointers_need_patching) {\n+    char* bitmap_base = map_bitmap_region();\n+    if (bitmap_base == nullptr) {\n+      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n+      _heap_pointers_need_patching = false;\n+      return false;\n+    }\n+  }\n+\n+  if (map_heap_region_impl()) {\n+#ifdef ASSERT\n+    \/\/ The \"old\" regions must be parsable -- we cannot have any unused space\n+    \/\/ at the start of the lowest G1 region that contains archived objects.\n+    assert(is_aligned(_mapped_heap_memregion.start(), HeapRegion::GrainBytes), \"must be\");\n+\n+    \/\/ Make sure we map at the very top of the heap - see comments in\n+    \/\/ init_heap_region_relocation().\n+    MemRegion heap_range = G1CollectedHeap::heap()->reserved();\n+    assert(heap_range.contains(_mapped_heap_memregion), \"must be\");\n+\n+    address heap_end = (address)heap_range.end();\n+    address mapped_heap_region_end = (address)_mapped_heap_memregion.end();\n+    assert(heap_end >= mapped_heap_region_end, \"must be\");\n+    assert(heap_end - mapped_heap_region_end < (intx)(HeapRegion::GrainBytes),\n+           \"must be at the top of the heap to avoid fragmentation\");\n+#endif\n+\n+    ArchiveHeapLoader::set_mapped();\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void FileMapInfo::init_heap_region_relocation() {\n@@ -2328,1 +2248,1 @@\n-  MemRegion archive_range = get_heap_regions_requested_range();\n+  MemRegion archive_range = get_heap_region_requested_range();\n@@ -2330,0 +2250,1 @@\n+  address requested_bottom = (address)archive_range.start();\n@@ -2331,3 +2252,5 @@\n-  address archive_end = (address)archive_range.end();\n-\n-  assert(is_aligned(archive_end, HeapRegion::GrainBytes), \"must be\");\n+\n+  \/\/ We map the archive heap region at the very top of the heap to avoid fragmentation.\n+  \/\/ To do that, we make sure that the bottom of the archived region is at the same\n+  \/\/ address as the bottom of the highest possible G1 region.\n+  address mapped_bottom = heap_end - align_up(archive_range.byte_size(), HeapRegion::GrainBytes);\n@@ -2341,4 +2264,3 @@\n-  } else if (!heap_range.contains(archive_range)) {\n-    log_info(cds)(\"CDS heap data needs to be relocated because\");\n-    log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(archive_range.start()), p2i(archive_range.end()));\n-    log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(heap_range.start()), p2i(heap_range.end()));\n+  } else if (requested_bottom != mapped_bottom) {\n+    log_info(cds)(\"CDS heap data needs to be relocated because it is mapped at a different address @ \" INTPTR_FORMAT,\n+                  p2i(mapped_bottom));\n@@ -2346,6 +2268,0 @@\n-  } else {\n-    assert(heap_end >= archive_end, \"must be\");\n-    if (heap_end != archive_end) {\n-      log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n-      _heap_pointers_need_patching = true;\n-    }\n@@ -2356,1 +2272,1 @@\n-    delta = heap_end - archive_end;\n+    delta = mapped_bottom - requested_bottom;\n@@ -2360,46 +2276,0 @@\n-\n-  FileMapRegion* r = region_at(MetaspaceShared::first_closed_heap_region);\n-  address relocated_closed_heap_region_bottom = heap_region_requested_address(r) + delta;\n-\n-  if (!is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes)) {\n-    \/\/ Align the bottom of the closed archive heap regions at G1 region boundary.\n-    \/\/ This will avoid the situation where the highest open region and the lowest\n-    \/\/ closed region sharing the same G1 region. Otherwise we will fail to map the\n-    \/\/ open regions.\n-    size_t align = size_t(relocated_closed_heap_region_bottom) % HeapRegion::GrainBytes;\n-    delta -= align;\n-    log_info(cds)(\"CDS heap data needs to be relocated lower by a further \" SIZE_FORMAT\n-                  \" bytes to \" INTX_FORMAT \" to be aligned with HeapRegion::GrainBytes\",\n-                  align, delta);\n-    _heap_pointers_need_patching = true;\n-  }\n-\n-  relocated_closed_heap_region_bottom = heap_region_mapped_address(r);\n-\n-  assert(is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes),\n-         \"must be\");\n-\n-  if (_heap_pointers_need_patching) {\n-    char* bitmap_base = map_bitmap_region();\n-    if (bitmap_base == nullptr) {\n-      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n-      _heap_pointers_need_patching = false;\n-      return;\n-    }\n-  }\n-\n-  \/\/ Map the closed heap regions: GC does not write into these regions.\n-  if (map_heap_regions(MetaspaceShared::first_closed_heap_region,\n-                       MetaspaceShared::max_num_closed_heap_regions,\n-                       \/*is_open_archive=*\/ false,\n-                       &closed_heap_regions, &num_closed_heap_regions)) {\n-    ArchiveHeapLoader::set_closed_regions_mapped();\n-\n-    \/\/ Now, map the open heap regions: GC can write into these regions.\n-    if (map_heap_regions(MetaspaceShared::first_open_heap_region,\n-                         MetaspaceShared::max_num_open_heap_regions,\n-                         \/*is_open_archive=*\/ true,\n-                         &open_heap_regions, &num_open_heap_regions)) {\n-      ArchiveHeapLoader::set_open_regions_mapped();\n-    }\n-  }\n@@ -2409,7 +2279,3 @@\n-bool FileMapInfo::map_heap_regions() {\n-  map_heap_regions_impl();\n-\n-  if (!ArchiveHeapLoader::closed_regions_mapped()) {\n-    assert(closed_heap_regions == nullptr &&\n-           num_closed_heap_regions == 0, \"sanity\");\n-  }\n+bool FileMapInfo::map_heap_region_impl() {\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  size_t size = r->used();\n@@ -2417,3 +2283,5 @@\n-  if (!ArchiveHeapLoader::open_regions_mapped()) {\n-    assert(open_heap_regions == nullptr && num_open_heap_regions == 0, \"sanity\");\n-    return false;\n+  if (size > 0) {\n+    HeapWord* start = (HeapWord*)heap_region_mapped_address();\n+    _mapped_heap_memregion = MemRegion(start, size \/ HeapWordSize);\n+    log_info(cds)(\"Trying to map heap data at \" INTPTR_FORMAT \", size = \" SIZE_FORMAT_W(8) \" bytes\",\n+                  p2i(start), size);\n@@ -2421,33 +2289,0 @@\n-    return true;\n-  }\n-}\n-\n-bool FileMapInfo::map_heap_regions(int first, int max,  bool is_open_archive,\n-                                   MemRegion** regions_ret, int* num_regions_ret) {\n-  MemRegion* regions = MemRegion::create_array(max, mtInternal);\n-\n-  struct Cleanup {\n-    MemRegion* _regions;\n-    uint _length;\n-    bool _aborted;\n-    Cleanup(MemRegion* regions, uint length) : _regions(regions), _length(length), _aborted(true) { }\n-    ~Cleanup() { if (_aborted) { MemRegion::destroy_array(_regions, _length); } }\n-  } cleanup(regions, max);\n-\n-  FileMapRegion* r;\n-  int num_regions = 0;\n-\n-  for (int i = first;\n-           i < first + max; i++) {\n-    r = region_at(i);\n-    size_t size = r->used();\n-    if (size > 0) {\n-      HeapWord* start = (HeapWord*)heap_region_mapped_address(r);\n-      regions[num_regions] = MemRegion(start, size \/ HeapWordSize);\n-      num_regions ++;\n-      log_info(cds)(\"Trying to map heap data: region[%d] at \" INTPTR_FORMAT \", size = \" SIZE_FORMAT_W(8) \" bytes\",\n-                    i, p2i(start), size);\n-    }\n-  }\n-\n-  if (num_regions == 0) {\n@@ -2457,2 +2292,2 @@\n-  \/\/ Check that regions are within the java heap\n-  if (!G1CollectedHeap::heap()->check_archive_addresses(regions, num_regions)) {\n+  \/\/ Check that the region is within the java heap\n+  if (!G1CollectedHeap::heap()->check_archive_addresses(_mapped_heap_memregion)) {\n@@ -2464,2 +2299,1 @@\n-  if (!G1CollectedHeap::heap()->alloc_archive_regions(\n-             regions, num_regions, is_open_archive)) {\n+  if (!G1CollectedHeap::heap()->alloc_archive_regions(_mapped_heap_memregion)) {\n@@ -2471,24 +2305,11 @@\n-  \/\/ for mapped regions as they are part of the reserved java heap, which is\n-  \/\/ already recorded.\n-  for (int i = 0; i < num_regions; i++) {\n-    r = region_at(first + i);\n-    char* addr = (char*)regions[i].start();\n-    char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n-                                addr, regions[i].byte_size(), r->read_only(),\n-                                r->allow_exec());\n-    if (base == nullptr || base != addr) {\n-      \/\/ dealloc the regions from java heap\n-      dealloc_heap_regions(regions, num_regions);\n-      log_info(cds)(\"Unable to map at required address in java heap. \"\n-                    INTPTR_FORMAT \", size = \" SIZE_FORMAT \" bytes\",\n-                    p2i(addr), regions[i].byte_size());\n-      return false;\n-    }\n-\n-    r->set_mapped_base(base);\n-    if (VerifySharedSpaces && !r->check_region_crc()) {\n-      \/\/ dealloc the regions from java heap\n-      dealloc_heap_regions(regions, num_regions);\n-      log_info(cds)(\"mapped heap regions are corrupt\");\n-      return false;\n-    }\n+  \/\/ for mapped region as it is part of the reserved java heap, which is already recorded.\n+  char* addr = (char*)_mapped_heap_memregion.start();\n+  char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n+                              addr, _mapped_heap_memregion.byte_size(), r->read_only(),\n+                              r->allow_exec());\n+  if (base == nullptr || base != addr) {\n+    dealloc_heap_region();\n+    log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+                  INTPTR_FORMAT \", size = \" SIZE_FORMAT \" bytes\",\n+                  p2i(addr), _mapped_heap_memregion.byte_size());\n+    return false;\n@@ -2497,10 +2318,5 @@\n-  cleanup._aborted = false;\n-  \/\/ the shared heap data is mapped successfully\n-  *regions_ret = regions;\n-  *num_regions_ret = num_regions;\n-  return true;\n-}\n-\n-void FileMapInfo::patch_heap_embedded_pointers() {\n-  if (!_heap_pointers_need_patching) {\n-    return;\n+  r->set_mapped_base(base);\n+  if (VerifySharedSpaces && !r->check_region_crc()) {\n+    dealloc_heap_region();\n+    log_info(cds)(\"mapped heap region is corrupt\");\n+    return false;\n@@ -2509,7 +2325,1 @@\n-  patch_heap_embedded_pointers(closed_heap_regions,\n-                               num_closed_heap_regions,\n-                               MetaspaceShared::first_closed_heap_region);\n-\n-  patch_heap_embedded_pointers(open_heap_regions,\n-                               num_open_heap_regions,\n-                               MetaspaceShared::first_open_heap_region);\n+  return true;\n@@ -2518,1 +2328,1 @@\n-narrowOop FileMapInfo::encoded_heap_region_dumptime_address(FileMapRegion* r) {\n+narrowOop FileMapInfo::encoded_heap_region_dumptime_address() {\n@@ -2521,1 +2331,1 @@\n-  r->assert_is_heap_region();\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -2525,2 +2335,5 @@\n-void FileMapInfo::patch_heap_embedded_pointers(MemRegion* regions, int num_regions,\n-                                               int first_region_idx) {\n+void FileMapInfo::patch_heap_embedded_pointers() {\n+  if (!ArchiveHeapLoader::is_mapped() || !_heap_pointers_need_patching) {\n+    return;\n+  }\n+\n@@ -2529,5 +2342,3 @@\n-  for (int i=0; i<num_regions; i++) {\n-    int region_idx = i + first_region_idx;\n-    FileMapRegion* r = region_at(region_idx);\n-    ArchiveHeapLoader::patch_embedded_pointers(\n-      this, r, regions[i],\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  ArchiveHeapLoader::patch_embedded_pointers(\n+      this, _mapped_heap_memregion,\n@@ -2537,1 +2348,0 @@\n-  }\n@@ -2540,25 +2350,5 @@\n-\/\/ This internally allocates objects using vmClasses::Object_klass(), so it\n-\/\/ must be called after the Object_klass is loaded\n-void FileMapInfo::fixup_mapped_heap_regions() {\n-  assert(vmClasses::Object_klass_loaded(), \"must be\");\n-  \/\/ If any closed regions were found, call the fill routine to make them parseable.\n-  \/\/ Note that closed_heap_regions may be non-null even if no regions were found.\n-  if (num_closed_heap_regions != 0) {\n-    assert(closed_heap_regions != nullptr,\n-           \"Null closed_heap_regions array with non-zero count\");\n-    G1CollectedHeap::heap()->fill_archive_regions(closed_heap_regions,\n-                                                  num_closed_heap_regions);\n-    \/\/ G1 marking uses the BOT for object chunking during marking in\n-    \/\/ G1CMObjArrayProcessor::process_slice(); for this reason we need to\n-    \/\/ initialize the BOT for closed archive regions too.\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(closed_heap_regions,\n-                                                               num_closed_heap_regions);\n-  }\n-\n-  \/\/ do the same for mapped open archive heap regions\n-  if (num_open_heap_regions != 0) {\n-    assert(open_heap_regions != nullptr, \"Null open_heap_regions array with non-zero count\");\n-    G1CollectedHeap::heap()->fill_archive_regions(open_heap_regions,\n-                                                  num_open_heap_regions);\n-\n-    \/\/ Populate the open archive regions' G1BlockOffsetTableParts. That ensures\n+void FileMapInfo::fixup_mapped_heap_region() {\n+  if (ArchiveHeapLoader::is_mapped()) {\n+    assert(!_mapped_heap_memregion.is_empty(), \"sanity\");\n+\n+    \/\/ Populate the archive regions' G1BlockOffsetTableParts. That ensures\n@@ -2566,1 +2356,1 @@\n-    \/\/ within the open archive regions when trying to find start of an object\n+    \/\/ within the archive regions when trying to find start of an object\n@@ -2568,2 +2358,1 @@\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(open_heap_regions,\n-                                                               num_open_heap_regions);\n+    G1CollectedHeap::heap()->populate_archive_regions_bot_part(_mapped_heap_memregion);\n@@ -2574,5 +2363,2 @@\n-void FileMapInfo::dealloc_heap_regions(MemRegion* regions, int num) {\n-  if (num > 0) {\n-    assert(regions != nullptr, \"Null archive regions array with non-zero count\");\n-    G1CollectedHeap::heap()->dealloc_archive_regions(regions, num);\n-  }\n+void FileMapInfo::dealloc_heap_region() {\n+  G1CollectedHeap::heap()->dealloc_archive_regions(_mapped_heap_memregion);\n@@ -2611,1 +2397,1 @@\n-    fail_stop(\"Mark mismatch while restoring from shared file.\");\n+    MetaspaceShared::unrecoverable_loading_error(\"Mark mismatch while restoring from shared file.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":174,"deletions":388,"binary":false,"changes":562,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class ArchiveHeapInfo;\n@@ -108,7 +109,0 @@\n-struct ArchiveHeapBitmapInfo {\n-  address _map;               \/\/ bitmap for relocating embedded oops\n-  size_t  _bm_region_offset;  \/\/ this bitmap is stored at this offset from the bottom of the BM region\n-  size_t  _size_in_bits;\n-  size_t  _size_in_bytes;\n-};\n-\n@@ -177,1 +171,2 @@\n-  void init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap);\n+  void init_oopmap(size_t offset, size_t size_in_bits);\n+  void init_ptrmap(size_t offset, size_t size_in_bits);\n@@ -488,3 +483,1 @@\n-  char* write_bitmap_region(const CHeapBitMap* ptrmap,\n-                            GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                            GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n+  char* write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n@@ -492,3 +485,1 @@\n-  size_t write_heap_regions(GrowableArray<MemRegion>* regions,\n-                            GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n-                            int first_region_id, int max_num_regions);\n+  size_t write_heap_region(ArchiveHeapInfo* heap_info);\n@@ -501,2 +492,2 @@\n-  void  map_or_load_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n-  void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  map_or_load_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  fixup_mapped_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -504,4 +495,2 @@\n-  void  patch_heap_embedded_pointers(MemRegion* regions, int num_regions,\n-                                     int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;\n-  bool  has_heap_regions()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  MemRegion get_heap_regions_requested_range() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n+  bool  has_heap_region()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  MemRegion get_heap_region_requested_range() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n@@ -519,2 +508,0 @@\n-  \/\/ Errors.\n-  static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);\n@@ -605,7 +592,6 @@\n-  bool  map_heap_regions(int first, int max, bool is_open_archive,\n-                         MemRegion** regions_ret, int* num_regions_ret) NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  void  dealloc_heap_regions(MemRegion* regions, int num) NOT_CDS_JAVA_HEAP_RETURN;\n-  bool  can_use_heap_regions();\n-  bool  load_heap_regions() NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  bool  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;\n+  bool  map_heap_region_impl() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  void  dealloc_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n+  bool  can_use_heap_region();\n+  bool  load_heap_region() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  bool  map_heap_region() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  void  init_heap_region_relocation();\n@@ -614,2 +600,2 @@\n-  static size_t set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_size);\n-  static size_t write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_offset, char* buffer);\n+\n+  static MemRegion _mapped_heap_memregion;\n@@ -618,4 +604,4 @@\n-  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  narrowOop encoded_heap_region_dumptime_address(FileMapRegion* r);\n+  address heap_region_dumptime_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_requested_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_mapped_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  narrowOop encoded_heap_region_dumptime_address();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -103,6 +103,1 @@\n-\/\/\n-\/\/     ca0 - closed archive heap space #0\n-\/\/     ca1 - closed archive heap space #1 (may be empty)\n-\/\/     oa0 - open archive heap space #0\n-\/\/     oa1 - open archive heap space #1 (may be empty)\n-\/\/\n+\/\/     hp  - heap region\n@@ -124,2 +119,3 @@\n-\/\/ The ca0\/ca1 and oa0\/oa1 regions are populated inside HeapShared::archive_objects.\n-\/\/ Their layout is independent of the rw\/ro regions.\n+\/\/ The heap region is populated by HeapShared::archive_objects.\n+\/\/\n+\/\/ The bitmap region is used to relocate the ro\/rw\/hp regions.\n@@ -272,2 +268,2 @@\n-    vm_exit_during_initialization(\"Unable to reserve memory for symbols\",\n-                                  err_msg(SIZE_FORMAT \" bytes.\", symbol_rs_size));\n+    log_error(cds)(\"Unable to reserve memory for symbols: \" SIZE_FORMAT \" bytes.\", symbol_rs_size);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -314,1 +310,2 @@\n-      vm_exit_during_initialization(err_msg(\"string length too large: %d\", utf8_length));\n+      log_error(cds)(\"string length too large: %d\", utf8_length);\n+      MetaspaceShared::unrecoverable_loading_error();\n@@ -435,5 +432,1 @@\n-  GrowableArray<MemRegion> *_closed_heap_regions;\n-  GrowableArray<MemRegion> *_open_heap_regions;\n-\n-  GrowableArray<ArchiveHeapBitmapInfo> *_closed_heap_bitmaps;\n-  GrowableArray<ArchiveHeapBitmapInfo> *_open_heap_bitmaps;\n+  ArchiveHeapInfo _heap_info;\n@@ -450,5 +443,1 @@\n-  VM_PopulateDumpSharedSpace() : VM_Operation(),\n-    _closed_heap_regions(nullptr),\n-    _open_heap_regions(nullptr),\n-    _closed_heap_bitmaps(nullptr),\n-    _open_heap_bitmaps(nullptr) {}\n+  VM_PopulateDumpSharedSpace() : VM_Operation(), _heap_info() {}\n@@ -554,5 +543,1 @@\n-  builder.write_archive(mapinfo,\n-                        _closed_heap_regions,\n-                        _open_heap_regions,\n-                        _closed_heap_bitmaps,\n-                        _open_heap_bitmaps);\n+  builder.write_archive(mapinfo, &_heap_info);\n@@ -569,4 +554,1 @@\n-  \/\/ There may be pending VM operations. We have changed some global states\n-  \/\/ (such as vmClasses::_klasses) that may cause these VM operations\n-  \/\/ to fail. For safety, forget these operations and exit the VM directly.\n-  os::_exit(0);\n+  MetaspaceShared::exit_after_static_dump();\n@@ -682,2 +664,3 @@\n-      vm_direct_exit(-1,  err_msg(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n-                                  SIZE_FORMAT \"M\", MaxHeapSize\/M));\n+      log_error(cds)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                     SIZE_FORMAT \"M\", MaxHeapSize\/M);\n+      MetaspaceShared::unrecoverable_writing_error();\n@@ -687,1 +670,1 @@\n-      vm_direct_exit(-1, \"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+      MetaspaceShared::unrecoverable_writing_error(\"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n@@ -806,0 +789,1 @@\n+  StringTable::allocate_shared_strings_array(CHECK);\n@@ -843,0 +827,1 @@\n+    ik->compute_has_loops_flag_for_methods();\n@@ -878,8 +863,1 @@\n-  \/\/ The closed and open archive heap space has maximum two regions.\n-  \/\/ See FileMapInfo::write_heap_regions() for details.\n-  _closed_heap_regions = new GrowableArray<MemRegion>(2);\n-  _open_heap_regions = new GrowableArray<MemRegion>(2);\n-  _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n-  _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n-  HeapShared::archive_objects(_closed_heap_regions, _open_heap_regions,\n-                              _closed_heap_bitmaps, _open_heap_bitmaps);\n+  HeapShared::archive_objects(&_heap_info);\n@@ -906,0 +884,31 @@\n+\/\/ This function is called when the JVM is unable to load the specified archive(s) due to one\n+\/\/ of the following conditions.\n+\/\/ - There's an error that indicates that the archive(s) files were corrupt or otherwise damaged.\n+\/\/ - When -XX:+RequireSharedSpaces is specified, AND the JVM cannot load the archive(s) due\n+\/\/   to version or classpath mismatch.\n+void MetaspaceShared::unrecoverable_loading_error(const char* message) {\n+  log_error(cds)(\"An error has occurred while processing the shared archive file.\");\n+  if (message != nullptr) {\n+    log_error(cds)(\"%s\", message);\n+  }\n+  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n+}\n+\n+\/\/ This function is called when the JVM is unable to write the specified CDS archive due to an\n+\/\/ unrecoverable error.\n+void MetaspaceShared::unrecoverable_writing_error(const char* message) {\n+  log_error(cds)(\"An error has occurred while writing the shared archive file.\");\n+  if (message != nullptr) {\n+    log_error(cds)(\"%s\", message);\n+  }\n+  vm_direct_exit(1);\n+}\n+\n+\/\/ We have finished dumping the static archive. At this point, there may be pending VM\n+\/\/ operations. We have changed some global states (such as vmClasses::_klasses) that\n+\/\/ may cause these VM operations to fail. For safety, forget these operations and\n+\/\/ exit the VM directly.\n+void MetaspaceShared::exit_after_static_dump() {\n+  os::_exit(0);\n+}\n+\n@@ -954,1 +963,1 @@\n-      vm_exit_during_initialization(\"Unable to use shared archive.\");\n+      MetaspaceShared::unrecoverable_loading_error(\"Unable to use shared archive.\");\n@@ -956,1 +965,1 @@\n-      FileMapInfo::fail_stop(\"Unable to map shared spaces\");\n+      MetaspaceShared::unrecoverable_loading_error(\"Unable to map shared spaces\");\n@@ -971,1 +980,1 @@\n-      FileMapInfo::fail_stop(\"Unable to map shared spaces\");\n+      MetaspaceShared::unrecoverable_loading_error(\"Unable to map shared spaces\");\n@@ -999,1 +1008,1 @@\n-      FileMapInfo::fail_stop(\"Failed to initialize dynamic archive\");\n+      MetaspaceShared::unrecoverable_loading_error(\"Failed to initialize dynamic archive\");\n@@ -1150,1 +1159,1 @@\n-          \/\/ map_heap_regions() compares the current narrow oop and klass encodings\n+          \/\/ map_or_load_heap_region() compares the current narrow oop and klass encodings\n@@ -1152,1 +1161,1 @@\n-          static_mapinfo->map_or_load_heap_regions();\n+          static_mapinfo->map_or_load_heap_region();\n@@ -1442,3 +1451,0 @@\n-  \/\/ Initialize the run-time symbol table.\n-  SymbolTable::create_table();\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":56,"deletions":50,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -519,12 +519,3 @@\n-  Klass* found_klass;\n-  {\n-    ttyUnlocker ttyul;  \/\/ release tty lock to avoid ordering problems\n-    MutexLocker ml(current, Compile_lock);\n-    Klass* kls;\n-    if (!require_local) {\n-      kls = SystemDictionary::find_constrained_instance_or_array_klass(current, sym, loader);\n-    } else {\n-      kls = SystemDictionary::find_instance_or_array_klass(current, sym, loader, domain);\n-    }\n-    found_klass = kls;\n-  }\n+  Klass* found_klass = require_local ?\n+                         SystemDictionary::find_instance_or_array_klass(current, sym, loader, domain) :\n+                         SystemDictionary::find_constrained_instance_or_array_klass(current, sym, loader);\n@@ -906,2 +897,0 @@\n-    ConstantPoolCacheEntry* cpce = cpool->invokedynamic_cp_cache_entry_at(index);\n-    bool is_resolved = !cpce->is_f1_null();\n@@ -915,5 +904,6 @@\n-\n-    if (is_resolved) {\n-      \/\/ Get the invoker Method* from the constant pool.\n-      \/\/ (The appendix argument, if any, will be noted in the method's signature.)\n-      Method* adapter = cpce->f1_as_method();\n+    int indy_index = cpool->decode_invokedynamic_index(index);\n+    assert (indy_index >= 0, \"should be\");\n+    assert(indy_index < cpool->cache()->resolved_indy_entries_length(), \"impossible\");\n+    Method* adapter = cpool->resolved_indy_entry_at(indy_index)->method();\n+    \/\/ Resolved if the adapter is non null.\n+    if (adapter != nullptr) {\n@@ -1102,1 +1092,1 @@\n-    \/\/ Prevent SystemDictionary::add_to_hierarchy from running\n+    \/\/ Prevent InstanceKlass::add_to_hierarchy from running\n@@ -1552,2 +1542,3 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(indy_index);\n-  if (cp_cache_entry->is_resolved(Bytecodes::_invokedynamic)) {\n+  int index = cp->decode_invokedynamic_index(indy_index);\n+  ResolvedIndyEntry* indy_info = cp->resolved_indy_entry_at(index);\n+  if (indy_info->method() != nullptr) {\n@@ -1555,1 +1546,1 @@\n-    Method* adapter = cp_cache_entry->f1_as_method();\n+    Method* adapter = indy_info->method();\n@@ -1558,1 +1549,1 @@\n-    oop appendix = cp_cache_entry->appendix_if_resolved(cp);\n+    oop appendix = cp->resolved_reference_from_indy(index);\n@@ -1564,2 +1555,2 @@\n-    int pool_index = cp_cache_entry->constant_pool_index();\n-    BootstrapInfo bootstrap_specifier(cp, pool_index, indy_index);\n+    int pool_index = indy_info->constant_pool_index();\n+    BootstrapInfo bootstrap_specifier(cp, pool_index, index);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -669,4 +669,4 @@\n-      MutexLocker ml(Compile_lock);\n-      Klass* k = get_instanceKlass()->implementor();\n-      if (k != nullptr) {\n-        if (k == get_instanceKlass()) {\n+      InstanceKlass* ik = get_instanceKlass();\n+      Klass* implk = ik->implementor();\n+      if (implk != nullptr) {\n+        if (implk == ik) {\n@@ -676,1 +676,1 @@\n-          impl = CURRENT_THREAD_ENV->get_instance_klass(k);\n+          impl = CURRENT_THREAD_ENV->get_instance_klass(implk);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -414,0 +414,9 @@\n+\n+      \/\/ ResolvedIndyEntry and ConstantPoolCacheEntry must currently coexist.\n+      \/\/ To address this, the variables below contain the values that *might*\n+      \/\/ be used to avoid multiple blocks of similar code. When CPCE is obsoleted\n+      \/\/ these can be removed\n+      oop appendix = nullptr;\n+      Method* adapter_method = nullptr;\n+      int pool_index = 0;\n+\n@@ -415,2 +424,6 @@\n-        cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(index);\n-        cp_cache_entry->set_dynamic_call(cp, callInfo);\n+        index = cp->decode_invokedynamic_index(index);\n+        cp->cache()->set_dynamic_call(callInfo, index);\n+\n+        appendix = cp->resolved_reference_from_indy(index);\n+        adapter_method = cp->resolved_indy_entry_at(index)->method();\n+        pool_index = cp->resolved_indy_entry_at(index)->constant_pool_index();\n@@ -425,0 +438,4 @@\n+\n+        appendix = cp_cache_entry->appendix_if_resolved(cp);\n+        adapter_method = cp_cache_entry->f1_as_method();\n+        pool_index = cp_cache_entry->constant_pool_index();\n@@ -431,1 +448,1 @@\n-        obj = cp_cache_entry->appendix_if_resolved(cp);\n+        obj = appendix;\n@@ -437,1 +454,1 @@\n-        Method* adapter = cp_cache_entry->f1_as_method();\n+        Method* adapter = adapter_method;\n@@ -444,1 +461,0 @@\n-        int pool_index = cp_cache_entry->constant_pool_index();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -813,11 +813,1 @@\n-  NameSigHash*  _next;             \/\/ Next entry in hash table\n-};\n-\n-static const int HASH_ROW_SIZE = 256;\n-static unsigned int hash(const Symbol* name, const Symbol* sig) {\n-  unsigned int raw_hash = 0;\n-  raw_hash += ((unsigned int)(uintptr_t)name) >> (LogHeapWordSize + 2);\n-  raw_hash += ((unsigned int)(uintptr_t)sig) >> LogHeapWordSize;\n-\n-  return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;\n-}\n+  static const int HASH_ROW_SIZE = 256;\n@@ -826,0 +816,3 @@\n+  NameSigHash(Symbol* name, Symbol* sig) :\n+    _name(name),\n+    _sig(sig) {}\n@@ -827,19 +820,2 @@\n-static void initialize_hashtable(NameSigHash** table) {\n-  memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);\n-}\n-\/\/ Return false if the name\/sig combination is found in table.\n-\/\/ Return true if no duplicate is found. And name\/sig is added as a new entry in table.\n-\/\/ The old format checker uses heap sort to find duplicates.\n-\/\/ NOTE: caller should guarantee that GC doesn't happen during the life cycle\n-\/\/ of table since we don't expect Symbol*'s to move.\n-static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {\n-  assert(name != nullptr, \"name in constant pool is null\");\n-\n-  \/\/ First lookup for duplicates\n-  int index = hash(name, sig);\n-  NameSigHash* entry = table[index];\n-  while (entry != nullptr) {\n-    if (entry->_name == name && entry->_sig == sig) {\n-      return false;\n-    }\n-    entry = entry->_next;\n+  static unsigned int hash(NameSigHash const& namesig) {\n+    return namesig._name->identity_hash() ^ namesig._sig->identity_hash();\n@@ -848,8 +824,5 @@\n-  \/\/ No duplicate is found, allocate a new entry and fill it.\n-  entry = new NameSigHash();\n-  entry->_name = name;\n-  entry->_sig = sig;\n-\n-  \/\/ Insert into hash table\n-  entry->_next = table[index];\n-  table[index] = entry;\n+  static bool equals(NameSigHash const& e0, NameSigHash const& e1) {\n+    return (e0._name == e1._name) &&\n+          (e0._sig  == e1._sig);\n+  }\n+};\n@@ -857,2 +830,4 @@\n-  return true;\n-}\n+using NameSigHashtable = ResourceHashtable<NameSigHash, int,\n+                                           NameSigHash::HASH_ROW_SIZE,\n+                                           AnyObj::RESOURCE_AREA, mtInternal,\n+                                           &NameSigHash::hash, &NameSigHash::equals>;\n@@ -926,15 +901,9 @@\n-    NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                                                 NameSigHash*,\n-                                                                 HASH_ROW_SIZE);\n-    initialize_hashtable(interface_names);\n-    bool dup = false;\n-    const Symbol* name = nullptr;\n-    {\n-      debug_only(NoSafepointVerifier nsv;)\n-      for (index = 0; index < itfs_len; index++) {\n-        name = cp->klass_name_at(_local_interface_indexes->at(index));\n-        \/\/ If no duplicates, add (name, nullptr) in hashtable interface_names.\n-        if (!put_after_lookup(name, nullptr, interface_names)) {\n-          dup = true;\n-          break;\n-        }\n+    \/\/ Set containing interface names\n+    ResourceHashtable<Symbol*, int>* interface_names = new ResourceHashtable<Symbol*, int>();\n+    for (index = 0; index < itfs_len; index++) {\n+      Symbol* interface_name = cp->klass_name_at(_local_interface_indexes->at(index));\n+      \/\/ If no duplicates, add (name, nullptr) in hashtable interface_names.\n+      if (!interface_names->put(interface_name, 0)) {\n+        classfile_parse_error(\"Duplicate interface name \\\"%s\\\" in class file %s\",\n+                               interface_name->as_C_string(), THREAD);\n+        return;\n@@ -943,4 +912,0 @@\n-    if (dup) {\n-      classfile_parse_error(\"Duplicate interface name \\\"%s\\\" in class file %s\",\n-                             name->as_C_string(), THREAD);\n-    }\n@@ -1722,16 +1687,10 @@\n-    NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(\n-      THREAD, NameSigHash*, HASH_ROW_SIZE);\n-    initialize_hashtable(names_and_sigs);\n-    bool dup = false;\n-    const Symbol* name = nullptr;\n-    const Symbol* sig = nullptr;\n-    {\n-      debug_only(NoSafepointVerifier nsv;)\n-      for (int i = 0; i < _temp_field_info->length(); i++) {\n-        name = _temp_field_info->adr_at(i)->name(_cp);\n-        sig = _temp_field_info->adr_at(i)->signature(_cp);\n-        \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n-        if (!put_after_lookup(name, sig, names_and_sigs)) {\n-          dup = true;\n-          break;\n-        }\n+    \/\/ Set containing name-signature pairs\n+    NameSigHashtable* names_and_sigs = new NameSigHashtable();\n+    for (int i = 0; i < _temp_field_info->length(); i++) {\n+      NameSigHash name_and_sig(_temp_field_info->adr_at(i)->name(_cp),\n+                               _temp_field_info->adr_at(i)->signature(_cp));\n+      \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n+      if(!names_and_sigs->put(name_and_sig, 0)) {\n+        classfile_parse_error(\"Duplicate field name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n+                               name_and_sig._name->as_C_string(), name_and_sig._sig->as_klass_external_name(), THREAD);\n+        return;\n@@ -1740,4 +1699,0 @@\n-    if (dup) {\n-      classfile_parse_error(\"Duplicate field name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n-                             name->as_C_string(), sig->as_klass_external_name(), THREAD);\n-    }\n@@ -3037,17 +2992,10 @@\n-      NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(\n-        THREAD, NameSigHash*, HASH_ROW_SIZE);\n-      initialize_hashtable(names_and_sigs);\n-      bool dup = false;\n-      const Symbol* name = nullptr;\n-      const Symbol* sig = nullptr;\n-      {\n-        debug_only(NoSafepointVerifier nsv;)\n-        for (int i = 0; i < length; i++) {\n-          const Method* const m = _methods->at(i);\n-          name = m->name();\n-          sig = m->signature();\n-          \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n-          if (!put_after_lookup(name, sig, names_and_sigs)) {\n-            dup = true;\n-            break;\n-          }\n+      \/\/ Set containing name-signature pairs\n+      NameSigHashtable* names_and_sigs = new NameSigHashtable();\n+      for (int i = 0; i < length; i++) {\n+        const Method* const m = _methods->at(i);\n+        NameSigHash name_and_sig(m->name(), m->signature());\n+        \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n+        if(!names_and_sigs->put(name_and_sig, 0)) {\n+          classfile_parse_error(\"Duplicate method name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n+                                 name_and_sig._name->as_C_string(), name_and_sig._sig->as_klass_external_name(), THREAD);\n+          return;\n@@ -3056,4 +3004,0 @@\n-      if (dup) {\n-        classfile_parse_error(\"Duplicate method name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n-                               name->as_C_string(), sig->as_klass_external_name(), THREAD);\n-      }\n@@ -4383,1 +4327,1 @@\n-  const Klass* const super = ik->super();\n+  const InstanceKlass* const super = ik->java_super();\n@@ -4685,1 +4629,1 @@\n-      const Klass* k = this_klass->super();\n+      const InstanceKlass* k = this_klass->java_super();\n@@ -4717,1 +4661,1 @@\n-          k = super_m->method_holder()->super();\n+          k = super_m->method_holder()->java_super();\n@@ -4721,1 +4665,1 @@\n-        k = k->super();\n+        k = k->java_super();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":48,"deletions":104,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -770,2 +770,7 @@\n-    st->print(\"%c\", (!is_latin1) ?  value->char_at(index) :\n-                           ((jchar) value->byte_at(index)) & 0xff );\n+    jchar c = (!is_latin1) ?  value->char_at(index) :\n+                             ((jchar) value->byte_at(index)) & 0xff;\n+    if (c < ' ') {\n+      st->print(\"\\\\x%02X\", c); \/\/ print control characters e.g. \\x0A\n+    } else {\n+      st->print(\"%c\", c);\n+    }\n@@ -896,1 +901,1 @@\n-    if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n+    if (ArchiveHeapLoader::is_in_use()) {\n@@ -1167,3 +1172,0 @@\n-  if (ArchiveHeapLoader::is_mapped()) {\n-    assert(Universe::heap()->is_archived_object(m), \"must be archived mirror object\");\n-  }\n@@ -1575,1 +1577,0 @@\n-int java_lang_Thread_Constants::_static_NOT_SUPPORTED_CLASSLOADER_offset = 0;\n@@ -1578,2 +1579,1 @@\n-  macro(_static_VTHREAD_GROUP_offset,             k, \"VTHREAD_GROUP\",             threadgroup_signature, true); \\\n-  macro(_static_NOT_SUPPORTED_CLASSLOADER_offset, k, \"NOT_SUPPORTED_CLASSLOADER\", classloader_signature, true);\n+  macro(_static_VTHREAD_GROUP_offset,             k, \"VTHREAD_GROUP\",             threadgroup_signature, true);\n@@ -1600,5 +1600,0 @@\n-oop java_lang_Thread_Constants::get_NOT_SUPPORTED_CLASSLOADER() {\n-  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n-  oop base = k->static_field_base_raw();\n-  return base->obj_field(_static_NOT_SUPPORTED_CLASSLOADER_offset);\n-}\n@@ -1689,0 +1684,4 @@\n+int java_lang_Thread::is_in_VTMS_transition_offset() {\n+  return _jvmti_is_in_VTMS_transition_offset;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -422,0 +422,1 @@\n+  static int  is_in_VTMS_transition_offset();\n@@ -490,1 +491,0 @@\n-  static oop get_NOT_SUPPORTED_CLASSLOADER();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"code\/codeCache.hpp\"\n@@ -75,1 +74,0 @@\n-#include \"runtime\/deoptimization.hpp\"\n@@ -891,1 +889,1 @@\n-  add_to_hierarchy(THREAD, k);\n+  k->add_to_hierarchy(THREAD);\n@@ -1435,5 +1433,1 @@\n-    { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n-      \/\/ during compilations.\n-      MutexLocker mu(THREAD, Compile_lock);\n-      update_dictionary(THREAD, loaded_class, loader_data);\n-    }\n+    update_dictionary(THREAD, loaded_class, loader_data);\n@@ -1498,1 +1492,1 @@\n-  add_to_hierarchy(THREAD, k);\n+  k->add_to_hierarchy(THREAD);\n@@ -1500,6 +1494,3 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n-    \/\/ Add to systemDictionary - so other classes can see it.\n-    \/\/ Grabs and releases SystemDictionary_lock\n-    update_dictionary(THREAD, k, loader_data);\n-  }\n+  \/\/ Add to systemDictionary - so other classes can see it.\n+  \/\/ Grabs and releases SystemDictionary_lock\n+  update_dictionary(THREAD, k, loader_data);\n@@ -1616,43 +1607,0 @@\n-\/\/ ----------------------------------------------------------------------------\n-\/\/ Update hierarchy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n-\/\/ is grabbed, to ensure that the compiler is not using the class hierarchy.\n-\n-void SystemDictionary::add_to_hierarchy(JavaThread* current, InstanceKlass* k) {\n-  assert(k != nullptr, \"just checking\");\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"must NOT be at safepoint\");\n-\n-  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-  \/\/ deopt is completed before anyone links this class.\n-  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n-  \/\/ held we make sure the deopt is completed before linking.\n-  if (!UseVtableBasedCHA) {\n-    k->init_monitor()->lock();\n-  }\n-\n-  DeoptimizationScope deopt_scope;\n-  {\n-    MutexLocker ml(current, Compile_lock);\n-\n-    k->set_init_state(InstanceKlass::loaded);\n-    \/\/ make sure init_state store is already done.\n-    \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n-    \/\/ Access ordering is used to add to hierarchy.\n-\n-    \/\/ Link into hierarchy.\n-    k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n-    k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n-\n-    \/\/ Now mark all code that depended on old class hierarchy.\n-    \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n-    if (Universe::is_fully_initialized()) {\n-      CodeCache::mark_dependents_on(&deopt_scope, k);\n-    }\n-  }\n-  \/\/ Perform the deopt handshake outside Compile_lock.\n-  deopt_scope.deoptimize_marked();\n-\n-  if (!UseVtableBasedCHA) {\n-    k->init_monitor()->unlock();\n-  }\n-}\n-\n@@ -1809,5 +1757,1 @@\n-  \/\/ Compile_lock prevents systemDictionary updates during compilations\n-  assert_locked_or_safepoint(Compile_lock);\n-  Symbol* name  = k->name();\n-\n-  MutexLocker mu1(SystemDictionary_lock);\n+  MonitorLocker mu1(SystemDictionary_lock);\n@@ -1816,0 +1760,1 @@\n+  Symbol* name  = k->name();\n@@ -1821,1 +1766,1 @@\n-  SystemDictionary_lock->notify_all();\n+  mu1.notify_all();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":9,"deletions":64,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -320,0 +320,5 @@\n+  \/\/ Class loader constraints\n+  static void check_constraints(InstanceKlass* k, ClassLoaderData* loader,\n+                                bool defining, TRAPS);\n+  static void update_dictionary(JavaThread* current, InstanceKlass* k, ClassLoaderData* loader_data);\n+\n@@ -334,0 +339,1 @@\n+\n@@ -369,15 +375,0 @@\n-\n-  \/\/ Setup link to hierarchy and deoptimize\n-  static void add_to_hierarchy(JavaThread* current, InstanceKlass* k);\n-protected:\n-\n-  \/\/ Basic find on loaded classes\n-  static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);\n-\n-  \/\/ Basic find on classes in the midst of being loaded\n-  static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);\n-\n-  \/\/ Class loader constraints\n-  static void check_constraints(InstanceKlass* k, ClassLoaderData* loader,\n-                                bool defining, TRAPS);\n-  static void update_dictionary(JavaThread* current, InstanceKlass* k, ClassLoaderData* loader_data);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -982,18 +982,0 @@\n-  do_intrinsic(_VectorShuffleIota, jdk_internal_vm_vector_VectorSupport, vector_shuffle_step_iota_name, vector_shuffle_step_iota_sig, F_S)     \\\n-   do_signature(vector_shuffle_step_iota_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                          \\\n-                                               \"IIII\"                                                                                          \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)\"                                  \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                         \\\n-   do_name(vector_shuffle_step_iota_name, \"shuffleIota\")                                                                                       \\\n-                                                                                                                                               \\\n-  do_intrinsic(_VectorShuffleToVector, jdk_internal_vm_vector_VectorSupport, vector_shuffle_to_vector_name, vector_shuffle_to_vector_sig, F_S) \\\n-   do_signature(vector_shuffle_to_vector_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                          \\\n-                                               \"ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)\"                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                \\\n-   do_name(vector_shuffle_to_vector_name, \"shuffleToVector\")                                                                                   \\\n-                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -765,0 +765,2 @@\n+  template(encodeAnnotations_name,                     \"encodeAnnotations\")                                       \\\n+  template(encodeAnnotations_signature,                \"([BLjava\/lang\/Class;Ljdk\/internal\/reflect\/ConstantPool;Z[Ljava\/lang\/Class;)[B\")\\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2148,1 +2148,5 @@\n-    _pc_desc_cache.add_pc_desc(upper);\n+    if (!Thread::current_in_asgct()) {\n+      \/\/ we don't want to modify the cache if we're in ASGCT\n+      \/\/ which is typically called in a signal handler\n+      _pc_desc_cache.add_pc_desc(upper);\n+    }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -762,1 +762,1 @@\n-  Handle thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK_NH);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name, CHECK_NH);\n@@ -2280,1 +2280,2 @@\n-      \/\/assert(false, \"compiler should always document failure\");\n+      assert(ci_env.failure_reason() != nullptr, \"expect failure reason\");\n+      assert(false, \"compiler should always document failure: %s\", ci_env.failure_reason());\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) {\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) {\n@@ -414,1 +414,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) {\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) {\n@@ -434,1 +434,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) {}\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) {}\n@@ -919,2 +919,2 @@\n-void DerivedPointerTable::add(derived_pointer* derived_loc, oop *base_loc) {\n-  assert(Universe::heap()->is_in_or_null(*base_loc), \"not an oop\");\n+void DerivedPointerTable::add(derived_pointer* derived_loc, derived_base* base_loc) {\n+  assert(Universe::heap()->is_in_or_null((void*)*base_loc), \"not an oop\");\n@@ -937,1 +937,1 @@\n-      p2i(derived_loc), derived_pointer_value(*derived_loc), p2i(*base_loc), p2i(base_loc), offset\n+      p2i(derived_loc), derived_pointer_value(*derived_loc), intptr_t(*base_loc), p2i(base_loc), offset\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                                           uint n_workers,\n+                                           uint num_workers,\n@@ -84,1 +84,1 @@\n-    _partial_array_stepper(n_workers),\n+    _partial_array_stepper(num_workers),\n@@ -86,1 +86,1 @@\n-    _num_optional_regions(optional_cset_length),\n+    _max_num_optional_regions(optional_cset_length),\n@@ -109,1 +109,1 @@\n-  _oops_into_optional_regions = new G1OopStarChunkedList[_num_optional_regions];\n+  _oops_into_optional_regions = new G1OopStarChunkedList[_max_num_optional_regions];\n@@ -566,1 +566,1 @@\n-  assert(worker_id < _n_workers, \"out of bounds access\");\n+  assert(worker_id < _num_workers, \"out of bounds access\");\n@@ -571,2 +571,4 @@\n-                               worker_id, _n_workers,\n-                               _young_cset_length, _optional_cset_length,\n+                               worker_id,\n+                               _num_workers,\n+                               _young_cset_length,\n+                               _optional_cset_length,\n@@ -586,1 +588,1 @@\n-  for (uint worker_id = 0; worker_id < _n_workers; ++worker_id) {\n+  for (uint worker_id = 0; worker_id < _num_workers; ++worker_id) {\n@@ -596,1 +598,1 @@\n-    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _n_workers) * HeapWordSize;\n+    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _num_workers) * HeapWordSize;\n@@ -603,1 +605,1 @@\n-    _states[worker_id] = NULL;\n+    _states[worker_id] = nullptr;\n@@ -609,1 +611,1 @@\n-  for (uint worker_index = 0; worker_index < _n_workers; ++worker_index) {\n+  for (uint worker_index = 0; worker_index < _num_workers; ++worker_index) {\n@@ -691,1 +693,1 @@\n-                                                 uint n_workers,\n+                                                 uint num_workers,\n@@ -698,1 +700,1 @@\n-    _states(NEW_C_HEAP_ARRAY(G1ParScanThreadState*, n_workers, mtGC)),\n+    _states(NEW_C_HEAP_ARRAY(G1ParScanThreadState*, num_workers, mtGC)),\n@@ -702,1 +704,1 @@\n-    _n_workers(n_workers),\n+    _num_workers(num_workers),\n@@ -705,2 +707,2 @@\n-  _preserved_marks_set.init(n_workers);\n-  for (uint i = 0; i < n_workers; ++i) {\n+  _preserved_marks_set.init(num_workers);\n+  for (uint i = 0; i < num_workers; ++i) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1682,1 +1682,1 @@\n-void PSParallelCompact::invoke(bool maximum_heap_compaction) {\n+bool PSParallelCompact::invoke(bool maximum_heap_compaction) {\n@@ -1699,2 +1699,2 @@\n-  PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||\n-                                      maximum_heap_compaction);\n+  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||\n+                                             maximum_heap_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -517,3 +517,0 @@\n-  \/\/ Is the given object inside a CDS archive area?\n-  virtual bool is_archived_object(oop object) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,3 +272,0 @@\n-JNIEXPORT jboolean JNICALL\n-JVM_IsThreadAlive(JNIEnv *env, jobject thread);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+  ResolvedIndyEntry* resolved_indy_entry() const;\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -428,3 +428,4 @@\n-    int indy_index = orig_i;\n-    int cpc_index = constants->invokedynamic_cp_cache_index(indy_index);\n-    print_cpcache_entry(cpc_index, st);\n+    int indy_index = constants->decode_invokedynamic_index(orig_i);\n+    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(indy_index);\n+    st->print(\"  ResolvedIndyEntry: \");\n+    indy_entry->print_on(st);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,7 +32,307 @@\n-bool            Bytecodes::_is_initialized = false;\n-const char*     Bytecodes::_name          [Bytecodes::number_of_codes];\n-BasicType       Bytecodes::_result_type   [Bytecodes::number_of_codes];\n-s_char          Bytecodes::_depth         [Bytecodes::number_of_codes];\n-u_char          Bytecodes::_lengths       [Bytecodes::number_of_codes];\n-Bytecodes::Code Bytecodes::_java_code     [Bytecodes::number_of_codes];\n-unsigned short  Bytecodes::_flags         [(1<<BitsPerByte)*2];\n+#define JVM_BYTECODES_DO(def)                                                                                                     \\\n+  def(_fast_agetfield            , \"fast_agetfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield          ) \\\n+  def(_fast_qgetfield            , \"fast_qgetfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield          ) \\\n+  def(_fast_bgetfield            , \"fast_bgetfield\"            , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _getfield          ) \\\n+  def(_fast_cgetfield            , \"fast_cgetfield\"            , \"bJJ\"  , nullptr    , T_CHAR   ,  0, true , _getfield          ) \\\n+  def(_fast_dgetfield            , \"fast_dgetfield\"            , \"bJJ\"  , nullptr    , T_DOUBLE ,  0, true , _getfield          ) \\\n+  def(_fast_fgetfield            , \"fast_fgetfield\"            , \"bJJ\"  , nullptr    , T_FLOAT  ,  0, true , _getfield          ) \\\n+  def(_fast_igetfield            , \"fast_igetfield\"            , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _getfield          ) \\\n+  def(_fast_lgetfield            , \"fast_lgetfield\"            , \"bJJ\"  , nullptr    , T_LONG   ,  0, true , _getfield          ) \\\n+  def(_fast_sgetfield            , \"fast_sgetfield\"            , \"bJJ\"  , nullptr    , T_SHORT  ,  0, true , _getfield          ) \\\n+                                                                                                                                  \\\n+  def(_fast_aputfield            , \"fast_aputfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield          ) \\\n+  def(_fast_qputfield            , \"fast_qputfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield          ) \\\n+  def(_fast_bputfield            , \"fast_bputfield\"            , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield          ) \\\n+  def(_fast_zputfield            , \"fast_zputfield\"            , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield          ) \\\n+  def(_fast_cputfield            , \"fast_cputfield\"            , \"bJJ\"  , nullptr    , T_CHAR   ,  0, true , _putfield          ) \\\n+  def(_fast_dputfield            , \"fast_dputfield\"            , \"bJJ\"  , nullptr    , T_DOUBLE ,  0, true , _putfield          ) \\\n+  def(_fast_fputfield            , \"fast_fputfield\"            , \"bJJ\"  , nullptr    , T_FLOAT  ,  0, true , _putfield          ) \\\n+  def(_fast_iputfield            , \"fast_iputfield\"            , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield          ) \\\n+  def(_fast_lputfield            , \"fast_lputfield\"            , \"bJJ\"  , nullptr    , T_LONG   ,  0, true , _putfield          ) \\\n+  def(_fast_sputfield            , \"fast_sputfield\"            , \"bJJ\"  , nullptr    , T_SHORT  ,  0, true , _putfield          ) \\\n+                                                                                                                                  \\\n+  def(_fast_aload_0              , \"fast_aload_0\"              , \"b\"    , nullptr    , T_OBJECT ,  1, true , _aload_0           ) \\\n+  def(_fast_iaccess_0            , \"fast_iaccess_0\"            , \"b_JJ\" , nullptr    , T_INT    ,  1, true , _aload_0           ) \\\n+  def(_fast_aaccess_0            , \"fast_aaccess_0\"            , \"b_JJ\" , nullptr    , T_OBJECT ,  1, true , _aload_0           ) \\\n+  def(_fast_faccess_0            , \"fast_faccess_0\"            , \"b_JJ\" , nullptr    , T_OBJECT ,  1, true , _aload_0           ) \\\n+                                                                                                                                  \\\n+  def(_fast_iload                , \"fast_iload\"                , \"bi\"   , nullptr    , T_INT    ,  1, false, _iload             ) \\\n+  def(_fast_iload2               , \"fast_iload2\"               , \"bi_i\" , nullptr    , T_INT    ,  2, false, _iload             ) \\\n+  def(_fast_icaload              , \"fast_icaload\"              , \"bi_\"  , nullptr    , T_INT    ,  0, false, _iload             ) \\\n+                                                                                                                                  \\\n+  def(_fast_invokevfinal         , \"fast_invokevfinal\"         , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true , _invokevirtual     ) \\\n+  def(_fast_linearswitch         , \"fast_linearswitch\"         , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch      ) \\\n+  def(_fast_binaryswitch         , \"fast_binaryswitch\"         , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch      ) \\\n+                                                                                                                                  \\\n+  def(_fast_aldc                 , \"fast_aldc\"                 , \"bj\"   , nullptr    , T_OBJECT ,  1, true ,  _ldc              ) \\\n+  def(_fast_aldc_w               , \"fast_aldc_w\"               , \"bJJ\"  , nullptr    , T_OBJECT ,  1, true ,  _ldc_w            ) \\\n+                                                                                                                                  \\\n+  def(_return_register_finalizer , \"return_register_finalizer\" , \"b\"     , nullptr    , T_VOID  ,  0, true , _return            ) \\\n+                                                                                                                                  \\\n+  def(_invokehandle              , \"invokehandle\"              , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true , _invokevirtual     ) \\\n+                                                                                                                                  \\\n+  def(_nofast_getfield           , \"nofast_getfield\"           , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true ,  _getfield         ) \\\n+  def(_nofast_putfield           , \"nofast_putfield\"           , \"bJJ\"  , nullptr    , T_ILLEGAL, -2, true , _putfield          ) \\\n+  def(_nofast_aload_0            , \"nofast_aload_0\"            , \"b\"    , nullptr    , T_OBJECT ,  1, true , _aload_0           ) \\\n+  def(_nofast_iload              , \"nofast_iload\"              , \"bi\"   , nullptr    , T_INT    ,  1, false, _iload             ) \\\n+                                                                                                                                  \\\n+  def(_shouldnotreachhere        , \"_shouldnotreachhere\"       , \"b\"    , nullptr    , T_VOID   ,  0, false, _shouldnotreachhere)\n+\n+#define BYTECODES_DO(def)                                                                                  \\\n+  def(_nop             , \"nop\"             , \"b\"    , nullptr    , T_VOID   ,  0, false, _nop            ) \\\n+  def(_aconst_null     , \"aconst_null\"     , \"b\"    , nullptr    , T_OBJECT ,  1, false, _aconst_null    ) \\\n+  def(_iconst_m1       , \"iconst_m1\"       , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_m1      ) \\\n+  def(_iconst_0        , \"iconst_0\"        , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_0       ) \\\n+  def(_iconst_1        , \"iconst_1\"        , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_1       ) \\\n+  def(_iconst_2        , \"iconst_2\"        , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_2       ) \\\n+  def(_iconst_3        , \"iconst_3\"        , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_3       ) \\\n+  def(_iconst_4        , \"iconst_4\"        , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_4       ) \\\n+  def(_iconst_5        , \"iconst_5\"        , \"b\"    , nullptr    , T_INT    ,  1, false, _iconst_5       ) \\\n+  def(_lconst_0        , \"lconst_0\"        , \"b\"    , nullptr    , T_LONG   ,  2, false, _lconst_0       ) \\\n+  def(_lconst_1        , \"lconst_1\"        , \"b\"    , nullptr    , T_LONG   ,  2, false, _lconst_1       ) \\\n+  def(_fconst_0        , \"fconst_0\"        , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fconst_0       ) \\\n+  def(_fconst_1        , \"fconst_1\"        , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fconst_1       ) \\\n+  def(_fconst_2        , \"fconst_2\"        , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fconst_2       ) \\\n+  def(_dconst_0        , \"dconst_0\"        , \"b\"    , nullptr    , T_DOUBLE ,  2, false, _dconst_0       ) \\\n+  def(_dconst_1        , \"dconst_1\"        , \"b\"    , nullptr    , T_DOUBLE ,  2, false, _dconst_1       ) \\\n+  def(_bipush          , \"bipush\"          , \"bc\"   , nullptr    , T_INT    ,  1, false, _bipush         ) \\\n+  def(_sipush          , \"sipush\"          , \"bcc\"  , nullptr    , T_INT    ,  1, false, _sipush         ) \\\n+  def(_ldc             , \"ldc\"             , \"bk\"   , nullptr    , T_ILLEGAL,  1, true , _ldc            ) \\\n+  def(_ldc_w           , \"ldc_w\"           , \"bkk\"  , nullptr    , T_ILLEGAL,  1, true , _ldc_w          ) \\\n+  def(_ldc2_w          , \"ldc2_w\"          , \"bkk\"  , nullptr    , T_ILLEGAL,  2, true , _ldc2_w         ) \\\n+  def(_iload           , \"iload\"           , \"bi\"   , \"wbii\"     , T_INT    ,  1, false, _iload          ) \\\n+  def(_lload           , \"lload\"           , \"bi\"   , \"wbii\"     , T_LONG   ,  2, false, _lload          ) \\\n+  def(_fload           , \"fload\"           , \"bi\"   , \"wbii\"     , T_FLOAT  ,  1, false, _fload          ) \\\n+  def(_dload           , \"dload\"           , \"bi\"   , \"wbii\"     , T_DOUBLE ,  2, false, _dload          ) \\\n+  def(_aload           , \"aload\"           , \"bi\"   , \"wbii\"     , T_OBJECT ,  1, false, _aload          ) \\\n+  def(_iload_0         , \"iload_0\"         , \"b\"    , nullptr    , T_INT    ,  1, false, _iload_0        ) \\\n+  def(_iload_1         , \"iload_1\"         , \"b\"    , nullptr    , T_INT    ,  1, false, _iload_1        ) \\\n+  def(_iload_2         , \"iload_2\"         , \"b\"    , nullptr    , T_INT    ,  1, false, _iload_2        ) \\\n+  def(_iload_3         , \"iload_3\"         , \"b\"    , nullptr    , T_INT    ,  1, false, _iload_3        ) \\\n+  def(_lload_0         , \"lload_0\"         , \"b\"    , nullptr    , T_LONG   ,  2, false, _lload_0        ) \\\n+  def(_lload_1         , \"lload_1\"         , \"b\"    , nullptr    , T_LONG   ,  2, false, _lload_1        ) \\\n+  def(_lload_2         , \"lload_2\"         , \"b\"    , nullptr    , T_LONG   ,  2, false, _lload_2        ) \\\n+  def(_lload_3         , \"lload_3\"         , \"b\"    , nullptr    , T_LONG   ,  2, false, _lload_3        ) \\\n+  def(_fload_0         , \"fload_0\"         , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fload_0        ) \\\n+  def(_fload_1         , \"fload_1\"         , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fload_1        ) \\\n+  def(_fload_2         , \"fload_2\"         , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fload_2        ) \\\n+  def(_fload_3         , \"fload_3\"         , \"b\"    , nullptr    , T_FLOAT  ,  1, false, _fload_3        ) \\\n+  def(_dload_0         , \"dload_0\"         , \"b\"    , nullptr    , T_DOUBLE ,  2, false, _dload_0        ) \\\n+  def(_dload_1         , \"dload_1\"         , \"b\"    , nullptr    , T_DOUBLE ,  2, false, _dload_1        ) \\\n+  def(_dload_2         , \"dload_2\"         , \"b\"    , nullptr    , T_DOUBLE ,  2, false, _dload_2        ) \\\n+  def(_dload_3         , \"dload_3\"         , \"b\"    , nullptr    , T_DOUBLE ,  2, false, _dload_3        ) \\\n+  def(_aload_0         , \"aload_0\"         , \"b\"    , nullptr    , T_OBJECT ,  1, true , _aload_0        ) \\\n+  def(_aload_1         , \"aload_1\"         , \"b\"    , nullptr    , T_OBJECT ,  1, false, _aload_1        ) \\\n+  def(_aload_2         , \"aload_2\"         , \"b\"    , nullptr    , T_OBJECT ,  1, false, _aload_2        ) \\\n+  def(_aload_3         , \"aload_3\"         , \"b\"    , nullptr    , T_OBJECT ,  1, false, _aload_3        ) \\\n+  def(_iaload          , \"iaload\"          , \"b\"    , nullptr    , T_INT    , -1, true , _iaload         ) \\\n+  def(_laload          , \"laload\"          , \"b\"    , nullptr    , T_LONG   ,  0, true , _laload         ) \\\n+  def(_faload          , \"faload\"          , \"b\"    , nullptr    , T_FLOAT  , -1, true , _faload         ) \\\n+  def(_daload          , \"daload\"          , \"b\"    , nullptr    , T_DOUBLE ,  0, true , _daload         ) \\\n+  def(_aaload          , \"aaload\"          , \"b\"    , nullptr    , T_OBJECT , -1, true , _aaload         ) \\\n+  def(_baload          , \"baload\"          , \"b\"    , nullptr    , T_INT    , -1, true , _baload         ) \\\n+  def(_caload          , \"caload\"          , \"b\"    , nullptr    , T_INT    , -1, true , _caload         ) \\\n+  def(_saload          , \"saload\"          , \"b\"    , nullptr    , T_INT    , -1, true , _saload         ) \\\n+  def(_istore          , \"istore\"          , \"bi\"   , \"wbii\"     , T_VOID   , -1, false, _istore         ) \\\n+  def(_lstore          , \"lstore\"          , \"bi\"   , \"wbii\"     , T_VOID   , -2, false, _lstore         ) \\\n+  def(_fstore          , \"fstore\"          , \"bi\"   , \"wbii\"     , T_VOID   , -1, false, _fstore         ) \\\n+  def(_dstore          , \"dstore\"          , \"bi\"   , \"wbii\"     , T_VOID   , -2, false, _dstore         ) \\\n+  def(_astore          , \"astore\"          , \"bi\"   , \"wbii\"     , T_VOID   , -1, false, _astore         ) \\\n+  def(_istore_0        , \"istore_0\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _istore_0       ) \\\n+  def(_istore_1        , \"istore_1\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _istore_1       ) \\\n+  def(_istore_2        , \"istore_2\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _istore_2       ) \\\n+  def(_istore_3        , \"istore_3\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _istore_3       ) \\\n+  def(_lstore_0        , \"lstore_0\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _lstore_0       ) \\\n+  def(_lstore_1        , \"lstore_1\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _lstore_1       ) \\\n+  def(_lstore_2        , \"lstore_2\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _lstore_2       ) \\\n+  def(_lstore_3        , \"lstore_3\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _lstore_3       ) \\\n+  def(_fstore_0        , \"fstore_0\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _fstore_0       ) \\\n+  def(_fstore_1        , \"fstore_1\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _fstore_1       ) \\\n+  def(_fstore_2        , \"fstore_2\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _fstore_2       ) \\\n+  def(_fstore_3        , \"fstore_3\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _fstore_3       ) \\\n+  def(_dstore_0        , \"dstore_0\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _dstore_0       ) \\\n+  def(_dstore_1        , \"dstore_1\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _dstore_1       ) \\\n+  def(_dstore_2        , \"dstore_2\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _dstore_2       ) \\\n+  def(_dstore_3        , \"dstore_3\"        , \"b\"    , nullptr    , T_VOID   , -2, false, _dstore_3       ) \\\n+  def(_astore_0        , \"astore_0\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _astore_0       ) \\\n+  def(_astore_1        , \"astore_1\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _astore_1       ) \\\n+  def(_astore_2        , \"astore_2\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _astore_2       ) \\\n+  def(_astore_3        , \"astore_3\"        , \"b\"    , nullptr    , T_VOID   , -1, false, _astore_3       ) \\\n+  def(_iastore         , \"iastore\"         , \"b\"    , nullptr    , T_VOID   , -3, true , _iastore        ) \\\n+  def(_lastore         , \"lastore\"         , \"b\"    , nullptr    , T_VOID   , -4, true , _lastore        ) \\\n+  def(_fastore         , \"fastore\"         , \"b\"    , nullptr    , T_VOID   , -3, true , _fastore        ) \\\n+  def(_dastore         , \"dastore\"         , \"b\"    , nullptr    , T_VOID   , -4, true , _dastore        ) \\\n+  def(_aastore         , \"aastore\"         , \"b\"    , nullptr    , T_VOID   , -3, true , _aastore        ) \\\n+  def(_bastore         , \"bastore\"         , \"b\"    , nullptr    , T_VOID   , -3, true , _bastore        ) \\\n+  def(_castore         , \"castore\"         , \"b\"    , nullptr    , T_VOID   , -3, true , _castore        ) \\\n+  def(_sastore         , \"sastore\"         , \"b\"    , nullptr    , T_VOID   , -3, true , _sastore        ) \\\n+  def(_pop             , \"pop\"             , \"b\"    , nullptr    , T_VOID   , -1, false, _pop            ) \\\n+  def(_pop2            , \"pop2\"            , \"b\"    , nullptr    , T_VOID   , -2, false, _pop2           ) \\\n+  def(_dup             , \"dup\"             , \"b\"    , nullptr    , T_VOID   ,  1, false, _dup            ) \\\n+  def(_dup_x1          , \"dup_x1\"          , \"b\"    , nullptr    , T_VOID   ,  1, false, _dup_x1         ) \\\n+  def(_dup_x2          , \"dup_x2\"          , \"b\"    , nullptr    , T_VOID   ,  1, false, _dup_x2         ) \\\n+  def(_dup2            , \"dup2\"            , \"b\"    , nullptr    , T_VOID   ,  2, false, _dup2           ) \\\n+  def(_dup2_x1         , \"dup2_x1\"         , \"b\"    , nullptr    , T_VOID   ,  2, false, _dup2_x1        ) \\\n+  def(_dup2_x2         , \"dup2_x2\"         , \"b\"    , nullptr    , T_VOID   ,  2, false, _dup2_x2        ) \\\n+  def(_swap            , \"swap\"            , \"b\"    , nullptr    , T_VOID   ,  0, false, _swap           ) \\\n+  def(_iadd            , \"iadd\"            , \"b\"    , nullptr    , T_INT    , -1, false, _iadd           ) \\\n+  def(_ladd            , \"ladd\"            , \"b\"    , nullptr    , T_LONG   , -2, false, _ladd           ) \\\n+  def(_fadd            , \"fadd\"            , \"b\"    , nullptr    , T_FLOAT  , -1, false, _fadd           ) \\\n+  def(_dadd            , \"dadd\"            , \"b\"    , nullptr    , T_DOUBLE , -2, false, _dadd           ) \\\n+  def(_isub            , \"isub\"            , \"b\"    , nullptr    , T_INT    , -1, false, _isub           ) \\\n+  def(_lsub            , \"lsub\"            , \"b\"    , nullptr    , T_LONG   , -2, false, _lsub           ) \\\n+  def(_fsub            , \"fsub\"            , \"b\"    , nullptr    , T_FLOAT  , -1, false, _fsub           ) \\\n+  def(_dsub            , \"dsub\"            , \"b\"    , nullptr    , T_DOUBLE , -2, false, _dsub           ) \\\n+  def(_imul            , \"imul\"            , \"b\"    , nullptr    , T_INT    , -1, false, _imul           ) \\\n+  def(_lmul            , \"lmul\"            , \"b\"    , nullptr    , T_LONG   , -2, false, _lmul           ) \\\n+  def(_fmul            , \"fmul\"            , \"b\"    , nullptr    , T_FLOAT  , -1, false, _fmul           ) \\\n+  def(_dmul            , \"dmul\"            , \"b\"    , nullptr    , T_DOUBLE , -2, false, _dmul           ) \\\n+  def(_idiv            , \"idiv\"            , \"b\"    , nullptr    , T_INT    , -1, true , _idiv           ) \\\n+  def(_ldiv            , \"ldiv\"            , \"b\"    , nullptr    , T_LONG   , -2, true , _ldiv           ) \\\n+  def(_fdiv            , \"fdiv\"            , \"b\"    , nullptr    , T_FLOAT  , -1, false, _fdiv           ) \\\n+  def(_ddiv            , \"ddiv\"            , \"b\"    , nullptr    , T_DOUBLE , -2, false, _ddiv           ) \\\n+  def(_irem            , \"irem\"            , \"b\"    , nullptr    , T_INT    , -1, true , _irem           ) \\\n+  def(_lrem            , \"lrem\"            , \"b\"    , nullptr    , T_LONG   , -2, true , _lrem           ) \\\n+  def(_frem            , \"frem\"            , \"b\"    , nullptr    , T_FLOAT  , -1, false, _frem           ) \\\n+  def(_drem            , \"drem\"            , \"b\"    , nullptr    , T_DOUBLE , -2, false, _drem           ) \\\n+  def(_ineg            , \"ineg\"            , \"b\"    , nullptr    , T_INT    ,  0, false, _ineg           ) \\\n+  def(_lneg            , \"lneg\"            , \"b\"    , nullptr    , T_LONG   ,  0, false, _lneg           ) \\\n+  def(_fneg            , \"fneg\"            , \"b\"    , nullptr    , T_FLOAT  ,  0, false, _fneg           ) \\\n+  def(_dneg            , \"dneg\"            , \"b\"    , nullptr    , T_DOUBLE ,  0, false, _dneg           ) \\\n+  def(_ishl            , \"ishl\"            , \"b\"    , nullptr    , T_INT    , -1, false, _ishl           ) \\\n+  def(_lshl            , \"lshl\"            , \"b\"    , nullptr    , T_LONG   , -1, false, _lshl           ) \\\n+  def(_ishr            , \"ishr\"            , \"b\"    , nullptr    , T_INT    , -1, false, _ishr           ) \\\n+  def(_lshr            , \"lshr\"            , \"b\"    , nullptr    , T_LONG   , -1, false, _lshr           ) \\\n+  def(_iushr           , \"iushr\"           , \"b\"    , nullptr    , T_INT    , -1, false, _iushr          ) \\\n+  def(_lushr           , \"lushr\"           , \"b\"    , nullptr    , T_LONG   , -1, false, _lushr          ) \\\n+  def(_iand            , \"iand\"            , \"b\"    , nullptr    , T_INT    , -1, false, _iand           ) \\\n+  def(_land            , \"land\"            , \"b\"    , nullptr    , T_LONG   , -2, false, _land           ) \\\n+  def(_ior             , \"ior\"             , \"b\"    , nullptr    , T_INT    , -1, false, _ior            ) \\\n+  def(_lor             , \"lor\"             , \"b\"    , nullptr    , T_LONG   , -2, false, _lor            ) \\\n+  def(_ixor            , \"ixor\"            , \"b\"    , nullptr    , T_INT    , -1, false, _ixor           ) \\\n+  def(_lxor            , \"lxor\"            , \"b\"    , nullptr    , T_LONG   , -2, false, _lxor           ) \\\n+  def(_iinc            , \"iinc\"            , \"bic\"  , \"wbiicc\",    T_VOID   ,  0, false, _iinc           ) \\\n+  def(_i2l             , \"i2l\"             , \"b\"    , nullptr    , T_LONG   ,  1, false, _i2l            ) \\\n+  def(_i2f             , \"i2f\"             , \"b\"    , nullptr    , T_FLOAT  ,  0, false, _i2f            ) \\\n+  def(_i2d             , \"i2d\"             , \"b\"    , nullptr    , T_DOUBLE ,  1, false, _i2d            ) \\\n+  def(_l2i             , \"l2i\"             , \"b\"    , nullptr    , T_INT    , -1, false, _l2i            ) \\\n+  def(_l2f             , \"l2f\"             , \"b\"    , nullptr    , T_FLOAT  , -1, false, _l2f            ) \\\n+  def(_l2d             , \"l2d\"             , \"b\"    , nullptr    , T_DOUBLE ,  0, false, _l2d            ) \\\n+  def(_f2i             , \"f2i\"             , \"b\"    , nullptr    , T_INT    ,  0, false, _f2i            ) \\\n+  def(_f2l             , \"f2l\"             , \"b\"    , nullptr    , T_LONG   ,  1, false, _f2l            ) \\\n+  def(_f2d             , \"f2d\"             , \"b\"    , nullptr    , T_DOUBLE ,  1, false, _f2d            ) \\\n+  def(_d2i             , \"d2i\"             , \"b\"    , nullptr    , T_INT    , -1, false, _d2i            ) \\\n+  def(_d2l             , \"d2l\"             , \"b\"    , nullptr    , T_LONG   ,  0, false, _d2l            ) \\\n+  def(_d2f             , \"d2f\"             , \"b\"    , nullptr    , T_FLOAT  , -1, false, _d2f            ) \\\n+  def(_i2b             , \"i2b\"             , \"b\"    , nullptr    , T_BYTE   ,  0, false, _i2b            ) \\\n+  def(_i2c             , \"i2c\"             , \"b\"    , nullptr    , T_CHAR   ,  0, false, _i2c            ) \\\n+  def(_i2s             , \"i2s\"             , \"b\"    , nullptr    , T_SHORT  ,  0, false, _i2s            ) \\\n+  def(_lcmp            , \"lcmp\"            , \"b\"    , nullptr    , T_VOID   , -3, false, _lcmp           ) \\\n+  def(_fcmpl           , \"fcmpl\"           , \"b\"    , nullptr    , T_VOID   , -1, false, _fcmpl          ) \\\n+  def(_fcmpg           , \"fcmpg\"           , \"b\"    , nullptr    , T_VOID   , -1, false, _fcmpg          ) \\\n+  def(_dcmpl           , \"dcmpl\"           , \"b\"    , nullptr    , T_VOID   , -3, false, _dcmpl          ) \\\n+  def(_dcmpg           , \"dcmpg\"           , \"b\"    , nullptr    , T_VOID   , -3, false, _dcmpg          ) \\\n+  def(_ifeq            , \"ifeq\"            , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifeq           ) \\\n+  def(_ifne            , \"ifne\"            , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifne           ) \\\n+  def(_iflt            , \"iflt\"            , \"boo\"  , nullptr    , T_VOID   , -1, false, _iflt           ) \\\n+  def(_ifge            , \"ifge\"            , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifge           ) \\\n+  def(_ifgt            , \"ifgt\"            , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifgt           ) \\\n+  def(_ifle            , \"ifle\"            , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifle           ) \\\n+  def(_if_icmpeq       , \"if_icmpeq\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_icmpeq      ) \\\n+  def(_if_icmpne       , \"if_icmpne\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_icmpne      ) \\\n+  def(_if_icmplt       , \"if_icmplt\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_icmplt      ) \\\n+  def(_if_icmpge       , \"if_icmpge\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_icmpge      ) \\\n+  def(_if_icmpgt       , \"if_icmpgt\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_icmpgt      ) \\\n+  def(_if_icmple       , \"if_icmple\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_icmple      ) \\\n+  def(_if_acmpeq       , \"if_acmpeq\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_acmpeq      ) \\\n+  def(_if_acmpne       , \"if_acmpne\"       , \"boo\"  , nullptr    , T_VOID   , -2, false, _if_acmpne      ) \\\n+  def(_goto            , \"goto\"            , \"boo\"  , nullptr    , T_VOID   ,  0, false, _goto           ) \\\n+  def(_jsr             , \"jsr\"             , \"boo\"  , nullptr    , T_INT    ,  0, false, _jsr            ) \\\n+  def(_ret             , \"ret\"             , \"bi\"   , \"wbii\"     , T_VOID   ,  0, false, _ret            ) \\\n+  def(_tableswitch     , \"tableswitch\"     , \"\"     , nullptr    , T_VOID   , -1, false, _tableswitch    ) \\\n+  def(_lookupswitch    , \"lookupswitch\"    , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch   ) \\\n+  def(_ireturn         , \"ireturn\"         , \"b\"    , nullptr    , T_INT    , -1, true , _ireturn        ) \\\n+  def(_lreturn         , \"lreturn\"         , \"b\"    , nullptr    , T_LONG   , -2, true , _lreturn        ) \\\n+  def(_freturn         , \"freturn\"         , \"b\"    , nullptr    , T_FLOAT  , -1, true , _freturn        ) \\\n+  def(_dreturn         , \"dreturn\"         , \"b\"    , nullptr    , T_DOUBLE , -2, true , _dreturn        ) \\\n+  def(_areturn         , \"areturn\"         , \"b\"    , nullptr    , T_OBJECT , -1, true , _areturn        ) \\\n+  def(_return          , \"return\"          , \"b\"    , nullptr    , T_VOID   ,  0, true , _return         ) \\\n+  def(_getstatic       , \"getstatic\"       , \"bJJ\"  , nullptr    , T_ILLEGAL,  1, true , _getstatic      ) \\\n+  def(_putstatic       , \"putstatic\"       , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true , _putstatic      ) \\\n+  def(_getfield        , \"getfield\"        , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true , _getfield       ) \\\n+  def(_putfield        , \"putfield\"        , \"bJJ\"  , nullptr    , T_ILLEGAL, -2, true , _putfield       ) \\\n+  def(_invokevirtual   , \"invokevirtual\"   , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true , _invokevirtual  ) \\\n+  def(_invokespecial   , \"invokespecial\"   , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true , _invokespecial  ) \\\n+  def(_invokestatic    , \"invokestatic\"    , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true , _invokestatic   ) \\\n+  def(_invokeinterface , \"invokeinterface\" , \"bJJ__\", nullptr    , T_ILLEGAL, -1, true , _invokeinterface) \\\n+  def(_invokedynamic   , \"invokedynamic\"   , \"bJJJJ\", nullptr    , T_ILLEGAL,  0, true , _invokedynamic  ) \\\n+  def(_new             , \"new\"             , \"bkk\"  , nullptr    , T_OBJECT ,  1, true , _new            ) \\\n+  def(_newarray        , \"newarray\"        , \"bc\"   , nullptr    , T_OBJECT ,  0, true , _newarray       ) \\\n+  def(_anewarray       , \"anewarray\"       , \"bkk\"  , nullptr    , T_OBJECT ,  0, true , _anewarray      ) \\\n+  def(_arraylength     , \"arraylength\"     , \"b\"    , nullptr    , T_INT    ,  0, true , _arraylength    ) \\\n+  def(_athrow          , \"athrow\"          , \"b\"    , nullptr    , T_VOID   , -1, true , _athrow         ) \\\n+  def(_checkcast       , \"checkcast\"       , \"bkk\"  , nullptr    , T_OBJECT ,  0, true , _checkcast      ) \\\n+  def(_instanceof      , \"instanceof\"      , \"bkk\"  , nullptr    , T_INT    ,  0, true , _instanceof     ) \\\n+  def(_monitorenter    , \"monitorenter\"    , \"b\"    , nullptr    , T_VOID   , -1, true , _monitorenter   ) \\\n+  def(_monitorexit     , \"monitorexit\"     , \"b\"    , nullptr    , T_VOID   , -1, true , _monitorexit    ) \\\n+  def(_wide            , \"wide\"            , \"\"     , nullptr    , T_VOID   ,  0, false, _wide           ) \\\n+  def(_multianewarray  , \"multianewarray\"  , \"bkkc\" , nullptr    , T_OBJECT ,  1, true , _multianewarray ) \\\n+  def(_ifnull          , \"ifnull\"          , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifnull         ) \\\n+  def(_ifnonnull       , \"ifnonnull\"       , \"boo\"  , nullptr    , T_VOID   , -1, false, _ifnonnull      ) \\\n+  def(_goto_w          , \"goto_w\"          , \"boooo\", nullptr    , T_VOID   ,  0, false, _goto_w         ) \\\n+  def(_jsr_w           , \"jsr_w\"           , \"boooo\", nullptr    , T_INT    ,  0, false, _jsr_w          ) \\\n+  def(_breakpoint      , \"breakpoint\"      , \"\"     , nullptr    , T_VOID   ,  0, true , _breakpoint     ) \\\n+  def(_aconst_init     , \"aconst_init\"     , \"bkk\"  , nullptr    , T_OBJECT ,  1, true , _aconst_init    ) \\\n+  def(_withfield       , \"withfield\"       , \"bJJ\"  , nullptr    , T_OBJECT , -1, true , _withfield      ) \\\n+  JVM_BYTECODES_DO(def)\n+\n+bool Bytecodes::_is_initialized = false;\n+\n+const char* const Bytecodes::_name[Bytecodes::number_of_codes] = {\n+#define BYTECODE_NAME(code, name, format, wide_format, result_type, depth, can_trap, java_code) name,\n+  BYTECODES_DO(BYTECODE_NAME)\n+#undef BYTECODE_NAME\n+};\n+\n+const BasicType Bytecodes::_result_type[Bytecodes::number_of_codes] = {\n+#define BYTECODE_RESULT_TYPE(code, name, format, wide_format, result_type, depth, can_trap, java_code) result_type,\n+  BYTECODES_DO(BYTECODE_RESULT_TYPE)\n+#undef BYTECODE_RESULT_TYPE\n+};\n+\n+const s_char Bytecodes::_depth[Bytecodes::number_of_codes] = {\n+#define BYTECODE_DEPTH(code, name, format, wide_format, result_type, depth, can_trap, java_code) depth,\n+  BYTECODES_DO(BYTECODE_DEPTH)\n+#undef BYTECODE_DEPTH\n+};\n+\n+\/\/ Helper for determining the size (a.k.a. length) of a string literal.\n+struct StringLiteralSize {\n+  template <size_t N>\n+  static constexpr size_t invoke(const char (&)[N]) {\n+    static_assert(N > 0, \"N must be greater than 0\");\n+    \/\/ The size is N - 1, as C strings have an implicit NUL at the end. So \"foo\" will result in N\n+    \/\/ being 4, but we actually want 3.\n+    return N - 1;\n+  }\n+\n+  static constexpr size_t invoke(std::nullptr_t) {\n+    return 0;\n+  }\n+};\n+\n+#define STRING_SIZE(string) StringLiteralSize::invoke(string)\n+\n+const u_char Bytecodes::_lengths[Bytecodes::number_of_codes] = {\n+#define BYTECODE_LENGTHS(code, name, format, wide_format, result_type, depth, can_trap, java_code) static_cast<u_char>((STRING_SIZE(wide_format) << 4) | (STRING_SIZE(format) & 0xf)),\n+  BYTECODES_DO(BYTECODE_LENGTHS)\n+#undef BYTECODE_LENGTHS\n+};\n+\n+const Bytecodes::Code Bytecodes::_java_code[Bytecodes::number_of_codes] = {\n+#define BYTECODE_JAVA_CODE(code, name, format, wide_format, result_type, depth, can_trap, java_code) Bytecodes::java_code,\n+  BYTECODES_DO(BYTECODE_JAVA_CODE)\n+#undef BYTECODE_JAVA_CODE\n+};\n+\n+jchar Bytecodes::_flags[(1<<BitsPerByte)*2];\n@@ -140,8 +440,1 @@\n-\n-\n-void Bytecodes::def(Code code, const char* name, const char* format, const char* wide_format, BasicType result_type, int depth, bool can_trap) {\n-  def(code, name, format, wide_format, result_type, depth, can_trap, code);\n-}\n-\n-\n-void Bytecodes::def(Code code, const char* name, const char* format, const char* wide_format, BasicType result_type, int depth, bool can_trap, Code java_code) {\n+void Bytecodes::def_flags(Code code, const char* format, const char* wide_format, bool can_trap, Code java_code) {\n@@ -149,0 +442,1 @@\n+#ifdef ASSERT\n@@ -151,5 +445,1 @@\n-  _name          [code] = name;\n-  _result_type   [code] = result_type;\n-  _depth         [code] = depth;\n-  _lengths       [code] = (wlen << 4) | (len & 0xF);\n-  _java_code     [code] = java_code;\n+#endif\n@@ -163,1 +453,1 @@\n-  assert(length_for(code)      == len, \"\");\n+  assert(length_for(code)      == len,  \"\");\n@@ -260,1 +550,0 @@\n-  assert(number_of_codes <= 256, \"too many bytecodes\");\n@@ -266,4 +555,1 @@\n-  \/\/ Note 1: nullptr for the format string means the bytecode doesn't exist\n-  \/\/         in that form.\n-  \/\/\n-  \/\/ Note 2: The result type is T_ILLEGAL for bytecodes where the top of stack\n+  \/\/ Note 1: The result type is T_ILLEGAL for bytecodes where the top of stack\n@@ -272,261 +558,10 @@\n-  \/\/  Java bytecodes\n-  \/\/  bytecode               bytecode name           format   wide f.   result tp  stk traps\n-  def(_nop                 , \"nop\"                 , \"b\"    , nullptr    , T_VOID   ,  0, false);\n-  def(_aconst_null         , \"aconst_null\"         , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n-  def(_iconst_m1           , \"iconst_m1\"           , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iconst_0            , \"iconst_0\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iconst_1            , \"iconst_1\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iconst_2            , \"iconst_2\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iconst_3            , \"iconst_3\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iconst_4            , \"iconst_4\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iconst_5            , \"iconst_5\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_lconst_0            , \"lconst_0\"            , \"b\"    , nullptr    , T_LONG   ,  2, false);\n-  def(_lconst_1            , \"lconst_1\"            , \"b\"    , nullptr    , T_LONG   ,  2, false);\n-  def(_fconst_0            , \"fconst_0\"            , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_fconst_1            , \"fconst_1\"            , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_fconst_2            , \"fconst_2\"            , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_dconst_0            , \"dconst_0\"            , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n-  def(_dconst_1            , \"dconst_1\"            , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n-  def(_bipush              , \"bipush\"              , \"bc\"   , nullptr    , T_INT    ,  1, false);\n-  def(_sipush              , \"sipush\"              , \"bcc\"  , nullptr    , T_INT    ,  1, false);\n-  def(_ldc                 , \"ldc\"                 , \"bk\"   , nullptr    , T_ILLEGAL,  1, true );\n-  def(_ldc_w               , \"ldc_w\"               , \"bkk\"  , nullptr    , T_ILLEGAL,  1, true );\n-  def(_ldc2_w              , \"ldc2_w\"              , \"bkk\"  , nullptr    , T_ILLEGAL,  2, true );\n-  def(_iload               , \"iload\"               , \"bi\"   , \"wbii\"     , T_INT    ,  1, false);\n-  def(_lload               , \"lload\"               , \"bi\"   , \"wbii\"     , T_LONG   ,  2, false);\n-  def(_fload               , \"fload\"               , \"bi\"   , \"wbii\"     , T_FLOAT  ,  1, false);\n-  def(_dload               , \"dload\"               , \"bi\"   , \"wbii\"     , T_DOUBLE ,  2, false);\n-  def(_aload               , \"aload\"               , \"bi\"   , \"wbii\"     , T_OBJECT ,  1, false);\n-  def(_iload_0             , \"iload_0\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iload_1             , \"iload_1\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iload_2             , \"iload_2\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_iload_3             , \"iload_3\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n-  def(_lload_0             , \"lload_0\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n-  def(_lload_1             , \"lload_1\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n-  def(_lload_2             , \"lload_2\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n-  def(_lload_3             , \"lload_3\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n-  def(_fload_0             , \"fload_0\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_fload_1             , \"fload_1\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_fload_2             , \"fload_2\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_fload_3             , \"fload_3\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n-  def(_dload_0             , \"dload_0\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n-  def(_dload_1             , \"dload_1\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n-  def(_dload_2             , \"dload_2\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n-  def(_dload_3             , \"dload_3\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n-  def(_aload_0             , \"aload_0\"             , \"b\"    , nullptr    , T_OBJECT ,  1, true ); \/\/ rewriting in interpreter\n-  def(_aload_1             , \"aload_1\"             , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n-  def(_aload_2             , \"aload_2\"             , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n-  def(_aload_3             , \"aload_3\"             , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n-  def(_iaload              , \"iaload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n-  def(_laload              , \"laload\"              , \"b\"    , nullptr    , T_LONG   ,  0, true );\n-  def(_faload              , \"faload\"              , \"b\"    , nullptr    , T_FLOAT  , -1, true );\n-  def(_daload              , \"daload\"              , \"b\"    , nullptr    , T_DOUBLE ,  0, true );\n-  def(_aaload              , \"aaload\"              , \"b\"    , nullptr    , T_OBJECT , -1, true );\n-  def(_baload              , \"baload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n-  def(_caload              , \"caload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n-  def(_saload              , \"saload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n-  def(_istore              , \"istore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -1, false);\n-  def(_lstore              , \"lstore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -2, false);\n-  def(_fstore              , \"fstore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -1, false);\n-  def(_dstore              , \"dstore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -2, false);\n-  def(_astore              , \"astore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -1, false);\n-  def(_istore_0            , \"istore_0\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_istore_1            , \"istore_1\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_istore_2            , \"istore_2\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_istore_3            , \"istore_3\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_lstore_0            , \"lstore_0\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_lstore_1            , \"lstore_1\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_lstore_2            , \"lstore_2\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_lstore_3            , \"lstore_3\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_fstore_0            , \"fstore_0\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_fstore_1            , \"fstore_1\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_fstore_2            , \"fstore_2\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_fstore_3            , \"fstore_3\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_dstore_0            , \"dstore_0\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_dstore_1            , \"dstore_1\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_dstore_2            , \"dstore_2\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_dstore_3            , \"dstore_3\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_astore_0            , \"astore_0\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_astore_1            , \"astore_1\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_astore_2            , \"astore_2\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_astore_3            , \"astore_3\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_iastore             , \"iastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n-  def(_lastore             , \"lastore\"             , \"b\"    , nullptr    , T_VOID   , -4, true );\n-  def(_fastore             , \"fastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n-  def(_dastore             , \"dastore\"             , \"b\"    , nullptr    , T_VOID   , -4, true );\n-  def(_aastore             , \"aastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n-  def(_bastore             , \"bastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n-  def(_castore             , \"castore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n-  def(_sastore             , \"sastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n-  def(_pop                 , \"pop\"                 , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_pop2                , \"pop2\"                , \"b\"    , nullptr    , T_VOID   , -2, false);\n-  def(_dup                 , \"dup\"                 , \"b\"    , nullptr    , T_VOID   ,  1, false);\n-  def(_dup_x1              , \"dup_x1\"              , \"b\"    , nullptr    , T_VOID   ,  1, false);\n-  def(_dup_x2              , \"dup_x2\"              , \"b\"    , nullptr    , T_VOID   ,  1, false);\n-  def(_dup2                , \"dup2\"                , \"b\"    , nullptr    , T_VOID   ,  2, false);\n-  def(_dup2_x1             , \"dup2_x1\"             , \"b\"    , nullptr    , T_VOID   ,  2, false);\n-  def(_dup2_x2             , \"dup2_x2\"             , \"b\"    , nullptr    , T_VOID   ,  2, false);\n-  def(_swap                , \"swap\"                , \"b\"    , nullptr    , T_VOID   ,  0, false);\n-  def(_iadd                , \"iadd\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_ladd                , \"ladd\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n-  def(_fadd                , \"fadd\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_dadd                , \"dadd\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n-  def(_isub                , \"isub\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lsub                , \"lsub\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n-  def(_fsub                , \"fsub\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_dsub                , \"dsub\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n-  def(_imul                , \"imul\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lmul                , \"lmul\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n-  def(_fmul                , \"fmul\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_dmul                , \"dmul\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n-  def(_idiv                , \"idiv\"                , \"b\"    , nullptr    , T_INT    , -1, true );\n-  def(_ldiv                , \"ldiv\"                , \"b\"    , nullptr    , T_LONG   , -2, true );\n-  def(_fdiv                , \"fdiv\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_ddiv                , \"ddiv\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n-  def(_irem                , \"irem\"                , \"b\"    , nullptr    , T_INT    , -1, true );\n-  def(_lrem                , \"lrem\"                , \"b\"    , nullptr    , T_LONG   , -2, true );\n-  def(_frem                , \"frem\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_drem                , \"drem\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n-  def(_ineg                , \"ineg\"                , \"b\"    , nullptr    , T_INT    ,  0, false);\n-  def(_lneg                , \"lneg\"                , \"b\"    , nullptr    , T_LONG   ,  0, false);\n-  def(_fneg                , \"fneg\"                , \"b\"    , nullptr    , T_FLOAT  ,  0, false);\n-  def(_dneg                , \"dneg\"                , \"b\"    , nullptr    , T_DOUBLE ,  0, false);\n-  def(_ishl                , \"ishl\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lshl                , \"lshl\"                , \"b\"    , nullptr    , T_LONG   , -1, false);\n-  def(_ishr                , \"ishr\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lshr                , \"lshr\"                , \"b\"    , nullptr    , T_LONG   , -1, false);\n-  def(_iushr               , \"iushr\"               , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lushr               , \"lushr\"               , \"b\"    , nullptr    , T_LONG   , -1, false);\n-  def(_iand                , \"iand\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_land                , \"land\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n-  def(_ior                 , \"ior\"                 , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lor                 , \"lor\"                 , \"b\"    , nullptr    , T_LONG   , -2, false);\n-  def(_ixor                , \"ixor\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_lxor                , \"lxor\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n-  def(_iinc                , \"iinc\"                , \"bic\"  , \"wbiicc\",    T_VOID   ,  0, false);\n-  def(_i2l                 , \"i2l\"                 , \"b\"    , nullptr    , T_LONG   ,  1, false);\n-  def(_i2f                 , \"i2f\"                 , \"b\"    , nullptr    , T_FLOAT  ,  0, false);\n-  def(_i2d                 , \"i2d\"                 , \"b\"    , nullptr    , T_DOUBLE ,  1, false);\n-  def(_l2i                 , \"l2i\"                 , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_l2f                 , \"l2f\"                 , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_l2d                 , \"l2d\"                 , \"b\"    , nullptr    , T_DOUBLE ,  0, false);\n-  def(_f2i                 , \"f2i\"                 , \"b\"    , nullptr    , T_INT    ,  0, false);\n-  def(_f2l                 , \"f2l\"                 , \"b\"    , nullptr    , T_LONG   ,  1, false);\n-  def(_f2d                 , \"f2d\"                 , \"b\"    , nullptr    , T_DOUBLE ,  1, false);\n-  def(_d2i                 , \"d2i\"                 , \"b\"    , nullptr    , T_INT    , -1, false);\n-  def(_d2l                 , \"d2l\"                 , \"b\"    , nullptr    , T_LONG   ,  0, false);\n-  def(_d2f                 , \"d2f\"                 , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n-  def(_i2b                 , \"i2b\"                 , \"b\"    , nullptr    , T_BYTE   ,  0, false);\n-  def(_i2c                 , \"i2c\"                 , \"b\"    , nullptr    , T_CHAR   ,  0, false);\n-  def(_i2s                 , \"i2s\"                 , \"b\"    , nullptr    , T_SHORT  ,  0, false);\n-  def(_lcmp                , \"lcmp\"                , \"b\"    , nullptr    , T_VOID   , -3, false);\n-  def(_fcmpl               , \"fcmpl\"               , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_fcmpg               , \"fcmpg\"               , \"b\"    , nullptr    , T_VOID   , -1, false);\n-  def(_dcmpl               , \"dcmpl\"               , \"b\"    , nullptr    , T_VOID   , -3, false);\n-  def(_dcmpg               , \"dcmpg\"               , \"b\"    , nullptr    , T_VOID   , -3, false);\n-  def(_ifeq                , \"ifeq\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_ifne                , \"ifne\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_iflt                , \"iflt\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_ifge                , \"ifge\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_ifgt                , \"ifgt\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_ifle                , \"ifle\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_if_icmpeq           , \"if_icmpeq\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_icmpne           , \"if_icmpne\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_icmplt           , \"if_icmplt\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_icmpge           , \"if_icmpge\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_icmpgt           , \"if_icmpgt\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_icmple           , \"if_icmple\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_acmpeq           , \"if_acmpeq\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_if_acmpne           , \"if_acmpne\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n-  def(_goto                , \"goto\"                , \"boo\"  , nullptr    , T_VOID   ,  0, false);\n-  def(_jsr                 , \"jsr\"                 , \"boo\"  , nullptr    , T_INT    ,  0, false);\n-  def(_ret                 , \"ret\"                 , \"bi\"   , \"wbii\"     , T_VOID   ,  0, false);\n-  def(_tableswitch         , \"tableswitch\"         , \"\"     , nullptr    , T_VOID   , -1, false); \/\/ may have backward branches\n-  def(_lookupswitch        , \"lookupswitch\"        , \"\"     , nullptr    , T_VOID   , -1, false); \/\/ rewriting in interpreter\n-  def(_ireturn             , \"ireturn\"             , \"b\"    , nullptr    , T_INT    , -1, true);\n-  def(_lreturn             , \"lreturn\"             , \"b\"    , nullptr    , T_LONG   , -2, true);\n-  def(_freturn             , \"freturn\"             , \"b\"    , nullptr    , T_FLOAT  , -1, true);\n-  def(_dreturn             , \"dreturn\"             , \"b\"    , nullptr    , T_DOUBLE , -2, true);\n-  def(_areturn             , \"areturn\"             , \"b\"    , nullptr    , T_OBJECT , -1, true);\n-  def(_return              , \"return\"              , \"b\"    , nullptr    , T_VOID   ,  0, true);\n-  def(_getstatic           , \"getstatic\"           , \"bJJ\"  , nullptr    , T_ILLEGAL,  1, true );\n-  def(_putstatic           , \"putstatic\"           , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true );\n-  def(_getfield            , \"getfield\"            , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true );\n-  def(_putfield            , \"putfield\"            , \"bJJ\"  , nullptr    , T_ILLEGAL, -2, true );\n-  def(_invokevirtual       , \"invokevirtual\"       , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true);\n-  def(_invokespecial       , \"invokespecial\"       , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true);\n-  def(_invokestatic        , \"invokestatic\"        , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true);\n-  def(_invokeinterface     , \"invokeinterface\"     , \"bJJ__\", nullptr    , T_ILLEGAL, -1, true);\n-  def(_invokedynamic       , \"invokedynamic\"       , \"bJJJJ\", nullptr    , T_ILLEGAL,  0, true );\n-  def(_new                 , \"new\"                 , \"bkk\"  , nullptr    , T_OBJECT ,  1, true );\n-  def(_newarray            , \"newarray\"            , \"bc\"   , nullptr    , T_OBJECT ,  0, true );\n-  def(_anewarray           , \"anewarray\"           , \"bkk\"  , nullptr    , T_OBJECT ,  0, true );\n-  def(_arraylength         , \"arraylength\"         , \"b\"    , nullptr    , T_INT    ,  0, true );\n-  def(_athrow              , \"athrow\"              , \"b\"    , nullptr    , T_VOID   , -1, true );\n-  def(_checkcast           , \"checkcast\"           , \"bkk\"  , nullptr    , T_OBJECT ,  0, true );\n-  def(_instanceof          , \"instanceof\"          , \"bkk\"  , nullptr    , T_INT    ,  0, true );\n-  def(_monitorenter        , \"monitorenter\"        , \"b\"    , nullptr    , T_VOID   , -1, true );\n-  def(_monitorexit         , \"monitorexit\"         , \"b\"    , nullptr    , T_VOID   , -1, true );\n-  def(_wide                , \"wide\"                , \"\"     , nullptr    , T_VOID   ,  0, false);\n-  def(_multianewarray      , \"multianewarray\"      , \"bkkc\" , nullptr    , T_OBJECT ,  1, true );\n-  def(_ifnull              , \"ifnull\"              , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_ifnonnull           , \"ifnonnull\"           , \"boo\"  , nullptr    , T_VOID   , -1, false);\n-  def(_goto_w              , \"goto_w\"              , \"boooo\", nullptr    , T_VOID   ,  0, false);\n-  def(_jsr_w               , \"jsr_w\"               , \"boooo\", nullptr    , T_INT    ,  0, false);\n-  def(_breakpoint          , \"breakpoint\"          , \"\"     , nullptr    , T_VOID   ,  0, true);\n-  def(_aconst_init         , \"aconst_ init\"        , \"bkk\"  , nullptr    , T_OBJECT ,  1, true);\n-  def(_withfield           , \"withfield\"           , \"bJJ\"  , nullptr    , T_OBJECT , -1, true);\n-\n-  \/\/  JVM bytecodes\n-  \/\/  bytecode               bytecode name           format   wide f.   result tp  stk traps  std code\n-\n-  def(_fast_agetfield      , \"fast_agetfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield       );\n-  def(_fast_qgetfield      , \"fast_qgetfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield       );\n-  def(_fast_bgetfield      , \"fast_bgetfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _getfield       );\n-  def(_fast_cgetfield      , \"fast_cgetfield\"      , \"bJJ\"  , nullptr    , T_CHAR   ,  0, true , _getfield       );\n-  def(_fast_dgetfield      , \"fast_dgetfield\"      , \"bJJ\"  , nullptr    , T_DOUBLE ,  0, true , _getfield       );\n-  def(_fast_fgetfield      , \"fast_fgetfield\"      , \"bJJ\"  , nullptr    , T_FLOAT  ,  0, true , _getfield       );\n-  def(_fast_igetfield      , \"fast_igetfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _getfield       );\n-  def(_fast_lgetfield      , \"fast_lgetfield\"      , \"bJJ\"  , nullptr    , T_LONG   ,  0, true , _getfield       );\n-  def(_fast_sgetfield      , \"fast_sgetfield\"      , \"bJJ\"  , nullptr    , T_SHORT  ,  0, true , _getfield       );\n-\n-  def(_fast_aputfield      , \"fast_aputfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield       );\n-  def(_fast_qputfield      , \"fast_qputfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield       );\n-  def(_fast_bputfield      , \"fast_bputfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield       );\n-  def(_fast_zputfield      , \"fast_zputfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield       );\n-  def(_fast_cputfield      , \"fast_cputfield\"      , \"bJJ\"  , nullptr    , T_CHAR   ,  0, true , _putfield       );\n-  def(_fast_dputfield      , \"fast_dputfield\"      , \"bJJ\"  , nullptr    , T_DOUBLE ,  0, true , _putfield       );\n-  def(_fast_fputfield      , \"fast_fputfield\"      , \"bJJ\"  , nullptr    , T_FLOAT  ,  0, true , _putfield       );\n-  def(_fast_iputfield      , \"fast_iputfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield       );\n-  def(_fast_lputfield      , \"fast_lputfield\"      , \"bJJ\"  , nullptr    , T_LONG   ,  0, true , _putfield       );\n-  def(_fast_sputfield      , \"fast_sputfield\"      , \"bJJ\"  , nullptr    , T_SHORT  ,  0, true , _putfield       );\n-\n-  def(_fast_aload_0        , \"fast_aload_0\"        , \"b\"    , nullptr    , T_OBJECT ,  1, true , _aload_0        );\n-  def(_fast_iaccess_0      , \"fast_iaccess_0\"      , \"b_JJ\" , nullptr    , T_INT    ,  1, true , _aload_0        );\n-  def(_fast_aaccess_0      , \"fast_aaccess_0\"      , \"b_JJ\" , nullptr    , T_OBJECT ,  1, true , _aload_0        );\n-  def(_fast_faccess_0      , \"fast_faccess_0\"      , \"b_JJ\" , nullptr    , T_OBJECT ,  1, true , _aload_0        );\n-\n-  def(_fast_iload          , \"fast_iload\"          , \"bi\"   , nullptr    , T_INT    ,  1, false, _iload);\n-  def(_fast_iload2         , \"fast_iload2\"         , \"bi_i\" , nullptr    , T_INT    ,  2, false, _iload);\n-  def(_fast_icaload        , \"fast_icaload\"        , \"bi_\"  , nullptr    , T_INT    ,  0, false, _iload);\n-\n-  \/\/ Faster method invocation.\n-  def(_fast_invokevfinal   , \"fast_invokevfinal\"   , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true, _invokevirtual   );\n-\n-  def(_fast_linearswitch   , \"fast_linearswitch\"   , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch   );\n-  def(_fast_binaryswitch   , \"fast_binaryswitch\"   , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch   );\n-\n-  def(_return_register_finalizer , \"return_register_finalizer\" , \"b\"     , nullptr    , T_VOID   ,  0, true, _return);\n-\n-  def(_invokehandle        , \"invokehandle\"        , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true, _invokevirtual   );\n-\n-  def(_fast_aldc           , \"fast_aldc\"           , \"bj\"   , nullptr    , T_OBJECT,   1, true,  _ldc   );\n-  def(_fast_aldc_w         , \"fast_aldc_w\"         , \"bJJ\"  , nullptr    , T_OBJECT,   1, true,  _ldc_w );\n-\n-  def(_nofast_getfield     , \"nofast_getfield\"     , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true,  _getfield       );\n-  def(_nofast_putfield     , \"nofast_putfield\"     , \"bJJ\"  , nullptr    , T_ILLEGAL, -2, true , _putfield       );\n-\n-  def(_nofast_aload_0      , \"nofast_aload_0\"      , \"b\"    , nullptr    , T_OBJECT,   1, true , _aload_0        );\n-  def(_nofast_iload        , \"nofast_iload\"        , \"bi\"   , nullptr    , T_INT,      1, false, _iload          );\n-\n-  def(_shouldnotreachhere  , \"_shouldnotreachhere\" , \"b\"    , nullptr    , T_VOID   ,  0, false);\n+#define BYTECODE(code, name, format, wide_format, result_type, depth, can_trap, java_code)  \\\n+  assert(strcmp(_name[code], name) == 0, \"bytecode name mismatch\");                         \\\n+  assert(_result_type[code] == result_type, \"bytecode result_type mismatch\");               \\\n+  assert(_depth[code] == depth, \"bytecode depth mismatch\");                                 \\\n+  assert(_lengths[code] == ((STRING_SIZE(wide_format) << 4) | (STRING_SIZE(format) & 0xF)), \\\n+         \"bytecode lengths mismatch\");                                                      \\\n+  assert(_java_code[code] == java_code, \"bytecode java_code mismatch\");                     \\\n+  def_flags(code, format, wide_format, can_trap, java_code);\n+  BYTECODES_DO(BYTECODE)\n+#undef BYTECODE\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":322,"deletions":287,"binary":false,"changes":609,"status":"modified"},{"patch":"@@ -316,0 +316,2 @@\n+  static_assert(number_of_codes <= 256, \"too many bytecodes\");\n+\n@@ -346,7 +348,7 @@\n-  static bool        _is_initialized;\n-  static const char* _name          [number_of_codes];\n-  static BasicType   _result_type   [number_of_codes];\n-  static s_char      _depth         [number_of_codes];\n-  static u_char      _lengths       [number_of_codes];\n-  static Code        _java_code     [number_of_codes];\n-  static jchar       _flags         [(1<<BitsPerByte)*2]; \/\/ all second page for wide formats\n+  static       bool        _is_initialized;\n+  static const char* const _name       [number_of_codes];\n+  static const BasicType   _result_type[number_of_codes];\n+  static const s_char      _depth      [number_of_codes];\n+  static const u_char      _lengths    [number_of_codes];\n+  static const Code        _java_code  [number_of_codes];\n+  static       jchar       _flags      [(1<<BitsPerByte)*2]; \/\/ all second page for wide formats\n@@ -354,2 +356,1 @@\n-  static void        def(Code code, const char* name, const char* format, const char* wide_format, BasicType result_type, int depth, bool can_trap);\n-  static void        def(Code code, const char* name, const char* format, const char* wide_format, BasicType result_type, int depth, bool can_trap, Code java_code);\n+  static void def_flags(Code code, const char* format, const char* wide_format, bool can_trap, Code java_code);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1213,2 +1213,1 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = pool->invokedynamic_cp_cache_entry_at(index);\n-  cp_cache_entry->set_dynamic_call(pool, info);\n+  pool->cache()->set_dynamic_call(info, pool->decode_invokedynamic_index(index));\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1797,2 +1797,2 @@\n-  ConstantPoolCacheEntry* cpce = pool->invokedynamic_cp_cache_entry_at(indy_index);\n-  int pool_index = cpce->constant_pool_index();\n+  int index = pool->decode_invokedynamic_index(indy_index);\n+  int pool_index = pool->resolved_indy_entry_at(index)->constant_pool_index();\n@@ -1801,1 +1801,1 @@\n-  BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n+  BootstrapInfo bootstrap_specifier(pool, pool_index, index);\n@@ -1813,2 +1813,2 @@\n-  \/\/ method's CP index for the CONSTANT_MethodHandle_info.  So, there is no need to\n-  \/\/ set the indy_rf flag since any subsequent invokedynamic instruction which shares\n+  \/\/ method's CP index for the CONSTANT_MethodHandle_info.\n+  \/\/ Any subsequent invokedynamic instruction which shares\n@@ -1827,2 +1827,2 @@\n-  \/\/ the relevant CPCE::f1 field.  This is done by the caller\n-  \/\/ of this method, via CPCE::set_dynamic_call, which uses\n+  \/\/ the relevant ResolvedIndyEntry::method field.  This is done by the caller\n+  \/\/ of this method, via CPC::set_dynamic_call, which uses\n@@ -1830,1 +1830,1 @@\n-  \/\/ to CPCE state, including f1.\n+  \/\/ to ResolvedIndyEntry state, including method.\n@@ -1861,9 +1861,9 @@\n-     bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);\n-     if (!recorded_res_status) {\n-       \/\/ Another thread got here just before we did.  So, either use the method\n-       \/\/ that it resolved or throw the LinkageError exception that it threw.\n-       bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);\n-       if (is_done) return;\n-     }\n-     assert(bootstrap_specifier.invokedynamic_cp_cache_entry()->indy_resolution_failed(),\n-            \"Resolution failure flag wasn't set\");\n+    bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);\n+    if (!recorded_res_status) {\n+      \/\/ Another thread got here just before we did.  So, either use the method\n+      \/\/ that it resolved or throw the LinkageError exception that it threw.\n+      bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);\n+      if (is_done) return;\n+    }\n+    assert(bootstrap_specifier.pool()->resolved_indy_entry_at(bootstrap_specifier.indy_index())->resolution_failed(),\n+          \"Resolution should have failed\");\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"oops\/constantPool.hpp\"\n@@ -102,2 +101,1 @@\n-                                  _invokedynamic_cp_cache_map,\n-                                  _invokedynamic_references_map, CHECK);\n+                                  _invokedynamic_references_map, _initialized_indy_entries, CHECK);\n@@ -271,6 +269,5 @@\n-    int cache_index = add_invokedynamic_cp_cache_entry(cp_index);\n-    int resolved_index = add_invokedynamic_resolved_references_entry(cp_index, cache_index);\n-    \/\/ Replace the trailing four bytes with a CPC index for the dynamic\n-    \/\/ call site.  Unlike other CPC entries, there is one per bytecode,\n-    \/\/ not just one per distinct CP entry.  In other words, the\n-    \/\/ CPC-to-CP relation is many-to-one for invokedynamic entries.\n+    int resolved_index = add_invokedynamic_resolved_references_entry(cp_index, -1); \/\/ Indy no longer has a CPCE\n+    \/\/ Replace the trailing four bytes with an index to the array of\n+    \/\/ indy resolution information in the CPC. There is one entry for\n+    \/\/ each bytecode, even if they make the same call. In other words,\n+    \/\/ the CPC-to-CP relation is many-to-one for invokedynamic entries.\n@@ -282,5 +279,5 @@\n-    Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(cache_index));\n-    \/\/ add the bcp in case we need to patch this bytecode if we also find a\n-    \/\/ invokespecial\/InterfaceMethodref in the bytecode stream\n-    _patch_invokedynamic_bcps->push(p);\n-    _patch_invokedynamic_refs->push(resolved_index);\n+    Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(_invokedynamic_index));\n+    _invokedynamic_index++;\n+\n+    \/\/ Collect invokedynamic information before creating ResolvedInvokeDynamicInfo array\n+    _initialized_indy_entries.push(ResolvedIndyEntry((u2)resolved_index, (u2)cp_index));\n@@ -288,0 +285,1 @@\n+    \/\/ Should do nothing since we are not patching this bytecode\n@@ -293,2 +291,1 @@\n-    int adjustment = cp_cache_delta() + _first_iteration_cp_cache_limit;\n-    int cp_index = invokedynamic_cp_cache_entry_pool_index(cache_index - adjustment);\n+    int cp_index = _initialized_indy_entries.at(cache_index).constant_pool_index();\n@@ -302,26 +299,0 @@\n-void Rewriter::patch_invokedynamic_bytecodes() {\n-  \/\/ If the end of the cp_cache is the same as after initializing with the\n-  \/\/ cpool, nothing needs to be done.  Invokedynamic bytecodes are at the\n-  \/\/ correct offsets. ie. no invokespecials added\n-  int delta = cp_cache_delta();\n-  if (delta > 0) {\n-    int length = _patch_invokedynamic_bcps->length();\n-    assert(length == _patch_invokedynamic_refs->length(),\n-           \"lengths should match\");\n-    for (int i = 0; i < length; i++) {\n-      address p = _patch_invokedynamic_bcps->at(i);\n-      int cache_index = ConstantPool::decode_invokedynamic_index(\n-                          Bytes::get_native_u4(p));\n-      Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(cache_index + delta));\n-\n-      \/\/ invokedynamic resolved references map also points to cp cache and must\n-      \/\/ add delta to each.\n-      int resolved_index = _patch_invokedynamic_refs->at(i);\n-        assert(_invokedynamic_references_map.at(resolved_index) == cache_index,\n-             \"should be the same index\");\n-        _invokedynamic_references_map.at_put(resolved_index, cache_index + delta);\n-    }\n-  }\n-}\n-\n-\n@@ -572,4 +543,0 @@\n-\n-  \/\/ May have to fix invokedynamic bytecodes if invokestatic\/InterfaceMethodref\n-  \/\/ entries had to be added.\n-  patch_invokedynamic_bytecodes();\n@@ -600,1 +567,1 @@\n-    _invokedynamic_cp_cache_map(cpool->length() \/ 4)\n+    _invokedynamic_index(0)\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":14,"deletions":47,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -269,0 +269,1 @@\n+  static void load_invokedynamic_entry(Register method);\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+void compiler_stubs_init(bool in_compiler_thread);\n+\n@@ -63,1 +65,1 @@\n-\n+  compiler_stubs_init(true \/* in_compiler_thread *\/); \/\/ generate compiler's intrinsics stubs\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -453,6 +453,1 @@\n-  JVMCIKlassHandle handle(THREAD);\n-  {\n-    \/\/ Need Compile_lock around implementor()\n-    MutexLocker locker(Compile_lock);\n-    handle = iklass->implementor();\n-  }\n+  JVMCIKlassHandle handle(THREAD, iklass->implementor());\n@@ -655,0 +650,7 @@\n+  \/\/ Get the indy entry based on CP index\n+  int indy_index = -1;\n+  for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n+    if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n+      indy_index = i;\n+    }\n+  }\n@@ -656,1 +658,1 @@\n-  BootstrapInfo bootstrap_specifier(cp, index);\n+  BootstrapInfo bootstrap_specifier(cp, index, indy_index);\n@@ -1481,1 +1483,5 @@\n-C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(int, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  if (!ConstantPool::is_invokedynamic_index(index)) {\n+    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an invokedynamic index %d\", index));\n+  }\n+\n@@ -1484,3 +1490,4 @@\n-  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);\n-  ConstantPoolCacheEntry* cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(index);\n-  cp_cache_entry->set_dynamic_call(cp, callInfo);\n+  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK_0);\n+  int indy_index = cp->decode_invokedynamic_index(index);\n+  cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  return cp->resolved_indy_entry_at(indy_index)->constant_pool_index();\n@@ -1535,2 +1542,4 @@\n-  if (cp_cache_entry->is_resolved(Bytecodes::_invokedynamic)) {\n-    return Bytecodes::_invokedynamic;\n+  if (cp->is_invokedynamic_index(index)) {\n+    if (cp->resolved_indy_entry_at(cp->decode_cpcache_index(index))->is_resolved()) {\n+      return Bytecodes::_invokedynamic;\n+    }\n@@ -2044,4 +2053,4 @@\n-    case T_BOOLEAN: value = obj->bool_field_acquire(displacement);  break;\n-    case T_BYTE:    value = obj->byte_field_acquire(displacement);  break;\n-    case T_SHORT:   value = obj->short_field_acquire(displacement); break;\n-    case T_CHAR:    value = obj->char_field_acquire(displacement);  break;\n+    case T_BOOLEAN: value = HeapAccess<MO_SEQ_CST>::load(obj->field_addr<jboolean>(displacement)); break;\n+    case T_BYTE:    value = HeapAccess<MO_SEQ_CST>::load(obj->field_addr<jbyte>(displacement));    break;\n+    case T_SHORT:   value = HeapAccess<MO_SEQ_CST>::load(obj->field_addr<jshort>(displacement));   break;\n+    case T_CHAR:    value = HeapAccess<MO_SEQ_CST>::load(obj->field_addr<jchar>(displacement));    break;\n@@ -2049,1 +2058,1 @@\n-    case T_INT:     value = obj->int_field_acquire(displacement);   break;\n+    case T_INT:     value = HeapAccess<MO_SEQ_CST>::load(obj->field_addr<jint>(displacement));     break;\n@@ -2051,1 +2060,1 @@\n-    case T_LONG:    value = obj->long_field_acquire(displacement);  break;\n+    case T_LONG:    value = HeapAccess<MO_SEQ_CST>::load(obj->field_addr<jlong>(displacement));    break;\n@@ -2061,1 +2070,3 @@\n-      oop value = obj->obj_field_acquire(displacement);\n+      \/\/ Perform the read including any barriers required to make the reference strongly reachable\n+      \/\/ since it will be wrapped as a JavaConstant.\n+      oop value = obj->obj_field_access<MO_SEQ_CST | ON_UNKNOWN_OOP_REF>(displacement);\n@@ -2664,3 +2675,1 @@\n-C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n-  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n-  Klass* klass = UNPACK_PAIR(Klass, klass);\n+static InstanceKlass* check_field(Klass* klass, jint index, JVMCI_TRAPS) {\n@@ -2676,0 +2685,7 @@\n+  return iklass;\n+}\n+\n+C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n+  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  InstanceKlass* iklass = check_field(klass, index, JVMCIENV);\n@@ -2681,0 +2697,82 @@\n+static jbyteArray get_encoded_annotation_data(InstanceKlass* holder, AnnotationArray* annotations_array, bool for_class,\n+                                              jint filter_length, jlong filter_klass_pointers,\n+                                              JavaThread* THREAD, JVMCIEnv* JVMCIENV) {\n+  \/\/ Get a ConstantPool object for annotation parsing\n+  Handle jcp = reflect_ConstantPool::create(CHECK_NULL);\n+  reflect_ConstantPool::set_cp(jcp(), holder->constants());\n+\n+  \/\/ load VMSupport\n+  Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+  Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+\n+  InstanceKlass* vm_support = InstanceKlass::cast(k);\n+  if (vm_support->should_be_initialized()) {\n+    vm_support->initialize(CHECK_NULL);\n+  }\n+\n+  typeArrayOop annotations_oop = Annotations::make_java_array(annotations_array, CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+\n+  InstanceKlass** filter = filter_length == 1 ?\n+      (InstanceKlass**) &filter_klass_pointers:\n+      (InstanceKlass**) filter_klass_pointers;\n+  objArrayOop filter_oop = oopFactory::new_objArray(vmClasses::Class_klass(), filter_length, CHECK_NULL);\n+  objArrayHandle filter_classes(THREAD, filter_oop);\n+  for (int i = 0; i < filter_length; i++) {\n+    filter_classes->obj_at_put(i, filter[i]->java_mirror());\n+  }\n+\n+  \/\/ invoke VMSupport.encodeAnnotations\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_oop(annotations);\n+  args.push_oop(Handle(THREAD, holder->java_mirror()));\n+  args.push_oop(jcp);\n+  args.push_int(for_class);\n+  args.push_oop(filter_classes);\n+  Symbol* signature = vmSymbols::encodeAnnotations_signature();\n+  JavaCalls::call_static(&result,\n+                         vm_support,\n+                         vmSymbols::encodeAnnotations_name(),\n+                         signature,\n+                         &args,\n+                         CHECK_NULL);\n+\n+  oop res = result.get_oop();\n+  if (JVMCIENV->is_hotspot()) {\n+    return (jbyteArray) JNIHandles::make_local(THREAD, res);\n+  }\n+\n+  typeArrayOop ba = typeArrayOop(res);\n+  int ba_len = ba->length();\n+  jbyte* ba_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jbyte, ba_len);\n+  if (ba_buf == nullptr) {\n+    JVMCI_THROW_MSG_NULL(InternalError,\n+              err_msg(\"could not allocate %d bytes\", ba_len));\n+\n+  }\n+  memcpy(ba_buf, ba->byte_at_addr(0), ba_len);\n+  JVMCIPrimitiveArray ba_dest = JVMCIENV->new_byteArray(ba_len, JVMCI_CHECK_NULL);\n+  JVMCIENV->copy_bytes_from(ba_buf, ba_dest, 0, ba_len);\n+  return JVMCIENV->get_jbyteArray(ba_dest);\n+}\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedClassAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = InstanceKlass::cast(UNPACK_PAIR(Klass, klass));\n+  return get_encoded_annotation_data(holder, holder->class_annotations(), true, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedExecutableAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  return get_encoded_annotation_data(method->method_holder(), method->annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedFieldAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index,\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = check_field(InstanceKlass::cast(UNPACK_PAIR(Klass, klass)), index, JVMCIENV);\n+  fieldDescriptor fd(holder, index);\n+  return get_encoded_annotation_data(holder, fd.annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n@@ -2884,1 +2982,1 @@\n-  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)V\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n+  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n@@ -2961,0 +3059,3 @@\n+  {CC \"getEncodedClassAnnotationData\",                CC \"(\" HS_KLASS2 OBJECT \"IJ)[B\",                                                      FN_PTR(getEncodedClassAnnotationData)},\n+  {CC \"getEncodedExecutableAnnotationData\",           CC \"(\" HS_METHOD2 OBJECT \"IJ)[B\",                                                     FN_PTR(getEncodedExecutableAnnotationData)},\n+  {CC \"getEncodedFieldAnnotationData\",                CC \"(\" HS_KLASS2 \"I\" OBJECT \"IJ)[B\",                                                  FN_PTR(getEncodedFieldAnnotationData)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":125,"deletions":24,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  nonstatic_field(Annotations,                 _class_annotations,                     AnnotationArray*)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  LOG_TAG(stubs) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+enum class derived_base : intptr_t;\n@@ -138,1 +139,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) = 0;\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) = 0;\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-  if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n+  if (ArchiveHeapLoader::is_in_use()) {\n@@ -327,1 +327,5 @@\n-  { AutoModifyRestore<bool> temporarily(_bootstrapping, true);\n+  \/\/ Explicit null checks are needed if these offsets are not smaller than the page size\n+  assert(oopDesc::klass_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n+         \"Klass offset is expected to be less than the page size\");\n+  assert(arrayOopDesc::length_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n+         \"Array length offset is expected to be less than the page size\");\n@@ -329,1 +333,1 @@\n-    { MutexLocker mc(THREAD, Compile_lock);\n+  { AutoModifyRestore<bool> temporarily(_bootstrapping, true);\n@@ -331,1 +335,1 @@\n-      java_lang_Class::allocate_fixup_lists();\n+    java_lang_Class::allocate_fixup_lists();\n@@ -333,2 +337,2 @@\n-      \/\/ determine base vtable size; without that we cannot create the array klasses\n-      compute_base_vtable_size();\n+    \/\/ determine base vtable size; without that we cannot create the array klasses\n+    compute_base_vtable_size();\n@@ -336,8 +340,8 @@\n-      if (!UseSharedSpaces) {\n-        \/\/ Initialization of the fillerArrayKlass must come before regular\n-        \/\/ int-TypeArrayKlass so that the int-Array mirror points to the\n-        \/\/ int-TypeArrayKlass.\n-        _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"Ljdk\/internal\/vm\/FillerArray;\", CHECK);\n-        for (int i = T_BOOLEAN; i < T_LONG+1; i++) {\n-          _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);\n-        }\n+    if (!UseSharedSpaces) {\n+      \/\/ Initialization of the fillerArrayKlass must come before regular\n+      \/\/ int-TypeArrayKlass so that the int-Array mirror points to the\n+      \/\/ int-TypeArrayKlass.\n+      _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"Ljdk\/internal\/vm\/FillerArray;\", CHECK);\n+      for (int i = T_BOOLEAN; i < T_LONG+1; i++) {\n+        _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);\n+      }\n@@ -345,1 +349,1 @@\n-        ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();\n+      ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();\n@@ -347,7 +351,6 @@\n-        _the_array_interfaces_array     = MetadataFactory::new_array<Klass*>(null_cld, 2, nullptr, CHECK);\n-        _the_empty_int_array            = MetadataFactory::new_array<int>(null_cld, 0, CHECK);\n-        _the_empty_short_array          = MetadataFactory::new_array<u2>(null_cld, 0, CHECK);\n-        _the_empty_method_array         = MetadataFactory::new_array<Method*>(null_cld, 0, CHECK);\n-        _the_empty_klass_array          = MetadataFactory::new_array<Klass*>(null_cld, 0, CHECK);\n-        _the_empty_instance_klass_array = MetadataFactory::new_array<InstanceKlass*>(null_cld, 0, CHECK);\n-      }\n+      _the_array_interfaces_array     = MetadataFactory::new_array<Klass*>(null_cld, 2, nullptr, CHECK);\n+      _the_empty_int_array            = MetadataFactory::new_array<int>(null_cld, 0, CHECK);\n+      _the_empty_short_array          = MetadataFactory::new_array<u2>(null_cld, 0, CHECK);\n+      _the_empty_method_array         = MetadataFactory::new_array<Method*>(null_cld, 0, CHECK);\n+      _the_empty_klass_array          = MetadataFactory::new_array<Klass*>(null_cld, 0, CHECK);\n+      _the_empty_instance_klass_array = MetadataFactory::new_array<InstanceKlass*>(null_cld, 0, CHECK);\n@@ -465,1 +468,1 @@\n-        ArchiveHeapLoader::are_archived_mirrors_available() &&\n+        ArchiveHeapLoader::is_in_use() &&\n@@ -823,4 +826,1 @@\n-    \/\/ system dictionary, symbol table, etc.).  After that, access to\n-    \/\/ the file (other than the mapped regions) is no longer needed, and\n-    \/\/ the file is closed. Closing the file does not affect the\n-    \/\/ currently mapped regions.\n+    \/\/ system dictionary, symbol table, etc.)\n@@ -828,11 +828,0 @@\n-    StringTable::create_table();\n-    if (ArchiveHeapLoader::is_loaded()) {\n-      StringTable::transfer_shared_strings_to_local_table();\n-    }\n-  } else\n-#endif\n-  {\n-    SymbolTable::create_table();\n-    StringTable::create_table();\n-\n-#if INCLUDE_CDS\n@@ -845,0 +834,3 @@\n+  SymbolTable::create_table();\n+  StringTable::create_table();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":30,"deletions":38,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+    HandleMark hm(THREAD);\n@@ -342,1 +343,1 @@\n-    if (ArchiveHeapLoader::is_fully_available() &&\n+    if (ArchiveHeapLoader::is_in_use() &&\n@@ -346,0 +347,1 @@\n+      HandleMark hm(THREAD);\n@@ -357,0 +359,1 @@\n+        HandleMark hm(THREAD);\n@@ -534,0 +537,1 @@\n+  HandleMark hm(THREAD);\n@@ -642,0 +646,1 @@\n+    HandleMark hm(current);\n@@ -683,3 +688,8 @@\n-  int cache_index = decode_cpcache_index(which, true);\n-  ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n-  return e->has_appendix();\n+  if (is_invokedynamic_index(which)) {\n+    int indy_index = decode_invokedynamic_index(which);\n+    return cpool->resolved_indy_entry_at(indy_index)->has_appendix();\n+  } else {\n+    int cache_index = decode_cpcache_index(which, true);\n+    ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n+    return e->has_appendix();\n+  }\n@@ -690,3 +700,8 @@\n-  int cache_index = decode_cpcache_index(which, true);\n-  ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n-  return e->appendix_if_resolved(cpool);\n+  if (is_invokedynamic_index(which)) {\n+    int indy_index = decode_invokedynamic_index(which);\n+    return cpool->resolved_reference_from_indy(indy_index);\n+  } else {\n+    int cache_index = decode_cpcache_index(which, true);\n+    ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n+    return e->appendix_if_resolved(cpool);\n+  }\n@@ -699,2 +714,6 @@\n-  ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n-  return e->has_local_signature();\n+  if (is_invokedynamic_index(which)) {\n+    return cpool->resolved_indy_entry_at(cache_index)->has_local_signature();\n+  } else {\n+    ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n+    return e->has_local_signature();\n+  }\n@@ -718,1 +737,1 @@\n-      \/\/ Invokedynamic index is index into the constant pool cache\n+      \/\/ Invokedynamic index is index into the resolved indy array in the constant pool cache\n@@ -975,1 +994,0 @@\n-  Handle throw_exception;\n@@ -1145,0 +1163,1 @@\n+      HandleMark hm(THREAD);\n@@ -1164,0 +1183,1 @@\n+      HandleMark hm(THREAD);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -259,14 +259,0 @@\n-\n-  \/\/ The invokedynamic points at a CP cache entry.  This entry points back\n-  \/\/ at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry\n-  \/\/ in the resolved_references array (which provides the appendix argument).\n-  int invokedynamic_cp_cache_index(int indy_index) const {\n-    assert(is_invokedynamic_index(indy_index), \"should be a invokedynamic index\");\n-    int cache_index = decode_invokedynamic_index(indy_index);\n-    return cache_index;\n-  }\n-  ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {\n-    \/\/ decode index that invokedynamic points to.\n-    int cp_cache_index = invokedynamic_cp_cache_index(indy_index);\n-    return cache()->entry_at(cp_cache_index);\n-  }\n@@ -277,1 +263,1 @@\n-    return invokedynamic_cp_cache_entry_at(indy_index)->constant_pool_index();\n+    return cache()->resolved_indy_entry_at(decode_invokedynamic_index(indy_index))->constant_pool_index();\n@@ -939,0 +925,11 @@\n+\n+  \/\/ ResolvedIndyEntry getters\n+  ResolvedIndyEntry* resolved_indy_entry_at(int index) {\n+    return cache()->resolved_indy_entry_at(index);\n+  }\n+  int resolved_indy_entries_length() {\n+    return cache()->resolved_indy_entries_length();\n+  }\n+  oop resolved_reference_from_indy(int index) {\n+    return resolved_references()->obj_at(cache()->resolved_indy_entry_at(index)->resolved_references_index());\n+  }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -352,4 +352,0 @@\n-void ConstantPoolCacheEntry::set_dynamic_call(const constantPoolHandle& cpool, const CallInfo &call_info) {\n-  set_method_handle_common(cpool, Bytecodes::_invokedynamic, call_info);\n-}\n-\n@@ -460,27 +456,0 @@\n-bool ConstantPoolCacheEntry::save_and_throw_indy_exc(\n-  const constantPoolHandle& cpool, int cpool_index, int index, constantTag tag, TRAPS) {\n-\n-  assert(HAS_PENDING_EXCEPTION, \"No exception got thrown!\");\n-  assert(PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass()),\n-         \"No LinkageError exception\");\n-\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n-\n-  \/\/ if f1 is not null or the indy_resolution_failed flag is set then another\n-  \/\/ thread either succeeded in resolving the method or got a LinkageError\n-  \/\/ exception, before this thread was able to record its failure.  So, clear\n-  \/\/ this thread's exception and return false so caller can use the earlier\n-  \/\/ thread's result.\n-  if (!is_f1_null() || indy_resolution_failed()) {\n-    CLEAR_PENDING_EXCEPTION;\n-    return false;\n-  }\n-\n-  Symbol* error = PENDING_EXCEPTION->klass()->name();\n-  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n-\n-  SystemDictionary::add_resolution_error(cpool, index, error, message);\n-  set_indy_resolution_failed();\n-  return true;\n-}\n-\n@@ -501,1 +470,0 @@\n-      case Bytecodes::_invokedynamic:\n@@ -504,0 +472,2 @@\n+      case Bytecodes::_invokedynamic:\n+        ShouldNotReachHere();\n@@ -653,2 +623,1 @@\n-    if (bytecode_1() == Bytecodes::_invokehandle ||\n-        bytecode_1() == Bytecodes::_invokedynamic) {\n+    if ((bytecode_1() == Bytecodes::_invokehandle)) {\n@@ -681,2 +650,3 @@\n-                                     const intStack& invokedynamic_index_map,\n-                                     const intStack& invokedynamic_map, TRAPS) {\n+                                     const intStack& invokedynamic_map,\n+                                     const GrowableArray<ResolvedIndyEntry> indy_entries,\n+                                     TRAPS) {\n@@ -684,1 +654,1 @@\n-  const int length = index_map.length() + invokedynamic_index_map.length();\n+  const int length = index_map.length();\n@@ -687,0 +657,11 @@\n+  \/\/ Initialize ResolvedIndyEntry array with available data\n+  Array<ResolvedIndyEntry>* resolved_indy_entries;\n+  if (indy_entries.length()) {\n+    resolved_indy_entries = MetadataFactory::new_array<ResolvedIndyEntry>(loader_data, indy_entries.length(), CHECK_NULL);\n+    for (int i = 0; i < indy_entries.length(); i++) {\n+      resolved_indy_entries->at_put(i, indy_entries.at(i));\n+    }\n+  } else {\n+    resolved_indy_entries = nullptr;\n+  }\n+\n@@ -688,1 +669,1 @@\n-    ConstantPoolCache(length, index_map, invokedynamic_index_map, invokedynamic_map);\n+              ConstantPoolCache(length, index_map, invokedynamic_map, resolved_indy_entries);\n@@ -692,1 +673,0 @@\n-                                   const intArray& invokedynamic_inverse_index_map,\n@@ -701,10 +681,0 @@\n-  \/\/ Append invokedynamic entries at the end\n-  int invokedynamic_offset = inverse_index_map.length();\n-  for (int i = 0; i < invokedynamic_inverse_index_map.length(); i++) {\n-    int offset = i + invokedynamic_offset;\n-    ConstantPoolCacheEntry* e = entry_at(offset);\n-    int original_index = invokedynamic_inverse_index_map.at(i);\n-    e->initialize_entry(original_index);\n-    assert(entry_at(offset) == e, \"sanity\");\n-  }\n-\n@@ -746,0 +716,6 @@\n+\n+  if (_resolved_indy_entries != nullptr) {\n+    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+      resolved_indy_entry_at(i)->remove_unshareable_info();\n+    }\n+  }\n@@ -759,0 +735,2 @@\n+    if (_resolved_indy_entries)\n+      MetadataFactory::free_array<ResolvedIndyEntry>(data, _resolved_indy_entries);\n@@ -790,0 +768,11 @@\n+  if (_resolved_indy_entries != nullptr) {\n+    for (int j = 0; j < _resolved_indy_entries->length(); j++) {\n+      Method* old_method = resolved_indy_entry_at(j)->method();\n+      if (old_method == nullptr || !old_method->is_old()) {\n+        continue;\n+      }\n+      Method* new_method = old_method->get_new_method();\n+      resolved_indy_entry_at(j)->adjust_method_entry(new_method);\n+      log_adjust(\"indy\", old_method, new_method, trace_name_printed);\n+    }\n+  }\n@@ -809,0 +798,12 @@\n+  if (_resolved_indy_entries) {\n+    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+      Method* m = resolved_indy_entry_at(i)->method();\n+      if (m != nullptr && !resolved_indy_entry_at(i)->check_no_old_or_obsolete_entry()) {\n+        log_trace(redefine, class, update, constantpool)\n+          (\"cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s\",\n+           constant_pool()->pool_holder()->external_name(), m->is_old(), m->is_obsolete(), m->external_name());\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -834,0 +835,89 @@\n+  if (_resolved_indy_entries != nullptr) {\n+    it->push(&_resolved_indy_entries, MetaspaceClosure::_writable);\n+  }\n+}\n+\n+bool ConstantPoolCache::save_and_throw_indy_exc(\n+  const constantPoolHandle& cpool, int cpool_index, int index, constantTag tag, TRAPS) {\n+\n+  assert(HAS_PENDING_EXCEPTION, \"No exception got thrown!\");\n+  assert(PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass()),\n+         \"No LinkageError exception\");\n+\n+  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+\n+  \/\/ if the indy_info is resolved or the indy_resolution_failed flag is set then another\n+  \/\/ thread either succeeded in resolving the method or got a LinkageError\n+  \/\/ exception, before this thread was able to record its failure.  So, clear\n+  \/\/ this thread's exception and return false so caller can use the earlier\n+  \/\/ thread's result.\n+  if (resolved_indy_entry_at(index)->is_resolved() || resolved_indy_entry_at(index)->resolution_failed()) {\n+    CLEAR_PENDING_EXCEPTION;\n+    return false;\n+  }\n+\n+  Symbol* error = PENDING_EXCEPTION->klass()->name();\n+  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n+\n+  int encoded_index = ResolutionErrorTable::encode_cpcache_index(\n+                          ConstantPool::encode_invokedynamic_index(index));\n+  SystemDictionary::add_resolution_error(cpool, encoded_index, error, message);\n+  resolved_indy_entry_at(index)->set_resolution_failed();\n+  return true;\n+}\n+\n+oop ConstantPoolCache::set_dynamic_call(const CallInfo &call_info, int index) {\n+  ResourceMark rm;\n+  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+  assert(index >= 0, \"Indy index must be positive at this point\");\n+\n+  if (resolved_indy_entry_at(index)->method() != nullptr) {\n+    return constant_pool()->resolved_reference_from_indy(index);\n+  }\n+\n+  if (resolved_indy_entry_at(index)->resolution_failed()) {\n+    \/\/ Before we got here, another thread got a LinkageError exception during\n+    \/\/ resolution.  Ignore our success and throw their exception.\n+    guarantee(index >= 0, \"Invalid indy index\");\n+    int encoded_index = ResolutionErrorTable::encode_cpcache_index(\n+                          ConstantPool::encode_invokedynamic_index(index));\n+    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+    constantPoolHandle cp(THREAD, constant_pool());\n+    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    return nullptr;\n+  }\n+\n+  Method* adapter            = call_info.resolved_method();\n+  const Handle appendix      = call_info.resolved_appendix();\n+  const bool has_appendix    = appendix.not_null();\n+\n+  LogStream* log_stream = NULL;\n+  LogStreamHandle(Debug, methodhandles, indy) lsh_indy;\n+  if (lsh_indy.is_enabled()) {\n+    ResourceMark rm;\n+    log_stream = &lsh_indy;\n+    log_stream->print_cr(\"set_method_handle bc=%d appendix=\" PTR_FORMAT \"%s method=\" PTR_FORMAT \" (local signature) \",\n+                         0xba,\n+                         p2i(appendix()),\n+                         (has_appendix ? \"\" : \" (unused)\"),\n+                         p2i(adapter));\n+    adapter->print_on(log_stream);\n+    if (has_appendix)  appendix()->print_on(log_stream);\n+  }\n+\n+  if (has_appendix) {\n+    const int appendix_index = resolved_indy_entry_at(index)->resolved_references_index();\n+    objArrayOop resolved_references = constant_pool()->resolved_references();\n+    assert(appendix_index >= 0 && appendix_index < resolved_references->length(), \"oob\");\n+    assert(resolved_references->obj_at(appendix_index) == NULL, \"init just once\");\n+    resolved_references->obj_at_put(appendix_index, appendix());\n+  }\n+\n+  \/\/ Populate entry with resolved information\n+  assert(resolved_indy_entries() != nullptr, \"Invokedynamic array is empty, cannot fill with resolved information\");\n+  resolved_indy_entry_at(index)->fill_in(adapter, adapter->size_of_parameters(), as_TosState(adapter->result_type()), has_appendix);\n+\n+  if (log_stream != NULL) {\n+    resolved_indy_entry_at(index)->print_on(log_stream);\n+  }\n+  return appendix();\n@@ -842,0 +932,8 @@\n+  for (int i = 0; i < resolved_indy_entries_length(); i++) {\n+    ResolvedIndyEntry* indy_entry = resolved_indy_entry_at(i);\n+    indy_entry->print_on(st);\n+    if (indy_entry->has_appendix()) {\n+      st->print(\"  appendix: \");\n+      constant_pool()->resolved_reference_from_indy(i)->print_on(st);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":147,"deletions":49,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/resolvedIndyEntry.hpp\"\n@@ -265,5 +266,0 @@\n-  void set_dynamic_call(\n-    const constantPoolHandle& cpool,             \/\/ holding constant pool (required for locking)\n-    const CallInfo &call_info                    \/\/ Call link information\n-  );\n-\n@@ -291,7 +287,0 @@\n-  \/\/ Return TRUE if resolution failed and this thread got to record the failure\n-  \/\/ status.  Return FALSE if another thread succeeded or failed in resolving\n-  \/\/ the method and recorded the success or failure before this thread had a\n-  \/\/ chance to record its failure.\n-  bool save_and_throw_indy_exc(const constantPoolHandle& cpool, int cpool_index,\n-                               int index, constantTag tag, TRAPS);\n-\n@@ -430,0 +419,2 @@\n+  Array<ResolvedIndyEntry>* _resolved_indy_entries;\n+\n@@ -438,2 +429,2 @@\n-                    const intStack& invokedynamic_inverse_index_map,\n-                    const intStack& invokedynamic_references_map);\n+                    const intStack& invokedynamic_references_map,\n+                    Array<ResolvedIndyEntry>* indy_info);\n@@ -443,1 +434,0 @@\n-                  const intArray& invokedynamic_inverse_index_map,\n@@ -448,2 +438,3 @@\n-                                     const intStack& invokedynamic_cp_cache_map,\n-                                     const intStack& invokedynamic_references_map, TRAPS);\n+                                     const intStack& invokedynamic_references_map,\n+                                     const GrowableArray<ResolvedIndyEntry> indy_entries,\n+                                     TRAPS);\n@@ -464,0 +455,9 @@\n+  Array<ResolvedIndyEntry>* resolved_indy_entries()          { return _resolved_indy_entries; }\n+  ResolvedIndyEntry* resolved_indy_entry_at(int index) const { return _resolved_indy_entries->adr_at(index); }\n+  int resolved_indy_entries_length()                   const { return _resolved_indy_entries->length();      }\n+  void print_resolved_indy_entries(outputStream* st)   const {\n+    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+        _resolved_indy_entries->at(i).print_on(st);\n+    }\n+  }\n+\n@@ -466,0 +466,1 @@\n+  static ByteSize invokedynamic_entries_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries); }\n@@ -525,0 +526,7 @@\n+  \/\/ Return TRUE if resolution failed and this thread got to record the failure\n+  \/\/ status.  Return FALSE if another thread succeeded or failed in resolving\n+  \/\/ the method and recorded the success or failure before this thread had a\n+  \/\/ chance to record its failure.\n+  bool save_and_throw_indy_exc(const constantPoolHandle& cpool, int cpool_index, int index, constantTag tag, TRAPS);\n+  oop set_dynamic_call(const CallInfo &call_info, int index);\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1400,0 +1400,40 @@\n+\/\/ Update hierarchy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n+\/\/ is grabbed, to ensure that the compiler is not using the class hierarchy.\n+void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"must NOT be at safepoint\");\n+\n+  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n+  \/\/ deopt is completed before anyone links this class.\n+  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n+  \/\/ held we make sure the deopt is completed before linking.\n+  if (!UseVtableBasedCHA) {\n+    init_monitor()->lock();\n+  }\n+\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker ml(current, Compile_lock);\n+\n+    set_init_state(InstanceKlass::loaded);\n+    \/\/ make sure init_state store is already done.\n+    \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n+    \/\/ Access ordering is used to add to hierarchy.\n+\n+    \/\/ Link into hierarchy.\n+    append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n+    process_interfaces();                        \/\/ handle all \"implements\" declarations\n+\n+    \/\/ Now mark all code that depended on old class hierarchy.\n+    \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n+    if (Universe::is_fully_initialized()) {\n+      CodeCache::mark_dependents_on(&deopt_scope, this);\n+    }\n+  }\n+  \/\/ Perform the deopt handshake outside Compile_lock.\n+  deopt_scope.deoptimize_marked();\n+\n+  if (!UseVtableBasedCHA) {\n+    init_monitor()->unlock();\n+  }\n+}\n+\n@@ -2298,1 +2338,0 @@\n-  if (k->has_final_method()) buf[i++] = 'f';\n@@ -2301,0 +2340,1 @@\n+    if (ik->has_final_method()) buf[i++] = 'f';\n@@ -2724,1 +2764,1 @@\n-  \/\/ being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).\n+  \/\/ being added to class hierarchy (see InstanceKlass:::add_to_hierarchy()).\n@@ -2804,0 +2844,10 @@\n+void InstanceKlass::compute_has_loops_flag_for_methods() {\n+  Array<Method*>* methods = this->methods();\n+  for (int index = 0; index < methods->length(); ++index) {\n+    Method* m = methods->at(index);\n+    if (!m->is_overpass()) { \/\/ work around JDK-8305771\n+      m->compute_has_loops_flag();\n+    }\n+  }\n+}\n+\n@@ -2806,1 +2856,1 @@\n-  \/\/ SystemDictionary::add_to_hierarchy() sets the init_state to loaded\n+  \/\/ InstanceKlass::add_to_hierarchy() sets the init_state to loaded\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":53,"deletions":3,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -248,4 +248,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags right now.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n@@ -256,1 +252,1 @@\n-  \/\/ State is set while executing, eventually atomically to not disturb other state\n+  \/\/ State is set either at parse time or while executing, atomically to not disturb other state\n@@ -593,2 +589,2 @@\n-  bool is_marked_dependent() const         { return _is_marked_dependent; }\n-  void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }\n+  bool is_marked_dependent() const         { return _misc_flags.is_marked_dependent(); }\n+  void set_is_marked_dependent(bool value) { _misc_flags.set_is_marked_dependent(value); }\n@@ -746,10 +742,2 @@\n-  bool is_being_redefined() const          {\n-    return _access_flags.is_being_redefined();\n-  }\n-  void set_is_being_redefined(bool value)  {\n-    if (value) {\n-      _access_flags.set_is_being_redefined();\n-    } else {\n-      _access_flags.clear_is_being_redefined();\n-    }\n-  }\n+  bool is_being_redefined() const          { return _misc_flags.is_being_redefined(); }\n+  void set_is_being_redefined(bool value)  { _misc_flags.set_is_being_redefined(value); }\n@@ -781,7 +769,2 @@\n-  bool has_resolved_methods() const {\n-    return _access_flags.has_resolved_methods();\n-  }\n-\n-  void set_has_resolved_methods() {\n-    _access_flags.set_has_resolved_methods();\n-  }\n+  bool has_resolved_methods() const { return _misc_flags.has_resolved_methods(); }\n+  void set_has_resolved_methods()   { _misc_flags.set_has_resolved_methods(true); }\n@@ -841,0 +824,7 @@\n+  bool has_vanilla_constructor() const  { return _misc_flags.has_vanilla_constructor(); }\n+  void set_has_vanilla_constructor()    { _misc_flags.set_has_vanilla_constructor(true); }\n+  bool has_miranda_methods () const     { return _misc_flags.has_miranda_methods(); }\n+  void set_has_miranda_methods()        { _misc_flags.set_has_miranda_methods(true); }\n+  bool has_final_method() const         { return _misc_flags.has_final_method(); }\n+  void set_has_final_method()           { _misc_flags.set_has_final_method(true); }\n+\n@@ -921,0 +911,2 @@\n+  \/\/ Setup link to hierarchy and deoptimize\n+  void add_to_hierarchy(JavaThread* current);\n@@ -960,0 +952,1 @@\n+ private:\n@@ -963,0 +956,1 @@\n+ public:\n@@ -1218,0 +1212,1 @@\n+  void compute_has_loops_flag_for_methods();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,0 +30,6 @@\n+\/\/ The InstanceKlassFlags class contains the parse-time and writeable flags associated with\n+\/\/ an InstanceKlass, and their associated accessors.\n+\/\/ _flags are parse-time and constant in the InstanceKlass after that.  _status are set at runtime and\n+\/\/ require atomic access.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n@@ -38,12 +44,12 @@\n-    flag(unused                             , 1 << 3) \/* not currently used *\/ \\\n-    flag(is_contended                       , 1 << 4) \/* marked with contended annotation *\/ \\\n-    flag(has_nonstatic_concrete_methods     , 1 << 5) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n-    flag(declares_nonstatic_concrete_methods, 1 << 6) \/* directly declares non-static, concrete methods *\/ \\\n-    flag(has_been_redefined                 , 1 << 7) \/* class has been redefined *\/ \\\n-    flag(shared_loading_failed              , 1 << 8) \/* class has been loaded from shared archive *\/ \\\n-    flag(is_scratch_class                   , 1 << 9) \/* class is the redefined scratch class *\/ \\\n-    flag(is_shared_boot_class               , 1 << 10) \/* defining class loader is boot class loader *\/ \\\n-    flag(is_shared_platform_class           , 1 << 11) \/* defining class loader is platform class loader *\/ \\\n-    flag(is_shared_app_class                , 1 << 12) \/* defining class loader is app class loader *\/ \\\n-    flag(has_contended_annotations          , 1 << 13) \/* has @Contended annotation *\/ \\\n-    flag(has_localvariable_table            , 1 << 14) \/* has localvariable information *\/ \\\n+    flag(is_contended                       , 1 << 3) \/* marked with contended annotation *\/ \\\n+    flag(has_nonstatic_concrete_methods     , 1 << 4) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n+    flag(declares_nonstatic_concrete_methods, 1 << 5) \/* directly declares non-static, concrete methods *\/ \\\n+    flag(shared_loading_failed              , 1 << 6) \/* class has been loaded from shared archive *\/ \\\n+    flag(is_shared_boot_class               , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n+    flag(is_shared_platform_class           , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n+    flag(is_shared_app_class                , 1 << 9) \/* defining class loader is app class loader *\/ \\\n+    flag(has_contended_annotations          , 1 << 10) \/* has @Contended annotation *\/ \\\n+    flag(has_localvariable_table            , 1 << 11) \/* has localvariable information *\/ \\\n+    flag(has_miranda_methods                , 1 << 12) \/* True if this class has miranda methods in it's vtable *\/ \\\n+    flag(has_vanilla_constructor            , 1 << 13) \/* True if klass has a vanilla default constructor *\/ \\\n+    flag(has_final_method                   , 1 << 14) \/* True if klass has final method *\/ \\\n@@ -56,0 +62,1 @@\n+    \/* end of list *\/\n@@ -68,0 +75,13 @@\n+#define IK_STATUS_DO(status)  \\\n+    status(is_being_redefined                , 1 << 0) \/* True if the klass is being redefined *\/ \\\n+    status(has_resolved_methods              , 1 << 1) \/* True if the klass has resolved MethodHandle methods *\/ \\\n+    status(has_been_redefined                , 1 << 2) \/* class has been redefined *\/ \\\n+    status(is_scratch_class                  , 1 << 3) \/* class is the redefined scratch class *\/ \\\n+    status(is_marked_dependent               , 1 << 4) \/* class is the redefined scratch class *\/\n+\n+#define IK_STATUS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    IK_STATUS_DO(IK_STATUS_ENUM_NAME)\n+  };\n+#undef IK_STATUS_ENUM_NAME\n+\n@@ -75,0 +95,3 @@\n+  \/\/ These flags are written during execution so require atomic stores\n+  u1 _status;\n+\n@@ -77,1 +100,1 @@\n-  InstanceKlassFlags() : _flags(0) {}\n+  InstanceKlassFlags() : _flags(0), _status(0) {}\n@@ -108,0 +131,20 @@\n+\n+  \/\/ Create getters and setters for the status values.\n+#define IK_STATUS_GET(name, ignore)          \\\n+  bool name() const { return (_status & _misc_##name) != 0; }\n+  IK_STATUS_DO(IK_STATUS_GET)\n+#undef IK_STATUS_GET\n+\n+#define IK_STATUS_SET(name, ignore)   \\\n+  void set_##name(bool b) {         \\\n+    if (b) { \\\n+      atomic_set_bits(_misc_##name); \\\n+    } else { \\\n+      atomic_clear_bits(_misc_##name); \\\n+    } \\\n+  }\n+  IK_STATUS_DO(IK_STATUS_SET)\n+#undef IK_STATUS_SET\n+\n+  void atomic_set_bits(u1 bits);\n+  void atomic_clear_bits(u1 bits);\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":56,"deletions":13,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-    if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n+    if (ArchiveHeapLoader::is_in_use()) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+    _is_shared_class                       = 1 << 0,  \/\/ shadows MetaspaceObj::is_shared\n@@ -369,0 +370,9 @@\n+  bool is_shared() const                { \/\/ shadows MetaspaceObj::is_shared)()\n+    CDS_ONLY(return (_shared_class_flags & _is_shared_class) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  void set_is_shared() {\n+    CDS_ONLY(_shared_class_flags |= _is_shared_class;)\n+  }\n+\n@@ -682,8 +692,0 @@\n-  bool has_final_method() const         { return _access_flags.has_final_method(); }\n-  void set_has_final_method()           { _access_flags.set_has_final_method(); }\n-  bool has_vanilla_constructor() const  { return _access_flags.has_vanilla_constructor(); }\n-  void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }\n-  bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }\n-  void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }\n-  bool is_shared() const                { return access_flags().is_shared_class(); } \/\/ shadows MetaspaceObj::is_shared)()\n-  void set_is_shared()                  { _access_flags.set_is_shared_class(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -575,0 +575,1 @@\n+        HandleMark hm(THREAD);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -236,7 +236,0 @@\n-void oopDesc::verify_forwardee(oop forwardee) {\n-#if INCLUDE_CDS_JAVA_HEAP\n-  assert(!Universe::heap()->is_archived_object(forwardee) && !Universe::heap()->is_archived_object(this),\n-         \"forwarding archive object\");\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-  void verify_forwardee(oop forwardee) NOT_DEBUG_RETURN;\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,0 @@\n-  verify_forwardee(p);\n@@ -291,1 +290,0 @@\n-  verify_forwardee(p);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1273,0 +1273,132 @@\n+\/\/ Collapse the \"addition with overflow-protection\" pattern, and the symmetrical\n+\/\/ \"subtraction with underflow-protection\" pattern. These are created during the\n+\/\/ unrolling, when we have to adjust the limit by subtracting the stride, but want\n+\/\/ to protect against underflow: MaxL(SubL(limit, stride), min_jint).\n+\/\/ If we have more than one of those in a sequence:\n+\/\/\n+\/\/   x  con2\n+\/\/   |  |\n+\/\/   AddL  clamp2\n+\/\/     |    |\n+\/\/    Max\/MinL con1\n+\/\/          |  |\n+\/\/          AddL  clamp1\n+\/\/            |    |\n+\/\/           Max\/MinL (n)\n+\/\/\n+\/\/ We want to collapse it to:\n+\/\/\n+\/\/   x  con1  con2\n+\/\/   |    |    |\n+\/\/   |   AddLNode (new_con)\n+\/\/   |    |\n+\/\/  AddLNode  clamp1\n+\/\/        |    |\n+\/\/       Max\/MinL (n)\n+\/\/\n+\/\/ Note: we assume that SubL was already replaced by an AddL, and that the stride\n+\/\/ has its sign flipped: SubL(limit, stride) -> AddL(limit, -stride).\n+Node* fold_subI_no_underflow_pattern(Node* n, PhaseGVN* phase) {\n+  assert(n->Opcode() == Op_MaxL || n->Opcode() == Op_MinL, \"sanity\");\n+  \/\/ Check that the two clamps have the correct values.\n+  jlong clamp = (n->Opcode() == Op_MaxL) ? min_jint : max_jint;\n+  auto is_clamp = [&](Node* c) {\n+    const TypeLong* t = phase->type(c)->isa_long();\n+    return t != nullptr && t->is_con() &&\n+           t->get_con() == clamp;\n+  };\n+  \/\/ Check that the constants are negative if MaxL, and positive if MinL.\n+  auto is_sub_con = [&](Node* c) {\n+    const TypeLong* t = phase->type(c)->isa_long();\n+    return t != nullptr && t->is_con() &&\n+           t->get_con() < max_jint && t->get_con() > min_jint &&\n+           (t->get_con() < 0) == (n->Opcode() == Op_MaxL);\n+  };\n+  \/\/ Verify the graph level by level:\n+  Node* add1   = n->in(1);\n+  Node* clamp1 = n->in(2);\n+  if (add1->Opcode() == Op_AddL && is_clamp(clamp1)) {\n+    Node* max2 = add1->in(1);\n+    Node* con1 = add1->in(2);\n+    if (max2->Opcode() == n->Opcode() && is_sub_con(con1)) {\n+      Node* add2   = max2->in(1);\n+      Node* clamp2 = max2->in(2);\n+      if (add2->Opcode() == Op_AddL && is_clamp(clamp2)) {\n+        Node* x    = add2->in(1);\n+        Node* con2 = add2->in(2);\n+        if (is_sub_con(con2)) {\n+          Node* new_con = phase->transform(new AddLNode(con1, con2));\n+          Node* new_sub = phase->transform(new AddLNode(x, new_con));\n+          n->set_req_X(1, new_sub, phase);\n+          return n;\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+const Type* MaxLNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n+\n+  return TypeLong::make(MAX2(r0->_lo, r1->_lo), MAX2(r0->_hi, r1->_hi), MAX2(r0->_widen, r1->_widen));\n+}\n+\n+Node* MaxLNode::Identity(PhaseGVN* phase) {\n+  const TypeLong* t1 = phase->type(in(1))->is_long();\n+  const TypeLong* t2 = phase->type(in(2))->is_long();\n+\n+  \/\/ Can we determine maximum statically?\n+  if (t1->_lo >= t2->_hi) {\n+    return in(1);\n+  } else if (t2->_lo >= t1->_hi) {\n+    return in(2);\n+  }\n+\n+  return MaxNode::Identity(phase);\n+}\n+\n+Node* MaxLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n+  if (can_reshape) {\n+    return fold_subI_no_underflow_pattern(this, phase);\n+  }\n+  return nullptr;\n+}\n+\n+const Type* MinLNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n+\n+  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MIN2(r0->_widen, r1->_widen));\n+}\n+\n+Node* MinLNode::Identity(PhaseGVN* phase) {\n+  const TypeLong* t1 = phase->type(in(1))->is_long();\n+  const TypeLong* t2 = phase->type(in(2))->is_long();\n+\n+  \/\/ Can we determine minimum statically?\n+  if (t1->_lo >= t2->_hi) {\n+    return in(2);\n+  } else if (t2->_lo >= t1->_hi) {\n+    return in(1);\n+  }\n+\n+  return MaxNode::Identity(phase);\n+}\n+\n+Node* MinLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n+  if (can_reshape) {\n+    return fold_subI_no_underflow_pattern(this, phase);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -254,1 +254,5 @@\n-        regalloc->C->record_method_not_compilable(\"illegal oopMap register name\");\n+        stringStream ss;\n+        ss.print(\"illegal oopMap register name: \");\n+        r->print_on(&ss);\n+        assert(false, \"%s\", ss.as_string());\n+        regalloc->C->record_method_not_compilable(ss.as_string());\n@@ -321,1 +325,5 @@\n-        regalloc->C->record_method_not_compilable(\"illegal oopMap register name\");\n+        stringStream ss;\n+        ss.print(\"illegal oopMap register name: \");\n+        r->print_on(&ss);\n+        assert(false, \"%s\", ss.as_string());\n+        regalloc->C->record_method_not_compilable(ss.as_string());\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,5 +85,0 @@\n-  product(intx, SuperWordMaxVectorSize, 64, DIAGNOSTIC,                     \\\n-          \"Vector size limit in bytes for superword, \"                      \\\n-          \"superword vector size limit in bytes\")                           \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+\n+void compiler_stubs_init(bool in_compiler_thread);\n+\n@@ -77,0 +80,2 @@\n+  compiler_stubs_init(true \/* in_compiler_thread *\/); \/\/ generate compiler's intrinsics stubs\n+\n@@ -760,2 +765,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-  case vmIntrinsics::_VectorShuffleToVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -543,0 +543,1 @@\n+  DEBUG_ONLY( uint outcnt_orig = outcnt(); )\n@@ -573,1 +574,0 @@\n-\n@@ -578,18 +578,9 @@\n-      uint max = outcnt();\n-      DUIterator j;\n-      bool progress = true;\n-      while(progress) {         \/\/ Need to establish property over all users\n-        progress = false;\n-        for (j = outs(); has_out(j); j++) {\n-          Node *n = out(j);\n-          if( n->req() != req() && n->is_Phi() ) {\n-            assert( n->in(0) == this, \"\" );\n-            igvn->hash_delete(n); \/\/ Yank from hash before hacking edges\n-            n->set_req_X(i,nullptr,igvn);\/\/ Correct DU info\n-            n->del_req(i);        \/\/ Yank path from Phis\n-            if( max != outcnt() ) {\n-              progress = true;\n-              j = refresh_out_pos(j);\n-              max = outcnt();\n-            }\n-          }\n+\n+      for (DUIterator_Fast jmax, j = fast_outs(jmax); j < jmax; j++) {\n+        Node* use = fast_out(j);\n+\n+        if (use->req() != req() && use->is_Phi()) {\n+          assert(use->in(0) == this, \"unexpected control input\");\n+          igvn->hash_delete(use);          \/\/ Yank from hash before hacking edges\n+          use->set_req_X(i, nullptr, igvn);\/\/ Correct DU info\n+          use->del_req(i);                 \/\/ Yank path from Phis\n@@ -598,2 +589,6 @@\n-      add_to_worklist = false;\n-      phase->is_IterGVN()->add_users_to_worklist(this);\n+\n+      if (add_to_worklist) {\n+        igvn->add_users_to_worklist(this);\n+        add_to_worklist = false;\n+      }\n+\n@@ -604,0 +599,2 @@\n+  assert(outcnt() == outcnt_orig, \"not expect to remove any use\");\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  _blks = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());\n+  uint nr_blocks = _cfg.number_of_blocks();\n@@ -230,0 +230,4 @@\n+\n+  \/\/ The space which our buckets point into.\n+  Block** start = NEW_RESOURCE_ARRAY(Block *, nr_blocks*NUMBUCKS);\n+\n@@ -231,1 +235,1 @@\n-    buckets[i] = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());\n+    buckets[i] = &start[i*nr_blocks];\n@@ -236,3 +240,1 @@\n-    for (uint j = 0; j < _cfg.number_of_blocks(); j++) {\n-      buckets[i][j] = nullptr;\n-    }\n+\n@@ -241,1 +243,1 @@\n-  for (uint i = 0; i < _cfg.number_of_blocks(); i++) {\n+  for (uint i = 0; i < nr_blocks; i++) {\n@@ -243,1 +245,4 @@\n-      if ((j == NUMBUCKS - 1) || (_cfg.get_block(i)->_freq > buckval[j])) {\n+      double bval = buckval[j];\n+      Block* blk = _cfg.get_block(i);\n+      if (j == NUMBUCKS - 1 || blk->_freq > bval) {\n+        uint cnt = buckcnt[j];\n@@ -245,1 +250,2 @@\n-        buckets[j][buckcnt[j]++] = _cfg.get_block(i);\n+        buckets[j][cnt] = blk;\n+        buckcnt[j] = cnt+1;\n@@ -250,1 +256,16 @@\n-  \/\/ Dump buckets into final block array\n+\n+  \/\/ Squash the partially filled buckets together into the first one.\n+  static_assert(NUMBUCKS >= 2, \"must\"); \/\/ If this isn't true then it'll mess up the squashing.\n+  Block** offset = &buckets[0][buckcnt[0]];\n+  for (int i = 1; i < NUMBUCKS; i++) {\n+    ::memmove(offset, buckets[i], buckcnt[i]*sizeof(Block*));\n+    offset += buckcnt[i];\n+  }\n+  assert((&buckets[0][0] + nr_blocks) == offset, \"should be\");\n+\n+  \/\/ Free the now unused memory\n+  FREE_RESOURCE_ARRAY(Block*, buckets[1], (NUMBUCKS-1)*nr_blocks);\n+  \/\/ Finally, point the _blks to our memory\n+  _blks = buckets[0];\n+\n+#ifdef ASSERT\n@@ -253,3 +274,1 @@\n-    for (uint j = 0; j < buckcnt[i]; j++) {\n-      _blks[blkcnt++] = buckets[i][j];\n-    }\n+    blkcnt += buckcnt[i];\n@@ -257,2 +276,2 @@\n-\n-  assert(blkcnt == _cfg.number_of_blocks(), \"Block array not totally filled\");\n+  assert(blkcnt == nr_blocks, \"Block array not totally filled\");\n+#endif\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+macro(CompressBitsV)\n+macro(ExpandBitsV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -769,1 +769,5 @@\n-      record_method_not_compilable(\"cannot parse method\");\n+      const char* reason = InlineTree::check_can_parse(method());\n+      assert(reason != nullptr, \"expect reason for parse failure\");\n+      stringStream ss;\n+      ss.print(\"cannot parse method: %s\", reason);\n+      record_method_not_compilable(ss.as_string());\n@@ -778,1 +782,4 @@\n-        record_method_not_compilable(\"method parse failed\");\n+        assert(failure_reason() != nullptr, \"expect reason for parse failure\");\n+        stringStream ss;\n+        ss.print(\"method parse failed: %s\", failure_reason());\n+        record_method_not_compilable(ss.as_string());\n@@ -4450,0 +4457,2 @@\n+    \/\/ Do not compile method that is only a trivial infinite loop,\n+    \/\/ since the content of the loop may have been eliminated.\n@@ -4515,0 +4524,1 @@\n+\n@@ -4517,0 +4527,2 @@\n+        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n+        assert(false, \"malformed control flow\");\n@@ -4535,0 +4547,3 @@\n+        DEBUG_ONLY( n->fast_out(j)->dump(); );\n+        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n+        assert(false, \"infinite loop\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -336,0 +336,14 @@\n+Node* ConvI2LNode::Identity(PhaseGVN* phase) {\n+  \/\/ If type is in \"int\" sub-range, we can\n+  \/\/ convert I2L(L2I(x)) => x\n+  \/\/ since the conversions have no effect.\n+  if (in(1)->Opcode() == Op_ConvL2I) {\n+    Node* x = in(1)->in(1);\n+    const TypeLong* t = phase->type(x)->isa_long();\n+    if (t != nullptr && t->_lo >= min_jint && t->_hi <= max_jint) {\n+      return x;\n+    }\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1060,5 +1060,9 @@\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n-             strncmp(name, \"_load_unknown_inline\", 20) == 0, \"TODO: add failed case check\");\n-      \/\/ Returns a newly allocated non-escaped object.\n-      add_java_object(call, PointsToNode::NoEscape);\n-      set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n+      if (strncmp(name, \"_notify_jvmti_object_alloc\", 26) == 0) { \/\/ Object escapes to JVMTI\n+        add_java_object(call, PointsToNode::GlobalEscape);\n+      } else {\n+        assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n+               strncmp(name, \"_load_unknown_inline\", 20) == 0, \"TODO: add failed case check\");\n+        \/\/ Returns a newly allocated non-escaped object.\n+        add_java_object(call, PointsToNode::NoEscape);\n+        set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n+      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1503,0 +1503,1 @@\n+    assert(false, \"early schedule failed\");\n@@ -1603,0 +1604,1 @@\n+        assert(false, \"local schedule failed\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -928,1 +928,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -707,2 +708,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-    return inline_vector_shuffle_iota();\n@@ -711,2 +710,0 @@\n-  case vmIntrinsics::_VectorShuffleToVector:\n-    return inline_vector_shuffle_to_vector();\n@@ -3047,0 +3044,22 @@\n+#if INCLUDE_JVMTI\n+  \/\/ Check if JvmtiExport::_should_notify_object_alloc is enabled and post notifications\n+  IdealKit ideal(this);\n+  IdealVariable result(ideal); ideal.declarations_done();\n+  Node* ONE = ideal.ConI(1);\n+  Node* addr = makecon(TypeRawPtr::make((address) &JvmtiExport::_should_notify_object_alloc));\n+  Node* should_post_vm_object_alloc = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+\n+  ideal.sync_kit(this);\n+  ideal.if_then(should_post_vm_object_alloc, BoolTest::eq, ONE); {\n+    const TypeFunc *tf = OptoRuntime::notify_jvmti_object_alloc_Type();\n+    address funcAddr = OptoRuntime::notify_jvmti_object_alloc();\n+    sync_kit(ideal);\n+    Node* call = make_runtime_call(RC_NO_LEAF, tf, funcAddr, \"_notify_jvmti_object_alloc\", TypePtr::BOTTOM, obj);\n+    ideal.sync_kit(this);\n+    ideal.set(result,_gvn.transform(new ProjNode(call, TypeFunc::Parms+0)));\n+  } ideal.else_(); {\n+    ideal.set(result,obj);\n+  } ideal.end_if();\n+  final_sync(ideal);\n+  obj = ideal.value(result);\n+#endif \/\/INCLUDE_JVMTI\n@@ -3093,1 +3112,2 @@\n-    \/\/ set hide value to the VTMS transition bit in current JavaThread\n+    \/\/ set hide value to the VTMS transition bit in current JavaThread and VirtualThread object\n+    Node* vt_oop = _gvn.transform(argument(0)); \/\/ this argument - VirtualThread oop\n@@ -3095,1 +3115,2 @@\n-    Node* addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_VTMS_transition_offset()));\n+    Node* jt_addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_VTMS_transition_offset()));\n+    Node* vt_addr = basic_plus_adr(vt_oop, java_lang_Thread::is_in_VTMS_transition_offset());\n@@ -3099,1 +3120,3 @@\n-    access_store_at(nullptr, addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, jt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, vt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+\n@@ -3107,1 +3130,1 @@\n-\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+\/\/ Always update the temporary VTMS transition bit.\n@@ -3114,6 +3137,2 @@\n-  Node* ONE = ideal.ConI(1);\n-  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n-  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n-\n-  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n-    \/\/ set the VTMS temporary transition bit in current JavaThread\n+  {\n+    \/\/ unconditionally update the temporary VTMS transition bit in current JavaThread\n@@ -3128,1 +3147,1 @@\n-  } ideal.end_if();\n+  }\n@@ -3707,2 +3726,1 @@\n-  store_to_memory(control(), cache_obj_handle, arr, T_OBJECT, adr_type,\n-                  MemNode::unordered);\n+  access_store_at(nullptr, cache_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n@@ -7673,1 +7691,1 @@\n-  assert(stubAddr != nullptr, \"Stub is generated\");\n+  assert(stubAddr != nullptr, \"Stub %s is not generated\", stubName);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -371,2 +371,0 @@\n-  bool inline_vector_shuffle_to_vector();\n-  bool inline_vector_shuffle_iota();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -798,1 +798,5 @@\n-  void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;\n+#endif\n+\n+#ifdef ASSERT\n+  GrowableArray<IdealLoopTree*> collect_sorted_children() const;\n+  bool verify_tree(IdealLoopTree* loop_verify) const;\n@@ -898,1 +902,1 @@\n-  bool has_ctrl( Node *n ) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n+  bool has_ctrl(const Node* n) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n@@ -975,1 +979,1 @@\n-  bool has_node( Node* n ) const {\n+  bool has_node(const Node* n) const {\n@@ -1006,2 +1010,1 @@\n-  Node *get_ctrl( Node *i ) {\n-\n+  Node* get_ctrl(const Node* i) {\n@@ -1027,1 +1030,1 @@\n-  Node *get_ctrl_no_update_helper(Node *i) const {\n+  Node* get_ctrl_no_update_helper(const Node* i) const {\n@@ -1032,1 +1035,1 @@\n-  Node *get_ctrl_no_update(Node *i) const {\n+  Node* get_ctrl_no_update(const Node* i) const {\n@@ -1706,2 +1709,0 @@\n-  void verify() const;          \/\/ Major slow  :-)\n-  void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &visited) const;\n@@ -1721,0 +1722,7 @@\n+#ifdef ASSERT\n+  void verify() const;\n+  bool verify_idom_and_nodes(Node* root, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_idom(Node* n, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const;\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -816,1 +816,1 @@\n-    if (VerifyLoopOptimizations) verify();\n+    DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n@@ -1607,3 +1607,1 @@\n-#ifndef PRODUCT\n-          if( VerifyLoopOptimizations ) verify();\n-#endif\n+          DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2888,0 +2888,2 @@\n+               n->Opcode() == Op_MaxL      ||\n+               n->Opcode() == Op_MinL      ||\n@@ -2975,0 +2977,12 @@\n+      } else if (n->Opcode() == Op_MaxL) {\n+        \/\/ Since MaxL and MinL are not implemented in the backend, we expand them to\n+        \/\/ a CMoveL construct now. At least until here, the type could be computed\n+        \/\/ precisely. CMoveL is not so smart, but we can give it at least the best\n+        \/\/ type we know abouot n now.\n+        Node* repl = MaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        _igvn.replace_node(n, repl);\n+        success = true;\n+      } else if (n->Opcode() == Op_MinL) {\n+        Node* repl = MaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        _igvn.replace_node(n, repl);\n+        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+      \/\/ Bailout. We do not have space to represent all arguments.\n@@ -346,0 +347,1 @@\n+    \/\/ Bailout. We do not have space to represent all arguments.\n@@ -393,0 +395,1 @@\n+      assert(false, \"instruction match failed\");\n@@ -424,1 +427,9 @@\n-    C->record_method_not_compilable(\"graph lost\"); \/\/ %%% cannot happen?\n+    \/\/ New graph lost. This is due to a compilation failure we encountered earlier.\n+    stringStream ss;\n+    if (C->failure_reason() != nullptr) {\n+      ss.print(\"graph lost: %s\", C->failure_reason());\n+    } else {\n+      assert(C->failure_reason() != nullptr, \"graph lost: reason unknown\");\n+      ss.print(\"graph lost: reason unknown\");\n+    }\n+    C->record_method_not_compilable(ss.as_string());\n@@ -1281,0 +1292,1 @@\n+      \/\/ Bailout. For example not enough space on stack for all arguments. Happens for methods with too many arguments.\n@@ -1478,0 +1490,1 @@\n+      \/\/ Bailout. We do not have space to represent all arguments.\n@@ -1665,0 +1678,1 @@\n+    \/\/ Bailout. Can for example be hit with a deep chain of operations.\n@@ -1765,1 +1779,1 @@\n-  if (_shared_nodes.Size() <= leaf->_idx) return nullptr;\n+  if (_shared_nodes.max() <= leaf->_idx) return nullptr;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -343,0 +343,2 @@\n+  static const bool vector_needs_load_shuffle(BasicType elem_bt, int vlen);\n+\n@@ -356,0 +358,2 @@\n+  \/\/ Limits on max vector size (number of elements) for auto-vectorization.\n+  static const int superword_max_vector_size(const BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1320,1 +1320,1 @@\n-    } else if (sub == up && sub->is_Region() && sub->req() == 3) {\n+    } else if (sub == up && sub->is_Region()) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1565,1 +1565,1 @@\n-  uint Size() const { return _max; }\n+  uint max() const { return _max; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2920,0 +2920,2 @@\n+      DEBUG_ONLY( pinch->dump(); );\n+      assert(false, \"too many D-U pinch points: %d >= %d\", pinch->_idx, _regalloc->node_regs_max_index());\n@@ -3154,1 +3156,1 @@\n-  for (uint k = 0; k < _reg_node.Size(); k++) {\n+  for (uint k = 0; k < _reg_node.max(); k++) {\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+    assert(false, \"OSR starts with an immediate trap\");\n@@ -267,0 +268,1 @@\n+    assert(false, \"OSR in empty or breakpointed method\");\n@@ -437,0 +439,1 @@\n+    assert(false, \"type flow failed during parsing\");\n@@ -515,0 +518,1 @@\n+      assert(false, \"type flow analysis failed for OSR compilation\");\n@@ -1116,0 +1120,10 @@\n+#ifdef ASSERT\n+      tty->print_cr(\"# Can't determine return type.\");\n+      tty->print_cr(\"# exit control\");\n+      _exits.control()->dump(2);\n+      tty->print_cr(\"# ret phi type\");\n+      _gvn.type(ret_phi)->dump();\n+      tty->print_cr(\"# ret phi\");\n+      ret_phi->dump(2);\n+#endif \/\/ ASSERT\n+      assert(false, \"Can't determine return type.\");\n@@ -1191,0 +1205,1 @@\n+    \/\/ Bailout expected, this is a very rare edge case.\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-  for( uint i=0; i<_nodes.Size(); i++ )\n+  for( uint i=0; i<_nodes.max(); i++ )\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+address OptoRuntime::_notify_jvmti_object_alloc                   = nullptr;\n@@ -158,0 +159,1 @@\n+  gen(env, _notify_jvmti_object_alloc      , notify_jvmti_object_alloc_Type, SharedRuntime::notify_jvmti_object_alloc, 0, true, false);\n@@ -483,0 +485,16 @@\n+#if INCLUDE_JVMTI\n+const TypeFunc *OptoRuntime::notify_jvmti_object_alloc_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+   \/\/ create result type (range)\n+   fields = TypeTuple::fields(1);\n+   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ Returned oop\n+\n+   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+   return TypeFunc::make(domain, range);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  static address _notify_jvmti_object_alloc;\n@@ -218,0 +219,1 @@\n+  static address notify_jvmti_object_alloc()             { return _notify_jvmti_object_alloc; }\n@@ -308,0 +310,1 @@\n+  static const TypeFunc* notify_jvmti_object_alloc_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -745,3 +745,1 @@\n-#ifndef PRODUCT\n-  if( VerifyLoopOptimizations ) verify();\n-#endif\n+  DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n-\n@@ -441,2 +436,0 @@\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n@@ -487,3 +480,0 @@\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/support\/jfrThreadId.hpp\"\n@@ -105,0 +103,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -106,1 +107,1 @@\n-static jint CurrentVersion = JNI_VERSION_20;\n+static jint CurrentVersion = JNI_VERSION_21;\n@@ -3585,18 +3586,0 @@\n-static void post_thread_start_event(const JavaThread* jt) {\n-  assert(jt != nullptr, \"invariant\");\n-  EventThreadStart event;\n-  if (event.should_commit()) {\n-    event.set_thread(JFR_JVM_THREAD_ID(jt));\n-    event.set_parentThread((traceid)0);\n-#if INCLUDE_JFR\n-    if (EventThreadStart::is_stacktrace_enabled()) {\n-      jt->jfr_thread_local()->set_cached_stack_trace_id((traceid)0);\n-      event.commit();\n-      jt->jfr_thread_local()->clear_cached_stack_trace();\n-    } else\n-#endif\n-    {\n-      event.commit();\n-    }\n-  }\n-}\n@@ -3737,1 +3720,1 @@\n-    post_thread_start_event(thread);\n+    JFR_ONLY(Jfr::on_thread_start(thread);)\n@@ -3972,1 +3955,1 @@\n-  post_thread_start_event(thread);\n+  JFR_ONLY(Jfr::on_thread_start(thread);)\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -430,6 +430,0 @@\n-#if INCLUDE_CDS\n-  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n-  if (DynamicArchive::should_dump_at_vm_exit()) {\n-    DynamicArchive::prepare_for_dump_at_exit();\n-  }\n-#endif\n@@ -3110,6 +3104,0 @@\n-JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))\n-  oop thread_oop = JNIHandles::resolve_non_null(jthread);\n-  return java_lang_Thread::is_alive(thread_oop);\n-JVM_END\n-\n-\n@@ -4015,0 +4003,2 @@\n+    oop vt = JNIHandles::resolve_external_guard(vthread);\n+    java_lang_Thread::set_is_in_VTMS_transition(vt, hide);\n@@ -4037,0 +4027,2 @@\n+    oop vt = JNIHandles::resolve_external_guard(vthread);\n+    java_lang_Thread::set_is_in_VTMS_transition(vt, hide);\n@@ -4049,1 +4041,1 @@\n-\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+\/\/ Always update the temporary VTMS transition bit.\n@@ -4056,3 +4048,0 @@\n-  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    return;\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1044,0 +1044,1 @@\n+        int pool_index;\n@@ -1046,1 +1047,1 @@\n-          entry = mh->constants()->invokedynamic_cp_cache_entry_at(cpci);\n+          pool_index = mh->constants()->resolved_indy_entry_at(mh->constants()->decode_invokedynamic_index(cpci))->constant_pool_index();\n@@ -1050,0 +1051,1 @@\n+          pool_index = entry->constant_pool_index();\n@@ -1051,3 +1053,2 @@\n-        int i = entry->constant_pool_index();\n-        assert(i < mh->constants()->length(), \"sanity check\");\n-        Bytes::put_Java_u2((address)(p+1), (u2)i);     \/\/ java byte ordering\n+        assert(pool_index < mh->constants()->length(), \"sanity check\");\n+        Bytes::put_Java_u2((address)(p+1), (u2)pool_index);     \/\/ java byte ordering\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1314,7 +1314,0 @@\n-  if (loader != nullptr) {\n-    \/\/ Do the same as Thread.getContextClassLoader and set context_class_loader to be\n-    \/\/ the system class loader when the field value is the \"not supported\" placeholder.\n-    if (loader == java_lang_Thread_Constants::get_NOT_SUPPORTED_CLASSLOADER()) {\n-      loader = SystemDictionary::java_system_loader();\n-    }\n-  }\n@@ -3663,1 +3656,1 @@\n-  JvmtiRawMonitor* rmonitor = new JvmtiRawMonitor(name);\n+  JvmtiRawMonitor* rmonitor = new (std::nothrow) JvmtiRawMonitor(name);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -382,1 +383,8 @@\n-    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n+      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+        ThreadInVMfromNative __tiv(JavaThread::current());\n+        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+      }\n+    } else {\n+      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    }\n@@ -693,0 +701,7 @@\n+\/\/ Lookup an agent from an JvmtiEnv. Return agent only if it is not yet initialized.\n+\/\/ An agent can create multiple JvmtiEnvs, but for agent initialization, we are only interested in the initial one.\n+static JvmtiAgent* lookup_uninitialized_agent(JvmtiEnv* env, void* callback) {\n+  JvmtiAgent* const agent = JvmtiAgentList::lookup(env, callback);\n+  return agent == nullptr || agent->is_initialized() ? nullptr : agent;\n+}\n+\n@@ -709,0 +724,6 @@\n+        \/\/ We map the JvmtiEnv to its Agent to measure when and for how long\n+        \/\/ it took to initialize so that JFR can report this information.\n+        JvmtiAgent* const agent = lookup_uninitialized_agent(env, reinterpret_cast<void*>(callback));\n+        if (agent != nullptr) {\n+          agent->initialization_begin();\n+        }\n@@ -710,0 +731,3 @@\n+        if (agent != nullptr) {\n+          agent->initialization_end();\n+        }\n@@ -713,1 +737,5 @@\n-}\n+  \/\/ Agents are initialized as part of posting the VMInit event above.\n+  \/\/ For -Xrun agents and agents with no VMInit callback, we explicitly ensure they are also initialized.\n+  \/\/ JVM_OnLoad and Agent_OnLoad callouts are performed too early for the proper timestamp logic.\n+  JvmtiAgentList::initialize();\n+}\n@@ -1042,0 +1070,4 @@\n+\/\/ This flag is read by C2 during VM internal objects allocation\n+bool JvmtiExport::_should_notify_object_alloc = false;\n+\n+\n@@ -2921,112 +2953,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-#if INCLUDE_SERVICES\n-\/\/ Attach is disabled if SERVICES is not included\n-\n-\/\/ type for the Agent_OnAttach entry point\n-extern \"C\" {\n-  typedef jint (JNICALL *OnAttachEntry_t)(JavaVM*, char *, void *);\n-}\n-\n-jint JvmtiExport::load_agent_library(const char *agent, const char *absParam,\n-                                     const char *options, outputStream* st) {\n-  char ebuf[1024] = {0};\n-  char buffer[JVM_MAXPATHLEN];\n-  void* library = nullptr;\n-  jint result = JNI_ERR;\n-  const char *on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n-  size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n-\n-  \/\/ The abs parameter should be \"true\" or \"false\"\n-  bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam,\"true\")==0);\n-\n-  \/\/ Initially marked as invalid. It will be set to valid if we can find the agent\n-  AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, nullptr);\n-\n-  \/\/ Check for statically linked in agent. If not found then if the path is\n-  \/\/ absolute we attempt to load the library. Otherwise we try to load it\n-  \/\/ from the standard dll directory.\n-\n-  if (!os::find_builtin_agent(agent_lib, on_attach_symbols, num_symbol_entries)) {\n-    if (is_absolute_path) {\n-      library = os::dll_load(agent, ebuf, sizeof ebuf);\n-    } else {\n-      \/\/ Try to load the agent from the standard dll directory\n-      if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),\n-                             agent)) {\n-        library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-      }\n-      if (library == nullptr) {\n-        \/\/ not found - try OS default library path\n-        if (os::dll_build_name(buffer, sizeof(buffer), agent)) {\n-          library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-        }\n-      }\n-    }\n-    if (library != nullptr) {\n-      agent_lib->set_os_lib(library);\n-      agent_lib->set_valid();\n-    }\n-  }\n-  \/\/ If the library was loaded then we attempt to invoke the Agent_OnAttach\n-  \/\/ function\n-  if (agent_lib->valid()) {\n-    \/\/ Lookup the Agent_OnAttach function\n-    OnAttachEntry_t on_attach_entry = nullptr;\n-    on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n-       os::find_agent_function(agent_lib, false, on_attach_symbols, num_symbol_entries));\n-    if (on_attach_entry == nullptr) {\n-      \/\/ Agent_OnAttach missing - unload library\n-      if (!agent_lib->is_static_lib()) {\n-        os::dll_unload(library);\n-      }\n-      st->print_cr(\"%s is not available in %s\",\n-                   on_attach_symbols[0], agent_lib->name());\n-      delete agent_lib;\n-    } else {\n-      \/\/ Invoke the Agent_OnAttach function\n-      JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-      {\n-        extern struct JavaVM_ main_vm;\n-        JvmtiThreadEventMark jem(THREAD);\n-        JvmtiJavaThreadEventTransition jet(THREAD);\n-\n-        result = (*on_attach_entry)(&main_vm, (char*)options, nullptr);\n-\n-        \/\/ Agent_OnAttach may have used JNI\n-        if (THREAD->is_pending_jni_exception_check()) {\n-          THREAD->clear_pending_jni_exception_check();\n-        }\n-      }\n-\n-      \/\/ Agent_OnAttach may have used JNI\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n-\n-      \/\/ If OnAttach returns JNI_OK then we add it to the list of\n-      \/\/ agent libraries so that we can call Agent_OnUnload later.\n-      if (result == JNI_OK) {\n-        Arguments::add_loaded_agent(agent_lib);\n-      } else {\n-        if (!agent_lib->is_static_lib()) {\n-          os::dll_unload(library);\n-        }\n-        delete agent_lib;\n-      }\n-\n-      \/\/ Agent_OnAttach executed so completion status is JNI_OK\n-      st->print_cr(\"return code: %d\", result);\n-      result = JNI_OK;\n-    }\n-  } else {\n-    st->print_cr(\"%s was not loaded.\", agent);\n-    if (*ebuf != '\\0') {\n-      st->print_cr(\"%s\", ebuf);\n-    }\n-  }\n-  return result;\n-}\n-\n-#endif \/\/ INCLUDE_SERVICES\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":34,"deletions":114,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"prims\/jvmtiEnvBase.hpp\"\n@@ -830,4 +831,3 @@\n-  if (directive->ExcludeOption) {\n-    return true;\n-  }\n-  return false;\n+  bool exclude = directive->ExcludeOption;\n+  DirectivesStack::release(directive);\n+  return exclude;\n@@ -1880,1 +1880,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1885,1 +1885,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1926,1 +1926,1 @@\n-    if (oh != NULL && oh->is_inline_type()) {\n+    if (oh != nullptr && oh->is_inline_type()) {\n@@ -1957,1 +1957,1 @@\n-    f->oops_do(&collectOops, NULL, sfs.register_map());\n+    f->oops_do(&collectOops, nullptr, sfs.register_map());\n@@ -1964,0 +1964,18 @@\n+WB_ENTRY(jint, WB_getIndyInfoLength(JNIEnv* env, jobject wb, jclass klass))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == nullptr) {\n+      return -1;\n+  }\n+  return cp->resolved_indy_entries_length();\n+WB_END\n+\n+WB_ENTRY(jint, WB_getIndyCPIndex(JNIEnv* env, jobject wb, jclass klass, jint index))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == nullptr) {\n+      return -1;\n+  }\n+  return cp->resolved_indy_entry_at(index)->constant_pool_index();\n+WB_END\n+\n@@ -2081,5 +2099,0 @@\n-WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))\n-  oop obj_oop = JNIHandles::resolve(obj);\n-  return Universe::heap()->is_archived_object(obj_oop);\n-WB_END\n-\n@@ -2099,13 +2112,1 @@\n-  return ArchiveHeapLoader::closed_regions_mapped();\n-WB_END\n-\n-WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))\n-  Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    ConstantPool *cp = ik->constants();\n-    objArrayOop refs =  cp->resolved_references();\n-    return (jobject)JNIHandles::make_local(THREAD, refs);\n-  } else {\n-    return nullptr;\n-  }\n+  return ArchiveHeapLoader::is_mapped();\n@@ -2124,1 +2125,1 @@\n-  return ArchiveHeapLoader::open_regions_mapped();\n+  return ArchiveHeapLoader::is_mapped();\n@@ -2613,0 +2614,16 @@\n+WB_ENTRY(jboolean, WB_SetVirtualThreadsNotifyJvmtiMode(JNIEnv* env, jobject wb, jboolean enable))\n+  if (!Continuations::enabled()) {\n+    tty->print_cr(\"WB error: must be Continuations::enabled()!\");\n+    return JNI_FALSE;\n+  }\n+  jboolean result = false;\n+#if INCLUDE_JVMTI\n+  if (enable) {\n+    result = JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+  } else {\n+    result = JvmtiEnvBase::disable_virtual_threads_notify_jvmti();\n+  }\n+#endif\n+  return result;\n+WB_END\n+\n@@ -2809,0 +2826,2 @@\n+  {CC\"getIndyInfoLength0\", CC\"(Ljava\/lang\/Class;)I\",  (void*)&WB_getIndyInfoLength},\n+  {CC\"getIndyCPIndex0\",    CC\"(Ljava\/lang\/Class;I)I\", (void*)&WB_getIndyCPIndex},\n@@ -2829,1 +2848,0 @@\n-  {CC\"isShared\",           CC\"(Ljava\/lang\/Object;)Z\", (void*)&WB_IsShared },\n@@ -2833,1 +2851,0 @@\n-  {CC\"getResolvedReferences\", CC\"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", (void*)&WB_GetResolvedReferences},\n@@ -2896,0 +2913,1 @@\n+  {CC\"setVirtualThreadsNotifyJvmtiMode\", CC\"(Z)Z\",    (void*)&WB_SetVirtualThreadsNotifyJvmtiMode},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":47,"deletions":29,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -67,0 +68,1 @@\n+#include \"utilities\/systemMemoryBarrier.hpp\"\n@@ -87,1 +89,0 @@\n-bool   Arguments::_java_compiler                = false;\n@@ -108,3 +109,0 @@\n-AgentLibraryList Arguments::_libraryList;\n-AgentLibraryList Arguments::_agentList;\n-\n@@ -220,19 +218,0 @@\n-AgentLibrary::AgentLibrary(const char* name, const char* options,\n-               bool is_absolute_path, void* os_lib,\n-               bool instrument_lib) {\n-  _name = AllocateHeap(strlen(name)+1, mtArguments);\n-  strcpy(_name, name);\n-  if (options == nullptr) {\n-    _options = nullptr;\n-  } else {\n-    _options = AllocateHeap(strlen(options)+1, mtArguments);\n-    strcpy(_options, options);\n-  }\n-  _is_absolute_path = is_absolute_path;\n-  _os_lib = os_lib;\n-  _next = nullptr;\n-  _state = agent_invalid;\n-  _is_static_lib = false;\n-  _is_instrument_lib = instrument_lib;\n-}\n-\n@@ -329,17 +308,0 @@\n-void Arguments::add_init_library(const char* name, const char* options) {\n-  _libraryList.add(new AgentLibrary(name, options, false, nullptr));\n-}\n-\n-void Arguments::add_init_agent(const char* name, const char* options, bool absolute_path) {\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr));\n-}\n-\n-void Arguments::add_instrument_agent(const char* name, const char* options, bool absolute_path) {\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, true));\n-}\n-\n-\/\/ Late-binding agents not started via arguments\n-void Arguments::add_loaded_agent(AgentLibrary *agentLib) {\n-  _agentList.add(agentLib);\n-}\n-\n@@ -562,2 +524,3 @@\n-  { \"G1ConcRSLogCacheSize\",    JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n-  { \"G1ConcRSHotCardLimit\",   JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n+  { \"G1UsePreventiveGC\",            JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n+  { \"G1ConcRSLogCacheSize\",         JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n+  { \"G1ConcRSHotCardLimit\",         JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n@@ -1306,2 +1269,8 @@\n-    process_java_compiler_argument(value);\n-    \/\/ Record value in Arguments, but let it get passed to Java.\n+    \/\/ we no longer support java.compiler system property, log a warning and let it get\n+    \/\/ passed to Java, like any other system property\n+    if (strlen(value) == 0 || strcasecmp(value, \"NONE\") == 0) {\n+        \/\/ for applications using NONE or empty value, log a more informative message\n+        warning(\"The java.compiler system property is obsolete and no longer supported, use -Xint\");\n+    } else {\n+        warning(\"The java.compiler system property is obsolete and no longer supported.\");\n+    }\n@@ -1412,1 +1381,0 @@\n-  set_java_compiler(false);\n@@ -1902,10 +1870,0 @@\n-\/\/ Parsing of java.compiler property\n-\n-void Arguments::process_java_compiler_argument(const char* arg) {\n-  \/\/ For backwards compatibility, Djava.compiler=NONE or \"\"\n-  \/\/ causes us to switch to -Xint mode UNLESS -Xdebug\n-  \/\/ is also specified.\n-  if (strlen(arg) == 0 || strcasecmp(arg, \"NONE\") == 0) {\n-    set_java_compiler(true);    \/\/ \"-Djava.compiler[=...]\" most recently seen.\n-  }\n-}\n@@ -2163,0 +2121,2 @@\n+  SystemMemoryBarrier::initialize();\n+\n@@ -2449,1 +2409,1 @@\n-        add_init_library(name, options);\n+        JvmtiAgentList::add_xrun(name, options, false);\n@@ -2521,1 +2481,1 @@\n-        add_init_agent(name, options, is_absolute_path);\n+        JvmtiAgentList::add(name, options, is_absolute_path);\n@@ -2536,1 +2496,1 @@\n-        add_instrument_agent(\"instrument\", options, false);\n+        JvmtiAgentList::add(\"instrument\", options, false);\n@@ -2538,0 +2498,1 @@\n+\n@@ -3126,9 +3087,0 @@\n-  \/\/ This must be done after all arguments have been processed.\n-  \/\/ java_compiler() true means set to \"NONE\" or empty.\n-  if (java_compiler() && !xdebug_mode()) {\n-    \/\/ For backwards compatibility, we switch to interpreted mode if\n-    \/\/ -Djava.compiler=\"NONE\" or \"\" is specified AND \"-Xdebug\" was\n-    \/\/ not specified.\n-    set_mode_flags(_int);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":19,"deletions":67,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -142,92 +142,0 @@\n-\n-\/\/ For use by -agentlib, -agentpath and -Xrun\n-class AgentLibrary : public CHeapObj<mtArguments> {\n-  friend class AgentLibraryList;\n-public:\n-  \/\/ Is this library valid or not. Don't rely on os_lib == nullptr as statically\n-  \/\/ linked lib could have handle of RTLD_DEFAULT which == 0 on some platforms\n-  enum AgentState {\n-    agent_invalid = 0,\n-    agent_valid   = 1\n-  };\n-\n- private:\n-  char*           _name;\n-  char*           _options;\n-  void*           _os_lib;\n-  bool            _is_absolute_path;\n-  bool            _is_static_lib;\n-  bool            _is_instrument_lib;\n-  AgentState      _state;\n-  AgentLibrary*   _next;\n-\n- public:\n-  \/\/ Accessors\n-  const char* name() const                  { return _name; }\n-  char* options() const                     { return _options; }\n-  bool is_absolute_path() const             { return _is_absolute_path; }\n-  void* os_lib() const                      { return _os_lib; }\n-  void set_os_lib(void* os_lib)             { _os_lib = os_lib; }\n-  AgentLibrary* next() const                { return _next; }\n-  bool is_static_lib() const                { return _is_static_lib; }\n-  bool is_instrument_lib() const            { return _is_instrument_lib; }\n-  void set_static_lib(bool is_static_lib)   { _is_static_lib = is_static_lib; }\n-  bool valid()                              { return (_state == agent_valid); }\n-  void set_valid()                          { _state = agent_valid; }\n-\n-  \/\/ Constructor\n-  AgentLibrary(const char* name, const char* options, bool is_absolute_path,\n-               void* os_lib, bool instrument_lib=false);\n-};\n-\n-\/\/ maintain an order of entry list of AgentLibrary\n-class AgentLibraryList {\n- private:\n-  AgentLibrary*   _first;\n-  AgentLibrary*   _last;\n- public:\n-  bool is_empty() const                     { return _first == nullptr; }\n-  AgentLibrary* first() const               { return _first; }\n-\n-  \/\/ add to the end of the list\n-  void add(AgentLibrary* lib) {\n-    if (is_empty()) {\n-      _first = _last = lib;\n-    } else {\n-      _last->_next = lib;\n-      _last = lib;\n-    }\n-    lib->_next = nullptr;\n-  }\n-\n-  \/\/ search for and remove a library known to be in the list\n-  void remove(AgentLibrary* lib) {\n-    AgentLibrary* curr;\n-    AgentLibrary* prev = nullptr;\n-    for (curr = first(); curr != nullptr; prev = curr, curr = curr->next()) {\n-      if (curr == lib) {\n-        break;\n-      }\n-    }\n-    assert(curr != nullptr, \"always should be found\");\n-\n-    if (curr != nullptr) {\n-      \/\/ it was found, by-pass this library\n-      if (prev == nullptr) {\n-        _first = curr->_next;\n-      } else {\n-        prev->_next = curr->_next;\n-      }\n-      if (curr == _last) {\n-        _last = prev;\n-      }\n-      curr->_next = nullptr;\n-    }\n-  }\n-\n-  AgentLibraryList() {\n-    _first = nullptr;\n-    _last = nullptr;\n-  }\n-};\n-\n@@ -335,12 +243,0 @@\n-  \/\/ -Xrun arguments\n-  static AgentLibraryList _libraryList;\n-  static void add_init_library(const char* name, const char* options);\n-\n-  \/\/ -agentlib and -agentpath arguments\n-  static AgentLibraryList _agentList;\n-  static void add_init_agent(const char* name, const char* options, bool absolute_path);\n-  static void add_instrument_agent(const char* name, const char* options, bool absolute_path);\n-\n-  \/\/ Late-binding agents not started via arguments\n-  static void add_loaded_agent(AgentLibrary *agentLib);\n-\n@@ -350,3 +246,0 @@\n-  static bool _java_compiler;\n-  static void set_java_compiler(bool arg) { _java_compiler = arg; }\n-  static bool java_compiler()   { return _java_compiler; }\n@@ -410,1 +303,0 @@\n-  static void process_java_compiler_argument(const char* arg);\n@@ -546,11 +438,0 @@\n-  \/\/ -Xrun\n-  static AgentLibrary* libraries()          { return _libraryList.first(); }\n-  static bool init_libraries_at_startup()   { return !_libraryList.is_empty(); }\n-  static void convert_library_to_agent(AgentLibrary* lib)\n-                                            { _libraryList.remove(lib);\n-                                              _agentList.add(lib); }\n-\n-  \/\/ -agentlib -agentpath\n-  static AgentLibrary* agents()             { return _agentList.first(); }\n-  static bool init_agents_at_startup()      { return !_agentList.is_empty(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1090,2 +1090,4 @@\n-    guarantee(ik->is_initialized(), \"%s must be initialized\", klass_name_str);\n-    CacheType::compute_offsets(ik);\n+    if (!ik->is_in_error_state()) {\n+      guarantee(ik->is_initialized(), \"%s must be initialized\", klass_name_str);\n+      CacheType::compute_offsets(ik);\n+    }\n@@ -1104,5 +1106,11 @@\n-    objArrayOop cache = CacheType::cache(ik);\n-    assert(cache->length() > 0, \"Empty cache\");\n-    _low = BoxType::value(cache->obj_at(0));\n-    _high = _low + cache->length() - 1;\n-    _cache = JNIHandles::make_global(Handle(thread, cache));\n+    if (ik->is_in_error_state()) {\n+      _low = 1;\n+      _high = 0;\n+      _cache = nullptr;\n+    } else {\n+      objArrayOop cache = CacheType::cache(ik);\n+      assert(cache->length() > 0, \"Empty cache\");\n+      _low = BoxType::value(cache->obj_at(0));\n+      _high = _low + cache->length() - 1;\n+      _cache = JNIHandles::make_global(Handle(thread, cache));\n+    }\n@@ -1130,1 +1138,5 @@\n-  oop lookup_raw(intptr_t raw_value) {\n+  oop lookup_raw(intptr_t raw_value, bool& cache_init_error) {\n+    if (_cache == nullptr) {\n+      cache_init_error = true;\n+      return nullptr;\n+    }\n@@ -1160,2 +1172,7 @@\n-    _true_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_TRUE(ik)));\n-    _false_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_FALSE(ik)));\n+    if (ik->is_in_error_state()) {\n+      _true_cache = nullptr;\n+      _false_cache = nullptr;\n+    } else {\n+      _true_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_TRUE(ik)));\n+      _false_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_FALSE(ik)));\n+    }\n@@ -1177,1 +1194,5 @@\n-  oop lookup_raw(intptr_t raw_value) {\n+  oop lookup_raw(intptr_t raw_value, bool& cache_in_error) {\n+    if (_true_cache == nullptr) {\n+      cache_in_error = true;\n+      return nullptr;\n+    }\n@@ -1192,1 +1213,1 @@\n-oop Deoptimization::get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS) {\n+oop Deoptimization::get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, bool& cache_init_error, TRAPS) {\n@@ -1198,6 +1219,6 @@\n-       case T_INT:     return IntegerBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_CHAR:    return CharacterBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_SHORT:   return ShortBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_BYTE:    return ByteBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_LONG:    return LongBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n+       case T_INT:     return IntegerBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n+       case T_CHAR:    return CharacterBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n+       case T_SHORT:   return ShortBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n+       case T_BYTE:    return ByteBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n+       case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n+       case T_LONG:    return LongBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n@@ -1235,0 +1256,1 @@\n+    bool cache_init_error = false;\n@@ -1242,1 +1264,1 @@\n-        obj = get_cached_box(abv, fr, reg_map, THREAD);\n+        obj = get_cached_box(abv, fr, reg_map, cache_init_error, THREAD);\n@@ -1246,0 +1268,4 @@\n+        } else if (cache_init_error) {\n+          \/\/ Results in an OOME which is valid (as opposed to a class initialization error)\n+          \/\/ and is fine for the rare case a cache initialization failing.\n+          failures = true;\n@@ -1251,1 +1277,1 @@\n-      if (obj == nullptr) {\n+      if (obj == nullptr && !cache_init_error) {\n@@ -1281,1 +1307,1 @@\n-    assert(obj != nullptr || HAS_PENDING_EXCEPTION, \"allocation should succeed or we should get an exception\");\n+    assert(obj != nullptr || HAS_PENDING_EXCEPTION || cache_init_error, \"allocation should succeed or we should get an exception\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS);\n+  static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, bool& cache_init_error, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1285,1 +1285,1 @@\n-  GrowableArray<oop*>* _base;\n+  GrowableArray<derived_base*>* _base;\n@@ -1293,1 +1293,1 @@\n-    _base = new (mtThread) GrowableArray<oop*>(100, mtThread);\n+    _base = new (mtThread) GrowableArray<derived_base*>(100, mtThread);\n@@ -1305,1 +1305,1 @@\n-  virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+  virtual void do_derived_oop(derived_base* base_loc, derived_pointer* derived_loc) override {\n@@ -1325,1 +1325,1 @@\n-      oop* base = _base->at(i);\n+      derived_base* base = _base->at(i);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,           \\\n+  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,          \\\n@@ -369,0 +369,3 @@\n+  product_pd(bool, DelayCompilerStubsGeneration, DIAGNOSTIC,                \\\n+          \"Use Compiler thread for compiler's stubs generation\")            \\\n+                                                                            \\\n@@ -713,0 +716,7 @@\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  product(intx, GuaranteedAsyncDeflationInterval, 60000, DIAGNOSTIC,        \\\n+          \"Async deflate idle monitors every so many milliseconds even \"    \\\n+          \"when MonitorUsedDeflationThreshold is NOT exceeded (0 is off).\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n@@ -1311,2 +1321,2 @@\n-  product(bool, UseSystemMemoryBarrier, false, EXPERIMENTAL,                \\\n-          \"Try to enable system memory barrier\")                            \\\n+  product(bool, UseSystemMemoryBarrier, false,                              \\\n+          \"Try to enable system memory barrier if supported by OS\")         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,3 +69,3 @@\n-void stubRoutines_init1();\n-void stubRoutines_initContinuationStubs();\n-jint universe_init();          \/\/ depends on codeCache_init and stubRoutines_init\n+void initial_stubs_init();\n+\n+jint universe_init();           \/\/ depends on codeCache_init and initial_stubs_init\n@@ -74,2 +74,4 @@\n-void interpreter_init_stub();  \/\/ before any methods loaded\n-void interpreter_init_code();  \/\/ after methods loaded, but before they are linked\n+void continuations_init();      \/\/ depends on flags (UseCompressedOops) and barrier sets\n+void continuation_stubs_init(); \/\/ depend on continuations_init\n+void interpreter_init_stub();   \/\/ before any methods loaded\n+void interpreter_init_code();   \/\/ after methods loaded, but before they are linked\n@@ -78,1 +80,1 @@\n-void universe2_init();  \/\/ dependent on codeCache_init and stubRoutines_init, loads primordial classes\n+void universe2_init();  \/\/ dependent on codeCache_init and initial_stubs_init, loads primordial classes\n@@ -92,4 +94,3 @@\n-void javaClasses_init();  \/\/ must happen after vtable initialization\n-void stubRoutines_init2(); \/\/ note: StubRoutines need 2-phase init\n-\n-void continuations_init(); \/\/ depends on flags (UseCompressedOops) and barrier sets\n+void javaClasses_init();    \/\/ must happen after vtable initialization\n+void compiler_stubs_init(bool in_compiler_thread); \/\/ compiler's StubRoutines stubs\n+void final_stubs_init();    \/\/ final StubRoutines stubs\n@@ -123,1 +124,1 @@\n-  stubRoutines_init1();\n+  initial_stubs_init();\n@@ -125,1 +126,1 @@\n-                                  \/\/ stubRoutines_init1 and metaspace_init.\n+                                  \/\/ initial_stubs_init and metaspace_init.\n@@ -138,4 +139,4 @@\n-  gc_barrier_stubs_init();  \/\/ depends on universe_init, must be before interpreter_init\n-  continuations_init(); \/\/ must precede continuation stub generation\n-  stubRoutines_initContinuationStubs(); \/\/ depends on continuations_init\n-  interpreter_init_stub();  \/\/ before methods get loaded\n+  gc_barrier_stubs_init();   \/\/ depends on universe_init, must be before interpreter_init\n+  continuations_init();      \/\/ must precede continuation stub generation\n+  continuation_stubs_init(); \/\/ depends on continuations_init\n+  interpreter_init_stub();   \/\/ before methods get loaded\n@@ -144,3 +145,3 @@\n-  universe2_init();  \/\/ dependent on codeCache_init and stubRoutines_init1\n-  javaClasses_init();\/\/ must happen after vtable initialization, before referenceProcessor_init\n-  interpreter_init_code();  \/\/ after javaClasses_init and before any method gets linked\n+  universe2_init();          \/\/ dependent on codeCache_init and initial_stubs_init\n+  javaClasses_init();        \/\/ must happen after vtable initialization, before referenceProcessor_init\n+  interpreter_init_code();   \/\/ after javaClasses_init and before any method gets linked\n@@ -172,1 +173,2 @@\n-  stubRoutines_init2(); \/\/ note: StubRoutines need 2-phase init\n+  compiler_stubs_init(false \/* in_compiler_thread *\/); \/\/ compiler's intrinsics stubs\n+  final_stubs_init();    \/\/ final StubRoutines stubs\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -380,0 +380,3 @@\n+  \/\/ Don't complain if running a debugging command.\n+  if (DebuggingContext::is_enabled()) return;\n+\n@@ -694,0 +697,4 @@\n+  if (AlwaysPreTouchStacks) {\n+    pretouch_stack();\n+  }\n+\n@@ -736,1 +743,3 @@\n-  \/\/ to complete once we've done the notify_all below\n+  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n+  \/\/ requirements.\n+  OrderAccess::release();\n@@ -2027,3 +2036,1 @@\n-  \/\/ We could get here with a pending exception, if so clear it now or\n-  \/\/ it will cause MetaspaceShared::link_shared_classes to\n-  \/\/ fail for dynamic dump.\n+  \/\/ We could get here with a pending exception, if so clear it now.\n@@ -2034,9 +2041,0 @@\n-#if INCLUDE_CDS\n-  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n-  \/\/ Same operation is being done in JVM_BeforeHalt for handling the\n-  \/\/ case where the application calls System.exit().\n-  if (DynamicArchive::should_dump_at_vm_exit()) {\n-    DynamicArchive::prepare_for_dump_at_exit();\n-  }\n-#endif\n-\n@@ -2073,2 +2071,1 @@\n-Handle JavaThread::create_system_thread_object(const char* name,\n-                                               bool is_visible, TRAPS) {\n+Handle JavaThread::create_system_thread_object(const char* name, TRAPS) {\n@@ -2131,0 +2128,19 @@\n+void JavaThread::pretouch_stack() {\n+  \/\/ Given an established java thread stack with usable area followed by\n+  \/\/ shadow zone and reserved\/yellow\/red zone, pretouch the usable area ranging\n+  \/\/ from the current frame down to the start of the shadow zone.\n+  const address end = _stack_overflow_state.shadow_zone_safe_limit();\n+  if (is_in_full_stack(end)) {\n+    char* p1 = (char*) alloca(1);\n+    address here = (address) &p1;\n+    if (is_in_full_stack(here) && here > end) {\n+      size_t to_alloc = here - end;\n+      char* p2 = (char*) alloca(to_alloc);\n+      log_trace(os, thread)(\"Pretouching thread stack from \" PTR_FORMAT \" to \" PTR_FORMAT \".\",\n+                            p2i(p2), p2i(end));\n+      os::pretouch_memory(p2, p2 + to_alloc,\n+                          NOT_AIX(os::vm_page_size()) AIX_ONLY(4096));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -419,0 +419,2 @@\n+  void pretouch_stack();\n+\n@@ -1158,4 +1160,3 @@\n-  \/\/ VM-internal thread. The thread will have the given name, be\n-  \/\/ part of the System ThreadGroup and if is_visible is true will be\n-  \/\/ discoverable via the system ThreadGroup.\n-  static Handle create_system_thread_object(const char* name, bool is_visible, TRAPS);\n+  \/\/ VM-internal thread. The thread will have the given name and be\n+  \/\/ part of the System ThreadGroup.\n+  static Handle create_system_thread_object(const char* name, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -71,1 +72,1 @@\n-#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -236,0 +237,1 @@\n+#ifdef _WIN64\n@@ -240,0 +242,1 @@\n+#endif\n@@ -241,1 +244,2 @@\n-JRT_LEAF(jfloat, SharedRuntime::frem(jfloat  x, jfloat  y))\n+#if !defined(X86) || !defined(TARGET_COMPILER_gcc) || defined(_WIN64)\n+JRT_LEAF(jfloat, SharedRuntime::frem(jfloat x, jfloat y))\n@@ -245,3 +249,2 @@\n-  union { jfloat f; juint i; } xbits, ybits;\n-  xbits.f = x;\n-  ybits.f = y;\n+  juint xbits = PrimitiveConversions::cast<juint>(x);\n+  juint ybits = PrimitiveConversions::cast<juint>(y);\n@@ -249,2 +252,2 @@\n-  if (((xbits.i & float_sign_mask) != float_infinity) &&\n-       ((ybits.i & float_sign_mask) == float_infinity) ) {\n+  if (((xbits & float_sign_mask) != float_infinity) &&\n+       ((ybits & float_sign_mask) == float_infinity) ) {\n@@ -259,1 +262,0 @@\n-\n@@ -262,3 +264,2 @@\n-  union { jdouble d; julong l; } xbits, ybits;\n-  xbits.d = x;\n-  ybits.d = y;\n+  julong xbits = PrimitiveConversions::cast<julong>(x);\n+  julong ybits = PrimitiveConversions::cast<julong>(y);\n@@ -266,2 +267,2 @@\n-  if (((xbits.l & double_sign_mask) != double_infinity) &&\n-       ((ybits.l & double_sign_mask) == double_infinity) ) {\n+  if (((xbits & double_sign_mask) != double_infinity) &&\n+       ((ybits & double_sign_mask) == double_infinity) ) {\n@@ -275,0 +276,1 @@\n+#endif \/\/ !X86 || !TARGET_COMPILER_gcc || _WIN64\n@@ -632,0 +634,8 @@\n+JRT_ENTRY(void, SharedRuntime::notify_jvmti_object_alloc(oopDesc* o, JavaThread* current))\n+  Handle h = Handle(current, o);\n+  if (JvmtiExport::should_post_vm_object_alloc()) {\n+    JvmtiExport::post_vm_object_alloc(current, o);\n+  }\n+  current->set_vm_result(h());\n+JRT_END\n+\n@@ -640,0 +650,2 @@\n+\n+  JNIHandles::destroy_local(vthread);\n@@ -650,0 +662,2 @@\n+\n+  JNIHandles::destroy_local(vthread);\n@@ -3216,5 +3230,5 @@\n-  \/\/ StubRoutines::code2() is initialized after this function can be called. As a result,\n-  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated\n-  \/\/ prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C\n-  \/\/ stub that ensure that an I2C stub is called from an interpreter frame.\n-  bool contains_all_checks = StubRoutines::code2() != nullptr;\n+  \/\/ StubRoutines::_final_stubs_code is initialized after this function can be called. As a result,\n+  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated prior\n+  \/\/ to all StubRoutines::_final_stubs_code being set. Checks refer to runtime range checks generated\n+  \/\/ in an I2C stub that ensure that an I2C stub is called from an interpreter frame or stubs.\n+  bool contains_all_checks = StubRoutines::final_stubs_code() != nullptr;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -269,0 +269,1 @@\n+  static void notify_jvmti_object_alloc(oopDesc* o, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,1 +76,13 @@\n-  return *(oop*)addr;\n+  oop val = *(oop*)addr;\n+\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    \/\/ Pass the value through the barrier to avoid capturing bad oops as\n+    \/\/ stack values. Note: do not heal the location, to avoid accidentally\n+    \/\/ corrupting the stack. Stack watermark barriers are supposed to handle\n+    \/\/ the healing.\n+    val = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(val);\n+  }\n+#endif\n+\n+  return val;\n@@ -101,1 +113,13 @@\n-  return CompressedOops::decode(*narrow_addr);\n+  oop val = CompressedOops::decode(*narrow_addr);\n+\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    \/\/ Pass the value through the barrier to avoid capturing bad oops as\n+    \/\/ stack values. Note: do not heal the location, to avoid accidentally\n+    \/\/ corrupting the stack. Stack watermark barriers are supposed to handle\n+    \/\/ the healing.\n+    val = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(val);\n+  }\n+#endif\n+\n+  return val;\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -53,3 +53,4 @@\n-BufferBlob* StubRoutines::_code1                                = nullptr;\n-BufferBlob* StubRoutines::_code2                                = nullptr;\n-BufferBlob* StubRoutines::_code3                                = nullptr;\n+BufferBlob* StubRoutines::_initial_stubs_code                   = nullptr;\n+BufferBlob* StubRoutines::_final_stubs_code                     = nullptr;\n+BufferBlob* StubRoutines::_compiler_stubs_code                  = nullptr;\n+BufferBlob* StubRoutines::_continuation_stubs_code              = nullptr;\n@@ -193,1 +194,1 @@\n-extern void StubGenerator_generate(CodeBuffer* code, int phase); \/\/ only interface to generators\n+extern void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind); \/\/ only interface to generators\n@@ -220,16 +221,57 @@\n-void StubRoutines::initialize1() {\n-  if (_code1 == nullptr) {\n-    ResourceMark rm;\n-    TraceTime timer(\"StubRoutines generation 1\", TRACETIME_LOG(Info, startuptime));\n-    \/\/ Add extra space for large CodeEntryAlignment\n-    int max_aligned_stubs = 10;\n-    int size = code_size1 + CodeEntryAlignment * max_aligned_stubs;\n-    _code1 = BufferBlob::create(\"StubRoutines (1)\", size);\n-    if (_code1 == nullptr) {\n-      vm_exit_out_of_memory(code_size1, OOM_MALLOC_ERROR, \"CodeCache: no room for StubRoutines (1)\");\n-    }\n-    CodeBuffer buffer(_code1);\n-    StubGenerator_generate(&buffer, 0);\n-    \/\/ When new stubs added we need to make sure there is some space left\n-    \/\/ to catch situation when we should increase size again.\n-    assert(code_size1 == 0 || buffer.insts_remaining() > 200, \"increase code_size1\");\n+\n+static BufferBlob* initialize_stubs(StubCodeGenerator::StubsKind kind,\n+                                    int code_size, int max_aligned_stubs,\n+                                    const char* timer_msg,\n+                                    const char* buffer_name,\n+                                    const char* assert_msg) {\n+  ResourceMark rm;\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+  \/\/ Add extra space for large CodeEntryAlignment\n+  int size = code_size + CodeEntryAlignment * max_aligned_stubs;\n+  BufferBlob* stubs_code = BufferBlob::create(buffer_name, size);\n+  if (stubs_code == nullptr) {\n+    vm_exit_out_of_memory(code_size, OOM_MALLOC_ERROR, \"CodeCache: no room for %s\", buffer_name);\n+  }\n+  CodeBuffer buffer(stubs_code);\n+  StubGenerator_generate(&buffer, kind);\n+  \/\/ When new stubs added we need to make sure there is some space left\n+  \/\/ to catch situation when we should increase size again.\n+  assert(code_size == 0 || buffer.insts_remaining() > 200, \"increase %s\", assert_msg);\n+\n+  LogTarget(Info, stubs) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"%s\\t [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \"] used: %d, free: %d\",\n+                buffer_name, p2i(stubs_code->content_begin()), p2i(stubs_code->content_end()),\n+                buffer.total_content_size(), buffer.insts_remaining());\n+  }\n+  return stubs_code;\n+}\n+\n+void StubRoutines::initialize_initial_stubs() {\n+  if (_initial_stubs_code == nullptr) {\n+    _initial_stubs_code = initialize_stubs(StubCodeGenerator::Initial_stubs,\n+                                           _initial_stubs_code_size, 10,\n+                                           \"StubRoutines generation initial stubs\",\n+                                           \"StubRoutines (initial stubs)\",\n+                                           \"_initial_stubs_code_size\");\n+  }\n+}\n+\n+void StubRoutines::initialize_continuation_stubs() {\n+  if (_continuation_stubs_code == nullptr) {\n+    _continuation_stubs_code = initialize_stubs(StubCodeGenerator::Continuation_stubs,\n+                                           _continuation_stubs_code_size, 10,\n+                                           \"StubRoutines generation continuation stubs\",\n+                                           \"StubRoutines (continuation stubs)\",\n+                                           \"_continuation_stubs_code_size\");\n+  }\n+}\n+\n+void StubRoutines::initialize_compiler_stubs() {\n+  if (_compiler_stubs_code == nullptr) {\n+    _compiler_stubs_code = initialize_stubs(StubCodeGenerator::Compiler_stubs,\n+                                           _compiler_stubs_code_size, 100,\n+                                           \"StubRoutines generation compiler stubs\",\n+                                           \"StubRoutines (compiler stubs)\",\n+                                           \"_compiler_stubs_code_size\");\n@@ -276,32 +318,7 @@\n-void StubRoutines::initializeContinuationStubs() {\n-  if (_code3 == nullptr) {\n-    ResourceMark rm;\n-    TraceTime timer(\"StubRoutines generation 3\", TRACETIME_LOG(Info, startuptime));\n-    _code3 = BufferBlob::create(\"StubRoutines (3)\", code_size2);\n-    if (_code3 == nullptr) {\n-      vm_exit_out_of_memory(code_size2, OOM_MALLOC_ERROR, \"CodeCache: no room for StubRoutines (3)\");\n-    }\n-    CodeBuffer buffer(_code3);\n-    StubGenerator_generate(&buffer, 1);\n-    \/\/ When new stubs added we need to make sure there is some space left\n-    \/\/ to catch situation when we should increase size again.\n-    assert(code_size2 == 0 || buffer.insts_remaining() > 200, \"increase code_size3\");\n-  }\n-}\n-\n-void StubRoutines::initialize2() {\n-  if (_code2 == nullptr) {\n-    ResourceMark rm;\n-    TraceTime timer(\"StubRoutines generation 2\", TRACETIME_LOG(Info, startuptime));\n-    \/\/ Add extra space for large CodeEntryAlignment\n-    int max_aligned_stubs = 100;\n-    int size = code_size2 + CodeEntryAlignment * max_aligned_stubs;\n-    _code2 = BufferBlob::create(\"StubRoutines (2)\", size);\n-    if (_code2 == nullptr) {\n-      vm_exit_out_of_memory(code_size2, OOM_MALLOC_ERROR, \"CodeCache: no room for StubRoutines (2)\");\n-    }\n-    CodeBuffer buffer(_code2);\n-    StubGenerator_generate(&buffer, 2);\n-    \/\/ When new stubs added we need to make sure there is some space left\n-    \/\/ to catch situation when we should increase size again.\n-    assert(code_size2 == 0 || buffer.insts_remaining() > 200, \"increase code_size2\");\n+void StubRoutines::initialize_final_stubs() {\n+  if (_final_stubs_code == nullptr) {\n+    _final_stubs_code = initialize_stubs(StubCodeGenerator::Final_stubs,\n+                                         _final_stubs_code_size, 10,\n+                                         \"StubRoutines generation final stubs\",\n+                                         \"StubRoutines (final stubs)\",\n+                                         \"_final_stubs_code_size\");\n@@ -393,3 +410,18 @@\n-void stubRoutines_init1() { StubRoutines::initialize1(); }\n-void stubRoutines_init2() { StubRoutines::initialize2(); }\n-void stubRoutines_initContinuationStubs() { StubRoutines::initializeContinuationStubs(); }\n+void initial_stubs_init()      { StubRoutines::initialize_initial_stubs(); }\n+void continuation_stubs_init() { StubRoutines::initialize_continuation_stubs(); }\n+void final_stubs_init()        { StubRoutines::initialize_final_stubs(); }\n+\n+void compiler_stubs_init(bool in_compiler_thread) {\n+  if (in_compiler_thread && DelayCompilerStubsGeneration) {\n+    \/\/ Temporarily revert state of stubs generation because\n+    \/\/ it is called after final_stubs_init() finished\n+    \/\/ during compiler runtime initialization.\n+    \/\/ It is fine because these stubs are only used by\n+    \/\/ compiled code and compiler is not running yet.\n+    StubCodeDesc::unfreeze();\n+    StubRoutines::initialize_compiler_stubs();\n+    StubCodeDesc::freeze();\n+  } else if (!in_compiler_thread && !DelayCompilerStubsGeneration) {\n+    StubRoutines::initialize_compiler_stubs();\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":87,"deletions":55,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -151,3 +151,4 @@\n-  static BufferBlob* _code1;                               \/\/ code buffer for initial routines\n-  static BufferBlob* _code2;\n-  static BufferBlob* _code3;                               \/\/ code buffer for all other routines\n+  static BufferBlob* _initial_stubs_code;                  \/\/ code buffer for initial routines\n+  static BufferBlob* _continuation_stubs_code;             \/\/ code buffer for continuation stubs\n+  static BufferBlob* _compiler_stubs_code;                 \/\/ code buffer for C2 intrinsics\n+  static BufferBlob* _final_stubs_code;                    \/\/ code buffer for all other routines\n@@ -271,3 +272,4 @@\n-  static void    initialize1();                            \/\/ must happen before universe::genesis\n-  static void    initialize2();                            \/\/ must happen after  universe::genesis\n-  static void    initializeContinuationStubs();            \/\/ must happen after  universe::genesis\n+  static void    initialize_initial_stubs();               \/\/ must happen before universe::genesis\n+  static void    initialize_continuation_stubs();          \/\/ must happen after  universe::genesis\n+  static void    initialize_compiler_stubs();              \/\/ must happen after  universe::genesis\n+  static void    initialize_final_stubs();                 \/\/ must happen after  universe::genesis\n@@ -279,2 +281,4 @@\n-      (_code1 != nullptr && _code1->blob_contains(addr)) ||\n-      (_code2 != nullptr && _code2->blob_contains(addr)) ;\n+      (_initial_stubs_code      != nullptr && _initial_stubs_code->blob_contains(addr))  ||\n+      (_continuation_stubs_code != nullptr && _continuation_stubs_code->blob_contains(addr)) ||\n+      (_compiler_stubs_code     != nullptr && _compiler_stubs_code->blob_contains(addr)) ||\n+      (_final_stubs_code        != nullptr && _final_stubs_code->blob_contains(addr)) ;\n@@ -283,3 +287,4 @@\n-  static RuntimeBlob* code1() { return _code1; }\n-  static RuntimeBlob* code2() { return _code2; }\n-  static RuntimeBlob* code3() { return _code3; }\n+  static RuntimeBlob* initial_stubs_code()      { return _initial_stubs_code; }\n+  static RuntimeBlob* continuation_stubs_code() { return _continuation_stubs_code; }\n+  static RuntimeBlob* compiler_stubs_code()     { return _compiler_stubs_code; }\n+  static RuntimeBlob* final_stubs_code()        { return _final_stubs_code; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -248,2 +248,10 @@\n-static const int NINFLATIONLOCKS = 256;\n-static PlatformMutex* gInflationLocks[NINFLATIONLOCKS];\n+static constexpr size_t inflation_lock_count() {\n+  return 256;\n+}\n+\n+\/\/ Static storage for an array of PlatformMutex.\n+alignas(PlatformMutex) static uint8_t _inflation_locks[inflation_lock_count()][sizeof(PlatformMutex)];\n+\n+static inline PlatformMutex* inflation_lock(size_t index) {\n+  return reinterpret_cast<PlatformMutex*>(_inflation_locks[index]);\n+}\n@@ -252,2 +260,2 @@\n-  for (int i = 0; i < NINFLATIONLOCKS; i++) {\n-    gInflationLocks[i] = new PlatformMutex();\n+  for (size_t i = 0; i < inflation_lock_count(); i++) {\n+    ::new(static_cast<void*>(inflation_lock(i))) PlatformMutex();\n@@ -257,0 +265,3 @@\n+\n+  \/\/ Start the timer for deflations, so it does not trigger immediately.\n+  _last_async_deflation_time_ns = os::javaTimeNanos();\n@@ -285,0 +296,1 @@\n+static bool _no_progress_skip_increment = false;\n@@ -769,2 +781,2 @@\n-        static_assert(is_power_of_2(NINFLATIONLOCKS), \"must be\");\n-        int ix = (cast_from_oop<intptr_t>(obj) >> 5) & (NINFLATIONLOCKS-1);\n+        static_assert(is_power_of_2(inflation_lock_count()), \"must be\");\n+        size_t ix = (cast_from_oop<intptr_t>(obj) >> 5) & (inflation_lock_count() - 1);\n@@ -772,2 +784,2 @@\n-        assert(ix >= 0 && ix < NINFLATIONLOCKS, \"invariant\");\n-        gInflationLocks[ix]->lock();\n+        assert(ix < inflation_lock_count(), \"invariant\");\n+        inflation_lock(ix)->lock();\n@@ -784,1 +796,1 @@\n-        gInflationLocks[ix]->unlock();\n+        inflation_lock(ix)->unlock();\n@@ -1108,1 +1120,8 @@\n-  return int(monitor_usage) > MonitorUsedDeflationThreshold;\n+  if (int(monitor_usage) > MonitorUsedDeflationThreshold) {\n+    log_info(monitorinflation)(\"monitors_used=\" SIZE_FORMAT \", ceiling=\" SIZE_FORMAT\n+                               \", monitor_usage=\" SIZE_FORMAT \", threshold=\" INTX_FORMAT,\n+                               monitors_used, ceiling, monitor_usage, MonitorUsedDeflationThreshold);\n+    return true;\n+  }\n+\n+  return false;\n@@ -1130,0 +1149,1 @@\n+    log_info(monitorinflation)(\"Async deflation needed: explicit request\");\n@@ -1132,0 +1152,3 @@\n+\n+  jlong time_since_last = time_since_last_async_deflation_ms();\n+\n@@ -1133,1 +1156,1 @@\n-      time_since_last_async_deflation_ms() > AsyncDeflationInterval &&\n+      time_since_last > AsyncDeflationInterval &&\n@@ -1139,0 +1162,27 @@\n+    log_info(monitorinflation)(\"Async deflation needed: monitors used are above the threshold\");\n+    return true;\n+  }\n+\n+  if (GuaranteedAsyncDeflationInterval > 0 &&\n+      time_since_last > GuaranteedAsyncDeflationInterval) {\n+    \/\/ It's been longer than our specified guaranteed deflate interval.\n+    \/\/ We need to clean up the used monitors even if the threshold is\n+    \/\/ not reached, to keep the memory utilization at bay when many threads\n+    \/\/ touched many monitors.\n+    log_info(monitorinflation)(\"Async deflation needed: guaranteed interval (\" INTX_FORMAT \" ms) \"\n+                               \"is greater than time since last deflation (\" JLONG_FORMAT \" ms)\",\n+                               GuaranteedAsyncDeflationInterval, time_since_last);\n+\n+    \/\/ If this deflation has no progress, then it should not affect the no-progress\n+    \/\/ tracking, otherwise threshold heuristics would think it was triggered, experienced\n+    \/\/ no progress, and needs to backoff more aggressively. In this \"no progress\" case,\n+    \/\/ the generic code would bump the no-progress counter, and we compensate for that\n+    \/\/ by telling it to skip the update.\n+    \/\/\n+    \/\/ If this deflation has progress, then it should let non-progress tracking\n+    \/\/ know about this, otherwise the threshold heuristics would kick in, potentially\n+    \/\/ experience no-progress due to aggressive cleanup by this deflation, and think\n+    \/\/ it is still in no-progress stride. In this \"progress\" case, the generic code would\n+    \/\/ zero the counter, and we allow it to happen.\n+    _no_progress_skip_increment = true;\n+\n@@ -1141,0 +1191,1 @@\n+\n@@ -1562,0 +1613,2 @@\n+  } else if (_no_progress_skip_increment) {\n+    _no_progress_skip_increment = false;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":64,"deletions":11,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  template(SetNotifyJvmtiEventsMode)              \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -226,0 +226,2 @@\n+  nonstatic_field(ConstantPoolCache,           _resolved_indy_entries,                        Array<ResolvedIndyEntry>*)             \\\n+  nonstatic_field(ResolvedIndyEntry,           _cpool_index,                                  u2)                                    \\\n@@ -239,1 +241,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -478,0 +479,2 @@\n+  nonstatic_field(Array<ResolvedIndyEntry>,    _length,                                       int)                                   \\\n+  nonstatic_field(Array<ResolvedIndyEntry>,    _data[0],                                      ResolvedIndyEntry)                     \\\n@@ -1024,6 +1027,7 @@\n-  nonstatic_field(Array<int>,                  _length,                                       int)                                   \\\n-  unchecked_nonstatic_field(Array<int>,        _data,                                         sizeof(int))                           \\\n-  unchecked_nonstatic_field(Array<u1>,         _data,                                         sizeof(u1))                            \\\n-  unchecked_nonstatic_field(Array<u2>,         _data,                                         sizeof(u2))                            \\\n-  unchecked_nonstatic_field(Array<Method*>,    _data,                                         sizeof(Method*))                       \\\n-  unchecked_nonstatic_field(Array<Klass*>,     _data,                                         sizeof(Klass*))                        \\\n+  nonstatic_field(Array<int>,                         _length,                                int)                                   \\\n+  unchecked_nonstatic_field(Array<int>,               _data,                                  sizeof(int))                           \\\n+  unchecked_nonstatic_field(Array<u1>,                _data,                                  sizeof(u1))                            \\\n+  unchecked_nonstatic_field(Array<u2>,                _data,                                  sizeof(u2))                            \\\n+  unchecked_nonstatic_field(Array<Method*>,           _data,                                  sizeof(Method*))                       \\\n+  unchecked_nonstatic_field(Array<Klass*>,            _data,                                  sizeof(Klass*))                        \\\n+  unchecked_nonstatic_field(Array<ResolvedIndyEntry>, _data,                                  sizeof(ResolvedIndyEntry))             \\\n@@ -1772,0 +1776,2 @@\n+  declare_c2_type(CompressBitsVNode, VectorNode)                          \\\n+  declare_c2_type(ExpandBitsVNode, VectorNode)                            \\\n@@ -1960,0 +1966,1 @@\n+            declare_type(Array<ResolvedIndyEntry>, MetaspaceObj)          \\\n@@ -1976,0 +1983,1 @@\n+  declare_toplevel_type(ResolvedIndyEntry)                                \\\n@@ -2089,2 +2097,0 @@\n-  declare_constant(JVM_ACC_HAS_LINE_NUMBER_TABLE)                         \\\n-  declare_constant(JVM_ACC_HAS_CHECKED_EXCEPTIONS)                        \\\n@@ -2095,2 +2101,0 @@\n-  declare_constant(JVM_ACC_HAS_MIRANDA_METHODS)                           \\\n-  declare_constant(JVM_ACC_HAS_VANILLA_CONSTRUCTOR)                       \\\n@@ -2099,1 +2103,0 @@\n-  declare_constant(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -196,10 +197,0 @@\n-      JavaPermission p = factory->permission();\n-      if(p._class != nullptr) {\n-        if(p._action != nullptr) {\n-          output()->print_cr(\"\\nPermission: %s(%s, %s)\",\n-                  p._class, p._name == nullptr ? \"null\" : p._name, p._action);\n-        } else {\n-          output()->print_cr(\"\\nPermission: %s(%s)\",\n-                  p._class, p._name == nullptr ? \"null\" : p._name);\n-        }\n-      }\n@@ -310,2 +301,1 @@\n-      JvmtiExport::load_agent_library(\"instrument\", \"false\",\n-                                      _libpath.value(), output());\n+      JvmtiAgentList::load_agent(\"instrument\", \"false\", _libpath.value(), output());\n@@ -328,1 +318,1 @@\n-      JvmtiExport::load_agent_library(\"instrument\", \"false\", opt, output());\n+      JvmtiAgentList::load_agent(\"instrument\", \"false\", opt, output());\n@@ -333,2 +323,1 @@\n-    JvmtiExport::load_agent_library(_libpath.value(), \"true\",\n-                                    _option.value(), output());\n+    JvmtiAgentList::load_agent(_libpath.value(), \"true\", _option.value(), output());\n@@ -1068,1 +1057,3 @@\n-    for (AgentLibrary* agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n+    JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+    while (it.has_next()) {\n+      JvmtiAgent* agent = it.next();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-                        \"monitor\", nullptr};\n+                        \"control\", nullptr};\n@@ -749,1 +749,1 @@\n-                        \"monitor\", nullptr};\n+                        \"control\", nullptr};\n@@ -769,1 +769,1 @@\n-                        \"monitor\", nullptr};\n+                        \"control\", nullptr};\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-  JVM_ACC_HAS_LINE_NUMBER_TABLE   = 0x00100000,\n-  JVM_ACC_HAS_CHECKED_EXCEPTIONS  = 0x00400000,\n@@ -64,2 +62,0 @@\n-  JVM_ACC_HAS_MIRANDA_METHODS     = 0x10000000,     \/\/ True if this class has miranda methods in it's vtable\n-  JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000,     \/\/ True if klass has a vanilla default constructor\n@@ -68,2 +64,0 @@\n-  JVM_ACC_HAS_FINAL_METHOD        = 0x01000000,     \/\/ True if klass has final method\n-  JVM_ACC_IS_SHARED_CLASS         = 0x02000000,     \/\/ True if klass is shared\n@@ -72,5 +66,0 @@\n-  JVM_ACC_IS_BEING_REDEFINED      = 0x00100000,     \/\/ True if the klass is being redefined.\n-  JVM_ACC_HAS_RESOLVED_METHODS    = 0x00200000,     \/\/ True if the klass has resolved methods\n-\n-  \/\/ Method* flags\n-  JVM_ACC_HAS_LOCAL_VARIABLE_TABLE= 0x00400000,\n@@ -117,2 +106,0 @@\n-  bool has_linenumber_table    () const { return (_flags & JVM_ACC_HAS_LINE_NUMBER_TABLE  ) != 0; }\n-  bool has_checked_exceptions  () const { return (_flags & JVM_ACC_HAS_CHECKED_EXCEPTIONS ) != 0; }\n@@ -126,4 +113,0 @@\n-  bool has_miranda_methods     () const { return (_flags & JVM_ACC_HAS_MIRANDA_METHODS    ) != 0; }\n-  bool has_vanilla_constructor () const { return (_flags & JVM_ACC_HAS_VANILLA_CONSTRUCTOR) != 0; }\n-  bool has_final_method        () const { return (_flags & JVM_ACC_HAS_FINAL_METHOD       ) != 0; }\n-  bool is_shared_class         () const { return (_flags & JVM_ACC_IS_SHARED_CLASS        ) != 0; }\n@@ -135,12 +118,0 @@\n-  \/\/ Method* flags\n-  bool has_localvariable_table () const { return (_flags & JVM_ACC_HAS_LOCAL_VARIABLE_TABLE) != 0; }\n-  void set_has_localvariable_table()    { atomic_set_bits(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE); }\n-  void clear_has_localvariable_table()  { atomic_clear_bits(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE); }\n-\n-  bool is_being_redefined() const       { return (_flags & JVM_ACC_IS_BEING_REDEFINED) != 0; }\n-  void set_is_being_redefined()         { atomic_set_bits(JVM_ACC_IS_BEING_REDEFINED); }\n-  void clear_is_being_redefined()       { atomic_clear_bits(JVM_ACC_IS_BEING_REDEFINED); }\n-\n-  bool has_resolved_methods() const     { return (_flags & JVM_ACC_HAS_RESOLVED_METHODS) != 0; }\n-  void set_has_resolved_methods()       { atomic_set_bits(JVM_ACC_HAS_RESOLVED_METHODS); }\n-\n@@ -184,2 +155,0 @@\n-  void set_has_linenumber_table()      { atomic_set_bits(JVM_ACC_HAS_LINE_NUMBER_TABLE);   }\n-  void set_has_checked_exceptions()    { atomic_set_bits(JVM_ACC_HAS_CHECKED_EXCEPTIONS);  }\n@@ -196,4 +165,0 @@\n-  void set_has_vanilla_constructor()   { atomic_set_bits(JVM_ACC_HAS_VANILLA_CONSTRUCTOR); }\n-  void set_has_final_method()          { atomic_set_bits(JVM_ACC_HAS_FINAL_METHOD);        }\n-  void set_has_miranda_methods()       { atomic_set_bits(JVM_ACC_HAS_MIRANDA_METHODS);     }\n-  void set_is_shared_class()           { atomic_set_bits(JVM_ACC_IS_SHARED_CLASS);         }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/attributeNoreturn.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -820,1 +820,1 @@\n-  void* operator new(size_t size) throw() {\n+  void* operator new(size_t size) {\n@@ -827,0 +827,3 @@\n+  void operator delete(void *p) {\n+    AnyObj::operator delete(p);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+ * @spec serialization\/index.html Java Object Serialization Specification\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+ * @spec serialization\/index.html Java Object Serialization Specification\n@@ -593,1 +594,1 @@\n-     * NullReferenceException in classes that contain references to the\n+     * {@link NullPointerException} in classes that contain references to the\n@@ -679,0 +680,1 @@\n+     * @spec serialization\/index.html Java Object Serialization Specification\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+ * @spec serialization\/index.html Java Object Serialization Specification\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+ * @spec serialization\/index.html Java Object Serialization Specification\n@@ -198,2 +199,0 @@\n- * @see <a href=\"{@docRoot}\/..\/specs\/serialization\/index.html\">\n- *      <cite>Java Object Serialization Specification<\/cite><\/a>\n","filename":"src\/java.base\/share\/classes\/java\/io\/Serializable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-import jdk.internal.vm.annotation.ChangesCurrentThread;\n@@ -765,2 +764,0 @@\n-     * <tr><th scope=\"row\">{@systemProperty java.compiler}<\/th>\n-     *     <td>Name of JIT compiler to use<\/td><\/tr>\n@@ -2014,0 +2011,2 @@\n+     *\n+     * @spec jni\/index.html Java Native Interface Specification\n@@ -2050,0 +2049,2 @@\n+     *\n+     * @spec jni\/index.html Java Native Interface Specification\n@@ -2567,10 +2568,2 @@\n-            @ChangesCurrentThread\n-                Thread thread = Thread.currentThread();\n-                if (thread.isVirtual()) {\n-                    Thread carrier = Thread.currentCarrierThread();\n-                    carrier.setCurrentThread(carrier);\n-                    try {\n-                        return task.call();\n-                    } finally {\n-                        carrier.setCurrentThread(thread);\n-                    }\n+                if (Thread.currentThread() instanceof VirtualThread vthread) {\n+                    return vthread.executeOnCarrierThread(task);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -365,0 +366,3 @@\n+    @Override\n+    Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,1 @@\n-import static java.lang.constant.ConstantUtils.dropFirstAndLastChar;\n-import static java.lang.constant.ConstantUtils.internalToBinary;\n+import static java.lang.constant.ConstantUtils.*;\n@@ -46,1 +45,1 @@\n-     * interface type\n+     * interface type or an array type.\n@@ -71,9 +70,7 @@\n-        ClassDesc c = this;\n-        int depth = ConstantUtils.arrayDepth(descriptorString());\n-        for (int i=0; i<depth; i++)\n-            c = c.componentType();\n-\n-        if (c.isPrimitive())\n-            return lookup.findClass(descriptorString());\n-        else {\n-            Class<?> clazz = lookup.findClass(internalToBinary(dropFirstAndLastChar(c.descriptorString())));\n+        if (isArray()) {\n+            if (isPrimitiveArray()) {\n+                return lookup.findClass(descriptor);\n+            }\n+            \/\/ Class.forName is slow on class or interface arrays\n+            int depth = ConstantUtils.arrayDepth(descriptor);\n+            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n@@ -90,0 +87,11 @@\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n+    }\n+\n+    \/**\n+     * Whether the descriptor is one of a primitive array, given this is\n+     * already a valid reference type descriptor.\n+     *\/\n+    private boolean isPrimitiveArray() {\n+        \/\/ All L-type descriptors must end with a semicolon; same for reference\n+        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n+        return descriptor.charAt(descriptor.length() - 1) != ';';\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDescImpl.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    \/** {@link MethodHandleDesc} representing {@link ConstantBootstraps#staticFieldVarHandle(Lookup, String, Class, Class, Class) ConstantBootstraps.staticVarHandle} *\/\n+    \/** {@link MethodHandleDesc} representing {@link ConstantBootstraps#staticFieldVarHandle(Lookup, String, Class, Class, Class) ConstantBootstraps.staticFieldVarHandle} *\/\n@@ -231,1 +231,1 @@\n-     * {@link MethodHandleDesc} representing {@link ConstantBootstraps#explicitCast(Lookup, String, Class, Object)} ConstantBootstraps.explicitCast}\n+     * {@link MethodHandleDesc} representing {@link ConstantBootstraps#explicitCast(Lookup, String, Class, Object) ConstantBootstraps.explicitCast}\n@@ -266,1 +266,1 @@\n-     * {@link MethodHandleDesc} representing {@link MethodHandles#classData(Lookup, String, Class)} MethodHandles.classData}\n+     * {@link MethodHandleDesc} representing {@link MethodHandles#classData(Lookup, String, Class) MethodHandles.classData}\n@@ -274,1 +274,1 @@\n-     * {@link MethodHandleDesc} representing {@link MethodHandles#classDataAt(Lookup, String, Class, int)} MethodHandles.classDataAt}\n+     * {@link MethodHandleDesc} representing {@link MethodHandles#classDataAt(Lookup, String, Class, int) MethodHandles.classDataAt}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return index; }\n+                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,2 +156,2 @@\n-        Class<?> resolvedOwner = (Class<?>) owner.resolveConstantDesc(lookup);\n-        MethodType invocationType = (MethodType) this.invocationType().resolveConstantDesc(lookup);\n+        Class<?> resolvedOwner = owner.resolveConstantDesc(lookup);\n+        MethodType invocationType = this.invocationType().resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -33,1 +34,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -36,1 +36,0 @@\n-import java.io.FilePermission;\n@@ -39,3 +38,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -43,0 +39,1 @@\n+import java.nio.file.Path;\n@@ -45,2 +42,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.PropertyPermission;\n@@ -90,4 +85,1 @@\n-    \/\/ Used to ensure that dumped class files for failed definitions have a unique class name\n-    private static final AtomicInteger counter = new AtomicInteger();\n-\n-    private static final ProxyClassesDumper dumper;\n+    private static final ClassFileDumper lambdaProxyClassFileDumper;\n@@ -102,3 +94,5 @@\n-        final String dumpProxyClassesKey = \"jdk.internal.lambda.dumpProxyClasses\";\n-        String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);\n-        dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);\n+        \/\/ To dump the lambda proxy classes, set this system property:\n+        \/\/    -Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\n+        \/\/ or -Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\n+        final String dumpProxyClassesKey = \"jdk.invoke.LambdaMetafactory.dumpProxyClassFiles\";\n+        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\"));\n@@ -379,26 +373,4 @@\n-            Lookup lookup = null;\n-            try {\n-                if (useImplMethodHandle) {\n-                    lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n-                                                                   NESTMATE, STRONG);\n-                } else {\n-                    lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n-                }\n-                return lookup.lookupClass();\n-            } finally {\n-                \/\/ If requested, dump out to a file for debugging purposes\n-                if (dumper != null) {\n-                    String name;\n-                    if (lookup != null) {\n-                        String definedName = lookup.lookupClass().getName();\n-                        int suffixIdx = definedName.lastIndexOf('\/');\n-                        assert suffixIdx != -1;\n-                        name = lambdaClassName + '.' + definedName.substring(suffixIdx + 1);\n-                    } else {\n-                        name = lambdaClassName + \".failed-\" + counter.incrementAndGet();\n-                    }\n-                    doDump(name, classBytes);\n-                }\n-            }\n-        } catch (IllegalAccessException e) {\n-            throw new LambdaConversionException(\"Exception defining lambda proxy class\", e);\n+            var classdata = useImplMethodHandle? implementation : null;\n+            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, Set.of(NESTMATE, STRONG), lambdaProxyClassFileDumper)\n+                         .defineClass(!disableEagerInitialization, classdata);\n+\n@@ -410,14 +382,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private void doDump(final String className, final byte[] classBytes) {\n-        AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public Void run() {\n-                dumper.dumpClass(className, classBytes);\n-                return null;\n-            }\n-        }, null,\n-        new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-        \/\/ createDirectories may need it\n-        new PropertyPermission(\"user.dir\", \"read\"));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":12,"deletions":54,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n@@ -128,1 +124,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumper().isEnabled()) {\n@@ -176,52 +172,2 @@\n-    private static final HashMap<String,Integer> DUMP_CLASS_FILES_COUNTERS;\n-    \/** debugging flag for saving generated class files *\/\n-    private static final File DUMP_CLASS_FILES_DIR;\n-\n-    static {\n-        if (DUMP_CLASS_FILES) {\n-            DUMP_CLASS_FILES_COUNTERS = new HashMap<>();\n-            try {\n-                File dumpDir = new File(\"DUMP_CLASS_FILES\");\n-                if (!dumpDir.exists()) {\n-                    dumpDir.mkdirs();\n-                }\n-                DUMP_CLASS_FILES_DIR = dumpDir;\n-                System.out.println(\"Dumping class files to \"+DUMP_CLASS_FILES_DIR+\"\/...\");\n-            } catch (Exception e) {\n-                throw newInternalError(e);\n-            }\n-        } else {\n-            DUMP_CLASS_FILES_COUNTERS = null;\n-            DUMP_CLASS_FILES_DIR = null;\n-        }\n-    }\n-\n-    private void maybeDump(final byte[] classFile) {\n-        if (DUMP_CLASS_FILES) {\n-            maybeDump(className, classFile);\n-        }\n-    }\n-\n-    \/\/ Also used from BoundMethodHandle\n-    @SuppressWarnings(\"removal\")\n-    static void maybeDump(final String className, final byte[] classFile) {\n-        if (DUMP_CLASS_FILES) {\n-            java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public Void run() {\n-                    try {\n-                        String dumpName = className.replace('.','\/');\n-                        File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+\".class\");\n-                        System.out.println(\"dump: \" + dumpFile);\n-                        dumpFile.getParentFile().mkdirs();\n-                        FileOutputStream file = new FileOutputStream(dumpFile);\n-                        file.write(classFile);\n-                        file.close();\n-                        return null;\n-                    } catch (IOException ex) {\n-                        throw newInternalError(ex);\n-                    }\n-                }\n-            });\n-        }\n-    }\n+    private static final HashMap<String,Integer> DUMP_CLASS_FILES_COUNTERS =\n+            dumper().isEnabled() ?  new HashMap<>(): null;\n@@ -274,1 +220,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumper().isEnabled()) {\n@@ -302,1 +248,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of())\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of(), dumper())\n@@ -812,3 +758,1 @@\n-        final byte[] classFile = toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return toByteArray();\n@@ -1902,3 +1846,1 @@\n-        final byte[] classFile = cw.toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return cw.toByteArray();\n@@ -1971,3 +1913,1 @@\n-        final byte[] classFile = cw.toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return cw.toByteArray();\n@@ -1981,1 +1921,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumper().isEnabled()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":10,"deletions":70,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -59,0 +60,1 @@\n+import java.nio.file.Path;\n@@ -2242,0 +2244,15 @@\n+        \/\/ A default dumper for writing class files passed to Lookup::defineClass\n+        \/\/ and Lookup::defineHiddenClass to disk for debugging purposes.  To enable,\n+        \/\/ set -Djdk.invoke.MethodHandle.dumpHiddenClassFiles or\n+        \/\/     -Djdk.invoke.MethodHandle.dumpHiddenClassFiles=true\n+        \/\/\n+        \/\/ This default dumper does not dump hidden classes defined by LambdaMetafactory\n+        \/\/ and LambdaForms and method handle internals.  They are dumped via\n+        \/\/ different ClassFileDumpers.\n+        private static ClassFileDumper defaultDumper() {\n+            return DEFAULT_DUMPER;\n+        }\n+\n+        private static final ClassFileDumper DEFAULT_DUMPER = ClassFileDumper.getInstance(\n+                \"jdk.invoke.MethodHandle.dumpClassFiles\", Path.of(\"DUMP_CLASS_FILES\"));\n+\n@@ -2243,1 +2260,1 @@\n-            final String name;\n+            final String name;  \/\/ internal name\n@@ -2265,0 +2282,12 @@\n+                var cf = readClassFile(bytes);\n+\n+                \/\/ check if it's in the named package\n+                int index = cf.name.lastIndexOf('\/');\n+                String pn = (index == -1) ? \"\" : cf.name.substring(0, index).replace('\/', '.');\n+                if (!pn.equals(pkgName)) {\n+                    throw newIllegalArgumentException(cf.name + \" not in same package as lookup class\");\n+                }\n+                return cf;\n+            }\n+\n+            private static ClassFile readClassFile(byte[] bytes) {\n@@ -2279,1 +2308,1 @@\n-                    \/\/ ClassReader::getClassName does not check if `this_class` is CONSTANT_Class_info\n+                    \/\/ ClassReader does not check if `this_class` is CONSTANT_Class_info\n@@ -2289,1 +2318,1 @@\n-                    name = type.getClassName();\n+                    name = type.getInternalName();\n@@ -2297,1 +2326,0 @@\n-\n@@ -2302,8 +2330,0 @@\n-\n-                \/\/ check if it's in the named package\n-                int index = name.lastIndexOf('.');\n-                String pn = (index == -1) ? \"\" : name.substring(0, index);\n-                if (!pn.equals(pkgName)) {\n-                    throw newIllegalArgumentException(name + \" not in same package as lookup class\");\n-                }\n-\n@@ -2343,1 +2363,16 @@\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK);\n+            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, defaultDumper());\n+        }\n+\n+        \/**\n+         * Returns a ClassDefiner that creates a {@code Class} object of a normal class\n+         * from the given bytes.  No package name check on the given bytes.\n+         *\n+         * @param name    internal name\n+         * @param bytes   class bytes\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n+         * @return ClassDefiner that defines a normal class of the given bytes.\n+         *\/\n+        ClassDefiner makeClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+            \/\/ skip package name validation\n+            ClassFile cf = ClassFile.newInstanceNoCheck(name, bytes);\n+            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, dumper);\n@@ -2354,0 +2389,1 @@\n+         * @param dumper dumper to write the given bytes to the dumper's output directory\n@@ -2359,1 +2395,1 @@\n-        ClassDefiner makeHiddenClassDefiner(byte[] bytes) {\n+        ClassDefiner makeHiddenClassDefiner(byte[] bytes, ClassFileDumper dumper) {\n@@ -2361,1 +2397,1 @@\n-            return makeHiddenClassDefiner(cf, Set.of(), false);\n+            return makeHiddenClassDefiner(cf, Set.of(), false, dumper);\n@@ -2380,3 +2416,3 @@\n-        ClassDefiner makeHiddenClassDefiner(byte[] bytes,\n-                                            Set<ClassOption> options,\n-                                            boolean accessVmAnnotations) {\n+        private ClassDefiner makeHiddenClassDefiner(byte[] bytes,\n+                                                    Set<ClassOption> options,\n+                                                    boolean accessVmAnnotations) {\n@@ -2384,1 +2420,1 @@\n-            return makeHiddenClassDefiner(cf, options, accessVmAnnotations);\n+            return makeHiddenClassDefiner(cf, options, accessVmAnnotations, defaultDumper());\n@@ -2389,1 +2425,1 @@\n-         * from the given bytes and the given options.  No package name check on the given name.\n+         * from the given bytes and the given options.  No package name check on the given bytes.\n@@ -2391,1 +2427,1 @@\n-         * @param name    fully-qualified name that specifies the prefix of the hidden class\n+         * @param name    internal name that specifies the prefix of the hidden class\n@@ -2394,0 +2430,1 @@\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n@@ -2396,1 +2433,2 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options) {\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options, ClassFileDumper dumper) {\n+            Objects.requireNonNull(dumper);\n@@ -2398,1 +2436,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false);\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false, dumper);\n@@ -2408,0 +2446,1 @@\n+         * @param dumper dumper to write the given bytes to the dumper's output directory\n@@ -2411,1 +2450,2 @@\n-                                                    boolean accessVmAnnotations) {\n+                                                    boolean accessVmAnnotations,\n+                                                    ClassFileDumper dumper) {\n@@ -2419,1 +2459,1 @@\n-            return new ClassDefiner(this, cf, flags);\n+            return new ClassDefiner(this, cf, flags, dumper);\n@@ -2424,1 +2464,1 @@\n-            private final String name;\n+            private final String name;  \/\/ internal name\n@@ -2427,0 +2467,1 @@\n+            private final ClassFileDumper dumper;\n@@ -2428,1 +2469,1 @@\n-            private ClassDefiner(Lookup lookup, ClassFile cf, int flags) {\n+            private ClassDefiner(Lookup lookup, ClassFile cf, int flags, ClassFileDumper dumper) {\n@@ -2434,0 +2475,1 @@\n+                this.dumper = dumper;\n@@ -2436,1 +2478,1 @@\n-            String className() {\n+            String internalName() {\n@@ -2463,4 +2505,17 @@\n-                Class<?> c = SharedSecrets.getJavaLangAccess()\n-                        .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n-                assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();\n-                return c;\n+                Class<?> c = null;\n+                try {\n+                    c = SharedSecrets.getJavaLangAccess()\n+                            .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n+                    assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();\n+                    return c;\n+                } finally {\n+                    \/\/ dump the classfile for debugging\n+                    if (dumper.isEnabled()) {\n+                        String name = internalName();\n+                        if (c != null) {\n+                            dumper.dumpClass(name, c, bytes);\n+                        } else {\n+                            dumper.dumpFailedClass(name, bytes);\n+                        }\n+                    }\n+                }\n@@ -2469,0 +2524,10 @@\n+            \/**\n+             * Defines the class of the given bytes and the given classData.\n+             * If {@code initialize} parameter is true, then the class will be initialized.\n+             *\n+             * @param initialize true if the class to be initialized\n+             * @param classData classData or null\n+             * @return a Lookup for the defined class\n+             *\n+             * @throws LinkageError linkage error\n+             *\/\n@@ -2821,0 +2886,1 @@\n+         * @param <T> the type of the class to be initialized\n@@ -2836,1 +2902,1 @@\n-        public Class<?> ensureInitialized(Class<?> targetClass) throws IllegalAccessException {\n+        public <T> Class<T> ensureInitialized(Class<T> targetClass) throws IllegalAccessException {\n@@ -2936,0 +3002,1 @@\n+         * @param <T> the type of the class to be access-checked\n@@ -2937,1 +3004,1 @@\n-         * @return the class that has been access-checked\n+         * @return {@code targetClass} that has been access-checked\n@@ -2946,1 +3013,1 @@\n-        public Class<?> accessClass(Class<?> targetClass) throws IllegalAccessException {\n+        public <T> Class<T> accessClass(Class<T> targetClass) throws IllegalAccessException {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":102,"deletions":35,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+ * @spec jni\/index.html Java Native Interface Specification\n@@ -206,0 +207,2 @@\n+     *\n+     * @spec jni\/index.html Java Native Interface Specification\n@@ -272,0 +275,1 @@\n+     * @spec jni\/index.html Java Native Interface Specification\n@@ -465,0 +469,1 @@\n+     * @spec jni\/index.html Java Native Interface Specification\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-        @JEP(number=436, title=\"Virtual Threads\", status=\"Second Preview\")\n+        \/\/ not used\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,2 +150,0 @@\n-        java.management, \/\/ participates in preview features\n-        jdk.incubator.concurrent, \/\/ participates in preview features\n@@ -155,4 +153,1 @@\n-        jdk.jdi,\n-        jdk.jfr,\n-        jdk.jshell,\n-        jdk.management;\n+        jdk.jshell;\n@@ -266,1 +261,2 @@\n-        jdk.management.agent;\n+        jdk.management.agent,\n+        jdk.internal.vm.ci;\n@@ -276,2 +272,0 @@\n-    exports jdk.internal.util.jar to\n-        jdk.jartool;\n@@ -287,1 +281,6 @@\n-        java.desktop;\n+        java.desktop,\n+        java.prefs,\n+        java.security.jgss,\n+        java.smartcardio,\n+        jdk.charsets,\n+        jdk.net;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -248,0 +248,5 @@\n+        \/**\n+         * Warn when any output file is written to more than once.\n+         *\/\n+        OUTPUT_FILE_CLASH(\"output-file-clash\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+        WARN_ON_ILLEGAL_UTF8(MIN, JDK21),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-                         that.getQualifiedName().compareTo(this.getQualifiedName()) < 0);\n+                         this.getQualifiedName().compareTo(that.getQualifiedName()) < 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2270,0 +2270,9 @@\n+                    \/\/ verify all static final fields got initailized\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        if (var.owner == classDef.sym && var.isStatic()) {\n+                            checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n+                        }\n+                    }\n+\n@@ -2365,1 +2374,1 @@\n-                            if (var.owner == classDef.sym) {\n+                            if (var.owner == classDef.sym && !var.isStatic()) {\n@@ -2374,1 +2383,0 @@\n-                                            !var.isStatic() &&\n@@ -2913,0 +2921,5 @@\n+                \/\/ JLS 16.1.10: No rule allows V to be definitely unassigned before a lambda\n+                \/\/ body. This is by design: a variable that was definitely unassigned before the\n+                \/\/ lambda body may end up being assigned to later on, so we cannot conclude that\n+                \/\/ the variable will be unassigned when the body is executed.\n+                uninits.excludeFrom(firstadr);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2460,1 +2460,6 @@\n-            Name name = names.fromUtf(ba);\n+            Name name;\n+            try {\n+                name = names.fromUtf(ba);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError(e);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -232,0 +232,28 @@\n+    \/**\n+     * Get the enum constants for the given enum class symbol, if known.\n+     * They will only be found if they are defined within the same top-level\n+     * class as the class being compiled, so it's safe to assume that they\n+     * can't change at runtime due to a recompilation.\n+     *\/\n+    List<Name> enumNamesFor(ClassSymbol c) {\n+\n+        \/\/ Find the class definition and verify it is an enum class\n+        final JCClassDecl classDef = classDef(c);\n+        if (classDef == null ||\n+            (classDef.mods.flags & ENUM) == 0 ||\n+            (types.supertype(currentClass.type).tsym.flags() & ENUM) != 0) {\n+            return null;\n+        }\n+\n+        \/\/ Gather the enum identifiers\n+        ListBuffer<Name> idents = new ListBuffer<>();\n+        for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs=defs.tail) {\n+            if (defs.head.hasTag(VARDEF) &&\n+                (((JCVariableDecl) defs.head).mods.flags & ENUM) != 0) {\n+                JCVariableDecl var = (JCVariableDecl)defs.head;\n+                idents.append(var.name);\n+            }\n+        }\n+        return idents.toList();\n+    }\n+\n@@ -432,4 +460,10 @@\n-        EnumMapping map = enumSwitchMap.get(enumClass);\n-        if (map == null)\n-            enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));\n-        return map;\n+\n+        \/\/ If enum class is part of this compilation, just switch on ordinal value\n+        if (enumClass.kind == TYP) {\n+            final List<Name> idents = enumNamesFor((ClassSymbol)enumClass);\n+            if (idents != null)\n+                return new CompileTimeEnumMapping(idents);\n+        }\n+\n+        \/\/ Map identifiers to ordinal values at runtime, and then switch on that\n+        return enumSwitchMap.computeIfAbsent(enumClass, ec -> new RuntimeEnumMapping(pos, ec));\n@@ -438,2 +472,44 @@\n-    \/** This map gives a translation table to be used for enum\n-     *  switches.\n+    \/** Generates a test value and corresponding cases for a switch on an enum type.\n+     *\/\n+    interface EnumMapping {\n+\n+        \/** Given an expression for the enum value's ordinal, generate an expression for the switch statement.\n+         *\/\n+        JCExpression switchValue(JCExpression ordinalExpr);\n+\n+        \/** Generate the switch statement case value corresponding to the given enum value.\n+         *\/\n+        JCLiteral caseValue(VarSymbol v);\n+\n+        default void translate() {\n+        }\n+    }\n+\n+    \/** EnumMapping using compile-time constants. Only valid when compiling the enum class itself,\n+     *  because otherwise the ordinals we use could become obsolete if\/when the enum class is recompiled.\n+     *\/\n+    class CompileTimeEnumMapping implements EnumMapping {\n+\n+        final List<Name> enumNames;\n+\n+        CompileTimeEnumMapping(List<Name> enumNames) {\n+            Assert.check(enumNames != null);\n+            this.enumNames = enumNames;\n+        }\n+\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return ordinalExpr;\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n+            final int ordinal = enumNames.indexOf(v.name);\n+            Assert.check(ordinal != -1);\n+            return make.Literal(ordinal);\n+        }\n+    }\n+\n+    \/** EnumMapping using run-time ordinal lookup.\n+     *\n+     *  This builds a translation table to be used for enum switches.\n@@ -471,2 +547,2 @@\n-    class EnumMapping {\n-        EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n+    class RuntimeEnumMapping implements EnumMapping {\n+        RuntimeEnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n@@ -480,1 +556,1 @@\n-                            names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()\n+                            ClassWriter.externalize(forEnum.type.tsym.flatName().toString())\n@@ -505,1 +581,7 @@\n-        JCLiteral forConstant(VarSymbol v) {\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return make.Indexed(mapVar, ordinalExpr);\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n@@ -513,1 +595,2 @@\n-        void translate() {\n+        @Override\n+        public void translate() {\n@@ -3075,1 +3158,2 @@\n-            \/\/ first argument.\n+            \/\/ first argument. If we are a static class, there is no\n+            \/\/ such outer instance, so generate an error.\n@@ -3086,0 +3170,5 @@\n+                } else if (currentClass.isStatic()) {\n+                    \/\/ super() call from static nested class - invalid\n+                    log.error(tree.pos(),\n+                        Errors.NoEnclInstanceOfTypeInScope(c.type.getEnclosingType().tsym));\n+                    thisArg = make.Literal(BOT, null).setType(syms.botType);\n@@ -3806,1 +3895,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3817,1 +3906,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3829,1 +3918,1 @@\n-                    pat = map.forConstant(label);\n+                    pat = map.caseValue(label);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":104,"deletions":15,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -4233,0 +4233,2 @@\n+            UnaryOperator<JCDiagnostic> rewriter = compactMethodDiags ?\n+              d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null;\n@@ -4241,2 +4243,1 @@\n-                              compactMethodDiags ?\n-                                      d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n+                              rewriter,\n@@ -4248,0 +4249,9 @@\n+                    \/\/ Avoid saying \"constructor Array in class Array\"\n+                    if (ws.owner == syms.arrayClass && ws.name == names.init) {\n+                        return diags.create(dkind, log.currentSource(), pos,\n+                                  \"cant.apply.array.ctor\",\n+                                  rewriter,\n+                                  methodArguments(ws.type.getParameterTypes()),\n+                                  methodArguments(argtypes),\n+                                  c.snd);\n+                    }\n@@ -4250,2 +4260,1 @@\n-                              compactMethodDiags ?\n-                                      d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n+                              rewriter,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        V48(48, 0),   \/\/ JDK 1.4\n@@ -168,2 +169,2 @@\n-    public static byte[] internalize(Name name) {\n-        return internalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+    public static Name internalize(Name name) {\n+        return name.table.names.fromString(name.toString().replace('\/', '.'));\n@@ -173,1 +174,1 @@\n-     * Return external representation of buf[offset..offset+len-1], converting '.' to '\/'.\n+     * Return external representation of given name, converting '\/' to '.'.\n@@ -178,8 +179,2 @@\n-    public static byte[] externalize(byte[] buf, int offset, int len) {\n-        byte[] translated = new byte[len];\n-        for (int j = 0; j < len; j++) {\n-            byte b = buf[offset + j];\n-            if (b == '.') translated[j] = (byte) '\/';\n-            else translated[j] = b;\n-        }\n-        return translated;\n+    public static Name externalize(Name name) {\n+        return name.table.names.fromString(externalize(name.toString()));\n@@ -194,2 +189,2 @@\n-    public static byte[] externalize(Name name) {\n-        return externalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+    public static String externalize(String name) {\n+        return name.replace('.', '\/');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -69,0 +70,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -130,0 +132,4 @@\n+    \/** Switch: warn (instead of error) on illegal UTF-8\n+     *\/\n+    boolean warnOnIllegalUtf8;\n+\n@@ -202,0 +208,3 @@\n+    \/** UTF-8 validation level *\/\n+    Convert.Validation utf8validation;\n+\n@@ -295,0 +304,1 @@\n+        warnOnIllegalUtf8 = Feature.WARN_ON_ILLEGAL_UTF8.allowedInSource(source);\n@@ -321,0 +331,8 @@\n+        return badClassFile(diagFactory.fragment(key, args));\n+    }\n+\n+    public ClassFinder.BadClassFile badClassFile(Fragment fragment) {\n+        return badClassFile(diagFactory.fragment(fragment));\n+    }\n+\n+    public ClassFinder.BadClassFile badClassFile(JCDiagnostic diagnostic) {\n@@ -324,1 +342,1 @@\n-            diagFactory.fragment(key, args),\n+            diagnostic,\n@@ -349,1 +367,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -361,1 +379,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -372,1 +390,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -469,1 +487,1 @@\n-                : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));\n+                : findTypeVar(readName(signature, start, sigp - 1 - start));\n@@ -508,1 +526,1 @@\n-                            Convert.utf2string(signature, sigp, 10));\n+                                       quoteBadSignature());\n@@ -558,2 +576,1 @@\n-            throw badClassFile(\"bad.signature\",\n-                               Convert.utf2string(signature, sigp, 10));\n+            throw badClassFile(\"bad.signature\", quoteBadSignature());\n@@ -570,2 +587,1 @@\n-            throw badClassFile(\"bad.class.signature\",\n-                               Convert.utf2string(signature, sigp, 10));\n+            throw badClassFile(\"bad.class.signature\", quoteBadSignature());\n@@ -583,1 +599,1 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                ClassSymbol t = enterClass(readName(signatureBuffer,\n@@ -602,1 +618,1 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                ClassSymbol t = enterClass(readName(signatureBuffer,\n@@ -667,1 +683,1 @@\n-                    t = enterClass(names.fromUtf(signatureBuffer,\n+                    t = enterClass(readName(signatureBuffer,\n@@ -686,0 +702,14 @@\n+    \/** Quote a bogus signature for display inside an error message.\n+     *\/\n+    String quoteBadSignature() {\n+        String sigString;\n+        try {\n+            sigString = Convert.utf2string(signature, sigp, siglimit - sigp, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n+        if (sigString.length() > 32)\n+            sigString = sigString.substring(0, 32) + \"...\";\n+        return \"\\\"\" + sigString + \"\\\"\";\n+    }\n+\n@@ -732,1 +762,1 @@\n-        Name name = names.fromUtf(signature, start, sigp - start);\n+        Name name = readName(signature, start, sigp - start);\n@@ -783,0 +813,13 @@\n+    private Name readName(byte[] buf, int off, int len) {\n+        try {\n+            return names.fromUtf(buf, off, len, utf8validation);\n+        } catch (InvalidUtfException e) {\n+            if (warnOnIllegalUtf8) {\n+                log.warning(Warnings.InvalidUtf8InClassfile(currentClassFile,\n+                    Fragments.BadUtf8ByteSequenceAt(sigp)));\n+                return names.fromUtfLax(buf, off, len);\n+            }\n+            throw badClassFile(Fragments.BadUtf8ByteSequenceAt(sigp));\n+        }\n+    }\n+\n@@ -1157,1 +1200,1 @@\n-                        Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);\n+                        Name moduleName = poolReader.peekModuleName(nextChar(), ClassReader.this::readName);\n@@ -1252,2 +1295,12 @@\n-                private Name classNameMapper(byte[] arr, int offset, int length) {\n-                    return names.fromUtf(ClassFile.internalize(arr, offset, length));\n+                private Name classNameMapper(byte[] arr, int offset, int length) throws InvalidUtfException {\n+                    byte[] buf = ClassFile.internalize(arr, offset, length);\n+                    try {\n+                        return names.fromUtf(buf, 0, buf.length, utf8validation);\n+                    } catch (InvalidUtfException e) {\n+                        if (warnOnIllegalUtf8) {\n+                            log.warning(Warnings.InvalidUtf8InClassfile(currentClassFile,\n+                                Fragments.BadUtf8ByteSequenceAt(e.getOffset())));\n+                            return names.fromUtfLax(buf, 0, buf.length);\n+                        }\n+                        throw e;\n+                    }\n@@ -1553,1 +1606,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -1847,1 +1900,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -2725,0 +2778,1 @@\n+        utf8validation = majorVersion < V48.major ? Convert.Validation.PREJDK14 : Convert.Validation.STRICT;\n@@ -2753,1 +2807,3 @@\n-            buf.appendStream(c.classfile.openInputStream());\n+            try (InputStream input = c.classfile.openInputStream()) {\n+                buf.appendStream(input);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":76,"deletions":20,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.util.InvalidUtfException;\n@@ -356,1 +357,5 @@\n-            return sigbuf.toName(names);\n+            try {\n+                return sigbuf.toName(names);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError(e);\n+            }\n@@ -397,1 +402,1 @@\n-                            c instanceof ConstantPoolQType ? names.fromString(\"Q\" + new String(externalize(ct.tsym.flatName())) + \";\") : names.fromUtf(externalize(ct.tsym.flatName()));\n+                      c instanceof ConstantPoolQType ? names.fromString(\"Q\" + externalize(ct.tsym.flatName()) + \";\") : externalize(ct.tsym.flatName());\n@@ -428,1 +433,1 @@\n-                    Name pkgName = names.fromUtf(externalize(pkg.flatName()));\n+                    Name pkgName = externalize(pkg.flatName());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3940,2 +3940,1 @@\n-        boolean checkForImports = true;\n-        boolean firstTypeDecl = true;\n+        boolean firstTypeDecl = true;   \/\/ have we see a class, enum, or interface declaration yet?\n@@ -3945,1 +3944,1 @@\n-                skip(checkForImports, false, false, false);\n+                skip(firstTypeDecl, false, false, false);\n@@ -3949,1 +3948,18 @@\n-            if (checkForImports && mods == null && token.kind == IMPORT) {\n+            \/\/ JLS 7.3 doesn't allow extra semicolons after package or import declarations,\n+            \/\/ but here we try to provide a more helpful error message if we encounter any.\n+            \/\/ Do that by slurping in as many semicolons as possible, and then seeing what\n+            \/\/ comes after before deciding how best to handle them.\n+            ListBuffer<JCTree> semiList = new ListBuffer<>();\n+            while (firstTypeDecl && mods == null && token.kind == SEMI) {\n+                semiList.append(toP(F.at(token.pos).Skip()));\n+                nextToken();\n+                if (token.kind == EOF)\n+                    break;\n+            }\n+            if (firstTypeDecl && mods == null && token.kind == IMPORT) {\n+                if (!semiList.isEmpty()) {\n+                    if (source.compareTo(Source.JDK21) >= 0)\n+                        reportSyntaxError(semiList.first().pos, Errors.ExtraneousSemicolon);\n+                    else\n+                        log.warning(semiList.first().pos, Warnings.ExtraneousSemicolon);\n+                }\n@@ -3961,0 +3977,6 @@\n+                    if (!semiList.isEmpty()) {\n+                        if (source.compareTo(Source.JDK21) >= 0)\n+                            reportSyntaxError(semiList.first().pos, Errors.ExtraneousSemicolon);\n+                        else\n+                            log.warning(semiList.first().pos, Warnings.ExtraneousSemicolon);\n+                    }\n@@ -3977,0 +3999,1 @@\n+                defs.appendList(semiList.toList());\n@@ -3981,2 +4004,0 @@\n-                if (def instanceof JCClassDecl)\n-                    checkForImports = false;\n@@ -4405,0 +4426,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -4408,1 +4430,3 @@\n-        if (token.kind == TokenKind.IDENTIFIER && token.name() != enumName &&\n+        boolean ident = token.kind == TokenKind.IDENTIFIER ||\n+                        token.kind == TokenKind.UNDERSCORE;\n+        if (ident && token.name() != enumName &&\n@@ -4417,5 +4441,3 @@\n-            case IDENTIFIER: case MONKEYS_AT: case LT:\n-                if (token.kind == IDENTIFIER) {\n-                    if (allowRecords && isRecordStart()) {\n-                        return EnumeratorEstimate.MEMBER;\n-                    }\n+            case IDENTIFIER:\n+                if (allowRecords && isRecordStart()) {\n+                    return EnumeratorEstimate.MEMBER;\n@@ -4423,0 +4445,1 @@\n+            case MONKEYS_AT: case LT: case UNDERSCORE:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -263,0 +263,7 @@\n+# 0: list of type or message segment, 1: list of type or message segment, 2: message segment\n+compiler.misc.cant.apply.array.ctor=\\\n+    cannot create array from given types\\n\\\n+    required: {0}\\n\\\n+    found:    {1}\\n\\\n+    reason:   {2}\n+\n@@ -1620,0 +1627,4 @@\n+# 0: path\n+compiler.warn.output.file.clash=\\\n+    output file written more than once: {0}\n+\n@@ -2043,0 +2054,4 @@\n+# 0: file name, 1: fragment\n+compiler.warn.invalid.utf8.in.classfile=\\\n+    {0}: classfile contains invalid UTF-8: {1}\n+\n@@ -2360,0 +2375,6 @@\n+compiler.err.extraneous.semicolon=\\\n+    extraneous semicolon\n+\n+compiler.warn.extraneous.semicolon=\\\n+    extraneous semicolon\n+\n@@ -2447,0 +2468,4 @@\n+# 0: number\n+compiler.misc.bad.utf8.byte.sequence.at=\\\n+    bad UTF-8 byte sequence at {0}\n+\n@@ -2450,0 +2475,1 @@\n+# 0: number\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-    Names of the annotation processors to run; bypasses default discovery process\n+    Names of the annotation processors to run;\\n\\\n+    bypasses default discovery process\n@@ -88,1 +89,2 @@\n-    Generate class files suitable for the specified Java SE release. Supported releases: {0}\n+    Generate class files suitable for the specified Java SE release.\\n\\\n+    Supported releases: {0}\n@@ -90,1 +92,2 @@\n-    Compile for the specified Java SE release. Supported releases: {0}\n+    Compile for the specified Java SE release.\\n\\\n+    Supported releases: {0}\n@@ -92,1 +95,2 @@\n-    Provide source compatibility with the specified Java SE release. Supported releases: {0}\n+    Provide source compatibility with the specified Java SE release.\\n\\\n+    Supported releases: {0}\n@@ -98,1 +102,1 @@\n-    Specify whether or not to generate class files for implicitly referenced files\n+    Specify whether to generate class files for implicitly referenced files\n@@ -227,0 +231,4 @@\n+javac.opt.Xlint.desc.output-file-clash=\\\n+    Warn when an output file is overwritten during compilation. This can occur, for example,\\n\\\n+\\                         on case-insensitive filesystems. Covers class files, native header files, and source files.\n+\n@@ -293,2 +301,3 @@\n-    where <group> is one of accessibility, html, missing, reference, or syntax,\\n\\\n-    and <access> is one of public, protected, package, or private.\n+    where <group> is one of accessibility, html, missing, reference,\\n\\\n+    or syntax, and <access> is one of public, protected, package,\\n\\\n+    or private.\n@@ -300,4 +309,4 @@\n-    Enable or disable checks in specific packages. Each <package> is either the\\n\\\n-    qualified name of a package or a package name prefix followed by '.*', which\\n\\\n-    expands to all sub-packages of the given package. Each <package> can be prefixed\\n\\\n-    with '-' to disable checks for the specified package or packages.\n+    Enable or disable checks in specific packages. Each <package> is either\\n\\\n+    the qualified name of a package or a package name prefix followed by '.*',\\n\\\n+    which expands to all sub-packages of the given package. Each <package>\\n\\\n+    can be prefixed with '-' to disable checks for the specified package(s).\n@@ -320,1 +329,2 @@\n-    Print information about which annotations a processor is asked to process\n+    Print information about which annotations a processor\\n\\\n+    is asked to process\n@@ -324,1 +334,2 @@\n-    Specify which file to read when both a source file and class file are found for an implicitly compiled class\n+    Specify which file to read when both a source file and class file\\n\\\n+    are found for an implicitly compiled class\n@@ -326,1 +337,2 @@\n-    Enable preview language features. To be used in conjunction with either -source or --release.\n+    Enable preview language features.\\n\\\n+    To be used in conjunction with either -source or --release.\n@@ -332,2 +344,3 @@\n-    Specify a package to be considered as exported from its defining module\\n\\\n-    to additional modules, or to all unnamed modules if <other-module> is ALL-UNNAMED.\n+    Specify a package to be considered as exported from its\\n\\\n+    defining module to additional modules, or to all unnamed modules\\n\\\n+    if <other-module> is ALL-UNNAMED.\n@@ -337,2 +350,3 @@\n-    Specify additional modules to be considered as required by a given module.\\n\\\n-    <other-module> may be ALL-UNNAMED to require the unnamed module.\n+    Specify additional modules to be considered as required by\\n\\\n+    a given module; <other-module> may be ALL-UNNAMED to require\\n\\\n+    the unnamed module.\n@@ -347,2 +361,2 @@\n-    Root modules to resolve in addition to the initial modules, or all modules\\n\\\n-    on the module path if <module> is ALL-MODULE-PATH.\n+    Root modules to resolve in addition to the initial modules,\\n\\\n+    or all modules on the module path if <module> is ALL-MODULE-PATH.\n@@ -362,1 +376,2 @@\n-    Fallback target module for files created by annotation processors, if none specified or inferred.\n+    Fallback target module for files created by annotation processors,\\n\\\n+    if none specified or inferred.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":36,"deletions":21,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-    public Name fromUtf(byte[] cs) {\n+    public Name fromUtf(byte[] cs) throws InvalidUtfException {\n@@ -457,2 +457,10 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n-        return table.fromUtf(cs, start, len);\n+    public Name fromUtf(byte[] cs, int start, int len, Convert.Validation validation) throws InvalidUtfException {\n+        return table.fromUtf(cs, start, len, validation);\n+    }\n+\n+    public Name fromUtfLax(byte[] cs, int start, int len) {\n+        try {\n+            return table.fromUtf(cs, start, len, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -442,2 +442,2 @@\n-            long accessFlags = m.getAccessFlags();\n-            \/\/ overpass method\n+            long accessFlags = m.getAccessFlags() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+            \/\/ skip overpass methods\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    final int annotationsClassAnnotationsOffset = getFieldOffset(\"Annotations::_class_annotations\", Integer.class, \"AnnotationArray*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-compiler\/sharedstubs\/SharedStubToInterpTest.java 8304681 generic-all\n-\n@@ -103,2 +101,1 @@\n-runtime\/vthread\/RedefineClass.java 8297286 generic-all\n-runtime\/vthread\/TestObjectAllocationSampleEvent.java 8297286 generic-all\n+runtime\/CompressedOops\/CompressedClassPointers.java 8305765 generic-all\n@@ -106,0 +103,2 @@\n+runtime\/Thread\/TestAlwaysPreTouchStacks.java 8305416 generic-all\n+runtime\/ErrorHandling\/TestDwarf.java 8305489 linux-all\n@@ -182,1 +181,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8277573 generic-all\n@@ -203,1 +201,0 @@\n-vmTestbase\/nsk\/stress\/except\/except012.java 8297977 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n-  :tier1_gc_gcold \\\n@@ -326,1 +325,1 @@\n-tier1_gc_gcold = \\\n+tier3_gc_gcold = \\\n@@ -583,0 +582,1 @@\n+  :tier3_gc_gcold \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -34,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +68,2 @@\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n@@ -66,0 +76,1 @@\n+import java.util.function.BiConsumer;\n@@ -69,0 +80,1 @@\n+import java.util.List;\n@@ -71,0 +83,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -75,1 +89,1 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -78,0 +92,3 @@\n+import jdk.vm.ci.meta.Annotated;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n@@ -81,0 +98,2 @@\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaUtil;\n@@ -84,0 +103,2 @@\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n+import sun.reflect.annotation.AnnotationSupport;\n@@ -180,1 +201,2 @@\n-        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from\n+        \/\/ internal name to java\n@@ -909,5 +931,5 @@\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n@@ -1137,0 +1159,34 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        getAnnotationDataTest(AnnotationTestInput.AnnotatedClass.class);\n+        getAnnotationDataTest(int.class);\n+        getAnnotationDataTest(void.class);\n+        for (Class<?> c : classes) {\n+            getAnnotationDataTest(c);\n+        }\n+\n+        \/\/ Primitive classes have no annotations but we cannot directly\n+        \/\/ test absence of annotations. Instead, just ensure empty answers\n+        \/\/ are returned when looking up an arbitrary annotation type.\n+        Class<?>[] prims = {void.class, byte.class, int.class, double.class, float.class, short.class, char.class, long.class};\n+        ResolvedJavaType overrideType = metaAccess.lookupJavaType(Override.class);\n+        for (Class<?> c : prims) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            AnnotationData ad = type.getAnnotationData(overrideType);\n+            Assert.assertNull(String.valueOf(ad), ad);\n+            List<AnnotationData> adArray = type.getAnnotationData(overrideType, overrideType);\n+            Assert.assertEquals(0, adArray.size());\n+        }\n+\n+        \/\/ Test that inherited annotations are handled properly.\n+        ResolvedJavaType namedType = metaAccess.lookupJavaType(AnnotationTestInput.Named.class);\n+        AnnotationData ad = metaAccess.lookupJavaType(AnnotationTestInput.OwnName.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"NonInheritedValue\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName1.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName2.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super2\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName3.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+    }\n+\n@@ -1180,0 +1236,125 @@\n+\n+    \/**\n+     * Tests that {@link AnnotationData} obtained from a {@link Class}, {@link Method} or\n+     * {@link Field} matches {@link AnnotatedElement#getAnnotations()} for the corresponding JVMCI\n+     * object.\n+     *\n+     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     *\/\n+    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n+        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n+    }\n+\n+    private static void testGetAnnotationData(AnnotatedElement annotated, List<Annotation> annotations) throws AssertionError {\n+        for (Annotation a : annotations) {\n+            AnnotationData ad = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertAnnotationsEquals(a, ad);\n+\n+            \/\/ Check that encoding\/decoding produces a stable result\n+            AnnotationData ad2 = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertEquals(ad, ad2);\n+        }\n+        if (annotations.size() < 2) {\n+            return;\n+        }\n+        ResolvedJavaType type1 = metaAccess.lookupJavaType(annotations.get(0).annotationType());\n+        ResolvedJavaType type2 = metaAccess.lookupJavaType(annotations.get(1).annotationType());\n+        for (int i = 2; i < annotations.size(); i++) {\n+\n+            ResolvedJavaType[] types = annotations.\/\/\n+                            subList(2, i + 1).\/\/\n+                            stream().map(a -> metaAccess.lookupJavaType(a.annotationType())).\/\/\n+                            toArray(ResolvedJavaType[]::new);\n+            List<AnnotationData> annotationData = toAnnotated(annotated).getAnnotationData(type1, type2, types);\n+            assertEquals(2 + types.length, annotationData.size());\n+\n+            for (int j = 0; j < annotationData.size(); j++) {\n+                Annotation a = annotations.get(j);\n+                AnnotationData ad = annotationData.get(j);\n+                assertAnnotationsEquals(a, ad);\n+            }\n+        }\n+    }\n+\n+    private static Annotated toAnnotated(AnnotatedElement element) {\n+        if (element instanceof Class<?> t) {\n+            return metaAccess.lookupJavaType(t);\n+        } else if (element instanceof Method m) {\n+            return metaAccess.lookupJavaMethod(m);\n+        } else {\n+            Field f = (Field) element;\n+            return metaAccess.lookupJavaField(f);\n+        }\n+    }\n+\n+    private static UnresolvedJavaType asType(Class<?> valueType) {\n+        return UnresolvedJavaType.create(MetaUtil.toInternalName(valueType.getName()));\n+    }\n+\n+    private static void assertAnnotationsEquals(Annotation a, AnnotationData ad) {\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            String name = e.getKey();\n+            Object aValue = e.getValue();\n+            Object adValue;\n+            try {\n+                adValue = ad.get(name, Object.class);\n+            } catch (IllegalArgumentException ex) {\n+                assertEquals(aValue.toString(), ex.getMessage());\n+                continue;\n+            }\n+            try {\n+                assertAnnotationElementsEqual(aValue, adValue);\n+            } catch (ClassCastException ex) {\n+                throw new AssertionError(a.getClass().getName() + \".\" + name + \" has wrong type: \" + adValue.getClass().getName(), ex);\n+            }\n+        }\n+    }\n+\n+    private static void assertAnnotationElementsEqual(Object aValue, Object adValue) {\n+        Class<?> valueType = aValue.getClass();\n+        if (valueType.isEnum()) {\n+            assertEnumObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Class) {\n+            assertClassObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Annotation) {\n+            assertAnnotationObjectsEquals(aValue, adValue);\n+        } else if (valueType.isArray()) {\n+            List<?> adList = (List<?>) adValue;\n+            int length = Array.getLength(aValue);\n+            assertEquals(length, adList.size());\n+            for (int i = 0; i < length; i++) {\n+                assertAnnotationElementsEqual(Array.get(aValue, i), adList.get(i));\n+            }\n+        } else {\n+            assertEquals(aValue.getClass(), adValue.getClass());\n+            assertEquals(aValue, adValue);\n+        }\n+    }\n+\n+    private static void assertClassObjectsEquals(Object aValue, Object adValue) {\n+        String aName = ((Class<?>) aValue).getName();\n+        String adName = ((JavaType) adValue).toClassName();\n+        assertEquals(aName, adName);\n+    }\n+\n+    private static void assertEnumObjectsEquals(Object aValue, Object adValue) {\n+        EnumData adEnum = (EnumData) adValue;\n+        String adEnumName = adEnum.getName();\n+        String aEnumName = ((Enum<?>) aValue).name();\n+        assertEquals(adEnumName, aEnumName);\n+    }\n+\n+    private static void assertAnnotationObjectsEquals(Object aValue, Object adValue) {\n+        Annotation aAnnotation = (Annotation) aValue;\n+        AnnotationData adAnnotation = (AnnotationData) adValue;\n+        assertAnnotationsEquals(aAnnotation, adAnnotation);\n+    }\n+\n+    private static void assertArraysEqual(Object aValue, Object adValue, int length, BiConsumer<Object, Object> assertEqualty) {\n+        Object[] aArray = (Object[]) aValue;\n+        Object[] adArray = (Object[]) adValue;\n+        for (int i = 0; i < length; i++) {\n+            assertEqualty.accept(aArray[i], adArray[i]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":189,"deletions":8,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -657,0 +657,5 @@\n+    public static final String MAX_L = PREFIX + \"MAX_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_L, \"MaxL\");\n+    }\n+\n@@ -682,0 +687,5 @@\n+    public static final String MIN_L = PREFIX + \"MIN_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_L, \"MinL\");\n+    }\n+\n@@ -727,0 +737,10 @@\n+    public static final String MUL_VF = PREFIX + \"MUL_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VF, \"MulVF\");\n+    }\n+\n+    public static final String MUL_VD = PREFIX + \"MUL_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VD, \"MulVD\");\n+    }\n+\n@@ -1411,0 +1431,10 @@\n+    public static final String COMPRESS_BITSV = PREFIX + \"COMPRESS_BITSV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COMPRESS_BITSV, \"CompressBitsV\");\n+    }\n+\n+    public static final String EXPAND_BITSV = PREFIX + \"EXPAND_BITSV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(EXPAND_BITSV, \"ExpandBitsV\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,6 +79,0 @@\n-                        if (output.getOutput().contains(\"Trying to map heap\") || output.getOutput().contains(\"Loaded heap\")) {\n-                          \/\/ The native data in the RO\/RW regions have been relocated. If the CDS heap is\n-                          \/\/ mapped\/loaded, we must patch all the native pointers. (CDS heap is\n-                          \/\/ not supported on all platforms)\n-                          output.shouldContain(\"Patching native pointers in heap region\");\n-                        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+            out.shouldNotContain(\"Error:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-java\/awt\/Toolkit\/ToolkitPropertyTest\/ToolkitPropertyTest_Enable.java 6847163\n+java\/awt\/Toolkit\/ToolkitPropertyTest\/ToolkitPropertyTest_Enable.java 6847163 linux-all\n@@ -444,1 +444,1 @@\n-java\/awt\/event\/MouseEvent\/FrameMouseEventAbsoluteCoordsTest\/FrameMouseEventAbsoluteCoordsTest.java\n+java\/awt\/event\/MouseEvent\/FrameMouseEventAbsoluteCoordsTest\/FrameMouseEventAbsoluteCoordsTest.java 8238720 windows-all\n@@ -536,2 +536,0 @@\n-java\/net\/MulticastSocket\/SetGetNetworkInterfaceTest.java        8219083 windows-all\n-\n@@ -544,2 +542,0 @@\n-java\/nio\/channels\/DatagramChannel\/Unref.java                    8233437 generic-all\n-\n@@ -550,0 +546,2 @@\n+java\/nio\/channels\/DatagramChannel\/Unref.java                    8233437 generic-all\n+\n@@ -702,0 +700,1 @@\n+com\/sun\/jdi\/JdbLastErrorTest.java                               8305913 windows-x64\n@@ -744,0 +743,2 @@\n+jdk\/incubator\/vector\/ShortMaxVectorTests.java                   8306592 generic-i586\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+    java\/util\/SequencedCollection \\\n@@ -282,1 +283,2 @@\n-    com\/sun\/management\/HotSpotDiagnosticMXBean\/ \\\n+    com\/sun\/management\/HotSpotDiagnosticMXBean \\\n+    com\/sun\/management\/ThreadMXBean \\\n@@ -610,2 +612,1 @@\n-    :jdk_core_manual_no_input_security \\\n-    :jdk_core_manual_requires_human_input\n+    :jdk_core_manual_no_input_security\n@@ -617,2 +618,1 @@\n-    java\/nio\/MappedByteBuffer\/PmemTest.java \\\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalRegistryTest.java \\\n+    java\/util\/zip\/ZipFile\/TestTooManyEntries.java \\\n@@ -625,0 +625,1 @@\n+    jdk\/nio\/zipfs\/LargeCompressedEntrySizeTest.java \\\n@@ -626,1 +627,3 @@\n-    java\/util\/Vector\/Bug8148174.java\n+    java\/util\/Vector\/Bug8148174.java \\\n+    com\/sun\/net\/httpserver\/simpleserver\/CommandLinePortNotSpecifiedTest.java \\\n+    com\/sun\/net\/httpserver\/simpleserver\/jwebserver\/CommandLinePortNotSpecifiedTest.java\n@@ -630,0 +633,2 @@\n+    com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementByte4.java \\\n+    com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementDirect4.java \\\n@@ -647,2 +652,1 @@\n-    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java \\\n-    java\/security\/Policy\/Root\/Root.java\n+    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java\n@@ -650,1 +654,1 @@\n-jdk_core_manual_requires_human_input = \\\n+jdk_core_manual_interactive = \\\n@@ -653,1 +657,6 @@\n-    sun\/security\/tools\/keytool\/i18n.java\n+    sun\/security\/tools\/keytool\/i18n.java \\\n+    java\/nio\/MappedByteBuffer\/PmemTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalRegistryTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java \\\n+    java\/security\/Policy\/Root\/Root.java \\\n+    sun\/security\/krb5\/config\/native\/TestDynamicStore.java\n","filename":"test\/jdk\/TEST.groups","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+compiler.misc.bad.utf8.byte.sequence.at                 # bad class file\n@@ -120,0 +121,1 @@\n+compiler.warn.invalid.utf8.in.classfile                 # bad class file\n@@ -122,0 +124,1 @@\n+compiler.warn.output.file.clash                         # this warning is not generated on Linux\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-CastNoNullCheckTest.java:11:9: compiler.err.cant.access: Point, (compiler.misc.bad.class.file.header: Point.class, (compiler.misc.bad.class.signature: QPoint;LPo))\n+CastNoNullCheckTest.java:11:9: compiler.err.cant.access: Point, (compiler.misc.bad.class.file.header: Point.class, (compiler.misc.bad.class.signature: \"QPoint;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNoNullCheckTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: QValueWith))\n+CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: \"QValueWithInvalidFlags;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,0 +168,12 @@\n+  private native int getIndyInfoLength0(Class<?> aClass);\n+  public         int getIndyInfoLength(Class<?> aClass) {\n+    Objects.requireNonNull(aClass);\n+    return getIndyInfoLength0(aClass);\n+  }\n+\n+  private native int getIndyCPIndex0(Class<?> aClass, int index);\n+  public         int getIndyCPIndex(Class<?> aClass, int index) {\n+    Objects.requireNonNull(aClass);\n+    return getIndyCPIndex0(aClass, index);\n+  }\n+\n@@ -693,1 +705,0 @@\n-  public native boolean isShared(Object o);\n@@ -701,1 +712,0 @@\n-  public native Object  getResolvedReferences(Class<?> c);\n@@ -755,0 +765,2 @@\n+\n+  public native boolean setVirtualThreadsNotifyJvmtiMode(boolean enabled);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}