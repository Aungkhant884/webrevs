{"files":[{"patch":"@@ -1909,0 +1909,12 @@\n+        \/** if this type variable is universal then it could also have a link to a pure reference\n+         *  type variable, it is important to know that a universal type variable and its\n+         *  corresponding referenceTypeVar share the same tsym. So if it is needed to double check if\n+         *  a type variable is universal or not, we need to check its type not the type of its tsym\n+         *\/\n+        public TypeVar projection = null;\n+\n+        protected boolean isReferenceProjection = false;\n+\n+        \/\/ redundant for now but helpful for debug reasons\n+        private boolean isUniversal;\n+\n@@ -1910,0 +1922,4 @@\n+            this(name, owner, lower, false);\n+        }\n+\n+        public TypeVar(Name name, Symbol owner, Type lower, boolean isUniversal) {\n@@ -1912,1 +1928,1 @@\n-            tsym = new TypeVariableSymbol(0, name, this, owner);\n+            tsym = new TypeVariableSymbol(isUniversal ? UNIVERSAL : 0, name, this, owner);\n@@ -1915,0 +1931,4 @@\n+            this.isUniversal = isUniversal;\n+            if (isUniversal && !isReferenceProjection) {\n+                referenceProjection();\n+            }\n@@ -1923,0 +1943,5 @@\n+            this(tsym, bound, lower, metadata, false);\n+        }\n+\n+        public TypeVar(TypeSymbol tsym, Type bound, Type lower,\n+                       TypeMetadata metadata, boolean isReferenceProjection) {\n@@ -1927,0 +1952,5 @@\n+            this.isReferenceProjection = isReferenceProjection;\n+            this.isUniversal = (tsym.flags_field & UNIVERSAL) != 0;\n+            if (isUniversal && !isReferenceProjection) {\n+                referenceProjection();\n+            }\n@@ -1931,1 +1961,1 @@\n-            return new TypeVar(tsym, getUpperBound(), lower, md) {\n+            return new TypeVar(tsym, getUpperBound(), lower, md, isReferenceProjection) {\n@@ -1955,1 +1985,5 @@\n-        public void setUpperBound(Type bound) { this._bound = bound; }\n+        public void setUpperBound(Type bound) {\n+            this._bound = bound;\n+            if (projection != null)\n+                projection.setUpperBound(bound);\n+        }\n@@ -1987,0 +2021,20 @@\n+\n+        @Override\n+        public TypeVar referenceProjection() {\n+            if (projection == null) {\n+                projection = new TypeVar(tsym, _bound, lower, metadata, true);\n+            }\n+            return projection;\n+        }\n+\n+        public boolean isUniversal() {\n+            return ((tsym.flags_field & UNIVERSAL) != 0);\n+        }\n+\n+        public boolean isReferenceProjection() {\n+            return isReferenceProjection;\n+        }\n+\n+        public boolean isValueProjection() {\n+            return isUniversal() && !isReferenceProjection();\n+        }\n@@ -2006,0 +2060,1 @@\n+            this.isReferenceProjection = wildcard.bound != null ? wildcard.bound.isReferenceProjection : false;\n@@ -2016,0 +2071,1 @@\n+            this.isReferenceProjection = wildcard.bound != null ? wildcard.bound.isReferenceProjection : false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"}]}