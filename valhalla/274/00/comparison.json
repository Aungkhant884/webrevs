{"files":[{"patch":"@@ -3895,1 +3895,1 @@\n-    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -3898,1 +3898,1 @@\n-      __ tstw(tmp, JVM_ACC_IS_BOX_CLASS);\n+      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -81,1 +81,1 @@\n-    tstw(hdr, JVM_ACC_IS_BOX_CLASS);\n+    tstw(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -747,1 +747,1 @@\n-      tstw(tmp, JVM_ACC_IS_BOX_CLASS);\n+      tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -210,1 +210,1 @@\n-    tst(tmp1, JVM_ACC_IS_BOX_CLASS);\n+    tst(tmp1, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -96,1 +96,1 @@\n-    tst(Rscratch, JVM_ACC_IS_BOX_CLASS);\n+    tst(Rscratch, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -886,1 +886,1 @@\n-    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -889,1 +889,1 @@\n-      tst(R0, JVM_ACC_IS_BOX_CLASS);\n+      tst(R0, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -111,1 +111,1 @@\n-    testbitdi(CCR0, R0, Rscratch, exact_log2(JVM_ACC_IS_BOX_CLASS));\n+    testbitdi(CCR0, R0, Rscratch, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -912,1 +912,1 @@\n-    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -915,1 +915,1 @@\n-      testbitdi(CCR0, R0, tmp, exact_log2(JVM_ACC_IS_BOX_CLASS));\n+      testbitdi(CCR0, R0, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2821,1 +2821,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -2824,1 +2824,1 @@\n-    testbitdi(flag, R0, temp, exact_log2(JVM_ACC_IS_BOX_CLASS));\n+    testbitdi(flag, R0, temp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -96,1 +96,1 @@\n-    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_BOX_CLASS));\n+    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1002,1 +1002,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -1004,1 +1004,1 @@\n-    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_BOX_CLASS));\n+    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3329,1 +3329,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -3332,2 +3332,2 @@\n-    assert((JVM_ACC_IS_BOX_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(Z_R1_scratch, JVM_ACC_IS_BOX_CLASS >> 16);\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(Z_R1_scratch, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -60,1 +60,1 @@\n-    testl(hdr, JVM_ACC_IS_BOX_CLASS);\n+    testl(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -491,1 +491,1 @@\n-    testl(tmpReg, JVM_ACC_IS_BOX_CLASS);\n+    testl(tmpReg, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1222,1 +1222,1 @@\n-    if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n+    if (DiagnoseSyncOnValueBasedClasses != 0) {\n@@ -1225,1 +1225,1 @@\n-      testl(tmp_reg, JVM_ACC_IS_BOX_CLASS);\n+      testl(tmp_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1093,0 +1093,1 @@\n+    _jdk_internal_ValueBased,\n@@ -2144,0 +2145,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_ValueBased_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in priviledged code\n+      return _jdk_internal_ValueBased;\n+    }\n@@ -2185,1 +2191,10 @@\n-  ik->set_is_contended(is_contended());\n+  if (has_annotation(_jdk_internal_vm_annotation_Contended)) {\n+    ik->set_is_contended(is_contended());\n+  }\n+  if (has_annotation(_jdk_internal_ValueBased)) {\n+    ik->set_has_value_based_class_annotation();\n+    if (DiagnoseSyncOnValueBasedClasses) {\n+      ik->set_is_value_based();\n+      ik->set_prototype_header(markWord::prototype());\n+    }\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2141,8 +2141,0 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0) {\n-    for (int i = T_BOOLEAN; i < T_LONG + 1; i++) {\n-      assert(_box_klasses[i] != NULL, \"NULL box class\");\n-      _box_klasses[i]->set_is_box();\n-      _box_klasses[i]->set_prototype_header(markWord::prototype());\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+  template(jdk_internal_ValueBased_signature,                                \"Ljdk\/internal\/ValueBased;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-  <Event name=\"SyncOnPrimitiveWrapper\" category=\"Java Virtual Machine, Diagnostics\" label=\"Primitive Wrapper Synchronization\" thread=\"true\" stackTrace=\"true\" startTime=\"false\" experimental=\"true\">\n-    <Field type=\"Class\" name=\"boxClass\" label=\"Boxing Class\" \/>\n+  <Event name=\"SyncOnValueBasedClass\" category=\"Java Virtual Machine, Diagnostics\" label=\"Value Based Class Synchronization\" thread=\"true\" stackTrace=\"true\" startTime=\"false\" experimental=\"true\">\n+    <Field type=\"Class\" name=\"valueBasedClass\" label=\"Value Based Class\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,0 @@\n-  LOG_TAG(primitivewrappers) \\\n@@ -188,0 +187,1 @@\n+  LOG_TAG(valuebasedclasses) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2597,0 +2597,6 @@\n+\n+  \/\/ Initialize @ValueBased class annotation\n+  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation()) {\n+    set_is_value_based();\n+    set_prototype_header(markWord::prototype());\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,2 @@\n-    _archived_lambda_proxy_is_available = 2\n+    _archived_lambda_proxy_is_available = 2,\n+    _has_value_based_class_annotation = 4\n@@ -332,0 +333,12 @@\n+  void set_has_value_based_class_annotation() {\n+    CDS_ONLY(_shared_class_flags |= _has_value_based_class_annotation;)\n+  }\n+  void clear_has_value_based_class_annotation() {\n+    CDS_ONLY(_shared_class_flags &= ~_has_value_based_class_annotation;)\n+  }\n+  bool has_value_based_class_annotation() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_value_based_class_annotation) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+\n@@ -635,2 +648,2 @@\n-  bool is_box() const                   { return access_flags().is_box_class(); }\n-  void set_is_box()                     { _access_flags.set_is_box_class(); }\n+  bool is_value_based()                 { return _access_flags.is_value_based_class(); }\n+  void set_is_value_based()             { _access_flags.set_is_value_based_class(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4257,3 +4257,3 @@\n-  if (FLAG_IS_CMDLINE(DiagnoseSyncOnPrimitiveWrappers)) {\n-    if (DiagnoseSyncOnPrimitiveWrappers == ObjectSynchronizer::LOG_WARNING && !log_is_enabled(Info, primitivewrappers)) {\n-      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(primitivewrappers));\n+  if (FLAG_IS_CMDLINE(DiagnoseSyncOnValueBasedClasses)) {\n+    if (DiagnoseSyncOnValueBasedClasses == ObjectSynchronizer::LOG_WARNING && !log_is_enabled(Info, valuebasedclasses)) {\n+      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(valuebasedclasses));\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -858,1 +858,1 @@\n-  product(intx, DiagnoseSyncOnPrimitiveWrappers, 0, DIAGNOSTIC,             \\\n+  product(intx, DiagnoseSyncOnValueBasedClasses, 0, DIAGNOSTIC,             \\\n@@ -860,1 +860,1 @@\n-             \"primitive wrappers. Modes: \"                                  \\\n+             \"value based classes. Modes: \"                                 \\\n@@ -864,1 +864,1 @@\n-             \"   -Xlog:primitivewrappers. If JFR is running it will \"       \\\n+             \"   -Xlog:valuebasedclasses. If JFR is running it will \"       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0 && obj->klass()->is_box()) {\n+  if (DiagnoseSyncOnValueBasedClasses != 0 && obj->klass()->is_value_based()) {\n@@ -384,2 +384,2 @@\n-\/\/ Handle notifications when synchronizing on primitive wrappers\n-void ObjectSynchronizer::handle_sync_on_primitive_wrapper(Handle obj, Thread* current) {\n+\/\/ Handle notifications when synchronizing on value based classes\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, Thread* current) {\n@@ -389,1 +389,6 @@\n-  if (last_frame.is_interpreted_frame()) {\n+  bool bcp_was_adjusted = false;\n+  \/\/ Don't decrement bcp if it points to the frame's first instruction.  This happens when\n+  \/\/ handle_sync_on_value_based_class() is called because of a synchronized method.  There\n+  \/\/ is no actual monitorenter instruction in the byte code in this case.\n+  if (last_frame.is_interpreted_frame() &&\n+      (last_frame.interpreter_frame_method()->code_base() < last_frame.interpreter_frame_bcp())) {\n@@ -392,0 +397,1 @@\n+    bcp_was_adjusted = true;\n@@ -394,1 +400,1 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers == FATAL_EXIT) {\n+  if (DiagnoseSyncOnValueBasedClasses == FATAL_EXIT) {\n@@ -405,1 +411,1 @@\n-    assert(DiagnoseSyncOnPrimitiveWrappers == LOG_WARNING, \"invalid value for DiagnoseSyncOnPrimitiveWrappers\");\n+    assert(DiagnoseSyncOnValueBasedClasses == LOG_WARNING, \"invalid value for DiagnoseSyncOnValueBasedClasses\");\n@@ -407,1 +413,1 @@\n-    Log(primitivewrappers) pwlog;\n+    Log(valuebasedclasses) vblog;\n@@ -409,1 +415,1 @@\n-    pwlog.info(\"Synchronizing on object \" INTPTR_FORMAT \" of klass %s\", p2i(obj()), obj->klass()->external_name());\n+    vblog.info(\"Synchronizing on object \" INTPTR_FORMAT \" of klass %s\", p2i(obj()), obj->klass()->external_name());\n@@ -411,1 +417,1 @@\n-      LogStream info_stream(pwlog.info());\n+      LogStream info_stream(vblog.info());\n@@ -414,1 +420,1 @@\n-      pwlog.info(\"Cannot find the last Java frame\");\n+      vblog.info(\"Cannot find the last Java frame\");\n@@ -417,1 +423,1 @@\n-    EventSyncOnPrimitiveWrapper event;\n+    EventSyncOnValueBasedClass event;\n@@ -419,1 +425,1 @@\n-      event.set_boxClass(obj->klass());\n+      event.set_valueBasedClass(obj->klass());\n@@ -424,1 +430,1 @@\n-  if (last_frame.is_interpreted_frame()) {\n+  if (bcp_was_adjusted) {\n@@ -436,2 +442,2 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0 && obj->klass()->is_box()) {\n-    handle_sync_on_primitive_wrapper(obj, THREAD);\n+  if (DiagnoseSyncOnValueBasedClasses != 0 && obj->klass()->is_value_based()) {\n+    handle_sync_on_value_based_class(obj, THREAD);\n@@ -583,2 +589,2 @@\n-  if (DiagnoseSyncOnPrimitiveWrappers != 0 && obj->klass()->is_box()) {\n-    handle_sync_on_primitive_wrapper(obj, THREAD);\n+  if (DiagnoseSyncOnValueBasedClasses != 0 && obj->klass()->is_value_based()) {\n+    handle_sync_on_value_based_class(obj, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  static void handle_sync_on_primitive_wrapper(Handle obj, Thread* current);\n+  static void handle_sync_on_value_based_class(Handle obj, Thread* current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  JVM_ACC_IS_BOX_CLASS            = 0x08000000,     \/\/ True if klass is primitive wrapper\n+  JVM_ACC_IS_VALUE_BASED_CLASS    = 0x08000000,     \/\/ True if klass is marked as a ValueBased class\n@@ -155,1 +155,1 @@\n-  bool is_box_class            () const { return (_flags & JVM_ACC_IS_BOX_CLASS           ) != 0; }\n+  bool is_value_based_class    () const { return (_flags & JVM_ACC_IS_VALUE_BASED_CLASS   ) != 0; }\n@@ -229,1 +229,1 @@\n-  void set_is_box_class()              { atomic_set_bits(JVM_ACC_IS_BOX_CLASS);            }\n+  void set_is_value_based_class()      { atomic_set_bits(JVM_ACC_IS_VALUE_BASED_CLASS);    }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    <event name=\"jdk.SyncOnPrimitiveWrapper\">\n+    <event name=\"jdk.SyncOnValueBasedClass\">\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    <event name=\"jdk.SyncOnPrimitiveWrapper\">\n+    <event name=\"jdk.SyncOnValueBasedClass\">\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @summary Exercise DiagnoseSyncOnPrimitiveWrappers diagnostic flag\n+ * @summary Exercise DiagnoseSyncOnValueBasedClasses diagnostic flag\n@@ -34,1 +34,1 @@\n- * @run driver\/timeout=180000 SyncOnPrimitiveWrapperTest\n+ * @run driver\/timeout=180000 SyncOnValueBasedClassTest\n@@ -37,1 +37,1 @@\n-public class SyncOnPrimitiveWrapperTest {\n+public class SyncOnValueBasedClassTest {\n@@ -67,1 +67,1 @@\n-        String[] commonFatalTestsFlags = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-CreateCoredumpOnCrash\", \"-XX:DiagnoseSyncOnPrimitiveWrappers=1\"};\n+        String[] commonFatalTestsFlags = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-CreateCoredumpOnCrash\", \"-XX:DiagnoseSyncOnValueBasedClasses=1\"};\n@@ -72,1 +72,1 @@\n-                fatalTests[index] = Stream.of(commonFatalTestsFlags, specificFlags[i], new String[] {\"SyncOnPrimitiveWrapperTest$FatalTest\", Integer.toString(j)})\n+                fatalTests[index] = Stream.of(commonFatalTestsFlags, specificFlags[i], new String[] {\"SyncOnValueBasedClassTest$FatalTest\", Integer.toString(j)})\n@@ -77,1 +77,1 @@\n-        String[] commonLogTestsFlags = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:DiagnoseSyncOnPrimitiveWrappers=2\"};\n+        String[] commonLogTestsFlags = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:DiagnoseSyncOnValueBasedClasses=2\"};\n@@ -80,1 +80,1 @@\n-            logTests[i] = Stream.of(commonLogTestsFlags, specificFlags[i], new String[] {\"SyncOnPrimitiveWrapperTest$LogTest\"})\n+            logTests[i] = Stream.of(commonLogTestsFlags, specificFlags[i], new String[] {\"SyncOnValueBasedClassTest$LogTest\"})\n@@ -92,1 +92,1 @@\n-            output.shouldNotContain(\"synchronization on primitive wrapper did not fail\");\n+            output.shouldNotContain(\"synchronization on value based class did not fail\");\n@@ -130,1 +130,1 @@\n-                throw new RuntimeException(\"synchronization on primitive wrapper did not fail\");\n+                throw new RuntimeException(\"synchronization on value based class did not fail\");\n@@ -167,1 +167,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnValueBasedClassTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnPrimitiveWrapperTest.java","status":"renamed"},{"patch":"@@ -85,1 +85,1 @@\n-            \"Flush\", \"SyncOnPrimitiveWrapper\")\n+            \"Flush\", \"SyncOnValueBasedClass\")\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestLookForUntestedEvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.runtime;\n-\n-import java.time.Duration;\n-import java.util.*;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.jfr.consumer.RecordedThread;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-\n-\/**\n- * @test\n- * @bug 8242263\n- * @requires vm.hasJFR\n- * @key jfr\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnPrimitiveWrappers=2 jdk.jfr.event.runtime.TestSyncOnPrimitiveWrapperEvent\n- *\/\n-public class TestSyncOnPrimitiveWrapperEvent {\n-    static final String EVENT_NAME = EventNames.SyncOnPrimitiveWrapper;\n-    static String[] classesWanted = {\"java\/lang\/Character\", \"java\/lang\/Boolean\", \"java\/lang\/Byte\", \"java\/lang\/Short\",\n-                                     \"java\/lang\/Integer\", \"java\/lang\/Long\", \"java\/lang\/Float\", \"java\/lang\/Double\"};\n-    static List<Object> testObjects = new ArrayList<Object>();\n-    static Integer counter = 0;\n-\n-    private static void initTestObjects() {\n-        testObjects.add(Character.valueOf('H'));\n-        testObjects.add(Boolean.valueOf(true));\n-        testObjects.add(Byte.valueOf((byte)0x40));\n-        testObjects.add(Short.valueOf((short)0x4000));\n-        testObjects.add(Integer.valueOf(0x40000000));\n-        testObjects.add(Long.valueOf(0x4000000000000000L));\n-        testObjects.add(Float.valueOf(1.20f));\n-        testObjects.add(Double.valueOf(1.2345));\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        initTestObjects();\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n-        recording.start();\n-        for (Object obj : testObjects) {\n-            synchronized (obj) {\n-                counter++;\n-            }\n-        }\n-        recording.stop();\n-\n-        List<String> classesFound = new ArrayList<String>();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-        Events.hasEvents(events);\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            String className = Events.assertField(event, \"boxClass.name\").notEmpty().getValue();\n-            RecordedThread jt = event.getThread();\n-            if (Thread.currentThread().getName().equals(jt.getJavaName())) {\n-                classesFound.add(className);\n-            }\n-        }\n-        for (String classWanted : classesWanted) {\n-            if (!classesFound.contains(classWanted)) {\n-                throw new AssertionError(\"No matching event SyncOnPrimitiveWrapper with \\\"boxClass=\" + classWanted + \"\\\" and current thread as caller\");\n-            }\n-        }\n-        if (classesFound.size() != classesWanted.length) {\n-            throw new AssertionError(\"Invalid number of SyncOnPrimitiveWrapper events for current thread\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestSyncOnPrimitiveWrapperEvent.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.time.Duration;\n+import java.util.*;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @bug 8242263\n+ * @requires vm.hasJFR\n+ * @key jfr\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=2 jdk.jfr.event.runtime.TestSyncOnValueBasedClassEvent\n+ *\/\n+public class TestSyncOnValueBasedClassEvent {\n+    static final String EVENT_NAME = EventNames.SyncOnValueBasedClass;\n+    static String[] classesWanted = {\"java\/lang\/Character\", \"java\/lang\/Boolean\", \"java\/lang\/Byte\", \"java\/lang\/Short\",\n+                                     \"java\/lang\/Integer\", \"java\/lang\/Long\", \"java\/lang\/Float\", \"java\/lang\/Double\"};\n+    static List<Object> testObjects = new ArrayList<Object>();\n+    static Integer counter = 0;\n+\n+    private static void initTestObjects() {\n+        testObjects.add(Character.valueOf('H'));\n+        testObjects.add(Boolean.valueOf(true));\n+        testObjects.add(Byte.valueOf((byte)0x40));\n+        testObjects.add(Short.valueOf((short)0x4000));\n+        testObjects.add(Integer.valueOf(0x40000000));\n+        testObjects.add(Long.valueOf(0x4000000000000000L));\n+        testObjects.add(Float.valueOf(1.20f));\n+        testObjects.add(Double.valueOf(1.2345));\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        initTestObjects();\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n+        recording.start();\n+        for (Object obj : testObjects) {\n+            synchronized (obj) {\n+                counter++;\n+            }\n+        }\n+        recording.stop();\n+\n+        List<String> classesFound = new ArrayList<String>();\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        Events.hasEvents(events);\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            String className = Events.assertField(event, \"valueBasedClass.name\").notEmpty().getValue();\n+            RecordedThread jt = event.getThread();\n+            if (Thread.currentThread().getName().equals(jt.getJavaName())) {\n+                classesFound.add(className);\n+            }\n+        }\n+        for (String classWanted : classesWanted) {\n+            if (!classesFound.contains(classWanted)) {\n+                throw new AssertionError(\"No matching event SyncOnValueBasedClass with \\\"valueBasedClass=\" + classWanted + \"\\\" and current thread as caller\");\n+            }\n+        }\n+        if (classesFound.size() != classesWanted.length) {\n+            throw new AssertionError(\"Invalid number of SyncOnValueBasedClass events for current thread\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestSyncOnValueBasedClassEvent.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-    public final static String SyncOnPrimitiveWrapper = PREFIX + \"SyncOnPrimitiveWrapper\";\n+    public final static String SyncOnValueBasedClass = PREFIX + \"SyncOnValueBasedClass\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}