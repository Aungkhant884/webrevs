{"files":[{"patch":"@@ -96,1 +96,2 @@\n-  \/\/ not recursively account for flattened fields of empty inline types.\n+  \/\/ consider the container empty even if fields of empty inline types\n+  \/\/ are not flattened\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5612,3 +5612,0 @@\n-  if (_is_empty_inline_type) {\n-    ik->set_is_empty_inline_type();\n-  }\n@@ -5789,0 +5786,1 @@\n+  bool all_fields_empty = true;\n@@ -5792,8 +5790,9 @@\n-    if (ik->field_is_inline_type(i) && ((ik->field_access_flags(i) & JVM_ACC_STATIC) == 0)) {\n-      Symbol* klass_name = ik->field_signature(i)->fundamental_name(CHECK);\n-      \/\/ Inline classes for instance fields must have been pre-loaded\n-      \/\/ Inline classes for static fields might not have been loaded yet\n-      Klass* klass = SystemDictionary::find(klass_name,\n-          Handle(THREAD, ik->class_loader()),\n-          Handle(THREAD, ik->protection_domain()), CHECK);\n-      if (klass != NULL) {\n+    if (((ik->field_access_flags(i) & JVM_ACC_STATIC) == 0)) {\n+      if (ik->field_is_inline_type(i)) {\n+        Symbol* klass_name = ik->field_signature(i)->fundamental_name(CHECK);\n+        \/\/ Inline classes for instance fields must have been pre-loaded\n+        \/\/ Inline classes for static fields might not have been loaded yet\n+        Klass* klass = SystemDictionary::find(klass_name,\n+            Handle(THREAD, ik->class_loader()),\n+            Handle(THREAD, ik->protection_domain()), CHECK);\n+        assert(klass != NULL, \"Just checking\");\n@@ -5802,0 +5801,4 @@\n+        klass_name->decrement_refcount();\n+        if (!InlineKlass::cast(klass)->is_empty_inline_type()) { all_fields_empty = false; }\n+      } else {\n+        all_fields_empty = false;\n@@ -5803,4 +5806,1 @@\n-      klass_name->decrement_refcount();\n-    } else\n-      if (is_inline_type() && ((ik->field_access_flags(i) & JVM_ACC_FIELD_INTERNAL) != 0)\n-        && ((ik->field_access_flags(i) & JVM_ACC_STATIC) != 0)) {\n+    } else if (is_inline_type() && ((ik->field_access_flags(i) & JVM_ACC_FIELD_INTERNAL) != 0)) {\n@@ -5811,0 +5811,4 @@\n+  if (_is_empty_inline_type || (is_inline_type() && all_fields_empty)) {\n+    ik->set_is_empty_inline_type();\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-    _misc_is_empty_inline_type                = 1 << 17, \/\/ empty inline type\n+    _misc_is_empty_inline_type                = 1 << 17, \/\/ empty inline type (*)\n@@ -298,0 +298,6 @@\n+\n+  \/\/ (*) An inline type is considered empty if it contains no non-static fields or\n+  \/\/ if it contains only empty inline fields. Note that JITs have a slightly different\n+  \/\/ definition: empty inline fields must be flattened otherwise the container won't\n+  \/\/ be considered empty\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}