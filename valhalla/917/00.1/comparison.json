{"files":[{"patch":"@@ -755,0 +755,12 @@\n+    \/**\n+     * Returns a {@code Class} object representing the null restricted type\n+     * of this class or interface.\n+     *\n+     * @return the {@code Class} representing the null restricted type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    public Class<?> asNullRestrictedType() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -65,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -170,1 +170,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -191,1 +191,1 @@\n-    boolean allowPrimitiveClasses;\n+    boolean allowValueClasses;\n@@ -735,0 +735,4 @@\n+        if (tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -808,1 +812,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env)));\n@@ -810,1 +814,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env)));\n@@ -1171,0 +1175,8 @@\n+            if (tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1336,0 +1348,11 @@\n+            Type elemOrType = result;\n+            while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                elemOrType = types.elemtype(elemOrType);\n+            }\n+            if ((result.isNonNullable() || elemOrType.isNonNullable()) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor())) {\n+                log.error(tree.pos(),\n+                        types.elemtype(result) == null?\n+                                Errors.TypeCantBeNullRestricted(result) :\n+                                Errors.TypeCantBeNullRestricted2(result)\n+                );\n+            }\n@@ -1566,1 +1589,1 @@\n-                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n@@ -1582,1 +1605,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n@@ -2012,1 +2035,1 @@\n-            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n@@ -2201,2 +2224,1 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n-            \/\/ value conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive\n@@ -2204,2 +2226,1 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n-                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n@@ -2216,1 +2237,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n@@ -2219,1 +2240,1 @@\n-            \/\/ both are known to be reference types (or projections).  The result is\n+            \/\/ both are known to be reference types.  The result is\n@@ -2659,2 +2680,1 @@\n-                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n-                                         qualifierType.referenceProjection() : qualifierType.baseType());\n+                Type wcb = types.erasure(qualifierType.baseType());\n@@ -2666,2 +2686,1 @@\n-                        restype.getMetadata(),\n-                        restype.getFlavor());\n+                        restype.getMetadata());\n@@ -2836,10 +2855,0 @@\n-            \/\/ Check that it is an instantiation of a class and not a projection type\n-            if (allowPrimitiveClasses) {\n-                if (clazz.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n-                    }\n-                }\n-            }\n@@ -2870,2 +2879,1 @@\n-                                               clazztype.getMetadata(),\n-                                               clazztype.getFlavor());\n+                                               clazztype.getMetadata());\n@@ -2932,1 +2940,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2934,0 +2942,4 @@\n+                if (owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3025,3 +3037,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n-                    }\n@@ -3100,3 +3109,0 @@\n-        \/\/ Likewise arg can't be null if it is a primitive class instance.\n-        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n-            return arg;\n@@ -4440,9 +4446,0 @@\n-        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n-            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-             * always matching the behavior of Object::getClass\n-             *\/\n-             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n-                 tree.selected.setType(site = site.referenceProjection());\n-             }\n-        }\n@@ -4452,0 +4449,9 @@\n+        \/\/ check nullness of site\n+        if (site.isNullable()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (site.isParametric()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4565,1 +4571,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n@@ -4608,2 +4614,0 @@\n-                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n-                    return site.tsym;\n@@ -4716,3 +4720,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n-                    }\n@@ -4722,8 +4723,1 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference projection\n-                    \/\/ is requested via the .ref notation, then adjust the computed type to\n-                    \/\/ reflect this.\n-                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n-                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                    }\n-\n-                    \/\/ (b) If the symbol's type is parameterized, erase it\n+                    \/\/ If the symbol's type is parameterized, erase it\n@@ -4756,1 +4750,1 @@\n-                                owntype.getMetadata(), owntype.getFlavor());\n+                                owntype.getMetadata());\n@@ -4787,0 +4781,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5074,1 +5073,1 @@\n-        if (!allowPrimitiveClasses) {\n+        if (!allowValueClasses) {\n@@ -5076,1 +5075,1 @@\n-                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n+                    Feature.VALUE_CLASSES.error(sourceName));\n@@ -5083,1 +5082,1 @@\n-        if (!allowPrimitiveClasses) {\n+        if (!allowValueClasses) {\n@@ -5191,1 +5190,1 @@\n-                                        clazztype.getMetadata(), clazztype.getFlavor());\n+                                        clazztype.getMetadata());\n@@ -5318,1 +5317,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n+                make.Modifiers(PUBLIC | ABSTRACT),\n@@ -5341,1 +5340,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n@@ -5459,1 +5458,1 @@\n-            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n+            if (c.type.isValueClass()) {\n@@ -5461,1 +5460,1 @@\n-                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n+                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n@@ -5641,1 +5640,1 @@\n-                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":69,"deletions":70,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -40,0 +39,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -82,1 +82,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -85,2 +84,0 @@\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n@@ -187,1 +184,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -231,1 +228,1 @@\n-    \/** Are primitive classes allowed\n+    \/** Are value classes allowed\n@@ -233,2 +230,1 @@\n-    private final boolean allowPrimitiveClasses;\n-\n+    private final boolean allowValueClasses;\n@@ -300,0 +296,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n+        if (lint.isEnabled(LintCategory.NULL)) {\n+            log.warning(LintCategory.NULL, pos, warnKey);\n+        }\n+    }\n+\n@@ -637,5 +643,0 @@\n-        } else {\n-            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n-            }\n@@ -686,3 +687,6 @@\n-                if (lint.isEnabled(LintCategory.CAST))\n-                    log.warning(LintCategory.CAST,\n-                            tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                if (lint.isEnabled(LintCategory.CAST)) {\n+                    if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+                        log.warning(LintCategory.CAST,\n+                                tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                    }\n+                }\n@@ -715,1 +719,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -720,1 +724,11 @@\n-             return types.isSubtype(a, bound);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -772,1 +786,3 @@\n-    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+    void checkConstraintsOfValueClass(JCClassDecl tree, ClassSymbol c) {\n+        DiagnosticPosition pos = tree.pos();\n+        checkConstraintsOfValueClassesWithImplicitConst(tree, c);\n@@ -823,0 +839,22 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+        if (implicitConstructor != null) {\n+            Type encl = c.type.getEnclosingType();\n+            if (encl != null && encl.hasTag(CLASS)) {\n+                log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+            }\n+            if ((c.flags() & HASINITBLOCK) != 0) {\n+                log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+            }\n+            for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case VAR:\n+                        if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                            log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                        }\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -835,9 +873,0 @@\n-                \/\/ Projection types may not be mentioned in constructor references\n-                if (expr.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n-                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n-                        t = types.createErrorType(t);\n-                    }\n-                }\n@@ -879,3 +908,2 @@\n-     *  @param primitiveClassOK       If false, a primitive class does not qualify\n-    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n-        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        if (t.isReference())\n@@ -890,3 +918,3 @@\n-    \/** Check that type is an identity type, i.e. not a primitive\/value type\n-     *  nor its reference projection. When not discernible statically,\n-     *  give it the benefit of doubt and defer to runtime.\n+    \/** Check that type is an identity type, i.e. not a value type.\n+     *  When not discernible statically, give it the benefit of doubt\n+     *  and defer to runtime.\n@@ -908,1 +936,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface())\n@@ -912,9 +940,0 @@\n-    \/** Check that type is a reference type, i.e. a class, interface or array type\n-     *  or a type variable.\n-     *  @param pos           Position to be used for error reporting.\n-     *  @param t             The type to be checked.\n-     *\/\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        return checkRefType(pos, t, true);\n-    }\n-\n@@ -929,1 +948,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, false);\n+            l.head = checkRefType(tl.head.pos(), l.head);\n@@ -965,49 +984,0 @@\n-    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n-    }\n-\n-    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n-     *  being used as type arguments and issues error against those usages.\n-     *\/\n-    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n-            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n-\n-        @Override\n-        public Void visitType(Type t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n-            for (Type targ : t.allparams()) {\n-                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n-                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n-                }\n-                visit(targ, pos);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n-             return null;\n-        }\n-\n-        @Override\n-        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n-            return visit(t.elemtype, pos);\n-        }\n-\n-        @Override\n-        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n-            return visit(t.type, pos);\n-        }\n-    };\n-\n-\n-\n@@ -1162,5 +1132,1 @@\n-        Type varType = types.upward(t, types.captures(t)).baseType();\n-        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n-            checkParameterizationByPrimitiveClass(pos, varType);\n-        }\n-        return varType;\n+        return types.upward(t, types.captures(t)).baseType();\n@@ -1189,1 +1155,0 @@\n-        \/\/ TODO - is enum so <init>\n@@ -1257,1 +1222,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1260,1 +1229,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1297,1 +1266,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1380,1 +1349,9 @@\n-                } else\n+                } else if ((flags & IMPLICIT) != 0) {\n+                    if ((flags & PUBLIC) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBePublic);\n+                    }\n+                    if ((sym.owner.flags_field & VALUE_CLASS) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBeDeclaredInValueClass);\n+                    }\n+                    mask = ImplicitConstructorFlags;\n+                } else {\n@@ -1382,0 +1359,1 @@\n+                }\n@@ -1438,2 +1416,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE_CLASS);\n@@ -1453,4 +1431,0 @@\n-            \/\/ primitive classes are implicitly final value classes.\n-            if ((flags & PRIMITIVE_CLASS) != 0)\n-                implicit |= VALUE_CLASS | FINAL;\n-\n@@ -1497,1 +1471,1 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED)\n@@ -1501,1 +1475,1 @@\n-                        PRIMITIVE_CLASS | VALUE_CLASS)\n+                        VALUE_CLASS)\n@@ -1647,1 +1621,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1706,2 +1680,1 @@\n-                tree.selected.type.isParameterized() &&\n-                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n+                tree.selected.type.isParameterized()) {\n@@ -1711,2 +1684,0 @@\n-                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -2057,0 +2028,9 @@\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+        }\n+        overrideWarner.remove(LintCategory.NULL);\n+        \/\/ at this point we know this will be true but to gather the warnings\n+        types.isSubSignature(mt, ot, overrideWarner);\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+        }\n@@ -2534,0 +2514,1 @@\n+    \/\/ TODO, update this method once we have null restricted types\n@@ -2535,10 +2516,11 @@\n-        if (allowPrimitiveClasses) {\n-            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n-            try {\n-                tree.sym.flags_field |= LOCKED;\n-                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (l.head.hasTag(VARDEF)) {\n-                        JCVariableDecl field = (JCVariableDecl) l.head;\n-                        if (cyclePossible(field.sym)) {\n-                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n-                        }\n+        if (!tree.sym.type.hasImplicitConstructor()) {\n+            return;\n+        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n@@ -2547,2 +2529,2 @@\n-            } finally {\n-                tree.sym.flags_field &= ~LOCKED;\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n@@ -2569,1 +2551,1 @@\n-            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n@@ -2821,0 +2803,6 @@\n+        boolean implementsNonAtomic = false;\n+        try {\n+            implementsNonAtomic = allowValueClasses ? types.asSuper(c, syms.nonAtomicType.tsym) != null : false;\n+        } catch (CompletionFailure cf) {\n+            \/\/ ignore\n+        }\n@@ -2823,0 +2811,5 @@\n+        if (c.getKind() == TypeKind.DECLARED && implementsNonAtomic && !c.tsym.isAbstract()) {\n+            if (!cIsValue || ((ClassSymbol)c.tsym).getImplicitConstructor() == null) {\n+                log.error(pos, Errors.CantImplementNonAtomic(c.tsym));\n+            }\n+        }\n@@ -4461,0 +4454,20 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            boolean warned = this.warned;\n+            super.warn(lint);\n+            if (warned) return; \/\/ suppress redundant diagnostics\n+            switch (lint) {\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected lint: \" + lint);\n+            }\n+        }\n+    }\n+\n@@ -4489,0 +4502,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4492,0 +4508,21 @@\n+            this.warned = true;\n+        }\n+    }\n+\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (expected.isParametric()) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                }\n+            }\n@@ -4496,1 +4533,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":168,"deletions":131,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -1601,1 +1601,1 @@\n-                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n@@ -2151,1 +2151,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedNonNullableOrParametricField(sym));\n@@ -2164,0 +2165,7 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (sym.type.isNonNullable() || sym.type.isParametric()));\n+        }\n+\n@@ -2274,0 +2282,9 @@\n+                if (isUninitializedNonNullableOrParametricField(sym)) {\n+                    if (lint.isEnabled(Lint.LintCategory.NULL)) {\n+                        if (sym.type.isNonNullable()) {\n+                            log.warning(pos, Warnings.NonNullableShouldBeInitialized);\n+                        } else {\n+                            log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                        }\n+                    }\n+                } else {\n@@ -2275,0 +2292,1 @@\n+                }\n@@ -2534,1 +2552,1 @@\n-                                } else {\n+                                } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -71,0 +72,1 @@\n+import java.util.function.BiFunction;\n@@ -198,1 +200,0 @@\n-        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n@@ -223,1 +224,0 @@\n-        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n@@ -262,4 +262,0 @@\n-    \/** Switch: are primitive classes allowed in this source level?\n-     *\/\n-     boolean allowPrimitiveClasses;\n-\n@@ -284,0 +280,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -291,0 +288,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -309,1 +307,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -313,1 +311,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -724,0 +722,4 @@\n+        if (EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -1160,1 +1162,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1341,0 +1354,1 @@\n+        boolean emotionalMarkersOK = false;\n@@ -1490,0 +1504,6 @@\n+                if (EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    emotionalMarkersOK = true;\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1509,0 +1529,4 @@\n+                            if (EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                setNullMarker(t);\n+                                nextToken();\n+                            }\n@@ -1649,0 +1673,10 @@\n+            if (EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n+                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                } else {\n+                    \/\/ not a type\n+                    break;\n+                }\n+            }\n@@ -1765,1 +1799,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1774,0 +1813,4 @@\n+                        if (isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1858,0 +1901,13 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        ((JCNullableTypeExpression)exp).setNullMarker(\n+                tk.kind == QUES ?\n+                        NullMarker.NULLABLE :\n+                        token.kind == BANG ?\n+                                NullMarker.NOT_NULL :\n+                                NullMarker.PARAMETRIC);\n+    }\n+\n@@ -1923,1 +1979,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -1991,0 +2047,15 @@\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW)) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2013,0 +2084,1 @@\n+                            peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN) ||\n@@ -2015,0 +2087,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -2017,0 +2090,6 @@\n+                    } else if (peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2035,0 +2114,1 @@\n+                                peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN) ||\n@@ -2094,0 +2174,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2433,0 +2517,6 @@\n+        } else if (EMOTIONAL_QUALIFIER.test(token.kind) && peekToken(LBRACKET)) {\n+            Token nullMarker = token;\n+            nextToken();\n+            int pos = token.pos;\n+            nextToken();\n+            t = bracketsOptCont(t, pos, nextLevelAnnotations, nullMarker);\n@@ -2455,0 +2545,5 @@\n+        return bracketsOptCont(t, pos, annotations, null);\n+    }\n+\n+    private JCExpression bracketsOptCont(JCExpression t, int pos,\n+                                         List<JCAnnotation> annotations, Token nullMarker) {\n@@ -2458,0 +2553,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -2615,1 +2713,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n@@ -2972,1 +3070,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3379,0 +3477,12 @@\n+                    } else if (typeDepth == 0 &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3393,0 +3503,2 @@\n+                case BANG:\n+                    if (!peekToken(lookahead, LPAREN)) break;\n@@ -3567,4 +3679,0 @@\n-                if (isPrimitiveModifier()) {\n-                    flag = Flags.PRIMITIVE_CLASS;\n-                    break;\n-                }\n@@ -3579,0 +3687,4 @@\n+                if (isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3845,5 +3957,0 @@\n-        if (name == names.primitive) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            }\n-        }\n@@ -3858,1 +3965,6 @@\n-            if (allowPrimitiveClasses) {\n+            if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n+        if (name == names.implicit) {\n+            if (allowValueClasses) {\n@@ -4930,26 +5042,0 @@\n-    protected boolean isPrimitiveModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n-            boolean isPrimitiveModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isPrimitiveModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isPrimitiveModifier = true;\n-                    break;\n-            }\n-            if (isPrimitiveModifier) {\n-                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -4968,1 +5054,1 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || new value Comparable() {} ??\n@@ -4970,1 +5056,1 @@\n-                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                            || (mode & EXPR) != 0)\n@@ -4995,1 +5081,1 @@\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                    if (next.name() == names.record || next.name() == names.identity\n@@ -5008,0 +5094,19 @@\n+    protected boolean isImplicitModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n+            boolean isImplicitModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n+                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n+                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n+                    isImplicitModifier = true;\n+                    break;\n+            }\n+            if (isImplicitModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -5525,4 +5630,1 @@\n-        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n-            \/\/ primitive classes are special\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":158,"deletions":56,"binary":false,"changes":214,"status":"modified"}]}